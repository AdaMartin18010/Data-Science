# SQLite页面管理与Pager层形式化

> **创建日期**: 2025-12-04
> **版本**: SQLite 3.47.x
> **难度**: ⭐⭐⭐⭐⭐

---

## Pager层架构

```text
SQLite存储层次
══════════════════════════════════════════════════════════════════════════════

┌──────────────────────────────────────────┐
│         SQL Layer (VDBE)                 │
└────────────────┬─────────────────────────┘
                 │
┌────────────────▼─────────────────────────┐
│         B-Tree Layer                     │
│  • btree.c                               │
│  • 管理B-Tree结构                        │
└────────────────┬─────────────────────────┘
                 │
┌────────────────▼─────────────────────────┐
│         Pager Layer ⭐                   │
│  • pager.c                               │
│  • 页面缓存(Page Cache)                  │
│  • 事务管理                              │
│  • WAL/Rollback Journal                 │
└────────────────┬─────────────────────────┘
                 │
┌────────────────▼─────────────────────────┐
│         VFS Layer                        │
│  • os_unix.c / os_win.c                  │
│  • 操作系统抽象                          │
└────────────────┬─────────────────────────┘
                 │
         ┌───────▼────────┐
         │ Database File  │
         └────────────────┘
```

---

## 形式化定义

### 定义1.1 页面

```text
定义1.1 数据库页面
═══════════════════════════════════════════════════════════════

页面 P = (pgno, data, state, dirty)

其中:
• pgno: 页号（1-based，0为无效页）
• data: 页面数据（byte数组，长度=page_size）
• state: 页面状态 ∈ {CLEAN, DIRTY, LOCKED, JOURNALED}
• dirty: 脏标记（是否已修改）

页面大小:
  page_size ∈ {512, 1024, 2048, 4096, 8192, 16384, 32768, 65536}
  默认: 4096 bytes

页面类型:
• Lock page (pgno = 1): 数据库锁页
• Schema page (pgno = 1): 第一页，存储schema
• Free list trunk page: 空闲页链表
• Free list leaf page: 空闲页数据
• B-Tree interior page: B-Tree内部节点
• B-Tree leaf page: B-Tree叶子节点
• Payload overflow page: 溢出页
```

### 定义1.2 页面缓存

```text
定义1.2 页面缓存（Page Cache）
═══════════════════════════════════════════════════════════════

缓存 C = (pages, lru, size_limit)

其中:
• pages: Map<pgno, Page>（页号→页面）
• lru: LRU链表（最近最少使用）
• size_limit: 缓存大小上限（单位：页数）

操作:
• fetch(pgno): Page - 获取页面
• release(page) - 释放页面
• flush() - 刷新脏页到磁盘
• evict() - 驱逐LRU页面

性质1（缓存一致性）:
  ∀ pgno, fetch(pgno) 返回的页面数据 = 磁盘上的页面数据 OR 更新的版本

性质2（脏页必须写回）:
  在事务提交前，所有 dirty=true 的页面必须 flush 到磁盘
```

---

## Pager状态机

```text
Pager状态转换图
═══════════════════════════════════════════════════════════════

                  ┌─────────┐
                  │ OPEN    │◄─── sqlite3_open()
                  └────┬────┘
                       │ BEGIN
                       ▼
                  ┌─────────┐
            ┌────►│ READER  │ (共享锁)
            │     └────┬────┘
            │          │ write操作
            │          ▼
            │     ┌─────────┐
            │     │ WRITER  │ (RESERVED锁)
            │     └────┬────┘
            │          │ 继续写
            │          ▼
            │     ┌─────────┐
            │     │ WRITER_ │
            │     │ LOCKED  │ (EXCLUSIVE锁预备)
            │     └────┬────┘
            │          │ 准备提交
            │          ▼
            │     ┌─────────┐
            └─────┤ WRITER_ │
                  │ FINISHED│ (EXCLUSIVE锁)
                  └────┬────┘
                       │ COMMIT
                       ▼
                  ┌─────────┐
                  │ OPEN    │
                  └─────────┘

状态说明:
• OPEN: 无锁，可读可写
• READER: SHARED锁，可读
• WRITER: RESERVED锁，可读可写（独占写）
• WRITER_LOCKED: PENDING锁，准备提交
• WRITER_FINISHED: EXCLUSIVE锁，提交中
```

---

## 页面管理算法

### 算法1：页面获取（fetch）

```c
// SQLite源码简化版
Page* pager_fetch(Pager *pager, Pgno pgno, int flags) {
    Page *page;

    // 1. 检查缓存
    page = cache_lookup(pager->cache, pgno);
    if (page != NULL) {
        cache_hit++;
        return page;  // 缓存命中
    }

    // 2. 缓存未命中，分配新页面
    cache_miss++;
    page = (Page*)malloc(sizeof(Page) + pager->page_size);
    page->pgno = pgno;
    page->dirty = 0;

    // 3. 从磁盘读取
    if (pgno <= pager->db_size) {
        off_t offset = (pgno - 1) * pager->page_size;
        pread(pager->fd, page->data, pager->page_size, offset);
    } else {
        // 新页面，清零
        memset(page->data, 0, pager->page_size);
    }

    // 4. 加入缓存
    cache_insert(pager->cache, page);

    // 5. LRU驱逐（如果缓存满）
    if (cache_size(pager->cache) > pager->cache_limit) {
        pager_evict_lru(pager);
    }

    return page;
}
```

### 算法2：页面写入（write）

```c
int pager_write(Pager *pager, Page *page) {
    // 1. 检查写权限
    if (pager->state < WRITER) {
        // 升级到WRITER状态
        acquire_reserved_lock(pager);
        pager->state = WRITER;
    }

    // 2. 如果页面未journal，先写journal
    if (!page->in_journal && pager->journal_mode == ROLLBACK) {
        // 写入rollback journal
        off_t offset = pager->journal_offset;
        write(pager->journal_fd, &page->pgno, sizeof(Pgno));
        write(pager->journal_fd, page->data, pager->page_size);
        pager->journal_offset += sizeof(Pgno) + pager->page_size;

        page->in_journal = 1;
    }

    // 3. WAL模式：追加到WAL
    if (pager->journal_mode == WAL) {
        wal_append_frame(pager->wal, page->pgno, page->data);
    }

    // 4. 标记为脏页
    page->dirty = 1;

    return SQLITE_OK;
}
```

### 算法3：事务提交（commit）

```c
int pager_commit(Pager *pager) {
    // 1. 状态检查
    if (pager->state != WRITER) {
        return SQLITE_OK;  // 无修改
    }

    // 2. Rollback Journal模式
    if (pager->journal_mode == ROLLBACK) {
        // 2.1 同步journal（确保持久化）
        fsync(pager->journal_fd);

        // 2.2 获取EXCLUSIVE锁
        acquire_exclusive_lock(pager);
        pager->state = WRITER_FINISHED;

        // 2.3 写入所有脏页到数据库文件
        for (Page *page : pager->dirty_pages) {
            off_t offset = (page->pgno - 1) * pager->page_size;
            pwrite(pager->fd, page->data, pager->page_size, offset);
        }

        // 2.4 同步数据库文件
        fsync(pager->fd);

        // 2.5 删除journal文件
        unlink(pager->journal_path);

        // 2.6 释放锁
        release_lock(pager);
        pager->state = OPEN;
    }

    // 3. WAL模式
    else if (pager->journal_mode == WAL) {
        // 3.1 WAL帧已经在write时追加
        // 3.2 写入commit record
        wal_commit(pager->wal, pager->txn_id);

        // 3.3 同步WAL
        fsync(pager->wal->fd);

        // 3.4 更新共享内存（通知其他连接）
        wal_update_shm(pager->wal, pager->txn_id);

        // 3.5 Checkpoint（如果需要）
        if (wal_size(pager->wal) > pager->wal_autocheckpoint) {
            wal_checkpoint(pager->wal, TRUNCATE);
        }
    }

    return SQLITE_OK;
}
```

---

## 形式化定理

### 定理1：崩溃恢复正确性

```text
定理1：Rollback Journal崩溃恢复正确性
═══════════════════════════════════════════════════════════════

前提:
  • Journal文件已fsync
  • 崩溃发生在commit过程中

定理: 恢复后，数据库状态 = 事务开始前的状态

证明:

设事务 T 修改了页面集合 M = {P1, P2, ..., Pn}

事务开始前:
  ∀ Pi ∈ M, disk(Pi) = before_image_i

Journal记录:
  Journal = [(pgno_1, before_image_1), (pgno_2, before_image_2), ..., (pgno_n, before_image_n)]

崩溃场景分类:

Case 1: Journal已写入，数据库文件未修改
  → 恢复: 不需要操作，数据库状态正确

Case 2: Journal已写入，数据库文件部分修改
  → 恢复: 从Journal读取before_image，覆盖数据库文件
  → ∀ Pi ∈ M, disk(Pi) := before_image_i
  → 数据库恢复到事务前状态

Case 3: Journal未完全写入（Hot Journal检测失败）
  → 恢复: 忽略Journal，数据库文件未修改
  → 数据库保持事务前状态

Case 4: 提交成功，Journal已删除
  → 恢复: 无需操作，事务已成功

结论:
  ∀ Case, 恢复后数据库状态 = 事务前状态 OR 事务后状态（原子性）

∴ 崩溃恢复正确 ∎
```

### 定理2：WAL并发读写不冲突

```text
定理2：WAL模式下读写不互斥
═══════════════════════════════════════════════════════════════

设:
• Reader: 事务T_r，开始时间t_r
• Writer: 事务T_w，开始时间t_w < t_r，提交时间t_c

定理: T_r和T_w可以并发执行，不互相阻塞

证明:

WAL读取规则:
  T_r读取页面P时，查找最大txn_id ≤ start_txn_id_r 的版本

时间线:
  t_w: T_w开始
  t_c: T_w提交（写入WAL）
  t_r: T_r开始

分析:

1. T_r读取时，T_w已提交
   → T_r的start_txn_id_r ≥ T_w的txn_id
   → T_r可以看到T_w的修改
   → 无冲突

2. T_r读取时，T_w未提交
   → T_r的start_txn_id_r < T_w的txn_id
   → T_r读取旧版本（从数据库文件或旧WAL帧）
   → T_w继续写WAL（不阻塞T_r）
   → 无冲突

3. T_w写入时，T_r正在读取
   → T_w追加到WAL（不修改T_r正在读的页面）
   → T_r继续从旧版本读取
   → 无冲突

结论:
  ∀ P ∈ Pages, read(T_r, P) 和 write(T_w, P) 不互斥

∴ WAL模式读写不冲突 ∎
```

---

## 性能优化

### 1. 页面缓存大小

```sql
-- 默认：2000页 (8MB，假设page_size=4096)
PRAGMA cache_size = -64000;  -- 64MB (负数表示KB)

-- 效果：
-- • 增加缓存 → 减少磁盘IO
-- • 缓存命中率从70% → 95%
-- • 查询性能提升2-3倍
```

### 2. 页面大小选择

```sql
-- 创建数据库时设置（之后不可更改）
PRAGMA page_size = 4096;  -- 默认
PRAGMA page_size = 8192;  -- 大页面

-- 权衡：
-- • 小页面(1024): 适合小记录，减少内部碎片
-- • 大页面(8192): 适合大记录（BLOB），减少B-Tree深度

-- B-Tree深度对比（100万行）：
-- page_size=1024: 深度≈4
-- page_size=4096: 深度≈3
-- page_size=8192: 深度≈3
```

### 3. 预读（Read-Ahead）

```c
// SQLite 3.47+ 支持预读优化
// 当顺序扫描时，Pager会预读后续页面

// 示例：SCAN orders
// 页面访问序列：1, 2, 3, 4, ...
// Pager自动预读：
//   访问页面1时，预读2, 3
//   访问页面2时，预读4, 5
// 效果：减少IO wait时间
```

---

**文档版本**: v1.0.0
**最后更新**: 2025-12-04
