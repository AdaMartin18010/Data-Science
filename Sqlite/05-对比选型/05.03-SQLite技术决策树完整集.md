# SQLite技术决策树完整集

> **创建日期**: 2025-12-05
> **版本**: v1.0
> **对象**: SQLite 3.47.x
> **难度**: ⭐⭐⭐⭐⭐

---

## 📑 目录

- [SQLite技术决策树完整集](#sqlite技术决策树完整集)
  - [📑 目录](#-目录)
  - [决策树1：SQLite适用性判断](#决策树1sqlite适用性判断)
  - [决策树2：WAL vs Rollback Journal](#决策树2wal-vs-rollback-journal)
  - [决策树3：索引策略](#决策树3索引策略)
  - [决策树4：性能优化策略](#决策树4性能优化策略)
  - [决策树5：并发控制策略](#决策树5并发控制策略)
  - [决策树6：数据类型选择](#决策树6数据类型选择)
  - [决策树7：PRAGMA配置优化](#决策树7pragma配置优化)
  - [实战决策矩阵](#实战决策矩阵)
  - [🔗 交叉引用](#-交叉引用)
    - [对比选型文档](#对比选型文档)
    - [应用场景文档](#应用场景文档)
    - [核心架构文档 🆕](#核心架构文档-)
    - [性能优化文档 🆕](#性能优化文档-)
    - [知识图谱与导航 🆕](#知识图谱与导航-)
    - [相关概念链接 🆕](#相关概念链接-)
      - [技术决策树概念](#技术决策树概念)


## 决策树1：SQLite适用性判断

```text
SQLite适用性决策树
══════════════════════════════════════════════════════════════════════════════

问题：是否应该使用SQLite？
    │
    ├─ 数据规模？
    │   ├─ < 2GB → ✓ 适合
    │   ├─ 2-10GB → ⚠️ 谨慎（需要优化）
    │   └─ > 10GB → ✗ 不推荐（考虑PostgreSQL）
    │
    ├─ 并发写入？
    │   ├─ 单写 → ✓ 适合（SQLite优势）
    │   ├─ 多写（<10） → ⚠️ 可考虑（WAL模式）
    │   └─ 高并发写（>10） → ✗ 不适合（考虑PostgreSQL/MySQL）
    │
    ├─ 网络需求？
    │   ├─ 本地访问 → ✓ 适合
    │   ├─ 局域网 → ⚠️ 可考虑（文件共享）
    │   └─ 互联网 → ✗ 不适合（需要客户端-服务器）
    │
    ├─ 部署环境？
    │   ├─ 移动App → ✓ 强烈推荐
    │   ├─ 桌面应用 → ✓ 推荐
    │   ├─ IoT设备 → ✓ 推荐
    │   ├─ Web服务器 → ✗ 不推荐（考虑PostgreSQL）
    │   └─ 云服务 → ✗ 不推荐（考虑云数据库）
    │
    └─ 功能需求？
        ├─ 简单CRUD → ✓ 适合
        ├─ 复杂查询 → ⚠️ 可考虑（SQLite支持）
        ├─ 全文搜索 → ✓ 适合（FTS扩展）
        ├─ JSON查询 → ✓ 适合（JSON1扩展）
        ├─ 地理空间 → ⚠️ 可考虑（需要扩展）
        └─ 分布式 → ✗ 不适合（单机数据库）

决策结果:
✓ 适合: 移动App、桌面应用、IoT、小规模数据、单写场景
✗ 不适合: 高并发写、大规模数据、网络访问、分布式需求
```

---

## 决策树2：WAL vs Rollback Journal

```text
WAL vs Rollback Journal决策树
══════════════════════════════════════════════════════════════════════════════

问题：选择哪种日志模式？
    │
    ├─ 并发需求？
    │   ├─ 需要并发读 → ✓ WAL模式
    │   │   • 读不阻塞写
    │   │   • 写不阻塞读
    │   │   • 性能提升2-3x
    │   │
    │   └─ 单线程/低并发 → ⚠️ Rollback Journal
    │       • 更简单
    │       • 兼容性更好
    │
    ├─ 性能要求？
    │   ├─ 高写入性能 → ✓ WAL模式
    │   │   • 顺序写入（更快）
    │   │   • 批量提交优化
    │   │
    │   └─ 低延迟要求 → ⚠️ Rollback Journal
    │       • 检查点延迟更低
    │
    ├─ 磁盘空间？
    │   ├─ 充足 → ✓ WAL模式
    │   │   • WAL文件可能较大
    │   │
    │   └─ 受限 → ⚠️ Rollback Journal
    │       • 空间占用更小
    │
    └─ 兼容性？
        ├─ 需要旧版本兼容 → ⚠️ Rollback Journal
        └─ 现代应用 → ✓ WAL模式（推荐）

推荐配置:
• 现代应用: WAL模式（默认）
• 旧系统: Rollback Journal（兼容性）
• 高并发: WAL模式（必需）
• 嵌入式: WAL模式（性能优势）
```

---

## 决策树3：索引策略

```text
SQLite索引策略决策树
══════════════════════════════════════════════════════════════════════════════

问题：是否需要创建索引？
    │
    ├─ 查询模式？
    │   ├─ WHERE条件 → ✓ 需要索引
    │   │   • 单列条件：单列索引
    │   │   • 多列条件：复合索引
    │   │
    │   ├─ ORDER BY → ⚠️ 考虑索引
    │   │   • 如果WHERE也有条件：复合索引
    │   │   • 如果只有ORDER BY：可能不需要
    │   │
    │   ├─ JOIN → ✓ 需要索引
    │   │   • 外键列必须索引
    │   │   • JOIN列必须索引
    │   │
    │   └─ 全表扫描 → ✗ 不需要索引
    │
    ├─ 列选择性？
    │   ├─ 高选择性（>10%） → ✓ 索引有效
    │   ├─ 低选择性（<1%） → ⚠️ 索引可能无效
    │   └─ 唯一列 → ✓ 强烈推荐索引
    │
    ├─ 查询频率？
    │   ├─ 频繁查询 → ✓ 需要索引
    │   └─ 偶尔查询 → ⚠️ 权衡（索引维护成本）
    │
    └─ 写入频率？
        ├─ 高写入 → ⚠️ 谨慎（索引维护开销）
        └─ 低写入 → ✓ 可以多建索引

索引类型选择:
• 单列查询 → 单列索引
• 多列查询 → 复合索引（列顺序重要）
• 部分查询 → 部分索引（WHERE条件）
• 覆盖查询 → 包含列索引（SQLite 3.9+）
• 表达式查询 → 表达式索引（SQLite 3.9+）

示例:
-- 单列索引
CREATE INDEX idx_user_email ON users(email);

-- 复合索引（WHERE + ORDER BY）
CREATE INDEX idx_orders_user_date ON orders(user_id, created_at DESC);

-- 部分索引（只索引活跃用户）
CREATE INDEX idx_active_users ON users(email) WHERE status = 'active';

-- 表达式索引（大小写不敏感）
CREATE INDEX idx_user_email_lower ON users(LOWER(email));
```

---

## 决策树4：性能优化策略

```text
SQLite性能优化决策树
══════════════════════════════════════════════════════════════════════════════

问题：查询慢，如何优化？
    │
    ├─ 查询计划分析
    │   ├─ EXPLAIN QUERY PLAN显示全表扫描？
    │   │   └─ → 创建索引
    │   │
    │   ├─ 显示临时B-Tree？
    │   │   └─ → 优化ORDER BY/GROUP BY（添加索引）
    │   │
    │   └─ 显示多表JOIN？
    │       └─ → 检查JOIN列索引
    │
    ├─ 数据量分析
    │   ├─ 表行数 > 100万？
    │   │   ├─ → 考虑分区
    │   │   └─ → 考虑归档历史数据
    │   │
    │   └─ 单行数据 > 1KB？
    │       └─ → 考虑垂直拆分（分离大字段）
    │
    ├─ 缓存配置
    │   ├─ cache_size < 默认值？
    │   │   └─ → 增加cache_size（PRAGMA cache_size=-64000）
    │   │
    │   └─ 频繁磁盘IO？
    │       └─ → 增加page_size（PRAGMA page_size=4096）
    │
    ├─ 事务优化
    │   ├─ 单条语句事务？
    │   │   └─ → 批量操作（BEGIN...COMMIT）
    │   │
    │   └─ 长时间事务？
    │       └─ → 缩短事务时间
    │
    └─ 查询优化
        ├─ SELECT *？
        │   └─ → 只选择需要的列
        │
        ├─ 子查询？
        │   └─ → 考虑JOIN或CTE
        │
        └─ 重复查询？
            └─ → 使用预编译语句

优化优先级:
1. 创建索引（最大收益）
2. 批量事务（写入优化）
3. 缓存配置（读取优化）
4. 查询改写（减少计算）
5. 数据归档（减少数据量）
```

---

## 决策树5：并发控制策略

```text
SQLite并发控制决策树
══════════════════════════════════════════════════════════════════════════════

问题：如何处理并发访问？
    │
    ├─ 访问模式？
    │   ├─ 单进程单线程 → ✓ 无需特殊处理
    │   │   • 默认配置即可
    │   │
    │   ├─ 单进程多线程 → ⚠️ 需要连接管理
    │   │   • 每个线程独立连接
    │   │   • 或使用连接池
    │   │
    │   └─ 多进程 → ⚠️ 需要文件锁
    │       • WAL模式（推荐）
    │       • 或应用层锁
    │
    ├─ 写入冲突？
    │   ├─ 低冲突率 → ✓ WAL模式
    │   │   • 自动处理冲突
    │   │
    │   ├─ 高冲突率 → ⚠️ 应用层协调
    │   │   • 使用队列
    │   │   • 或升级到PostgreSQL
    │   │
    │   └─ 无冲突（单写） → ✓ 任何模式
    │
    ├─ 读取一致性？
    │   ├─ 需要快照隔离 → ✓ WAL模式
    │   │   • MVCC支持
    │   │
    │   └─ 可接受脏读 → ⚠️ Rollback Journal
    │       • 更简单
    │
    └─ 性能要求？
        ├─ 高并发读 → ✓ WAL模式
        │   • 读不阻塞
        │
        └─ 低延迟写 → ⚠️ 优化事务大小
            • 减少锁持有时间

推荐方案:
• 单进程多线程: 每线程一连接 + WAL
• 多进程: WAL模式 + 应用层队列（高冲突）
• 高并发读: WAL模式（必需）
• 单写多读: WAL模式（最佳）
```

---

## 决策树6：数据类型选择

```text
SQLite数据类型决策树
══════════════════════════════════════════════════════════════════════════════

问题：选择什么数据类型？
    │
    ├─ 数值类型
    │   ├─ 整数 → INTEGER
    │   │   • 主键：INTEGER PRIMARY KEY
    │   │   • 外键：INTEGER
    │   │   • 性能最优
    │   │
    │   ├─ 浮点数 → REAL
    │   │   • 科学计算
    │   │   • 注意精度问题
    │   │
    │   └─ 精确小数 → TEXT（存储为字符串）
    │       • 或使用NUMERIC（SQLite 3.37+）
    │
    ├─ 文本类型
    │   ├─ 短文本（<255） → TEXT
    │   ├─ 长文本 → TEXT
    │   └─ 固定长度 → TEXT（SQLite无CHAR）
    │
    ├─ 日期时间
    │   ├─ 存储格式？
    │   │   ├─ Unix时间戳 → INTEGER
    │   │   │   • 性能好
    │   │   │   • 计算方便
    │   │   │
    │   │   ├─ ISO 8601 → TEXT
    │   │   │   • 可读性好
    │   │   │   • 排序正确
    │   │   │
    │   │   └─ 日期函数 → TEXT
    │   │       • date()函数支持
    │   │
    │   └─ 时区？
    │       ├─ UTC → INTEGER（时间戳）
    │       └─ 本地时间 → TEXT（ISO 8601）
    │
    ├─ 二进制数据
    │   └─ → BLOB
    │       • 小数据（<1MB）：直接存储
    │       • 大数据：考虑外部存储
    │
    └─ JSON数据
        └─ → TEXT + JSON1扩展
            • 存储为TEXT
            • 使用json()函数查询

最佳实践:
• 主键：INTEGER PRIMARY KEY（自增）
• 外键：INTEGER（性能好）
• 日期：INTEGER（Unix时间戳）或TEXT（ISO 8601）
• 金额：TEXT（精确）或INTEGER（分为单位）
• JSON：TEXT + JSON1扩展
```

---

## 决策树7：PRAGMA配置优化

```text
SQLite PRAGMA配置决策树
══════════════════════════════════════════════════════════════════════════════

问题：如何配置PRAGMA参数？
    │
    ├─ journal_mode
    │   ├─ 需要并发读 → WAL
    │   ├─ 高写入性能 → WAL
    │   └─ 兼容性要求 → DELETE（Rollback Journal）
    │
    ├─ synchronous
    │   ├─ 数据安全优先 → FULL
    │   │   • 金融/关键数据
    │   │
    │   ├─ 性能优先 → NORMAL（WAL模式）
    │   │   • 大多数应用
    │   │
    │   └─ 测试/临时 → OFF
    │       • 不推荐生产
    │
    ├─ cache_size
    │   ├─ 内存充足 → -64000（64MB）
    │   ├─ 内存受限 → -2000（2MB）
    │   └─ 默认 → -2000
    │
    ├─ page_size
    │   ├─ 大数据 → 4096或8192
    │   ├─ 小数据 → 1024或2048
    │   └─ 默认 → 4096（推荐）
    │
    ├─ temp_store
    │   ├─ 内存充足 → MEMORY
    │   └─ 内存受限 → FILE
    │
    └─ foreign_keys
        ├─ 需要外键约束 → ON
        └─ 性能优先 → OFF（不推荐）

推荐配置（生产环境）:
PRAGMA journal_mode = WAL;
PRAGMA synchronous = NORMAL;  -- WAL模式下
PRAGMA cache_size = -64000;   -- 64MB
PRAGMA page_size = 4096;
PRAGMA foreign_keys = ON;
PRAGMA temp_store = MEMORY;
```

---

## 实战决策矩阵

```text
SQLite应用场景决策矩阵
══════════════════════════════════════════════════════════════════════════════

场景 | 数据量 | 并发 | 模式 | 索引 | PRAGMA | 推荐度
-----|--------|------|------|------|--------|-------
移动App | <100MB | 单写 | WAL | 必需 | cache=32MB | ⭐⭐⭐⭐⭐
桌面应用 | <1GB | 单写 | WAL | 推荐 | cache=64MB | ⭐⭐⭐⭐⭐
IoT设备 | <10MB | 单写 | WAL | 简单 | cache=2MB | ⭐⭐⭐⭐⭐
Web缓存 | <500MB | 多读 | WAL | 必需 | cache=128MB | ⭐⭐⭐⭐
测试环境 | 任意 | 单写 | DELETE | 可选 | cache=64MB | ⭐⭐⭐⭐⭐
数据分析 | <2GB | 单读 | WAL | 必需 | cache=256MB | ⭐⭐⭐⭐
日志存储 | <5GB | 单写 | WAL | 时间索引 | cache=32MB | ⭐⭐⭐
配置存储 | <10MB | 单写 | DELETE | 无 | 默认 | ⭐⭐⭐⭐⭐

性能优化决策矩阵
══════════════════════════════════════════════════════════════════════════════

瓶颈 | 症状 | 优化方案 | 预期提升
-----|------|---------|----------
全表扫描 | EXPLAIN显示SCAN | 创建索引 | 10-1000x
临时排序 | EXPLAIN显示USE TEMP | ORDER BY索引 | 5-50x
频繁IO | 磁盘IO高 | 增加cache_size | 2-10x
慢写入 | 写入延迟高 | 批量事务 | 10-100x
大事务 | 锁等待 | 缩短事务 | 2-5x
```

---

## 🔗 交叉引用

### 对比选型文档

- ⭐⭐⭐ [多维知识矩阵](./05.01-多维知识矩阵.md) - 数据库对比分析（含交叉引用）
- ⭐⭐⭐ [选型决策框架](./05.02-选型决策框架.md) - 选型决策框架（含交叉引用）

### 应用场景文档

- ⭐⭐⭐ [适用场景分析](../04-应用场景/04.01-适用场景分析.md) - 适用场景分析（含交叉引用）
- ⭐⭐ [不适用场景论证](../04-应用场景/04.02-不适用场景论证.md) - 不适用场景论证

### 核心架构文档 🆕

- ⭐⭐ [核心机制全景图](../01-核心架构/01.05-SQLite核心机制全景图-多维度整合分析.md) - 核心机制整合分析
- ⭐⭐ [事务与并发控制](../01-核心架构/01.02-事务与并发控制.md) - 并发控制基础

### 性能优化文档 🆕

- ⭐⭐ [性能特征分析](../03-性能优化/03.01-性能特征分析.md) - 性能分析（含决策树）
- ⭐⭐ [优化策略](../03-性能优化/03.02-优化策略.md) - 优化方法（含决策树）

### 知识图谱与导航 🆕

- ⭐⭐⭐ [知识图谱与概念关系网络](../09-最新特性/09.03-SQLite知识图谱与概念关系网络.md) - 技术决策树概念关系（400+概念）
- ⭐⭐ [文档依赖关系图](../00-项目导航/06-文档依赖关系图.md) - 技术决策树文档依赖
- ⭐⭐ [术语标准化词典](../00-项目导航/03-术语词典/SQLite术语标准化词典.md) - 技术决策树术语索引

### 相关概念链接 🆕

#### 技术决策树概念

- **技术决策树** → [技术决策树完整集](./05.03-SQLite技术决策树完整集.md)
- **选型决策** → [选型决策框架](./05.02-选型决策框架.md)
- **决策树体系** → [知识图谱：决策树概念](../09-最新特性/09.03-SQLite知识图谱与概念关系网络.md#应用场景本体)

---

**文档版本**: v2.0
**最后更新**: 2025-12-05
**决策树数量**: 7个
**决策节点**: 80+个
**实战矩阵**: 2个
