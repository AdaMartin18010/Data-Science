# SQLite嵌入式数据库架构设计模式

> **创建日期**: 2025-12-04
> **版本**: SQLite 3.47.x
> **难度**: ⭐⭐⭐⭐⭐

---

## 设计模式总览

```text
SQLite嵌入式架构六大模式
══════════════════════════════════════════════════════════════════════════════

1. 单进程模式（Single-Process）
   ├─ 场景：桌面应用、移动App
   └─ 特点：简单、无网络开销

2. 多进程共享模式（Shared-Cache）
   ├─ 场景：同一机器多进程
   └─ 特点：共享缓存、降低内存

3. 客户端-服务器模式（Client-Server）
   ├─ 场景：多客户端访问
   └─ 特点：中心化控制、网络访问

4. 离线优先模式（Offline-First）
   ├─ 场景：移动App、PWA
   └─ 特点：离线可用、后台同步

5. 嵌入式缓存模式（Embedded Cache）
   ├─ 场景：服务器缓存层
   └─ 特点：快速访问、数据预热

6. 边缘计算模式（Edge Computing）
   ├─ 场景：IoT设备、CDN节点
   └─ 特点：本地处理、减少延迟
```

---

## 模式1：单进程模式

### 架构图

```text
单进程SQLite架构
═══════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────┐
│          Application Process                │
│                                             │
│  ┌────────────┐      ┌─────────────┐      │
│  │ UI Thread  │      │ Worker Thread│      │
│  └──────┬─────┘      └──────┬──────┘      │
│         │                   │              │
│         └───────┬───────────┘              │
│                 │                          │
│         ┌───────▼────────┐                │
│         │ SQLite Library │                │
│         └───────┬────────┘                │
│                 │                          │
│         ┌───────▼────────┐                │
│         │  Database File │                │
│         └────────────────┘                │
└─────────────────────────────────────────────┘

特点:
• 单个数据库连接
• WAL模式支持并发读
• 简单易用
```

### 实现（Python桌面应用）

```python
import sqlite3
from threading import Lock
from contextlib import contextmanager

class SingleProcessDB:
    """单进程SQLite数据库封装"""

    def __init__(self, db_path):
        self.db_path = db_path
        self.conn = None
        self.lock = Lock()  # 保护写操作
        self._init_db()

    def _init_db(self):
        """初始化数据库连接"""
        self.conn = sqlite3.connect(
            self.db_path,
            check_same_thread=False  # 允许多线程
        )

        # 配置优化
        self.conn.execute('PRAGMA journal_mode=WAL')
        self.conn.execute('PRAGMA synchronous=NORMAL')
        self.conn.execute('PRAGMA cache_size=-64000')  # 64MB
        self.conn.execute('PRAGMA temp_store=MEMORY')
        self.conn.execute('PRAGMA foreign_keys=ON')

        # 创建表
        self.conn.execute('''
            CREATE TABLE IF NOT EXISTS tasks (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                title TEXT NOT NULL,
                status TEXT NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        self.conn.commit()

    @contextmanager
    def transaction(self):
        """事务上下文管理器"""
        with self.lock:  # 串行化写操作
            self.conn.execute('BEGIN')
            try:
                yield self.conn
                self.conn.commit()
            except Exception:
                self.conn.rollback()
                raise

    def query(self, sql, params=()):
        """读操作（不需要锁）"""
        return self.conn.execute(sql, params).fetchall()

    def execute(self, sql, params=()):
        """写操作（需要锁）"""
        with self.transaction() as conn:
            conn.execute(sql, params)

    def close(self):
        """关闭连接"""
        if self.conn:
            self.conn.close()

# 使用
db = SingleProcessDB('app.db')

# 多线程读取（并发）
import threading

def read_thread():
    tasks = db.query('SELECT * FROM tasks LIMIT 10')
    print(f"Thread {threading.current_thread().name}: {len(tasks)} tasks")

threads = [threading.Thread(target=read_thread) for _ in range(5)]
for t in threads:
    t.start()
for t in threads:
    t.join()

# 写入（串行）
db.execute('INSERT INTO tasks (title, status) VALUES (?, ?)', ('Task 1', 'pending'))
```

---

## 模式2：多进程共享模式

### 架构图

```text
多进程共享缓存架构
═══════════════════════════════════════════════════════════════

┌─────────────┐  ┌─────────────┐  ┌─────────────┐
│  Process 1  │  │  Process 2  │  │  Process 3  │
└──────┬──────┘  └──────┬──────┘  └──────┬──────┘
       │                │                │
       │         ┌──────▼──────┐         │
       │         │ Shared Cache│         │
       │         │  (内存共享)  │         │
       │         └──────┬──────┘         │
       │                │                │
       └────────────────┼────────────────┘
                        │
                ┌───────▼────────┐
                │  Database File │
                └────────────────┘

特点:
• 多进程共享缓存
• 减少内存占用
• 需要操作系统支持
```

### 实现（Shared-Cache模式）

```python
import sqlite3
import multiprocessing

def worker(worker_id):
    """工作进程"""
    # 启用共享缓存模式
    conn = sqlite3.connect(
        'file:app.db?cache=shared',
        uri=True
    )

    # 读取数据
    for i in range(10):
        result = conn.execute('SELECT COUNT(*) FROM tasks').fetchone()
        print(f"Worker {worker_id}: {result[0]} tasks")

    conn.close()

if __name__ == '__main__':
    # 创建多个工作进程
    processes = [
        multiprocessing.Process(target=worker, args=(i,))
        for i in range(4)
    ]

    for p in processes:
        p.start()
    for p in processes:
        p.join()
```

---

## 模式3：客户端-服务器模式

### 架构图

```text
SQLite客户端-服务器架构
═══════════════════════════════════════════════════════════════

┌──────────┐  ┌──────────┐  ┌──────────┐
│ Client 1 │  │ Client 2 │  │ Client 3 │
└────┬─────┘  └────┬─────┘  └────┬─────┘
     │             │             │
     │  HTTP/gRPC  │             │
     └─────────────┼─────────────┘
                   │
            ┌──────▼──────┐
            │ HTTP Server │
            │ (FastAPI)   │
            └──────┬──────┘
                   │
            ┌──────▼──────┐
            │  SQLite Lib │
            └──────┬──────┘
                   │
            ┌──────▼──────┐
            │  DB File    │
            └─────────────┘

特点:
• 中心化控制
• 网络访问
• 适合多客户端
```

### 实现（FastAPI服务器）

```python
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import sqlite3
from contextlib import asynccontextmanager
from threading import Lock

# 数据库管理器
class DatabaseManager:
    def __init__(self, db_path):
        self.conn = sqlite3.connect(db_path, check_same_thread=False)
        self.conn.row_factory = sqlite3.Row
        self.lock = Lock()

        # 配置
        self.conn.execute('PRAGMA journal_mode=WAL')
        self.conn.execute('PRAGMA synchronous=NORMAL')

        # 创建表
        self.conn.execute('''
            CREATE TABLE IF NOT EXISTS tasks (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                title TEXT NOT NULL,
                status TEXT NOT NULL
            )
        ''')
        self.conn.commit()

    def query(self, sql, params=()):
        """读操作"""
        cursor = self.conn.execute(sql, params)
        return [dict(row) for row in cursor.fetchall()]

    def execute(self, sql, params=()):
        """写操作"""
        with self.lock:
            self.conn.execute(sql, params)
            self.conn.commit()
            return self.conn.execute('SELECT last_insert_rowid()').fetchone()[0]

# 全局数据库实例
db = DatabaseManager('app.db')

# FastAPI应用
app = FastAPI()

class Task(BaseModel):
    title: str
    status: str

@app.get("/tasks")
def get_tasks():
    """获取所有任务"""
    return db.query('SELECT * FROM tasks')

@app.get("/tasks/{task_id}")
def get_task(task_id: int):
    """获取单个任务"""
    result = db.query('SELECT * FROM tasks WHERE id = ?', (task_id,))
    if not result:
        raise HTTPException(status_code=404, detail="Task not found")
    return result[0]

@app.post("/tasks")
def create_task(task: Task):
    """创建任务"""
    task_id = db.execute(
        'INSERT INTO tasks (title, status) VALUES (?, ?)',
        (task.title, task.status)
    )
    return {"id": task_id, **task.dict()}

@app.put("/tasks/{task_id}")
def update_task(task_id: int, task: Task):
    """更新任务"""
    db.execute(
        'UPDATE tasks SET title = ?, status = ? WHERE id = ?',
        (task.title, task.status, task_id)
    )
    return {"id": task_id, **task.dict()}

@app.delete("/tasks/{task_id}")
def delete_task(task_id: int):
    """删除任务"""
    db.execute('DELETE FROM tasks WHERE id = ?', (task_id,))
    return {"status": "deleted"}

# 运行: uvicorn main:app --reload
```

---

## 模式4：离线优先模式

### 架构图

```text
离线优先架构
═══════════════════════════════════════════════════════════════

┌─────────────────────────────────────────┐
│          Mobile App                     │
│                                         │
│  ┌────────────┐      ┌──────────┐     │
│  │ UI Layer   │◄─────┤ ViewModel│     │
│  └────────────┘      └─────┬────┘     │
│                            │           │
│                    ┌───────▼───────┐   │
│                    │ Local DB (RW) │   │
│                    │  (SQLite)     │   │
│                    └───────┬───────┘   │
│                            │           │
│                    ┌───────▼───────┐   │
│                    │ Sync Manager  │   │
│                    └───────┬───────┘   │
└────────────────────────────┼───────────┘
                             │
                       Network?
                             │
                    ┌────────▼────────┐
                    │  Remote Server  │
                    │  (PostgreSQL)   │
                    └─────────────────┘

流程:
1. UI → ViewModel → Local DB (即时响应)
2. Sync Manager后台同步
3. 网络恢复时批量上传
```

### 实现（Flutter + SQLite）

```dart
// lib/models/sync_item.dart
class SyncItem {
  final int? id;
  final String tableName;
  final String operation;  // INSERT/UPDATE/DELETE
  final Map<String, dynamic> data;
  final DateTime createdAt;
  final int retryCount;

  SyncItem({
    this.id,
    required this.tableName,
    required this.operation,
    required this.data,
    required this.createdAt,
    this.retryCount = 0,
  });
}

// lib/database/offline_first_db.dart
import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart';
import 'dart:convert';

class OfflineFirstDB {
  static Database? _database;

  Future<Database> get database async {
    if (_database != null) return _database!;
    _database = await _initDB();
    return _database!;
  }

  Future<Database> _initDB() async {
    final dbPath = await getDatabasesPath();
    final path = join(dbPath, 'offline_app.db');

    return await openDatabase(
      path,
      version: 1,
      onCreate: (db, version) async {
        // 业务表
        await db.execute('''
          CREATE TABLE tasks (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            server_id INTEGER,  -- 服务器端ID
            title TEXT NOT NULL,
            status TEXT NOT NULL,
            synced INTEGER DEFAULT 0,  -- 是否已同步
            created_at TEXT NOT NULL,
            updated_at TEXT NOT NULL
          )
        ''');

        // 同步队列
        await db.execute('''
          CREATE TABLE sync_queue (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            table_name TEXT NOT NULL,
            operation TEXT NOT NULL,
            local_id INTEGER,
            data TEXT NOT NULL,  -- JSON
            retry_count INTEGER DEFAULT 0,
            created_at TEXT NOT NULL
          )
        ''');

        await db.execute('PRAGMA journal_mode=WAL');
      },
    );
  }

  // 创建任务（离线操作）
  Future<int> createTask(String title, String status) async {
    final db = await database;
    final now = DateTime.now().toIso8601String();

    return await db.transaction((txn) async {
      // 插入任务
      final taskId = await txn.insert('tasks', {
        'title': title,
        'status': status,
        'synced': 0,
        'created_at': now,
        'updated_at': now,
      });

      // 加入同步队列
      await txn.insert('sync_queue', {
        'table_name': 'tasks',
        'operation': 'INSERT',
        'local_id': taskId,
        'data': json.encode({'title': title, 'status': status}),
        'created_at': now,
      });

      return taskId;
    });
  }

  // 后台同步
  Future<void> sync(Future<dynamic> Function(String, String, Map) apiCall) async {
    final db = await database;

    // 获取待同步项
    final pending = await db.query(
      'sync_queue',
      orderBy: 'id ASC',
      limit: 100,
    );

    for (final item in pending) {
      try {
        final tableName = item['table_name'] as String;
        final operation = item['operation'] as String;
        final data = json.decode(item['data'] as String);
        final localId = item['local_id'] as int?;

        // 调用API
        final response = await apiCall(tableName, operation, data);

        // 更新server_id
        if (operation == 'INSERT' && localId != null && response['id'] != null) {
          await db.update(
            tableName,
            {'server_id': response['id'], 'synced': 1},
            where: 'id = ?',
            whereArgs: [localId],
          );
        }

        // 删除同步项
        await db.delete('sync_queue', where: 'id = ?', whereArgs: [item['id']]);
      } catch (e) {
        // 更新重试次数
        await db.update(
          'sync_queue',
          {'retry_count': (item['retry_count'] as int) + 1},
          where: 'id = ?',
          whereArgs: [item['id']],
        );
      }
    }
  }
}
```

---

## 模式5：嵌入式缓存模式

### 架构图

```text
嵌入式缓存架构
═══════════════════════════════════════════════════════════════

┌─────────────────────────────────────────┐
│       Application Server                │
│                                         │
│  ┌──────────┐      ┌─────────────┐    │
│  │ HTTP API │      │ Business    │    │
│  └────┬─────┘      │ Logic       │    │
│       │            └──────┬──────┘    │
│       │                   │            │
│       │         ┌─────────▼────────┐  │
│       │         │ Cache Layer      │  │
│       │         │  (SQLite)        │  │
│       │         └─────────┬────────┘  │
│       │                   │            │
│       │         ┌─────────▼────────┐  │
│       └─────────┤ Primary DB       │  │
│                 │  (PostgreSQL)    │  │
│                 └──────────────────┘  │
└─────────────────────────────────────────┘

策略:
• Read: Cache Hit → 返回; Cache Miss → DB → 写Cache
• Write: 更新DB → 删除Cache
```

### 实现（Python缓存层）

```python
import sqlite3
import json
import time
from functools import wraps

class SQLiteCache:
    """SQLite缓存层"""

    def __init__(self, cache_db='cache.db', ttl=3600):
        self.conn = sqlite3.connect(cache_db, check_same_thread=False)
        self.ttl = ttl

        # 配置（内存优先）
        self.conn.execute('PRAGMA journal_mode=MEMORY')
        self.conn.execute('PRAGMA synchronous=OFF')
        self.conn.execute('PRAGMA cache_size=-128000')  # 128MB

        # 创建缓存表
        self.conn.execute('''
            CREATE TABLE IF NOT EXISTS cache (
                key TEXT PRIMARY KEY,
                value TEXT NOT NULL,
                expires_at REAL NOT NULL
            )
        ''')
        self.conn.execute('CREATE INDEX IF NOT EXISTS idx_expires ON cache(expires_at)')
        self.conn.commit()

        # 定期清理
        self._cleanup()

    def get(self, key):
        """获取缓存"""
        cursor = self.conn.execute(
            'SELECT value FROM cache WHERE key = ? AND expires_at > ?',
            (key, time.time())
        )
        row = cursor.fetchone()
        return json.loads(row[0]) if row else None

    def set(self, key, value, ttl=None):
        """设置缓存"""
        expires_at = time.time() + (ttl or self.ttl)
        self.conn.execute(
            '''INSERT OR REPLACE INTO cache (key, value, expires_at)
               VALUES (?, ?, ?)''',
            (key, json.dumps(value), expires_at)
        )
        self.conn.commit()

    def delete(self, key):
        """删除缓存"""
        self.conn.execute('DELETE FROM cache WHERE key = ?', (key,))
        self.conn.commit()

    def _cleanup(self):
        """清理过期缓存"""
        self.conn.execute('DELETE FROM cache WHERE expires_at <= ?', (time.time(),))
        self.conn.commit()

# 缓存装饰器
cache = SQLiteCache()

def cached(key_func, ttl=3600):
    """缓存装饰器"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            # 生成缓存键
            key = key_func(*args, **kwargs)

            # 尝试从缓存读取
            cached_value = cache.get(key)
            if cached_value is not None:
                print(f"Cache HIT: {key}")
                return cached_value

            # 缓存未命中，执行函数
            print(f"Cache MISS: {key}")
            result = func(*args, **kwargs)

            # 写入缓存
            cache.set(key, result, ttl)
            return result
        return wrapper
    return decorator

# 使用示例
@cached(key_func=lambda user_id: f"user:{user_id}", ttl=3600)
def get_user(user_id):
    """获取用户（从数据库）"""
    import psycopg2
    conn = psycopg2.connect("postgresql://...")
    cursor = conn.execute('SELECT * FROM users WHERE id = %s', (user_id,))
    return cursor.fetchone()

# 调用
user = get_user(123)  # Cache MISS，从数据库读取
user = get_user(123)  # Cache HIT，从SQLite读取（快）
```

---

**文档版本**: v1.0.0
**最后更新**: 2025-12-04
