# SQLiteåµŒå…¥å¼æ•°æ®åº“æ¶æ„è®¾è®¡æ¨¡å¼

> **åˆ›å»ºæ—¥æœŸ**: 2025-12-04
> **ç‰ˆæœ¬**: SQLite 3.47.x
> **éš¾åº¦**: â­â­â­â­â­

---

## ğŸ“‘ ç›®å½•

- [SQLiteåµŒå…¥å¼æ•°æ®åº“æ¶æ„è®¾è®¡æ¨¡å¼](#sqliteåµŒå…¥å¼æ•°æ®åº“æ¶æ„è®¾è®¡æ¨¡å¼)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [è®¾è®¡æ¨¡å¼æ€»è§ˆ](#è®¾è®¡æ¨¡å¼æ€»è§ˆ)
  - [æ¨¡å¼1ï¼šå•è¿›ç¨‹æ¨¡å¼](#æ¨¡å¼1å•è¿›ç¨‹æ¨¡å¼)
    - [æ¶æ„å›¾](#æ¶æ„å›¾)
    - [å®ç°ï¼ˆPythonæ¡Œé¢åº”ç”¨ï¼‰](#å®ç°pythonæ¡Œé¢åº”ç”¨)
  - [æ¨¡å¼2ï¼šå¤šè¿›ç¨‹å…±äº«æ¨¡å¼](#æ¨¡å¼2å¤šè¿›ç¨‹å…±äº«æ¨¡å¼)
    - [æ¶æ„å›¾](#æ¶æ„å›¾-1)
    - [å®ç°ï¼ˆShared-Cacheæ¨¡å¼ï¼‰](#å®ç°shared-cacheæ¨¡å¼)
  - [æ¨¡å¼3ï¼šå®¢æˆ·ç«¯-æœåŠ¡å™¨æ¨¡å¼](#æ¨¡å¼3å®¢æˆ·ç«¯-æœåŠ¡å™¨æ¨¡å¼)
    - [æ¶æ„å›¾](#æ¶æ„å›¾-2)
    - [å®ç°ï¼ˆFastAPIæœåŠ¡å™¨ï¼‰](#å®ç°fastapiæœåŠ¡å™¨)
  - [æ¨¡å¼4ï¼šç¦»çº¿ä¼˜å…ˆæ¨¡å¼](#æ¨¡å¼4ç¦»çº¿ä¼˜å…ˆæ¨¡å¼)
    - [æ¶æ„å›¾](#æ¶æ„å›¾-3)
    - [å®ç°ï¼ˆFlutter + SQLiteï¼‰](#å®ç°flutter--sqlite)
  - [æ¨¡å¼5ï¼šåµŒå…¥å¼ç¼“å­˜æ¨¡å¼](#æ¨¡å¼5åµŒå…¥å¼ç¼“å­˜æ¨¡å¼)
    - [æ¶æ„å›¾](#æ¶æ„å›¾-4)
    - [å®ç°ï¼ˆPythonç¼“å­˜å±‚ï¼‰](#å®ç°pythonç¼“å­˜å±‚)

## è®¾è®¡æ¨¡å¼æ€»è§ˆ

```text
SQLiteåµŒå…¥å¼æ¶æ„å…­å¤§æ¨¡å¼
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. å•è¿›ç¨‹æ¨¡å¼ï¼ˆSingle-Processï¼‰
   â”œâ”€ åœºæ™¯ï¼šæ¡Œé¢åº”ç”¨ã€ç§»åŠ¨App
   â””â”€ ç‰¹ç‚¹ï¼šç®€å•ã€æ— ç½‘ç»œå¼€é”€

2. å¤šè¿›ç¨‹å…±äº«æ¨¡å¼ï¼ˆShared-Cacheï¼‰
   â”œâ”€ åœºæ™¯ï¼šåŒä¸€æœºå™¨å¤šè¿›ç¨‹
   â””â”€ ç‰¹ç‚¹ï¼šå…±äº«ç¼“å­˜ã€é™ä½å†…å­˜

3. å®¢æˆ·ç«¯-æœåŠ¡å™¨æ¨¡å¼ï¼ˆClient-Serverï¼‰
   â”œâ”€ åœºæ™¯ï¼šå¤šå®¢æˆ·ç«¯è®¿é—®
   â””â”€ ç‰¹ç‚¹ï¼šä¸­å¿ƒåŒ–æ§åˆ¶ã€ç½‘ç»œè®¿é—®

4. ç¦»çº¿ä¼˜å…ˆæ¨¡å¼ï¼ˆOffline-Firstï¼‰
   â”œâ”€ åœºæ™¯ï¼šç§»åŠ¨Appã€PWA
   â””â”€ ç‰¹ç‚¹ï¼šç¦»çº¿å¯ç”¨ã€åå°åŒæ­¥

5. åµŒå…¥å¼ç¼“å­˜æ¨¡å¼ï¼ˆEmbedded Cacheï¼‰
   â”œâ”€ åœºæ™¯ï¼šæœåŠ¡å™¨ç¼“å­˜å±‚
   â””â”€ ç‰¹ç‚¹ï¼šå¿«é€Ÿè®¿é—®ã€æ•°æ®é¢„çƒ­

6. è¾¹ç¼˜è®¡ç®—æ¨¡å¼ï¼ˆEdge Computingï¼‰
   â”œâ”€ åœºæ™¯ï¼šIoTè®¾å¤‡ã€CDNèŠ‚ç‚¹
   â””â”€ ç‰¹ç‚¹ï¼šæœ¬åœ°å¤„ç†ã€å‡å°‘å»¶è¿Ÿ
```

---

## æ¨¡å¼1ï¼šå•è¿›ç¨‹æ¨¡å¼

### æ¶æ„å›¾

```text
å•è¿›ç¨‹SQLiteæ¶æ„
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          Application Process                â”‚
â”‚                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚ UI Thread  â”‚      â”‚ Worker Threadâ”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚         â”‚                   â”‚              â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚                 â”‚                          â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚         â”‚ SQLite Library â”‚                â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚                 â”‚                          â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚         â”‚  Database File â”‚                â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ç‰¹ç‚¹:
â€¢ å•ä¸ªæ•°æ®åº“è¿æ¥
â€¢ WALæ¨¡å¼æ”¯æŒå¹¶å‘è¯»
â€¢ ç®€å•æ˜“ç”¨
```

### å®ç°ï¼ˆPythonæ¡Œé¢åº”ç”¨ï¼‰

```python
import sqlite3
from threading import Lock
from contextlib import contextmanager

class SingleProcessDB:
    """å•è¿›ç¨‹SQLiteæ•°æ®åº“å°è£…"""

    def __init__(self, db_path):
        self.db_path = db_path
        self.conn = None
        self.lock = Lock()  # ä¿æŠ¤å†™æ“ä½œ
        self._init_db()

    def _init_db(self):
        """åˆå§‹åŒ–æ•°æ®åº“è¿æ¥"""
        self.conn = sqlite3.connect(
            self.db_path,
            check_same_thread=False  # å…è®¸å¤šçº¿ç¨‹
        )

        # é…ç½®ä¼˜åŒ–
        self.conn.execute('PRAGMA journal_mode=WAL')
        self.conn.execute('PRAGMA synchronous=NORMAL')
        self.conn.execute('PRAGMA cache_size=-64000')  # 64MB
        self.conn.execute('PRAGMA temp_store=MEMORY')
        self.conn.execute('PRAGMA foreign_keys=ON')

        # åˆ›å»ºè¡¨
        self.conn.execute('''
            CREATE TABLE IF NOT EXISTS tasks (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                title TEXT NOT NULL,
                status TEXT NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        self.conn.commit()

    @contextmanager
    def transaction(self):
        """äº‹åŠ¡ä¸Šä¸‹æ–‡ç®¡ç†å™¨"""
        with self.lock:  # ä¸²è¡ŒåŒ–å†™æ“ä½œ
            self.conn.execute('BEGIN')
            try:
                yield self.conn
                self.conn.commit()
            except Exception:
                self.conn.rollback()
                raise

    def query(self, sql, params=()):
        """è¯»æ“ä½œï¼ˆä¸éœ€è¦é”ï¼‰"""
        return self.conn.execute(sql, params).fetchall()

    def execute(self, sql, params=()):
        """å†™æ“ä½œï¼ˆéœ€è¦é”ï¼‰"""
        with self.transaction() as conn:
            conn.execute(sql, params)

    def close(self):
        """å…³é—­è¿æ¥"""
        if self.conn:
            self.conn.close()

# ä½¿ç”¨
db = SingleProcessDB('app.db')

# å¤šçº¿ç¨‹è¯»å–ï¼ˆå¹¶å‘ï¼‰
import threading

def read_thread():
    tasks = db.query('SELECT * FROM tasks LIMIT 10')
    print(f"Thread {threading.current_thread().name}: {len(tasks)} tasks")

threads = [threading.Thread(target=read_thread) for _ in range(5)]
for t in threads:
    t.start()
for t in threads:
    t.join()

# å†™å…¥ï¼ˆä¸²è¡Œï¼‰
db.execute('INSERT INTO tasks (title, status) VALUES (?, ?)', ('Task 1', 'pending'))
```

---

## æ¨¡å¼2ï¼šå¤šè¿›ç¨‹å…±äº«æ¨¡å¼

### æ¶æ„å›¾

```text
å¤šè¿›ç¨‹å…±äº«ç¼“å­˜æ¶æ„
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Process 1  â”‚  â”‚  Process 2  â”‚  â”‚  Process 3  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚                â”‚                â”‚
       â”‚         â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”         â”‚
       â”‚         â”‚ Shared Cacheâ”‚         â”‚
       â”‚         â”‚  (å†…å­˜å…±äº«)  â”‚         â”‚
       â”‚         â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜         â”‚
       â”‚                â”‚                â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚  Database File â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ç‰¹ç‚¹:
â€¢ å¤šè¿›ç¨‹å…±äº«ç¼“å­˜
â€¢ å‡å°‘å†…å­˜å ç”¨
â€¢ éœ€è¦æ“ä½œç³»ç»Ÿæ”¯æŒ
```

### å®ç°ï¼ˆShared-Cacheæ¨¡å¼ï¼‰

```python
import sqlite3
import multiprocessing

def worker(worker_id):
    """å·¥ä½œè¿›ç¨‹"""
    # å¯ç”¨å…±äº«ç¼“å­˜æ¨¡å¼
    conn = sqlite3.connect(
        'file:app.db?cache=shared',
        uri=True
    )

    # è¯»å–æ•°æ®
    for i in range(10):
        result = conn.execute('SELECT COUNT(*) FROM tasks').fetchone()
        print(f"Worker {worker_id}: {result[0]} tasks")

    conn.close()

if __name__ == '__main__':
    # åˆ›å»ºå¤šä¸ªå·¥ä½œè¿›ç¨‹
    processes = [
        multiprocessing.Process(target=worker, args=(i,))
        for i in range(4)
    ]

    for p in processes:
        p.start()
    for p in processes:
        p.join()
```

---

## æ¨¡å¼3ï¼šå®¢æˆ·ç«¯-æœåŠ¡å™¨æ¨¡å¼

### æ¶æ„å›¾

```text
SQLiteå®¢æˆ·ç«¯-æœåŠ¡å™¨æ¶æ„
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Client 1 â”‚  â”‚ Client 2 â”‚  â”‚ Client 3 â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
     â”‚             â”‚             â”‚
     â”‚  HTTP/gRPC  â”‚             â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
            â”‚ HTTP Server â”‚
            â”‚ (FastAPI)   â”‚
            â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
            â”‚  SQLite Lib â”‚
            â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
            â”‚  DB File    â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ç‰¹ç‚¹:
â€¢ ä¸­å¿ƒåŒ–æ§åˆ¶
â€¢ ç½‘ç»œè®¿é—®
â€¢ é€‚åˆå¤šå®¢æˆ·ç«¯
```

### å®ç°ï¼ˆFastAPIæœåŠ¡å™¨ï¼‰

```python
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import sqlite3
from contextlib import asynccontextmanager
from threading import Lock

# æ•°æ®åº“ç®¡ç†å™¨
class DatabaseManager:
    def __init__(self, db_path):
        self.conn = sqlite3.connect(db_path, check_same_thread=False)
        self.conn.row_factory = sqlite3.Row
        self.lock = Lock()

        # é…ç½®
        self.conn.execute('PRAGMA journal_mode=WAL')
        self.conn.execute('PRAGMA synchronous=NORMAL')

        # åˆ›å»ºè¡¨
        self.conn.execute('''
            CREATE TABLE IF NOT EXISTS tasks (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                title TEXT NOT NULL,
                status TEXT NOT NULL
            )
        ''')
        self.conn.commit()

    def query(self, sql, params=()):
        """è¯»æ“ä½œ"""
        cursor = self.conn.execute(sql, params)
        return [dict(row) for row in cursor.fetchall()]

    def execute(self, sql, params=()):
        """å†™æ“ä½œ"""
        with self.lock:
            self.conn.execute(sql, params)
            self.conn.commit()
            return self.conn.execute('SELECT last_insert_rowid()').fetchone()[0]

# å…¨å±€æ•°æ®åº“å®ä¾‹
db = DatabaseManager('app.db')

# FastAPIåº”ç”¨
app = FastAPI()

class Task(BaseModel):
    title: str
    status: str

@app.get("/tasks")
def get_tasks():
    """è·å–æ‰€æœ‰ä»»åŠ¡"""
    return db.query('SELECT * FROM tasks')

@app.get("/tasks/{task_id}")
def get_task(task_id: int):
    """è·å–å•ä¸ªä»»åŠ¡"""
    result = db.query('SELECT * FROM tasks WHERE id = ?', (task_id,))
    if not result:
        raise HTTPException(status_code=404, detail="Task not found")
    return result[0]

@app.post("/tasks")
def create_task(task: Task):
    """åˆ›å»ºä»»åŠ¡"""
    task_id = db.execute(
        'INSERT INTO tasks (title, status) VALUES (?, ?)',
        (task.title, task.status)
    )
    return {"id": task_id, **task.dict()}

@app.put("/tasks/{task_id}")
def update_task(task_id: int, task: Task):
    """æ›´æ–°ä»»åŠ¡"""
    db.execute(
        'UPDATE tasks SET title = ?, status = ? WHERE id = ?',
        (task.title, task.status, task_id)
    )
    return {"id": task_id, **task.dict()}

@app.delete("/tasks/{task_id}")
def delete_task(task_id: int):
    """åˆ é™¤ä»»åŠ¡"""
    db.execute('DELETE FROM tasks WHERE id = ?', (task_id,))
    return {"status": "deleted"}

# è¿è¡Œ: uvicorn main:app --reload
```

---

## æ¨¡å¼4ï¼šç¦»çº¿ä¼˜å…ˆæ¨¡å¼

### æ¶æ„å›¾

```text
ç¦»çº¿ä¼˜å…ˆæ¶æ„
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          Mobile App                     â”‚
â”‚                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ UI Layer   â”‚â—„â”€â”€â”€â”€â”€â”¤ ViewModelâ”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜     â”‚
â”‚                            â”‚           â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚                    â”‚ Local DB (RW) â”‚   â”‚
â”‚                    â”‚  (SQLite)     â”‚   â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                            â”‚           â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚                    â”‚ Sync Manager  â”‚   â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
                       Network?
                             â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  Remote Server  â”‚
                    â”‚  (PostgreSQL)   â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æµç¨‹:
1. UI â†’ ViewModel â†’ Local DB (å³æ—¶å“åº”)
2. Sync Manageråå°åŒæ­¥
3. ç½‘ç»œæ¢å¤æ—¶æ‰¹é‡ä¸Šä¼ 
```

### å®ç°ï¼ˆFlutter + SQLiteï¼‰

```dart
// lib/models/sync_item.dart
class SyncItem {
  final int? id;
  final String tableName;
  final String operation;  // INSERT/UPDATE/DELETE
  final Map<String, dynamic> data;
  final DateTime createdAt;
  final int retryCount;

  SyncItem({
    this.id,
    required this.tableName,
    required this.operation,
    required this.data,
    required this.createdAt,
    this.retryCount = 0,
  });
}

// lib/database/offline_first_db.dart
import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart';
import 'dart:convert';

class OfflineFirstDB {
  static Database? _database;

  Future<Database> get database async {
    if (_database != null) return _database!;
    _database = await _initDB();
    return _database!;
  }

  Future<Database> _initDB() async {
    final dbPath = await getDatabasesPath();
    final path = join(dbPath, 'offline_app.db');

    return await openDatabase(
      path,
      version: 1,
      onCreate: (db, version) async {
        // ä¸šåŠ¡è¡¨
        await db.execute('''
          CREATE TABLE tasks (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            server_id INTEGER,  -- æœåŠ¡å™¨ç«¯ID
            title TEXT NOT NULL,
            status TEXT NOT NULL,
            synced INTEGER DEFAULT 0,  -- æ˜¯å¦å·²åŒæ­¥
            created_at TEXT NOT NULL,
            updated_at TEXT NOT NULL
          )
        ''');

        // åŒæ­¥é˜Ÿåˆ—
        await db.execute('''
          CREATE TABLE sync_queue (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            table_name TEXT NOT NULL,
            operation TEXT NOT NULL,
            local_id INTEGER,
            data TEXT NOT NULL,  -- JSON
            retry_count INTEGER DEFAULT 0,
            created_at TEXT NOT NULL
          )
        ''');

        await db.execute('PRAGMA journal_mode=WAL');
      },
    );
  }

  // åˆ›å»ºä»»åŠ¡ï¼ˆç¦»çº¿æ“ä½œï¼‰
  Future<int> createTask(String title, String status) async {
    final db = await database;
    final now = DateTime.now().toIso8601String();

    return await db.transaction((txn) async {
      // æ’å…¥ä»»åŠ¡
      final taskId = await txn.insert('tasks', {
        'title': title,
        'status': status,
        'synced': 0,
        'created_at': now,
        'updated_at': now,
      });

      // åŠ å…¥åŒæ­¥é˜Ÿåˆ—
      await txn.insert('sync_queue', {
        'table_name': 'tasks',
        'operation': 'INSERT',
        'local_id': taskId,
        'data': json.encode({'title': title, 'status': status}),
        'created_at': now,
      });

      return taskId;
    });
  }

  // åå°åŒæ­¥
  Future<void> sync(Future<dynamic> Function(String, String, Map) apiCall) async {
    final db = await database;

    // è·å–å¾…åŒæ­¥é¡¹
    final pending = await db.query(
      'sync_queue',
      orderBy: 'id ASC',
      limit: 100,
    );

    for (final item in pending) {
      try {
        final tableName = item['table_name'] as String;
        final operation = item['operation'] as String;
        final data = json.decode(item['data'] as String);
        final localId = item['local_id'] as int?;

        // è°ƒç”¨API
        final response = await apiCall(tableName, operation, data);

        // æ›´æ–°server_id
        if (operation == 'INSERT' && localId != null && response['id'] != null) {
          await db.update(
            tableName,
            {'server_id': response['id'], 'synced': 1},
            where: 'id = ?',
            whereArgs: [localId],
          );
        }

        // åˆ é™¤åŒæ­¥é¡¹
        await db.delete('sync_queue', where: 'id = ?', whereArgs: [item['id']]);
      } catch (e) {
        // æ›´æ–°é‡è¯•æ¬¡æ•°
        await db.update(
          'sync_queue',
          {'retry_count': (item['retry_count'] as int) + 1},
          where: 'id = ?',
          whereArgs: [item['id']],
        );
      }
    }
  }
}
```

---

## æ¨¡å¼5ï¼šåµŒå…¥å¼ç¼“å­˜æ¨¡å¼

### æ¶æ„å›¾

```text
åµŒå…¥å¼ç¼“å­˜æ¶æ„
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       Application Server                â”‚
â”‚                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ HTTP API â”‚      â”‚ Business    â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜      â”‚ Logic       â”‚    â”‚
â”‚       â”‚            â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚       â”‚                   â”‚            â”‚
â”‚       â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚       â”‚         â”‚ Cache Layer      â”‚  â”‚
â”‚       â”‚         â”‚  (SQLite)        â”‚  â”‚
â”‚       â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚       â”‚                   â”‚            â”‚
â”‚       â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ Primary DB       â”‚  â”‚
â”‚                 â”‚  (PostgreSQL)    â”‚  â”‚
â”‚                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ç­–ç•¥:
â€¢ Read: Cache Hit â†’ è¿”å›; Cache Miss â†’ DB â†’ å†™Cache
â€¢ Write: æ›´æ–°DB â†’ åˆ é™¤Cache
```

### å®ç°ï¼ˆPythonç¼“å­˜å±‚ï¼‰

```python
import sqlite3
import json
import time
from functools import wraps

class SQLiteCache:
    """SQLiteç¼“å­˜å±‚"""

    def __init__(self, cache_db='cache.db', ttl=3600):
        self.conn = sqlite3.connect(cache_db, check_same_thread=False)
        self.ttl = ttl

        # é…ç½®ï¼ˆå†…å­˜ä¼˜å…ˆï¼‰
        self.conn.execute('PRAGMA journal_mode=MEMORY')
        self.conn.execute('PRAGMA synchronous=OFF')
        self.conn.execute('PRAGMA cache_size=-128000')  # 128MB

        # åˆ›å»ºç¼“å­˜è¡¨
        self.conn.execute('''
            CREATE TABLE IF NOT EXISTS cache (
                key TEXT PRIMARY KEY,
                value TEXT NOT NULL,
                expires_at REAL NOT NULL
            )
        ''')
        self.conn.execute('CREATE INDEX IF NOT EXISTS idx_expires ON cache(expires_at)')
        self.conn.commit()

        # å®šæœŸæ¸…ç†
        self._cleanup()

    def get(self, key):
        """è·å–ç¼“å­˜"""
        cursor = self.conn.execute(
            'SELECT value FROM cache WHERE key = ? AND expires_at > ?',
            (key, time.time())
        )
        row = cursor.fetchone()
        return json.loads(row[0]) if row else None

    def set(self, key, value, ttl=None):
        """è®¾ç½®ç¼“å­˜"""
        expires_at = time.time() + (ttl or self.ttl)
        self.conn.execute(
            '''INSERT OR REPLACE INTO cache (key, value, expires_at)
               VALUES (?, ?, ?)''',
            (key, json.dumps(value), expires_at)
        )
        self.conn.commit()

    def delete(self, key):
        """åˆ é™¤ç¼“å­˜"""
        self.conn.execute('DELETE FROM cache WHERE key = ?', (key,))
        self.conn.commit()

    def _cleanup(self):
        """æ¸…ç†è¿‡æœŸç¼“å­˜"""
        self.conn.execute('DELETE FROM cache WHERE expires_at <= ?', (time.time(),))
        self.conn.commit()

# ç¼“å­˜è£…é¥°å™¨
cache = SQLiteCache()

def cached(key_func, ttl=3600):
    """ç¼“å­˜è£…é¥°å™¨"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            # ç”Ÿæˆç¼“å­˜é”®
            key = key_func(*args, **kwargs)

            # å°è¯•ä»ç¼“å­˜è¯»å–
            cached_value = cache.get(key)
            if cached_value is not None:
                print(f"Cache HIT: {key}")
                return cached_value

            # ç¼“å­˜æœªå‘½ä¸­ï¼Œæ‰§è¡Œå‡½æ•°
            print(f"Cache MISS: {key}")
            result = func(*args, **kwargs)

            # å†™å…¥ç¼“å­˜
            cache.set(key, result, ttl)
            return result
        return wrapper
    return decorator

# ä½¿ç”¨ç¤ºä¾‹
@cached(key_func=lambda user_id: f"user:{user_id}", ttl=3600)
def get_user(user_id):
    """è·å–ç”¨æˆ·ï¼ˆä»æ•°æ®åº“ï¼‰"""
    import psycopg2
    conn = psycopg2.connect("postgresql://...")
    cursor = conn.execute('SELECT * FROM users WHERE id = %s', (user_id,))
    return cursor.fetchone()

# è°ƒç”¨
user = get_user(123)  # Cache MISSï¼Œä»æ•°æ®åº“è¯»å–
user = get_user(123)  # Cache HITï¼Œä»SQLiteè¯»å–ï¼ˆå¿«ï¼‰
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0
**æœ€åæ›´æ–°**: 2025-12-04
