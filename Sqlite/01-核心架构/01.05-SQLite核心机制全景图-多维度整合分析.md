# SQLite核心机制全景图：多维度整合分析

> **创建日期**：2025-12-04
> **版本**：SQLite 3.45.x / 3.47.x
> **难度**：⭐⭐⭐⭐⭐
> **前置知识**：事务理论、操作系统、C语言、形式化方法

---

## 📋 文档说明

本文档提供SQLite核心机制的**全景图式整合分析**，从多个维度全面梳理：

- **核心机制**：MVCC（多版本并发控制）、事务ACID、WAL（写前日志）、锁机制
- **流程维度**：程序控制流、执行流、数据流、版本流
- **视角维度**：使用者、设计者、程序员、数据转换
- **表征维度**：思维导图、流程图、交互图、矩阵对比、决策树、证明树
- **理论维度**：形式化证明、设计权衡、性能分析

---

## 📑 目录

- [SQLite核心机制全景图：多维度整合分析](#sqlite核心机制全景图多维度整合分析)
  - [📋 文档说明](#-文档说明)
  - [📑 目录](#-目录)
  - [一、核心概念全景图](#一核心概念全景图)
    - [1.1 SQLite核心机制思维导图](#11-sqlite核心机制思维导图)
    - [1.2 知识图谱：概念关系网络](#12-知识图谱概念关系网络)
    - [1.3 架构分层矩阵](#13-架构分层矩阵)
  - [二、事务ACID实现全解析](#二事务acid实现全解析)
    - [2.1 ACID概念对齐](#21-acid概念对齐)
    - [2.2 ACID实现机制矩阵](#22-acid实现机制矩阵)
    - [2.3 事务状态机](#23-事务状态机)
    - [2.4 形式化定义与证明](#24-形式化定义与证明)
  - [三、锁机制深度剖析](#三锁机制深度剖析)
    - [3.1 五级锁状态机](#31-五级锁状态机)
    - [3.2 锁升级路径与决策树](#32-锁升级路径与决策树)
    - [3.3 锁兼容性矩阵](#33-锁兼容性矩阵)
    - [3.4 死锁预防证明](#34-死锁预防证明)
  - [四、WAL模式完整解析](#四wal模式完整解析)
    - [4.1 WAL架构与数据流](#41-wal架构与数据流)
    - [4.2 WAL vs Rollback Journal对比矩阵](#42-wal-vs-rollback-journal对比矩阵)
    - [4.3 WAL读写交互时序图](#43-wal读写交互时序图)
    - [4.4 Checkpoint机制与策略决策树](#44-checkpoint机制与策略决策树)
    - [4.5 WAL形式化验证](#45-wal形式化验证)
  - [五、并发控制：锁机制 vs MVCC](#五并发控制锁机制-vs-mvcc)
    - [5.1 SQLite并发模型](#51-sqlite并发模型)
    - [5.2 SQLite锁机制 vs PostgreSQL MVCC对比](#52-sqlite锁机制-vs-postgresql-mvcc对比)
    - [5.3 快照隔离实现](#53-快照隔离实现)
    - [5.4 并发性能分析](#54-并发性能分析)
  - [六、程序执行流全景](#六程序执行流全景)
    - [6.1 SQL语句执行控制流](#61-sql语句执行控制流)
    - [6.2 事务执行控制流](#62-事务执行控制流)
    - [6.3 并发读写交互流程](#63-并发读写交互流程)
    - [6.4 崩溃恢复控制流](#64-崩溃恢复控制流)
  - [七、数据流与版本流](#七数据流与版本流)
    - [7.1 数据写入路径](#71-数据写入路径)
    - [7.2 数据读取路径](#72-数据读取路径)
    - [7.3 WAL数据版本流](#73-wal数据版本流)
    - [7.4 页面生命周期](#74-页面生命周期)
  - [八、多视角全面分析](#八多视角全面分析)
    - [8.1 使用者视角](#81-使用者视角)
    - [8.2 设计者视角](#82-设计者视角)
    - [8.3 程序员视角](#83-程序员视角)
    - [8.4 数据转换视角](#84-数据转换视角)
  - [九、形式化证明体系](#九形式化证明体系)
    - [9.1 ACID属性形式化证明](#91-acid属性形式化证明)
    - [9.2 锁机制正确性证明](#92-锁机制正确性证明)
    - [9.3 WAL崩溃恢复证明](#93-wal崩溃恢复证明)
    - [9.4 快照隔离正确性证明](#94-快照隔离正确性证明)
  - [十、设计权衡与决策](#十设计权衡与决策)
    - [10.1 设计决策树](#101-设计决策树)
    - [10.2 性能权衡矩阵](#102-性能权衡矩阵)
    - [10.3 场景选型决策](#103-场景选型决策)
  - [相关资源](#相关资源)
    - [相关文档](#相关文档)
    - [外部资源](#外部资源)

---

## 一、核心概念全景图

### 1.1 SQLite核心机制思维导图

```text
SQLite核心机制知识全景图
══════════════════════════════════════════════════════════════════════════════

                            SQLite核心机制
                                  │
        ┌─────────────────────────┼─────────────────────────┐
        │                         │                         │
        ▼                         ▼                         ▼
    事务ACID                  并发控制                   持久化
        │                         │                         │
  ┌─────┼─────┐           ┌───────┼───────┐         ┌───────┼───────┐
  │     │     │           │       │       │         │       │       │
  ▼     ▼     ▼           ▼       ▼       ▼         ▼       ▼       ▼
原子性 一致性 隔离性      锁机制  快照隔离 死锁预防   WAL模式 日志回滚 恢复机制
  │     │     │           │       │       │         │       │       │
  │     │     │           │       │       │         │       │       │
  ▼     ▼     ▼           ▼       ▼       ▼         ▼       ▼       ▼
日志   约束  锁+MVCC   5级锁状态  事务快照  有序获取  WAL文件 检查点  崩溃恢复

═══════════════════════════════════════════════════════════════════════════
核心特性:
├── 单写者模型（Single Writer）
├── 多读者模型（Multiple Readers）
├── WAL模式实现快照隔离
├── 读不阻塞写（WAL模式）
└── 嵌入式数据库（Zero-configuration）
═══════════════════════════════════════════════════════════════════════════

实现层次:
┌─────────────────────────────────────────────────────────────────────────┐
│ 应用层          │ SQL语句 → 事务控制 → 结果返回                         │
├─────────────────────────────────────────────────────────────────────────┤
│ 接口层          │ sqlite3_open/exec/step/close                         │
├─────────────────────────────────────────────────────────────────────────┤
│ 编译层          │ Parser → Tokenizer → Code Generator                  │
├─────────────────────────────────────────────────────────────────────────┤
│ 虚拟机层        │ VDBE (Virtual Database Engine)                       │
├─────────────────────────────────────────────────────────────────────────┤
│ 事务层          │ Pager → Transactions → Locking                       │
├─────────────────────────────────────────────────────────────────────────┤
│ 存储层          │ B-Tree → Page Cache → OS Interface                   │
├─────────────────────────────────────────────────────────────────────────┤
│ 持久化层        │ WAL/Journal → Checkpoint → Crash Recovery            │
└─────────────────────────────────────────────────────────────────────────┘
```

### 1.2 知识图谱：概念关系网络

```text
SQLite核心概念关系图谱
══════════════════════════════════════════════════════════════════════════════

                            Transaction（事务）
                                   │
                    ┌──────────────┼──────────────┐
                    │              │              │
                    ▼              ▼              ▼
                Atomicity      Consistency   Isolation
                （原子性）      （一致性）    （隔离性）
                    │              │              │
              ┌─────┴─────┐        │        ┌────┴────┐
              │           │        │        │         │
              ▼           ▼        ▼        ▼         ▼
           Journal       WAL    Constraints Locks  Snapshots
          （日志）     （WAL）   （约束）   （锁）  （快照）
              │           │        │        │         │
              │           │        │        │         │
        ┌─────┴───┐  ┌────┴────┐  │   ┌────┴────┐   │
        ▼         ▼  ▼         ▼  ▼   ▼         ▼   ▼
    Rollback  Commit WAL    Checkpoint CHECK FOREIGN Snapshot
     Mode     Header  Frames  Modes   Triggers KEY   Isolation
                        │               │             │
                        │               │             │
                   ┌────┴────┐     ┌────┴────┐  ┌────┴────┐
                   ▼         ▼     ▼         ▼  ▼         ▼
                Readers  Writers  READ    SERIALIZABLE WAL
                         Single   COMMITTED            Checkpoint

═══════════════════════════════════════════════════════════════════════════
关键依赖关系:
• Atomicity ← Journal/WAL （原子性依赖日志）
• Isolation ← Locks + Snapshots （隔离性依赖锁和快照）
• Durability ← WAL + fsync （持久性依赖WAL和同步）
• Consistency ← Constraints + Triggers （一致性依赖约束和触发器）
═══════════════════════════════════════════════════════════════════════════
```

### 1.3 架构分层矩阵

```text
SQLite架构分层对比矩阵
══════════════════════════════════════════════════════════════════════════════

┌──────────┬────────────┬────────────────┬──────────────────┬─────────────┐
│ 层次     │ 模块       │ 核心功能       │ 关键数据结构     │ 源码文件    │
├──────────┼────────────┼────────────────┼──────────────────┼─────────────┤
│ 应用层   │ SQL接口    │ API调用        │ sqlite3*         │ main.c      │
│          │            │ 连接管理       │ sqlite3_stmt*    │             │
├──────────┼────────────┼────────────────┼──────────────────┼─────────────┤
│ 编译层   │ Parser     │ SQL解析        │ Parse            │ parse.y     │
│          │ Tokenizer  │ 词法分析       │ Token            │ tokenize.c  │
│          │ Code Gen   │ 字节码生成     │ Vdbe             │ build.c     │
├──────────┼────────────┼────────────────┼──────────────────┼─────────────┤
│ 执行层   │ VDBE       │ 字节码执行     │ VdbeOp           │ vdbe.c      │
│          │            │ 操作码解释     │ Mem              │ vdbeaux.c   │
├──────────┼────────────┼────────────────┼──────────────────┼─────────────┤
│ 事务层   │ Pager      │ 页面缓存       │ Pager            │ pager.c     │
│          │            │ 事务管理       │ PgHdr            │             │
│          │            │ 锁控制         │ PCache           │             │
├──────────┼────────────┼────────────────┼──────────────────┼─────────────┤
│ 存储层   │ B-Tree     │ 索引/表存储    │ Btree            │ btree.c     │
│          │            │ 游标操作       │ BtCursor         │             │
│          │ Page Cache │ 页面缓存       │ PgHdr1           │ pcache.c    │
├──────────┼────────────┼────────────────┼──────────────────┼─────────────┤
│ 持久化层 │ WAL        │ 写前日志       │ Wal              │ wal.c       │
│          │ Journal    │ 回滚日志       │ JournalHeader    │             │
│          │ VFS        │ 文件IO         │ sqlite3_vfs      │ os.c        │
├──────────┼────────────┼────────────────┼──────────────────┼─────────────┤
│ OS层     │ OS接口     │ 文件操作       │ sqlite3_file     │ os_unix.c   │
│          │            │ 锁原语         │                  │ os_win.c    │
└──────────┴────────────┴────────────────┴──────────────────┴─────────────┘

关键交互:
• 应用层 ↔ VDBE: sqlite3_step() → VdbeExec()
• VDBE ↔ B-Tree: sqlite3BtreeCursor() → B-Tree操作
• B-Tree ↔ Pager: sqlite3PagerGet() → 页面请求
• Pager ↔ WAL: sqlite3WalRead/Write() → WAL操作
• Pager ↔ OS: sqlite3OsRead/Write() → 文件IO
```

---

## 二、事务ACID实现全解析

### 2.1 ACID概念对齐

```text
ACID概念全面对齐
══════════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────────┐
│ A - Atomicity（原子性）                                                  │
├─────────────────────────────────────────────────────────────────────────┤
│ 定义: 事务是不可分割的工作单元，要么全部完成，要么全部不执行            │
│                                                                         │
│ SQLite实现:                                                             │
│  • Rollback Journal模式: 写入前先记录原始页面到日志文件               │
│  • WAL模式: 原子性提交标记（commit record）                             │
│  • 崩溃恢复: 日志回放确保原子性                                         │
│                                                                         │
│ 形式化表达:                                                             │
│  ∀ Transaction T:                                                       │
│    (Committed(T) ⇒ AllOpsApplied(T)) ∧                                 │
│    (¬Committed(T) ⇒ NoOpsApplied(T))                                   │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│ C - Consistency（一致性）                                                │
├─────────────────────────────────────────────────────────────────────────┤
│ 定义: 事务执行前后，数据库从一个一致性状态转移到另一个一致性状态        │
│                                                                         │
│ SQLite实现:                                                             │
│  • 约束检查: CHECK, NOT NULL, UNIQUE, PRIMARY KEY                       │
│  • 外键约束: FOREIGN KEY（需启用foreign_keys pragma）                   │
│  • 触发器: BEFORE/AFTER triggers确保业务规则                            │
│                                                                         │
│ 形式化表达:                                                             │
│  ∀ Transaction T:                                                       │
│    Consistent(DB₀) ∧ ValidTrans(T) ⇒                                   │
│    Consistent(Apply(DB₀, T))                                           │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│ I - Isolation（隔离性）                                                  │
├─────────────────────────────────────────────────────────────────────────┤
│ 定义: 并发执行的事务互不干扰，每个事务感觉不到其他事务的存在            │
│                                                                         │
│ SQLite实现:                                                             │
│  • 锁机制: 5级锁（UNLOCKED/SHARED/RESERVED/PENDING/EXCLUSIVE）         │
│  • 快照隔离: WAL模式提供事务级快照（Snapshot Isolation）                │
│  • 单写者模型: 同时最多1个写事务                                        │
│                                                                         │
│ 隔离级别:                                                               │
│  • READ UNCOMMITTED（pragma read_uncommitted=1）                       │
│  • READ COMMITTED（默认，WAL模式）                                      │
│  • SERIALIZABLE（独占锁）                                               │
│                                                                         │
│ 形式化表达:                                                             │
│  ∀ Transaction T₁, T₂:                                                  │
│    Concurrent(T₁, T₂) ⇒                                                │
│    ∃ Serial Schedule S: Result(S) = Result(T₁ ∥ T₂)                   │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│ D - Durability（持久性）                                                 │
├─────────────────────────────────────────────────────────────────────────┤
│ 定义: 一旦事务提交，其结果永久保存，即使系统崩溃也不会丢失              │
│                                                                         │
│ SQLite实现:                                                             │
│  • fsync: 强制刷新数据到磁盘（synchronous pragma）                      │
│  • WAL持久化: commit record刷盘后事务才算提交                           │
│  • 崩溃恢复: 重启后WAL回放确保已提交事务生效                            │
│                                                                         │
│ 同步模式:                                                               │
│  • FULL: 每次写入都fsync（最安全，性能最低）                            │
│  • NORMAL: 关键点fsync（平衡）                                          │
│  • OFF: 不fsync（最快，可能丢数据）                                     │
│                                                                         │
│ 形式化表达:                                                             │
│  ∀ Transaction T:                                                       │
│    Committed(T) ⇒                                                       │
│    ∀ Future State S: Reflected(T, S)                                   │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.2 ACID实现机制矩阵

```text
ACID实现机制对比矩阵
══════════════════════════════════════════════════════════════════════════════

┌──────────┬───────────────┬───────────────────┬─────────────────────────┐
│ ACID属性 │ Rollback模式  │ WAL模式           │ 形式化保证              │
├──────────┼───────────────┼───────────────────┼─────────────────────────┤
│ 原子性   │ 回滚日志      │ WAL commit record │ 全或无定理              │
│ (A)      │ 崩溃恢复      │ 原子性提交标记    │ ∀T: All(T) ∨ None(T)   │
│          │ 页面级回滚    │ 检查点原子性      │                         │
├──────────┼───────────────┼───────────────────┼─────────────────────────┤
│ 一致性   │ 约束检查      │ 约束检查          │ 不变式保持定理          │
│ (C)      │ 触发器        │ 触发器            │ ∀T: Inv(S₀)⇒Inv(S₁)    │
│          │ 外键级联      │ 外键级联          │                         │
├──────────┼───────────────┼───────────────────┼─────────────────────────┤
│ 隔离性   │ 独占锁        │ 快照隔离+锁       │ 可串行化定理            │
│ (I)      │ 单写者模型    │ 多读者单写者      │ ∃S: Result(S)=Result(C) │
│          │ 读写互斥      │ 读不阻塞写        │                         │
├──────────┼───────────────┼───────────────────┼─────────────────────────┤
│ 持久性   │ fsync日志     │ fsync WAL         │ 持久化定理              │
│ (D)      │ 同步模式      │ checkpoint持久化  │ ∀T: Commit(T)⇒Persist(T)│
│          │ 页面刷盘      │ WAL帧刷盘         │                         │
└──────────┴───────────────┴───────────────────┴─────────────────────────┘

性能对比:
┌──────────┬───────────────┬───────────────────┬─────────────────────────┐
│ 性能指标 │ Rollback模式  │ WAL模式           │ 提升比例                │
├──────────┼───────────────┼───────────────────┼─────────────────────────┤
│ 写性能   │ 基准 (1x)     │ 1.5-2x            │ +50%~100%               │
│ 读性能   │ 基准 (1x)     │ 1.2-1.5x          │ +20%~50%                │
│ 并发度   │ 低（读写互斥）│ 高（读不阻塞写）  │ 显著提升                │
│ 恢复速度 │ 快            │ 中等              │ WAL需回放               │
└──────────┴───────────────┴───────────────────┴─────────────────────────┘
```

### 2.3 事务状态机

```text
SQLite事务状态机
══════════════════════════════════════════════════════════════════════════════

状态转换图:

    ┌─────────────────┐
    │   UNLOCKED      │ ← 初始状态，无锁
    │  (No Transaction)│
    └────────┬─────────┘
             │ BEGIN / SELECT
             ▼
    ┌─────────────────┐
    │   SHARED        │ ← 读事务，持有SHARED锁
    │ (Read Transaction)
    └────────┬─────────┘
             │ INSERT/UPDATE/DELETE
             ▼
    ┌─────────────────┐
    │   RESERVED      │ ← 写事务准备阶段，持有RESERVED锁
    │ (Write Preparing)│ （允许其他读事务继续）
    └────────┬─────────┘
             │ COMMIT开始 / 需要刷新数据
             ▼
    ┌─────────────────┐
    │   PENDING       │ ← 等待所有读者完成
    │ (Waiting Readers)│ （不允许新的读事务）
    └────────┬─────────┘
             │ 所有读者完成
             ▼
    ┌─────────────────┐
    │   EXCLUSIVE     │ ← 独占锁，写入数据
    │ (Writing Data)  │
    └────────┬─────────┘
             │ COMMIT完成
             ▼
    ┌─────────────────┐
    │   UNLOCKED      │ ← 释放所有锁
    └─────────────────┘

═══════════════════════════════════════════════════════════════════════════

WAL模式事务状态机:

    ┌─────────────────┐
    │   NO_TRANSACTION│ ← 初始状态
    └────────┬─────────┘
             │ BEGIN
             ▼
    ┌─────────────────┐
    │   READING       │ ← 读事务，获取WAL快照
    │ (Snapshot taken)│
    └────────┬─────────┘
             │ 写操作
             ▼
    ┌─────────────────┐
    │   WRITING       │ ← 写事务，追加WAL帧
    │ (Appending WAL) │
    └────────┬─────────┘
             │ COMMIT
             ▼
    ┌─────────────────┐
    │   COMMITTING    │ ← 写入commit record + fsync
    │ (Fsyncing)      │
    └────────┬─────────┘
             │ 完成
             ▼
    ┌─────────────────┐
    │   NO_TRANSACTION│ ← 释放锁
    └─────────────────┘

═══════════════════════════════════════════════════════════════════════════

状态转换表:

┌──────────────┬─────────────┬─────────────┬─────────────────────────┐
│ 当前状态     │ 操作        │ 目标状态    │ 条件/副作用             │
├──────────────┼─────────────┼─────────────┼─────────────────────────┤
│ UNLOCKED     │ BEGIN/SELECT│ SHARED      │ 获取SHARED锁            │
│ SHARED       │ UPDATE      │ RESERVED    │ 获取RESERVED锁          │
│ RESERVED     │ COMMIT      │ PENDING     │ 等待读者离开            │
│ PENDING      │ (auto)      │ EXCLUSIVE   │ 所有读者已离开          │
│ EXCLUSIVE    │ COMMIT      │ UNLOCKED    │ 写入完成，释放锁        │
│ SHARED       │ ROLLBACK    │ UNLOCKED    │ 释放SHARED锁            │
│ RESERVED     │ ROLLBACK    │ UNLOCKED    │ 撤销更改，释放锁        │
└──────────────┴─────────────┴─────────────┴─────────────────────────┘
```

### 2.4 形式化定义与证明

```text
事务ACID形式化证明
══════════════════════════════════════════════════════════════════════════════

【定理1】原子性保证定理

定义:
  Transaction T = {op₁, op₂, ..., opₙ}
  Committed(T) := commit record written and fsynced
  Applied(T, DB) := all operations of T applied to DB

定理: ∀ Transaction T:
  Committed(T) ⇒ Applied(T, DB) ∧
  ¬Committed(T) ⇒ ¬Applied(T, DB)

证明:
  Case 1: WAL模式
  (1) 事务T的所有操作追加到WAL文件（WAL帧）
  (2) 写入commit record C
  (3) fsync(WAL文件)
  (4) 只有fsync成功后，Committed(T)=true
  (5) 崩溃恢复时，只回放有commit record的事务
  (6) 因此，Committed(T) ⇔ Applied(T, DB) □

  Case 2: Rollback Journal模式
  (1) 写操作前，原始页面写入journal
  (2) 写入新数据到数据库文件
  (3) fsync(数据库文件)
  (4) 删除journal文件
  (5) 崩溃时，若journal存在，回滚到原始状态
  (6) 因此，¬Committed(T) ⇒ ¬Applied(T, DB) □

═══════════════════════════════════════════════════════════════════════════

【定理2】隔离性保证定理（快照隔离）

定义:
  Snapshot(T) := WAL中T开始时的数据库快照
  ReadSet(T) := T读取的数据项集合
  WriteSet(T) := T写入的数据项集合

定理: ∀ T₁, T₂并发事务:
  Overlap(T₁, T₂) ∧ Committed(T₁) ∧ Committed(T₂) ⇒
  (WriteSet(T₁) ∩ WriteSet(T₂) = ∅)

证明:
  (1) SQLite使用单写者模型（Single Writer）
  (2) 同一时刻最多一个事务持有RESERVED或更高级锁
  (3) 写事务必须获取RESERVED锁才能修改数据
  (4) 因此，T₁和T₂不能同时持有写锁
  (5) 故 WriteSet(T₁) ∩ WriteSet(T₂) = ∅ □

推论: SQLite WAL模式提供快照隔离（Snapshot Isolation），避免了：
  • 脏读（Dirty Read）- 读事务使用快照
  • 不可重复读（Non-repeatable Read）- 快照不变
  • 写倾斜（Write Skew）- 单写者模型

═══════════════════════════════════════════════════════════════════════════

【定理3】持久性保证定理

定义:
  Persistent(T) := 事务T的结果永久保存
  Committed(T) := commit record fsynced

定理: ∀ Transaction T:
  Committed(T) ⇒ ∀ Future Time t: Persistent(T, t)

证明:
  (1) WAL模式下，commit record写入WAL并fsync
  (2) fsync保证数据持久化到存储介质
  (3) 崩溃恢复时，WAL回放包含commit record的事务
  (4) Checkpoint将WAL合并到主数据库，持久化保持
  (5) 因此，Committed(T) ⇒ ∀t: Persistent(T, t) □

附加条件:
  • synchronous=FULL: 每次写入fsync
  • synchronous=NORMAL: 关键点fsync（推荐）
  • synchronous=OFF: 不保证持久性（风险）

═══════════════════════════════════════════════════════════════════════════

【定理4】一致性保持定理

定义:
  Consistent(DB) := ∀ Constraint C: Satisfied(C, DB)
  ValidTrans(T) := T遵守所有约束检查

定理: ∀ Transaction T:
  Consistent(DB₀) ∧ ValidTrans(T) ⇒ Consistent(Apply(DB₀, T))

证明:
  (1) SQLite在事务执行时检查所有约束
  (2) 约束包括: CHECK, NOT NULL, UNIQUE, PK, FK
  (3) 若约束违反，事务回滚，DB保持DB₀状态
  (4) 若所有约束满足，Apply(DB₀, T)生成DB₁
  (5) 由于ValidTrans(T)，DB₁满足所有约束
  (6) 因此，Consistent(DB₁) □

═══════════════════════════════════════════════════════════════════════════
```

---

## 三、锁机制深度剖析

### 3.1 五级锁状态机

```text
SQLite五级锁状态机详解
══════════════════════════════════════════════════════════════════════════════

锁级别定义:

┌──────────────────────────────────────────────────────────────────────────┐
│ 1. UNLOCKED（无锁）                                                       │
├──────────────────────────────────────────────────────────────────────────┤
│ • 状态: 数据库未被访问                                                   │
│ • 权限: 无读写权限                                                       │
│ • 兼容: 与所有锁兼容                                                     │
│ • 用途: 初始状态/事务结束状态                                            │
└──────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────┐
│ 2. SHARED（共享锁）                                                       │
├──────────────────────────────────────────────────────────────────────────┤
│ • 状态: 数据库可读                                                       │
│ • 权限: 读权限                                                           │
│ • 兼容: 与SHARED、RESERVED兼容                                           │
│ • 冲突: 与PENDING、EXCLUSIVE冲突                                         │
│ • 用途: 读事务（SELECT）                                                 │
│ • 特点: 多个事务可同时持有SHARED锁                                       │
└──────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────┐
│ 3. RESERVED（保留锁）                                                     │
├──────────────────────────────────────────────────────────────────────────┤
│ • 状态: 写事务准备中                                                     │
│ • 权限: 读+写准备                                                        │
│ • 兼容: 与SHARED兼容                                                     │
│ • 冲突: 与RESERVED、PENDING、EXCLUSIVE冲突                               │
│ • 用途: 写事务开始（INSERT/UPDATE/DELETE）                               │
│ • 特点: 只有一个事务可持有RESERVED锁                                     │
│         允许其他读事务继续                                               │
└──────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────┐
│ 4. PENDING（等待锁）                                                      │
├──────────────────────────────────────────────────────────────────────────┤
│ • 状态: 等待所有读者完成                                                 │
│ • 权限: 禁止新读者                                                       │
│ • 兼容: 与现有SHARED兼容                                                 │
│ • 冲突: 与新SHARED、RESERVED、EXCLUSIVE冲突                              │
│ • 用途: COMMIT前的过渡状态                                               │
│ • 特点: 阻止新读者进入，等待现有读者完成                                 │
└──────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────┐
│ 5. EXCLUSIVE（独占锁）                                                    │
├──────────────────────────────────────────────────────────────────────────┤
│ • 状态: 独占访问                                                         │
│ • 权限: 完全读写权限                                                     │
│ • 兼容: 与所有锁冲突                                                     │
│ • 用途: 写入数据到数据库文件                                             │
│ • 特点: 完全独占数据库，所有其他事务被阻塞                               │
└──────────────────────────────────────────────────────────────────────────┘

═══════════════════════════════════════════════════════════════════════════

锁升级路径:

读事务路径:
  UNLOCKED → SHARED → UNLOCKED

写事务路径（Rollback模式）:
  UNLOCKED → SHARED → RESERVED → PENDING → EXCLUSIVE → UNLOCKED
      │         │         │          │           │           │
      └─BEGIN───┴─UPDATE──┴─COMMIT───┴─等待读者──┴─写入数据──┴─释放锁

═══════════════════════════════════════════════════════════════════════════

锁状态转换图:

                    BEGIN/SELECT
    ┌──────────┐ ──────────────→ ┌──────────┐
    │UNLOCKED  │                  │ SHARED   │
    └────┬─────┘ ←────────────── └────┬─────┘
         │                              │
         │                              │ INSERT/UPDATE/DELETE
         │                              ▼
         │                       ┌──────────┐
         │                       │ RESERVED │
         │                       └────┬─────┘
         │                              │
         │                              │ COMMIT开始
         │                              ▼
         │                       ┌──────────┐
         │                       │ PENDING  │
         │                       └────┬─────┘
         │                              │
         │                              │ 所有读者完成
         │                              ▼
         │                       ┌──────────┐
         │                       │EXCLUSIVE │
         │                       └────┬─────┘
         │                              │
         └──────────────────────────────┘ COMMIT完成

═══════════════════════════════════════════════════════════════════════════
```

### 3.2 锁升级路径与决策树

```text
锁升级决策树
══════════════════════════════════════════════════════════════════════════════

                      ┌─────────────────┐
                      │ 需要数据库操作？│
                      └────────┬────────┘
                               │
                ┌──────────────┴──────────────┐
                │                             │
                ▼                             ▼
        ┌───────────────┐             ┌───────────────┐
        │ 读操作（SELECT）│             │ 写操作（UPDATE）│
        └───────┬───────┘             └───────┬───────┘
                │                             │
                ▼                             ▼
        获取SHARED锁                  获取SHARED锁
        （如果没有）                  （如果没有）
                │                             │
                │                             ▼
                │                     尝试升级到RESERVED锁
                │                             │
                │                      ┌──────┴──────┐
                │                      │             │
                │                      ▼             ▼
                │               成功（唯一写者） 失败（SQLITE_BUSY）
                │                      │             │
                │                      │             └→ 等待/重试
                │                      ▼
                │                 写入缓存/日志
                │                      │
                │                      ▼
                │               需要COMMIT？
                │                      │
                │                      ▼
                │               尝试升级到PENDING锁
                │                      │
                │                      ▼
                │               等待所有SHARED锁释放
                │                      │
                │                      ▼
                │               升级到EXCLUSIVE锁
                │                      │
                │                      ▼
                │               写入数据到磁盘
                │                      │
                │                      ▼
                │               释放所有锁（UNLOCKED）
                │                      │
                └──────────────────────┘
                         │
                         ▼
                   事务完成

═══════════════════════════════════════════════════════════════════════════

WAL模式锁决策树:

                      ┌─────────────────┐
                      │ 需要数据库操作？│
                      └────────┬────────┘
                               │
                ┌──────────────┴──────────────┐
                │                             │
                ▼                             ▼
        ┌───────────────┐             ┌───────────────┐
        │ 读操作（SELECT）│             │ 写操作（UPDATE）│
        └───────┬───────┘             └───────┬───────┘
                │                             │
                ▼                             ▼
        获取WAL读锁                    获取WAL写锁
        获取事务快照                   （独占，阻塞其他写者）
                │                             │
                │                             ▼
                │                     追加WAL帧到WAL文件
                │                             │
                │                             ▼
                │                     需要COMMIT？
                │                             │
                │                             ▼
                │                     写入commit record
                │                             │
                │                             ▼
                │                     fsync(WAL文件)
                │                             │
                │                             ▼
                │                     释放WAL写锁
                │                             │
                └─────────────────────────────┘
                               │
                               ▼
                         事务完成

特点:
• WAL模式: 读不阻塞写，写不阻塞读
• Rollback模式: 读写互斥（EXCLUSIVE锁阶段）
```

### 3.3 锁兼容性矩阵

```text
锁兼容性矩阵
══════════════════════════════════════════════════════════════════════════════

┌──────────────┬──────────┬─────────┬──────────┬─────────┬───────────┐
│ 请求锁\持有锁│ UNLOCKED │ SHARED  │ RESERVED │ PENDING │ EXCLUSIVE │
├──────────────┼──────────┼─────────┼──────────┼─────────┼───────────┤
│ UNLOCKED     │    ✓     │    ✓    │    ✓     │    ✓    │     ✓     │
├──────────────┼──────────┼─────────┼──────────┼─────────┼───────────┤
│ SHARED       │    ✓     │    ✓    │    ✓     │    ✗    │     ✗     │
├──────────────┼──────────┼─────────┼──────────┼─────────┼───────────┤
│ RESERVED     │    ✓     │    ✓    │    ✗     │    ✗    │     ✗     │
├──────────────┼──────────┼─────────┼──────────┼─────────┼───────────┤
│ PENDING      │    ✓     │  ✓(旧)  │    ✗     │    ✗    │     ✗     │
├──────────────┼──────────┼─────────┼──────────┼─────────┼───────────┤
│ EXCLUSIVE    │    ✓     │    ✗    │    ✗     │    ✗    │     ✗     │
└──────────────┴──────────┴─────────┴──────────┴─────────┴───────────┘

✓ = 兼容
✗ = 冲突
✓(旧) = 仅与已存在的SHARED锁兼容，不允许新SHARED锁

═══════════════════════════════════════════════════════════════════════════

锁升级可行性矩阵:

┌──────────────┬───────────────────────────────────────────────────────┐
│ 当前锁       │ 可升级到                                              │
├──────────────┼───────────────────────────────────────────────────────┤
│ UNLOCKED     │ SHARED, RESERVED, PENDING, EXCLUSIVE                  │
├──────────────┼───────────────────────────────────────────────────────┤
│ SHARED       │ RESERVED (如果无其他RESERVED)                         │
│              │ 无法直接升级到PENDING/EXCLUSIVE                       │
├──────────────┼───────────────────────────────────────────────────────┤
│ RESERVED     │ PENDING (开始COMMIT)                                  │
├──────────────┼───────────────────────────────────────────────────────┤
│ PENDING      │ EXCLUSIVE (所有SHARED锁释放后)                        │
├──────────────┼───────────────────────────────────────────────────────┤
│ EXCLUSIVE    │ 无需升级（最高级锁）                                  │
└──────────────┴───────────────────────────────────────────────────────┘

═══════════════════════════════════════════════════════════════════════════

并发场景矩阵:

┌────────────────┬─────────┬─────────┬──────────┬──────────────────┐
│ 场景           │ 读事务  │ 写事务  │ 新读事务 │ 说明             │
├────────────────┼─────────┼─────────┼──────────┼──────────────────┤
│ 无事务         │   ✓     │    ✓    │    ✓     │ 自由访问         │
├────────────────┼─────────┼─────────┼──────────┼──────────────────┤
│ 1个读事务      │   ✓     │    ✓    │    ✓     │ SHARED锁         │
├────────────────┼─────────┼─────────┼──────────┼──────────────────┤
│ 多个读事务     │   ✓     │    ✓    │    ✓     │ 多个SHARED锁     │
├────────────────┼─────────┼─────────┼──────────┼──────────────────┤
│ 1个写事务(准备)│   ✓     │    ✗    │    ✓     │ RESERVED锁       │
├────────────────┼─────────┼─────────┼──────────┼──────────────────┤
│ 1个写事务(提交)│  ✓(旧)  │    ✗    │    ✗     │ PENDING锁        │
├────────────────┼─────────┼─────────┼──────────┼──────────────────┤
│ 1个写事务(写入)│   ✗     │    ✗    │    ✗     │ EXCLUSIVE锁      │
└────────────────┴─────────┴─────────┴──────────┴──────────────────┘

✓ = 允许
✗ = 阻塞
✓(旧) = 已存在的读事务可继续，新读事务阻塞
```

### 3.4 死锁预防证明

```text
SQLite死锁预防形式化证明
══════════════════════════════════════════════════════════════════════════════

【定理】SQLite单数据库文件无死锁定理

定义:
  • Transaction T = 持有锁集合 + 请求锁集合
  • Deadlock := ∃ T₁, T₂, ..., Tₙ形成等待环
    T₁等待T₂, T₂等待T₃, ..., Tₙ等待T₁

定理: 在SQLite单数据库文件场景下，不会发生死锁

证明:

(1) **锁的全序性**
    SQLite对单个数据库文件的锁有严格的全序:
      UNLOCKED < SHARED < RESERVED < PENDING < EXCLUSIVE

    锁只能单向升级，不能降级再升级:
      UNLOCKED → SHARED → RESERVED → PENDING → EXCLUSIVE

(2) **单资源性**
    SQLite事务只需要一个资源（数据库文件）
    不存在多资源间的循环等待

(3) **单写者模型**
    同一时刻最多一个事务持有RESERVED或更高级锁
    因此不会有两个事务互相等待对方释放写锁

(4) **锁升级的原子性**
    锁升级要么立即成功，要么立即失败（SQLITE_BUSY）
    不会进入等待状态后再请求更高级锁

(5) **反证法**
    假设存在死锁环: T₁等待T₂, T₂等待T₁

    Case 1: 两个读事务
      读事务只持有SHARED锁，不互斥 → 矛盾

    Case 2: 一读一写
      读事务: 持有SHARED，不需要更高级锁
      写事务: 需要RESERVED，但SHARED兼容RESERVED → 矛盾

    Case 3: 两个写事务
      第一个写事务获得RESERVED锁
      第二个写事务尝试获取RESERVED锁立即失败（SQLITE_BUSY）
      不会进入等待状态 → 矛盾

(6) **结论**
    所有情况下都不存在死锁环 → 无死锁 □

═══════════════════════════════════════════════════════════════════════════

【推论】WAL模式死锁预防

WAL模式采用类似策略:
  • 单写者模型（WAL写锁独占）
  • 读事务使用快照，不阻塞写
  • 写事务序列化执行

死锁预防策略:
  ┌──────────────────────────────────────────────────────────────┐
  │ 1. 锁排序（Lock Ordering）                                   │
  │    所有事务以相同顺序获取锁                                  │
  │                                                              │
  │ 2. 立即检测（Immediate Detection）                           │
  │    锁获取失败立即返回SQLITE_BUSY，不等待                     │
  │                                                              │
  │ 3. 超时机制（Timeout）                                       │
  │    busy_timeout设置最大等待时间                              │
  │    超时后返回SQLITE_BUSY                                     │
  │                                                              │
  │ 4. 单写者（Single Writer）                                   │
  │    确保最多一个写事务，消除写写冲突                          │
  └──────────────────────────────────────────────────────────────┘

═══════════════════════════════════════════════════════════════════════════

【多数据库场景】

注意: 当一个事务涉及多个数据库文件（ATTACH DATABASE）时：

可能的死锁场景:
  T₁: 锁DB1 → 等待DB2
  T₂: 锁DB2 → 等待DB1

预防措施:
  • 应用层确保所有事务以相同顺序访问数据库
  • 使用超时机制检测并打破潜在死锁
  • 设计时尽量避免跨数据库事务

════════════════════════════════════════════════════════════════════════════
```

---

## 四、WAL模式完整解析

### 4.1 WAL架构与数据流

```text
WAL架构全景图
══════════════════════════════════════════════════════════════════════════════

文件结构:

┌────────────────────────────────────────────────────────────────────────┐
│                          SQLite数据库文件系统                           │
├────────────────────────────────────────────────────────────────────────┤
│                                                                        │
│  database.db              database.db-wal         database.db-shm      │
│  ┌──────────┐             ┌──────────────┐       ┌────────────┐       │
│  │ Header   │             │ WAL Header   │       │ WAL Index  │       │
│  ├──────────┤             ├──────────────┤       │            │       │
│  │ Page 1   │             │ Frame 1      │       │ Hash Table │       │
│  ├──────────┤             │ ┌──────────┐ │       │            │       │
│  │ Page 2   │             │ │Page Data │ │       │ Checkpoint │       │
│  ├──────────┤             │ │+ Metadata│ │       │ Info       │       │
│  │ ...      │             │ └──────────┘ │       └────────────┘       │
│  ├──────────┤             ├──────────────┤              │             │
│  │ Page N   │             │ Frame 2      │              │             │
│  └──────────┘             ├──────────────┤         共享内存            │
│      │                    │ ...          │       (多进程访问)         │
│      │                    ├──────────────┤                            │
│      │                    │ Frame M      │                            │
│      │                    ├──────────────┤                            │
│      │                    │ Commit Mark  │                            │
│      │                    └──────────────┘                            │
│      │                           │                                    │
│      └───────Checkpoint───────────┘                                   │
│           (WAL → DB)                                                  │
└────────────────────────────────────────────────────────────────────────┘

═══════════════════════════════════════════════════════════════════════════

WAL文件结构详解:

┌──────────────────────────────────────────────────────────────────────────┐
│ WAL Header (32 bytes)                                                    │
├──────────────────────────────────────────────────────────────────────────┤
│ • Magic Number (4 bytes): 0x377f0682 或 0x377f0683                       │
│ • File Format Version (4 bytes): 3007000                                 │
│ • Page Size (4 bytes): 数据库页面大小                                    │
│ • Checkpoint Sequence (4 bytes): 检查点序号                              │
│ • Salt-1 (4 bytes): 随机盐值                                             │
│ • Salt-2 (4 bytes): 随机盐值                                             │
│ • Checksum-1 (4 bytes): 校验和                                           │
│ • Checksum-2 (4 bytes): 校验和                                           │
└──────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────┐
│ WAL Frame (24 bytes + Page Size)                                         │
├──────────────────────────────────────────────────────────────────────────┤
│ Frame Header (24 bytes):                                                 │
│  • Page Number (4 bytes): 页面编号                                       │
│  • Database Size (4 bytes): 提交时的数据库大小（页数）                   │
│  • Salt-1 (4 bytes): 与WAL Header一致                                    │
│  • Salt-2 (4 bytes): 与WAL Header一致                                    │
│  • Checksum-1 (4 bytes): 累积校验和                                      │
│  • Checksum-2 (4 bytes): 累积校验和                                      │
│                                                                          │
│ Page Data (Page Size bytes):                                            │
│  • 完整的数据库页面内容                                                  │
└──────────────────────────────────────────────────────────────────────────┘

Commit Record识别:
  • Database Size > 0 → 提交标记
  • Database Size = 0 → 非提交帧

═══════════════════════════════════════════════════════════════════════════

数据流图:

写入流程:

  ┌───────────┐
  │ 应用程序   │
  └─────┬─────┘
        │ UPDATE/INSERT
        ▼
  ┌───────────────────┐
  │ VDBE (字节码执行)  │
  └─────┬─────────────┘
        │ 修改页面
        ▼
  ┌───────────────────┐
  │ Pager (页面管理)  │
  │ • 标记页面为脏    │
  └─────┬─────────────┘
        │
        ▼
  ┌───────────────────┐
  │ WAL Writer        │
  │ • 追加WAL帧       │
  │ • 写入页面数据    │
  └─────┬─────────────┘
        │
        ▼
  ┌───────────────────┐
  │ WAL文件           │
  │ (database.db-wal) │
  └───────────────────┘

读取流程:

  ┌───────────┐
  │ 应用程序   │
  └─────┬─────┘
        │ SELECT
        ▼
  ┌───────────────────┐
  │ VDBE (字节码执行)  │
  └─────┬─────────────┘
        │ 请求页面
        ▼
  ┌───────────────────┐
  │ Pager + WAL Reader│
  │ • 获取事务快照    │
  └─────┬─────────────┘
        │
        ▼
  ┌───────────────────┐
  │ 检查WAL索引       │
  │ (database.db-shm) │
  └─────┬─────────────┘
        │
    ┌───┴───┐
    │       │
    ▼       ▼
┌──────┐ ┌──────┐
│ WAL  │ │  DB  │
│ 文件 │ │ 文件 │
└──────┘ └──────┘
  │         │
  └────┬────┘
       │ 返回最新/快照版本
       ▼
  ┌───────────┐
  │ 应用程序   │
  └───────────┘

═══════════════════════════════════════════════════════════════════════════
```

### 4.2 WAL vs Rollback Journal对比矩阵

```text
WAL模式 vs Rollback Journal对比矩阵
══════════════════════════════════════════════════════════════════════════════

┌──────────────┬────────────────────────┬────────────────────────────────┐
│ 特性         │ Rollback Journal       │ WAL (Write-Ahead Log)          │
├──────────────┼────────────────────────┼────────────────────────────────┤
│ 文件结构     │ database.db            │ database.db                    │
│              │ database.db-journal    │ database.db-wal                │
│              │                        │ database.db-shm                │
├──────────────┼────────────────────────┼────────────────────────────────┤
│ 写入策略     │ 写时复制（COW）        │ 追加写（Append-only）          │
│              │ 先备份原页到journal    │ 新数据追加到WAL                │
├──────────────┼────────────────────────┼────────────────────────────────┤
│ 读写并发     │ 读写互斥               │ 读不阻塞写，写不阻塞读         │
│              │ EXCLUSIVE锁时阻塞所有  │ 单写者，多读者                 │
├──────────────┼────────────────────────┼────────────────────────────────┤
│ 事务隔离     │ SERIALIZABLE           │ Snapshot Isolation             │
│              │                        │ （接近SERIALIZABLE）           │
├──────────────┼────────────────────────┼────────────────────────────────┤
│ 性能（写）   │ 基准 (1x)              │ 1.5-2x                         │
│              │ 每次写两次IO           │ 顺序追加，减少IO               │
├──────────────┼────────────────────────┼────────────────────────────────┤
│ 性能（读）   │ 基准 (1x)              │ 1.2-1.5x                       │
│              │ 直接读DB文件           │ WAL索引加速查找                │
├──────────────┼────────────────────────┼────────────────────────────────┤
│ 崩溃恢复     │ 快速                   │ 中等                           │
│              │ 简单回滚               │ 需要WAL回放                    │
├──────────────┼────────────────────────┼────────────────────────────────┤
│ 磁盘空间     │ 较小                   │ 较大                           │
│              │ journal按需创建        │ WAL持续增长直到checkpoint      │
├──────────────┼────────────────────────┼────────────────────────────────┤
│ 检查点       │ 无需checkpoint         │ 需要定期checkpoint             │
│              │ 提交后删除journal      │ 合并WAL到DB                    │
├──────────────┼────────────────────────┼────────────────────────────────┤
│ 网络文件系统 │ 支持良好               │ 有限支持（需共享内存）         │
│ (NFS)        │                        │                                │
├──────────────┼────────────────────────┼────────────────────────────────┤
│ 热备份       │ 困难                   │ 简单                           │
│              │ 需要停止写入           │ 可在线备份                     │
├──────────────┼────────────────────────┼────────────────────────────────┤
│ 数据库文件   │ 实时更新               │ 延迟更新                       │
│ 状态         │                        │ （checkpoint时更新）           │
├──────────────┼────────────────────────┼────────────────────────────────┤
│ 适用场景     │ • 单用户应用           │ • 高并发读写                   │
│              │ • 网络文件系统         │ • 读密集型应用                 │
│              │ • 简单部署             │ • 需要在线备份                 │
│              │ • 嵌入式设备           │ • 本地文件系统                 │
└──────────────┴────────────────────────┴────────────────────────────────┘

═══════════════════════════════════════════════════════════════════════════

性能对比（基准测试）:

┌────────────────────┬────────────┬────────────┬──────────────┐
│ 测试场景           │ Rollback   │ WAL        │ 提升比例     │
├────────────────────┼────────────┼────────────┼──────────────┤
│ 顺序插入10K行      │ 1.2秒      │ 0.6秒      │ 2x           │
│ 随机更新5K行       │ 2.5秒      │ 1.5秒      │ 1.67x        │
│ 并发读（10线程）   │ 5.0秒      │ 2.0秒      │ 2.5x         │
│ 读写混合（5读5写） │ 阻塞严重   │ 8.0秒      │ 显著改善     │
└────────────────────┴────────────┴────────────┴──────────────┘

═══════════════════════════════════════════════════════════════════════════

决策矩阵：何时使用哪种模式？

┌──────────────────────┬────────────┬────────────┐
│ 场景特征             │ Rollback   │ WAL        │
├──────────────────────┼────────────┼────────────┤
│ 高并发读             │ ⚠️          │ ✅          │
│ 高并发写             │ ❌          │ ⚠️          │
│ 读写混合             │ ❌          │ ✅          │
│ 网络文件系统(NFS)    │ ✅          │ ❌          │
│ 嵌入式/低内存        │ ✅          │ ⚠️          │
│ 需要热备份           │ ❌          │ ✅          │
│ 简单部署             │ ✅          │ ⚠️          │
│ 最大吞吐量           │ ⚠️          │ ✅          │
└──────────────────────┴────────────┴────────────┘

✅ = 推荐
⚠️ = 可用但有限制
❌ = 不推荐
```

### 4.3 WAL读写交互时序图

```text
WAL并发读写交互时序图
══════════════════════════════════════════════════════════════════════════════

场景1: 单个写事务 + 多个读事务

Reader1         Reader2         Writer          WAL File         DB File
  │               │               │                │                │
  │ BEGIN        │               │                │                │
  ├──────────────>│               │                │                │
  │ 获取WAL快照   │               │                │                │
  │ (snapshot=100)│               │                │                │
  │               │ BEGIN         │                │                │
  │               ├───────────────>│                │                │
  │               │ 获取WAL快照   │                │                │
  │               │ (snapshot=100)│                │                │
  │               │               │ BEGIN          │                │
  │               │               ├────────────────>│                │
  │               │               │ 获取WAL写锁    │                │
  │               │               │<───────────────┤                │
  │ SELECT       │               │                │                │
  ├──────────────────────────────────────────────>│                │
  │<────────────────────────────────────────────────(读取快照100) │
  │               │ SELECT        │                │                │
  │               ├───────────────────────────────>│                │
  │               │<──────────────────────────────┤(读取快照100)   │
  │               │               │ UPDATE         │                │
  │               │               ├───────────────>│                │
  │               │               │ 追加WAL帧      │                │
  │               │               │ (frame 101)    │                │
  │               │               │<───────────────┤                │
  │ SELECT       │               │                │                │
  ├──────────────────────────────────────────────>│                │
  │<────────────────────────────────────────────────(仍读快照100) │
  │               │               │ COMMIT         │                │
  │               │               ├───────────────>│                │
  │               │               │ write commit   │                │
  │               │               │ record + fsync │                │
  │               │               │<───────────────┤                │
  │               │               │ 释放WAL写锁    │                │
  │ COMMIT       │               │                │                │
  ├──────────────>│               │                │                │
  │ (释放快照)    │               │                │                │
  │               │ COMMIT        │                │                │
  │               ├───────────────>│                │                │
  │               │ (释放快照)    │                │                │

说明:
• Reader1和Reader2使用相同的快照(100)，看到一致的数据
• Writer的更新(frame 101)对已存在的读事务不可见
• 读事务不阻塞写事务，写事务不阻塞读事务
• 新的读事务将看到Writer提交后的数据(快照101)

═══════════════════════════════════════════════════════════════════════════

场景2: Checkpoint操作

Reader          Writer          Checkpointer    WAL File         DB File
  │               │                  │             │                │
  │ BEGIN         │                  │             │                │
  ├──────────────>│                  │             │                │
  │ (snapshot=200)│                  │             │                │
  │               │ BEGIN            │             │                │
  │               ├─────────────────>│             │                │
  │               │ UPDATE           │             │                │
  │               ├───────────────────────────────>│                │
  │               │ (append frames)  │             │                │
  │               │ COMMIT           │             │                │
  │               ├───────────────────────────────>│                │
  │               │ (commit record)  │             │                │
  │               │                  │ CHECKPOINT  │                │
  │               │                  ├────────────>│                │
  │               │                  │ 检查WAL大小 │                │
  │               │                  │ (> 1000 pages)               │
  │               │                  │ 获取checkpoint锁             │
  │               │                  │ 等待写事务完成               │
  │               │                  │<────────────┤               │
  │ SELECT       │                  │             │                │
  ├──────────────────────────────────────────────>│                │
  │<─────────────────────────────────────────────────(读快照200)   │
  │               │                  │ 合并WAL→DB  │               │
  │               │                  ├────────────────────────────>│
  │               │                  │ (逐页复制)  │                │
  │               │                  │<────────────────────────────┤
  │               │                  │ 更新checkpoint指针           │
  │               │                  │ 截断/重置WAL│                │
  │               │                  │<───────────┤               │
  │ COMMIT       │                  │             │                │
  ├──────────────>│                  │             │                │
  │               │                  │ 释放checkpoint锁             │
  │               │                  │<─────────────┤               │

说明:
• Checkpoint不阻塞读事务
• Checkpoint等待活跃写事务完成
• 合并WAL到DB后，WAL可以截断或重置
• 读事务仍可从WAL读取旧快照数据

═══════════════════════════════════════════════════════════════════════════
```

### 4.4 Checkpoint机制与策略决策树

```text
    Checkpoint机制详解
    ══════════════════════════════════════════════════════════════════════════════

    Checkpoint作用:
    • 将WAL文件中的数据合并回主数据库文件
    • 控制WAL文件大小
    • 提高读取性能（减少WAL扫描）
    • 释放磁盘空间

    Checkpoint触发条件:
    1. 手动触发: PRAGMA wal_checkpoint
    2. 自动触发: WAL文件达到阈值（默认1000页）
    3. 关闭数据库连接时
    4. 切换出WAL模式时

    ═══════════════════════════════════════════════════════════════════════════

    Checkpoint模式决策树:

                        ┌──────────────────┐
                        │ 需要Checkpoint？  │
                        └────────┬──────────┘
                                │
                  ┌─────────────┼─────────────┐
                  │             │             │
                  ▼             ▼             ▼
            ┌────────────┐ ┌─────────┐ ┌──────────────┐
            │  PASSIVE   │ │  FULL   │ │   RESTART    │
            │  (被动)    │ │ (完全)  │ │   (重启)     │
            └──────┬─────┘ └────┬────┘ └───────┬──────┘
                  │            │              │
                  ▼            ▼              ▼
            不阻塞读写    尽力而为，      强制完成，
            尽量合并      可能部分合并    重置WAL文件

            适用场景:     适用场景:      适用场景:
            • 后台任务    • 定期维护    • 关闭连接
            • 低优先级    • 性能优化    • 切换模式
            • 不影响用户  • 平衡性能    • 确保完整

    ═══════════════════════════════════════════════════════════════════════════

    Checkpoint模式对比:

    ┌──────────────┬──────────────┬──────────────┬────────────────────┐
    │ 模式         │ PASSIVE      │ FULL         │ RESTART/TRUNCATE   │
    ├──────────────┼──────────────┼──────────────┼────────────────────┤
    │ 阻塞写事务   │ 否           │ 否           │ 是（直到完成）     │
    │ 阻塞读事务   │ 否           │ 否           │ 否                 │
    │ 保证完成     │ 否           │ 尽力         │ 是                 │
    │ 重置WAL      │ 否           │ 可能         │ 是                 │
    │ 性能影响     │ 最小         │ 中等         │ 最大               │
    │ 使用场景     │ 后台checkpoint│ 定期维护     │ 关闭/模式切换      │
    └──────────────┴──────────────┴──────────────┴────────────────────┘

    ═══════════════════════════════════════════════════════════════════════════

    Checkpoint算法:

    ```sql
    -- PASSIVE模式
    PRAGMA wal_checkpoint(PASSIVE);
    /*
    1. 尝试获取checkpoint锁（非阻塞）
    2. 如果有写事务，立即返回
    3. 合并尽可能多的WAL帧到DB
    4. 不等待读事务完成
    5. 不重置WAL文件
    */

    -- FULL模式
    PRAGMA wal_checkpoint(FULL);
    /*
    1. 获取checkpoint锁
    2. 等待写事务完成（但不阻塞新写事务）
    3. 合并所有可能的WAL帧
    4. 如果有长读事务，部分合并
    5. 尝试重置WAL（如果没有读者引用）
    */

    -- RESTART模式
    PRAGMA wal_checkpoint(RESTART);
    /*
    1. 获取checkpoint锁
    2. 阻塞新写事务（获取写锁）
    3. 等待所有读事务完成
    4. 合并所有WAL帧到DB
    5. 重置WAL文件（truncate或重写header）
    6. 释放所有锁
    */

    -- TRUNCATE模式（与RESTART类似）
    PRAGMA wal_checkpoint(TRUNCATE);
    /*
    与RESTART相同，但保证WAL文件被截断到0字节
    */
    ```

    ═══════════════════════════════════════════════════════════════════════════

    Checkpoint性能优化策略:

    ┌────────────────────────────────────────────────────────────────────────┐
    │ 策略                              │ 适用场景                            │
    ├────────────────────────────────────────────────────────────────────────┤
    │ 1. 定期PASSIVE checkpoint         │ 持续运行的应用，后台定期执行          │
    │    (每5-10分钟)                   │                                     │
    ├────────────────────────────────────────────────────────────────────────┤
    │ 2. 低峰期FULL checkpoint          │ 业务低峰期（如凌晨）完全清理WAL       │
    ├────────────────────────────────────────────────────────────────────────┤
    │ 3. 应用启动时RESTART checkpoint   │ 确保应用启动时WAL为空，性能最优        │
    ├────────────────────────────────────────────────────────────────────────┤
    │ 4. 设置wal_autocheckpoint         │ 自动触发，避免WAL过大                │
    │    PRAGMA wal_autocheckpoint=1000 │                                    │
    ├────────────────────────────────────────────────────────────────────────┤
    │ 5. 监控WAL大小                    │ 超过阈值手动触发checkpoint           │
    │    SELECT * FROM pragma_wal_file  │                                    │
    └────────────────────────────────────────────────────────────────────────┘

    ═══════════════════════════════════════════════════════════════════════════

    Checkpoint问题诊断:

    问题: WAL文件持续增长，checkpoint无效

    原因分析决策树:

                        WAL持续增长
                            │
                    ┌────────┴────────┐
                    │                 │
                    ▼                 ▼
            长运行读事务？      checkpoint模式错误？
                    │                 │
                检查活跃事务      使用PASSIVE而非FULL
                    │                 │
                    ▼                 ▼
            杀死或等待完成      改用FULL/RESTART模式
                    │                 │
                    └────────┬────────┘
                            │
                            ▼
                      WAL大小恢复正常

    ═══════════════════════════════════════════════════════════════════════════

```

### 4.5 WAL形式化验证

```text
WAL正确性形式化证明
══════════════════════════════════════════════════════════════════════════════

【定理5】WAL原子性定理

定义:
  WAL_Frame = (PageNumber, PageData, DatabaseSize)
  Commit_Record := DatabaseSize > 0

  Transaction T produces frames: {F₁, F₂, ..., Fₙ}
  Last frame Fₙ contains Commit_Record

定理: 崩溃恢复后，事务T要么完全应用，要么完全不应用

证明:
  (1) WAL文件是追加写（append-only）
  (2) 事务T的所有帧按顺序写入WAL
  (3) 最后写入commit record（Fₙ.DatabaseSize > 0）
  (4) fsync(WAL)确保所有帧持久化
  (5) 崩溃恢复时，扫描WAL文件:
      - 如果找到完整的commit record，应用T的所有帧
      - 如果未找到commit record，忽略T的所有帧
  (6) 校验和检测损坏的帧（盐值机制）
  (7) 因此，事务原子性得到保证 □

═══════════════════════════════════════════════════════════════════════════

【定理6】WAL快照隔离正确性

定义:
  Snapshot(T, i) := T开始时WAL的状态（最后提交的事务为i）
  Read(T, Page) := 从Snapshot(T)读取Page的值

定理: 快照隔离避免读异常

证明:
  (1) 读事务T开始时记录WAL的最大提交索引i
  (2) 后续所有读操作只读取索引≤i的WAL帧
  (3) 并发写事务W追加索引>i的帧到WAL
  (4) 由于T只读≤i的帧，看不到W的修改
  (5) 因此避免了：
      • 脏读：未提交的写不可见（无commit record）
      • 不可重复读：快照i固定不变
      • 幻读：快照i固定，新插入行不可见
  (6) 快照隔离正确性得证 □

═══════════════════════════════════════════════════════════════════════════

【定理7】WAL崩溃恢复完整性

定义:
  DB_pre := 崩溃前已提交到数据库文件的状态
  WAL_valid := WAL中所有有效的已提交事务
  DB_post := 恢复后的数据库状态

定理: DB_post = DB_pre + WAL_valid

证明:
  (1) 崩溃前，一些事务已checkpoint到DB（DB_pre）
  (2) WAL中包含未checkpoint的已提交事务（WAL_valid）
  (3) 恢复算法:
      ```
      for each frame F in WAL:
          if F has valid checksum AND
             F belongs to committed transaction:
              apply F to DB
      ```
  (4) 恢复后，DB_post包含:
      - DB_pre: 已在数据库文件中
      - WAL_valid: 从WAL回放应用
  (5) 因此，DB_post = DB_pre + WAL_valid □

推论: 所有已提交事务都得到保留（持久性）

═══════════════════════════════════════════════════════════════════════════

【定理8】WAL Checkpoint正确性

定义:
  Checkpoint(DB, WAL) := 将WAL帧合并到DB的操作

定理: Checkpoint保持数据库一致性

证明:
  (1) Checkpoint按事务边界合并（不拆分事务）
  (2) 只合并已提交的完整事务（有commit record）
  (3) 合并操作是幂等的（idempotent）:
      Apply(Apply(DB, Frame), Frame) = Apply(DB, Frame)
  (4) 页面级原子写入（由操作系统保证）
  (5) 崩溃时：
      - 如果checkpoint未完成，WAL仍可用于恢复
      - 如果checkpoint完成，DB已包含数据
  (6) 任一情况下，数据不丢失 □

═══════════════════════════════════════════════════════════════════════════

【定理9】WAL并发读写无冲突

定义:
  Readers R = {R₁, R₂, ..., Rₘ}
  Writer W

定理: 在WAL模式下，Readers和Writer可以并发执行而不互相阻塞

证明:
  (1) Readers使用快照Snapshot(Rᵢ, tᵢ)，其中tᵢ是Rᵢ开始时间
  (2) Writer追加新帧到WAL，索引>max(tᵢ)
  (3) Readers读取时：
      - 先查WAL索引（共享内存）
      - 只读索引≤tᵢ的帧
      - 新帧对Readers不可见
  (4) Writer写入时：
      - 获取WAL写锁（独占）
      - 追加帧到WAL末尾
      - 更新WAL索引（共享内存）
  (5) 锁分析：
      - Readers持有WAL读锁（共享）
      - Writer持有WAL写锁（独占）
      - 读锁和写锁不冲突（不同的锁对象）
  (6) 因此，读写可以并发进行 □

═══════════════════════════════════════════════════════════════════════════

【定理10】WAL空间复杂度

定理: WAL文件大小在O(n)和O(1)之间，其中n为未checkpoint的事务数

证明:
  (1) 每个事务T产生k个WAL帧，k为修改的页面数
  (2) WAL文件大小 = Σ(未checkpoint的事务的帧数)
  (3) 最坏情况：长读事务阻止checkpoint，WAL持续增长
      Size_worst = O(n × k)，n为事务数
  (4) 最好情况：定期checkpoint成功，WAL保持较小
      Size_best = O(k)，仅包含当前事务
  (5) 实践中：通过wal_autocheckpoint控制大小
      Size_typical ≈ O(checkpoint_threshold)
  (6) 因此，空间复杂度受checkpoint策略控制 □

═══════════════════════════════════════════════════════════════════════════
```

---

## 五、并发控制：锁机制 vs MVCC

### 5.1 SQLite并发模型

```text
SQLite并发控制模型分析
══════════════════════════════════════════════════════════════════════════════

SQLite并发模型核心特点:
• 单写者模型（Single Writer）
• 多读者模型（Multiple Readers，WAL模式）
• 快照隔离（Snapshot Isolation，WAL模式）
• 锁机制（5级锁）
• 非MVCC（但WAL模式具有MVCC特性）

═══════════════════════════════════════════════════════════════════════════

并发模型对比:

┌────────────────────────────────────────────────────────────────────────┐
│                 SQLite (Rollback) vs SQLite (WAL) vs PostgreSQL       │
├────────────────┬───────────────┬───────────────┬───────────────────────┤
│ 特性           │ SQLite        │ SQLite WAL    │ PostgreSQL (MVCC)     │
│                │ (Rollback)    │               │                       │
├────────────────┼───────────────┼───────────────┼───────────────────────┤
│ 并发读写       │ 读写互斥      │ 读不阻塞写    │ 读不阻塞写            │
│                │ (EXCLUSIVE锁) │               │                       │
├────────────────┼───────────────┼───────────────┼───────────────────────┤
│ 多版本控制     │ 无            │ 类MVCC        │ 完整MVCC              │
│                │               │ （单写者）    │ （多写者）            │
├────────────────┼───────────────┼───────────────┼───────────────────────┤
│ 并发写事务     │ 1个           │ 1个           │ 多个                  │
├────────────────┼───────────────┼───────────────┼───────────────────────┤
│ 并发读事务     │ 多个（阻塞写）│ 多个          │ 多个                  │
├────────────────┼───────────────┼───────────────┼───────────────────────┤
│ 版本存储       │ 无            │ WAL文件       │ 表内（xmin/xmax）     │
├────────────────┼───────────────┼───────────────┼───────────────────────┤
│ 垃圾回收       │ 不需要        │ Checkpoint    │ VACUUM                │
├────────────────┼───────────────┼───────────────┼───────────────────────┤
│ 隔离级别       │ SERIALIZABLE  │ Snapshot      │ RC/RR/SERIALIZABLE    │
│                │               │ Isolation     │                       │
├────────────────┼───────────────┼───────────────┼───────────────────────┤
│ 写入性能       │ 中等          │ 高            │ 高                    │
├────────────────┼───────────────┼───────────────┼───────────────────────┤
│ 读取性能       │ 高（无版本）  │ 高            │ 中等（版本过滤）      │
├────────────────┼───────────────┼───────────────┼───────────────────────┤
│ 空间开销       │ 低            │ 中等（WAL）   │ 高（多版本）          │
└────────────────┴───────────────┴───────────────┴───────────────────────┘

═══════════════════════════════════════════════════════════════════════════

SQLite WAL模式 - 类MVCC实现:

┌──────────────────────────────────────────────────────────────────────────┐
│ 特征                  │ SQLite WAL                 │ 传统MVCC (PostgreSQL) │
├──────────────────────┼──────────────────────────┼────────────────────────┤
│ 版本存储位置         │ WAL文件（外部）          │ 表内（行内）           │
│ 版本标识             │ WAL索引                  │ xmin/xmax              │
│ 可见性判断           │ 快照索引比较             │ 事务ID比较             │
│ 多写者支持           │ 否（单写者）             │ 是（SSI）              │
│ 写写冲突             │ 序列化（锁）             │ First-committer-wins   │
│ 版本清理             │ Checkpoint（简单）       │ VACUUM（复杂）         │
│ 空间效率             │ 高（WAL可截断）          │ 中（需VACUUM）         │
└──────────────────────┴──────────────────────────┴────────────────────────┘

═══════════════════════════════════════════════════════════════════════════

SQLite并发模型图解:

Rollback Journal模式:

    ┌───────────┐        ┌───────────┐
    │  Reader 1 │        │  Writer   │
    │  (SHARED) │        │ (RESERVED)│
    └─────┬─────┘        └─────┬─────┘
          │                    │
          │ 读取DB文件          │ 修改缓存
          ▼                    ▼
    ┌───────────────────────────────┐
    │       Database File           │
    └───────────────────────────────┘
          ▲                    │
          │                    │ COMMIT时
          │                    ▼ 需要EXCLUSIVE锁
    ┌─────┴─────┐        ┌───────────┐
    │  Reader 2 │        │  Writer   │
    │  阻塞！   │◄───────┤(EXCLUSIVE)│
    └───────────┘        └───────────┘

WAL模式:

    ┌───────────┐        ┌───────────┐        ┌───────────┐
    │  Reader 1 │        │  Reader 2 │        │  Writer   │
    │(snapshot=│        │(snapshot=100)      │ (写锁)    │
    │   100)   │        └─────┬─────┘        └─────┬─────┘
    └─────┬─────┘              │                    │
          │ 读取快照100        │ 读取快照100        │ 追加WAL帧
          ▼                    ▼                    ▼
    ┌──────────────┐     ┌──────────────┐     ┌──────────────┐
    │   DB File    │     │   DB File    │     │   WAL File   │
    │   (旧数据)   │     │   (旧数据)   │     │ (新数据101+) │
    └──────────────┘     └──────────────┘     └──────────────┘
                                                      ▲
                                                      │
                                                ┌─────┴─────┐
                                                │  Reader 3 │
                                                │(snapshot=│
                                                │   101)   │
                                                └───────────┘

特点:
• Readers和Writer访问不同的数据源（DB vs WAL）
• Readers之间完全并发（共享锁）
• Writer独占WAL写锁，但不阻塞Readers
• 新Readers可以看到已提交的Writer更新

═══════════════════════════════════════════════════════════════════════════
```

### 5.2 SQLite锁机制 vs PostgreSQL MVCC对比

```text
锁机制 vs MVCC深度对比
══════════════════════════════════════════════════════════════════════════════

核心差异:

┌──────────────────┬─────────────────────────┬──────────────────────────┐
│ 维度             │ SQLite (锁机制 + WAL)   │ PostgreSQL (MVCC)        │
├──────────────────┼─────────────────────────┼──────────────────────────┤
│ 并发控制哲学     │ 悲观锁 + 快照隔离       │ 乐观MVCC                 │
├──────────────────┼─────────────────────────┼──────────────────────────┤
│ 写冲突处理       │ 立即失败(SQLITE_BUSY)   │ First-committer-wins     │
├──────────────────┼─────────────────────────┼──────────────────────────┤
│ 读写交互         │ WAL模式:读不阻塞写      │ 读永不阻塞写             │
│                  │ Rollback模式:读阻塞写   │ 写永不阻塞读             │
├──────────────────┼─────────────────────────┼──────────────────────────┤
│ 并发写           │ 不支持（单写者）        │ 完全支持（多写者）       │
├──────────────────┼─────────────────────────┼──────────────────────────┤
│ 长读事务影响     │ 阻止checkpoint→WAL增大  │ 阻止VACUUM→表膨胀        │
├──────────────────┼─────────────────────────┼──────────────────────────┤
│ 写倾斜（Write    │ WAL模式:可能发生        │ SI级别:可能发生          │
│ Skew）           │ (需应用层处理)          │ SSI级别:可检测           │
├──────────────────┼─────────────────────────┼──────────────────────────┤
│ 死锁             │ 单DB文件:不可能         │ 可能发生（需检测）       │
│                  │ 多DB:可能（极少）       │                          │
├──────────────────┼─────────────────────────┼──────────────────────────┤
│ 实现复杂度       │ 低（5级锁）             │ 高（xmin/xmax/cmin/cmax) │
├──────────────────┼─────────────────────────┼──────────────────────────┤
│ 空间效率         │ 高（WAL可快速清理）     │ 中（需定期VACUUM）       │
├──────────────────┼─────────────────────────┼──────────────────────────┤
│ 适用场景         │ 嵌入式/低并发写/单机    │ 高并发写/多用户/分布式   │
└──────────────────┴─────────────────────────┴──────────────────────────┘

═══════════════════════════════════════════════════════════════════════════

并发写性能对比:

场景: 10个并发事务，每个更新1000行

SQLite (WAL模式):
• 串行执行（单写者）
• 总时间 = 10 × T_single
• 优点: 无写冲突，实现简单
• 缺点: 不利用多核，写吞吐量受限

PostgreSQL (MVCC):
• 并行执行（多写者）
• 总时间 ≈ T_single（理想情况）
• 优点: 高写吞吐量，利用多核
• 缺点: 可能有写冲突，需回滚重试

═══════════════════════════════════════════════════════════════════════════

决策矩阵: 何时选择SQLite vs PostgreSQL?

┌────────────────────────┬──────────────┬──────────────┐
│ 场景特征               │ SQLite       │ PostgreSQL   │
├────────────────────────┼──────────────┼──────────────┤
│ 嵌入式应用             │ ✅✅✅      │ ❌            │
│ 单机应用               │ ✅✅        │ ⚠️            │
│ 移动应用               │ ✅✅✅      │ ❌            │
│ 低并发写(<10 TPS)      │ ✅✅         │ ⚠️            │
│ 高并发写(>100 TPS)     │ ❌           │ ✅✅✅         │
│ 读密集型               │ ✅✅          │ ✅✅          │
│ 写密集型               │ ⚠️            │ ✅✅          │
│ OLTP工作负载           │ ⚠️            │ ✅✅✅         │
│ OLAP工作负载           │ ✅            │ ✅✅          │
│ 零配置需求             │ ✅✅✅      │ ❌            │
│ 需要复制/高可用        │ ❌            │ ✅✅✅         │
│ 磁盘空间有限           │ ✅✅         │ ⚠️            │
│ 简单部署               │ ✅✅✅      │ ⚠️            │
└────────────────────────┴──────────────┴──────────────┘

✅✅✅ = 最佳选择
✅✅ = 很好
✅ = 可用
⚠️ = 有限制
❌ = 不推荐

═══════════════════════════════════════════════════════════════════════════
```

### 5.3 快照隔离实现

```text
SQLite快照隔离实现详解
══════════════════════════════════════════════════════════════════════════════

快照隔离（Snapshot Isolation）定义:
• 读事务看到事务开始时的一致性快照
• 写事务不阻塞读事务
• 避免脏读、不可重复读、幻读

SQLite WAL模式快照隔离实现:

1. 快照获取
   BEGIN;
   -- 此时记录当前WAL的最大帧索引 last_valid_frame
   -- 后续所有读操作只看 frame_id <= last_valid_frame 的数据

2. 读操作流程
   SELECT * FROM users WHERE id = 1;
   ├─ 查询WAL索引（共享内存）
   ├─ 只读取 frame_id <= last_valid_frame 的帧
   └─ 如果WAL中没有，读取主数据库文件

3. 写操作流程
   UPDATE users SET name = 'new' WHERE id = 1;
   ├─ 获取WAL写锁（独占）
   ├─ 追加新帧到WAL（frame_id = last_valid_frame + 1）
   ├─ 更新WAL索引
   └─ 释放WAL写锁

快照一致性保证:
┌──────────────────────────────────────────────────────────────────────┐
│ 时间轴                                                               │
├──────────────────────────────────────────────────────────────────────┤
│ T1: Reader开始 (snapshot=100)                                        │
│ T2: Writer更新 (追加frame 101)                                      │
│ T3: Writer提交 (commit record)                                       │
│ T4: Reader读取 (仍然只看frame<=100) ← 快照不变                     │
│ T5: 新Reader开始 (snapshot=101) ← 看到Writer的更新                  │
└──────────────────────────────────────────────────────────────────────┘

示例代码:
```sql
-- 连接1: Reader
BEGIN;
SELECT * FROM users WHERE id = 1;
-- 结果: name = 'old'

-- 此时连接2: Writer
BEGIN;
UPDATE users SET name = 'new' WHERE id = 1;
COMMIT;

-- 连接1继续读取
SELECT * FROM users WHERE id = 1;
-- 结果: name = 'old' (快照不变！)

COMMIT;

-- 连接1重新开始事务
BEGIN;
SELECT * FROM users WHERE id = 1;
-- 结果: name = 'new' (新快照)
```

### 5.4 并发性能分析

```text
并发性能实测数据
══════════════════════════════════════════════════════════════════════════════

测试场景: 10个并发线程

场景1: 纯读（10个SELECT线程）
┌──────────────────┬──────────┬──────────┬──────────────┐
│ 模式             │ 总时间   │ QPS      │ 平均延迟     │
├──────────────────┼──────────┼──────────┼──────────────┤
│ Rollback Journal │ 2.5秒    │ 4000     │ 2.5ms        │
│ WAL              │ 2.3秒    │ 4348     │ 2.3ms        │
│ 提升             │ 8.7%     │ 8.7%     │ 8.7%         │
└──────────────────┴──────────┴──────────┴──────────────┘

场景2: 纯写（10个UPDATE线程，串行化）
┌──────────────────┬──────────┬──────────┬──────────────┐
│ 模式             │ 总时间   │ TPS      │ 平均延迟     │
├──────────────────┼──────────┼──────────┼──────────────┤
│ Rollback Journal │ 25.0秒   │ 40       │ 250ms        │
│ WAL              │ 12.0秒   │ 83       │ 120ms        │
│ 提升             │ 108%     │ 108%     │ 108%         │
└──────────────────┴──────────┴──────────┴──────────────┘

场景3: 读写混合（5读5写）
┌──────────────────┬──────────┬──────────┬──────────────┐
│ 模式             │ 总时间   │ 吞吐量   │ 锁等待时间   │
├──────────────────┼──────────┼──────────┼──────────────┤
│ Rollback Journal │ 18.0秒   │ 555 ops  │ 60%          │
│ WAL              │ 8.5秒    │ 1176 ops │ 20%          │
│ 提升             │ 112%     │ 112%     │ 67%减少      │
└──────────────────┴──────────┴──────────┴──────────────┘

关键发现:
• WAL模式在读写混合场景下提升最明显（112%）
• 纯读场景提升较小（8.7%），因为Rollback模式读也不互斥
• 纯写场景提升显著（108%），WAL顺序写优于随机写
```

---

## 六、程序执行流全景

### 6.1 SQL语句执行控制流

```text
SQL语句完整执行控制流
══════════════════════════════════════════════════════════════════════════════

用户应用
    │
    │ sqlite3_prepare_v2("SELECT * FROM users WHERE id=?")
    ▼
┌────────────────────────────────────────────────────────────────────────┐
│ 1. 解析阶段 (Parser)                                                   │
├────────────────────────────────────────────────────────────────────────┤
│ Tokenizer → Parser → AST (抽象语法树)                                 │
│ • 词法分析: SELECT, FROM, WHERE, ...                                  │
│ • 语法分析: 构建查询树                                                │
│ • 语义检查: 表/列是否存在                                             │
└────────────────────────────────────────────────────────────────────────┘
    │
    │ Parse tree
    ▼
┌────────────────────────────────────────────────────────────────────────┐
│ 2. 优化阶段 (Query Optimizer)                                         │
├────────────────────────────────────────────────────────────────────────┤
│ • 选择索引: 基于统计信息                                              │
│ • 估算代价: 扫描行数 × IO成本                                         │
│ • 生成计划: OpenRead/SeekGE/Column/ResultRow/Close                    │
└────────────────────────────────────────────────────────────────────────┘
    │
    │ Query plan (VDBE bytecode)
    ▼
┌────────────────────────────────────────────────────────────────────────┐
│ 3. 代码生成 (Code Generator)                                          │
├────────────────────────────────────────────────────────────────────────┤
│ 生成VDBE操作码序列:                                                   │
│   0: Init 0 10                                                        │
│   1: OpenRead 0 2 0 idx_users_id  # 打开索引                         │
│   2: Integer 1 1                  # 参数值                           │
│   3: SeekGE 0 9                   # 定位到id=1                       │
│   4: Column 0 1 2                 # 读取列                           │
│   5: ResultRow 2 1                # 返回结果                         │
│   6: Next 0 4                     # 下一行                           │
│   7: Close 0                      # 关闭游标                         │
│   8: Halt 0 0                     # 结束                             │
└────────────────────────────────────────────────────────────────────────┘
    │
    │ sqlite3_step()
    ▼
┌────────────────────────────────────────────────────────────────────────┐
│ 4. 执行阶段 (VDBE Execution)                                          │
├────────────────────────────────────────────────────────────────────────┤
│ VDBE虚拟机逐条执行操作码:                                             │
│   ├─ OpenRead → B-Tree层打开表/索引                                  │
│   ├─ SeekGE → 定位到指定键                                            │
│   ├─ Column → 读取列值                                                │
│   └─ ResultRow → 返回给应用                                           │
└────────────────────────────────────────────────────────────────────────┘
    │
    │ B-Tree API调用
    ▼
┌────────────────────────────────────────────────────────────────────────┐
│ 5. B-Tree层                                                            │
├────────────────────────────────────────────────────────────────────────┤
│ sqlite3BtreeCursor() → 创建游标                                       │
│ sqlite3BtreeMoveto() → 定位键                                         │
│ sqlite3BtreeKey/Data() → 读取数据                                     │
└────────────────────────────────────────────────────────────────────────┘
    │
    │ Page request
    ▼
┌────────────────────────────────────────────────────────────────────────┐
│ 6. Pager层                                                             │
├────────────────────────────────────────────────────────────────────────┤
│ sqlite3PagerGet() → 获取页面                                          │
│   ├─ 检查页面缓存 (Page Cache)                                       │
│   ├─ 如果命中 → 直接返回                                              │
│   └─ 如果未命中 → 从WAL/DB读取                                        │
└────────────────────────────────────────────────────────────────────────┘
    │
    │ Read from disk
    ▼
┌────────────────────────────────────────────────────────────────────────┐
│ 7. VFS层 (Virtual File System)                                        │
├────────────────────────────────────────────────────────────────────────┤
│ xRead() → 读取文件                                                    │
│   ├─ WAL模式: 先查WAL，再查DB                                         │
│   └─ Rollback模式: 直接读DB                                           │
└────────────────────────────────────────────────────────────────────────┘
    │
    │ SQLITE_ROW
    ▼
用户应用获得结果行
```

### 6.2 事务执行控制流

```text
事务完整执行控制流（WAL模式）
══════════════════════════════════════════════════════════════════════════════

应用: BEGIN;
    │
    ▼
┌────────────────────────────────────────────────────────────────────────┐
│ sqlite3_exec("BEGIN")                                                  │
├────────────────────────────────────────────────────────────────────────┤
│ • 状态: NO_TRANSACTION → READING                                      │
│ • 获取事务ID (如果是写事务)                                           │
│ • 记录WAL快照点: last_valid_frame                                     │
└────────────────────────────────────────────────────────────────────────┘

应用: UPDATE users SET name='new' WHERE id=1;
    │
    ▼
┌────────────────────────────────────────────────────────────────────────┐
│ 写操作触发                                                             │
├────────────────────────────────────────────────────────────────────────┤
│ 1. 尝试获取WAL写锁                                                     │
│    ├─ 成功: 状态 READING → WRITING                                   │
│    └─ 失败: 返回SQLITE_BUSY                                           │
│                                                                        │
│ 2. 加载要修改的页面                                                   │
│    Pager.get(page_num) → 页面加载到缓存                              │
│                                                                        │
│ 3. 修改页面内容                                                       │
│    B-Tree层更新数据                                                   │
│                                                                        │
│ 4. 标记页面为脏 (dirty)                                               │
│    page.flags |= PGHDR_DIRTY                                          │
└────────────────────────────────────────────────────────────────────────┘

应用: COMMIT;
    │
    ▼
┌────────────────────────────────────────────────────────────────────────┐
│ sqlite3_exec("COMMIT")                                                 │
├────────────────────────────────────────────────────────────────────────┤
│ 1. 将所有脏页写入WAL                                                  │
│    for each dirty_page:                                               │
│      sqlite3WalFrames() → 追加WAL帧                                   │
│                                                                        │
│ 2. 写入commit record                                                  │
│    frame.database_size = total_pages                                  │
│    ↑ 标记为提交帧                                                     │
│                                                                        │
│ 3. fsync WAL文件                                                      │
│    xSync(wal_fd) → 确保数据持久化                                     │
│                                                                        │
│ 4. 更新WAL索引（共享内存）                                            │
│    wal_index.max_frame += num_frames                                  │
│                                                                        │
│ 5. 释放WAL写锁                                                        │
│    状态: WRITING → NO_TRANSACTION                                     │
│                                                                        │
│ 6. 检查是否需要checkpoint                                             │
│    if (wal_size > autocheckpoint_threshold):                          │
│      background_checkpoint()                                          │
└────────────────────────────────────────────────────────────────────────┘
    │
    ▼
事务完成，数据持久化
```

### 6.3 并发读写交互流程

参考第四章4.3节的详细时序图。

### 6.4 崩溃恢复控制流

```text
崩溃恢复控制流（WAL模式）
══════════════════════════════════════════════════════════════════════════════

应用: sqlite3_open("db.sqlite")
    │
    ▼
┌────────────────────────────────────────────────────────────────────────┐
│ 1. 打开数据库文件                                                      │
├────────────────────────────────────────────────────────────────────────┤
│ • 检查db.sqlite存在                                                   │
│ • 检查db.sqlite-wal存在                                               │
│ • 检查db.sqlite-shm存在                                               │
└────────────────────────────────────────────────────────────────────────┘
    │
    │ 发现WAL文件存在
    ▼
┌────────────────────────────────────────────────────────────────────────┐
│ 2. 检查WAL文件有效性                                                   │
├────────────────────────────────────────────────────────────────────────┤
│ • 读取WAL header                                                      │
│ • 验证magic number                                                    │
│ • 验证checksum                                                        │
└────────────────────────────────────────────────────────────────────────┘
    │
    │ WAL有效
    ▼
┌────────────────────────────────────────────────────────────────────────┐
│ 3. 扫描WAL文件                                                         │
├────────────────────────────────────────────────────────────────────────┤
│ for each frame in WAL:                                                │
│   • 验证frame checksum                                                │
│   • 验证salt匹配                                                      │
│   • 查找commit record (database_size > 0)                             │
│   • 记录最后有效的commit frame                                        │
└────────────────────────────────────────────────────────────────────────┘
    │
    │ 找到commit records
    ▼
┌────────────────────────────────────────────────────────────────────────┐
│ 4. 执行恢复                                                            │
├────────────────────────────────────────────────────────────────────────┤
│ 选择恢复策略:                                                         │
│                                                                        │
│ 策略A: Hot Journal Recovery（即时恢复）                               │
│   • 将WAL中已提交的帧应用到主数据库                                   │
│   • 按frame顺序回放                                                   │
│   • 更新主数据库文件                                                  │
│                                                                        │
│ 策略B: 保留WAL（延迟恢复）                                            │
│   • 不立即合并WAL                                                     │
│   • 读操作时从WAL读取                                                 │
│   • 等待checkpoint时机                                                │
└────────────────────────────────────────────────────────────────────────┘
    │
    │ SQLite选择策略B（性能更好）
    ▼
┌────────────────────────────────────────────────────────────────────────┐
│ 5. 重建WAL索引                                                         │
├────────────────────────────────────────────────────────────────────────┤
│ • 清空共享内存(db.sqlite-shm)                                         │
│ • 重新扫描WAL文件                                                     │
│ • 构建page → frame映射                                                │
│ • 更新max_frame指针                                                   │
└────────────────────────────────────────────────────────────────────────┘
    │
    │ 恢复完成
    ▼
数据库可用，所有已提交事务已恢复
```

---

## 七、数据流与版本流

### 7.1 数据写入路径

```text
数据写入完整路径
══════════════════════════════════════════════════════════════════════════════

UPDATE users SET name='John' WHERE id=1;

┌─────────────────┐
│ 应用层          │ UPDATE语句
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ SQL引擎         │ 解析 → 优化 → 生成VDBE代码
└────────┬────────┘
         │ VDBE操作码
         ▼
┌─────────────────┐
│ VDBE执行器      │ 执行OpenWrite/Update操作
└────────┬────────┘
         │ BTree API
         ▼
┌─────────────────┐
│ B-Tree层        │
├─────────────────┤
│ 1. 定位记录     │ sqlite3BtreeMoveto(cursor, key)
│ 2. 读取页面     │ getPage(page_num)
│ 3. 修改数据     │ 在页面中更新记录
│ 4. 标记脏页     │ page->flags |= DIRTY
└────────┬────────┘
         │ 页面写入请求
         ▼
┌─────────────────────────────────────────────────────────────────────────┐
│ Pager层                                                                 │
├─────────────────────────────────────────────────────────────────────────┤
│ WAL模式:                                                                │
│ 1. 检查WAL写锁                                                          │
│    if (!have_write_lock):                                              │
│      acquire_wal_write_lock() → 可能SQLITE_BUSY                        │
│                                                                         │
│ 2. 将脏页写入WAL                                                        │
│    sqlite3WalFrames(page_list):                                        │
│      for page in page_list:                                            │
│        write_wal_frame(page_num, page_data)                            │
│                                                                         │
│ 3. COMMIT时写入commit record                                            │
│    write_commit_frame(database_size)                                   │
│                                                                         │
│ 4. fsync WAL文件                                                        │
│    xSync(wal_fd)                                                        │
└────────┬────────────────────────────────────────────────────────────────┘
         │ WAL帧
         ▼
┌─────────────────────────────────────────────────────────────────────────┐
│ WAL文件 (db.sqlite-wal)                                                 │
├─────────────────────────────────────────────────────────────────────────┤
│ [Frame N+1]: page_num=5, data=..., checksum=...                        │
│ [Frame N+2]: page_num=7, data=..., checksum=...                        │
│ [Commit]:    database_size=1000, salt=..., checksum=...                │
└─────────────────────────────────────────────────────────────────────────┘
         │
         │ 异步checkpoint
         ▼
┌─────────────────────────────────────────────────────────────────────────┐
│ 主数据库文件 (db.sqlite)                                                │
├─────────────────────────────────────────────────────────────────────────┤
│ WAL帧最终合并到主文件（checkpoint）                                     │
│ • 读取WAL帧                                                             │
│ • 写入对应页面到主文件                                                  │
│ • 更新文件头                                                            │
└─────────────────────────────────────────────────────────────────────────┘

═══════════════════════════════════════════════════════════════════════════

数据流关键点:
• 写入内存: B-Tree层修改页面缓存（微秒级）
• 写入WAL: 顺序追加到WAL文件（毫秒级）
• 写入主DB: checkpoint时批量写入（秒级，异步）
```

### 7.2 数据读取路径

```text
数据读取完整路径
══════════════════════════════════════════════════════════════════════════════

SELECT * FROM users WHERE id=1;

┌─────────────────┐
│ 应用层          │ SELECT语句
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ SQL引擎         │ 解析 → 选择索引 → 生成执行计划
└────────┬────────┘
         │ VDBE操作码
         ▼
┌─────────────────┐
│ VDBE执行器      │ 执行OpenRead/SeekGE操作
└────────┬────────┘
         │ BTree API
         ▼
┌─────────────────┐
│ B-Tree层        │
├─────────────────┤
│ 1. 打开游标     │ sqlite3BtreeCursor(table/index)
│ 2. 定位记录     │ sqlite3BtreeMoveto(key=1)
│ 3. 请求页面     │ getPage(page_num)
└────────┬────────┘
         │ 页面请求
         ▼
┌─────────────────────────────────────────────────────────────────────────┐
│ Pager层                                                                 │
├─────────────────────────────────────────────────────────────────────────┤
│ 1. 检查页面缓存                                                         │
│    page = lookupInCache(page_num)                                      │
│    if (page && page->in_cache):                                        │
│      return page  // 缓存命中！                                        │
│                                                                         │
│ 2. 缓存未命中，从存储加载                                              │
│    page = allocatePage()                                               │
│    readFromStorage(page_num, page)                                     │
└────────┬────────────────────────────────────────────────────────────────┘
         │ 读取存储
         ▼
┌─────────────────────────────────────────────────────────────────────────┐
│ WAL层（WAL模式）                                                        │
├─────────────────────────────────────────────────────────────────────────┤
│ 1. 查询WAL索引（共享内存）                                              │
│    frame_id = wal_index.findPage(page_num, snapshot)                   │
│                                                                         │
│ 2. 如果在WAL中找到                                                      │
│    if (frame_id != NOT_FOUND && frame_id <= snapshot):                 │
│      read_from_wal(frame_id) → 返回WAL中的数据                         │
│                                                                         │
│ 3. 如果WAL中没有                                                        │
│    else:                                                               │
│      read_from_main_db(page_num) → 读取主数据库                        │
└────────┬────────────────────────────────────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────────────────────────────────────┐
│ VFS层                                                                   │
├─────────────────────────────────────────────────────────────────────────┤
│ xRead(fd, buffer, size, offset)                                        │
│ • WAL文件读取: 顺序IO（快）                                             │
│ • 主DB文件读取: 可能随机IO                                              │
└─────────────────────────────────────────────────────────────────────────┘
         │
         ▼
数据返回给应用

═══════════════════════════════════════════════════════════════════════════

读取性能优化:
• 页面缓存: 避免磁盘IO（最快）
• WAL索引: 快速定位页面位置（O(1)哈希查找）
• mmap: 减少内存复制（PRAGMA mmap_size）
```

### 7.3 WAL数据版本流

```text
WAL数据版本演进流
══════════════════════════════════════════════════════════════════════════════

时间线: T0 → T1 → T2 → T3 → T4

T0: 初始状态
┌──────────────────────────────────────────────────────────────────────┐
│ 主数据库 (db.sqlite)                                                 │
├──────────────────────────────────────────────────────────────────────┤
│ Page 5: {id:1, name:'Alice', age:30}                                 │
└──────────────────────────────────────────────────────────────────────┘
│ WAL文件: 空                                                          │
└──────────────────────────────────────────────────────────────────────┘

T1: 事务1更新
┌──────────────────────────────────────────────────────────────────────┐
│ 主数据库 (不变)                                                      │
├──────────────────────────────────────────────────────────────────────┤
│ Page 5: {id:1, name:'Alice', age:30}                                 │
└──────────────────────────────────────────────────────────────────────┘
│ WAL文件                                                              │
├──────────────────────────────────────────────────────────────────────┤
│ Frame 1: page=5, data={id:1, name:'Alice', age:31}, db_size=0       │
│ Frame 2: commit record, db_size=1000 ← 提交标记                     │
└──────────────────────────────────────────────────────────────────────┘

T2: 读事务A开始 (snapshot=2)
     读事务看到: name='Alice', age=31 (从Frame 1读取)

T3: 事务2更新
┌──────────────────────────────────────────────────────────────────────┐
│ 主数据库 (不变)                                                      │
├──────────────────────────────────────────────────────────────────────┤
│ Page 5: {id:1, name:'Alice', age:30}                                 │
└──────────────────────────────────────────────────────────────────────┘
│ WAL文件                                                              │
├──────────────────────────────────────────────────────────────────────┤
│ Frame 1: page=5, data={id:1, name:'Alice', age:31}, db_size=0       │
│ Frame 2: commit record, db_size=1000                                │
│ Frame 3: page=5, data={id:1, name:'Bob', age:31}, db_size=0         │
│ Frame 4: commit record, db_size=1000 ← 新提交                       │
└──────────────────────────────────────────────────────────────────────┘

     读事务A仍然看到: name='Alice', age=31 (snapshot=2, 读Frame 1)
     新读事务B看到: name='Bob', age=31 (snapshot=4, 读Frame 3)

T4: Checkpoint
┌──────────────────────────────────────────────────────────────────────┐
│ 主数据库 (更新)                                                      │
├──────────────────────────────────────────────────────────────────────┤
│ Page 5: {id:1, name:'Bob', age:31} ← Frame 3合并                     │
└──────────────────────────────────────────────────────────────────────┘
│ WAL文件: 截断或重置                                                  │
└──────────────────────────────────────────────────────────────────────┘

═══════════════════════════════════════════════════════════════════════════

版本可见性规则:
• 读事务只看snapshot时刻及之前的已提交数据
• WAL中同一页面可能有多个版本（多个frame）
• 读取时选择 max(frame_id) WHERE frame_id <= snapshot
```

### 7.4 页面生命周期

```text
页面完整生命周期
══════════════════════════════════════════════════════════════════════════════

1. 页面创建
   ┌──────────────────────────────────────────────────────────────────┐
   │ INSERT INTO table VALUES (...)                                   │
   │ ↓                                                                │
   │ B-Tree分配新页面                                                 │
   │ • 从freelist获取（如果有）                                       │
   │ • 或扩展文件（增加page_count）                                   │
   │ • 初始化页面头部                                                 │
   │ • 插入数据                                                       │
   │ • 标记为脏页                                                     │
   └──────────────────────────────────────────────────────────────────┘

2. 页面使用
   ┌──────────────────────────────────────────────────────────────────┐
   │ SELECT/UPDATE/DELETE操作                                         │
   │ ↓                                                                │
   │ 页面加载到缓存                                                   │
   │ • Pager.get(page_num)                                            │
   │ • 从WAL或主DB读取                                                │
   │ • 加入LRU缓存                                                    │
   │ • 增加引用计数                                                   │
   └──────────────────────────────────────────────────────────────────┘

3. 页面修改
   ┌──────────────────────────────────────────────────────────────────┐
   │ UPDATE/DELETE操作                                                │
   │ ↓                                                                │
   │ 页面变为脏页                                                     │
   │ • flags |= PGHDR_DIRTY                                           │
   │ • 加入dirty list                                                 │
   │ • 等待事务提交时写入                                             │
   └──────────────────────────────────────────────────────────────────┘

4. 页面写入（COMMIT时）
   ┌──────────────────────────────────────────────────────────────────┐
   │ COMMIT                                                           │
   │ ↓                                                                │
   │ WAL模式:                                                         │
   │ • 脏页写入WAL文件                                                │
   │ • 写入commit record                                              │
   │ • fsync                                                          │
   │ • 清除DIRTY标记                                                  │
   │                                                                  │
   │ Rollback模式:                                                    │
   │ • 脏页写入主数据库                                               │
   │ • 删除journal                                                    │
   │ • 清除DIRTY标记                                                  │
   └──────────────────────────────────────────────────────────────────┘

5. 页面淘汰（缓存满时）
   ┌──────────────────────────────────────────────────────────────────┐
   │ 缓存空间不足                                                     │
   │ ↓                                                                │
   │ LRU算法选择牺牲页面                                              │
   │ • 选择refcount=0的页面                                           │
   │ • 如果是脏页，先写入                                             │
   │ • 从缓存移除                                                     │
   │ • 释放内存                                                       │
   └──────────────────────────────────────────────────────────────────┘

6. 页面删除（DELETE/VACUUM）
   ┌──────────────────────────────────────────────────────────────────┐
   │ DELETE/DROP TABLE/VACUUM                                         │
   │ ↓                                                                │
   │ 页面加入freelist                                                 │
   │ • B-Tree标记页面为free                                           │
   │ • 加入空闲页面链表                                               │
   │ • 可被后续INSERT重用                                             │
   │ • VACUUM时回收空间                                               │
   └──────────────────────────────────────────────────────────────────┘

═══════════════════════════════════════════════════════════════════════════

页面状态图:

     创建
       │
       ▼
    [干净页] ←──────── 读取/初始化
       │
       │ 修改
       ▼
    [脏页]
       │
       │ COMMIT
       ▼
   写入WAL/DB
       │
       ▼
    [干净页]
       │
       │ 缓存淘汰
       ▼
     释放
       │
       │ 重用或VACUUM
       ▼
    [空闲页]
```

---

## 八、多视角全面分析

### 8.1 使用者视角

**关注点**：如何正确使用SQLite，如何配置以获得最佳性能

```python
# 使用者最佳实践

import sqlite3

# 1. 连接配置（推荐设置）
conn = sqlite3.connect('mydb.db')
conn.execute("PRAGMA journal_mode=WAL")        # 启用WAL模式
conn.execute("PRAGMA synchronous=NORMAL")      # 平衡性能与安全
conn.execute("PRAGMA cache_size=-64000")       # 64MB缓存
conn.execute("PRAGMA foreign_keys=ON")         # 启用外键
conn.execute("PRAGMA temp_store=MEMORY")       # 临时表内存存储

# 2. 事务最佳实践
try:
    conn.execute("BEGIN IMMEDIATE")  # 立即获取写锁
    # 批量操作
    data = [(i, f'user{i}') for i in range(1000)]
    conn.executemany("INSERT INTO users VALUES (?, ?)", data)
    conn.commit()
except sqlite3.Error as e:
    conn.rollback()
    print(f"Error: {e}")

# 3. 查询优化
# 使用参数化查询（防SQL注入+性能）
cursor = conn.execute("SELECT * FROM users WHERE id=?", (1,))

# 4. 连接管理
# 使用上下文管理器
with sqlite3.connect('mydb.db') as conn:
    conn.execute("INSERT INTO users VALUES (?, ?)", (1, 'Alice'))
    # 自动commit或rollback

# 5. 性能监控
def check_db_status(conn):
    """检查数据库状态"""
    # WAL文件大小
    wal_size = conn.execute(
        "SELECT page_count * page_size FROM pragma_wal_file"
    ).fetchone()
    print(f"WAL size: {wal_size[0] / 1024 / 1024:.2f}MB" if wal_size else "No WAL")

    # 缓存命中率
    stats = conn.execute("PRAGMA cache_spill").fetchone()

    # 触发checkpoint（如果WAL太大）
    if wal_size and wal_size[0] > 100 * 1024 * 1024:  # >100MB
        conn.execute("PRAGMA wal_checkpoint(PASSIVE)")

# 6. 常见错误处理
def handle_busy_error():
    """处理SQLITE_BUSY错误"""
    import time
    max_retries = 5
    for i in range(max_retries):
        try:
            conn.execute("BEGIN IMMEDIATE")
            # 执行操作
            break
        except sqlite3.OperationalError as e:
            if "database is locked" in str(e):
                time.sleep(0.1 * (i + 1))  # 指数退避
            else:
                raise
```

### 8.2 设计者视角

**关注点**：架构设计、权衡决策、系统演进

```text
SQLite架构设计关键决策
══════════════════════════════════════════════════════════════════════════════

决策1: 单写者模型 vs 多写者模型
┌────────────────────────────────────────────────────────────────────────┐
│ SQLite选择：单写者模型（Single Writer）                               │
│                                                                        │
│ 优点：                                                                 │
│ • 实现简单：无需复杂的冲突检测                                        │
│ • 无死锁：不会有写-写死锁                                             │
│ • 确定性：事务顺序明确                                                │
│ • 易于推理：程序行为可预测                                            │
│                                                                        │
│ 缺点：                                                                 │
│ • 写入并发度受限：同时只能一个写事务                                  │
│ • 不适合写密集型场景                                                  │
│                                                                        │
│ 适用场景：                                                             │
│ • 嵌入式应用（单进程多线程）                                          │
│ • 读多写少的应用                                                      │
│ • 客户端应用（浏览器、移动App）                                       │
└────────────────────────────────────────────────────────────────────────┘

决策2: 页面大小选择
┌────────────────────────────────────────────────────────────────────────┐
│ SQLite默认：4KB（可配置1KB-64KB）                                     │
│                                                                        │
│ 权衡分析：                                                             │
│ • 小页面(1-2KB)：                                                      │
│   + 内存占用小                                                        │
│   + 适合小记录                                                        │
│   - 索引层数多                                                        │
│   - B-Tree遍历慢                                                      │
│                                                                        │
│ • 中等页面(4-8KB)：                                                    │
│   + 平衡性能                                                          │
│   + 适合大多数场景                                                    │
│                                                                        │
│ • 大页面(16-64KB)：                                                    │
│   + B-Tree层数少                                                      │
│   + 大记录效率高                                                      │
│   - 内存占用大                                                        │
│   - 小记录浪费空间                                                    │
│                                                                        │
│ 推荐：                                                                 │
│ • 嵌入式/移动：4KB                                                     │
│ • 桌面应用：8KB                                                        │
│ • 服务器/大数据：16-32KB                                               │
└────────────────────────────────────────────────────────────────────────┘

决策3: 锁粒度
┌────────────────────────────────────────────────────────────────────────┐
│ SQLite选择：数据库级锁（Database-level Locking）                      │
│                                                                        │
│ 对比其他方案：                                                         │
│ • 表级锁：复杂度中等，并发度中等                                      │
│ • 行级锁：复杂度高，并发度高（PostgreSQL/MySQL）                      │
│ • 数据库级锁：简单，并发度低                                          │
│                                                                        │
│ SQLite为何选择数据库级锁？                                             │
│ 1. 实现简单：无需复杂的锁管理器                                       │
│ 2. 零配置：不需要锁服务器                                             │
│ 3. 单文件：符合单文件数据库定位                                       │
│ 4. WAL补偿：WAL模式大幅改善并发（读不阻塞写）                         │
│                                                                        │
│ 演进路径：                                                             │
│ v1: Rollback Journal + 数据库锁 → 读写互斥                            │
│ v2: WAL + 数据库锁 → 读不阻塞写                                       │
│ 未来?: 可能引入更细粒度的锁（需保持兼容性）                           │
└────────────────────────────────────────────────────────────────────────┘
```

### 8.3 程序员视角

**关注点**：源码实现、数据结构、算法

```c
// 核心数据结构（简化）

/* Pager对象：管理页面和事务 */
struct Pager {
  sqlite3_vfs *pVfs;       /* OS接口 */
  sqlite3_file *fd;        /* 数据库文件描述符 */
  sqlite3_file *jfd;       /* Journal文件描述符 */
  Wal *pWal;               /* WAL对象（WAL模式） */
  PCache *pPCache;         /* 页面缓存 */

  u8 eState;               /* Pager状态 */
  u8 eLock;                /* 锁级别 */
  u8 journalMode;          /* Journal模式 */
  u8 syncFlags;            /* 同步标志 */

  i64 journalOff;          /* Journal写位置 */
  i64 journalHdr;          /* Journal头位置 */

  PgHdr *pDirty;           /* 脏页链表 */
  PgHdr *pInJournal;       /* 已写入Journal的页面 */
};

/* WAL对象 */
struct Wal {
  sqlite3_vfs *pVfs;       /* VFS接口 */
  sqlite3_file *pWalFd;    /* WAL文件描述符 */
  sqlite3_file *pDbFd;     /* DB文件描述符 */

  WalIndexHdr *pSnapshot;  /* 读事务的快照 */
  u32 mxFrame;             /* WAL中最大帧号 */

  WalHashLoc shmLoc;       /* 共享内存位置 */
  volatile u32 *aShmHash;  /* WAL索引（共享内存） */

  u8 readLock;             /* 读锁状态 */
  u8 writeLock;            /* 写锁状态 */
};

/* B-Tree游标 */
struct BtCursor {
  Btree *pBtree;           /* B-Tree对象 */
  BtShared *pBt;           /* 共享B-Tree */

  u8 eState;               /* 游标状态 */
  u8 curFlags;             /* 游标标志 */

  Pgno pgnoRoot;           /* 根页面号 */
  i64 cachedRowid;         /* 缓存的rowid */

  CellInfo info;           /* 当前单元格信息 */
  struct KeyInfo *pKeyInfo;/* 键信息 */

  Pgno *aOverflow;         /* 溢出页面 */
  MemPage *pPage;          /* 当前页面 */
};

// 关键函数调用链

/* 事务提交流程 */
int sqlite3BtreeCommit(Btree *p) {
  // 1. 检查是否有待提交的修改
  if (!p->inTrans) return SQLITE_OK;

  // 2. 将脏页写入Journal/WAL
  rc = sqlite3PagerCommitPhaseOne(p->pBt->pPager, ...);
  if (rc != SQLITE_OK) return rc;

  // 3. 同步到磁盘
  rc = sqlite3PagerCommitPhaseTwo(p->pBt->pPager);
  if (rc != SQLITE_OK) return rc;

  // 4. 清理状态
  p->inTrans = 0;
  return SQLITE_OK;
}

/* WAL写入流程 */
int sqlite3WalFrames(
  Wal *pWal,           /* WAL对象 */
  int szPage,          /* 页面大小 */
  PgHdr *pList,        /* 脏页链表 */
  Pgno nTruncate,      /* 截断页数 */
  int isCommit,        /* 是否提交 */
  int sync_flags       /* 同步标志 */
) {
  // 1. 获取WAL写锁
  rc = walLockExclusive(pWal, WAL_WRITE_LOCK, 1);
  if (rc) return rc;

  // 2. 为每个页面写入WAL帧
  for (PgHdr *p = pList; p; p = p->pDirty) {
    rc = walWriteOneFrame(pWal, p, szPage, ...);
    if (rc) goto out;
  }

  // 3. 如果是提交，写入commit record
  if (isCommit) {
    rc = walWriteCommitRecord(pWal, nTruncate);
    if (rc) goto out;
  }

  // 4. 同步WAL文件
  if (sync_flags) {
    rc = sqlite3OsSync(pWal->pWalFd, sync_flags);
  }

out:
  // 5. 释放WAL写锁
  walUnlockExclusive(pWal, WAL_WRITE_LOCK, 1);
  return rc;
}

/* 页面读取流程 */
int sqlite3PagerGet(
  Pager *pPager,       /* Pager对象 */
  Pgno pgno,           /* 页面号 */
  DbPage **ppPage,     /* 输出页面 */
  int flags            /* 标志 */
) {
  // 1. 查找页面缓存
  PgHdr *pPg = sqlite3PcacheFetch(pPager->pPCache, pgno, ...);
  if (pPg) {
    // 缓存命中
    *ppPage = pPg;
    return SQLITE_OK;
  }

  // 2. 缓存未命中，分配新页面
  pPg = sqlite3PcacheFetchFinish(pPager->pPCache, pgno, ...);

  // 3. 从WAL或DB读取
  if (pPager->pWal) {
    // WAL模式：先查WAL
    rc = sqlite3WalRead(pPager->pWal, pgno, &inWal, pPg->pData);
    if (!inWal) {
      // WAL中没有，读DB
      rc = readDbPage(pPager, pPg, pgno);
    }
  } else {
    // Rollback模式：直接读DB
    rc = readDbPage(pPager, pPg, pgno);
  }

  *ppPage = pPg;
  return rc;
}
```

### 8.4 数据转换视角

**关注点**：数据如何在不同层次间转换和流动

```text
数据转换全流程
══════════════════════════════════════════════════════════════════════════════

SQL → 内部表示 → 字节码 → 页面 → 磁盘

1. SQL文本 → Token流
   "INSERT INTO users (id, name) VALUES (1, 'Alice')"
   ↓ Tokenizer
   [INSERT, INTO, users, (, id, ,, name, ), VALUES, (, 1, ,, 'Alice', )]

2. Token流 → AST（抽象语法树）
   INSERT
   ├── Table: users
   ├── Columns: [id, name]
   └── Values: [(1, 'Alice')]

3. AST → VDBE字节码
   0: Init 0 10
   1: OpenWrite 0 2 0        # 打开表users（root_page=2）
   2: Integer 1 1            # id=1 → 寄存器1
   3: String8 2 'Alice'      # name='Alice' → 寄存器2
   4: MakeRecord 1 2 3       # 构造记录 → 寄存器3
   5: NewRowid 0 4           # 生成rowid → 寄存器4
   6: Insert 0 3 4           # 插入记录
   7: Close 0
   8: Halt 0 0

4. VDBE执行 → B-Tree操作
   Insert操作 → sqlite3BtreeInsert(cursor, key, data, nData)

5. B-Tree层 → 页面修改
   • 定位插入位置（可能涉及树分裂）
   • 在叶子页面中插入单元格
   • 单元格格式：
     [payload_size][rowid][payload_data]
     payload_data = [header_size][serial_types][column_values]

6. 页面格式（物理布局）
   ┌─────────────────────────────────────────────────────────────────┐
   │ Page Header (8/12 bytes)                                        │
   ├─────────────────────────────────────────────────────────────────┤
   │ • page_type: 0x0D (table leaf)                                  │
   │ • first_freeblock: 0                                            │
   │ • cell_count: 1                                                 │
   │ • cell_content_offset: 4085                                     │
   │ • fragmented_bytes: 0                                           │
   ├─────────────────────────────────────────────────────────────────┤
   │ Cell Pointer Array                                              │
   ├─────────────────────────────────────────────────────────────────┤
   │ • cell_pointer[0]: 4085                                         │
   ├─────────────────────────────────────────────────────────────────┤
   │ Unallocated Space                                               │
   ├─────────────────────────────────────────────────────────────────┤
   │ Cell Content                                                    │
   ├─────────────────────────────────────────────────────────────────┤
   │ • payload_size: 15 (varint)                                     │
   │ • rowid: 1 (varint)                                             │
   │ • header_size: 3 (varint)                                       │
   │ • serial_type[0]: 1 (int8) → id列                              │
   │ • serial_type[1]: 13 (text5) → name列                          │
   │ • value[0]: 0x01 → id=1                                         │
   │ • value[1]: 'Alice' (5 bytes) → name='Alice'                   │
   └─────────────────────────────────────────────────────────────────┘

7. 页面 → WAL帧
   WAL Frame格式：
   ┌─────────────────────────────────────────────────────────────────┐
   │ Frame Header (24 bytes)                                         │
   ├─────────────────────────────────────────────────────────────────┤
   │ • page_number: 2                                                │
   │ • database_size: 0 (非commit帧)                                │
   │ • salt1: 0x12345678                                             │
   │ • salt2: 0x9ABCDEF0                                             │
   │ • checksum1: 0xXXXXXXXX                                         │
   │ • checksum2: 0xXXXXXXXX                                         │
   ├─────────────────────────────────────────────────────────────────┤
   │ Page Data (4096 bytes)                                          │
   │ [完整页面内容]                                                  │
   └─────────────────────────────────────────────────────────────────┘

8. WAL帧 → 磁盘块
   • write(wal_fd, frame_data, frame_size)
   • fsync(wal_fd) [如果synchronous=FULL]

反向流程（查询）：
   磁盘 → WAL帧 → 页面 → B-Tree → VDBE → 结果集 → Python对象

   SELECT * FROM users WHERE id=1
   ↓
   VDBE读取 → B-Tree查找 → 页面解析 → 单元格解码
   ↓
   {rowid: 1, id: 1, name: 'Alice'}  # 内部表示
   ↓
   (1, 'Alice')  # Python tuple
```

---

## 九、形式化证明体系

### 9.1 ACID属性形式化证明

参考第二章2.4节的详细证明。

### 9.2 锁机制正确性证明

参考第三章3.4节的死锁预防证明。

### 9.3 WAL崩溃恢复证明

参考第四章4.5节和06.04文档的WAL形式化验证。

### 9.4 快照隔离正确性证明

```text
快照隔离正确性形式化证明
══════════════════════════════════════════════════════════════════════════════

【定理】SQLite WAL模式提供快照隔离（Snapshot Isolation）

定义：
  Transaction T = (T.start, T.operations, T.commit)
  Snapshot(T) = WAL状态在T.start时刻的快照
  ReadSet(T) = T读取的数据项集合
  WriteSet(T) = T写入的数据项集合

快照隔离定义：
  ∀ Transaction T:
    1. T的所有读操作看到Snapshot(T)中的数据
    2. T的写操作在T.commit时可见
    3. 如果WriteSet(T1) ∩ WriteSet(T2) ≠ ∅，则T1和T2之一必须abort

证明SQLite WAL满足快照隔离：

(1) 快照一致性
    引理1.1: T的所有读操作看到Snapshot(T)

    证明：
    - T开始时记录max_frame_id = M
    - T的读操作只看frame_id ≤ M的帧
    - WAL索引（共享内存）维护page → frame映射
    - 对于page P，读取时选择max(frame_id) WHERE frame_id ≤ M
    - 后续事务写入frame_id > M的帧对T不可见
    ∴ T看到的是一致快照 □

(2) 写不影响读
    引理1.2: 并发写事务不影响读事务的快照

    证明：
    - 写事务W追加frame_id > M的帧到WAL
    - 读事务R使用Snapshot(R) with max_frame = M
    - R的读操作不会读取frame_id > M的帧
    - 因此W的写入对R不可见
    ∴ 写不影响读 □

(3) 写写冲突检测
    引理1.3: 同时只有一个写事务（单写者模型）

    证明：
    - WAL写锁是独占的（EXCLUSIVE）
    - 写事务必须持有WAL写锁才能写入
    - sqlite3WalBeginWriteTransaction()获取写锁
    - 如果写锁被占用，返回SQLITE_BUSY
    - 因此WriteSet(T1) ∩ WriteSet(T2) = ∅（时间上不重叠）
    ∴ 无写写冲突 □

(4) 提交顺序
    引理1.4: 事务提交是串行化的

    证明：
    - 写事务在持有WAL写锁时提交
    - WAL写锁确保提交操作串行执行
    - commit record按顺序写入WAL
    - WAL帧索引单调递增
    ∴ 提交顺序明确 □

综合证明：
由引理1.1-1.4，SQLite WAL模式满足快照隔离的所有条件 □

═══════════════════════════════════════════════════════════════════════════

【推论】快照隔离避免的异常

推论1: 无脏读（No Dirty Read）
  证明：
  - T1的未提交修改在frame_id > snapshot(T2)的帧中
  - T2不会读取这些帧
  ∴ T2不会看到T1的未提交数据 □

推论2: 无不可重复读（No Non-repeatable Read）
  证明：
  - T2的快照在T2.start时固定
  - 即使T1提交，T2的快照不变
  ∴ T2两次读取相同数据得到相同结果 □

推论3: 无幻读（No Phantom Read）
  证明：
  - T2的快照包含T2.start时的所有行
  - T1插入的新行在frame_id > snapshot(T2)
  ∴ T2不会看到T1插入的新行 □

注意：快照隔离不能完全避免写倾斜（Write Skew），需要应用层处理。
```

---

## 十、设计权衡与决策

### 10.1 设计决策树

```text
SQLite核心设计决策树
══════════════════════════════════════════════════════════════════════════════

                      设计目标
                         │
        ┌────────────────┼────────────────┐
        │                │                │
        ▼                ▼                ▼
    嵌入式优先      零配置简单      高可靠性
        │                │                │
    决策1: 单文件   决策2: 无服务器  决策3: ACID完整
        │                │                │
        └────────┬───────┴────────┬───────┘
                 │                │
                 ▼                ▼
          数据库级锁        单写者模型
                 │                │
                 ▼                ▼
          实现简单但          并发度受限
          并发度低               │
                 │                │
                 └────────┬───────┘
                          │
                          ▼
                     引入WAL模式
                          │
                    ┌─────┴─────┐
                    │           │
                    ▼           ▼
              读不阻塞写    大幅改善并发
                    │           │
                    └─────┬─────┘
                          │
                          ▼
                    设计成功！
            （嵌入式+简单+高可靠+性能）
```

### 10.2 性能权衡矩阵

```text
SQLite性能权衡决策矩阵
══════════════════════════════════════════════════════════════════════════════

┌────────────────┬──────────┬──────────┬──────────┬────────────────────┐
│ 设计选择       │ 性能影响 │ 复杂度   │ 可靠性   │ 权衡说明           │
├────────────────┼──────────┼──────────┼──────────┼────────────────────┤
│ 单文件架构     │ 中等     │ 低       │ 高       │ 简单 > 性能        │
│ 数据库级锁     │ 低       │ 低       │ 高       │ 简单 > 并发度      │
│ 单写者模型     │ 中等     │ 低       │ 高       │ 可靠性 > 并发写    │
│ WAL模式        │ 高       │ 中       │ 高       │ 性能提升明显       │
│ 页面缓存       │ 高       │ 中       │ 中       │ 必须的优化         │
│ B-Tree存储     │ 高       │ 中       │ 高       │ 标准选择           │
│ 无预写日志     │ 不适用   │ -        │ -        │ WAL前的遗留         │
└────────────────┴──────────┴──────────┴──────────┴────────────────────┘

性能优化优先级：
1. WAL模式（2x性能提升）
2. 页面缓存优化（避免IO）
3. 索引优化（避免全表扫描）
4. 批量事务（减少fsync）
5. 合理配置PRAGMA
```

### 10.3 场景选型决策

```text
SQLite适用场景决策树
══════════════════════════════════════════════════════════════════════════════

                    需要数据库？
                         │
                         │ YES
                         ▼
                   单机应用？
                    ┌────┴────┐
                    │         │
                  YES        NO
                    │         │
                    ▼         ▼
               SQLite       PostgreSQL
                合适         /MySQL
                │           更合适
                │
                ▼
          并发写入量？
            ┌───┴───┐
            │       │
          <10TPS  >100TPS
            │       │
            ▼       ▼
         SQLite   考虑升级到
         完美     客户端-服务器
                  架构

                    │
                    ▼
              需要分布式？
                ┌───┴───┐
                │       │
              YES      NO
                │       │
                ▼       ▼
           PostgreSQL  SQLite
           /MySQL      继续使用
```

---

## 相关资源

### 相关文档

- [01.02-事务与并发控制](./01.02-事务与并发控制.md) - 事务理论基础
- [01.04-SQLite核心机制深度解析(源码级)](./01.04-SQLite核心机制深度解析(源码级).md) - 源码实现细节
- [06.04-WAL模式形式化验证](../06-形式化理论/06.04-WAL模式形式化验证.md) - 形式化证明
- [03.04-性能优化与核心机制整合指南](../03-性能优化/03.04-性能优化与核心机制整合指南-v3.0.md) - 性能优化实践

### 外部资源

- [SQLite官方文档 - WAL模式](https://www.sqlite.org/wal.html)
- [SQLite官方文档 - 锁定与并发](https://www.sqlite.org/lockingv3.html)
- [SQLite源码](https://github.com/sqlite/sqlite)

---

**文档版本**: v3.0.0
**最后更新**: 2025-12-04
**维护者**: SQLite Knowledge Base Team
