# 查询优化：预编译语句与执行计划分析

> **创建日期**：2025-11-13
> **最后更新**：2025-11-13
> **版本**：SQLite 3.31+ 至 3.47+

---

## 📋 概述

查询优化是SQLite性能的关键。本文档深入解析预编译语句、参数化查询、EXPLAIN QUERY PLAN分析和索引使用技巧。

---

## 📑 目录

- [查询优化：预编译语句与执行计划分析](#查询优化预编译语句与执行计划分析)
  - [📋 概述](#-概述)
  - [📑 目录](#-目录)
  - [一、预编译语句（Prepared Statements）](#一预编译语句prepared-statements)
    - [1.1 预编译语句概述](#11-预编译语句概述)
    - [1.2 C API预编译语句](#12-c-api预编译语句)
    - [1.3 Python预编译语句](#13-python预编译语句)
    - [1.4 性能优势](#14-性能优势)
  - [二、参数化查询](#二参数化查询)
    - [2.1 SQL注入防护](#21-sql注入防护)
    - [2.2 参数绑定语法](#22-参数绑定语法)
    - [2.3 命名参数 vs 位置参数](#23-命名参数-vs-位置参数)
  - [三、EXPLAIN QUERY PLAN分析](#三explain-query-plan分析)
    - [3.1 EXPLAIN QUERY PLAN语法](#31-explain-query-plan语法)
    - [3.2 执行计划解读](#32-执行计划解读)
    - [3.3 常见执行计划模式](#33-常见执行计划模式)
    - [3.4 性能问题诊断](#34-性能问题诊断)
  - [四、索引使用技巧](#四索引使用技巧)
    - [4.1 索引选择策略](#41-索引选择策略)
    - [4.2 覆盖索引优化](#42-覆盖索引优化)
    - [4.3 部分索引使用](#43-部分索引使用)
    - [4.4 索引提示](#44-索引提示)
  - [五、查询重写优化](#五查询重写优化)
    - [5.1 子查询优化](#51-子查询优化)
    - [5.2 JOIN优化](#52-join优化)
    - [5.3 聚合查询优化](#53-聚合查询优化)
  - [六、查询优化最佳实践](#六查询优化最佳实践)
    - [6.1 查询设计原则](#61-查询设计原则)
    - [6.2 性能优化清单](#62-性能优化清单)
  - [🔗 相关资源](#-相关资源)
  - [📚 参考资料](#-参考资料)

---

## 一、预编译语句（Prepared Statements）

### 1.1 预编译语句概述

**定义**：预编译语句是预先解析和优化的SQL语句，可以重复执行而无需重新解析。

**优势**：

- **性能提升**：避免重复解析SQL语句
- **安全性**：防止SQL注入攻击
- **类型安全**：参数类型检查

### 1.2 C API预编译语句

**基本用法**：

```c
#include <sqlite3.h>

sqlite3* db;
sqlite3_stmt* stmt;

// 打开数据库
sqlite3_open("app.db", &db);

// 预编译语句
const char* sql = "SELECT * FROM users WHERE id = ? AND status = ?";
sqlite3_prepare_v2(db, sql, -1, &stmt, NULL);

// 绑定参数
sqlite3_bind_int(stmt, 1, 123);        // 第一个参数（索引从1开始）
sqlite3_bind_text(stmt, 2, "active", -1, SQLITE_STATIC);

// 执行查询
while (sqlite3_step(stmt) == SQLITE_ROW) {
    int id = sqlite3_column_int(stmt, 0);
    const char* name = (const char*)sqlite3_column_text(stmt, 1);
    printf("ID: %d, Name: %s\n", id, name);
}

// 重置语句（准备下次使用）
sqlite3_reset(stmt);

// 清理
sqlite3_finalize(stmt);
sqlite3_close(db);
```

**参数绑定函数**：

```c
sqlite3_bind_int(stmt, index, value);           // INTEGER
sqlite3_bind_int64(stmt, index, value);         // BIGINT
sqlite3_bind_double(stmt, index, value);        // REAL
sqlite3_bind_text(stmt, index, text, len, flag); // TEXT
sqlite3_bind_blob(stmt, index, data, len, flag); // BLOB
sqlite3_bind_null(stmt, index);                 // NULL
```

### 1.3 Python预编译语句

**基本用法**：

```python
import sqlite3

conn = sqlite3.connect('app.db')
cursor = conn.cursor()

# 预编译语句
stmt = cursor.execute(
    'SELECT * FROM users WHERE id = ? AND status = ?',
    (123, 'active')
)

# 获取结果
for row in stmt:
    print(row)

# 重复使用（参数不同）
cursor.execute(
    'SELECT * FROM users WHERE id = ? AND status = ?',
    (456, 'inactive')
)
```

**命名参数**：

```python
# 使用命名参数
cursor.execute(
    'SELECT * FROM users WHERE id = :user_id AND status = :status',
    {'user_id': 123, 'status': 'active'}
)
```

### 1.4 性能优势

**性能对比**：

| 方式 | 1000次查询耗时 | 说明 |
|------|--------------|------|
| 字符串拼接 | ~500ms | 每次解析SQL |
| 预编译语句 | ~50ms | 只解析一次 |
| **性能提升** | **10倍** | - |

---

## 二、参数化查询

### 2.1 SQL注入防护

**错误方式（易受SQL注入）**：

```python
# ❌ 危险：SQL注入风险
user_id = "123 OR 1=1"
query = f"SELECT * FROM users WHERE id = {user_id}"
# 结果：SELECT * FROM users WHERE id = 123 OR 1=1（返回所有用户）
```

**正确方式（参数化查询）**：

```python
# ✅ 安全：参数化查询
user_id = "123 OR 1=1"
cursor.execute("SELECT * FROM users WHERE id = ?", (user_id,))
# SQLite会将整个字符串作为参数值，不会执行SQL注入
```

### 2.2 参数绑定语法

**位置参数（?）**：

```sql
-- 使用?作为占位符
SELECT * FROM users WHERE id = ? AND name = ?;

-- 绑定参数
sqlite3_bind_int(stmt, 1, 123);
sqlite3_bind_text(stmt, 2, "Alice", -1, SQLITE_STATIC);
```

**命名参数（:name或$name）**：

```sql
-- 使用命名参数
SELECT * FROM users WHERE id = :user_id AND name = :user_name;

-- 绑定参数
sqlite3_bind_int(stmt, sqlite3_bind_parameter_index(stmt, ":user_id"), 123);
sqlite3_bind_text(stmt, sqlite3_bind_parameter_index(stmt, ":user_name"), "Alice", -1, SQLITE_STATIC);
```

### 2.3 命名参数 vs 位置参数

**位置参数（推荐用于简单查询）**：

```python
# 简单直接
cursor.execute("SELECT * FROM users WHERE id = ?", (123,))
```

**命名参数（推荐用于复杂查询）**：

```python
# 可读性更好
cursor.execute(
    "SELECT * FROM users WHERE id = :user_id AND status = :status",
    {'user_id': 123, 'status': 'active'}
)
```

---

## 三、EXPLAIN QUERY PLAN分析

### 3.1 EXPLAIN QUERY PLAN语法

**基本用法**：

```sql
-- 分析查询计划
EXPLAIN QUERY PLAN
SELECT * FROM users WHERE id = 123;
```

**输出示例**：

```text
QUERY PLAN
`--SEARCH users USING INTEGER PRIMARY KEY (rowid=?)
```

### 3.2 执行计划解读

**常见操作类型**：

| 操作 | 说明 | 性能 |
|------|------|------|
| **SCAN TABLE** | 全表扫描 | 最慢（O(n)） |
| **SEARCH TABLE** | 索引查找 | 快（O(log n)） |
| **SEARCH ... USING INDEX** | 使用索引 | 很快（O(log n)） |
| **SEARCH ... USING COVERING INDEX** | 覆盖索引 | 最快（无需回表） |

**执行计划示例**：

```sql
-- 全表扫描（慢）
EXPLAIN QUERY PLAN
SELECT * FROM users WHERE name = 'Alice';
-- 输出：SCAN TABLE users

-- 索引查找（快）
EXPLAIN QUERY PLAN
SELECT * FROM users WHERE id = 123;
-- 输出：SEARCH users USING INTEGER PRIMARY KEY (rowid=?)

-- 覆盖索引（最快）
EXPLAIN QUERY PLAN
SELECT id, name FROM users WHERE id = 123;
-- 输出：SEARCH users USING COVERING INDEX idx_id_name (id=?)
```

### 3.3 常见执行计划模式

**模式1：全表扫描**：

```sql
-- 问题：没有索引
EXPLAIN QUERY PLAN
SELECT * FROM orders WHERE status = 'pending';
-- 输出：SCAN TABLE orders

-- 解决方案：创建索引
CREATE INDEX idx_status ON orders(status);
-- 输出：SEARCH orders USING INDEX idx_status (status=?)
```

**模式2：索引查找**：

```sql
-- 使用索引
EXPLAIN QUERY PLAN
SELECT * FROM orders WHERE user_id = 123 AND status = 'pending';
-- 输出：SEARCH orders USING INDEX idx_user_status (user_id=? AND status=?)
```

**模式3：覆盖索引**：

```sql
-- 覆盖索引（查询列都在索引中）
EXPLAIN QUERY PLAN
SELECT user_id, status FROM orders WHERE user_id = 123;
-- 输出：SEARCH orders USING COVERING INDEX idx_user_status (user_id=?)
```

### 3.4 性能问题诊断

**诊断步骤**：

1. **执行EXPLAIN QUERY PLAN**：查看执行计划
2. **检查是否使用索引**：如果没有，创建索引
3. **检查是否全表扫描**：如果出现SCAN TABLE，需要优化
4. **检查索引选择性**：低选择性索引可能不如全表扫描

**示例诊断**：

```sql
-- 步骤1：分析查询
EXPLAIN QUERY PLAN
SELECT * FROM users WHERE email = 'alice@example.com';
-- 输出：SCAN TABLE users（全表扫描）

-- 步骤2：创建索引
CREATE INDEX idx_email ON users(email);

-- 步骤3：再次分析
EXPLAIN QUERY PLAN
SELECT * FROM users WHERE email = 'alice@example.com';
-- 输出：SEARCH users USING INDEX idx_email (email=?)（使用索引）
```

---

## 四、索引使用技巧

### 4.1 索引选择策略

**索引选择原则**：

1. **高选择性列**：不同值多的列优先
2. **查询频率**：频繁查询的列优先
3. **WHERE子句**：WHERE条件中的列优先
4. **JOIN条件**：JOIN条件中的列优先

**选择性计算**：

```sql
-- 计算列的选择性
SELECT
    COUNT(DISTINCT status) * 1.0 / COUNT(*) as selectivity
FROM orders;
-- 选择性 > 0.1 时，索引才有价值
```

### 4.2 覆盖索引优化

**覆盖索引定义**：索引包含查询所需的所有列，无需回表查询。

**示例**：

```sql
-- 查询：只需要user_id和status
SELECT user_id, status FROM orders WHERE user_id = 123;

-- 普通索引（需要回表）
CREATE INDEX idx_user_id ON orders(user_id);
-- 执行计划：SEARCH orders USING INDEX idx_user_id (user_id=?)

-- 覆盖索引（无需回表）
CREATE INDEX idx_covering ON orders(user_id, status);
-- 执行计划：SEARCH orders USING COVERING INDEX idx_covering (user_id=?)
-- 性能提升：2-5倍
```

### 4.3 部分索引使用

**部分索引**：只索引满足条件的行。

**示例**：

```sql
-- 只索引活跃用户（减少索引大小）
CREATE INDEX idx_active_users ON users(last_login)
WHERE status = 'active';

-- 查询活跃用户（使用索引）
SELECT * FROM users WHERE status = 'active' AND last_login > ?;
-- 执行计划：SEARCH users USING INDEX idx_active_users (last_login>?)

-- 查询非活跃用户（不使用索引）
SELECT * FROM users WHERE status = 'inactive';
-- 执行计划：SCAN TABLE users
```

### 4.4 索引提示

**SQLite不支持索引提示**：

SQLite不支持`USE INDEX`或`FORCE INDEX`语法，但可以通过以下方式影响索引选择：

1. **创建合适的索引**：确保有最优索引
2. **使用ANALYZE**：更新统计信息
3. **查询重写**：调整查询顺序

---

## 五、查询重写优化

### 5.1 子查询优化

**IN子查询优化**：

```sql
-- 方式1：IN子查询（可能较慢）
SELECT * FROM users WHERE id IN (SELECT user_id FROM orders WHERE status = 'pending');

-- 方式2：JOIN（通常更快）
SELECT DISTINCT u.* FROM users u
JOIN orders o ON u.id = o.user_id
WHERE o.status = 'pending';
```

**EXISTS优化**：

```sql
-- EXISTS通常比IN快
SELECT * FROM users u
WHERE EXISTS (
    SELECT 1 FROM orders o
    WHERE o.user_id = u.id AND o.status = 'pending'
);
```

### 5.2 JOIN优化

**JOIN顺序优化**：

```sql
-- 原则：小表在前，大表在后
-- 方式1：小表在前（推荐）
SELECT * FROM small_table s
JOIN large_table l ON s.id = l.small_id;

-- 方式2：大表在前（不推荐）
SELECT * FROM large_table l
JOIN small_table s ON l.small_id = s.id;
```

**索引JOIN优化**：

```sql
-- 确保JOIN列有索引
CREATE INDEX idx_user_id ON orders(user_id);

-- JOIN查询
SELECT u.name, o.amount
FROM users u
JOIN orders o ON u.id = o.user_id;
-- 执行计划：使用索引进行JOIN
```

### 5.3 聚合查询优化

**GROUP BY优化**：

```sql
-- 确保GROUP BY列有索引
CREATE INDEX idx_dept_status ON employees(dept_id, status);

-- 聚合查询
SELECT dept_id, status, COUNT(*)
FROM employees
GROUP BY dept_id, status;
-- 执行计划：使用索引进行分组
```

**LIMIT优化**：

```sql
-- 使用LIMIT减少结果集
SELECT * FROM users ORDER BY created_at DESC LIMIT 10;
-- 如果created_at有索引，只扫描10行
```

---

## 六、查询优化最佳实践

### 6.1 查询设计原则

1. **使用索引**：确保WHERE、JOIN、ORDER BY列有索引
2. **避免全表扫描**：使用EXPLAIN QUERY PLAN检查
3. **使用覆盖索引**：减少回表查询
4. **限制结果集**：使用LIMIT
5. **避免SELECT ***：只查询需要的列

### 6.2 性能优化清单

- ✅ 使用预编译语句
- ✅ 使用参数化查询（防止SQL注入）
- ✅ 为WHERE条件创建索引
- ✅ 为JOIN条件创建索引
- ✅ 使用覆盖索引
- ✅ 使用EXPLAIN QUERY PLAN分析
- ✅ 避免全表扫描
- ✅ 使用LIMIT限制结果集

---

## 🔗 相关资源

- [03.02 优化策略](../03-性能优化/03.02-优化策略.md) - 性能优化策略
- [02.02 表结构设计](../02-数据模型/02.02-表结构设计.md) - 索引设计最佳实践
- [07.01 SQL标准对齐](../07-标准对齐/07.01-SQL标准对齐.md) - SQL标准函数对比、查询兼容性
- [08.02 事务管理](./08.02-事务管理.md) - 事务管理最佳实践
- [08.04 PRAGMA配置](./08.04-PRAGMA配置.md) - PRAGMA配置优化

---

## 📚 参考资料

- [SQLite查询优化器](https://www.sqlite.org/queryplanner.html)
- [EXPLAIN QUERY PLAN](https://www.sqlite.org/eqp.html)
- [预编译语句文档](https://www.sqlite.org/c3ref/prepare.html)

---

**最后更新**：2025-11-13
**维护者**：Data-Science Team
