# SQLite多线程并发模式最佳实践

> **创建日期**: 2025-12-04
> **版本**: SQLite 3.47.x
> **难度**: ⭐⭐⭐⭐⭐

---

## 📑 目录

- [SQLite多线程并发模式最佳实践](#sqlite多线程并发模式最佳实践)
  - [📑 目录](#-目录)
  - [并发模式总览](#并发模式总览)
  - [模式1：连接池模式（推荐）](#模式1连接池模式推荐)
    - [架构](#架构)
    - [Python实现](#python实现)
  - [模式2：读写分离模式](#模式2读写分离模式)
    - [架构](#架构-1)
    - [Python实现](#python实现-1)
  - [模式3：事务队列模式](#模式3事务队列模式)
    - [架构](#架构-2)
    - [Python实现](#python实现-2)
  - [多线程并发模式决策树](#多线程并发模式决策树)
  - [多线程并发模式正反例证明](#多线程并发模式正反例证明)
  - [多线程并发模式理论推导](#多线程并发模式理论推导)
  - [死锁预防](#死锁预防)
    - [BUSY超时与重试](#busy超时与重试)
  - [🔗 交叉引用](#-交叉引用)
    - [核心架构文档](#核心架构文档)
    - [编程实践文档](#编程实践文档)
    - [性能优化文档 🆕](#性能优化文档-)
    - [知识图谱与导航 🆕](#知识图谱与导航-)
    - [相关概念链接 🆕](#相关概念链接-)
      - [多线程并发概念](#多线程并发概念)

## 并发模式总览

```text
SQLite三种线程模式
══════════════════════════════════════════════════════════════════════════════

1. 单线程模式（Single-Thread）
   • SQLITE_CONFIG_SINGLETHREAD
   • 禁用所有互斥锁
   • 最快，但不线程安全

2. 多线程模式（Multi-Thread）
   • SQLITE_CONFIG_MULTITHREAD
   • 默认模式
   • 连接不能跨线程共享

3. 串行化模式（Serialized）
   • SQLITE_CONFIG_SERIALIZED
   • 连接可跨线程共享
   • 自动加锁，最安全

检测当前模式：
  SELECT sqlite_threadsafe();
  -- 返回: 0=单线程, 1=串行化, 2=多线程
```

---

## 模式1：连接池模式（推荐）

### 架构

```text
连接池架构
═══════════════════════════════════════════════════════════════

┌─────────────────────────────────────────┐
│          Application                    │
│                                         │
│  ┌────────┐  ┌────────┐  ┌────────┐   │
│  │Thread 1│  │Thread 2│  │Thread 3│   │
│  └───┬────┘  └───┬────┘  └───┬────┘   │
│      │           │           │         │
│      └───────────┼───────────┘         │
│                  │                     │
│          ┌───────▼───────┐             │
│          │ Connection Pool│             │
│          │ (Queue-based)  │             │
│          └───────┬───────┘             │
│                  │                     │
│       ┌──────────┼──────────┐         │
│       │          │          │         │
│   ┌───▼───┐  ┌──▼───┐  ┌──▼───┐     │
│   │Conn 1 │  │Conn 2│  │Conn 3│     │
│   └───────┘  └──────┘  └──────┘     │
│                  │                     │
└──────────────────┼─────────────────────┘
                   │
            ┌──────▼──────┐
            │   app.db    │
            └─────────────┘
```

### Python实现

```python
import sqlite3
import threading
from queue import Queue, Empty
from contextlib import contextmanager
import time

class SQLiteConnectionPool:
    """SQLite连接池"""

    def __init__(self, db_path, pool_size=5, timeout=30):
        self.db_path = db_path
        self.pool_size = pool_size
        self.timeout = timeout
        self.pool = Queue(maxsize=pool_size)
        self._lock = threading.Lock()
        self._created_connections = 0

        # 预创建连接
        self._init_pool()

    def _init_pool(self):
        """初始化连接池"""
        for _ in range(self.pool_size):
            conn = self._create_connection()
            self.pool.put(conn)

    def _create_connection(self):
        """创建新连接"""
        conn = sqlite3.connect(
            self.db_path,
            check_same_thread=False,  # 允许跨线程
            timeout=self.timeout
        )

        # 配置优化
        conn.execute('PRAGMA journal_mode=WAL')
        conn.execute('PRAGMA synchronous=NORMAL')
        conn.execute('PRAGMA cache_size=-64000')
        conn.execute('PRAGMA temp_store=MEMORY')
        conn.execute('PRAGMA foreign_keys=ON')

        # 设置行工厂（返回字典）
        conn.row_factory = sqlite3.Row

        self._created_connections += 1
        return conn

    @contextmanager
    def get_connection(self):
        """获取连接（上下文管理器）"""
        conn = None
        try:
            # 从池中获取连接
            conn = self.pool.get(timeout=self.timeout)
            yield conn
        except Empty:
            raise TimeoutError("无法从连接池获取连接")
        finally:
            # 归还连接
            if conn:
                self.pool.put(conn)

    def execute_query(self, sql, params=()):
        """执行查询"""
        with self.get_connection() as conn:
            cursor = conn.execute(sql, params)
            return [dict(row) for row in cursor.fetchall()]

    def execute_write(self, sql, params=()):
        """执行写操作"""
        with self.get_connection() as conn:
            cursor = conn.execute(sql, params)
            conn.commit()
            return cursor.lastrowid

    def execute_many(self, sql, params_list):
        """批量执行"""
        with self.get_connection() as conn:
            cursor = conn.executemany(sql, params_list)
            conn.commit()
            return cursor.rowcount

    def close_all(self):
        """关闭所有连接"""
        while not self.pool.empty():
            try:
                conn = self.pool.get_nowait()
                conn.close()
            except Empty:
                break

# 全局连接池
pool = SQLiteConnectionPool('app.db', pool_size=10)

# 使用示例
def worker_thread(thread_id):
    """工作线程"""
    for i in range(100):
        # 读取
        users = pool.execute_query('SELECT * FROM users LIMIT 10')
        print(f"Thread {thread_id}: 读取 {len(users)} 用户")

        # 写入
        user_id = pool.execute_write(
            'INSERT INTO users (name, email) VALUES (?, ?)',
            (f'User_{thread_id}_{i}', f'user_{thread_id}_{i}@example.com')
        )
        print(f"Thread {thread_id}: 创建用户 {user_id}")

        time.sleep(0.01)

# 多线程测试
threads = [
    threading.Thread(target=worker_thread, args=(i,))
    for i in range(5)
]

for t in threads:
    t.start()

for t in threads:
    t.join()

pool.close_all()
```

---

## 模式2：读写分离模式

### 架构

```text
读写分离架构（WAL模式）
═══════════════════════════════════════════════════════════════

┌──────────────────────────────────────────────┐
│          Application                         │
│                                              │
│  ┌────────────┐           ┌──────────────┐  │
│  │ Write Thread│          │ Read Threads │  │
│  │   (1个)     │          │    (N个)     │  │
│  └─────┬──────┘           └──────┬───────┘  │
│        │                         │          │
│        │ INSERT/UPDATE/DELETE    │ SELECT   │
│        │                         │          │
│   ┌────▼────┐              ┌─────▼─────┐   │
│   │ Writer  │              │  Readers  │   │
│   │Connection│            │ Connections│   │
│   └────┬────┘              └─────┬─────┘   │
│        │                         │          │
└────────┼─────────────────────────┼──────────┘
         │                         │
         │       ┌─────────┐       │
         └───────►│ WAL Mode│◄──────┘
                 │  app.db │
                 └─────────┘

特点:
• Writer: 独占写连接
• Readers: 多个只读连接，并发读取
• WAL模式支持读写并发
```

### Python实现

```python
import sqlite3
import threading
from queue import Queue

class ReadWriteSeparation:
    """读写分离数据库"""

    def __init__(self, db_path, read_pool_size=5):
        self.db_path = db_path

        # 写连接（单例）
        self.write_conn = None
        self.write_lock = threading.Lock()
        self._init_writer()

        # 读连接池
        self.read_pool = Queue(maxsize=read_pool_size)
        for _ in range(read_pool_size):
            self.read_pool.put(self._create_reader())

    def _init_writer(self):
        """初始化写连接"""
        self.write_conn = sqlite3.connect(
            self.db_path,
            check_same_thread=False
        )
        self.write_conn.execute('PRAGMA journal_mode=WAL')
        self.write_conn.execute('PRAGMA synchronous=NORMAL')
        self.write_conn.row_factory = sqlite3.Row

    def _create_reader(self):
        """创建只读连接"""
        conn = sqlite3.connect(
            f'file:{self.db_path}?mode=ro',  # 只读模式
            uri=True,
            check_same_thread=False
        )
        conn.row_factory = sqlite3.Row
        return conn

    def read(self, sql, params=()):
        """读操作（从读连接池）"""
        conn = self.read_pool.get()
        try:
            cursor = conn.execute(sql, params)
            return [dict(row) for row in cursor.fetchall()]
        finally:
            self.read_pool.put(conn)

    def write(self, sql, params=()):
        """写操作（独占写连接）"""
        with self.write_lock:
            cursor = self.write_conn.execute(sql, params)
            self.write_conn.commit()
            return cursor.lastrowid

    def transaction(self, operations):
        """事务（多个写操作）"""
        with self.write_lock:
            try:
                self.write_conn.execute('BEGIN')
                results = []
                for sql, params in operations:
                    cursor = self.write_conn.execute(sql, params)
                    results.append(cursor.lastrowid)
                self.write_conn.commit()
                return results
            except Exception:
                self.write_conn.rollback()
                raise

# 使用示例
db = ReadWriteSeparation('app.db', read_pool_size=10)

def read_worker():
    """读线程"""
    for _ in range(1000):
        users = db.read('SELECT * FROM users LIMIT 10')
        print(f"读取: {len(users)} 用户")

def write_worker():
    """写线程"""
    for i in range(100):
        user_id = db.write(
            'INSERT INTO users (name) VALUES (?)',
            (f'User_{i}',)
        )
        print(f"创建: {user_id}")

# 多个读线程 + 1个写线程
readers = [threading.Thread(target=read_worker) for _ in range(5)]
writer = threading.Thread(target=write_worker)

for t in readers + [writer]:
    t.start()
for t in readers + [writer]:
    t.join()
```

---

## 模式3：事务队列模式

### 架构

```text
事务队列架构
═══════════════════════════════════════════════════════════════

┌─────────────────────────────────────────┐
│          Application                    │
│                                         │
│  ┌────────┐  ┌────────┐  ┌────────┐   │
│  │Thread 1│  │Thread 2│  │Thread 3│   │
│  └───┬────┘  └───┬────┘  └───┬────┘   │
│      │           │           │         │
│      └───────────┼───────────┘         │
│                  │                     │
│          ┌───────▼───────┐             │
│          │ Write Queue   │             │
│          │  (线程安全)    │             │
│          └───────┬───────┘             │
│                  │                     │
│          ┌───────▼───────┐             │
│          │ Writer Thread │             │
│          │  (单一线程)    │             │
│          └───────┬───────┘             │
│                  │                     │
└──────────────────┼─────────────────────┘
                   │
            ┌──────▼──────┐
            │   app.db    │
            └─────────────┘

特点:
• 所有写操作排队
• 单线程处理写请求
• 消除写冲突
```

### Python实现

```python
import sqlite3
import threading
from queue import Queue
from dataclasses import dataclass
from typing import Any, Tuple

@dataclass
class WriteTask:
    """写任务"""
    sql: str
    params: Tuple
    result_queue: Queue  # 用于返回结果

class TransactionQueue:
    """事务队列"""

    def __init__(self, db_path):
        self.db_path = db_path
        self.write_queue = Queue()
        self.conn = None
        self.running = False

        # 启动写线程
        self.writer_thread = threading.Thread(target=self._writer_loop, daemon=True)
        self.writer_thread.start()

    def _writer_loop(self):
        """写线程循环"""
        self.conn = sqlite3.connect(self.db_path)
        self.conn.execute('PRAGMA journal_mode=WAL')
        self.conn.row_factory = sqlite3.Row
        self.running = True

        while self.running:
            try:
                task = self.write_queue.get(timeout=1)
                self._execute_task(task)
            except:
                continue

    def _execute_task(self, task: WriteTask):
        """执行写任务"""
        try:
            cursor = self.conn.execute(task.sql, task.params)
            self.conn.commit()
            task.result_queue.put(('success', cursor.lastrowid))
        except Exception as e:
            task.result_queue.put(('error', str(e)))

    def write(self, sql, params=(), timeout=30):
        """异步写入（等待结果）"""
        result_queue = Queue()
        task = WriteTask(sql, params, result_queue)

        # 提交任务
        self.write_queue.put(task)

        # 等待结果
        status, result = result_queue.get(timeout=timeout)
        if status == 'error':
            raise Exception(result)
        return result

    def write_async(self, sql, params=()):
        """异步写入（不等待结果）"""
        result_queue = Queue()
        task = WriteTask(sql, params, result_queue)
        self.write_queue.put(task)

    def read(self, sql, params=()):
        """读操作（直接执行）"""
        conn = sqlite3.connect(f'file:{self.db_path}?mode=ro', uri=True)
        conn.row_factory = sqlite3.Row
        cursor = conn.execute(sql, params)
        results = [dict(row) for row in cursor.fetchall()]
        conn.close()
        return results

    def stop(self):
        """停止写线程"""
        self.running = False
        self.writer_thread.join()
        if self.conn:
            self.conn.close()

# 使用示例
tq = TransactionQueue('app.db')

def worker(worker_id):
    """工作线程"""
    for i in range(100):
        # 写入（同步）
        user_id = tq.write(
            'INSERT INTO users (name) VALUES (?)',
            (f'User_{worker_id}_{i}',)
        )
        print(f"Worker {worker_id}: 创建用户 {user_id}")

        # 读取
        users = tq.read('SELECT * FROM users LIMIT 5')
        print(f"Worker {worker_id}: 读取 {len(users)} 用户")

# 多线程
threads = [threading.Thread(target=worker, args=(i,)) for i in range(5)]
for t in threads:
    t.start()
for t in threads:
    t.join()

tq.stop()
```

---

## 多线程并发模式决策树

```text
多线程并发模式决策树
══════════════════════════════════════════════════════════════════════════════

问题：如何选择多线程并发模式？
    │
    ├─ 并发场景？
    │   ├─ 读多写少（> 10:1）？ → 连接池模式（推荐）
    │   │   ├─ 连接池管理
    │   │   ├─ 连接复用
    │   │   ├─ 性能提升10-15倍
    │   │   └─ 适合大多数场景
    │   │
    │   ├─ 读写分离需求？ → 读写分离模式
    │   │   ├─ 读连接池
    │   │   ├─ 写连接池
    │   │   ├─ 读写不阻塞
    │   │   └─ 适合高并发读场景
    │   │
    │   └─ 写冲突频繁？ → 事务队列模式
    │       ├─ 写操作排队
    │       ├─ 单线程处理写
    │       ├─ 消除写冲突
    │       └─ 适合写冲突场景
    │
    ├─ 线程安全要求？
    │   ├─ 需要线程安全？ → 多线程模式或串行化模式
    │   │   ├─ SQLITE_CONFIG_MULTITHREAD（默认）
    │   │   │   ├─ 连接不能跨线程共享
    │   │   │   └─ 需要连接池
    │   │   │
    │   │   └─ SQLITE_CONFIG_SERIALIZED
    │   │       ├─ 连接可跨线程共享
    │   │       └─ 自动加锁
    │   │
    │   └─ 不需要线程安全？ → 单线程模式
    │       ├─ SQLITE_CONFIG_SINGLETHREAD
    │       └─ 最快但不线程安全
    │
    ├─ WAL模式？
    │   ├─ 需要高并发读？ → 启用WAL模式（必需）
    │   │   ├─ 一写多读
    │   │   ├─ 读不阻塞写
    │   │   └─ 性能提升2-10倍
    │   │
    │   └─ 不需要高并发读？ → DELETE模式
    │       ├─ 写阻塞读
    │       └─ 性能较低
    │
    └─ 死锁预防？
        ├─ BUSY超时设置？
        │   ├─ 是 → sqlite3_busy_timeout（推荐）
        │   │   ├─ 自动重试
        │   │   ├─ 超时处理
        │   │   └─ 默认5秒
        │   │
        │   └─ 否 → 手动重试机制
        │       ├─ 指数退避
        │       └─ 最大重试次数
        │
        └─ 锁顺序？
            ├─ 统一锁顺序 → 避免死锁
            └─ 锁超时 → 检测死锁

推荐模式组合:
1. 大多数场景（推荐）:
   - 连接池模式
   - WAL模式
   - BUSY超时设置
   - 多线程模式

2. 高并发读场景:
   - 读写分离模式
   - WAL模式
   - 读连接池（多个）
   - 写连接池（单个）

3. 写冲突频繁场景:
   - 事务队列模式
   - WAL模式
   - 写操作排队
   - 单线程处理写
```

---

## 死锁预防

### BUSY超时与重试

```python
import sqlite3
import time
import random

def execute_with_retry(conn, sql, params=(), max_retries=5):
    """带重试的执行"""
    for attempt in range(max_retries):
        try:
            cursor = conn.execute(sql, params)
            conn.commit()
            return cursor.lastrowid
        except sqlite3.OperationalError as e:
            if 'database is locked' in str(e):
                if attempt < max_retries - 1:
                    # 指数退避
                    wait_time = (2 ** attempt) * 0.1 + random.uniform(0, 0.1)
                    print(f"数据库锁定，等待{wait_time:.2f}秒后重试...")
                    time.sleep(wait_time)
                else:
                    raise
            else:
                raise

# 使用
conn = sqlite3.connect('app.db', timeout=30)  # 30秒超时
execute_with_retry(conn, 'INSERT INTO users (name) VALUES (?)', ('Alice',))
```

---

## 🔗 交叉引用

### 核心架构文档

- ⭐⭐⭐ [事务与并发控制](../01-核心架构/01.02-事务与并发控制.md) - 并发控制基础（含论证脉络和正反例）
- ⭐⭐ [核心机制全景图](../01-核心架构/01.05-SQLite核心机制全景图-多维度整合分析.md) - 并发机制整合分析

### 编程实践文档

- ⭐⭐⭐ [连接管理](./08.01-连接管理.md) - 连接管理实践（含交叉引用）
- ⭐⭐⭐ [事务管理](./08.02-事务管理.md) - 事务管理实践（含交叉引用）
- ⭐⭐ [高级编程模式](./08.11-SQLite高级编程模式.md) - 高级编程模式（含论证脉络）

### 性能优化文档 🆕

- ⭐⭐ [性能特征分析](../03-性能优化/03.01-性能特征分析.md) - 并发性能分析（含决策树）
- ⭐⭐ [优化策略](../03-性能优化/03.02-优化策略.md) - 并发优化策略（含论证脉络）

### 知识图谱与导航 🆕

- ⭐⭐⭐ [知识图谱与概念关系网络](../09-最新特性/09.03-SQLite知识图谱与概念关系网络.md) - 多线程并发概念关系（400+概念）
- ⭐⭐ [文档依赖关系图](../00-项目导航/06-文档依赖关系图.md) - 多线程并发文档依赖
- ⭐⭐ [术语标准化词典](../00-项目导航/03-术语词典/SQLite术语标准化词典.md) - 多线程并发术语索引

### 相关概念链接 🆕

#### 多线程并发概念

- **多线程并发** → [知识图谱：并发控制概念](../09-最新特性/09.03-SQLite知识图谱与概念关系网络.md#核心本体事务与并发)
- **WAL并发读** → [定理：C6-WAL并发读](../06-形式化理论/06.06-SQLite定理依赖关系图谱.md#c6-wal并发读)
- **死锁预防** → [定理：C7-死锁预防](../06-形式化理论/06.06-SQLite定理依赖关系图谱.md#c7-死锁预防)

---

**文档版本**: v2.0.0
**最后更新**: 2025-12-05
