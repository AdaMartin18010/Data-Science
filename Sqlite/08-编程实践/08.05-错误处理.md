# 错误处理：错误码体系与异常恢复

> **创建日期**：2025-11-13
> **最后更新**：2025-11-13
> **版本**：SQLite 3.31+ 至 3.47+

---

## 📋 概述

完善的错误处理是SQLite应用稳定性的关键。本文档深入解析错误码体系、异常恢复策略和最佳实践。

---

## 📑 目录

- [错误处理：错误码体系与异常恢复](#错误处理错误码体系与异常恢复)
  - [📋 概述](#-概述)
  - [📑 目录](#-目录)
  - [一、错误码体系](#一错误码体系)
    - [1.1 成功码](#11-成功码)
    - [1.2 错误码分类](#12-错误码分类)
    - [1.3 常见错误码](#13-常见错误码)
  - [二、C API错误处理](#二c-api错误处理)
    - [2.1 错误码获取](#21-错误码获取)
    - [2.2 错误消息获取](#22-错误消息获取)
    - [2.3 错误处理示例](#23-错误处理示例)
  - [三、Python错误处理](#三python错误处理)
    - [3.1 异常类型](#31-异常类型)
    - [3.2 异常处理示例](#32-异常处理示例)
    - [3.3 异常恢复策略](#33-异常恢复策略)
  - [四、常见错误场景](#四常见错误场景)
    - [4.1 数据库锁定错误](#41-数据库锁定错误)
    - [4.2 约束违反错误](#42-约束违反错误)
    - [4.3 磁盘空间不足](#43-磁盘空间不足)
    - [4.4 数据库损坏](#44-数据库损坏)
  - [五、异常恢复机制](#五异常恢复机制)
    - [5.1 事务回滚](#51-事务回滚)
    - [5.2 重试机制](#52-重试机制)
    - [5.3 崩溃恢复](#53-崩溃恢复)
  - [六、错误处理最佳实践](#六错误处理最佳实践)
    - [6.1 错误处理原则](#61-错误处理原则)
    - [6.2 错误日志记录](#62-错误日志记录)
    - [6.3 用户友好错误提示](#63-用户友好错误提示)
  - [🔗 相关资源](#-相关资源)
  - [📚 参考资料](#-参考资料)

---

## 一、错误码体系

### 1.1 成功码

**SQLITE_OK**：

```c
#define SQLITE_OK           0   // 成功
```

**扩展成功码**：

```c
#define SQLITE_ROW          100 // 有数据行
#define SQLITE_DONE         101 // 执行完成
```

### 1.2 错误码分类

**主要错误码类别**：

| 类别 | 错误码范围 | 说明 |
|------|----------|------|
| **成功** | 0, 100-101 | SQLITE_OK, SQLITE_ROW, SQLITE_DONE |
| **SQL错误** | 1 | SQLITE_ERROR |
| **内部错误** | 2 | SQLITE_INTERNAL |
| **权限错误** | 3 | SQLITE_PERM |
| **中止错误** | 4 | SQLITE_ABORT |
| **忙错误** | 5 | SQLITE_BUSY |
| **锁定错误** | 6 | SQLITE_LOCKED |
| **内存错误** | 7 | SQLITE_NOMEM |
| **只读错误** | 8 | SQLITE_READONLY |
| **中断错误** | 9 | SQLITE_INTERRUPT |
| **IO错误** | 10 | SQLITE_IOERR |
| **损坏错误** | 11 | SQLITE_CORRUPT |
| **未找到错误** | 12 | SQLITE_NOTFOUND |
| **满错误** | 13 | SQLITE_FULL |
| **不能打开错误** | 14 | SQLITE_CANTOPEN |
| **协议错误** | 15 | SQLITE_PROTOCOL |
| **空错误** | 16 | SQLITE_EMPTY |
| **架构错误** | 17 | SQLITE_SCHEMA |
| **过大错误** | 18 | SQLITE_TOOBIG |
| **约束错误** | 19 | SQLITE_CONSTRAINT |
| **不匹配错误** | 20 | SQLITE_MISMATCH |
| **使用错误** | 21 | SQLITE_MISUSE |
| **不支持错误** | 22 | SQLITE_NOLFS |
| **授权错误** | 23 | SQLITE_AUTH |
| **格式错误** | 24 | SQLITE_FORMAT |
| **范围错误** | 25 | SQLITE_RANGE |
| **非数据库错误** | 26 | SQLITE_NOTADB |
| **通知错误** | 27 | SQLITE_NOTICE |
| **警告错误** | 28 | SQLITE_WARNING |

### 1.3 常见错误码

**SQLITE_BUSY（5）**：

```c
// 数据库被锁定
#define SQLITE_BUSY          5
```

**SQLITE_LOCKED（6）**：

```c
// 表被锁定
#define SQLITE_LOCKED         6
```

**SQLITE_CONSTRAINT（19）**：

```c
// 约束违反（主键、外键、唯一性等）
#define SQLITE_CONSTRAINT    19
```

**SQLITE_CORRUPT（11）**：

```c
// 数据库损坏
#define SQLITE_CORRUPT       11
```

---

## 二、C API错误处理

### 2.1 错误码获取

**获取错误码**：

```c
int rc = sqlite3_exec(db, "INSERT INTO ...", NULL, NULL, NULL);
if (rc != SQLITE_OK) {
    int error_code = rc;
    // 处理错误
}
```

**获取扩展错误码**：

```c
int rc = sqlite3_exec(db, "INSERT INTO ...", NULL, NULL, NULL);
if (rc != SQLITE_OK) {
    int extended_code = sqlite3_extended_errcode(db);
    // 获取更详细的错误码
}
```

### 2.2 错误消息获取

**获取错误消息**：

```c
int rc = sqlite3_exec(db, "INSERT INTO ...", NULL, NULL, NULL);
if (rc != SQLITE_OK) {
    const char* err_msg = sqlite3_errmsg(db);
    fprintf(stderr, "SQLite error: %s\n", err_msg);
}
```

**获取错误字符串**：

```c
const char* err_str = sqlite3_errstr(rc);
printf("Error: %s\n", err_str);
```

### 2.3 错误处理示例

**完整错误处理**：

```c
int execute_sql(sqlite3* db, const char* sql) {
    char* err_msg = NULL;
    int rc = sqlite3_exec(db, sql, NULL, NULL, &err_msg);

    if (rc != SQLITE_OK) {
        fprintf(stderr, "SQL error: %s\n", err_msg);
        sqlite3_free(err_msg);

        // 根据错误码处理
        switch (rc) {
            case SQLITE_BUSY:
                // 数据库被锁定，重试
                return retry_operation(db, sql);
            case SQLITE_CONSTRAINT:
                // 约束违反，回滚
                sqlite3_exec(db, "ROLLBACK;", NULL, NULL, NULL);
                return -1;
            case SQLITE_CORRUPT:
                // 数据库损坏，需要修复
                return handle_corruption(db);
            default:
                return -1;
        }
    }

    return 0;
}
```

---

## 三、Python错误处理

### 3.1 异常类型

**SQLite异常层次**：

```python
sqlite3.Error
├── sqlite3.Warning
├── sqlite3.Error
│   ├── sqlite3.DatabaseError
│   │   ├── sqlite3.IntegrityError  # 约束违反
│   │   └── sqlite3.OperationalError  # 操作错误（锁定、IO等）
│   └── sqlite3.ProgrammingError  # SQL语法错误
```

### 3.2 异常处理示例

**基本异常处理**：

```python
import sqlite3

try:
    conn = sqlite3.connect('app.db')
    cursor = conn.cursor()
    cursor.execute('INSERT INTO users (name) VALUES (?)', ('Alice',))
    conn.commit()
except sqlite3.IntegrityError as e:
    # 约束违反（主键、外键、唯一性等）
    print(f"Integrity error: {e}")
    conn.rollback()
except sqlite3.OperationalError as e:
    # 操作错误（锁定、IO等）
    print(f"Operational error: {e}")
    conn.rollback()
except sqlite3.Error as e:
    # 其他数据库错误
    print(f"Database error: {e}")
    conn.rollback()
finally:
    conn.close()
```

### 3.3 异常恢复策略

**重试机制**：

```python
import sqlite3
import time

def execute_with_retry(conn, sql, params, max_retries=3):
    for attempt in range(max_retries):
        try:
            cursor = conn.cursor()
            cursor.execute(sql, params)
            conn.commit()
            return True
        except sqlite3.OperationalError as e:
            if 'locked' in str(e).lower() and attempt < max_retries - 1:
                # 数据库被锁定，等待后重试
                time.sleep(0.1 * (attempt + 1))
                continue
            else:
                raise
    return False
```

---

## 四、常见错误场景

### 4.1 数据库锁定错误

**错误码**：`SQLITE_BUSY` (5)

**原因**：

- 另一个连接持有写锁
- WAL模式下Checkpoint正在进行

**处理方式**：

```c
// 设置超时
sqlite3_busy_timeout(db, 5000);  // 5秒超时

// 或使用忙处理回调
sqlite3_busy_handler(db, busy_callback, NULL);
```

**Python处理**：

```python
# 设置超时
conn.execute('PRAGMA busy_timeout=5000')

# 或使用重试
try:
    cursor.execute('INSERT INTO ...')
except sqlite3.OperationalError as e:
    if 'locked' in str(e).lower():
        time.sleep(0.1)
        cursor.execute('INSERT INTO ...')  # 重试
```

### 4.2 约束违反错误

**错误码**：`SQLITE_CONSTRAINT` (19)

**原因**：

- 主键冲突
- 外键约束违反
- 唯一性约束违反
- CHECK约束违反

**处理方式**：

```python
try:
    cursor.execute('INSERT INTO users (id, name) VALUES (?, ?)', (1, 'Alice'))
    conn.commit()
except sqlite3.IntegrityError as e:
    if 'UNIQUE constraint' in str(e):
        # 主键或唯一性约束违反
        print("User already exists")
    elif 'FOREIGN KEY constraint' in str(e):
        # 外键约束违反
        print("Invalid foreign key")
    conn.rollback()
```

### 4.3 磁盘空间不足

**错误码**：`SQLITE_FULL` (13)

**处理方式**：

```python
try:
    cursor.execute('INSERT INTO ...')
    conn.commit()
except sqlite3.OperationalError as e:
    if 'database or disk is full' in str(e).lower():
        # 磁盘空间不足
        print("Disk space full, need cleanup")
        # 执行清理操作
        cleanup_database(conn)
```

### 4.4 数据库损坏

**错误码**：`SQLITE_CORRUPT` (11)

**检测**：

```sql
-- 检查数据库完整性
PRAGMA integrity_check;
```

**处理方式**：

```python
# 检查完整性
result = conn.execute('PRAGMA integrity_check').fetchone()
if result[0] != 'ok':
    print("Database corrupted!")
    # 尝试恢复或重建数据库
    recover_database(conn)
```

---

## 五、异常恢复机制

### 5.1 事务回滚

**自动回滚**：

```python
try:
    conn.execute('BEGIN')
    conn.execute('INSERT INTO ...')
    conn.execute('UPDATE ...')
    conn.commit()
except sqlite3.Error:
    conn.rollback()  # 自动回滚
    raise
```

### 5.2 重试机制

**指数退避重试**：

```python
import time
import random

def execute_with_backoff(conn, sql, params, max_retries=5):
    for attempt in range(max_retries):
        try:
            cursor = conn.cursor()
            cursor.execute(sql, params)
            conn.commit()
            return True
        except sqlite3.OperationalError as e:
            if 'locked' in str(e).lower() and attempt < max_retries - 1:
                # 指数退避
                wait_time = (2 ** attempt) + random.uniform(0, 1)
                time.sleep(wait_time)
                continue
            else:
                raise
    return False
```

### 5.3 崩溃恢复

**WAL模式恢复**：

SQLite在WAL模式下自动处理崩溃恢复：

```python
# 打开数据库时自动恢复
conn = sqlite3.connect('app.db')
# SQLite自动检查WAL文件并恢复未完成事务
```

**手动恢复**：

```python
# 检查并修复
result = conn.execute('PRAGMA integrity_check').fetchone()
if result[0] != 'ok':
    # 尝试恢复
    conn.execute('PRAGMA wal_checkpoint(FULL)')
```

---

## 六、错误处理最佳实践

### 6.1 错误处理原则

1. **总是检查返回值**：检查所有SQLite API调用的返回值
2. **使用异常处理**：Python中使用try-except
3. **记录错误日志**：记录所有错误信息
4. **优雅降级**：提供备用方案
5. **用户友好提示**：将技术错误转换为用户可理解的提示

### 6.2 错误日志记录

**日志记录示例**：

```python
import logging

logger = logging.getLogger(__name__)

try:
    cursor.execute('INSERT INTO ...')
    conn.commit()
except sqlite3.IntegrityError as e:
    logger.error(f"Integrity error: {e}", exc_info=True)
    # 用户友好提示
    raise UserFriendlyError("数据已存在，请勿重复添加")
except sqlite3.OperationalError as e:
    logger.error(f"Operational error: {e}", exc_info=True)
    # 用户友好提示
    raise UserFriendlyError("数据库暂时不可用，请稍后重试")
```

### 6.3 用户友好错误提示

**错误映射**：

```python
def get_user_friendly_error(error):
    """将技术错误转换为用户友好提示"""
    error_str = str(error).lower()

    if 'unique constraint' in error_str:
        return "该记录已存在，请勿重复添加"
    elif 'foreign key constraint' in error_str:
        return "关联数据不存在，请检查输入"
    elif 'not null constraint' in error_str:
        return "必填字段不能为空"
    elif 'locked' in error_str:
        return "数据库正在使用中，请稍后重试"
    elif 'disk' in error_str and 'full' in error_str:
        return "存储空间不足，请清理后重试"
    else:
        return "操作失败，请稍后重试或联系管理员"
```

---

## 🔗 相关资源

- [08.01 连接管理](./08.01-连接管理.md)
- [08.02 事务管理](./08.02-事务管理.md)
- [08.03 查询优化](./08.03-查询优化.md)

---

## 📚 参考资料

- [SQLite错误码文档](https://www.sqlite.org/rescode.html)
- [错误处理最佳实践](https://www.sqlite.org/c3ref/errcode.html)
- [崩溃恢复机制](https://www.sqlite.org/wal.html#recovery)

---

**最后更新**：2025-11-13
**维护者**：Data-Science Team
