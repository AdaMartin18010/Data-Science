# SQLite C/C++ä½¿ç”¨æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**ï¼š2025-11-13
> **æœ€åæ›´æ–°**ï¼š2025-01-15
> **ç‰ˆæœ¬**ï¼šSQLite 3.31+ è‡³ 3.47.x
> **é€‚ç”¨ç¯å¢ƒ**ï¼šC99+ã€C++11+

---

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›SQLiteåœ¨Cå’ŒC++ä¸­çš„åŸç”ŸAPIä½¿ç”¨æŒ‡å—ï¼ŒåŒ…æ‹¬åŸºæœ¬æ“ä½œã€äº‹åŠ¡ç®¡ç†ã€é¢„ç¼–è¯‘è¯­å¥å’Œé«˜çº§ç‰¹æ€§ã€‚

---

## ğŸ“‘ ç›®å½•

- [SQLite C/C++ä½¿ç”¨æŒ‡å—](#sqlite-ccä½¿ç”¨æŒ‡å—)
  - [ğŸ“‹ æ¦‚è¿°](#-æ¦‚è¿°)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [3. ğŸ“Š æ€ç»´å¯¼å›¾](#3--æ€ç»´å¯¼å›¾)
  - [4. Cè¯­è¨€API](#4-cè¯­è¨€api)
    - [4.1. ç¼–è¯‘å’Œé“¾æ¥](#41-ç¼–è¯‘å’Œé“¾æ¥)
  - [5. åŸºæœ¬è¿æ¥](#5-åŸºæœ¬è¿æ¥)
    - [5.1. åŸºæœ¬æ“ä½œ](#51-åŸºæœ¬æ“ä½œ)
    - [5.2. é¢„ç¼–è¯‘è¯­å¥](#52-é¢„ç¼–è¯‘è¯­å¥)
    - [5.3. äº‹åŠ¡ç®¡ç†](#53-äº‹åŠ¡ç®¡ç†)
  - [6. C++å°è£…](#6-cå°è£…)
    - [6.1. ç®€å•å°è£…ç±»](#61-ç®€å•å°è£…ç±»)
    - [6.2. RAIIèµ„æºç®¡ç†](#62-raiièµ„æºç®¡ç†)
    - [6.3. ç°ä»£C++ç‰¹æ€§](#63-ç°ä»£cç‰¹æ€§)
  - [7. é«˜çº§ç‰¹æ€§](#7-é«˜çº§ç‰¹æ€§)
    - [7.1. è‡ªå®šä¹‰å‡½æ•°](#71-è‡ªå®šä¹‰å‡½æ•°)
    - [7.2. è‡ªå®šä¹‰èšåˆå‡½æ•°](#72-è‡ªå®šä¹‰èšåˆå‡½æ•°)
    - [7.3. å›è°ƒå‡½æ•°](#73-å›è°ƒå‡½æ•°)
    - [7.4. å¤‡ä»½å’Œæ¢å¤](#74-å¤‡ä»½å’Œæ¢å¤)
  - [8. æ€§èƒ½ä¼˜åŒ–](#8-æ€§èƒ½ä¼˜åŒ–)
    - [8.1. WALæ¨¡å¼é…ç½®](#81-walæ¨¡å¼é…ç½®)
    - [8.2. æ‰¹é‡æ“ä½œ](#82-æ‰¹é‡æ“ä½œ)
    - [8.3. å†…å­˜æ•°æ®åº“](#83-å†…å­˜æ•°æ®åº“)
  - [9. C/C++ä½¿ç”¨æ–¹å¼å¤šç»´å¯¹æ¯”çŸ©é˜µ](#9-ccä½¿ç”¨æ–¹å¼å¤šç»´å¯¹æ¯”çŸ©é˜µ)
    - [9.1. C/C++ä½¿ç”¨æ–¹å¼å¯¹æ¯”çŸ©é˜µ](#91-ccä½¿ç”¨æ–¹å¼å¯¹æ¯”çŸ©é˜µ)
    - [9.2. C/C++æœ€ä½³å®è·µå¯¹æ¯”çŸ©é˜µ](#92-ccæœ€ä½³å®è·µå¯¹æ¯”çŸ©é˜µ)
  - [10. æœ€ä½³å®è·µ](#10-æœ€ä½³å®è·µ)
    - [10.1. é”™è¯¯å¤„ç†](#101-é”™è¯¯å¤„ç†)
    - [10.2. èµ„æºç®¡ç†](#102-èµ„æºç®¡ç†)
    - [10.3. çº¿ç¨‹å®‰å…¨](#103-çº¿ç¨‹å®‰å…¨)
  - [11. ğŸ”— ç›¸å…³èµ„æº](#11--ç›¸å…³èµ„æº)
  - [12. ğŸ”— äº¤å‰å¼•ç”¨](#12--äº¤å‰å¼•ç”¨)
    - [12.1. ç†è®ºæ¨¡å‹ ğŸ†•](#121-ç†è®ºæ¨¡å‹-)
    - [12.2. è®¾è®¡æ¨¡å‹ ğŸ†•](#122-è®¾è®¡æ¨¡å‹-)
  - [13. ğŸ“š å‚è€ƒèµ„æ–™](#13--å‚è€ƒèµ„æ–™)

---

## 3. ğŸ“Š æ€ç»´å¯¼å›¾

```mermaid
mindmap
  root((C/C++ä½¿ç”¨æŒ‡å—))
    Cè¯­è¨€API
      ç¼–è¯‘å’Œé“¾æ¥
        æºç ä¸‹è½½
        é™æ€åº“ç¼–è¯‘
        CMakeé…ç½®
      åŸºæœ¬è¿æ¥
        sqlite3_open
        sqlite3_close
        é”™è¯¯å¤„ç†
      åŸºæœ¬æ“ä½œ
        sqlite3_exec
        CREATE TABLE
        INSERT UPDATE DELETE
        SELECTæŸ¥è¯¢
      é¢„ç¼–è¯‘è¯­å¥
        sqlite3_prepare_v2
        sqlite3_bind_*
        sqlite3_step
        sqlite3_finalize
      äº‹åŠ¡ç®¡ç†
        BEGIN TRANSACTION
        COMMIT ROLLBACK
        é”™è¯¯å¤„ç†
    C++å°è£…
      ç®€å•å°è£…ç±»
        ç±»è®¾è®¡
        èµ„æºç®¡ç†
        é”™è¯¯å¤„ç†
      RAIIèµ„æºç®¡ç†
        æ™ºèƒ½æŒ‡é’ˆ
        è‡ªåŠ¨é‡Šæ”¾
        å¼‚å¸¸å®‰å…¨
      ç°ä»£C++ç‰¹æ€§
        C++11ç‰¹æ€§
        C++14ç‰¹æ€§
        C++17ç‰¹æ€§
    é«˜çº§ç‰¹æ€§
      è‡ªå®šä¹‰å‡½æ•°
        sqlite3_create_function
        Cå‡½æ•°æ³¨å†Œ
        ç±»å‹è½¬æ¢
      è‡ªå®šä¹‰èšåˆå‡½æ•°
        sqlite3_create_aggregate
        èšåˆé€»è¾‘
        çŠ¶æ€ç®¡ç†
      å›è°ƒå‡½æ•°
        æŸ¥è¯¢å›è°ƒ
        è¿›åº¦å›è°ƒ
        æˆæƒå›è°ƒ
      å¤‡ä»½å’Œæ¢å¤
        sqlite3_backup_init
        å¢é‡å¤‡ä»½
        æ¢å¤æ“ä½œ
    æ€§èƒ½ä¼˜åŒ–
      WALæ¨¡å¼é…ç½®
        PRAGMAè®¾ç½®
        æ€§èƒ½æå‡
        å¹¶å‘ä¼˜åŒ–
      æ‰¹é‡æ“ä½œ
        äº‹åŠ¡æ‰¹å¤„ç†
        é¢„ç¼–è¯‘è¯­å¥
        æ€§èƒ½ä¼˜åŒ–
      å†…å­˜æ•°æ®åº“
        :memory:æ•°æ®åº“
        ä¸´æ—¶å­˜å‚¨
        é«˜æ€§èƒ½
    æœ€ä½³å®è·µ
      é”™è¯¯å¤„ç†
        é”™è¯¯ç æ£€æŸ¥
        é”™è¯¯æ¶ˆæ¯
        é”™è¯¯æ¢å¤
      èµ„æºç®¡ç†
        å†…å­˜ç®¡ç†
        è¿æ¥ç®¡ç†
        è¯­å¥ç®¡ç†
      çº¿ç¨‹å®‰å…¨
        è¿æ¥å…±äº«
        é”æœºåˆ¶
        å¹¶å‘æ§åˆ¶
```

---

## 4. Cè¯­è¨€API

SQLiteçš„C APIæ˜¯å…¶ä»–æ‰€æœ‰è¯­è¨€ç»‘å®šçš„åŸºç¡€ã€‚

### 4.1. ç¼–è¯‘å’Œé“¾æ¥

**ä¸‹è½½SQLiteæºç **ï¼š

```bash
# ä¸‹è½½amalgamationç‰ˆæœ¬ï¼ˆå•æ–‡ä»¶ï¼‰
wget https://www.sqlite.org/2024/sqlite-amalgamation-3450000.zip
unzip sqlite-amalgamation-3450000.zip
```

**ç¼–è¯‘**ï¼š

```bash
# ç¼–è¯‘ä¸ºé™æ€åº“
gcc -c sqlite3.c -o sqlite3.o
ar rcs libsqlite3.a sqlite3.o

# æˆ–ç›´æ¥ç¼–è¯‘åˆ°ç¨‹åº
gcc main.c sqlite3.c -o main -lpthread -ldl
```

**CMakeé…ç½®**ï¼š

```cmake
cmake_minimum_required(VERSION 3.10)
project(sqlite_example)

add_executable(main main.c sqlite3.c)
target_link_libraries(main pthread dl)
```

## 5. åŸºæœ¬è¿æ¥

**æ‰“å¼€å’Œå…³é—­æ•°æ®åº“**ï¼š

```c
#include <sqlite3.h>
#include <stdio.h>

int main() {
    sqlite3 *db;
    int rc;

    // æ‰“å¼€æ•°æ®åº“ï¼ˆä¸å­˜åœ¨åˆ™åˆ›å»ºï¼‰
    rc = sqlite3_open("example.db", &db);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "æ— æ³•æ‰“å¼€æ•°æ®åº“: %s\n", sqlite3_errmsg(db));
        sqlite3_close(db);
        return 1;
    }

    printf("æ•°æ®åº“è¿æ¥æˆåŠŸ\n");

    // å…³é—­æ•°æ®åº“
    sqlite3_close(db);
    return 0;
}
```

**ä½¿ç”¨å†…å­˜æ•°æ®åº“**ï¼š

```c
// å†…å­˜æ•°æ®åº“
rc = sqlite3_open(":memory:", &db);

// æˆ–ä½¿ç”¨URIæ ¼å¼
rc = sqlite3_open_v2("file:example.db?mode=rwc", &db,
                     SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, NULL);
```

### 5.1. åŸºæœ¬æ“ä½œ

**æ‰§è¡ŒSQLè¯­å¥**ï¼š

```c
#include <sqlite3.h>
#include <stdio.h>

int main() {
    sqlite3 *db;
    char *err_msg = 0;
    int rc;

    rc = sqlite3_open("example.db", &db);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "æ— æ³•æ‰“å¼€æ•°æ®åº“: %s\n", sqlite3_errmsg(db));
        sqlite3_close(db);
        return 1;
    }

    // åˆ›å»ºè¡¨
    const char *sql = "CREATE TABLE IF NOT EXISTS users ("
                      "id INTEGER PRIMARY KEY AUTOINCREMENT,"
                      "name TEXT NOT NULL,"
                      "email TEXT UNIQUE,"
                      "age INTEGER"
                      ");";

    rc = sqlite3_exec(db, sql, 0, 0, &err_msg);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "SQLé”™è¯¯: %s\n", err_msg);
        sqlite3_free(err_msg);
    } else {
        printf("è¡¨åˆ›å»ºæˆåŠŸ\n");
    }

    // æ’å…¥æ•°æ®
    sql = "INSERT INTO users (name, email, age) VALUES ('Alice', 'alice@example.com', 25);";
    rc = sqlite3_exec(db, sql, 0, 0, &err_msg);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "SQLé”™è¯¯: %s\n", err_msg);
        sqlite3_free(err_msg);
    }

    sqlite3_close(db);
    return 0;
}
```

**æŸ¥è¯¢æ•°æ®ï¼ˆä½¿ç”¨å›è°ƒï¼‰**ï¼š

```c
#include <sqlite3.h>
#include <stdio.h>

// æŸ¥è¯¢å›è°ƒå‡½æ•°
static int callback(void *data, int argc, char **argv, char **azColName) {
    int i;
    printf("%s: ", (const char*)data);
    for (i = 0; i < argc; i++) {
        printf("%s = %s\n", azColName[i], argv[i] ? argv[i] : "NULL");
    }
    printf("\n");
    return 0;
}

int main() {
    sqlite3 *db;
    char *err_msg = 0;
    int rc;

    rc = sqlite3_open("example.db", &db);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "æ— æ³•æ‰“å¼€æ•°æ®åº“: %s\n", sqlite3_errmsg(db));
        sqlite3_close(db);
        return 1;
    }

    // æŸ¥è¯¢æ•°æ®
    const char *sql = "SELECT * FROM users;";
    const char *data = "å›è°ƒå‡½æ•°";

    rc = sqlite3_exec(db, sql, callback, (void*)data, &err_msg);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "SQLé”™è¯¯: %s\n", err_msg);
        sqlite3_free(err_msg);
    }

    sqlite3_close(db);
    return 0;
}
```

### 5.2. é¢„ç¼–è¯‘è¯­å¥

**ä½¿ç”¨é¢„ç¼–è¯‘è¯­å¥ï¼ˆæ¨èï¼‰**ï¼š

```c
#include <sqlite3.h>
#include <stdio.h>

int main() {
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;

    rc = sqlite3_open("example.db", &db);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "æ— æ³•æ‰“å¼€æ•°æ®åº“: %s\n", sqlite3_errmsg(db));
        return 1;
    }

    // é¢„ç¼–è¯‘æ’å…¥è¯­å¥
    const char *sql = "INSERT INTO users (name, email, age) VALUES (?, ?, ?);";
    rc = sqlite3_prepare_v2(db, sql, -1, &stmt, NULL);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "å‡†å¤‡è¯­å¥å¤±è´¥: %s\n", sqlite3_errmsg(db));
        sqlite3_close(db);
        return 1;
    }

    // ç»‘å®šå‚æ•°
    sqlite3_bind_text(stmt, 1, "Bob", -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, "bob@example.com", -1, SQLITE_STATIC);
    sqlite3_bind_int(stmt, 3, 30);

    // æ‰§è¡Œ
    rc = sqlite3_step(stmt);
    if (rc != SQLITE_DONE) {
        fprintf(stderr, "æ‰§è¡Œå¤±è´¥: %s\n", sqlite3_errmsg(db));
    }

    // é‡ç½®è¯­å¥ä»¥ä¾¿é‡ç”¨
    sqlite3_reset(stmt);

    // å†æ¬¡ä½¿ç”¨
    sqlite3_bind_text(stmt, 1, "Charlie", -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, "charlie@example.com", -1, SQLITE_STATIC);
    sqlite3_bind_int(stmt, 3, 35);
    sqlite3_step(stmt);

    // é‡Šæ”¾è¯­å¥
    sqlite3_finalize(stmt);

    // æŸ¥è¯¢æ•°æ®
    sql = "SELECT id, name, email, age FROM users WHERE age > ?;";
    rc = sqlite3_prepare_v2(db, sql, -1, &stmt, NULL);
    if (rc == SQLITE_OK) {
        sqlite3_bind_int(stmt, 1, 25);

        while (sqlite3_step(stmt) == SQLITE_ROW) {
            int id = sqlite3_column_int(stmt, 0);
            const char *name = (const char*)sqlite3_column_text(stmt, 1);
            const char *email = (const char*)sqlite3_column_text(stmt, 2);
            int age = sqlite3_column_int(stmt, 3);

            printf("ID: %d, Name: %s, Email: %s, Age: %d\n", id, name, email, age);
        }
    }

    sqlite3_finalize(stmt);
    sqlite3_close(db);
    return 0;
}
```

### 5.3. äº‹åŠ¡ç®¡ç†

**ä½¿ç”¨äº‹åŠ¡**ï¼š

```c
#include <sqlite3.h>
#include <stdio.h>

int main() {
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;

    rc = sqlite3_open("example.db", &db);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "æ— æ³•æ‰“å¼€æ•°æ®åº“: %s\n", sqlite3_errmsg(db));
        return 1;
    }

    // å¼€å§‹äº‹åŠ¡
    sqlite3_exec(db, "BEGIN TRANSACTION;", NULL, NULL, NULL);

    const char *sql = "INSERT INTO users (name, email, age) VALUES (?, ?, ?);";
    rc = sqlite3_prepare_v2(db, sql, -1, &stmt, NULL);

    // æ‰¹é‡æ’å…¥
    for (int i = 0; i < 1000; i++) {
        char name[32], email[64];
        sprintf(name, "User%d", i);
        sprintf(email, "user%d@example.com", i);

        sqlite3_bind_text(stmt, 1, name, -1, SQLITE_STATIC);
        sqlite3_bind_text(stmt, 2, email, -1, SQLITE_STATIC);
        sqlite3_bind_int(stmt, 3, 20 + (i % 50));

        rc = sqlite3_step(stmt);
        if (rc != SQLITE_DONE) {
            fprintf(stderr, "æ’å…¥å¤±è´¥: %s\n", sqlite3_errmsg(db));
            sqlite3_exec(db, "ROLLBACK;", NULL, NULL, NULL);
            sqlite3_finalize(stmt);
            sqlite3_close(db);
            return 1;
        }

        sqlite3_reset(stmt);
    }

    sqlite3_finalize(stmt);

    // æäº¤äº‹åŠ¡
    rc = sqlite3_exec(db, "COMMIT;", NULL, NULL, NULL);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "æäº¤å¤±è´¥: %s\n", sqlite3_errmsg(db));
    } else {
        printf("äº‹åŠ¡æäº¤æˆåŠŸ\n");
    }

    sqlite3_close(db);
    return 0;
}
```

---

## 6. C++å°è£…

### 6.1. ç®€å•å°è£…ç±»

**åŸºæœ¬çš„C++å°è£…**ï¼š

```cpp
#include <sqlite3.h>
#include <string>
#include <vector>
#include <memory>

class SQLiteDB {
private:
    sqlite3 *db;

public:
    SQLiteDB(const std::string &filename) {
        int rc = sqlite3_open(filename.c_str(), &db);
        if (rc != SQLITE_OK) {
            throw std::runtime_error(sqlite3_errmsg(db));
        }
    }

    ~SQLiteDB() {
        sqlite3_close(db);
    }

    void exec(const std::string &sql) {
        char *err_msg = 0;
        int rc = sqlite3_exec(db, sql.c_str(), NULL, NULL, &err_msg);
        if (rc != SQLITE_OK) {
            std::string error = err_msg;
            sqlite3_free(err_msg);
            throw std::runtime_error(error);
        }
    }

    sqlite3* get() {
        return db;
    }
};

int main() {
    try {
        SQLiteDB db("example.db");
        db.exec("CREATE TABLE IF NOT EXISTS users ("
                "id INTEGER PRIMARY KEY AUTOINCREMENT,"
                "name TEXT NOT NULL,"
                "email TEXT UNIQUE"
                ");");

        db.exec("INSERT INTO users (name, email) VALUES ('Alice', 'alice@example.com');");
    } catch (const std::exception &e) {
        std::cerr << "é”™è¯¯: " << e.what() << std::endl;
        return 1;
    }

    return 0;
}
```

### 6.2. RAIIèµ„æºç®¡ç†

**ä½¿ç”¨RAIIç®¡ç†èµ„æº**ï¼š

```cpp
#include <sqlite3.h>
#include <string>
#include <memory>

class Statement {
private:
    sqlite3_stmt *stmt;

public:
    Statement(sqlite3 *db, const std::string &sql) {
        int rc = sqlite3_prepare_v2(db, sql.c_str(), -1, &stmt, NULL);
        if (rc != SQLITE_OK) {
            throw std::runtime_error(sqlite3_errmsg(db));
        }
    }

    ~Statement() {
        sqlite3_finalize(stmt);
    }

    void bind(int index, const std::string &value) {
        sqlite3_bind_text(stmt, index, value.c_str(), -1, SQLITE_STATIC);
    }

    void bind(int index, int value) {
        sqlite3_bind_int(stmt, index, value);
    }

    bool step() {
        return sqlite3_step(stmt) == SQLITE_ROW;
    }

    void reset() {
        sqlite3_reset(stmt);
    }

    int getInt(int column) {
        return sqlite3_column_int(stmt, column);
    }

    std::string getText(int column) {
        return std::string((const char*)sqlite3_column_text(stmt, column));
    }

    sqlite3_stmt* get() {
        return stmt;
    }
};

int main() {
    SQLiteDB db("example.db");

    Statement stmt(db.get(), "INSERT INTO users (name, email, age) VALUES (?, ?, ?);");
    stmt.bind(1, "Bob");
    stmt.bind(2, "bob@example.com");
    stmt.bind(3, 30);
    stmt.step();

    Statement query(db.get(), "SELECT name, email FROM users WHERE age > ?;");
    query.bind(1, 25);
    while (query.step()) {
        std::cout << query.getText(0) << " - " << query.getText(1) << std::endl;
    }

    return 0;
}
```

### 6.3. ç°ä»£C++ç‰¹æ€§

**ä½¿ç”¨ç°ä»£C++ç‰¹æ€§**ï¼š

```cpp
#include <sqlite3.h>
#include <string>
#include <vector>
#include <memory>
#include <functional>

class SQLiteDB {
private:
    std::unique_ptr<sqlite3, std::function<void(sqlite3*)>> db;

    static void deleter(sqlite3 *db) {
        sqlite3_close(db);
    }

public:
    SQLiteDB(const std::string &filename) {
        sqlite3 *raw_db;
        int rc = sqlite3_open(filename.c_str(), &raw_db);
        if (rc != SQLITE_OK) {
            throw std::runtime_error(sqlite3_errmsg(raw_db));
        }
        db = std::unique_ptr<sqlite3, std::function<void(sqlite3*)>>(raw_db, deleter);
    }

    template<typename F>
    void query(const std::string &sql, F callback) {
        sqlite3_stmt *stmt;
        int rc = sqlite3_prepare_v2(db.get(), sql.c_str(), -1, &stmt, NULL);
        if (rc != SQLITE_OK) {
            throw std::runtime_error(sqlite3_errmsg(db.get()));
        }

        while (sqlite3_step(stmt) == SQLITE_ROW) {
            callback(stmt);
        }

        sqlite3_finalize(stmt);
    }

    sqlite3* get() {
        return db.get();
    }
};

int main() {
    SQLiteDB db("example.db");

    db.query("SELECT name, email FROM users;", [](sqlite3_stmt *stmt) {
        std::cout << sqlite3_column_text(stmt, 0) << " - "
                  << sqlite3_column_text(stmt, 1) << std::endl;
    });

    return 0;
}
```

---

## 7. é«˜çº§ç‰¹æ€§

### 7.1. è‡ªå®šä¹‰å‡½æ•°

**æ³¨å†ŒCå‡½æ•°ä¸ºSQLiteå‡½æ•°**ï¼š

```c
#include <sqlite3.h>
#include <string.h>
#include <ctype.h>

// è‡ªå®šä¹‰å‡½æ•°ï¼šè½¬æ¢ä¸ºå¤§å†™
static void upper_case(sqlite3_context *context, int argc, sqlite3_value **argv) {
    if (argc != 1) {
        sqlite3_result_error(context, "upper_case() éœ€è¦ä¸€ä¸ªå‚æ•°", -1);
        return;
    }

    const char *input = (const char*)sqlite3_value_text(argv[0]);
    if (input == NULL) {
        sqlite3_result_null(context);
        return;
    }

    int len = strlen(input);
    char *result = (char*)sqlite3_malloc(len + 1);
    for (int i = 0; i < len; i++) {
        result[i] = toupper(input[i]);
    }
    result[len] = '\0';

    sqlite3_result_text(context, result, len, sqlite3_free);
}

int main() {
    sqlite3 *db;
    sqlite3_open("example.db", &db);

    // æ³¨å†Œè‡ªå®šä¹‰å‡½æ•°
    sqlite3_create_function(db, "upper_case", 1, SQLITE_UTF8, NULL,
                           upper_case, NULL, NULL);

    // ä½¿ç”¨è‡ªå®šä¹‰å‡½æ•°
    sqlite3_exec(db, "SELECT upper_case(name) FROM users;", NULL, NULL, NULL);

    sqlite3_close(db);
    return 0;
}
```

### 7.2. è‡ªå®šä¹‰èšåˆå‡½æ•°

**åˆ›å»ºè‡ªå®šä¹‰èšåˆå‡½æ•°**ï¼š

```c
#include <sqlite3.h>
#include <stdlib.h>

// èšåˆå‡½æ•°ä¸Šä¸‹æ–‡
typedef struct {
    double sum;
    int count;
} AvgContext;

// èšåˆæ­¥éª¤å‡½æ•°
static void avg_step(sqlite3_context *context, int argc, sqlite3_value **argv) {
    AvgContext *ctx = (AvgContext*)sqlite3_aggregate_context(context, sizeof(AvgContext));
    if (ctx) {
        double value = sqlite3_value_double(argv[0]);
        ctx->sum += value;
        ctx->count++;
    }
}

// èšåˆæœ€ç»ˆå‡½æ•°
static void avg_final(sqlite3_context *context) {
    AvgContext *ctx = (AvgContext*)sqlite3_aggregate_context(context, 0);
    if (ctx && ctx->count > 0) {
        sqlite3_result_double(context, ctx->sum / ctx->count);
    } else {
        sqlite3_result_null(context);
    }
}

int main() {
    sqlite3 *db;
    sqlite3_open("example.db", &db);

    // æ³¨å†Œèšåˆå‡½æ•°
    sqlite3_create_function(db, "my_avg", 1, SQLITE_UTF8, NULL,
                           NULL, avg_step, avg_final);

    sqlite3_close(db);
    return 0;
}
```

### 7.3. å›è°ƒå‡½æ•°

**ä½¿ç”¨å„ç§å›è°ƒå‡½æ•°**ï¼š

```c
#include <sqlite3.h>
#include <stdio.h>

// æ›´æ–°é’©å­
static void update_hook(void *arg, int op, const char *db_name,
                       const char *table_name, sqlite3_int64 rowid) {
    const char *op_name[] = {"INSERT", "UPDATE", "DELETE"};
    printf("æ“ä½œ: %s, è¡¨: %s, RowID: %lld\n", op_name[op-1], table_name, rowid);
}

// æäº¤é’©å­
static int commit_hook(void *arg) {
    printf("å‡†å¤‡æäº¤äº‹åŠ¡\n");
    return 0; // è¿”å›0å…è®¸æäº¤ï¼Œé0å›æ»š
}

int main() {
    sqlite3 *db;
    sqlite3_open("example.db", &db);

    // æ³¨å†Œæ›´æ–°é’©å­
    sqlite3_update_hook(db, update_hook, NULL);

    // æ³¨å†Œæäº¤é’©å­
    sqlite3_commit_hook(db, commit_hook, NULL);

    sqlite3_exec(db, "INSERT INTO users (name) VALUES ('Test');", NULL, NULL, NULL);

    sqlite3_close(db);
    return 0;
}
```

### 7.4. å¤‡ä»½å’Œæ¢å¤

**æ•°æ®åº“å¤‡ä»½**ï¼š

```c
#include <sqlite3.h>
#include <stdio.h>

static int backup_progress(void *arg, int remaining, int page_count) {
    int percent = ((page_count - remaining) * 100) / page_count;
    printf("å¤‡ä»½è¿›åº¦: %d%%\n", percent);
    return 0;
}

int main() {
    sqlite3 *db;
    sqlite3_backup *backup;
    sqlite3 *backup_db;
    int rc;

    sqlite3_open("example.db", &db);
    sqlite3_open("backup.db", &backup_db);

    // åˆ›å»ºå¤‡ä»½å¯¹è±¡
    backup = sqlite3_backup_init(backup_db, "main", db, "main");
    if (backup) {
        // æ‰§è¡Œå¤‡ä»½
        sqlite3_backup_step(backup, -1); // -1è¡¨ç¤ºå¤‡ä»½æ‰€æœ‰é¡µé¢
        sqlite3_backup_finish(backup);
    }

    rc = sqlite3_errcode(backup_db);
    if (rc == SQLITE_OK) {
        printf("å¤‡ä»½æˆåŠŸ\n");
    } else {
        printf("å¤‡ä»½å¤±è´¥: %s\n", sqlite3_errmsg(backup_db));
    }

    sqlite3_close(backup_db);
    sqlite3_close(db);
    return 0;
}
```

---

## 8. æ€§èƒ½ä¼˜åŒ–

### 8.1. WALæ¨¡å¼é…ç½®

**é…ç½®WALæ¨¡å¼**ï¼š

```c
#include <sqlite3.h>

void configure_database(sqlite3 *db) {
    sqlite3_exec(db, "PRAGMA journal_mode=WAL;", NULL, NULL, NULL);
    sqlite3_exec(db, "PRAGMA synchronous=NORMAL;", NULL, NULL, NULL);
    sqlite3_exec(db, "PRAGMA cache_size=-16000;", NULL, NULL, NULL); // 16MB
    sqlite3_exec(db, "PRAGMA foreign_keys=ON;", NULL, NULL, NULL);
    sqlite3_exec(db, "PRAGMA temp_store=MEMORY;", NULL, NULL, NULL);
}

int main() {
    sqlite3 *db;
    sqlite3_open("example.db", &db);
    configure_database(db);
    sqlite3_close(db);
    return 0;
}
```

### 8.2. æ‰¹é‡æ“ä½œ

**æ‰¹é‡æ“ä½œä¼˜åŒ–**ï¼š

```c
#include <sqlite3.h>
#include <stdio.h>

int main() {
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;

    sqlite3_open("example.db", &db);

    // å¼€å§‹äº‹åŠ¡
    sqlite3_exec(db, "BEGIN TRANSACTION;", NULL, NULL, NULL);

    const char *sql = "INSERT INTO users (name, email, age) VALUES (?, ?, ?);";
    sqlite3_prepare_v2(db, sql, -1, &stmt, NULL);

    // æ‰¹é‡æ’å…¥
    for (int i = 0; i < 10000; i++) {
        char name[32], email[64];
        sprintf(name, "User%d", i);
        sprintf(email, "user%d@example.com", i);

        sqlite3_bind_text(stmt, 1, name, -1, SQLITE_STATIC);
        sqlite3_bind_text(stmt, 2, email, -1, SQLITE_STATIC);
        sqlite3_bind_int(stmt, 3, 20 + (i % 50));

        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }

    sqlite3_finalize(stmt);

    // æäº¤äº‹åŠ¡
    sqlite3_exec(db, "COMMIT;", NULL, NULL, NULL);

    sqlite3_close(db);
    return 0;
}
```

### 8.3. å†…å­˜æ•°æ®åº“

**ä½¿ç”¨å†…å­˜æ•°æ®åº“**ï¼š

```c
#include <sqlite3.h>

int main() {
    sqlite3 *db;

    // å†…å­˜æ•°æ®åº“
    sqlite3_open(":memory:", &db);

    // åˆ›å»ºè¡¨
    sqlite3_exec(db, "CREATE TABLE test (id INTEGER, name TEXT);", NULL, NULL, NULL);

    // ä½¿ç”¨å®Œæ¯•åå…³é—­
    sqlite3_close(db);
    return 0;
}
```

---

## 9. C/C++ä½¿ç”¨æ–¹å¼å¤šç»´å¯¹æ¯”çŸ©é˜µ

### 9.1. C/C++ä½¿ç”¨æ–¹å¼å¯¹æ¯”çŸ©é˜µ

| ç»´åº¦ | Cè¯­è¨€API | C++ç®€å•å°è£… | C++RAIIå°è£… | ç°ä»£C++ç‰¹æ€§ |
|------|---------|-----------|-----------|-----------|
| **æ€§èƒ½** | â­â­â­â­â­ | â­â­â­â­â­ | â­â­â­â­ | â­â­â­â­ |
| **æ˜“ç”¨æ€§** | â­â­â­ | â­â­â­â­ | â­â­â­â­â­ | â­â­â­â­â­ |
| **ç±»å‹å®‰å…¨** | â­â­ | â­â­â­ | â­â­â­â­ | â­â­â­â­â­ |
| **èµ„æºç®¡ç†** | â­â­ | â­â­â­ | â­â­â­â­â­ | â­â­â­â­â­ |
| **é”™è¯¯å¤„ç†** | â­â­ | â­â­â­ | â­â­â­â­ | â­â­â­â­â­ |
| **å­¦ä¹ æ›²çº¿** | â­â­â­ | â­â­â­â­ | â­â­â­ | â­â­â­ |
| **é€‚ç”¨åœºæ™¯** | åº•å±‚å¼€å‘ | ç®€å•å°è£… | ç”Ÿäº§ç¯å¢ƒï¼ˆæ¨èï¼‰ | ç°ä»£C++é¡¹ç›® |
| **ä»£ç å¯è¯»æ€§** | â­â­â­ | â­â­â­â­ | â­â­â­â­â­ | â­â­â­â­â­ |
| **ç»´æŠ¤æˆæœ¬** | â­â­â­ | â­â­â­â­ | â­â­â­â­ | â­â­â­â­â­ |

### 9.2. C/C++æœ€ä½³å®è·µå¯¹æ¯”çŸ©é˜µ

| å®è·µé¡¹ | æ¨èåšæ³• | ä¸æ¨èåšæ³• | æ€§èƒ½å½±å“ |
|--------|---------|-----------|---------|
| **èµ„æºç®¡ç†** | RAIIæ¨¡å¼ | æ‰‹åŠ¨ç®¡ç† | â­â­â­â­â­ |
| **é”™è¯¯å¤„ç†** | æ£€æŸ¥è¿”å›å€¼ | å¿½ç•¥é”™è¯¯ | â­â­â­â­â­ |
| **é¢„ç¼–è¯‘è¯­å¥** | sqlite3_prepare_v2 | sqlite3_exec | â­â­â­â­â­ |
| **äº‹åŠ¡ç®¡ç†** | æ‰¹é‡æ“ä½œä½¿ç”¨äº‹åŠ¡ | é€æ¡æ“ä½œ | â­â­â­â­â­ |
| **è¿æ¥ç®¡ç†** | å•è¿æ¥å¤ç”¨ | é¢‘ç¹åˆ›å»ºè¿æ¥ | â­â­â­â­â­ |
| **WALæ¨¡å¼** | å¯ç”¨WALæ¨¡å¼ | ä½¿ç”¨DELETEæ¨¡å¼ | â­â­â­â­ |

## 10. æœ€ä½³å®è·µ

### 10.1. é”™è¯¯å¤„ç†

**å®Œå–„çš„é”™è¯¯å¤„ç†**ï¼š

```c
#include <sqlite3.h>
#include <stdio.h>
#include <stdlib.h>

void check_error(sqlite3 *db, int rc, const char *operation) {
    if (rc != SQLITE_OK) {
        fprintf(stderr, "%s å¤±è´¥: %s\n", operation, sqlite3_errmsg(db));
        sqlite3_close(db);
        exit(1);
    }
}

int main() {
    sqlite3 *db;
    int rc;

    rc = sqlite3_open("example.db", &db);
    check_error(db, rc, "æ‰“å¼€æ•°æ®åº“");

    rc = sqlite3_exec(db, "CREATE TABLE users (id INTEGER, name TEXT);", NULL, NULL, NULL);
    check_error(db, rc, "åˆ›å»ºè¡¨");

    sqlite3_close(db);
    return 0;
}
```

### 10.2. èµ„æºç®¡ç†

**ç¡®ä¿èµ„æºé‡Šæ”¾**ï¼š

```c
#include <sqlite3.h>
#include <stdio.h>

int main() {
    sqlite3 *db = NULL;
    sqlite3_stmt *stmt = NULL;
    int rc;

    rc = sqlite3_open("example.db", &db);
    if (rc != SQLITE_OK) {
        goto cleanup;
    }

    rc = sqlite3_prepare_v2(db, "SELECT * FROM users;", -1, &stmt, NULL);
    if (rc != SQLITE_OK) {
        goto cleanup;
    }

    // ä½¿ç”¨stmt...

cleanup:
    if (stmt) {
        sqlite3_finalize(stmt);
    }
    if (db) {
        sqlite3_close(db);
    }
    return rc == SQLITE_OK ? 0 : 1;
}
```

### 10.3. çº¿ç¨‹å®‰å…¨

**å¤šçº¿ç¨‹ä½¿ç”¨**ï¼š

```c
#include <sqlite3.h>
#include <pthread.h>

// SQLiteé»˜è®¤æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼ˆå¦‚æœç¼–è¯‘æ—¶å¯ç”¨äº†ï¼‰
// æ¯ä¸ªçº¿ç¨‹åº”è¯¥ä½¿ç”¨ç‹¬ç«‹çš„è¿æ¥

void* thread_func(void *arg) {
    sqlite3 *db;
    sqlite3_open("example.db", &db);

    // ä½¿ç”¨æ•°æ®åº“...

    sqlite3_close(db);
    return NULL;
}

int main() {
    pthread_t threads[5];

    for (int i = 0; i < 5; i++) {
        pthread_create(&threads[i], NULL, thread_func, NULL);
    }

    for (int i = 0; i < 5; i++) {
        pthread_join(threads[i], NULL);
    }

    return 0;
}
```

---

## 11. ğŸ”— ç›¸å…³èµ„æº

- [08.01 è¿æ¥ç®¡ç†](./08.01-è¿æ¥ç®¡ç†.md) - è¿æ¥ç®¡ç†æœ€ä½³å®è·µ
- [08.02 äº‹åŠ¡ç®¡ç†](./08.02-äº‹åŠ¡ç®¡ç†.md) - äº‹åŠ¡ç®¡ç†è¯¦è§£
- [08.03 æŸ¥è¯¢ä¼˜åŒ–](./08.03-æŸ¥è¯¢ä¼˜åŒ–.md) - æŸ¥è¯¢ä¼˜åŒ–æŠ€å·§
- [08.06 Pythonä½¿ç”¨æŒ‡å—](./08.06-Pythonä½¿ç”¨æŒ‡å—.md) - å…¶ä»–è¯­è¨€ä½¿ç”¨æŒ‡å—
- [08.08 Goä½¿ç”¨æŒ‡å—](./08.08-Goä½¿ç”¨æŒ‡å—.md) - å…¶ä»–è¯­è¨€ä½¿ç”¨æŒ‡å—
- [SQLite C APIæ–‡æ¡£](https://www.sqlite.org/c3ref/intro.html)

---

## 12. ğŸ”— äº¤å‰å¼•ç”¨

### 12.1. ç†è®ºæ¨¡å‹ ğŸ†•

- â­â­ [ç³»ç»Ÿç†è®ºæ¨¡å‹](../11-ç†è®ºæ¨¡å‹/11.01-ç³»ç»Ÿç†è®ºæ¨¡å‹.md) - ç³»ç»Ÿæ¥å£ç†è®ºã€C APIç†è®º
- â­ [ç®—æ³•å¤æ‚åº¦ç†è®º](../11-ç†è®ºæ¨¡å‹/11.03-ç®—æ³•å¤æ‚åº¦ç†è®º.md) - C/C++æ“ä½œå¤æ‚åº¦

### 12.2. è®¾è®¡æ¨¡å‹ ğŸ†•

- â­â­ [è®¾è®¡æ¨¡å¼](../12-è®¾è®¡æ¨¡å‹/12.03-è®¾è®¡æ¨¡å¼.md) - C/C++ç¼–ç¨‹æ¨¡å¼
- â­ [è®¾è®¡åŸåˆ™](../12-è®¾è®¡æ¨¡å‹/12.02-è®¾è®¡åŸåˆ™.md) - C/C++ç¼–ç¨‹åŸåˆ™

---

## 13. ğŸ“š å‚è€ƒèµ„æ–™

- [SQLite C APIå‚è€ƒ](https://www.sqlite.org/c3ref/intro.html)
- [SQLite C++æ•™ç¨‹](https://www.sqlite.org/quickstart.html)
- [SQLiteä¸‹è½½é¡µé¢](https://www.sqlite.org/download.html)

---

**æœ€åæ›´æ–°**ï¼š2025-01-15
**ç»´æŠ¤è€…**ï¼šData-Science Team
