# SQLiteå¼€å‘å·¥ä½œæµä¸CI/CDé›†æˆ

> **åˆ›å»ºæ—¥æœŸ**: 2025-12-05
> **ç‰ˆæœ¬**: SQLite 3.47.x
> **éš¾åº¦**: â­â­â­â­â­
> **é€‚ç”¨åœºæ™¯**: å¼€å‘å·¥ä½œæµã€CI/CDé›†æˆã€è‡ªåŠ¨åŒ–éƒ¨ç½²ã€æ•°æ®åº“ç‰ˆæœ¬ç®¡ç†

---

## ğŸ“‘ ç›®å½•

- [SQLiteå¼€å‘å·¥ä½œæµä¸CI/CDé›†æˆ](#sqliteå¼€å‘å·¥ä½œæµä¸cicdé›†æˆ)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [å·¥ä½œæµæ€»è§ˆ](#å·¥ä½œæµæ€»è§ˆ)
  - [1. æ•°æ®åº“ç‰ˆæœ¬ç®¡ç†](#1-æ•°æ®åº“ç‰ˆæœ¬ç®¡ç†)
    - [1.1 Schemaè¿ç§»](#11-schemaè¿ç§»)
    - [1.2 ç‰ˆæœ¬æ§åˆ¶ç­–ç•¥](#12-ç‰ˆæœ¬æ§åˆ¶ç­–ç•¥)
    - [1.3 è¿ç§»è„šæœ¬ç®¡ç†](#13-è¿ç§»è„šæœ¬ç®¡ç†)
  - [2. CI/CDé›†æˆ](#2-cicdé›†æˆ)
    - [2.1 GitHub Actions](#21-github-actions)
    - [2.2 GitLab CI](#22-gitlab-ci)
    - [2.3 Jenkins Pipeline](#23-jenkins-pipeline)
  - [3. è‡ªåŠ¨åŒ–æµ‹è¯•](#3-è‡ªåŠ¨åŒ–æµ‹è¯•)
    - [3.1 æµ‹è¯•æµç¨‹](#31-æµ‹è¯•æµç¨‹)
    - [3.2 æ€§èƒ½æµ‹è¯•é›†æˆ](#32-æ€§èƒ½æµ‹è¯•é›†æˆ)
  - [4. è‡ªåŠ¨åŒ–éƒ¨ç½²](#4-è‡ªåŠ¨åŒ–éƒ¨ç½²)
    - [4.1 éƒ¨ç½²è„šæœ¬](#41-éƒ¨ç½²è„šæœ¬)
    - [4.2 å›æ»šæœºåˆ¶](#42-å›æ»šæœºåˆ¶)
  - [5. æ•°æ®åº“å˜æ›´ç®¡ç†](#5-æ•°æ®åº“å˜æ›´ç®¡ç†)
    - [5.1 å˜æ›´å®¡æ‰¹æµç¨‹](#51-å˜æ›´å®¡æ‰¹æµç¨‹)
    - [5.2 å˜æ›´è®°å½•](#52-å˜æ›´è®°å½•)
  - [6. æœ€ä½³å®è·µ](#6-æœ€ä½³å®è·µ)
    - [6.1 å¼€å‘å·¥ä½œæµæœ€ä½³å®è·µ](#61-å¼€å‘å·¥ä½œæµæœ€ä½³å®è·µ)
    - [6.2 CI/CDæœ€ä½³å®è·µ](#62-cicdæœ€ä½³å®è·µ)
  - [7. ğŸ”— ç›¸å…³èµ„æº](#7--ç›¸å…³èµ„æº)
    - [å†…éƒ¨èµ„æº](#å†…éƒ¨èµ„æº)
    - [å¤–éƒ¨èµ„æº](#å¤–éƒ¨èµ„æº)

---

## å·¥ä½œæµæ€»è§ˆ

```text
SQLiteå¼€å‘å·¥ä½œæµ
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        å·¥ä½œæµé˜¶æ®µ                                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1. å¼€å‘é˜¶æ®µ                                                              â”‚
â”‚    â€¢ Schemaè®¾è®¡                                                          â”‚
â”‚    â€¢ è¿ç§»è„šæœ¬ç¼–å†™                                                        â”‚
â”‚    â€¢ æœ¬åœ°æµ‹è¯•                                                            â”‚
â”‚                                                                          â”‚
â”‚ 2. ç‰ˆæœ¬æ§åˆ¶                                                              â”‚
â”‚    â€¢ Schemaç‰ˆæœ¬ç®¡ç†                                                      â”‚
â”‚    â€¢ è¿ç§»è„šæœ¬ç‰ˆæœ¬æ§åˆ¶                                                    â”‚
â”‚    â€¢ å˜æ›´è®°å½•                                                            â”‚
â”‚                                                                          â”‚
â”‚ 3. CI/CDæµç¨‹                                                             â”‚
â”‚    â€¢ è‡ªåŠ¨åŒ–æµ‹è¯•                                                          â”‚
â”‚    â€¢ SchemaéªŒè¯                                                          â”‚
â”‚    â€¢ æ€§èƒ½æµ‹è¯•                                                            â”‚
â”‚                                                                          â”‚
â”‚ 4. éƒ¨ç½²é˜¶æ®µ                                                              â”‚
â”‚    â€¢ è¿ç§»è„šæœ¬æ‰§è¡Œ                                                        â”‚
â”‚    â€¢ æ•°æ®éªŒè¯                                                            â”‚
â”‚    â€¢ å›æ»šå‡†å¤‡                                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 1. æ•°æ®åº“ç‰ˆæœ¬ç®¡ç†

### 1.1 Schemaè¿ç§»

```python
import sqlite3
from pathlib import Path
from typing import List, Dict
import hashlib

class SchemaMigration:
    def __init__(self, db_path: str):
        self.db_path = db_path
        self.conn = sqlite3.connect(db_path)
        self.setup_migration_table()

    def setup_migration_table(self):
        """è®¾ç½®è¿ç§»è®°å½•è¡¨"""
        cursor = self.conn.cursor()
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS schema_migrations (
                version INTEGER PRIMARY KEY,
                name TEXT NOT NULL,
                checksum TEXT NOT NULL,
                applied_at INTEGER NOT NULL
            )
        """)
        self.conn.commit()

    def get_current_version(self) -> int:
        """è·å–å½“å‰Schemaç‰ˆæœ¬"""
        cursor = self.conn.cursor()
        cursor.execute("SELECT MAX(version) FROM schema_migrations")
        result = cursor.fetchone()[0]
        return result if result else 0

    def apply_migration(self, version: int, name: str, sql: str):
        """åº”ç”¨è¿ç§»"""
        cursor = self.conn.cursor()

        # è®¡ç®—SQLæ ¡éªŒå’Œ
        checksum = hashlib.md5(sql.encode()).hexdigest()

        # æ£€æŸ¥æ˜¯å¦å·²åº”ç”¨
        cursor.execute("""
            SELECT version FROM schema_migrations WHERE version = ?
        """, (version,))
        if cursor.fetchone():
            print(f"è¿ç§» {version} å·²åº”ç”¨ï¼Œè·³è¿‡")
            return

        # æ‰§è¡Œè¿ç§»
        try:
            cursor.executescript(sql)
            cursor.execute("""
                INSERT INTO schema_migrations (version, name, checksum, applied_at)
                VALUES (?, ?, ?, strftime('%s', 'now'))
            """, (version, name, checksum))
            self.conn.commit()
            print(f"è¿ç§» {version} åº”ç”¨æˆåŠŸ")
        except Exception as e:
            self.conn.rollback()
            print(f"è¿ç§» {version} åº”ç”¨å¤±è´¥: {e}")
            raise

    def rollback_migration(self, version: int):
        """å›æ»šè¿ç§»"""
        cursor = self.conn.cursor()

        # è·å–è¿ç§»ä¿¡æ¯
        cursor.execute("""
            SELECT name FROM schema_migrations WHERE version = ?
        """, (version,))
        result = cursor.fetchone()
        if not result:
            raise ValueError(f"è¿ç§» {version} ä¸å­˜åœ¨")

        # æ‰§è¡Œå›æ»šï¼ˆéœ€è¦æä¾›å›æ»šSQLï¼‰
        # è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…éœ€è¦ç»´æŠ¤å›æ»šè„šæœ¬
        cursor.execute("DELETE FROM schema_migrations WHERE version = ?", (version,))
        self.conn.commit()
        print(f"è¿ç§» {version} å·²å›æ»š")

class MigrationManager:
    def __init__(self, migrations_dir: str):
        self.migrations_dir = Path(migrations_dir)
        self.migrations = self.load_migrations()

    def load_migrations(self) -> List[Dict]:
        """åŠ è½½è¿ç§»è„šæœ¬"""
        migrations = []

        for migration_file in sorted(self.migrations_dir.glob("*.sql")):
            # æ–‡ä»¶åæ ¼å¼: 001_initial_schema.sql
            parts = migration_file.stem.split('_', 1)
            version = int(parts[0])
            name = parts[1] if len(parts) > 1 else migration_file.stem

            with open(migration_file, 'r', encoding='utf-8') as f:
                sql = f.read()

            migrations.append({
                'version': version,
                'name': name,
                'file': migration_file,
                'sql': sql
            })

        return sorted(migrations, key=lambda x: x['version'])

    def apply_all(self, db_path: str):
        """åº”ç”¨æ‰€æœ‰æœªåº”ç”¨çš„è¿ç§»"""
        migration = SchemaMigration(db_path)
        current_version = migration.get_current_version()

        for mig in self.migrations:
            if mig['version'] > current_version:
                migration.apply_migration(
                    mig['version'],
                    mig['name'],
                    mig['sql']
                )

    def create_migration(self, name: str) -> Path:
        """åˆ›å»ºæ–°çš„è¿ç§»è„šæœ¬"""
        max_version = max([m['version'] for m in self.migrations]) if self.migrations else 0
        new_version = max_version + 1

        migration_file = self.migrations_dir / f"{new_version:03d}_{name}.sql"
        migration_file.write_text(f"-- Migration: {name}\n-- Version: {new_version}\n\n")

        return migration_file
```

### 1.2 ç‰ˆæœ¬æ§åˆ¶ç­–ç•¥

```python
class VersionControl:
    def __init__(self, db_path: str):
        self.db_path = db_path
        self.conn = sqlite3.connect(db_path)

    def get_schema_version(self) -> str:
        """è·å–Schemaç‰ˆæœ¬"""
        cursor = self.conn.cursor()

        # è·å–æ‰€æœ‰è¡¨ç»“æ„
        cursor.execute("""
            SELECT name, sql FROM sqlite_master
            WHERE type='table' AND name NOT LIKE 'sqlite_%'
            ORDER BY name
        """)

        tables = cursor.fetchall()
        schema_text = '\n'.join([f"{name}: {sql}" for name, sql in tables])

        # è®¡ç®—ç‰ˆæœ¬å“ˆå¸Œ
        version_hash = hashlib.sha256(schema_text.encode()).hexdigest()[:8]
        return version_hash

    def export_schema(self, output_file: str):
        """å¯¼å‡ºSchema"""
        cursor = self.conn.cursor()

        with open(output_file, 'w', encoding='utf-8') as f:
            f.write("-- SQLite Schema Export\n")
            f.write(f"-- Version: {self.get_schema_version()}\n")
            f.write(f"-- Date: {datetime.now().isoformat()}\n\n")

            # å¯¼å‡ºè¡¨ç»“æ„
            cursor.execute("""
                SELECT sql FROM sqlite_master
                WHERE type='table' AND name NOT LIKE 'sqlite_%'
                ORDER BY name
            """)

            for (sql,) in cursor.fetchall():
                if sql:
                    f.write(f"{sql};\n\n")

            # å¯¼å‡ºç´¢å¼•
            cursor.execute("""
                SELECT sql FROM sqlite_master
                WHERE type='index' AND name NOT LIKE 'sqlite_%'
                ORDER BY name
            """)

            for (sql,) in cursor.fetchall():
                if sql:
                    f.write(f"{sql};\n\n")
```

### 1.3 è¿ç§»è„šæœ¬ç®¡ç†

```python
# migrations/001_initial_schema.sql
CREATE TABLE users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    email TEXT UNIQUE NOT NULL,
    created_at INTEGER NOT NULL
);

CREATE INDEX idx_users_email ON users(email);

# migrations/002_add_user_profile.sql
ALTER TABLE users ADD COLUMN profile TEXT;

CREATE TABLE user_profiles (
    user_id INTEGER PRIMARY KEY,
    bio TEXT,
    avatar_url TEXT,
    FOREIGN KEY (user_id) REFERENCES users(id)
);

# migrations/003_add_indexes.sql
CREATE INDEX idx_users_created ON users(created_at);
CREATE INDEX idx_profiles_user ON user_profiles(user_id);
```

---

## 2. CI/CDé›†æˆ

### 2.1 GitHub Actions

```yaml
# .github/workflows/sqlite-test.yml
name: SQLite Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install dependencies
      run: |
        pip install -r requirements.txt
        pip install pytest pytest-cov

    - name: Run migrations
      run: |
        python scripts/migrate.py --up

    - name: Run tests
      run: |
        pytest tests/ --cov=src --cov-report=xml

    - name: Upload coverage
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml

    - name: Schema validation
      run: |
        python scripts/validate_schema.py

    - name: Performance tests
      run: |
        pytest tests/performance/ --benchmark-only
```

### 2.2 GitLab CI

```yaml
# .gitlab-ci.yml
stages:
  - test
  - migrate
  - deploy

variables:
  SQLITE_DB: "test.db"

test:
  stage: test
  script:
    - pip install -r requirements.txt
    - pytest tests/
    - python scripts/validate_schema.py
  artifacts:
    paths:
      - test-results/
    expire_in: 1 week

migrate:
  stage: migrate
  script:
    - python scripts/migrate.py --up
    - python scripts/validate_schema.py
  only:
    - main

deploy:
  stage: deploy
  script:
    - python scripts/deploy.py
  only:
    - main
  when: manual
```

### 2.3 Jenkins Pipeline

```groovy
// Jenkinsfile
pipeline {
    agent any

    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }

        stage('Test') {
            steps {
                sh 'pip install -r requirements.txt'
                sh 'pytest tests/'
            }
        }

        stage('Migrate') {
            steps {
                sh 'python scripts/migrate.py --up'
            }
        }

        stage('Deploy') {
            when {
                branch 'main'
            }
            steps {
                sh 'python scripts/deploy.py'
            }
        }
    }

    post {
        always {
            archiveArtifacts artifacts: 'test-results/**/*'
        }
    }
}
```

---

## 3. è‡ªåŠ¨åŒ–æµ‹è¯•

### 3.1 æµ‹è¯•æµç¨‹

```python
# scripts/run_tests.py
import subprocess
import sys

def run_tests():
    """è¿è¡Œæµ‹è¯•å¥—ä»¶"""
    commands = [
        ['pytest', 'tests/unit/', '-v'],
        ['pytest', 'tests/integration/', '-v'],
        ['pytest', 'tests/performance/', '--benchmark-only'],
    ]

    results = []
    for cmd in commands:
        result = subprocess.run(cmd, capture_output=True, text=True)
        results.append({
            'command': ' '.join(cmd),
            'returncode': result.returncode,
            'stdout': result.stdout,
            'stderr': result.stderr
        })

    # æ£€æŸ¥æ˜¯å¦æœ‰å¤±è´¥
    failed = any(r['returncode'] != 0 for r in results)

    if failed:
        print("æµ‹è¯•å¤±è´¥:")
        for r in results:
            if r['returncode'] != 0:
                print(f"  {r['command']}")
                print(f"  {r['stderr']}")
        sys.exit(1)
    else:
        print("æ‰€æœ‰æµ‹è¯•é€šè¿‡")

if __name__ == '__main__':
    run_tests()
```

### 3.2 æ€§èƒ½æµ‹è¯•é›†æˆ

```python
# scripts/performance_test.py
import pytest
import time
from migration_manager import MigrationManager

def test_migration_performance():
    """æµ‹è¯•è¿ç§»æ€§èƒ½"""
    manager = MigrationManager('migrations')

    start = time.time()
    manager.apply_all('test.db')
    elapsed = time.time() - start

    # æ–­è¨€è¿ç§»æ—¶é—´
    assert elapsed < 5.0, f"è¿ç§»è€—æ—¶è¿‡é•¿: {elapsed:.2f}ç§’"

def test_query_performance():
    """æµ‹è¯•æŸ¥è¯¢æ€§èƒ½"""
    conn = sqlite3.connect('test.db')
    cursor = conn.cursor()

    # å‡†å¤‡æµ‹è¯•æ•°æ®
    cursor.executemany(
        "INSERT INTO users (name, email, created_at) VALUES (?, ?, ?)",
        [(f'User{i}', f'user{i}@example.com', int(time.time()))
         for i in range(10000)]
    )
    conn.commit()

    # æµ‹è¯•æŸ¥è¯¢æ€§èƒ½
    start = time.time()
    cursor.execute("SELECT * FROM users WHERE email = ?", ('user5000@example.com',))
    cursor.fetchone()
    elapsed = time.time() - start

    assert elapsed < 0.01, f"æŸ¥è¯¢è€—æ—¶è¿‡é•¿: {elapsed*1000:.2f}æ¯«ç§’"
```

---

## 4. è‡ªåŠ¨åŒ–éƒ¨ç½²

### 4.1 éƒ¨ç½²è„šæœ¬

```python
# scripts/deploy.py
import argparse
import sqlite3
from migration_manager import MigrationManager
from schema_migration import SchemaMigration

class DeploymentManager:
    def __init__(self, db_path: str, migrations_dir: str):
        self.db_path = db_path
        self.migration_manager = MigrationManager(migrations_dir)
        self.schema_migration = SchemaMigration(db_path)

    def deploy(self, backup: bool = True):
        """éƒ¨ç½²æ•°æ®åº“å˜æ›´"""
        if backup:
            self.backup_database()

        # åº”ç”¨è¿ç§»
        self.migration_manager.apply_all(self.db_path)

        # éªŒè¯Schema
        self.validate_schema()

        # æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        self.update_statistics()

    def backup_database(self):
        """å¤‡ä»½æ•°æ®åº“"""
        from datetime import datetime
        backup_path = f"{self.db_path}.{datetime.now().strftime('%Y%m%d_%H%M%S')}"

        import shutil
        shutil.copy2(self.db_path, backup_path)
        print(f"æ•°æ®åº“å·²å¤‡ä»½åˆ°: {backup_path}")

    def validate_schema(self):
        """éªŒè¯Schema"""
        cursor = self.schema_migration.conn.cursor()

        # å®Œæ•´æ€§æ£€æŸ¥
        cursor.execute("PRAGMA integrity_check")
        result = cursor.fetchone()[0]

        if result != 'ok':
            raise Exception(f"SchemaéªŒè¯å¤±è´¥: {result}")

        print("SchemaéªŒè¯é€šè¿‡")

    def update_statistics(self):
        """æ›´æ–°ç»Ÿè®¡ä¿¡æ¯"""
        cursor = self.schema_migration.conn.cursor()
        cursor.execute("ANALYZE")
        print("ç»Ÿè®¡ä¿¡æ¯å·²æ›´æ–°")

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='éƒ¨ç½²æ•°æ®åº“å˜æ›´')
    parser.add_argument('--db', required=True, help='æ•°æ®åº“è·¯å¾„')
    parser.add_argument('--migrations', default='migrations', help='è¿ç§»è„šæœ¬ç›®å½•')
    parser.add_argument('--no-backup', action='store_true', help='è·³è¿‡å¤‡ä»½')

    args = parser.parse_args()

    manager = DeploymentManager(args.db, args.migrations)
    manager.deploy(backup=not args.no_backup)
```

### 4.2 å›æ»šæœºåˆ¶

```python
class RollbackManager:
    def __init__(self, db_path: str):
        self.db_path = db_path
        self.migration = SchemaMigration(db_path)

    def rollback_to_version(self, target_version: int):
        """å›æ»šåˆ°æŒ‡å®šç‰ˆæœ¬"""
        current_version = self.migration.get_current_version()

        if target_version >= current_version:
            raise ValueError(f"ç›®æ ‡ç‰ˆæœ¬ {target_version} å¿…é¡»å°äºå½“å‰ç‰ˆæœ¬ {current_version}")

        # è·å–éœ€è¦å›æ»šçš„è¿ç§»
        cursor = self.migration.conn.cursor()
        cursor.execute("""
            SELECT version, name FROM schema_migrations
            WHERE version > ?
            ORDER BY version DESC
        """, (target_version,))

        migrations_to_rollback = cursor.fetchall()

        # æ‰§è¡Œå›æ»š
        for version, name in migrations_to_rollback:
            print(f"å›æ»šè¿ç§» {version}: {name}")
            self.migration.rollback_migration(version)

        print(f"å·²å›æ»šåˆ°ç‰ˆæœ¬ {target_version}")
```

---

## 5. æ•°æ®åº“å˜æ›´ç®¡ç†

### 5.1 å˜æ›´å®¡æ‰¹æµç¨‹

```python
class ChangeManagement:
    def __init__(self):
        self.pending_changes = []
        self.approved_changes = []

    def submit_change(self, change: Dict):
        """æäº¤å˜æ›´è¯·æ±‚"""
        change['status'] = 'pending'
        change['submitted_at'] = datetime.now().isoformat()
        self.pending_changes.append(change)

    def approve_change(self, change_id: str, approver: str):
        """æ‰¹å‡†å˜æ›´"""
        change = next((c for c in self.pending_changes if c['id'] == change_id), None)
        if not change:
            raise ValueError(f"å˜æ›´ {change_id} ä¸å­˜åœ¨")

        change['status'] = 'approved'
        change['approver'] = approver
        change['approved_at'] = datetime.now().isoformat()

        self.pending_changes.remove(change)
        self.approved_changes.append(change)

    def get_pending_changes(self) -> List[Dict]:
        """è·å–å¾…å®¡æ‰¹å˜æ›´"""
        return [c for c in self.pending_changes if c['status'] == 'pending']
```

### 5.2 å˜æ›´è®°å½•

```python
class ChangeLogger:
    def __init__(self, conn):
        self.conn = conn
        self.setup_change_log()

    def setup_change_log(self):
        """è®¾ç½®å˜æ›´æ—¥å¿—è¡¨"""
        cursor = self.conn.cursor()
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS change_log (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                change_type TEXT NOT NULL,
                description TEXT NOT NULL,
                applied_by TEXT NOT NULL,
                applied_at INTEGER NOT NULL,
                version INTEGER,
                rollback_sql TEXT
            )
        """)
        self.conn.commit()

    def log_change(self, change_type: str, description: str,
                   applied_by: str, version: int = None, rollback_sql: str = None):
        """è®°å½•å˜æ›´"""
        cursor = self.conn.cursor()
        cursor.execute("""
            INSERT INTO change_log
            (change_type, description, applied_by, applied_at, version, rollback_sql)
            VALUES (?, ?, ?, strftime('%s', 'now'), ?, ?)
        """, (change_type, description, applied_by, version, rollback_sql))
        self.conn.commit()

    def get_change_history(self, limit: int = 100) -> List[Dict]:
        """è·å–å˜æ›´å†å²"""
        cursor = self.conn.cursor()
        cursor.execute("""
            SELECT * FROM change_log
            ORDER BY applied_at DESC
            LIMIT ?
        """, (limit,))

        return [dict(row) for row in cursor.fetchall()]
```

---

## 6. æœ€ä½³å®è·µ

### 6.1 å¼€å‘å·¥ä½œæµæœ€ä½³å®è·µ

1. **ç‰ˆæœ¬æ§åˆ¶**
   - æ‰€æœ‰Schemaå˜æ›´é€šè¿‡è¿ç§»è„šæœ¬
   - è¿ç§»è„šæœ¬ç‰ˆæœ¬åŒ–
   - ç¦æ­¢ç›´æ¥ä¿®æ”¹ç”Ÿäº§æ•°æ®åº“

2. **æµ‹è¯•æµç¨‹**
   - æ¯ä¸ªè¿ç§»è„šæœ¬éƒ½è¦æµ‹è¯•
   - è‡ªåŠ¨åŒ–æµ‹è¯•è¦†ç›–
   - æ€§èƒ½æµ‹è¯•é›†æˆ

3. **éƒ¨ç½²æµç¨‹**
   - éƒ¨ç½²å‰å¤‡ä»½
   - éªŒè¯Schema
   - å‡†å¤‡å›æ»šæ–¹æ¡ˆ

### 6.2 CI/CDæœ€ä½³å®è·µ

1. **è‡ªåŠ¨åŒ–**
   - è‡ªåŠ¨åŒ–æµ‹è¯•
   - è‡ªåŠ¨åŒ–è¿ç§»
   - è‡ªåŠ¨åŒ–éªŒè¯

2. **å®‰å…¨æ€§**
   - å˜æ›´å®¡æ‰¹
   - å˜æ›´è®°å½•
   - å®¡è®¡æ—¥å¿—

3. **å¯é æ€§**
   - å›æ»šæœºåˆ¶
   - å¤‡ä»½ç­–ç•¥
   - ç›‘æ§å‘Šè­¦

---

## 7. ğŸ”— ç›¸å…³èµ„æº

### å†…éƒ¨èµ„æº

- [æµ‹è¯•ä¸è°ƒè¯•](./08.16-SQLiteæµ‹è¯•ä¸è°ƒè¯•å®Œæ•´æŒ‡å—.md) - æµ‹è¯•å®è·µ
- [å¤‡ä»½ä¸æ¢å¤](./08.14-SQLiteå¤‡ä»½ä¸æ¢å¤å®Œæ•´æŒ‡å—.md) - å¤‡ä»½ç­–ç•¥
- [ç”Ÿäº§ç¯å¢ƒç›‘æ§](./08.13-SQLiteç”Ÿäº§ç¯å¢ƒç›‘æ§ä¸è¯Šæ–­.md) - ç›‘æ§å®è·µ

### å¤–éƒ¨èµ„æº

- [GitHub Actionsæ–‡æ¡£](https://docs.github.com/en/actions)
- [GitLab CIæ–‡æ¡£](https://docs.gitlab.com/ee/ci/)
- [Jenkinsæ–‡æ¡£](https://www.jenkins.io/doc/)

---

**æœ€åæ›´æ–°**: 2025-12-05
**ç»´æŠ¤è€…**: Data-Science Team
