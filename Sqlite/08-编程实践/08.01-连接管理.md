# 连接管理：单连接最佳实践与多线程共享

> **创建日期**：2025-11-13
> **最后更新**：2025-11-13
> **版本**：SQLite 3.31+ 至 3.47+

---

## 📋 概述

SQLite的连接管理是性能和安全的关键。本文档深入解析单连接最佳实践、多线程共享和内存数据库的使用。

---

## 一、单连接最佳实践

### 1.1 核心原则

**SQLite设计哲学**：单个应用只维护一个`sqlite3*`连接

**原因**：

- SQLite是进程内数据库，单连接性能最优
- 多连接会增加锁竞争和内存开销
- WAL模式支持一写多读，单连接足够

### 1.2 连接创建

**C API**：

```c
#include <sqlite3.h>

sqlite3* db;

// 打开数据库连接
int rc = sqlite3_open("app.db", &db);
if (rc != SQLITE_OK) {
    fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(db));
    sqlite3_close(db);
    return 1;
}

// 配置连接
sqlite3_exec(db, "PRAGMA journal_mode=WAL;", NULL, NULL, NULL);
sqlite3_exec(db, "PRAGMA foreign_keys=ON;", NULL, NULL, NULL);

// 使用连接...

// 关闭连接
sqlite3_close(db);
```

**Python API**：

```python
import sqlite3

# 打开连接
conn = sqlite3.connect('app.db')

# 配置连接
conn.execute('PRAGMA journal_mode=WAL')
conn.execute('PRAGMA foreign_keys=ON')

# 使用连接...

# 关闭连接
conn.close()
```

### 1.3 连接配置

**推荐配置**：

```c
// C代码：生产级连接配置
sqlite3* db;
sqlite3_open("app.db", &db);

// 性能配置
sqlite3_exec(db, "PRAGMA journal_mode=WAL;", NULL, NULL, NULL);
sqlite3_exec(db, "PRAGMA synchronous=NORMAL;", NULL, NULL, NULL);
sqlite3_exec(db, "PRAGMA cache_size=-64000;", NULL, NULL, NULL);  // 64MB缓存
sqlite3_exec(db, "PRAGMA temp_store=MEMORY;", NULL, NULL, NULL);

// 安全配置
sqlite3_exec(db, "PRAGMA foreign_keys=ON;", NULL, NULL, NULL);

// 超时配置
sqlite3_busy_timeout(db, 5000);  // 5秒超时
```

---

## 二、多线程共享

### 2.1 线程安全模式

**SQLite线程安全选项**：

| 编译选项 | 说明 | 性能 |
|---------|------|------|
| **SQLITE_THREADSAFE=0** | 单线程模式 | 最快 |
| **SQLITE_THREADSAFE=1** | 序列化模式 | 较慢 |
| **SQLITE_THREADSAFE=2** | 多线程模式 | 中等 |

**默认情况**：大多数SQLite编译版本支持多线程

### 2.2 多线程连接共享

**方式1：序列化模式（推荐）**：

```c
// 使用SQLITE_OPEN_FULLMUTEX标志
sqlite3* db;
sqlite3_open_v2(
    "app.db",
    &db,
    SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE | SQLITE_OPEN_FULLMUTEX,
    NULL
);

// 多线程安全：SQLite内部管理锁
// 性能：中等（有锁开销）
```

**方式2：应用层锁（高性能）**：

```c
#include <pthread.h>

sqlite3* db;
pthread_mutex_t db_mutex = PTHREAD_MUTEX_INITIALIZER;

// 线程1
void* thread1_func(void* arg) {
    pthread_mutex_lock(&db_mutex);
    sqlite3_exec(db, "INSERT INTO ...", NULL, NULL, NULL);
    pthread_mutex_unlock(&db_mutex);
    return NULL;
}

// 线程2
void* thread2_func(void* arg) {
    pthread_mutex_lock(&db_mutex);
    sqlite3_exec(db, "SELECT ...", NULL, NULL, NULL);
    pthread_mutex_unlock(&db_mutex);
    return NULL;
}
```

### 2.3 Python多线程

**推荐方式**：

```python
import sqlite3
import threading

# 创建线程本地连接
local = threading.local()

def get_db():
    if not hasattr(local, 'db'):
        local.db = sqlite3.connect('app.db', check_same_thread=False)
        local.db.execute('PRAGMA journal_mode=WAL')
    return local.db

# 每个线程使用自己的连接
def worker():
    db = get_db()
    db.execute('INSERT INTO ...')
    db.commit()
```

**不推荐方式**：

```python
# ❌ 不推荐：多线程共享同一连接
db = sqlite3.connect('app.db')

def worker():
    db.execute('INSERT INTO ...')  # 可能出错
```

---

## 三、内存数据库（:memory:）

### 3.1 内存数据库概述

**定义**：完全在RAM中运行的数据库，进程退出后数据消失

**特点**：

- 极快的读写性能
- 无需磁盘I/O
- 数据不持久化
- 适合临时数据和测试

### 3.2 使用场景

**场景1：单元测试**：

```python
import sqlite3
import pytest

@pytest.fixture
def test_db():
    # 每个测试用例独立的内存数据库
    conn = sqlite3.connect(':memory:')
    conn.execute('''
        CREATE TABLE test_users (
            id INTEGER PRIMARY KEY,
            name TEXT UNIQUE
        )
    ''')
    yield conn
    conn.close()  # 测试结束自动销毁

def test_user_creation(test_db):
    test_db.execute("INSERT INTO test_users (name) VALUES ('Alice')")
    result = test_db.execute("SELECT * FROM test_users").fetchone()
    assert result[1] == 'Alice'
```

**场景2：临时数据缓存**：

```python
# 高速临时缓存
cache_db = sqlite3.connect(':memory:')
cache_db.execute('''
    CREATE TABLE cache (
        key TEXT PRIMARY KEY,
        value TEXT,
        expires_at INTEGER
    )
''')

# 写入缓存
cache_db.execute(
    "INSERT OR REPLACE INTO cache VALUES (?, ?, ?)",
    (key, value, expires_at)
)

# 读取缓存
result = cache_db.execute(
    "SELECT value FROM cache WHERE key = ? AND expires_at > ?",
    (key, current_time)
).fetchone()
```

**场景3：数据处理中间结果**：

```python
# 复杂数据处理
temp_db = sqlite3.connect(':memory:')

# 加载数据到内存
temp_db.execute('CREATE TABLE temp_data AS SELECT * FROM source_table')

# 复杂计算
temp_db.execute('''
    WITH processed AS (
        SELECT *, ROW_NUMBER() OVER (PARTITION BY category ORDER BY value DESC) as rn
        FROM temp_data
    )
    SELECT * FROM processed WHERE rn <= 10
''')

# 结果写回磁盘
# ...
```

### 3.3 内存数据库性能

**性能对比**：

| 操作 | 磁盘数据库 | 内存数据库 | 提升 |
|------|----------|----------|------|
| 插入1000条 | ~45ms | ~2ms | 22倍 |
| 查询1000条 | ~8ms | ~0.5ms | 16倍 |
| 复杂JOIN | ~25ms | ~1ms | 25倍 |

---

## 四、连接池配置

### 4.1 SQLite连接池特点

**重要说明**：SQLite通常不需要连接池

**原因**：

- SQLite是进程内数据库，连接创建成本低
- 单连接+WAL模式性能最优
- 连接池可能增加复杂度

### 4.2 特殊情况：连接池使用

**场景**：需要限制并发连接数

```python
import sqlite3
from queue import Queue
import threading

class SQLiteConnectionPool:
    def __init__(self, db_path, max_connections=5):
        self.db_path = db_path
        self.pool = Queue(maxsize=max_connections)

        # 预创建连接
        for _ in range(max_connections):
            conn = sqlite3.connect(db_path, check_same_thread=False)
            conn.execute('PRAGMA journal_mode=WAL')
            self.pool.put(conn)

    def get_connection(self):
        return self.pool.get()

    def return_connection(self, conn):
        self.pool.put(conn)

    def close_all(self):
        while not self.pool.empty():
            conn = self.pool.get()
            conn.close()

# 使用连接池
pool = SQLiteConnectionPool('app.db')

def worker():
    conn = pool.get_connection()
    try:
        conn.execute('INSERT INTO ...')
        conn.commit()
    finally:
        pool.return_connection(conn)
```

### 4.3 Go语言连接池

**database/sql包**：

```go
import (
    "database/sql"
    _ "github.com/mattn/go-sqlite3"
)

// Go的database/sql包自动管理连接池
db, err := sql.Open("sqlite3", "app.db")
if err != nil {
    log.Fatal(err)
}
defer db.Close()

// 配置连接池
db.SetMaxOpenConns(1)  // SQLite最佳实践：单连接
db.SetMaxIdleConns(1)
db.SetConnMaxLifetime(0)  // 连接不过期

// 使用连接
rows, err := db.Query("SELECT * FROM users")
```

---

## 五、连接生命周期管理

### 5.1 连接创建模式

**模式1：应用启动时创建**：

```c
// 应用启动
sqlite3* db;
sqlite3_open("app.db", &db);
configure_database(db);

// 应用运行期间使用
// ...

// 应用退出时关闭
sqlite3_close(db);
```

**模式2：按需创建**：

```python
# 按需创建连接（适合脚本）
def get_connection():
    conn = sqlite3.connect('app.db')
    conn.execute('PRAGMA journal_mode=WAL')
    return conn

def process_data():
    conn = get_connection()
    try:
        # 处理数据
        pass
    finally:
        conn.close()
```

### 5.2 连接错误处理

**C API错误处理**：

```c
sqlite3* db;
int rc = sqlite3_open("app.db", &db);

if (rc != SQLITE_OK) {
    const char* err_msg = sqlite3_errmsg(db);
    fprintf(stderr, "Database error: %s\n", err_msg);
    sqlite3_close(db);
    return 1;
}

// 使用连接时检查错误
rc = sqlite3_exec(db, "INSERT INTO ...", NULL, NULL, NULL);
if (rc != SQLITE_OK) {
    fprintf(stderr, "SQL error: %s\n", sqlite3_errmsg(db));
}
```

**Python错误处理**：

```python
import sqlite3

try:
    conn = sqlite3.connect('app.db')
    cursor = conn.cursor()
    cursor.execute('INSERT INTO ...')
    conn.commit()
except sqlite3.Error as e:
    print(f"Database error: {e}")
finally:
    if conn:
        conn.close()
```

### 5.3 连接健康检查

**定期检查**：

```python
import sqlite3
import time

def check_connection_health(conn):
    try:
        # 简单查询检查连接
        conn.execute('SELECT 1').fetchone()
        return True
    except sqlite3.Error:
        return False

# 定期检查
def monitor_connection(conn):
    while True:
        if not check_connection_health(conn):
            # 重新创建连接
            conn.close()
            conn = sqlite3.connect('app.db')
        time.sleep(60)  # 每分钟检查一次
```

---

## 六、最佳实践总结

### 6.1 连接管理原则

1. **单连接优先**：单个应用只维护一个连接
2. **WAL模式**：启用WAL模式支持并发
3. **配置优化**：设置合适的PRAGMA参数
4. **错误处理**：完善的错误处理和恢复机制

### 6.2 多线程建议

1. **序列化模式**：使用`SQLITE_OPEN_FULLMUTEX`或应用层锁
2. **线程本地连接**：每个线程使用独立连接（Python）
3. **避免共享连接**：不要在多线程间共享未保护的连接

### 6.3 内存数据库建议

1. **测试环境**：单元测试使用`:memory:`
2. **临时数据**：临时缓存和处理结果
3. **性能优化**：需要极致性能的临时场景

---

## 🔗 相关资源

- [08.02 事务管理](./08.02-事务管理.md)
- [08.04 PRAGMA配置](./08.04-PRAGMA配置.md)
- [01.02 事务与并发控制](../01-核心架构/01.02-事务与并发控制.md)

---

## 📚 参考资料

- [SQLite C API文档](https://www.sqlite.org/c3ref/open.html)
- [SQLite线程安全](https://www.sqlite.org/threadsafe.html)
- [SQLite内存数据库](https://www.sqlite.org/inmemorydb.html)

---

**最后更新**：2025-11-13
**维护者**：Data-Science Team
