# SQLiteé«˜çº§ç¼–ç¨‹æ¨¡å¼

> **åˆ›å»ºæ—¥æœŸ**ï¼š2025-12-04
> **ç‰ˆæœ¬**ï¼šSQLite 3.47.x
> **éš¾åº¦**ï¼šâ­â­â­â­
> **ç¼–ç¨‹è¯­è¨€**ï¼šPython / C / Go

---

## ğŸ“‹ æ¦‚è¿°

SQLiteé«˜çº§ç¼–ç¨‹æŠ€å·§å’Œè®¾è®¡æ¨¡å¼ï¼Œæå‡åº”ç”¨æ€§èƒ½å’Œå¯é æ€§ã€‚

---

## ğŸ“‘ ç›®å½•

- [SQLiteé«˜çº§ç¼–ç¨‹æ¨¡å¼](#sqliteé«˜çº§ç¼–ç¨‹æ¨¡å¼)
  - [ğŸ“‹ æ¦‚è¿°](#-æ¦‚è¿°)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [ä¸€ã€è¿æ¥æ± æ¨¡å¼](#ä¸€è¿æ¥æ± æ¨¡å¼)
  - [äºŒã€è¯»å†™åˆ†ç¦»æ¨¡å¼](#äºŒè¯»å†™åˆ†ç¦»æ¨¡å¼)
  - [ä¸‰ã€æ‰¹é‡æ“ä½œæ¨¡å¼](#ä¸‰æ‰¹é‡æ“ä½œæ¨¡å¼)
  - [å››ã€äº‹åŠ¡é‡è¯•æ¨¡å¼](#å››äº‹åŠ¡é‡è¯•æ¨¡å¼)
  - [äº”ã€ç¼“å­˜é¢„çƒ­æ¨¡å¼](#äº”ç¼“å­˜é¢„çƒ­æ¨¡å¼)
  - [å…­ã€ç›‘æ§è¯Šæ–­æ¨¡å¼](#å…­ç›‘æ§è¯Šæ–­æ¨¡å¼)

---

## ä¸€ã€è¿æ¥æ± æ¨¡å¼

```python
# SQLiteè¿æ¥æ± å®ç°ï¼ˆçº¿ç¨‹å®‰å…¨ï¼‰

import sqlite3
import threading
from queue import Queue, Empty
from contextlib import contextmanager

class SQLiteConnectionPool:
    def __init__(self, database, pool_size=5):
        self.database = database
        self.pool_size = pool_size
        self.pool = Queue(maxsize=pool_size)
        self.lock = threading.Lock()
        self._init_pool()

    def _init_pool(self):
        """åˆå§‹åŒ–è¿æ¥æ± """
        for _ in range(self.pool_size):
            conn = sqlite3.connect(
                self.database,
                check_same_thread=False,  # å…è®¸å¤šçº¿ç¨‹
                isolation_level=None  # è‡ªåŠ¨æäº¤æ¨¡å¼
            )
            # ä¼˜åŒ–é…ç½®
            conn.execute("PRAGMA journal_mode=WAL")
            conn.execute("PRAGMA synchronous=NORMAL")
            conn.execute("PRAGMA cache_size=-64000")  # 64MB
            conn.execute("PRAGMA temp_store=MEMORY")
            conn.execute("PRAGMA mmap_size=268435456")  # 256MB

            self.pool.put(conn)

    @contextmanager
    def get_connection(self, timeout=5.0):
        """è·å–è¿æ¥ï¼ˆä¸Šä¸‹æ–‡ç®¡ç†å™¨ï¼‰"""
        try:
            conn = self.pool.get(timeout=timeout)
            yield conn
        except Empty:
            raise TimeoutError("è¿æ¥æ± å·²æ»¡ï¼Œç­‰å¾…è¶…æ—¶")
        finally:
            self.pool.put(conn)

    def execute(self, sql, params=None, timeout=5.0):
        """æ‰§è¡ŒSQL"""
        with self.get_connection(timeout) as conn:
            if params:
                return conn.execute(sql, params)
            return conn.execute(sql)

    def executemany(self, sql, params_list, timeout=5.0):
        """æ‰¹é‡æ‰§è¡Œ"""
        with self.get_connection(timeout) as conn:
            return conn.executemany(sql, params_list)

    def close_all(self):
        """å…³é—­æ‰€æœ‰è¿æ¥"""
        while not self.pool.empty():
            try:
                conn = self.pool.get_nowait()
                conn.close()
            except Empty:
                break

# ä½¿ç”¨ç¤ºä¾‹
pool = SQLiteConnectionPool('app.db', pool_size=10)

# å¤šçº¿ç¨‹å®‰å…¨æŸ¥è¯¢
def worker(thread_id):
    for i in range(100):
        result = pool.execute(
            "SELECT * FROM users WHERE id = ?",
            (i,)
        ).fetchone()
        print(f"Thread {thread_id}: {result}")

# å¯åŠ¨10ä¸ªçº¿ç¨‹
threads = [threading.Thread(target=worker, args=(i,)) for i in range(10)]
for t in threads:
    t.start()
for t in threads:
    t.join()

pool.close_all()
```

---

## äºŒã€è¯»å†™åˆ†ç¦»æ¨¡å¼

```python
# è¯»å†™åˆ†ç¦»ï¼šå¤šä¸ªåªè¯»è¿æ¥+å•ä¸ªå†™è¿æ¥

class ReadWriteSplitDB:
    def __init__(self, database):
        self.database = database

        # å†™è¿æ¥ï¼ˆå•ä¸ªï¼‰
        self.write_conn = sqlite3.connect(database)
        self.write_conn.execute("PRAGMA journal_mode=WAL")
        self.write_conn.execute("PRAGMA busy_timeout=5000")

        # è¯»è¿æ¥æ± ï¼ˆå¤šä¸ªï¼‰
        self.read_pool = SQLiteConnectionPool(database, pool_size=10)

    def read(self, sql, params=None):
        """åªè¯»æŸ¥è¯¢ï¼ˆä½¿ç”¨è¯»è¿æ¥æ± ï¼‰"""
        with self.read_pool.get_connection() as conn:
            cursor = conn.execute(sql, params or ())
            return cursor.fetchall()

    def write(self, sql, params=None):
        """å†™æ“ä½œï¼ˆä½¿ç”¨å•ä¸ªå†™è¿æ¥ï¼‰"""
        # WALæ¨¡å¼ï¼šå†™ä¸é˜»å¡è¯»
        with self.write_lock:
            cursor = self.write_conn.execute(sql, params or ())
            self.write_conn.commit()
            return cursor.rowcount

    def transaction(self, operations):
        """äº‹åŠ¡æ“ä½œ"""
        with self.write_lock:
            try:
                self.write_conn.execute("BEGIN IMMEDIATE")
                for sql, params in operations:
                    self.write_conn.execute(sql, params)
                self.write_conn.commit()
                return True
            except Exception as e:
                self.write_conn.rollback()
                raise

# ä½¿ç”¨ç¤ºä¾‹
db = ReadWriteSplitDB('app.db')

# å¹¶å‘è¯»ï¼ˆä¸é˜»å¡ï¼‰
results = db.read("SELECT * FROM products WHERE category = ?", ('Electronics',))

# å†™æ“ä½œ
db.write("INSERT INTO products (name, price) VALUES (?, ?)", ('Laptop', 999))

# äº‹åŠ¡
db.transaction([
    ("UPDATE products SET stock = stock - 1 WHERE id = ?", (101,)),
    ("INSERT INTO orders (product_id, quantity) VALUES (?, ?)", (101, 1))
])
```

---

## ä¸‰ã€æ‰¹é‡æ“ä½œæ¨¡å¼

```python
# æ‰¹é‡æ“ä½œä¼˜åŒ–æ¨¡å¼

class BatchProcessor:
    def __init__(self, conn, batch_size=1000):
        self.conn = conn
        self.batch_size = batch_size
        self.buffer = []

    def add(self, item):
        """æ·»åŠ åˆ°æ‰¹æ¬¡"""
        self.buffer.append(item)
        if len(self.buffer) >= self.batch_size:
            self.flush()

    def flush(self):
        """åˆ·æ–°æ‰¹æ¬¡åˆ°æ•°æ®åº“"""
        if not self.buffer:
            return

        try:
            self.conn.execute("BEGIN")
            self.conn.executemany(
                "INSERT INTO table VALUES (?, ?, ?)",
                self.buffer
            )
            self.conn.commit()
            self.buffer = []
        except Exception as e:
            self.conn.rollback()
            raise

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if exc_type is None:
            self.flush()  # æ­£å¸¸é€€å‡ºï¼Œåˆ·æ–°å‰©ä½™æ•°æ®
        return False

# ä½¿ç”¨ç¤ºä¾‹
conn = sqlite3.connect('app.db')

with BatchProcessor(conn, batch_size=5000) as batch:
    for i in range(100000):
        batch.add((i, f'user{i}', f'user{i}@example.com'))
# è‡ªåŠ¨åˆ·æ–°

# æ€§èƒ½å¯¹æ¯”ï¼š
# é€è¡Œæ’å…¥+é€è¡Œæäº¤: 200ç§’
# æ‰¹é‡æ’å…¥ï¼ˆ5000è¡Œ/æ‰¹ï¼‰: 4ç§’ï¼ˆ50xæå‡ï¼‰
```

---

## å››ã€äº‹åŠ¡é‡è¯•æ¨¡å¼

```python
# äº‹åŠ¡é‡è¯•è£…é¥°å™¨ï¼ˆå¤„ç†SQLITE_BUSYï¼‰

import functools
import time
import random

def retry_on_busy(max_retries=5, initial_delay=0.1, backoff=2):
    """äº‹åŠ¡é‡è¯•è£…é¥°å™¨"""
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            delay = initial_delay
            last_exception = None

            for attempt in range(max_retries):
                try:
                    return func(*args, **kwargs)
                except sqlite3.OperationalError as e:
                    last_exception = e
                    if "database is locked" in str(e):
                        if attempt < max_retries - 1:
                            # æŒ‡æ•°é€€é¿+éšæœºæŠ–åŠ¨
                            jitter = random.uniform(0, delay * 0.1)
                            time.sleep(delay + jitter)
                            delay *= backoff
                            continue
                    raise

            raise last_exception
        return wrapper
    return decorator

# ä½¿ç”¨ç¤ºä¾‹
@retry_on_busy(max_retries=5)
def transfer_money(conn, from_id, to_id, amount):
    """è½¬è´¦æ“ä½œï¼ˆè‡ªåŠ¨é‡è¯•ï¼‰"""
    conn.execute("BEGIN IMMEDIATE")  # ç«‹å³è·å–å†™é”

    # æ£€æŸ¥ä½™é¢
    balance = conn.execute(
        "SELECT balance FROM accounts WHERE id = ?", (from_id,)
    ).fetchone()[0]

    if balance < amount:
        conn.rollback()
        raise ValueError("ä½™é¢ä¸è¶³")

    # æ‰§è¡Œè½¬è´¦
    conn.execute(
        "UPDATE accounts SET balance = balance - ? WHERE id = ?",
        (amount, from_id)
    )
    conn.execute(
        "UPDATE accounts SET balance = balance + ? WHERE id = ?",
        (amount, to_id)
    )

    conn.commit()
    return True

# è°ƒç”¨
conn = sqlite3.connect('bank.db')
transfer_money(conn, 101, 102, 100)  # è‡ªåŠ¨é‡è¯•SQLITE_BUSY
```

---

## äº”ã€ç¼“å­˜é¢„çƒ­æ¨¡å¼

```python
# å¯åŠ¨æ—¶é¢„çƒ­SQLiteç¼“å­˜

class SQLiteApp:
    def __init__(self, database):
        self.conn = sqlite3.connect(database)
        self.conn.execute("PRAGMA journal_mode=WAL")
        self.warm_up_cache()

    def warm_up_cache(self):
        """é¢„çƒ­ç¼“å­˜ï¼šåŠ è½½çƒ­ç‚¹æ•°æ®"""
        print("é¢„çƒ­ç¼“å­˜...")

        # 1. åŠ è½½é«˜é¢‘æŸ¥è¯¢çš„æ•°æ®åˆ°é¡µé¢ç¼“å­˜
        # ç¤ºä¾‹ï¼šæœ€è¿‘æ´»è·ƒç”¨æˆ·
        self.conn.execute("""
            SELECT * FROM users
            WHERE last_login > datetime('now', '-7 days')
            ORDER BY last_login DESC
            LIMIT 1000
        """).fetchall()

        # 2. åŠ è½½çƒ­é—¨å•†å“
        self.conn.execute("""
            SELECT * FROM products
            WHERE category IN ('Electronics', 'Books')
            ORDER BY view_count DESC
            LIMIT 5000
        """).fetchall()

        # 3. å¼ºåˆ¶åŠ è½½ç´¢å¼•åˆ°å†…å­˜
        self.conn.execute("SELECT * FROM sqlite_master").fetchall()

        # 4. æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        self.conn.execute("ANALYZE")

        print("ç¼“å­˜é¢„çƒ­å®Œæˆ")

    def get_cache_stats(self):
        """è·å–ç¼“å­˜ç»Ÿè®¡"""
        # æ³¨æ„ï¼šSQLiteæ²¡æœ‰ç›´æ¥çš„ç¼“å­˜å‘½ä¸­ç‡API
        # å¯ä»¥é€šè¿‡å‰åå¯¹æ¯”PRAGMA statsæ¥é—´æ¥æ¨ç®—

        # æŸ¥çœ‹ç¼“å­˜å¤§å°
        cache_size = self.conn.execute("PRAGMA cache_size").fetchone()[0]
        page_size = self.conn.execute("PRAGMA page_size").fetchone()[0]
        cache_mb = abs(cache_size) / 1024 if cache_size < 0 else cache_size * page_size / 1024 / 1024

        return {
            'cache_size_mb': cache_mb,
            'page_size': page_size
        }

# ä½¿ç”¨
app = SQLiteApp('app.db')
stats = app.get_cache_stats()
print(f"ç¼“å­˜å¤§å°: {stats['cache_size_mb']:.2f}MB")
```

---

## å…­ã€ç›‘æ§è¯Šæ–­æ¨¡å¼

```python
# ç»¼åˆç›‘æ§ç±»

import time
from datetime import datetime
from dataclasses import dataclass
from typing import Dict, List

@dataclass
class QueryMetrics:
    query: str
    execution_time: float
    rows_affected: int
    timestamp: datetime

class SQLiteMonitor:
    def __init__(self, conn):
        self.conn = conn
        self.metrics = []
        self.slow_query_threshold = 100  # ms

    def execute_with_monitoring(self, sql, params=None):
        """æ‰§è¡Œå¹¶ç›‘æ§SQL"""
        start = time.time()

        try:
            if params:
                cursor = self.conn.execute(sql, params)
            else:
                cursor = self.conn.execute(sql)

            rows = cursor.rowcount
            elapsed = (time.time() - start) * 1000  # ms

            # è®°å½•æŒ‡æ ‡
            metric = QueryMetrics(
                query=sql[:100],  # æˆªæ–­é•¿æŸ¥è¯¢
                execution_time=elapsed,
                rows_affected=rows,
                timestamp=datetime.now()
            )
            self.metrics.append(metric)

            # æ…¢æŸ¥è¯¢å‘Šè­¦
            if elapsed > self.slow_query_threshold:
                self.log_slow_query(metric)

            return cursor

        except Exception as e:
            self.log_error(sql, e)
            raise

    def log_slow_query(self, metric):
        """è®°å½•æ…¢æŸ¥è¯¢"""
        print(f"[SLOW QUERY] {metric.execution_time:.2f}ms: {metric.query}")

        # åˆ†ææŸ¥è¯¢è®¡åˆ’
        explain = self.conn.execute(
            f"EXPLAIN QUERY PLAN {metric.query}"
        ).fetchall()
        print("Query Plan:", explain)

    def get_statistics(self):
        """è·å–ç»Ÿè®¡ä¿¡æ¯"""
        if not self.metrics:
            return {}

        times = [m.execution_time for m in self.metrics]
        return {
            'total_queries': len(self.metrics),
            'avg_time': sum(times) / len(times),
            'max_time': max(times),
            'min_time': min(times),
            'slow_queries': sum(1 for t in times if t > self.slow_query_threshold),
            'p95_time': sorted(times)[int(len(times) * 0.95)],
            'p99_time': sorted(times)[int(len(times) * 0.99)]
        }

    def get_db_health(self):
        """æ•°æ®åº“å¥åº·æ£€æŸ¥"""
        health = {}

        # WALæ–‡ä»¶å¤§å°
        wal_checkpoint = self.conn.execute("PRAGMA wal_checkpoint").fetchone()
        health['wal_frames'] = wal_checkpoint[0] if wal_checkpoint else 0

        # æ•°æ®åº“å¤§å°
        page_count = self.conn.execute("PRAGMA page_count").fetchone()[0]
        page_size = self.conn.execute("PRAGMA page_size").fetchone()[0]
        health['db_size_mb'] = (page_count * page_size) / 1024 / 1024

        # ç©ºé—²é¡µé¢
        freelist_count = self.conn.execute("PRAGMA freelist_count").fetchone()[0]
        health['freelist_pct'] = (freelist_count / page_count * 100) if page_count > 0 else 0

        # å®Œæ•´æ€§æ£€æŸ¥
        integrity = self.conn.execute("PRAGMA quick_check").fetchone()
        health['integrity'] = integrity[0]

        # å¥åº·è¯„åˆ†
        issues = []
        if health['wal_frames'] > 10000:
            issues.append("WALæ–‡ä»¶è¿‡å¤§")
        if health['freelist_pct'] > 20:
            issues.append("ç¢ç‰‡è¿‡å¤šï¼ˆå»ºè®®VACUUMï¼‰")
        if health['integrity'] != 'ok':
            issues.append("æ•°æ®å®Œæ•´æ€§é—®é¢˜")

        health['status'] = 'healthy' if not issues else 'warning'
        health['issues'] = issues

        return health

# ä½¿ç”¨ç¤ºä¾‹
conn = sqlite3.connect('app.db')
monitor = SQLiteMonitor(conn)

# æ‰§è¡ŒæŸ¥è¯¢å¹¶ç›‘æ§
cursor = monitor.execute_with_monitoring(
    "SELECT * FROM users WHERE age > ?", (25,)
)

# è·å–ç»Ÿè®¡
stats = monitor.get_statistics()
print(f"å¹³å‡æŸ¥è¯¢æ—¶é—´: {stats['avg_time']:.2f}ms")
print(f"P95å»¶è¿Ÿ: {stats['p95_time']:.2f}ms")
print(f"æ…¢æŸ¥è¯¢æ•°: {stats['slow_queries']}")

# å¥åº·æ£€æŸ¥
health = monitor.get_db_health()
print(f"æ•°æ®åº“çŠ¶æ€: {health['status']}")
print(f"æ•°æ®åº“å¤§å°: {health['db_size_mb']:.2f}MB")
if health['issues']:
    print(f"é—®é¢˜: {', '.join(health['issues'])}")
```

---

## å®æˆ˜ç»¼åˆç¤ºä¾‹ï¼šé«˜æ€§èƒ½SQLite Webåº”ç”¨

```python
# Flask + SQLiteé«˜æ€§èƒ½é…ç½®

from flask import Flask, g
import sqlite3

app = Flask(__name__)
DATABASE = 'app.db'

# è¿æ¥æ± 
pool = SQLiteConnectionPool(DATABASE, pool_size=20)

def get_db():
    """è·å–æ•°æ®åº“è¿æ¥"""
    if 'db' not in g:
        g.db = pool.get_connection()
    return g.db

@app.teardown_appcontext
def close_db(error):
    """è¯·æ±‚ç»“æŸæ—¶å½’è¿˜è¿æ¥"""
    db = g.pop('db', None)
    if db is not None:
        # è¿æ¥æ± è‡ªåŠ¨å½’è¿˜ï¼ˆä¸Šä¸‹æ–‡ç®¡ç†å™¨ï¼‰
        pass

@app.route('/api/users/<int:user_id>')
def get_user(user_id):
    """é«˜æ€§èƒ½æŸ¥è¯¢"""
    with monitor.execute_with_monitoring:
        cursor = get_db().execute(
            "SELECT * FROM users WHERE id = ?",
            (user_id,)
        )
        user = cursor.fetchone()

        if user:
            return jsonify(dict(user))
        return jsonify({"error": "Not found"}), 404

@app.route('/api/users', methods=['POST'])
def create_user():
    """å¸¦é‡è¯•çš„å†™æ“ä½œ"""
    data = request.json

    @retry_on_busy(max_retries=3)
    def insert():
        conn = get_db()
        conn.execute("BEGIN IMMEDIATE")
        cursor = conn.execute("""
            INSERT INTO users (name, email, created_at)
            VALUES (?, ?, ?)
        """, (data['name'], data['email'], datetime.now().isoformat()))
        conn.commit()
        return cursor.lastrowid

    user_id = insert()
    return jsonify({"user_id": user_id}), 201

# å¯åŠ¨æ—¶é…ç½®
@app.before_first_request
def initialize():
    """åº”ç”¨åˆå§‹åŒ–"""
    with pool.get_connection() as conn:
        # ä¼˜åŒ–é…ç½®
        conn.execute("PRAGMA journal_mode=WAL")
        conn.execute("PRAGMA synchronous=NORMAL")
        conn.execute("PRAGMA cache_size=-64000")
        conn.execute("PRAGMA temp_store=MEMORY")

        # é¢„çƒ­ç¼“å­˜
        conn.execute("SELECT * FROM users LIMIT 1000").fetchall()

        # æ›´æ–°ç»Ÿè®¡
        conn.execute("ANALYZE")

    print("SQLiteåˆå§‹åŒ–å®Œæˆ")

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, threaded=True)
```

---

**é«˜çº§ç¼–ç¨‹æ¨¡å¼å®Œæˆï¼**

æœ¬æ–‡æ¡£æä¾›ï¼š
- âœ… çº¿ç¨‹å®‰å…¨è¿æ¥æ± ï¼ˆå®Œæ•´å®ç°ï¼‰
- âœ… è¯»å†™åˆ†ç¦»æ¨¡å¼ï¼ˆWALæ¨¡å¼ä¼˜åŠ¿ï¼‰
- âœ… æ‰¹é‡æ“ä½œæ¨¡å¼ï¼ˆ50xæ€§èƒ½æå‡ï¼‰
- âœ… äº‹åŠ¡é‡è¯•æ¨¡å¼ï¼ˆå¤„ç†SQLITE_BUSYï¼‰
- âœ… ç¼“å­˜é¢„çƒ­æ¨¡å¼ï¼ˆå‡å°‘å†·å¯åŠ¨æ—¶é—´ï¼‰
- âœ… ç›‘æ§è¯Šæ–­æ¨¡å¼ï¼ˆæ€§èƒ½æŒ‡æ ‡+å¥åº·æ£€æŸ¥ï¼‰
- âœ… Flask Webåº”ç”¨å®Œæ•´ç¤ºä¾‹

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0
**æœ€åæ›´æ–°**: 2025-12-04
**ç»´æŠ¤è€…**: SQLite Knowledge Base Team
