# SQLite Rustä½¿ç”¨æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**ï¼š2025-11-13
> **æœ€åæ›´æ–°**ï¼š2025-01-15
> **ç‰ˆæœ¬**ï¼šRust 1.56+ï¼ŒSQLite 3.31+ è‡³ 3.47.x
> **é€‚ç”¨åº“**ï¼šrusqliteã€sqlxã€libsqlite3-sys

---

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›SQLiteåœ¨Rustè¯­è¨€ä¸­çš„å®Œæ•´ä½¿ç”¨æŒ‡å—ï¼ŒåŒ…æ‹¬åŒæ­¥åº“rusqliteã€å¼‚æ­¥åº“sqlxå’Œåº•å±‚ç»‘å®šlibsqlite3-sysçš„ä½¿ç”¨æ–¹æ³•ã€‚

---

## ğŸ“‘ ç›®å½•

- [SQLite Rustä½¿ç”¨æŒ‡å—](#sqlite-rustä½¿ç”¨æŒ‡å—)
  - [ğŸ“‹ æ¦‚è¿°](#-æ¦‚è¿°)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [ğŸ“Š æ€ç»´å¯¼å›¾](#-æ€ç»´å¯¼å›¾)
  - [ä¸€ã€rusqliteï¼ˆæ¨èï¼‰](#ä¸€rusqliteæ¨è)
    - [1.1 å®‰è£…å’ŒåŸºæœ¬ä½¿ç”¨](#11-å®‰è£…å’ŒåŸºæœ¬ä½¿ç”¨)
    - [1.2 åŸºæœ¬æ“ä½œ](#12-åŸºæœ¬æ“ä½œ)
    - [1.3 äº‹åŠ¡ç®¡ç†](#13-äº‹åŠ¡ç®¡ç†)
    - [1.4 é¢„ç¼–è¯‘è¯­å¥](#14-é¢„ç¼–è¯‘è¯­å¥)
    - [1.5 ç±»å‹æ˜ å°„](#15-ç±»å‹æ˜ å°„)
  - [äºŒã€sqlxï¼ˆå¼‚æ­¥ï¼‰](#äºŒsqlxå¼‚æ­¥)
    - [2.1 å®‰è£…å’Œä½¿ç”¨](#21-å®‰è£…å’Œä½¿ç”¨)
    - [2.2 å¼‚æ­¥æ“ä½œ](#22-å¼‚æ­¥æ“ä½œ)
    - [2.3 ç¼–è¯‘æ—¶SQLæ£€æŸ¥](#23-ç¼–è¯‘æ—¶sqlæ£€æŸ¥)
  - [ä¸‰ã€é«˜çº§ç‰¹æ€§](#ä¸‰é«˜çº§ç‰¹æ€§)
    - [3.1 è‡ªå®šä¹‰å‡½æ•°](#31-è‡ªå®šä¹‰å‡½æ•°)
    - [3.2 è‡ªå®šä¹‰èšåˆå‡½æ•°](#32-è‡ªå®šä¹‰èšåˆå‡½æ•°)
    - [3.3 è¿æ¥é’©å­](#33-è¿æ¥é’©å­)
  - [å››ã€ORMæ¡†æ¶](#å››ormæ¡†æ¶)
    - [4.1 Diesel](#41-diesel)
    - [4.2 Sea-ORM](#42-sea-orm)
  - [äº”ã€Ruståº“å¤šç»´å¯¹æ¯”çŸ©é˜µ](#äº”ruståº“å¤šç»´å¯¹æ¯”çŸ©é˜µ)
    - [5.1 Rust SQLiteåº“å¯¹æ¯”çŸ©é˜µ](#51-rust-sqliteåº“å¯¹æ¯”çŸ©é˜µ)
    - [5.2 Rustä½¿ç”¨æ–¹å¼å¯¹æ¯”çŸ©é˜µ](#52-rustä½¿ç”¨æ–¹å¼å¯¹æ¯”çŸ©é˜µ)
    - [5.3 Rustæœ€ä½³å®è·µå¯¹æ¯”çŸ©é˜µ](#53-rustæœ€ä½³å®è·µå¯¹æ¯”çŸ©é˜µ)
  - [å…­ã€æœ€ä½³å®è·µ](#å…­æœ€ä½³å®è·µ)
    - [6.1 é”™è¯¯å¤„ç†](#61-é”™è¯¯å¤„ç†)
    - [6.2 æ€§èƒ½ä¼˜åŒ–](#62-æ€§èƒ½ä¼˜åŒ–)
    - [6.3 çº¿ç¨‹å®‰å…¨](#63-çº¿ç¨‹å®‰å…¨)
  - [ğŸ”— ç›¸å…³èµ„æº](#-ç›¸å…³èµ„æº)
  - [ğŸ”— äº¤å‰å¼•ç”¨](#-äº¤å‰å¼•ç”¨)
    - [ç†è®ºæ¨¡å‹ ğŸ†•](#ç†è®ºæ¨¡å‹-)
    - [è®¾è®¡æ¨¡å‹ ğŸ†•](#è®¾è®¡æ¨¡å‹-)
  - [ğŸ“š å‚è€ƒèµ„æ–™](#-å‚è€ƒèµ„æ–™)

---

## ğŸ“Š æ€ç»´å¯¼å›¾

```mermaid
mindmap
  root((Rustä½¿ç”¨æŒ‡å—))
    rusqliteæ¨è
      å®‰è£…å’ŒåŸºæœ¬ä½¿ç”¨
        Cargo.tomlä¾èµ–
        Connection::open
        åŸºæœ¬è¿æ¥
      åŸºæœ¬æ“ä½œ
        CREATE TABLE
        INSERT UPDATE DELETE
        SELECTæŸ¥è¯¢
        Rowæ‰«æ
      äº‹åŠ¡ç®¡ç†
        transactionæ–¹æ³•
        è‡ªåŠ¨æäº¤
        é”™è¯¯å¤„ç†
      é¢„ç¼–è¯‘è¯­å¥
        prepareæ–¹æ³•
        å‚æ•°ç»‘å®š
        ç±»å‹å®‰å…¨
      ç±»å‹æ˜ å°„
        FromSql trait
        ToSql trait
        ç±»å‹è½¬æ¢
    sqlxå¼‚æ­¥
      å®‰è£…å’Œä½¿ç”¨
        async/await
        å¼‚æ­¥è¿æ¥
        å¼‚æ­¥æ“ä½œ
      å¼‚æ­¥æ“ä½œ
        queryæ–¹æ³•
        å¼‚æ­¥æŸ¥è¯¢
        å¼‚æ­¥äº‹åŠ¡
      ç¼–è¯‘æ—¶SQLæ£€æŸ¥
        sqlx::queryå®
        ç¼–è¯‘æ—¶éªŒè¯
        ç±»å‹å®‰å…¨
    é«˜çº§ç‰¹æ€§
      è‡ªå®šä¹‰å‡½æ•°
        create_function
        Rustå‡½æ•°æ³¨å†Œ
        ç±»å‹è½¬æ¢
      è‡ªå®šä¹‰èšåˆå‡½æ•°
        create_aggregate
        èšåˆé€»è¾‘
        çŠ¶æ€ç®¡ç†
      è¿æ¥é’©å­
        è¿æ¥äº‹ä»¶
        é’©å­å‡½æ•°
        ç›‘æ§ç»Ÿè®¡
    ORMæ¡†æ¶
      Diesel
        ç±»å‹å®‰å…¨
        æŸ¥è¯¢æ„å»ºå™¨
        è¿ç§»å·¥å…·
      Sea-ORM
        ç°ä»£ORM
        å¼‚æ­¥æ”¯æŒ
        å…³ç³»æ˜ å°„
    æœ€ä½³å®è·µ
      é”™è¯¯å¤„ç†
        Resultç±»å‹
        é”™è¯¯è½¬æ¢
        é”™è¯¯æ¢å¤
      æ€§èƒ½ä¼˜åŒ–
        æ‰¹é‡æ“ä½œ
        ç´¢å¼•ä¼˜åŒ–
        æŸ¥è¯¢ä¼˜åŒ–
      çº¿ç¨‹å®‰å…¨
        è¿æ¥å…±äº«
        é”æœºåˆ¶
        å¹¶å‘æ§åˆ¶
```

---

## ä¸€ã€rusqliteï¼ˆæ¨èï¼‰

`rusqlite`æ˜¯Rustæœ€æµè¡Œçš„SQLiteç»‘å®šåº“ï¼Œæä¾›ç±»å‹å®‰å…¨çš„APIã€‚

### 1.1 å®‰è£…å’ŒåŸºæœ¬ä½¿ç”¨

**å®‰è£…**ï¼š

åœ¨`Cargo.toml`ä¸­æ·»åŠ ä¾èµ–ï¼š

```toml
[dependencies]
rusqlite = { version = "0.29", features = ["bundled"] }
```

**åŸºæœ¬ä½¿ç”¨**ï¼š

```rust
use rusqlite::{Connection, Result};

fn main() -> Result<()> {
    // è¿æ¥åˆ°æ•°æ®åº“ï¼ˆä¸å­˜åœ¨åˆ™åˆ›å»ºï¼‰
    let conn = Connection::open("example.db")?;

    // åˆ›å»ºè¡¨
    conn.execute(
        "CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            email TEXT UNIQUE,
            age INTEGER,
            created_at TEXT DEFAULT (datetime('now'))
        )",
        [],
    )?;

    Ok(())
}
```

### 1.2 åŸºæœ¬æ“ä½œ

**æ’å…¥æ•°æ®**ï¼š

```rust
use rusqlite::{Connection, Result, params};

fn main() -> Result<()> {
    let conn = Connection::open("example.db")?;

    // æ’å…¥å•æ¡æ•°æ®
    conn.execute(
        "INSERT INTO users (name, email, age) VALUES (?1, ?2, ?3)",
        params!["Alice", "alice@example.com", 25],
    )?;

    // è·å–æœ€åæ’å…¥çš„ID
    let last_id = conn.last_insert_rowid();
    println!("æ’å…¥æˆåŠŸï¼ŒID: {}", last_id);

    // æ’å…¥å¤šæ¡æ•°æ®
    let mut stmt = conn.prepare(
        "INSERT INTO users (name, email, age) VALUES (?1, ?2, ?3)"
    )?;

    let users = vec![
        ("Bob", "bob@example.com", 30),
        ("Charlie", "charlie@example.com", 35),
    ];

    for user in users {
        stmt.execute(params![user.0, user.1, user.2])?;
    }

    Ok(())
}
```

**æŸ¥è¯¢æ•°æ®**ï¼š

```rust
use rusqlite::{Connection, Result, params};

#[derive(Debug)]
struct User {
    id: i64,
    name: String,
    email: String,
    age: Option<i32>,
    created_at: String,
}

fn main() -> Result<()> {
    let conn = Connection::open("example.db")?;

    // æŸ¥è¯¢å•æ¡è®°å½•
    let mut stmt = conn.prepare("SELECT id, name, email, age, created_at FROM users WHERE id = ?1")?;
    let user = stmt.query_row(params![1], |row| {
        Ok(User {
            id: row.get(0)?,
            name: row.get(1)?,
            email: row.get(2)?,
            age: row.get(3)?,
            created_at: row.get(4)?,
        })
    })?;

    println!("ç”¨æˆ·: {:?}", user);

    // æŸ¥è¯¢å¤šæ¡è®°å½•
    let mut stmt = conn.prepare("SELECT id, name, email, age, created_at FROM users WHERE age > ?1")?;
    let users = stmt.query_map(params![25], |row| {
        Ok(User {
            id: row.get(0)?,
            name: row.get(1)?,
            email: row.get(2)?,
            age: row.get(3)?,
            created_at: row.get(4)?,
        })
    })?;

    for user in users {
        println!("ç”¨æˆ·: {:?}", user?);
    }

    Ok(())
}
```

**æ›´æ–°å’Œåˆ é™¤**ï¼š

```rust
use rusqlite::{Connection, Result, params};

fn main() -> Result<()> {
    let conn = Connection::open("example.db")?;

    // æ›´æ–°æ•°æ®
    let rows_affected = conn.execute(
        "UPDATE users SET age = ?1 WHERE id = ?2",
        params![26, 1],
    )?;
    println!("æ›´æ–°äº† {} è¡Œ", rows_affected);

    // åˆ é™¤æ•°æ®
    let rows_affected = conn.execute(
        "DELETE FROM users WHERE id = ?1",
        params![2],
    )?;
    println!("åˆ é™¤äº† {} è¡Œ", rows_affected);

    Ok(())
}
```

### 1.3 äº‹åŠ¡ç®¡ç†

**ä½¿ç”¨äº‹åŠ¡**ï¼š

```rust
use rusqlite::{Connection, Result, params};

fn main() -> Result<()> {
    let conn = Connection::open("example.db")?;

    // å¼€å§‹äº‹åŠ¡
    let tx = conn.transaction()?;

    // æ‰§è¡Œå¤šä¸ªæ“ä½œ
    tx.execute(
        "INSERT INTO users (name, email) VALUES (?1, ?2)",
        params!["David", "david@example.com"],
    )?;

    tx.execute(
        "UPDATE users SET age = ?1 WHERE id = ?2",
        params![26, 1],
    )?;

    // æäº¤äº‹åŠ¡
    tx.commit()?;

    println!("äº‹åŠ¡æäº¤æˆåŠŸ");
    Ok(())
}
```

**åµŒå¥—äº‹åŠ¡ï¼ˆSAVEPOINTï¼‰**ï¼š

```rust
use rusqlite::{Connection, Result, params};

fn main() -> Result<()> {
    let conn = Connection::open("example.db")?;

    let tx = conn.transaction()?;

    tx.execute(
        "INSERT INTO users (name, email) VALUES (?1, ?2)",
        params!["Eve", "eve@example.com"],
    )?;

    // åµŒå¥—äº‹åŠ¡
    let savepoint = tx.savepoint()?;
    match savepoint.execute(
        "INSERT INTO users (name, email) VALUES (?1, ?2)",
        params!["Frank", "frank@example.com"],
    ) {
        Ok(_) => savepoint.commit()?,
        Err(e) => {
            savepoint.rollback()?;
            println!("å›æ»šåµŒå¥—äº‹åŠ¡: {}", e);
        }
    }

    tx.commit()?;
    Ok(())
}
```

### 1.4 é¢„ç¼–è¯‘è¯­å¥

**ä½¿ç”¨é¢„ç¼–è¯‘è¯­å¥**ï¼š

```rust
use rusqlite::{Connection, Result, params};

fn main() -> Result<()> {
    let conn = Connection::open("example.db")?;

    // é¢„ç¼–è¯‘è¯­å¥å¯ä»¥é‡å¤ä½¿ç”¨
    let mut stmt = conn.prepare("SELECT id, name, email FROM users WHERE id = ?1")?;

    // å¤šæ¬¡ä½¿ç”¨
    let user1 = stmt.query_row(params![1], |row| {
        Ok((row.get::<_, i64>(0)?, row.get::<_, String>(1)?, row.get::<_, String>(2)?))
    })?;
    println!("ç”¨æˆ·1: {:?}", user1);

    let user2 = stmt.query_row(params![2], |row| {
        Ok((row.get::<_, i64>(0)?, row.get::<_, String>(1)?, row.get::<_, String>(2)?))
    })?;
    println!("ç”¨æˆ·2: {:?}", user2);

    Ok(())
}
```

### 1.5 ç±»å‹æ˜ å°„

**Rustç±»å‹ä¸SQLiteç±»å‹æ˜ å°„**ï¼š

```rust
use rusqlite::{Connection, Result, params, types::ToSql};

fn main() -> Result<()> {
    let conn = Connection::open("example.db")?;

    // SQLiteç±»å‹æ˜ å°„
    // INTEGER -> i32, i64
    // TEXT -> String, &str
    // REAL -> f64
    // BLOB -> Vec<u8>
    // NULL -> Option<T>

    // ä½¿ç”¨Optionå¤„ç†NULLå€¼
    let mut stmt = conn.prepare("INSERT INTO users (name, email, age) VALUES (?1, ?2, ?3)")?;
    stmt.execute(params!["Alice", "alice@example.com", Some(25)])?;
    stmt.execute(params!["Bob", None::<String>, None::<i32>])?;

    // æŸ¥è¯¢æ—¶å¤„ç†NULL
    let mut stmt = conn.prepare("SELECT name, age FROM users")?;
    let users = stmt.query_map([], |row| {
        Ok((
            row.get::<_, String>(0)?,
            row.get::<_, Option<i32>>(1)?,
        ))
    })?;

    for user in users {
        let (name, age) = user?;
        match age {
            Some(age) => println!("{}: {}å²", name, age),
            None => println!("{}: å¹´é¾„æœªçŸ¥", name),
        }
    }

    Ok(())
}
```

---

## äºŒã€sqlxï¼ˆå¼‚æ­¥ï¼‰

`sqlx`æä¾›å¼‚æ­¥SQLiteæ”¯æŒï¼Œå¹¶æ”¯æŒç¼–è¯‘æ—¶SQLæ£€æŸ¥ã€‚

### 2.1 å®‰è£…å’Œä½¿ç”¨

**å®‰è£…**ï¼š

```toml
[dependencies]
sqlx = { version = "0.7", features = ["runtime-tokio-native-tls", "sqlite"] }
tokio = { version = "1", features = ["full"] }
```

**åŸºæœ¬ä½¿ç”¨**ï¼š

```rust
use sqlx::{sqlite::SqlitePool, Row};

#[tokio::main]
async fn main() -> Result<(), sqlx::Error> {
    // åˆ›å»ºè¿æ¥æ± 
    let pool = SqlitePool::connect("sqlite:example.db").await?;

    // åˆ›å»ºè¡¨
    sqlx::query(
        "CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            email TEXT UNIQUE,
            age INTEGER
        )"
    )
    .execute(&pool)
    .await?;

    // æ’å…¥æ•°æ®
    sqlx::query("INSERT INTO users (name, email, age) VALUES (?1, ?2, ?3)")
        .bind("Alice")
        .bind("alice@example.com")
        .bind(25)
        .execute(&pool)
        .await?;

    // æŸ¥è¯¢æ•°æ®
    let rows = sqlx::query("SELECT id, name, email, age FROM users")
        .fetch_all(&pool)
        .await?;

    for row in rows {
        let id: i64 = row.get(0);
        let name: String = row.get(1);
        let email: String = row.get(2);
        let age: Option<i32> = row.get(3);
        println!("ID: {}, Name: {}, Email: {}, Age: {:?}", id, name, email, age);
    }

    pool.close().await;
    Ok(())
}
```

### 2.2 å¼‚æ­¥æ“ä½œ

**å¼‚æ­¥CRUDæ“ä½œ**ï¼š

```rust
use sqlx::{sqlite::SqlitePool, Row};

#[tokio::main]
async fn main() -> Result<(), sqlx::Error> {
    let pool = SqlitePool::connect("sqlite:example.db").await?;

    // æ’å…¥
    let result = sqlx::query("INSERT INTO users (name, email, age) VALUES (?1, ?2, ?3)")
        .bind("Bob")
        .bind("bob@example.com")
        .bind(30)
        .execute(&pool)
        .await?;

    println!("æ’å…¥æˆåŠŸï¼ŒID: {}", result.last_insert_rowid());

    // æŸ¥è¯¢å•æ¡
    let row = sqlx::query("SELECT * FROM users WHERE id = ?1")
        .bind(1)
        .fetch_one(&pool)
        .await?;

    let name: String = row.get("name");
    println!("ç”¨æˆ·: {}", name);

    // æ›´æ–°
    sqlx::query("UPDATE users SET age = ?1 WHERE id = ?2")
        .bind(26)
        .bind(1)
        .execute(&pool)
        .await?;

    // åˆ é™¤
    sqlx::query("DELETE FROM users WHERE id = ?1")
        .bind(2)
        .execute(&pool)
        .await?;

    pool.close().await;
    Ok(())
}
```

### 2.3 ç¼–è¯‘æ—¶SQLæ£€æŸ¥

**ä½¿ç”¨å®è¿›è¡Œç¼–è¯‘æ—¶SQLæ£€æŸ¥**ï¼š

```rust
use sqlx::{sqlite::SqlitePool, FromRow};

#[derive(FromRow, Debug)]
struct User {
    id: i64,
    name: String,
    email: String,
    age: Option<i32>,
}

#[tokio::main]
async fn main() -> Result<(), sqlx::Error> {
    let pool = SqlitePool::connect("sqlite:example.db").await?;

    // ç¼–è¯‘æ—¶æ£€æŸ¥SQLè¯­æ³•
    let users = sqlx::query_as::<_, User>(
        "SELECT id, name, email, age FROM users WHERE age > ?1"
    )
    .bind(25)
    .fetch_all(&pool)
    .await?;

    for user in users {
        println!("ç”¨æˆ·: {:?}", user);
    }

    pool.close().await;
    Ok(())
}
```

---

## ä¸‰ã€é«˜çº§ç‰¹æ€§

### 3.1 è‡ªå®šä¹‰å‡½æ•°

**æ³¨å†ŒRustå‡½æ•°ä¸ºSQLiteå‡½æ•°**ï¼š

```rust
use rusqlite::{Connection, Result, functions::Function};

fn main() -> Result<()> {
    let conn = Connection::open("example.db")?;

    // æ³¨å†Œè‡ªå®šä¹‰å‡½æ•°
    conn.create_scalar_function(
        "upper_case",
        1,
        rusqlite::functions::FunctionFlags::SQLITE_UTF8,
        |ctx| {
            let value = ctx.get::<String>(0)?;
            Ok(value.to_uppercase())
        },
    )?;

    // ä½¿ç”¨è‡ªå®šä¹‰å‡½æ•°
    let result: String = conn.query_row(
        "SELECT upper_case(name) FROM users WHERE id = ?1",
        rusqlite::params![1],
        |row| row.get(0),
    )?;

    println!("ç»“æœ: {}", result);
    Ok(())
}
```

### 3.2 è‡ªå®šä¹‰èšåˆå‡½æ•°

**åˆ›å»ºè‡ªå®šä¹‰èšåˆå‡½æ•°**ï¼š

```rust
use rusqlite::{Connection, Result, functions::Aggregate};

struct Median {
    values: Vec<f64>,
}

impl Aggregate for Median {
    fn init() -> Self {
        Median { values: Vec::new() }
    }

    fn step(&mut self, ctx: &rusqlite::functions::Context) -> Result<()> {
        if let Ok(value) = ctx.get::<f64>(0) {
            self.values.push(value);
        }
        Ok(())
    }

    fn finalize(&mut self, ctx: &rusqlite::functions::Context) -> Result<()> {
        if self.values.is_empty() {
            ctx.set_result(None::<f64>);
            return Ok(());
        }

        self.values.sort_by(|a, b| a.partial_cmp(b).unwrap());
        let median = if self.values.len() % 2 == 0 {
            let mid = self.values.len() / 2;
            (self.values[mid - 1] + self.values[mid]) / 2.0
        } else {
            self.values[self.values.len() / 2]
        };

        ctx.set_result(median);
        Ok(())
    }
}

fn main() -> Result<()> {
    let conn = Connection::open("example.db")?;

    conn.create_aggregate_function(
        "median",
        1,
        rusqlite::functions::FunctionFlags::SQLITE_UTF8,
        Median::init,
        |agg, ctx| agg.step(ctx),
        |agg, ctx| agg.finalize(ctx),
    )?;

    let result: Option<f64> = conn.query_row(
        "SELECT median(age) FROM users",
        [],
        |row| row.get(0),
    )?;

    println!("å¹´é¾„ä¸­ä½æ•°: {:?}", result);
    Ok(())
}
```

### 3.3 è¿æ¥é’©å­

**ä½¿ç”¨è¿æ¥é’©å­**ï¼š

```rust
use rusqlite::{Connection, Result, hooks::Action};

fn main() -> Result<()> {
    let conn = Connection::open("example.db")?;

    // æ³¨å†Œæ›´æ–°é’©å­
    conn.update_hook(Some(|action, db_name, table_name, row_id| {
        match action {
            Action::SQLITE_INSERT => {
                println!("æ’å…¥: {} -> {} (row_id: {})", db_name, table_name, row_id);
            }
            Action::SQLITE_UPDATE => {
                println!("æ›´æ–°: {} -> {} (row_id: {})", db_name, table_name, row_id);
            }
            Action::SQLITE_DELETE => {
                println!("åˆ é™¤: {} -> {} (row_id: {})", db_name, table_name, row_id);
            }
        }
    }));

    conn.execute("INSERT INTO users (name, email) VALUES (?1, ?2)", rusqlite::params!["Alice", "alice@example.com"])?;

    Ok(())
}
```

---

## å››ã€ORMæ¡†æ¶

### 4.1 Diesel

**ä½¿ç”¨Diesel ORM**ï¼š

```toml
[dependencies]
diesel = { version = "2.1", features = ["sqlite"] }
diesel_migrations = "2.1"
```

```rust
use diesel::prelude::*;
use diesel::sqlite::SqliteConnection;

#[derive(Queryable, Insertable, Debug)]
#[diesel(table_name = users)]
struct User {
    id: Option<i32>,
    name: String,
    email: String,
    age: Option<i32>,
}

diesel::table! {
    users {
        id -> Nullable<Integer>,
        name -> Text,
        email -> Text,
        age -> Nullable<Integer>,
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut conn = SqliteConnection::establish("example.db")?;

    // æ’å…¥
    let new_user = User {
        id: None,
        name: "Alice".to_string(),
        email: "alice@example.com".to_string(),
        age: Some(25),
    };

    diesel::insert_into(users::table)
        .values(&new_user)
        .execute(&mut conn)?;

    // æŸ¥è¯¢
    let results = users::table
        .filter(users::age.gt(20))
        .load::<User>(&mut conn)?;

    for user in results {
        println!("ç”¨æˆ·: {:?}", user);
    }

    Ok(())
}
```

### 4.2 Sea-ORM

**ä½¿ç”¨Sea-ORM**ï¼š

```rust
use sea_orm::{Database, EntityTrait, DbErr};

#[derive(Clone, Debug, PartialEq, DeriveEntityModel)]
#[sea_orm(table_name = "users")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    pub name: String,
    pub email: String,
    pub age: Option<i32>,
}

#[tokio::main]
async fn main() -> Result<(), DbErr> {
    let db = Database::connect("sqlite://example.db").await?;

    // æŸ¥è¯¢æ‰€æœ‰ç”¨æˆ·
    let users = Entity::find().all(&db).await?;

    for user in users {
        println!("ç”¨æˆ·: {:?}", user);
    }

    Ok(())
}
```

---

## äº”ã€Ruståº“å¤šç»´å¯¹æ¯”çŸ©é˜µ

### 5.1 Rust SQLiteåº“å¯¹æ¯”çŸ©é˜µ

| ç»´åº¦ | rusqlite | sqlx | Diesel | Sea-ORM |
|------|---------|-----|--------|---------|
| **ç±»å‹** | åŒæ­¥åº“ | å¼‚æ­¥åº“ | ORMæ¡†æ¶ | ç°ä»£ORM |
| **å¼‚æ­¥æ”¯æŒ** | âŒ | âœ… | âŒ | âœ… |
| **æ€§èƒ½** | â­â­â­â­â­ | â­â­â­â­ | â­â­â­â­ | â­â­â­â­ |
| **æ˜“ç”¨æ€§** | â­â­â­â­â­ | â­â­â­â­ | â­â­â­ | â­â­â­â­â­ |
| **ç±»å‹å®‰å…¨** | â­â­â­â­â­ | â­â­â­â­â­ | â­â­â­â­â­ | â­â­â­â­â­ |
| **ç¼–è¯‘æ—¶æ£€æŸ¥** | â­â­â­â­ | â­â­â­â­â­ | â­â­â­â­â­ | â­â­â­â­ |
| **å­¦ä¹ æ›²çº¿** | â­â­â­â­â­ | â­â­â­ | â­â­â­ | â­â­â­â­ |
| **é€‚ç”¨åœºæ™¯** | æ ‡å‡†åº”ç”¨ï¼ˆæ¨èï¼‰ | å¼‚æ­¥åº”ç”¨ | ç±»å‹å®‰å…¨ORM | ç°ä»£å¼‚æ­¥ORM |
| **æ–‡æ¡£è´¨é‡** | â­â­â­â­â­ | â­â­â­â­â­ | â­â­â­â­ | â­â­â­â­ |
| **ç¤¾åŒºæ”¯æŒ** | â­â­â­â­ | â­â­â­â­â­ | â­â­â­â­â­ | â­â­â­â­ |

### 5.2 Rustä½¿ç”¨æ–¹å¼å¯¹æ¯”çŸ©é˜µ

| ç»´åº¦ | åŸç”ŸSQLï¼ˆrusqliteï¼‰ | å¼‚æ­¥SQLï¼ˆsqlxï¼‰ | ORMï¼ˆDiesel/Sea-ORMï¼‰ |
|------|-------------------|----------------|---------------------|
| **æ€§èƒ½** | â­â­â­â­â­ | â­â­â­â­ | â­â­â­ |
| **çµæ´»æ€§** | â­â­â­â­â­ | â­â­â­â­ | â­â­â­ |
| **å¼€å‘æ•ˆç‡** | â­â­â­ | â­â­â­â­ | â­â­â­â­â­ |
| **ç±»å‹å®‰å…¨** | â­â­â­â­ | â­â­â­â­â­ | â­â­â­â­â­ |
| **å­¦ä¹ æ›²çº¿** | â­â­â­â­ | â­â­â­ | â­â­â­ |
| **é€‚ç”¨åœºæ™¯** | ç®€å•æŸ¥è¯¢ã€æ€§èƒ½è¦æ±‚é«˜ | å¼‚æ­¥åº”ç”¨ | å¤æ‚åº”ç”¨ã€å¿«é€Ÿå¼€å‘ |
| **ä»£ç å¯è¯»æ€§** | â­â­â­ | â­â­â­â­ | â­â­â­â­â­ |
| **ç»´æŠ¤æˆæœ¬** | â­â­â­ | â­â­â­â­ | â­â­â­â­ |

### 5.3 Rustæœ€ä½³å®è·µå¯¹æ¯”çŸ©é˜µ

| å®è·µé¡¹ | æ¨èåšæ³• | ä¸æ¨èåšæ³• | æ€§èƒ½å½±å“ |
|--------|---------|-----------|---------|
| **è¿æ¥ç®¡ç†** | ä½¿ç”¨Connection | é¢‘ç¹åˆ›å»ºè¿æ¥ | â­â­â­â­â­ |
| **äº‹åŠ¡ç®¡ç†** | ä½¿ç”¨transaction | é€æ¡æ“ä½œ | â­â­â­â­â­ |
| **é¢„ç¼–è¯‘è¯­å¥** | ä½¿ç”¨prepare | ç›´æ¥execute | â­â­â­â­ |
| **é”™è¯¯å¤„ç†** | ä½¿ç”¨Resultç±»å‹ | ä½¿ç”¨unwrap | â­â­â­ |
| **ç±»å‹æ˜ å°„** | ä½¿ç”¨FromSql/ToSql | æ‰‹åŠ¨è½¬æ¢ | â­â­â­ |
| **WALæ¨¡å¼** | å¯ç”¨WALæ¨¡å¼ | ä½¿ç”¨DELETEæ¨¡å¼ | â­â­â­â­ |

## å…­ã€æœ€ä½³å®è·µ

### 6.1 é”™è¯¯å¤„ç†

**å®Œå–„çš„é”™è¯¯å¤„ç†**ï¼š

```rust
use rusqlite::{Connection, Result};

fn safe_query(conn: &Connection, id: i64) -> Result<Option<String>> {
    match conn.query_row(
        "SELECT name FROM users WHERE id = ?1",
        rusqlite::params![id],
        |row| row.get(0),
    ) {
        Ok(name) => Ok(Some(name)),
        Err(rusqlite::Error::QueryReturnedNoRows) => Ok(None),
        Err(e) => Err(e),
    }
}

fn main() -> Result<()> {
    let conn = Connection::open("example.db")?;

    match safe_query(&conn, 1)? {
        Some(name) => println!("æ‰¾åˆ°ç”¨æˆ·: {}", name),
        None => println!("æœªæ‰¾åˆ°ç”¨æˆ·"),
    }

    Ok(())
}
```

### 6.2 æ€§èƒ½ä¼˜åŒ–

**æ€§èƒ½ä¼˜åŒ–å»ºè®®**ï¼š

```rust
use rusqlite::{Connection, Result};

fn main() -> Result<()> {
    let conn = Connection::open("example.db")?;

    // 1. å¯ç”¨WALæ¨¡å¼
    conn.execute("PRAGMA journal_mode=WAL", [])?;
    conn.execute("PRAGMA synchronous=NORMAL", [])?;
    conn.execute("PRAGMA cache_size=-16000", [])?;

    // 2. ä½¿ç”¨é¢„ç¼–è¯‘è¯­å¥
    let mut stmt = conn.prepare("INSERT INTO users (name, email) VALUES (?1, ?2)")?;

    // 3. æ‰¹é‡æ“ä½œä½¿ç”¨äº‹åŠ¡
    let tx = conn.transaction()?;
    for i in 0..1000 {
        tx.execute(
            "INSERT INTO users (name, email) VALUES (?1, ?2)",
            rusqlite::params![format!("User{}", i), format!("user{}@example.com", i)],
        )?;
    }
    tx.commit()?;

    Ok(())
}
```

### 6.3 çº¿ç¨‹å®‰å…¨

**å¤šçº¿ç¨‹ä½¿ç”¨**ï¼š

```rust
use rusqlite::{Connection, Result};
use std::sync::{Arc, Mutex};

fn main() -> Result<()> {
    // æ¯ä¸ªçº¿ç¨‹ä½¿ç”¨ç‹¬ç«‹è¿æ¥
    let conn = Connection::open("example.db")?;

    // æˆ–è€…ä½¿ç”¨Arc<Mutex<Connection>>å…±äº«è¿æ¥
    let shared_conn = Arc::new(Mutex::new(conn));

    let handles: Vec<_> = (0..5)
        .map(|i| {
            let conn = shared_conn.clone();
            std::thread::spawn(move || {
                let conn = conn.lock().unwrap();
                conn.execute(
                    "INSERT INTO users (name, email) VALUES (?1, ?2)",
                    rusqlite::params![format!("User{}", i), format!("user{}@example.com", i)],
                )
            })
        })
        .collect();

    for handle in handles {
        handle.join().unwrap()?;
    }

    Ok(())
}
```

---

## ğŸ”— ç›¸å…³èµ„æº

- [08.01 è¿æ¥ç®¡ç†](./08.01-è¿æ¥ç®¡ç†.md) - è¿æ¥ç®¡ç†æœ€ä½³å®è·µ
- [08.02 äº‹åŠ¡ç®¡ç†](./08.02-äº‹åŠ¡ç®¡ç†.md) - äº‹åŠ¡ç®¡ç†è¯¦è§£
- [08.03 æŸ¥è¯¢ä¼˜åŒ–](./08.03-æŸ¥è¯¢ä¼˜åŒ–.md) - æŸ¥è¯¢ä¼˜åŒ–æŠ€å·§
- [08.06 Pythonä½¿ç”¨æŒ‡å—](./08.06-Pythonä½¿ç”¨æŒ‡å—.md) - å…¶ä»–è¯­è¨€ä½¿ç”¨æŒ‡å—
- [08.08 Goä½¿ç”¨æŒ‡å—](./08.08-Goä½¿ç”¨æŒ‡å—.md) - å…¶ä»–è¯­è¨€ä½¿ç”¨æŒ‡å—
- [rusqliteæ–‡æ¡£](https://docs.rs/rusqlite/)
- [sqlxæ–‡æ¡£](https://docs.rs/sqlx/)

---

## ğŸ”— äº¤å‰å¼•ç”¨

### ç†è®ºæ¨¡å‹ ğŸ†•

- â­ [ç³»ç»Ÿç†è®ºæ¨¡å‹](../11-ç†è®ºæ¨¡å‹/11.01-ç³»ç»Ÿç†è®ºæ¨¡å‹.md) - ç¼–ç¨‹æ¥å£ç†è®º
- â­ [ç®—æ³•å¤æ‚åº¦ç†è®º](../11-ç†è®ºæ¨¡å‹/11.03-ç®—æ³•å¤æ‚åº¦ç†è®º.md) - Rustæ“ä½œå¤æ‚åº¦

### è®¾è®¡æ¨¡å‹ ğŸ†•

- â­â­ [è®¾è®¡æ¨¡å¼](../12-è®¾è®¡æ¨¡å‹/12.03-è®¾è®¡æ¨¡å¼.md) - Rustç¼–ç¨‹æ¨¡å¼
- â­ [è®¾è®¡åŸåˆ™](../12-è®¾è®¡æ¨¡å‹/12.02-è®¾è®¡åŸåˆ™.md) - Rustç¼–ç¨‹åŸåˆ™

---

## ğŸ“š å‚è€ƒèµ„æ–™

- [rusqlite GitHub](https://github.com/rusqlite/rusqlite)
- [sqlx GitHub](https://github.com/launchbadge/sqlx)
- [Dieselæ–‡æ¡£](https://diesel.rs/)
- [Sea-ORMæ–‡æ¡£](https://www.sea-ql.org/SeaORM/)

---

**æœ€åæ›´æ–°**ï¼š2025-01-15
**ç»´æŠ¤è€…**ï¼šData-Science Team
