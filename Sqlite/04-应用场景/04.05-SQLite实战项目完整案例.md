# SQLite实战项目完整案例

> **版本**: SQLite 3.47.x
> **创建日期**: 2025-12-04
> **难度**: ⭐⭐⭐⭐

---

## 案例1：移动端离线优先应用

### 场景描述

Flutter移动应用，支持离线操作，后台同步到PostgreSQL服务器。

### 完整实现

```dart
// lib/database/local_db.dart
import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart';
import 'dart:convert';

class LocalDatabase {
  static final LocalDatabase instance = LocalDatabase._init();
  static Database? _database;

  LocalDatabase._init();

  Future<Database> get database async {
    if (_database != null) return _database!;
    _database = await _initDB('app.db');
    return _database!;
  }

  Future<Database> _initDB(String filePath) async {
    final dbPath = await getDatabasesPath();
    final path = join(dbPath, filePath);

    return await openDatabase(
      path,
      version: 1,
      onCreate: _createDB,
      onConfigure: _onConfigure,
    );
  }

  Future _onConfigure(Database db) async {
    // 启用WAL模式
    await db.execute('PRAGMA journal_mode=WAL');
    await db.execute('PRAGMA synchronous=NORMAL');
    await db.execute('PRAGMA cache_size=-64000');  // 64MB cache
    await db.execute('PRAGMA temp_store=MEMORY');

    // 启用外键约束
    await db.execute('PRAGMA foreign_keys=ON');
  }

  Future _createDB(Database db, int version) async {
    // 用户表
    await db.execute('''
      CREATE TABLE users (
        id INTEGER PRIMARY KEY,
        name TEXT NOT NULL,
        email TEXT NOT NULL UNIQUE,
        avatar_path TEXT,
        last_sync_at INTEGER,
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL
      )
    ''');

    // 任务表
    await db.execute('''
      CREATE TABLE tasks (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER NOT NULL,
        title TEXT NOT NULL,
        description TEXT,
        status TEXT CHECK(status IN ('pending', 'in_progress', 'completed')) DEFAULT 'pending',
        priority INTEGER CHECK(priority BETWEEN 1 AND 5) DEFAULT 3,
        due_date INTEGER,
        synced INTEGER DEFAULT 0,  -- 0: 未同步, 1: 已同步
        server_id INTEGER,  -- 服务器端ID
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL,
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
      )
    ''');

    // 同步队列（存储待同步操作）
    await db.execute('''
      CREATE TABLE sync_queue (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        table_name TEXT NOT NULL,
        operation TEXT CHECK(operation IN ('INSERT', 'UPDATE', 'DELETE')) NOT NULL,
        local_id INTEGER,
        data TEXT NOT NULL,  -- JSON格式的数据
        retry_count INTEGER DEFAULT 0,
        last_error TEXT,
        created_at INTEGER NOT NULL
      )
    ''');

    // 索引
    await db.execute('CREATE INDEX idx_tasks_user_id ON tasks(user_id)');
    await db.execute('CREATE INDEX idx_tasks_status ON tasks(status)');
    await db.execute('CREATE INDEX idx_tasks_synced ON tasks(synced)');
    await db.execute('CREATE INDEX idx_sync_queue_created ON sync_queue(created_at)');
  }

  // 创建任务（离线操作）
  Future<int> createTask({
    required int userId,
    required String title,
    String? description,
    int? dueDate,
  }) async {
    final db = await database;
    final now = DateTime.now().millisecondsSinceEpoch;

    return await db.transaction((txn) async {
      // 插入任务
      final taskId = await txn.insert('tasks', {
        'user_id': userId,
        'title': title,
        'description': description,
        'due_date': dueDate,
        'created_at': now,
        'updated_at': now,
      });

      // 加入同步队列
      await txn.insert('sync_queue', {
        'table_name': 'tasks',
        'operation': 'INSERT',
        'local_id': taskId,
        'data': json.encode({
          'user_id': userId,
          'title': title,
          'description': description,
          'due_date': dueDate,
        }),
        'created_at': now,
      });

      return taskId;
    });
  }

  // 更新任务（离线操作）
  Future<void> updateTask(int taskId, Map<String, dynamic> updates) async {
    final db = await database;
    final now = DateTime.now().millisecondsSinceEpoch;

    await db.transaction((txn) async {
      // 更新任务
      updates['updated_at'] = now;
      await txn.update(
        'tasks',
        updates,
        where: 'id = ?',
        whereArgs: [taskId],
      );

      // 加入同步队列
      await txn.insert('sync_queue', {
        'table_name': 'tasks',
        'operation': 'UPDATE',
        'local_id': taskId,
        'data': json.encode(updates),
        'created_at': now,
      });
    });
  }

  // 后台同步（定时调用）
  Future<void> syncToServer(Future<void> Function(String, String, Map) apiCall) async {
    final db = await database;

    // 获取待同步操作（按时间顺序）
    final pending = await db.query(
      'sync_queue',
      orderBy: 'id ASC',
      limit: 100,
    );

    for (final op in pending) {
      try {
        final tableName = op['table_name'] as String;
        final operation = op['operation'] as String;
        final data = json.decode(op['data'] as String) as Map<String, dynamic>;
        final localId = op['local_id'] as int?;

        // 调用服务器API
        await apiCall(tableName, operation, data);

        // 如果是INSERT，更新server_id
        if (operation == 'INSERT' && localId != null) {
          // 假设API返回server_id
          await db.update(
            tableName,
            {'synced': 1, 'server_id': data['server_id']},
            where: 'id = ?',
            whereArgs: [localId],
          );
        }

        // 删除同步队列记录
        await db.delete(
          'sync_queue',
          where: 'id = ?',
          whereArgs: [op['id']],
        );
      } catch (e) {
        // 更新重试计数和错误信息
        await db.update(
          'sync_queue',
          {
            'retry_count': (op['retry_count'] as int) + 1,
            'last_error': e.toString(),
          },
          where: 'id = ?',
          whereArgs: [op['id']],
        );

        // 超过3次重试，停止同步
        if ((op['retry_count'] as int) >= 3) {
          break;
        }
      }
    }
  }

  // 查询任务（支持筛选和排序）
  Future<List<Map<String, dynamic>>> getTasks({
    int? userId,
    String? status,
    String orderBy = 'created_at DESC',
  }) async {
    final db = await database;

    String where = '';
    List<dynamic> whereArgs = [];

    if (userId != null) {
      where += 'user_id = ?';
      whereArgs.add(userId);
    }

    if (status != null) {
      if (where.isNotEmpty) where += ' AND ';
      where += 'status = ?';
      whereArgs.add(status);
    }

    return await db.query(
      'tasks',
      where: where.isNotEmpty ? where : null,
      whereArgs: whereArgs.isNotEmpty ? whereArgs : null,
      orderBy: orderBy,
    );
  }

  // 统计数据（Dashboard）
  Future<Map<String, int>> getTaskStats(int userId) async {
    final db = await database;

    final result = await db.rawQuery('''
      SELECT
        status,
        COUNT(*) as count
      FROM tasks
      WHERE user_id = ?
      GROUP BY status
    ''', [userId]);

    return {
      for (var row in result)
        row['status'] as String: row['count'] as int
    };
  }

  // 清理旧数据
  Future<void> cleanupOldData({int daysToKeep = 30}) async {
    final db = await database;
    final cutoffTime = DateTime.now()
        .subtract(Duration(days: daysToKeep))
        .millisecondsSinceEpoch;

    await db.transaction((txn) async {
      // 删除已完成且已同步的旧任务
      await txn.delete(
        'tasks',
        where: 'status = ? AND synced = 1 AND updated_at < ?',
        whereArgs: ['completed', cutoffTime],
      );

      // 删除已同步的旧同步队列
      await txn.delete(
        'sync_queue',
        where: 'created_at < ? AND retry_count = 0',
        whereArgs: [cutoffTime],
      );
    });
  }

  Future close() async {
    final db = await database;
    await db.close();
  }
}
```

### 使用示例

```dart
// main.dart
void main() {
  runApp(MyApp());

  // 后台同步任务（每5分钟）
  Timer.periodic(Duration(minutes: 5), (_) async {
    if (await isOnline()) {
      await LocalDatabase.instance.syncToServer(syncAPI);
    }
  });

  // 每天清理旧数据
  Timer.periodic(Duration(hours: 24), (_) async {
    await LocalDatabase.instance.cleanupOldData(daysToKeep: 30);
  });
}

Future<void> syncAPI(String table, String operation, Map data) async {
  // 调用服务器API
  final response = await http.post(
    Uri.parse('https://api.example.com/sync'),
    body: json.encode({
      'table': table,
      'operation': operation,
      'data': data,
    }),
  );

  if (response.statusCode != 200) {
    throw Exception('Sync failed: ${response.body}');
  }
}
```

---

## 案例2：桌面应用嵌入式数据库

### 场景描述

Electron桌面应用，使用SQLite存储用户配置、历史记录、缓存数据。

### 完整实现

```javascript
// database.js
const sqlite3 = require('better-sqlite3');
const path = require('path');
const { app } = require('electron');

class AppDatabase {
  constructor() {
    const dbPath = path.join(app.getPath('userData'), 'app.db');
    this.db = new sqlite3(dbPath);

    // 配置
    this.db.pragma('journal_mode = WAL');
    this.db.pragma('synchronous = NORMAL');
    this.db.pragma('cache_size = -64000');  // 64MB
    this.db.pragma('foreign_keys = ON');

    this.init();
  }

  init() {
    // 用户配置表
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS user_settings (
        key TEXT PRIMARY KEY,
        value TEXT NOT NULL,
        updated_at INTEGER NOT NULL
      )
    `);

    // 历史记录表
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS history (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        type TEXT NOT NULL,
        title TEXT NOT NULL,
        url TEXT,
        data TEXT,  -- JSON
        created_at INTEGER NOT NULL
      )
    `);

    // 缓存表
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS cache (
        key TEXT PRIMARY KEY,
        value TEXT NOT NULL,
        expires_at INTEGER NOT NULL,
        created_at INTEGER NOT NULL
      )
    `);

    // 索引
    this.db.exec('CREATE INDEX IF NOT EXISTS idx_history_type ON history(type)');
    this.db.exec('CREATE INDEX IF NOT EXISTS idx_history_created ON history(created_at DESC)');
    this.db.exec('CREATE INDEX IF NOT EXISTS idx_cache_expires ON cache(expires_at)');

    // 定期清理过期缓存
    this.startCleanupTimer();
  }

  // 配置管理
  getSetting(key, defaultValue = null) {
    const stmt = this.db.prepare('SELECT value FROM user_settings WHERE key = ?');
    const row = stmt.get(key);
    return row ? JSON.parse(row.value) : defaultValue;
  }

  setSetting(key, value) {
    const stmt = this.db.prepare(`
      INSERT INTO user_settings (key, value, updated_at)
      VALUES (?, ?, ?)
      ON CONFLICT(key) DO UPDATE SET
        value = excluded.value,
        updated_at = excluded.updated_at
    `);
    stmt.run(key, JSON.stringify(value), Date.now());
  }

  // 历史记录
  addHistory(type, title, url, data = null) {
    const stmt = this.db.prepare(`
      INSERT INTO history (type, title, url, data, created_at)
      VALUES (?, ?, ?, ?, ?)
    `);
    return stmt.run(
      type,
      title,
      url,
      data ? JSON.stringify(data) : null,
      Date.now()
    ).lastInsertRowid;
  }

  getHistory(type = null, limit = 100) {
    let query = 'SELECT * FROM history';
    let params = [];

    if (type) {
      query += ' WHERE type = ?';
      params.push(type);
    }

    query += ' ORDER BY created_at DESC LIMIT ?';
    params.push(limit);

    const stmt = this.db.prepare(query);
    return stmt.all(...params).map(row => ({
      ...row,
      data: row.data ? JSON.parse(row.data) : null
    }));
  }

  searchHistory(keyword, limit = 50) {
    const stmt = this.db.prepare(`
      SELECT * FROM history
      WHERE title LIKE ? OR url LIKE ?
      ORDER BY created_at DESC
      LIMIT ?
    `);
    const pattern = `%${keyword}%`;
    return stmt.all(pattern, pattern, limit);
  }

  clearHistory(olderThanDays = 30) {
    const cutoff = Date.now() - (olderThanDays * 24 * 60 * 60 * 1000);
    const stmt = this.db.prepare('DELETE FROM history WHERE created_at < ?');
    return stmt.run(cutoff).changes;
  }

  // 缓存管理
  setCache(key, value, ttlSeconds = 3600) {
    const stmt = this.db.prepare(`
      INSERT INTO cache (key, value, expires_at, created_at)
      VALUES (?, ?, ?, ?)
      ON CONFLICT(key) DO UPDATE SET
        value = excluded.value,
        expires_at = excluded.expires_at
    `);
    const now = Date.now();
    stmt.run(key, JSON.stringify(value), now + (ttlSeconds * 1000), now);
  }

  getCache(key) {
    const stmt = this.db.prepare(`
      SELECT value FROM cache
      WHERE key = ? AND expires_at > ?
    `);
    const row = stmt.get(key, Date.now());
    return row ? JSON.parse(row.value) : null;
  }

  deleteCache(key) {
    const stmt = this.db.prepare('DELETE FROM cache WHERE key = ?');
    return stmt.run(key).changes > 0;
  }

  // 清理过期缓存
  cleanupExpiredCache() {
    const stmt = this.db.prepare('DELETE FROM cache WHERE expires_at <= ?');
    const changes = stmt.run(Date.now()).changes;
    console.log(`Cleaned up ${changes} expired cache entries`);
  }

  startCleanupTimer() {
    // 每小时清理一次
    setInterval(() => {
      this.cleanupExpiredCache();
    }, 60 * 60 * 1000);
  }

  // 统计信息
  getStats() {
    const historyCount = this.db.prepare('SELECT COUNT(*) as count FROM history').get().count;
    const cacheCount = this.db.prepare('SELECT COUNT(*) as count FROM cache').get().count;
    const dbSize = this.db.prepare("SELECT page_count * page_size as size FROM pragma_page_count(), pragma_page_size()").get().size;

    return {
      historyCount,
      cacheCount,
      dbSize: (dbSize / 1024 / 1024).toFixed(2) + ' MB'
    };
  }

  // 数据库维护
  vacuum() {
    this.db.exec('VACUUM');
  }

  checkpoint() {
    this.db.pragma('wal_checkpoint(TRUNCATE)');
  }

  close() {
    this.db.close();
  }
}

module.exports = new AppDatabase();
```

---

**文档版本**: v1.0.0
**最后更新**: 2025-12-04
