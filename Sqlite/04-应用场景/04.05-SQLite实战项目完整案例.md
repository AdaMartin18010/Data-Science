# SQLiteå®æˆ˜é¡¹ç›®å®Œæ•´æ¡ˆä¾‹

> **ç‰ˆæœ¬**: SQLite 3.47.x
> **åˆ›å»ºæ—¥æœŸ**: 2025-12-04
> **éš¾åº¦**: â­â­â­â­

---

## æ¡ˆä¾‹1ï¼šç§»åŠ¨ç«¯ç¦»çº¿ä¼˜å…ˆåº”ç”¨

### åœºæ™¯æè¿°

Flutterç§»åŠ¨åº”ç”¨ï¼Œæ”¯æŒç¦»çº¿æ“ä½œï¼Œåå°åŒæ­¥åˆ°PostgreSQLæœåŠ¡å™¨ã€‚

### å®Œæ•´å®ç°

```dart
// lib/database/local_db.dart
import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart';
import 'dart:convert';

class LocalDatabase {
  static final LocalDatabase instance = LocalDatabase._init();
  static Database? _database;

  LocalDatabase._init();

  Future<Database> get database async {
    if (_database != null) return _database!;
    _database = await _initDB('app.db');
    return _database!;
  }

  Future<Database> _initDB(String filePath) async {
    final dbPath = await getDatabasesPath();
    final path = join(dbPath, filePath);

    return await openDatabase(
      path,
      version: 1,
      onCreate: _createDB,
      onConfigure: _onConfigure,
    );
  }

  Future _onConfigure(Database db) async {
    // å¯ç”¨WALæ¨¡å¼
    await db.execute('PRAGMA journal_mode=WAL');
    await db.execute('PRAGMA synchronous=NORMAL');
    await db.execute('PRAGMA cache_size=-64000');  // 64MB cache
    await db.execute('PRAGMA temp_store=MEMORY');

    // å¯ç”¨å¤–é”®çº¦æŸ
    await db.execute('PRAGMA foreign_keys=ON');
  }

  Future _createDB(Database db, int version) async {
    // ç”¨æˆ·è¡¨
    await db.execute('''
      CREATE TABLE users (
        id INTEGER PRIMARY KEY,
        name TEXT NOT NULL,
        email TEXT NOT NULL UNIQUE,
        avatar_path TEXT,
        last_sync_at INTEGER,
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL
      )
    ''');

    // ä»»åŠ¡è¡¨
    await db.execute('''
      CREATE TABLE tasks (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER NOT NULL,
        title TEXT NOT NULL,
        description TEXT,
        status TEXT CHECK(status IN ('pending', 'in_progress', 'completed')) DEFAULT 'pending',
        priority INTEGER CHECK(priority BETWEEN 1 AND 5) DEFAULT 3,
        due_date INTEGER,
        synced INTEGER DEFAULT 0,  -- 0: æœªåŒæ­¥, 1: å·²åŒæ­¥
        server_id INTEGER,  -- æœåŠ¡å™¨ç«¯ID
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL,
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
      )
    ''');

    // åŒæ­¥é˜Ÿåˆ—ï¼ˆå­˜å‚¨å¾…åŒæ­¥æ“ä½œï¼‰
    await db.execute('''
      CREATE TABLE sync_queue (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        table_name TEXT NOT NULL,
        operation TEXT CHECK(operation IN ('INSERT', 'UPDATE', 'DELETE')) NOT NULL,
        local_id INTEGER,
        data TEXT NOT NULL,  -- JSONæ ¼å¼çš„æ•°æ®
        retry_count INTEGER DEFAULT 0,
        last_error TEXT,
        created_at INTEGER NOT NULL
      )
    ''');

    // ç´¢å¼•
    await db.execute('CREATE INDEX idx_tasks_user_id ON tasks(user_id)');
    await db.execute('CREATE INDEX idx_tasks_status ON tasks(status)');
    await db.execute('CREATE INDEX idx_tasks_synced ON tasks(synced)');
    await db.execute('CREATE INDEX idx_sync_queue_created ON sync_queue(created_at)');
  }

  // åˆ›å»ºä»»åŠ¡ï¼ˆç¦»çº¿æ“ä½œï¼‰
  Future<int> createTask({
    required int userId,
    required String title,
    String? description,
    int? dueDate,
  }) async {
    final db = await database;
    final now = DateTime.now().millisecondsSinceEpoch;

    return await db.transaction((txn) async {
      // æ’å…¥ä»»åŠ¡
      final taskId = await txn.insert('tasks', {
        'user_id': userId,
        'title': title,
        'description': description,
        'due_date': dueDate,
        'created_at': now,
        'updated_at': now,
      });

      // åŠ å…¥åŒæ­¥é˜Ÿåˆ—
      await txn.insert('sync_queue', {
        'table_name': 'tasks',
        'operation': 'INSERT',
        'local_id': taskId,
        'data': json.encode({
          'user_id': userId,
          'title': title,
          'description': description,
          'due_date': dueDate,
        }),
        'created_at': now,
      });

      return taskId;
    });
  }

  // æ›´æ–°ä»»åŠ¡ï¼ˆç¦»çº¿æ“ä½œï¼‰
  Future<void> updateTask(int taskId, Map<String, dynamic> updates) async {
    final db = await database;
    final now = DateTime.now().millisecondsSinceEpoch;

    await db.transaction((txn) async {
      // æ›´æ–°ä»»åŠ¡
      updates['updated_at'] = now;
      await txn.update(
        'tasks',
        updates,
        where: 'id = ?',
        whereArgs: [taskId],
      );

      // åŠ å…¥åŒæ­¥é˜Ÿåˆ—
      await txn.insert('sync_queue', {
        'table_name': 'tasks',
        'operation': 'UPDATE',
        'local_id': taskId,
        'data': json.encode(updates),
        'created_at': now,
      });
    });
  }

  // åå°åŒæ­¥ï¼ˆå®šæ—¶è°ƒç”¨ï¼‰
  Future<void> syncToServer(Future<void> Function(String, String, Map) apiCall) async {
    final db = await database;

    // è·å–å¾…åŒæ­¥æ“ä½œï¼ˆæŒ‰æ—¶é—´é¡ºåºï¼‰
    final pending = await db.query(
      'sync_queue',
      orderBy: 'id ASC',
      limit: 100,
    );

    for (final op in pending) {
      try {
        final tableName = op['table_name'] as String;
        final operation = op['operation'] as String;
        final data = json.decode(op['data'] as String) as Map<String, dynamic>;
        final localId = op['local_id'] as int?;

        // è°ƒç”¨æœåŠ¡å™¨API
        await apiCall(tableName, operation, data);

        // å¦‚æœæ˜¯INSERTï¼Œæ›´æ–°server_id
        if (operation == 'INSERT' && localId != null) {
          // å‡è®¾APIè¿”å›server_id
          await db.update(
            tableName,
            {'synced': 1, 'server_id': data['server_id']},
            where: 'id = ?',
            whereArgs: [localId],
          );
        }

        // åˆ é™¤åŒæ­¥é˜Ÿåˆ—è®°å½•
        await db.delete(
          'sync_queue',
          where: 'id = ?',
          whereArgs: [op['id']],
        );
      } catch (e) {
        // æ›´æ–°é‡è¯•è®¡æ•°å’Œé”™è¯¯ä¿¡æ¯
        await db.update(
          'sync_queue',
          {
            'retry_count': (op['retry_count'] as int) + 1,
            'last_error': e.toString(),
          },
          where: 'id = ?',
          whereArgs: [op['id']],
        );

        // è¶…è¿‡3æ¬¡é‡è¯•ï¼Œåœæ­¢åŒæ­¥
        if ((op['retry_count'] as int) >= 3) {
          break;
        }
      }
    }
  }

  // æŸ¥è¯¢ä»»åŠ¡ï¼ˆæ”¯æŒç­›é€‰å’Œæ’åºï¼‰
  Future<List<Map<String, dynamic>>> getTasks({
    int? userId,
    String? status,
    String orderBy = 'created_at DESC',
  }) async {
    final db = await database;

    String where = '';
    List<dynamic> whereArgs = [];

    if (userId != null) {
      where += 'user_id = ?';
      whereArgs.add(userId);
    }

    if (status != null) {
      if (where.isNotEmpty) where += ' AND ';
      where += 'status = ?';
      whereArgs.add(status);
    }

    return await db.query(
      'tasks',
      where: where.isNotEmpty ? where : null,
      whereArgs: whereArgs.isNotEmpty ? whereArgs : null,
      orderBy: orderBy,
    );
  }

  // ç»Ÿè®¡æ•°æ®ï¼ˆDashboardï¼‰
  Future<Map<String, int>> getTaskStats(int userId) async {
    final db = await database;

    final result = await db.rawQuery('''
      SELECT
        status,
        COUNT(*) as count
      FROM tasks
      WHERE user_id = ?
      GROUP BY status
    ''', [userId]);

    return {
      for (var row in result)
        row['status'] as String: row['count'] as int
    };
  }

  // æ¸…ç†æ—§æ•°æ®
  Future<void> cleanupOldData({int daysToKeep = 30}) async {
    final db = await database;
    final cutoffTime = DateTime.now()
        .subtract(Duration(days: daysToKeep))
        .millisecondsSinceEpoch;

    await db.transaction((txn) async {
      // åˆ é™¤å·²å®Œæˆä¸”å·²åŒæ­¥çš„æ—§ä»»åŠ¡
      await txn.delete(
        'tasks',
        where: 'status = ? AND synced = 1 AND updated_at < ?',
        whereArgs: ['completed', cutoffTime],
      );

      // åˆ é™¤å·²åŒæ­¥çš„æ—§åŒæ­¥é˜Ÿåˆ—
      await txn.delete(
        'sync_queue',
        where: 'created_at < ? AND retry_count = 0',
        whereArgs: [cutoffTime],
      );
    });
  }

  Future close() async {
    final db = await database;
    await db.close();
  }
}
```

### ä½¿ç”¨ç¤ºä¾‹

```dart
// main.dart
void main() {
  runApp(MyApp());

  // åå°åŒæ­¥ä»»åŠ¡ï¼ˆæ¯5åˆ†é’Ÿï¼‰
  Timer.periodic(Duration(minutes: 5), (_) async {
    if (await isOnline()) {
      await LocalDatabase.instance.syncToServer(syncAPI);
    }
  });

  // æ¯å¤©æ¸…ç†æ—§æ•°æ®
  Timer.periodic(Duration(hours: 24), (_) async {
    await LocalDatabase.instance.cleanupOldData(daysToKeep: 30);
  });
}

Future<void> syncAPI(String table, String operation, Map data) async {
  // è°ƒç”¨æœåŠ¡å™¨API
  final response = await http.post(
    Uri.parse('https://api.example.com/sync'),
    body: json.encode({
      'table': table,
      'operation': operation,
      'data': data,
    }),
  );

  if (response.statusCode != 200) {
    throw Exception('Sync failed: ${response.body}');
  }
}
```

---

## æ¡ˆä¾‹2ï¼šæ¡Œé¢åº”ç”¨åµŒå…¥å¼æ•°æ®åº“

### åœºæ™¯æè¿°

Electronæ¡Œé¢åº”ç”¨ï¼Œä½¿ç”¨SQLiteå­˜å‚¨ç”¨æˆ·é…ç½®ã€å†å²è®°å½•ã€ç¼“å­˜æ•°æ®ã€‚

### å®Œæ•´å®ç°

```javascript
// database.js
const sqlite3 = require('better-sqlite3');
const path = require('path');
const { app } = require('electron');

class AppDatabase {
  constructor() {
    const dbPath = path.join(app.getPath('userData'), 'app.db');
    this.db = new sqlite3(dbPath);

    // é…ç½®
    this.db.pragma('journal_mode = WAL');
    this.db.pragma('synchronous = NORMAL');
    this.db.pragma('cache_size = -64000');  // 64MB
    this.db.pragma('foreign_keys = ON');

    this.init();
  }

  init() {
    // ç”¨æˆ·é…ç½®è¡¨
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS user_settings (
        key TEXT PRIMARY KEY,
        value TEXT NOT NULL,
        updated_at INTEGER NOT NULL
      )
    `);

    // å†å²è®°å½•è¡¨
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS history (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        type TEXT NOT NULL,
        title TEXT NOT NULL,
        url TEXT,
        data TEXT,  -- JSON
        created_at INTEGER NOT NULL
      )
    `);

    // ç¼“å­˜è¡¨
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS cache (
        key TEXT PRIMARY KEY,
        value TEXT NOT NULL,
        expires_at INTEGER NOT NULL,
        created_at INTEGER NOT NULL
      )
    `);

    // ç´¢å¼•
    this.db.exec('CREATE INDEX IF NOT EXISTS idx_history_type ON history(type)');
    this.db.exec('CREATE INDEX IF NOT EXISTS idx_history_created ON history(created_at DESC)');
    this.db.exec('CREATE INDEX IF NOT EXISTS idx_cache_expires ON cache(expires_at)');

    // å®šæœŸæ¸…ç†è¿‡æœŸç¼“å­˜
    this.startCleanupTimer();
  }

  // é…ç½®ç®¡ç†
  getSetting(key, defaultValue = null) {
    const stmt = this.db.prepare('SELECT value FROM user_settings WHERE key = ?');
    const row = stmt.get(key);
    return row ? JSON.parse(row.value) : defaultValue;
  }

  setSetting(key, value) {
    const stmt = this.db.prepare(`
      INSERT INTO user_settings (key, value, updated_at)
      VALUES (?, ?, ?)
      ON CONFLICT(key) DO UPDATE SET
        value = excluded.value,
        updated_at = excluded.updated_at
    `);
    stmt.run(key, JSON.stringify(value), Date.now());
  }

  // å†å²è®°å½•
  addHistory(type, title, url, data = null) {
    const stmt = this.db.prepare(`
      INSERT INTO history (type, title, url, data, created_at)
      VALUES (?, ?, ?, ?, ?)
    `);
    return stmt.run(
      type,
      title,
      url,
      data ? JSON.stringify(data) : null,
      Date.now()
    ).lastInsertRowid;
  }

  getHistory(type = null, limit = 100) {
    let query = 'SELECT * FROM history';
    let params = [];

    if (type) {
      query += ' WHERE type = ?';
      params.push(type);
    }

    query += ' ORDER BY created_at DESC LIMIT ?';
    params.push(limit);

    const stmt = this.db.prepare(query);
    return stmt.all(...params).map(row => ({
      ...row,
      data: row.data ? JSON.parse(row.data) : null
    }));
  }

  searchHistory(keyword, limit = 50) {
    const stmt = this.db.prepare(`
      SELECT * FROM history
      WHERE title LIKE ? OR url LIKE ?
      ORDER BY created_at DESC
      LIMIT ?
    `);
    const pattern = `%${keyword}%`;
    return stmt.all(pattern, pattern, limit);
  }

  clearHistory(olderThanDays = 30) {
    const cutoff = Date.now() - (olderThanDays * 24 * 60 * 60 * 1000);
    const stmt = this.db.prepare('DELETE FROM history WHERE created_at < ?');
    return stmt.run(cutoff).changes;
  }

  // ç¼“å­˜ç®¡ç†
  setCache(key, value, ttlSeconds = 3600) {
    const stmt = this.db.prepare(`
      INSERT INTO cache (key, value, expires_at, created_at)
      VALUES (?, ?, ?, ?)
      ON CONFLICT(key) DO UPDATE SET
        value = excluded.value,
        expires_at = excluded.expires_at
    `);
    const now = Date.now();
    stmt.run(key, JSON.stringify(value), now + (ttlSeconds * 1000), now);
  }

  getCache(key) {
    const stmt = this.db.prepare(`
      SELECT value FROM cache
      WHERE key = ? AND expires_at > ?
    `);
    const row = stmt.get(key, Date.now());
    return row ? JSON.parse(row.value) : null;
  }

  deleteCache(key) {
    const stmt = this.db.prepare('DELETE FROM cache WHERE key = ?');
    return stmt.run(key).changes > 0;
  }

  // æ¸…ç†è¿‡æœŸç¼“å­˜
  cleanupExpiredCache() {
    const stmt = this.db.prepare('DELETE FROM cache WHERE expires_at <= ?');
    const changes = stmt.run(Date.now()).changes;
    console.log(`Cleaned up ${changes} expired cache entries`);
  }

  startCleanupTimer() {
    // æ¯å°æ—¶æ¸…ç†ä¸€æ¬¡
    setInterval(() => {
      this.cleanupExpiredCache();
    }, 60 * 60 * 1000);
  }

  // ç»Ÿè®¡ä¿¡æ¯
  getStats() {
    const historyCount = this.db.prepare('SELECT COUNT(*) as count FROM history').get().count;
    const cacheCount = this.db.prepare('SELECT COUNT(*) as count FROM cache').get().count;
    const dbSize = this.db.prepare("SELECT page_count * page_size as size FROM pragma_page_count(), pragma_page_size()").get().size;

    return {
      historyCount,
      cacheCount,
      dbSize: (dbSize / 1024 / 1024).toFixed(2) + ' MB'
    };
  }

  // æ•°æ®åº“ç»´æŠ¤
  vacuum() {
    this.db.exec('VACUUM');
  }

  checkpoint() {
    this.db.pragma('wal_checkpoint(TRUNCATE)');
  }

  close() {
    this.db.close();
  }
}

module.exports = new AppDatabase();
```

---

## ğŸ”— äº¤å‰å¼•ç”¨

### åº”ç”¨åœºæ™¯æ–‡æ¡£

- â­â­â­ [é€‚ç”¨åœºæ™¯åˆ†æ](./04.01-é€‚ç”¨åœºæ™¯åˆ†æ.md) - é€‚ç”¨åœºæ™¯åˆ†æï¼ˆå«äº¤å‰å¼•ç”¨ï¼‰
- â­â­ [ä¸é€‚ç”¨åœºæ™¯è®ºè¯](./04.02-ä¸é€‚ç”¨åœºæ™¯è®ºè¯.md) - ä¸é€‚ç”¨åœºæ™¯è®ºè¯ï¼ˆå«äº¤å‰å¼•ç”¨ï¼‰
- â­â­â­ [é¡¶çº§åº”ç”¨æ¡ˆä¾‹](./04.03-é¡¶çº§åº”ç”¨æ¡ˆä¾‹.md) - é¡¶çº§åº”ç”¨æ¡ˆä¾‹ï¼ˆå«äº¤å‰å¼•ç”¨ï¼‰

### å®è·µæ¡ˆä¾‹æ–‡æ¡£ ğŸ†•

- â­â­â­ [å®æˆ˜æ¡ˆä¾‹åº“](../cases/README.md) - è¯¦ç»†æ¡ˆä¾‹æ–‡æ¡£ï¼ˆå«äº¤å‰å¼•ç”¨ï¼‰
  - Chromeæµè§ˆå™¨æ¡ˆä¾‹
  - GitLab CIæ¡ˆä¾‹
  - ç”µå•†ç³»ç»Ÿè¿ç§»æ¡ˆä¾‹
  - é‡‘èé£æ§æ¡ˆä¾‹

### ç¼–ç¨‹å®è·µæ–‡æ¡£ ğŸ†•

- â­â­â­ [é«˜çº§ç¼–ç¨‹æ¨¡å¼](../08-ç¼–ç¨‹å®è·µ/08.11-SQLiteé«˜çº§ç¼–ç¨‹æ¨¡å¼.md) - ç¼–ç¨‹æ¨¡å¼å®è·µï¼ˆå«è®ºè¯è„‰ç»œï¼‰
- â­â­ [è¿æ¥ç®¡ç†](../08-ç¼–ç¨‹å®è·µ/08.01-è¿æ¥ç®¡ç†.md) - è¿æ¥ç®¡ç†å®è·µ
- â­â­ [äº‹åŠ¡ç®¡ç†](../08-ç¼–ç¨‹å®è·µ/08.02-äº‹åŠ¡ç®¡ç†.md) - äº‹åŠ¡ç®¡ç†å®è·µ

### æ€§èƒ½ä¼˜åŒ–æ–‡æ¡£ ğŸ†•

- â­â­ [ä¼˜åŒ–ç­–ç•¥](../03-æ€§èƒ½ä¼˜åŒ–/03.02-ä¼˜åŒ–ç­–ç•¥.md) - ä¼˜åŒ–æ–¹æ³•ï¼ˆå«è®ºè¯è„‰ç»œå’Œå†³ç­–æ ‘ï¼‰
- â­â­ [ç‰¹å®šåœºæ™¯æ·±åº¦ä¼˜åŒ–](../03-æ€§èƒ½ä¼˜åŒ–/03.05-SQLiteç‰¹å®šåœºæ™¯æ·±åº¦ä¼˜åŒ–.md) - åœºæ™¯ä¼˜åŒ–ï¼ˆå«å†³ç­–æ ‘å’Œè®ºè¯è„‰ç»œï¼‰

### çŸ¥è¯†å›¾è°±ä¸å¯¼èˆª ğŸ†•

- â­â­â­ [çŸ¥è¯†å›¾è°±ä¸æ¦‚å¿µå…³ç³»ç½‘ç»œ](../09-æœ€æ–°ç‰¹æ€§/09.03-SQLiteçŸ¥è¯†å›¾è°±ä¸æ¦‚å¿µå…³ç³»ç½‘ç»œ.md) - å®æˆ˜é¡¹ç›®æ¦‚å¿µå…³ç³»ï¼ˆ400+æ¦‚å¿µï¼‰
- â­â­ [æ–‡æ¡£ä¾èµ–å…³ç³»å›¾](../00-é¡¹ç›®å¯¼èˆª/06-æ–‡æ¡£ä¾èµ–å…³ç³»å›¾.md) - å®æˆ˜é¡¹ç›®æ–‡æ¡£ä¾èµ–
- â­â­ [æœ¯è¯­æ ‡å‡†åŒ–è¯å…¸](../00-é¡¹ç›®å¯¼èˆª/03-æœ¯è¯­è¯å…¸/SQLiteæœ¯è¯­æ ‡å‡†åŒ–è¯å…¸.md) - å®æˆ˜é¡¹ç›®æœ¯è¯­ç´¢å¼•

### ç›¸å…³æ¦‚å¿µé“¾æ¥ ğŸ†•

#### å®æˆ˜é¡¹ç›®æ¦‚å¿µ

- **å®æˆ˜é¡¹ç›®** â†’ [çŸ¥è¯†å›¾è°±ï¼šåº”ç”¨åœºæ™¯æœ¬ä½“](../09-æœ€æ–°ç‰¹æ€§/09.03-SQLiteçŸ¥è¯†å›¾è°±ä¸æ¦‚å¿µå…³ç³»ç½‘ç»œ.md#åº”ç”¨åœºæ™¯æœ¬ä½“)
- **é¡¹ç›®æ¡ˆä¾‹** â†’ [å®æˆ˜æ¡ˆä¾‹åº“](../cases/README.md)
- **ç¼–ç¨‹æ¨¡å¼** â†’ [é«˜çº§ç¼–ç¨‹æ¨¡å¼](../08-ç¼–ç¨‹å®è·µ/08.11-SQLiteé«˜çº§ç¼–ç¨‹æ¨¡å¼.md)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v2.0.0
**æœ€åæ›´æ–°**: 2025-12-05
