# 不适用场景论证：高并发写与分布式需求

> **创建日期**：2025-11-13
> **最后更新**：2025-11-13
> **版本**：SQLite 3.31+ 至 3.47+

---

## 📋 概述

SQLite并非适用于所有场景。本文档深入论证SQLite的不适用场景，帮助开发者做出正确的技术选型决策。

---

## 📑 目录

- [不适用场景论证：高并发写与分布式需求](#不适用场景论证高并发写与分布式需求)
  - [📋 概述](#-概述)
  - [📑 目录](#-目录)
  - [一、高并发写场景](#一高并发写场景)
    - [1.1 多写并发限制](#11-多写并发限制)
    - [1.2 写冲突问题](#12-写冲突问题)
    - [1.3 替代方案](#13-替代方案)
  - [二、大规模数据场景](#二大规模数据场景)
    - [2.1 单文件限制](#21-单文件限制)
    - [2.2 性能瓶颈](#22-性能瓶颈)
    - [2.3 替代方案](#23-替代方案)
  - [三、网络访问需求](#三网络访问需求)
    - [3.1 无网络协议](#31-无网络协议)
    - [3.2 远程访问限制](#32-远程访问限制)
    - [3.3 替代方案](#33-替代方案)
  - [四、复杂查询需求](#四复杂查询需求)
    - [4.1 查询优化器限制](#41-查询优化器限制)
    - [4.2 并行查询不支持](#42-并行查询不支持)
    - [4.3 替代方案](#43-替代方案)
  - [五、高可用性需求](#五高可用性需求)
    - [5.1 单点故障](#51-单点故障)
    - [5.2 无主从复制](#52-无主从复制)
    - [5.3 替代方案](#53-替代方案)
  - [六、不适用场景总结](#六不适用场景总结)
    - [6.1 技术限制总结](#61-技术限制总结)
    - [6.2 选型建议](#62-选型建议)
  - [🔗 相关资源](#-相关资源)
  - [📚 参考资料](#-参考资料)

---

## 一、高并发写场景

### 1.1 多写并发限制

**技术限制**：

SQLite在WAL模式下仅支持**一写多读**，不支持多写并发。

**性能影响**：

```text
场景：10个连接同时写入
- PostgreSQL/MySQL：支持多写并发，吞吐量线性增长
- SQLite：写操作序列化，吞吐量不增长
```

**形式化描述**：

```text
SQLite写并发模型：
∀w₁, w₂ ∈ Writes, w₁ || w₂ → w₁; w₂ 或 w₂; w₁
（任意两个写操作必须串行执行）
```

### 1.2 写冲突问题

**问题场景**：

```python
# 场景：多用户同时下单
# 连接1
conn1.execute('BEGIN')
conn1.execute('UPDATE inventory SET quantity = quantity - 1 WHERE product_id = 1')
# 此时连接2也尝试更新同一商品
conn2.execute('BEGIN')
conn2.execute('UPDATE inventory SET quantity = quantity - 1 WHERE product_id = 1')
# 结果：连接2会等待或超时
```

**性能影响**：

| 并发写数 | SQLite吞吐量 | PostgreSQL吞吐量 | 性能差距 |
|---------|------------|-----------------|---------|
| 1 | 基准 | 基准 | 1:1 |
| 5 | 基准 | 5倍 | 1:5 |
| 10 | 基准 | 10倍 | 1:10 |

### 1.3 替代方案

**推荐方案**：

- **PostgreSQL**：支持多写并发，适合高并发写场景
- **MySQL**：支持多写并发，适合Web应用
- **MongoDB**：支持分布式写入，适合大规模并发

---

## 二、大规模数据场景

### 2.1 单文件限制

**技术限制**：

SQLite使用单文件存储，虽然理论上支持281TB，但实际使用中：

- **性能瓶颈**：文件过大导致查询性能下降
- **备份困难**：大文件备份和恢复耗时
- **迁移困难**：大文件迁移不便

**实际限制**：

| 数据量 | SQLite性能 | 推荐度 |
|--------|-----------|--------|
| < 10GB | 优秀 | ⭐⭐⭐⭐⭐ |
| 10GB - 100GB | 良好 | ⭐⭐⭐⭐ |
| 100GB - 1TB | 可接受 | ⭐⭐⭐ |
| > 1TB | 不推荐 | ⭐⭐ |

### 2.2 性能瓶颈

**问题场景**：

```sql
-- 场景：1TB数据库，查询性能下降
SELECT * FROM large_table WHERE id = 123456789;
-- 即使有索引，大文件I/O也会影响性能
```

**性能对比**：

| 数据库大小 | 查询延迟 | 说明 |
|-----------|---------|------|
| 1GB | ~0.1ms | 优秀 |
| 10GB | ~1ms | 良好 |
| 100GB | ~10ms | 可接受 |
| 1TB | ~100ms+ | 不推荐 |

### 2.3 替代方案

**推荐方案**：

- **PostgreSQL**：支持分区表，适合大规模数据
- **MySQL**：支持分区表，适合大规模数据
- **分布式数据库**：Cassandra、MongoDB等

---

## 三、网络访问需求

### 3.1 无网络协议

**技术限制**：

SQLite是进程内数据库，**没有网络协议**，无法通过网络直接访问。

**问题场景**：

```text
需求：多个应用服务器需要共享数据库
- SQLite：无法实现（单文件，无法网络访问）
- PostgreSQL/MySQL：支持网络协议，多服务器可访问
```

### 3.2 远程访问限制

**解决方案（不推荐）**：

虽然可以通过网络文件系统（NFS）共享SQLite文件，但存在严重问题：

1. **锁竞争**：网络文件系统锁性能差
2. **数据损坏风险**：网络故障可能导致数据损坏
3. **性能问题**：网络I/O延迟高

**官方警告**：

> SQLite官方明确警告：不要在网络文件系统上使用SQLite

### 3.3 替代方案

**推荐方案**：

- **PostgreSQL**：原生网络协议支持
- **MySQL**：原生网络协议支持
- **SQLite + 应用层API**：通过应用服务器提供API访问

---

## 四、复杂查询需求

### 4.1 查询优化器限制

**技术限制**：

SQLite的查询优化器相对简单，不支持：

- 复杂查询并行化
- 高级优化技术（如物化视图）
- 复杂统计信息

**问题场景**：

```sql
-- 复杂查询：多表JOIN + 聚合
SELECT
    u.name,
    COUNT(o.id) as order_count,
    SUM(o.amount) as total_amount
FROM users u
JOIN orders o ON u.id = o.user_id
JOIN order_items oi ON o.id = oi.order_id
WHERE o.created_at > '2024-01-01'
GROUP BY u.id, u.name
HAVING COUNT(o.id) > 10
ORDER BY total_amount DESC
LIMIT 100;

-- SQLite：可能性能较差
-- PostgreSQL：优化器更强大，性能更好
```

### 4.2 并行查询不支持

**技术限制**：

SQLite不支持查询并行化，复杂查询只能单线程执行。

**性能影响**：

| 查询复杂度 | SQLite性能 | PostgreSQL性能 | 性能差距 |
|-----------|-----------|---------------|---------|
| 简单查询 | 优秀 | 良好 | SQLite更快 |
| 中等查询 | 良好 | 优秀 | PostgreSQL更快 |
| 复杂查询 | 可接受 | 优秀 | PostgreSQL快2-5倍 |

### 4.3 替代方案

**推荐方案**：

- **PostgreSQL**：强大的查询优化器，支持并行查询
- **MySQL**：支持并行查询（8.0+）
- **分析型数据库**：ClickHouse、DuckDB等

---

## 五、高可用性需求

### 5.1 单点故障

**技术限制**：

SQLite是单文件数据库，存在单点故障风险：

- **文件损坏**：数据库文件损坏可能导致数据丢失
- **磁盘故障**：磁盘故障导致数据丢失
- **无冗余**：无法提供数据冗余

**问题场景**：

```text
场景：关键业务系统需要高可用性
- SQLite：单文件，无冗余，风险高
- PostgreSQL：支持主从复制，高可用
- MySQL：支持主从复制，高可用
```

### 5.2 无主从复制

**技术限制**：

SQLite**不支持主从复制**，无法提供：

- 读写分离
- 数据冗余
- 故障自动切换

**替代方案**：

虽然可以通过应用层实现复制（如Litestream），但：

1. **复杂度高**：需要额外的复制逻辑
2. **性能开销**：应用层复制有性能开销
3. **一致性保证**：不如数据库原生复制可靠

### 5.3 替代方案

**推荐方案**：

- **PostgreSQL**：支持流复制、逻辑复制
- **MySQL**：支持主从复制、组复制
- **分布式数据库**：MongoDB、Cassandra等

---

## 六、不适用场景总结

### 6.1 技术限制总结

**SQLite不适用场景**：

| 场景 | 技术限制 | 推荐替代 |
|------|---------|---------|
| **高并发写** | 仅支持一写多读 | PostgreSQL、MySQL |
| **大规模数据** | 单文件性能瓶颈 | PostgreSQL、MySQL |
| **网络访问** | 无网络协议 | PostgreSQL、MySQL |
| **复杂查询** | 优化器简单 | PostgreSQL、ClickHouse |
| **高可用性** | 单点故障 | PostgreSQL、MySQL |
| **分布式需求** | 单机架构 | MongoDB、Cassandra |

### 6.2 选型建议

**决策流程**：

```text
需要数据库？
├─ 是否需要网络访问？
│  ├─ 是 → PostgreSQL/MySQL
│  └─ 否 → 继续
├─ 是否需要高并发写？
│  ├─ 是 → PostgreSQL/MySQL
│  └─ 否 → 继续
├─ 数据量是否 > 100GB？
│  ├─ 是 → PostgreSQL/MySQL
│  └─ 否 → 继续
└─ SQLite ✅（适合）
```

**选型原则**：

1. **单机应用** → SQLite ✅
2. **网络访问** → PostgreSQL/MySQL
3. **高并发写** → PostgreSQL/MySQL
4. **大规模数据** → PostgreSQL/MySQL
5. **高可用性** → PostgreSQL/MySQL

---

## 🔗 相关资源

- [04.01 适用场景分析](./04.01-适用场景分析.md)
- [04.03 顶级应用案例](./04.03-顶级应用案例.md)
- [05.02 选型决策框架](../05-对比选型/05.02-选型决策框架.md)

---

## 📚 参考资料

- [SQLite适用场景](https://www.sqlite.org/whentouse.html)
- [SQLite不适用场景](https://www.sqlite.org/whentouse.html)
- [数据库选型指南](https://www.sqlite.org/whentouse.html)

---

**最后更新**：2025-11-13
**维护者**：Data-Science Team
