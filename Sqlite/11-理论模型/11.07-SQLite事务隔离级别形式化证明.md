# SQLite事务隔离级别形式化证明

> **创建日期**: 2025-12-04
> **版本**: SQLite 3.47.x
> **难度**: ⭐⭐⭐⭐⭐

---

## SQLite隔离级别总览

```text
SQLite隔离级别与异常
══════════════════════════════════════════════════════════════════════════════

SQLite支持的隔离级别：
┌────────────────────┬─────────┬─────────┬─────────┬─────────┐
│ 隔离级别           │ 脏读    │ 不可重复 │ 幻读    │ 写偏序  │
├────────────────────┼─────────┼─────────┼─────────┼─────────┤
│ Read Uncommitted   │ ✗       │ ✗       │ ✗       │ ✗       │
│ (默认)             │         │         │         │         │
├────────────────────┼─────────┼─────────┼─────────┼─────────┤
│ Serializable       │ ✓       │ ✓       │ ✓       │ ✓       │
│ (WAL模式)          │         │         │         │         │
└────────────────────┴─────────┴─────────┴─────────┴─────────┘

注：SQLite的"Read Uncommitted"实际上因为数据库级锁，不会有真正的脏读。
```

---

## 形式化定义

### 事务与操作

```text
定义1.1 事务
═══════════════════════════════════════════════════════════════

事务 T = (ops, <)
  其中:
  • ops: 操作集合 {r(x), w(x), commit, abort}
  • <: 偏序关系（happens-before）

操作类型:
• r_i(x): 事务T_i读取数据项x
• w_i(x): 事务T_i写入数据项x
• c_i: 事务T_i提交
• a_i: 事务T_i中止
```

### 历史与调度

```text
定义1.2 历史
═══════════════════════════════════════════════════════════════

历史 H = (ops, <_H)
  其中:
  • ops = ⋃_i ops_i (所有事务的操作)
  • <_H: 全序关系（实际执行顺序）

满足:
  1. 如果 op1 <_i op2 in T_i, 则 op1 <_H op2
  2. 每个r_i(x)或w_i(x)后最终是c_i或a_i
```

---

## SQLite默认模式（Rollback Journal）

### 锁状态机

```text
SQLite锁状态转换图
═══════════════════════════════════════════════════════════════

    UNLOCKED ──read──> SHARED
       │                 │
       │                 │ write
       │                 ↓
       │             RESERVED
       │                 │
       │                 │ prepare commit
       │                 ↓
       │             PENDING
       │                 │
       └─────write───────┤
                         │ commit/rollback
                         ↓
                     EXCLUSIVE
                         │
                         │ commit完成
                         ↓
                     UNLOCKED

锁规则:
• SHARED: 可多个读事务持有
• RESERVED: 只有一个写事务持有
• EXCLUSIVE: 独占，阻止所有其他事务
```

### 定理1.1：Rollback模式不允许脏读

```text
定理1.1：Rollback Journal模式下不存在脏读
═══════════════════════════════════════════════════════════════

证明：

假设存在脏读，即:
  T_1: w_1(x) ... a_1 (T_1写x后中止)
  T_2: r_2(x) (T_2读到T_1未提交的x)

SQLite锁协议：
  1. T_1在w_1(x)前必须获得RESERVED锁
  2. RESERVED锁阻止其他事务获得RESERVED或PENDING锁
  3. T_2在r_2(x)前只能获得SHARED锁
  4. SHARED锁只能读取已提交的数据（从journal恢复）

矛盾：
  T_1持有RESERVED锁 → T_2的r_2(x)只能读journal文件（已提交数据）
  → T_2不能读到T_1的未提交数据

∴ 不存在脏读 ∎
```

### 定理1.2：Rollback模式允许不可重复读

```text
定理1.2：Rollback Journal模式下存在不可重复读
═══════════════════════════════════════════════════════════════

反例：

T_1: BEGIN
T_1: SELECT balance FROM accounts WHERE id = 1; -- 读到100
T_2: BEGIN
T_2: UPDATE accounts SET balance = 200 WHERE id = 1;
T_2: COMMIT -- 释放RESERVED锁，提交到磁盘
T_1: SELECT balance FROM accounts WHERE id = 1; -- 读到200（不同！）
T_1: COMMIT

执行时间线：
  t1: T_1: SHARED锁, 读balance=100
  t2: T_2: RESERVED→EXCLUSIVE锁, 写balance=200, 提交
  t3: T_1: SHARED锁, 读balance=200 (T_2已提交)
  t4: T_1: 提交

分析：
  • T_1的两次读取值不同（100 → 200）
  • 原因：SHARED锁不保证快照隔离
  • T_2提交后，数据库状态更新，T_1后续读取看到新值

∴ 存在不可重复读 ∎
```

---

## WAL模式形式化

### MVCC快照

```text
定义2.1 WAL模式快照
═══════════════════════════════════════════════════════════════

快照 S_i = {(x, v, txn_id) | txn_id ≤ start_txn_id_i}
  其中:
  • x: 数据项
  • v: 值
  • txn_id: 写入该值的事务ID
  • start_txn_id_i: T_i开始时的事务ID

可见性规则:
  r_i(x) 读取 max{txn_id | txn_id ≤ start_txn_id_i} 的版本
```

### 定理2.1：WAL模式实现快照隔离

```text
定理2.1：WAL模式提供快照隔离（Snapshot Isolation）
═══════════════════════════════════════════════════════════════

证明：

快照隔离要求:
  1. 事务读操作基于一致快照
  2. 写操作不可见，直到提交

WAL模式实现:
  1. T_i开始时，记录当前最大txn_id = N
  2. T_i的所有读操作只看到 txn_id ≤ N 的版本
  3. T_i的写操作追加到WAL（txn_id = N+1）
  4. T_i提交前，其他事务看不到N+1版本

形式化：
  对于任意T_i, 定义快照S_i = {(x, v, t) | t ≤ start_txn_id_i}

  性质1（一致快照）:
    ∀ r_i(x) in T_i, 读取的v来自S_i
    证明：WAL读取逻辑只返回 t ≤ start_txn_id_i 的版本

  性质2（写隔离）:
    ∀ w_i(x) in T_i, 直到c_i前，不影响其他事务的S_j (j ≠ i)
    证明：写入txn_id = start_txn_id_i + 1 > start_txn_id_j

∴ WAL模式实现快照隔离 ∎
```

### 定理2.2：WAL模式防止幻读

```text
定理2.2：WAL模式下不存在幻读
═══════════════════════════════════════════════════════════════

证明：

幻读定义:
  T_1: r_1(P) → 返回集合S1
  T_2: w_2(x) 使x满足谓词P
  T_2: c_2
  T_1: r_1(P) → 返回集合S2
  要求: S1 ⊆ S2 (出现新行)

WAL模式下:
  1. T_1开始时，快照S_1 = {... | txn_id ≤ N}
  2. T_1的所有r_1(P)都基于S_1
  3. T_2的w_2(x)产生版本 (x, v, N+1)
  4. T_1的第二次r_1(P)仍然基于S_1 (txn_id ≤ N)
  5. (x, v, N+1) ∉ S_1 (因为N+1 > N)
  6. ∴ 两次r_1(P)返回相同结果

∴ 不存在幻读 ∎
```

---

## 写偏序分析

### 定义3.1 写偏序

```text
写偏序（Write Skew）
═══════════════════════════════════════════════════════════════

场景：两个账户，总和需要>0

  T_1: r_1(x) = 100, r_1(y) = 100
  T_1: if (x + y > 100) then w_1(x := 0)

  T_2: r_2(x) = 100, r_2(y) = 100
  T_2: if (x + y > 100) then w_2(y := 0)

  并发执行后: x = 0, y = 0 (违反约束！)

形式化:
  T_1和T_2读取相同快照，分别写不同数据项，
  两个写操作都基于过时的读取结果。
```

### 定理3.1：WAL模式允许写偏序

```text
定理3.1：SQLite WAL模式下存在写偏序
═══════════════════════════════════════════════════════════════

反例（实际SQL）:

-- 初始状态
CREATE TABLE accounts (id INTEGER PRIMARY KEY, balance INTEGER);
INSERT INTO accounts VALUES (1, 100), (2, 100);

-- 约束: SUM(balance) >= 100

-- T_1
BEGIN;
SELECT SUM(balance) FROM accounts; -- 200
UPDATE accounts SET balance = 0 WHERE id = 1;
-- (未提交)

-- T_2 (并发)
BEGIN;
SELECT SUM(balance) FROM accounts; -- 200 (T_1未提交)
UPDATE accounts SET balance = 0 WHERE id = 2;
COMMIT;

-- T_1
COMMIT;

-- 最终: SUM(balance) = 0 (违反约束！)

证明：
  1. T_1和T_2基于同一快照 (start_txn_id相同)
  2. T_1读: balance_1=100, balance_2=100, sum=200 ✓
  3. T_2读: balance_1=100, balance_2=100, sum=200 ✓
  4. T_1写: balance_1 := 0 (不冲突，不同行)
  5. T_2写: balance_2 := 0 (不冲突，不同行)
  6. 两个事务都提交成功
  7. 最终: sum=0 ✗

原因：
  快照隔离只检测 write-write 冲突（同一行）
  不检测 read-write 冲突（约束违反）

∴ 存在写偏序 ∎
```

### 解决方案：显式锁

```sql
-- 方案1：FOR UPDATE锁（PostgreSQL）
-- SQLite不支持

-- 方案2：应用层检测
BEGIN;
SELECT SUM(balance) FROM accounts; -- 200
UPDATE accounts SET balance = 0 WHERE id = 1;
-- 再次检查
SELECT SUM(balance) FROM accounts; -- 如果<100，ROLLBACK
COMMIT;

-- 方案3：CHECK约束（限制，不能跨行）
-- 无法用CHECK约束表达SUM约束

-- 方案4：触发器
CREATE TRIGGER check_sum_constraint BEFORE UPDATE ON accounts
BEGIN
  SELECT CASE
    WHEN (SELECT SUM(balance) FROM accounts) - OLD.balance + NEW.balance < 100
    THEN RAISE(ABORT, 'Constraint violation')
  END;
END;
```

---

## 总结定理

### 定理4.1：SQLite隔离级别分类

```text
定理4.1：SQLite隔离级别与异常
═══════════════════════════════════════════════════════════════

Rollback Journal模式：
  • 隔离级别：介于Read Committed和Repeatable Read之间
  • 防止：脏读
  • 允许：不可重复读、幻读、写偏序
  • 原因：数据库级锁，无MVCC

WAL模式：
  • 隔离级别：快照隔离（Snapshot Isolation）
  • 防止：脏读、不可重复读、幻读
  • 允许：写偏序
  • 原因：MVCC，但无Serializable验证

对比标准SQL隔离级别：
┌─────────────────────┬──────────┬──────────┬────────┬────────┐
│                     │ 脏读     │ 不可重复 │ 幻读   │ 写偏序 │
├─────────────────────┼──────────┼──────────┼────────┼────────┤
│ SQL Serializable    │ 防止     │ 防止     │ 防止   │ 防止   │
│ SQLite WAL          │ 防止     │ 防止     │ 防止   │ 允许   │
│ SQL Repeatable Read │ 防止     │ 防止     │ 允许   │ 允许   │
│ SQLite Rollback     │ 防止     │ 允许     │ 允许   │ 允许   │
│ SQL Read Committed  │ 防止     │ 允许     │ 允许   │ 允许   │
└─────────────────────┴──────────┴──────────┴────────┴────────┘

∎
```

---

## 实验验证

### 实验1：不可重复读（Rollback模式）

```python
import sqlite3
import threading
import time

# 创建数据库
conn = sqlite3.connect('test.db')
conn.execute('PRAGMA journal_mode=DELETE')  # Rollback模式
conn.execute('CREATE TABLE IF NOT EXISTS accounts (id INTEGER PRIMARY KEY, balance INTEGER)')
conn.execute('DELETE FROM accounts')
conn.execute('INSERT INTO accounts VALUES (1, 100)')
conn.commit()
conn.close()

def transaction1():
    conn = sqlite3.connect('test.db')
    print("T1: BEGIN")
    balance1 = conn.execute('SELECT balance FROM accounts WHERE id = 1').fetchone()[0]
    print(f"T1: First read: balance = {balance1}")

    time.sleep(2)  # 等待T2提交

    balance2 = conn.execute('SELECT balance FROM accounts WHERE id = 1').fetchone()[0]
    print(f"T1: Second read: balance = {balance2}")
    print(f"T1: 不可重复读? {balance1 != balance2}")
    conn.close()

def transaction2():
    time.sleep(0.5)
    conn = sqlite3.connect('test.db')
    print("T2: BEGIN")
    conn.execute('UPDATE accounts SET balance = 200 WHERE id = 1')
    conn.commit()
    print("T2: COMMIT")
    conn.close()

t1 = threading.Thread(target=transaction1)
t2 = threading.Thread(target=transaction2)

t1.start()
t2.start()

t1.join()
t2.join()

# 输出:
# T1: BEGIN
# T1: First read: balance = 100
# T2: BEGIN
# T2: COMMIT
# T1: Second read: balance = 200
# T1: 不可重复读? True
```

### 实验2：快照隔离（WAL模式）

```python
import sqlite3
import threading
import time

# 创建数据库
conn = sqlite3.connect('test.db')
conn.execute('PRAGMA journal_mode=WAL')  # WAL模式
conn.execute('CREATE TABLE IF NOT EXISTS accounts (id INTEGER PRIMARY KEY, balance INTEGER)')
conn.execute('DELETE FROM accounts')
conn.execute('INSERT INTO accounts VALUES (1, 100)')
conn.commit()
conn.close()

def transaction1():
    conn = sqlite3.connect('test.db')
    conn.execute('BEGIN')
    print("T1: BEGIN")
    balance1 = conn.execute('SELECT balance FROM accounts WHERE id = 1').fetchone()[0]
    print(f"T1: First read: balance = {balance1}")

    time.sleep(2)  # 等待T2提交

    balance2 = conn.execute('SELECT balance FROM accounts WHERE id = 1').fetchone()[0]
    print(f"T1: Second read: balance = {balance2}")
    print(f"T1: 快照隔离? {balance1 == balance2}")
    conn.commit()
    conn.close()

def transaction2():
    time.sleep(0.5)
    conn = sqlite3.connect('test.db')
    print("T2: BEGIN")
    conn.execute('UPDATE accounts SET balance = 200 WHERE id = 1')
    conn.commit()
    print("T2: COMMIT")
    conn.close()

t1 = threading.Thread(target=transaction1)
t2 = threading.Thread(target=transaction2)

t1.start()
t2.start()

t1.join()
t2.join()

# 输出:
# T1: BEGIN
# T1: First read: balance = 100
# T2: BEGIN
# T2: COMMIT
# T1: Second read: balance = 100  (快照隔离！)
# T1: 快照隔离? True
```

---

**文档版本**: v1.0.0
**最后更新**: 2025-12-04
