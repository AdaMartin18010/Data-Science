# B-Tree算法详解与实现

> **创建日期**：2025-12-04
> **版本**：SQLite 3.47.x
> **难度**：⭐⭐⭐⭐⭐
> **前置知识**：数据结构、算法分析

---

## 📋 概述

本文档深入解析SQLite B-Tree算法的实现细节，包括插入、查找、删除、分裂、合并等核心操作。

---

## 📑 目录

- [B-Tree算法详解与实现](#b-tree算法详解与实现)
  - [📋 概述](#-概述)
  - [📑 目录](#-目录)
  - [一、B-Tree基础](#一b-tree基础)
    - [1.1 B-Tree定义](#11-b-tree定义)
    - [1.2 SQLite B-Tree特点](#12-sqlite-b-tree特点)
  - [二、插入算法详解](#二插入算法详解)
    - [2.1 插入算法流程](#21-插入算法流程)
    - [2.2 页面分裂算法](#22-页面分裂算法)
    - [2.3 分裂代码实现](#23-分裂代码实现)
  - [三、查找算法详解](#三查找算法详解)
    - [3.1 二分查找优化](#31-二分查找优化)
    - [3.2 查找算法实现](#32-查找算法实现)
  - [四、删除算法详解](#四删除算法详解)
    - [4.1 删除流程](#41-删除流程)
    - [4.2 页面合并算法](#42-页面合并算法)
  - [五、性能分析](#五性能分析)
    - [5.1 时间复杂度分析](#51-时间复杂度分析)
    - [5.2 空间复杂度分析](#52-空间复杂度分析)

---

## 一、B-Tree基础

### 1.1 B-Tree定义

```text
B-Tree形式化定义
══════════════════════════════════════════════════════════════════════════════

定义：B-Tree是一个m阶（order）的搜索树，满足：

1. 每个节点最多m个子节点
2. 每个非根非叶节点至少⌈m/2⌉个子节点
3. 根节点至少2个子节点（如果不是叶节点）
4. 所有叶节点在同一层（完美平衡）
5. 非叶节点有k个键，则有k+1个子节点

SQLite B+Tree变体：
• 内部节点只存储键（用于导航）
• 叶子节点存储键+数据（或指向数据的指针）
• 叶子节点链表连接（范围查询优化）

数学表示：
  B-Tree(m) = {
    order: m,
    root: Node,
    height: h
  }

  Node = {
    keys: Key[1..m-1],
    children: Node*[0..m],  // 内部节点
    data: Data[],           // 叶子节点
    is_leaf: Boolean,
    parent: Node*
  }

不变式（Invariants）：
  1. ∀ internal node n: ⌈m/2⌉ - 1 ≤ |n.keys| ≤ m - 1
  2. ∀ leaf node n: ⌈m/2⌉ - 1 ≤ |n.keys| ≤ m - 1
  3. ∀ node n: n.keys是有序的
  4. ∀ internal node n, i: n.children[i].keys < n.keys[i] < n.children[i+1].keys
```

### 1.2 SQLite B-Tree特点

```text
SQLite B-Tree参数
══════════════════════════════════════════════════════════════════════════════

页面大小（Page Size）：
• 默认: 4096字节
• 可选: 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536

B-Tree阶数（Order）：
• 依赖页面大小和键大小
• 典型值: 4KB页面，10字节键 → 约200阶
• 公式: m ≈ (page_size - header_size) / (key_size + pointer_size)

最大高度（Height）：
• 100万记录，m=200: h ≈ log₂₀₀(1000000) ≈ 2.6 → 3层
• 10亿记录，m=200: h ≈ log₂₀₀(1000000000) ≈ 3.9 → 4层

查找复杂度：
• 磁盘IO: O(log_m n) ≈ O(h)
• 内存比较: O(log₂ m) per node
• 总复杂度: O(h × log m)
```

---

## 二、插入算法详解

### 2.1 插入算法流程

```text
B-Tree插入算法完整流程
══════════════════════════════════════════════════════════════════════════════

INSERT INTO table VALUES (key, data)

Step 1: 查找插入位置
┌────────────────────────────────────────────────────────────────────────┐
│ 从根节点开始，沿着树向下查找                                           │
│                                                                        │
│ function findLeafNode(root, key):                                      │
│     node = root                                                        │
│     while (!node.is_leaf):                                             │
│         // 二分查找确定子节点索引                                      │
│         i = binarySearch(node.keys, key)                               │
│         node = node.children[i]                                        │
│     return node                                                        │
│                                                                        │
│ 时间复杂度: O(h × log m)，h为树高，m为阶数                            │
└────────────────────────────────────────────────────────────────────────┘

Step 2: 检查页面空间
┌────────────────────────────────────────────────────────────────────────┐
│ if (leaf.keys.length < m - 1):                                         │
│     // 有空间，直接插入                                                │
│     insertInPlace(leaf, key, data)                                     │
│     return SUCCESS                                                     │
│ else:                                                                  │
│     // 页面已满，需要分裂                                              │
│     goto Step 3                                                        │
└────────────────────────────────────────────────────────────────────────┘

Step 3: 页面分裂（如果需要）
┌────────────────────────────────────────────────────────────────────────┐
│ splitPage(leaf, key, data):                                            │
│     // 1. 创建新页面                                                   │
│     newLeaf = allocatePage()                                           │
│                                                                        │
│     // 2. 临时插入所有键（包括新键）                                   │
│     allKeys = leaf.keys + [key]                                        │
│     allKeys.sort()                                                     │
│                                                                        │
│     // 3. 分配键到两个页面                                             │
│     mid = allKeys.length / 2                                           │
│     leaf.keys = allKeys[0:mid]                                         │
│     newLeaf.keys = allKeys[mid:]                                       │
│                                                                        │
│     // 4. 提升中间键到父节点                                           │
│     promoteKey = allKeys[mid]                                          │
│     insertIntoParent(leaf.parent, promoteKey, newLeaf)                 │
└────────────────────────────────────────────────────────────────────────┘

Step 4: 递归向上分裂
┌────────────────────────────────────────────────────────────────────────┐
│ insertIntoParent(parent, key, newChild):                               │
│     if (parent == NULL):                                               │
│         // 根节点分裂，创建新根                                        │
│         newRoot = createNode([key], [oldRoot, newChild])               │
│         tree.root = newRoot                                            │
│         tree.height++                                                  │
│     else if (parent.keys.length < m - 1):                              │
│         // 父节点有空间                                                │
│         insertInPlace(parent, key, newChild)                           │
│     else:                                                              │
│         // 父节点也满，递归分裂                                        │
│         splitPage(parent, key, newChild)                               │
└────────────────────────────────────────────────────────────────────────┘
```

### 2.2 页面分裂算法

```text
页面分裂可视化
══════════════════════════════════════════════════════════════════════════════

初始状态（m=5，页面满，插入key=25）：

叶子节点（已满，4个键）:
┌────────────────────────────────────────┐
│ Keys: [10, 20, 30, 40]                 │
│ Data: [d1, d2, d3, d4]                 │
│ Next: NULL                             │
└────────────────────────────────────────┘

插入key=25后（临时状态，5个键）:
┌────────────────────────────────────────┐
│ Keys: [10, 20, 25, 30, 40]             │
│ Data: [d1, d2, d5, d3, d4]             │
└────────────────────────────────────────┘

分裂后（mid=2，提升key=25）:

      父节点
      ┌──────────┐
      │ Keys: 25 │
      └─┬──────┬─┘
        │      │
   ┌────┘      └────┐
   │                │
   ▼                ▼
 左页面            右页面
┌──────────────┐  ┌──────────────┐
│ Keys: 10, 20 │  │ Keys: 30, 40 │
│ Data: d1, d2 │  │ Data: d3, d4 │
│ Next: ────────────>             │
└──────────────┘  └──────────────┘

══════════════════════════════════════════════════════════════════════════════

分裂策略选择：

策略1: 中间分裂（Median Split）
• 左页面: ⌊(m-1)/2⌋个键
• 右页面: ⌈(m-1)/2⌉个键
• 优点: 平衡性最好
• SQLite默认策略

策略2: 偏斜分裂（Skewed Split）
• 顺序插入时，新页面分配更多空间
• 左页面: 25%满
• 右页面: 75%满
• 优点: 减少后续分裂次数

策略3: 自适应分裂
• 根据插入模式动态调整
• 检测顺序/随机插入
• SQLite在某些情况下使用
```

### 2.3 分裂代码实现

```c
/* B-Tree页面分裂实现（简化版） */

int sqlite3BtreeInsert(
  BtCursor *pCur,     /* 游标 */
  const void *pKey,   /* 键 */
  i64 nKey,          /* 键长度 */
  const void *pData,  /* 数据 */
  int nData          /* 数据长度 */
) {
  int rc;
  MemPage *pPage = pCur->pPage;

  // 1. 检查页面是否需要分裂
  if (pageFull(pPage, nKey, nData)) {
    rc = balance(pCur);  // 分裂或重新平衡
    if (rc != SQLITE_OK) return rc;
  }

  // 2. 在页面中插入
  rc = insertCell(pPage, pCur->ix, pKey, nKey, pData, nData);

  return rc;
}

/* 页面平衡（包括分裂） */
int balance(BtCursor *pCur) {
  MemPage *pPage = pCur->pPage;
  MemPage *pParent = pPage->pParent;

  // 1. 检查是否可以与兄弟页面合并空间
  if (pParent && tryBalance(pPage, pParent)) {
    return SQLITE_OK;  // 成功平衡，无需分裂
  }

  // 2. 必须分裂
  return splitPage(pPage, pCur->ix);
}

/* 页面分裂核心算法 */
int splitPage(MemPage *pPage, int iInsert) {
  MemPage *pNew;      /* 新页面 */
  int nCell;          /* 原页面单元格数 */
  int splitPoint;     /* 分裂点 */
  int rc;

  // 1. 分配新页面
  rc = allocateBtreePage(&pNew);
  if (rc != SQLITE_OK) return rc;

  // 2. 确定分裂点
  nCell = pPage->nCell;
  if (iInsert < nCell / 2) {
    // 插入在前半部分，均匀分裂
    splitPoint = nCell / 2;
  } else if (iInsert > nCell - nCell / 4) {
    // 插入在末尾，偏斜分裂（顺序插入优化）
    splitPoint = nCell - 2;
  } else {
    // 中间插入，均匀分裂
    splitPoint = nCell / 2;
  }

  // 3. 移动单元格到新页面
  for (int i = splitPoint; i < nCell; i++) {
    u8 *pCell = findCell(pPage, i);
    insertCell(pNew, i - splitPoint, pCell, getCellSize(pCell));
  }

  // 4. 从原页面删除已移动的单元格
  pPage->nCell = splitPoint;

  // 5. 更新父节点（插入分裂键）
  if (pPage->pParent == NULL) {
    // 根节点分裂，创建新根
    MemPage *pNewRoot;
    allocateBtreePage(&pNewRoot);
    pNewRoot->nCell = 1;
    // 设置分裂键和两个子节点
    insertCell(pNewRoot, 0, dividerKey, ...);
    pNewRoot->children[0] = pPage;
    pNewRoot->children[1] = pNew;
    // 更新根指针
    pBt->root = pNewRoot;
  } else {
    // 递归插入到父节点
    insertIntoParent(pPage->pParent, dividerKey, pNew);
  }

  return SQLITE_OK;
}

/* 插入单元格到页面 */
int insertCell(
  MemPage *pPage,
  int idx,
  const void *pCell,
  int nCell
) {
  u8 *pData;
  int gap;

  // 1. 检查空间
  if (pPage->nFree < nCell + 2) {
    return SQLITE_FULL;  // 页面满
  }

  // 2. 在单元格指针数组中插入指针
  pData = pPage->aData;
  gap = CELL_PTR_OFFSET(pPage) + idx * 2;
  memmove(&pData[gap+2], &pData[gap], (pPage->nCell - idx) * 2);

  // 3. 在页面内容区域追加单元格数据
  int cellOffset = pPage->cellOffset - nCell;
  memcpy(&pData[cellOffset], pCell, nCell);
  put2byte(&pData[gap], cellOffset);

  // 4. 更新页面元数据
  pPage->nCell++;
  pPage->nFree -= (nCell + 2);
  pPage->cellOffset -= nCell;

  return SQLITE_OK;
}
```

---

## 三、查找算法详解

### 3.1 二分查找优化

```c
/* B-Tree单元格二分查找 */
int cellCompare(
  MemPage *pPage,
  int iCell,
  const void *pKey,
  int nKey
) {
  u8 *pCell = findCell(pPage, iCell);
  i64 cellKey;

  // 解析单元格获取键
  getCellKey(pCell, &cellKey);

  // 比较
  if (cellKey < nKey) return -1;
  if (cellKey > nKey) return 1;
  return 0;
}

/* 二分查找实现 */
int findCellIndex(MemPage *pPage, const void *pKey, int nKey) {
  int left = 0;
  int right = pPage->nCell - 1;
  int mid, cmp;

  while (left <= right) {
    mid = (left + right) / 2;
    cmp = cellCompare(pPage, mid, pKey, nKey);

    if (cmp == 0) {
      return mid;  // 找到
    } else if (cmp < 0) {
      left = mid + 1;  // 在右半部分
    } else {
      right = mid - 1;  // 在左半部分
    }
  }

  return -(left + 1);  // 未找到，返回插入位置（负数编码）
}

/* 优化：提前退出 */
int findCellIndexOptimized(MemPage *pPage, const void *pKey, int nKey) {
  int n = pPage->nCell;

  // 特殊情况：空页面
  if (n == 0) return -1;

  // 特殊情况：插入在末尾（顺序插入优化）
  int cmpLast = cellCompare(pPage, n - 1, pKey, nKey);
  if (cmpLast < 0) return -n;  // 大于所有键
  if (cmpLast == 0) return n - 1;

  // 特殊情况：插入在开头
  int cmpFirst = cellCompare(pPage, 0, pKey, nKey);
  if (cmpFirst > 0) return -1;  // 小于所有键
  if (cmpFirst == 0) return 0;

  // 一般情况：二分查找
  return binarySearchGeneral(pPage, pKey, nKey);
}
```

### 3.2 查找算法实现

```c
/* B-Tree查找算法 */
int sqlite3BtreeMoveto(
  BtCursor *pCur,
  const void *pKey,
  i64 nKey,
  int bias,  // 偏向（0=精确，-1=小于等于，1=大于等于）
  int *pRes  // 结果（0=找到，<0=小于，>0=大于）
) {
  MemPage *pPage;
  int rc;
  int idx;

  // 1. 从根节点开始
  pPage = pCur->pBt->pPage1;  // 根页面

  // 2. 向下查找直到叶子节点
  while (!pPage->leaf) {
    // 在内部节点中查找
    idx = findCellIndex(pPage, pKey, nKey);
    if (idx < 0) {
      idx = -(idx + 1);  // 解码插入位置
    }

    // 移动到子节点
    pPage = getChildPage(pPage, idx);
  }

  // 3. 在叶子节点中查找
  idx = findCellIndex(pPage, pKey, nKey);

  if (idx >= 0) {
    // 找到
    pCur->pPage = pPage;
    pCur->ix = idx;
    *pRes = 0;
    return SQLITE_OK;
  } else {
    // 未找到
    idx = -(idx + 1);
    pCur->pPage = pPage;
    pCur->ix = idx + bias;  // 根据偏向调整位置
    *pRes = (bias == 0) ? 1 : 0;
    return SQLITE_OK;
  }
}
```

---

## 四、删除算法详解

### 4.1 删除流程

```text
B-Tree删除算法流程
══════════════════════════════════════════════════════════════════════════════

DELETE FROM table WHERE key = ?

Step 1: 查找要删除的键
┌────────────────────────────────────────────────────────────────────────┐
│ 使用查找算法定位键的位置                                               │
│ 如果未找到，返回NOT_FOUND                                              │
└────────────────────────────────────────────────────────────────────────┘

Step 2: 删除单元格
┌────────────────────────────────────────────────────────────────────────┐
│ function deleteCell(page, idx):                                        │
│     // 1. 移动单元格指针数组                                           │
│     memmove(&page.cellPtrs[idx],                                       │
│             &page.cellPtrs[idx+1],                                     │
│             (page.nCell - idx - 1) * 2)                                │
│     page.nCell--                                                       │
│                                                                        │
│     // 2. 标记单元格空间为freelist                                     │
│     addToFreeList(page, cellOffset, cellSize)                          │
│     page.nFree += cellSize + 2                                         │
└────────────────────────────────────────────────────────────────────────┘

Step 3: 检查页面填充率
┌────────────────────────────────────────────────────────────────────────┐
│ if (page.nCell < ⌈m/2⌉ - 1):                                           │
│     // 页面未达到最小填充率，需要合并或重新分配                        │
│     goto Step 4                                                        │
│ else:                                                                  │
│     return SUCCESS  // 删除完成                                        │
└────────────────────────────────────────────────────────────────────────┘

Step 4: 页面合并或重新分配
┌────────────────────────────────────────────────────────────────────────┐
│ if (sibling.nCell + page.nCell <= m - 1):                              │
│     // 可以合并                                                        │
│     mergePage(page, sibling)                                           │
│ else:                                                                  │
│     // 重新分配键                                                      │
│     redistributeKeys(page, sibling)                                    │
└────────────────────────────────────────────────────────────────────────┘
```

### 4.2 页面合并算法

```c
/* 页面合并实现 */
int mergePage(MemPage *pLeft, MemPage *pRight) {
  int i;

  // 1. 将右页面的所有单元格移动到左页面
  for (i = 0; i < pRight->nCell; i++) {
    u8 *pCell = findCell(pRight, i);
    int nCell = getCellSize(pCell);
    insertCell(pLeft, pLeft->nCell, pCell, nCell);
  }

  // 2. 更新叶子节点链表
  if (pLeft->leaf) {
    pLeft->pNext = pRight->pNext;
  }

  // 3. 从父节点删除分隔键
  MemPage *pParent = pLeft->pParent;
  int idxInParent = findChildIndex(pParent, pRight);
  deleteCell(pParent, idxInParent - 1);  // 删除分隔键

  // 4. 释放右页面
  freePage(pRight);

  // 5. 递归检查父节点
  if (pParent->nCell < MIN_CELLS) {
    return balance(createCursor(pParent));
  }

  return SQLITE_OK;
}

/* 键重新分配（避免合并） */
int redistributeKeys(MemPage *pLeft, MemPage *pRight) {
  int totalCells = pLeft->nCell + pRight->nCell;
  int newLeftCells = totalCells / 2;
  int i;

  // 创建临时数组存储所有键
  Cell *allCells = malloc(totalCells * sizeof(Cell));

  // 1. 收集所有单元格
  for (i = 0; i < pLeft->nCell; i++) {
    copyCellToTemp(&allCells[i], pLeft, i);
  }
  for (i = 0; i < pRight->nCell; i++) {
    copyCellToTemp(&allCells[pLeft->nCell + i], pRight, i);
  }

  // 2. 清空两个页面
  clearPage(pLeft);
  clearPage(pRight);

  // 3. 重新分配单元格
  for (i = 0; i < newLeftCells; i++) {
    insertCellFromTemp(pLeft, i, &allCells[i]);
  }
  for (i = newLeftCells; i < totalCells; i++) {
    insertCellFromTemp(pRight, i - newLeftCells, &allCells[i]);
  }

  // 4. 更新父节点的分隔键
  updateDividerKey(pLeft->pParent, &allCells[newLeftCells]);

  free(allCells);
  return SQLITE_OK;
}
```

---

## 五、性能分析

### 5.1 时间复杂度分析

```text
B-Tree操作时间复杂度分析
══════════════════════════════════════════════════════════════════════════════

操作          │ 最坏情况      │ 平均情况      │ 最好情况
─────────────┼──────────────┼──────────────┼────────────────
查找（Search）│ O(h log m)   │ O(h log m)   │ O(1) [根节点]
插入（Insert）│ O(h log m)   │ O(h log m)   │ O(log m) [无分裂]
删除（Delete）│ O(h log m)   │ O(h log m)   │ O(log m) [无合并]
范围查询      │ O(h log m+k) │ O(h log m+k) │ O(k) [连续]

其中：
• h = 树高 = O(log_m n)
• m = B-Tree阶数（每页单元格数）
• n = 总记录数
• k = 范围查询返回的记录数

══════════════════════════════════════════════════════════════════════════════

实际性能（SQLite 3.47.x）：

数据集大小与树高关系（m=200, 4KB页面）：
┌──────────────┬────────┬──────────────────────────────────┐
│ 记录数       │ 树高   │ 查找磁盘IO次数                   │
├──────────────┼────────┼──────────────────────────────────┤
│ 1000         │ 2      │ 2次（根+叶子）                   │
│ 100万        │ 3      │ 3次                              │
│ 10亿         │ 4      │ 4次                              │
│ 1万亿        │ 5      │ 5次                              │
└──────────────┴────────┴──────────────────────────────────┘

关键观察：
• 即使10亿记录，也只需4次IO
• B-Tree的扁平化特性（大m值）极大减少树高
• 页面缓存进一步减少实际IO（通常根节点在缓存中）

══════════════════════════════════════════════════════════════════════════════

分裂/合并开销：

插入操作分裂概率：
• 假设页面75%满为稳态
• 分裂概率 ≈ 1 / (m × 0.25) ≈ 0.5%（m=200时）
• 即每200次插入触发1次分裂

分裂开销：
• 分配新页面: O(1)
• 移动单元格: O(m)
• 更新父节点: O(log m)（递归可能向上传播）
• 总开销: O(m + h log m)

均摊分析：
• 每次插入: O(log m) + (1/200) × O(m) = O(log m)
• 因为m >> log m，分裂开销可忽略
• 因此插入操作均摊O(log m)
```

### 5.2 空间复杂度分析

```text
B-Tree空间复杂度分析
══════════════════════════════════════════════════════════════════════════════

总空间：S = S_data + S_index + S_overhead

1. 数据空间（Data Space）
   S_data = n × avg_record_size
   • n = 记录数
   • avg_record_size = 键大小 + 值大小

2. 索引空间（Index Space）
   S_index = n_internal_nodes × page_size

   内部节点数估算：
   n_internal_nodes = n / (m × fill_factor) × (1 + 1/m + 1/m² + ...)
                    ≈ n / (m × fill_factor) × m/(m-1)
                    ≈ n / ((m-1) × fill_factor)

   例如：n=100万，m=200，fill_factor=0.75
   n_internal_nodes ≈ 1000000 / (199 × 0.75) ≈ 6700页
   S_index ≈ 6700 × 4KB ≈ 27MB

3. 开销空间（Overhead）
   每页开销：
   • 页面头部: 8-12字节
   • 单元格指针数组: 2字节 × 单元格数
   • 碎片空间: 平均10-20%

   总开销：S_overhead ≈ 0.15 × (S_data + S_index)

空间效率：
• 填充率: 75-85%（B-Tree特性）
• 索引开销: 约2-5%（相对数据大小）
• 总空间效率: 70-80%

══════════════════════════════════════════════════════════════════════════════

示例计算（100万用户记录）：

假设：
• 记录大小: 200字节（id + name + email + ...）
• 页面大小: 4KB
• B-Tree阶数: m = 200

数据空间:
S_data = 1000000 × 200 = 200MB

索引空间:
叶子节点数 = 1000000 / (200 × 0.75) ≈ 6667页 ≈ 27MB
内部节点数 = 6667 / 200 ≈ 34页 ≈ 140KB
S_index ≈ 27MB

总空间:
S_total = 200MB + 27MB ≈ 227MB
空间效率 = 200 / 227 ≈ 88%

结论：B-Tree空间效率高，索引开销小
```

---

**算法详解完成！**

本文档提供了：

- ✅ B-Tree形式化定义
- ✅ 插入算法完整流程（含分裂）
- ✅ 查找算法优化实现
- ✅ 删除算法（含合并）
- ✅ C源码级实现
- ✅ 时间复杂度详细分析
- ✅ 空间复杂度计算示例

---

**文档版本**: v1.0.0
**最后更新**: 2025-12-04
**维护者**: SQLite Knowledge Base Team
