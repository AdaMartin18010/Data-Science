# 算法复杂度理论：SQLite操作的时间与空间复杂度

> **创建日期**：2025-01-15
> **最后更新**：2025-01-15
> **版本**：SQLite 3.31+ 至 3.47.x

---

## 📋 概述

本文档从算法复杂度理论视角深入分析SQLite各种操作的时间复杂度和空间复杂度，包括查询优化、B-Tree操作、并发控制和存储操作的复杂度分析。

---

## 📑 目录

- [算法复杂度理论：SQLite操作的时间与空间复杂度](#算法复杂度理论sqlite操作的时间与空间复杂度)
  - [📋 概述](#-概述)
  - [📑 目录](#-目录)
  - [3. 📊 思维导图](#3--思维导图)
  - [4. 复杂度理论基础](#4-复杂度理论基础)
    - [4.1. 复杂度定义](#41-复杂度定义)
    - [4.2. 复杂度表示法](#42-复杂度表示法)
    - [4.3. 复杂度分析](#43-复杂度分析)
  - [5. 查询操作复杂度](#5-查询操作复杂度)
    - [5.1. 选择查询复杂度](#51-选择查询复杂度)
    - [5.2. 连接查询复杂度](#52-连接查询复杂度)
    - [5.3. 聚合查询复杂度](#53-聚合查询复杂度)
    - [5.4. 排序查询复杂度](#54-排序查询复杂度)
  - [6. B-Tree操作复杂度](#6-b-tree操作复杂度)
    - [6.1. B-Tree查找复杂度](#61-b-tree查找复杂度)
    - [6.2. B-Tree插入复杂度](#62-b-tree插入复杂度)
    - [6.3. B-Tree删除复杂度](#63-b-tree删除复杂度)
    - [6.4. B-Tree范围查询复杂度](#64-b-tree范围查询复杂度)
  - [7. 并发控制复杂度](#7-并发控制复杂度)
    - [7.1. 锁操作复杂度](#71-锁操作复杂度)
    - [7.2. 事务管理复杂度](#72-事务管理复杂度)
    - [7.3. WAL操作复杂度](#73-wal操作复杂度)
  - [8. 存储操作复杂度](#8-存储操作复杂度)
    - [8.1. 页面操作复杂度](#81-页面操作复杂度)
    - [8.2. 缓存操作复杂度](#82-缓存操作复杂度)
    - [8.3. 磁盘I/O复杂度](#83-磁盘io复杂度)
  - [9. 复杂度理论总结](#9-复杂度理论总结)
    - [9.1. 复杂度总结表](#91-复杂度总结表)
    - [9.2. 复杂度优化策略](#92-复杂度优化策略)
    - [9.3. 实际性能考虑](#93-实际性能考虑)
    - [9.4. 复杂度验证代码](#94-复杂度验证代码)
  - [10. 🔗 相关资源](#10--相关资源)
  - [11. 📚 参考资料](#11--参考资料)

---

## 3. 📊 思维导图

```mermaid
mindmap
  root((算法复杂度理论))
    复杂度理论基础
      复杂度定义
        时间复杂度
        空间复杂度
        最坏情况
        平均情况
        最好情况
      复杂度表示法
        大O表示法
        Θ表示法
        Ω表示法
      复杂度分析
        递归分析
        迭代分析
        摊还分析
    查询操作复杂度
      选择查询
        全表扫描
        O(n)
        索引查找
        O(log n)
        覆盖索引
        O(log n)
      连接查询
        嵌套循环
        O(n × m)
        哈希连接
        O(n + m)
        索引连接
        O(n × log m)
      聚合查询
        全表扫描
        O(n)
        索引扫描
        O(n)
        分组聚合
        O(n log n)
      排序查询
        内存排序
        O(n log n)
        外部排序
        O(n log n)
     B-Tree操作复杂度
      查找操作
        单键查找
        O(log n)
        范围查找
        O(log n + k)
      插入操作
        插入
        O(log n)
        分裂
        O(1)
      删除操作
        删除
        O(log n)
        合并
        O(1)
      范围查询
        范围扫描
        O(log n + k)
    并发控制复杂度
      锁操作
        获取锁
        O(1)
        释放锁
        O(1)
        锁等待
        O(1)
      事务管理
        开始事务
        O(1)
        提交事务
        O(k)
        回滚事务
        O(k)
      WAL操作
        WAL写入
        O(1)
        Checkpoint
        O(k)
    存储操作复杂度
      页面操作
        页面读取
        O(1)
        页面写入
        O(1)
      缓存操作
        缓存命中
        O(1)
        缓存未命中
        O(1)
      磁盘I/O
        顺序读取
        O(1)
        随机读取
        O(1)
```

---

## 4. 复杂度理论基础

### 4.1. 复杂度定义

**定义1（时间复杂度）**：算法的时间复杂度是算法执行时间随输入规模增长的变化趋势。

**形式化表示**：

```text
时间复杂度定义：
  T(n) = 算法在输入规模为n时的执行时间

复杂度函数：
  f(n) = O(g(n)) 当且仅当
    ∃c > 0, n₀ > 0: ∀n > n₀, T(n) ≤ c·g(n)
```

**定义2（空间复杂度）**：算法的空间复杂度是算法使用的存储空间随输入规模增长的变化趋势。

**形式化表示**：

```text
空间复杂度定义：
  S(n) = 算法在输入规模为n时使用的存储空间

复杂度函数：
  f(n) = O(g(n)) 当且仅当
    ∃c > 0, n₀ > 0: ∀n > n₀, S(n) ≤ c·g(n)
```

### 4.2. 复杂度表示法

**大O表示法（Big-O Notation）**：

```text
O(f(n)): 上界，最坏情况复杂度

常见复杂度：
  O(1): 常数时间
  O(log n): 对数时间
  O(n): 线性时间
  O(n log n): 线性对数时间
  O(n²): 平方时间
  O(2ⁿ): 指数时间
```

**Θ表示法（Theta Notation）**：

```text
Θ(f(n)): 紧界，平均情况复杂度

定义：
  f(n) = Θ(g(n)) 当且仅当
    f(n) = O(g(n)) ∧ f(n) = Ω(g(n))
```

**Ω表示法（Omega Notation）**：

```text
Ω(f(n)): 下界，最好情况复杂度

定义：
  f(n) = Ω(g(n)) 当且仅当
    ∃c > 0, n₀ > 0: ∀n > n₀, T(n) ≥ c·g(n)
```

### 4.3. 复杂度分析

**递归分析**：

```text
递归关系式：
  T(n) = a·T(n/b) + f(n)

主定理（Master Theorem）：
  如果 f(n) = O(n^c)，其中 c < log_b(a):
    T(n) = Θ(n^log_b(a))

  如果 f(n) = Θ(n^c)，其中 c = log_b(a):
    T(n) = Θ(n^c log n)

  如果 f(n) = Ω(n^c)，其中 c > log_b(a):
    T(n) = Θ(f(n))
```

**摊还分析**：

```text
摊还复杂度：
  考虑一系列操作的平均复杂度

摊还分析技术：
  1. 聚合分析：分析n个操作的总复杂度
  2. 记账方法：为操作分配摊还成本
  3. 势能方法：使用势能函数分析
```

---

## 5. 查询操作复杂度

### 5.1. 选择查询复杂度

**全表扫描**：

```text
复杂度分析：
  时间复杂度：O(n)
  空间复杂度：O(1)

其中：
  n = 表中的行数

算法：
  for each row in table:
    if condition(row):
      return row

复杂度证明：
  - 最坏情况：扫描所有n行
  - 时间复杂度：O(n)
  - 空间复杂度：O(1)（只存储当前行）
```

**索引查找**：

```text
复杂度分析：
  时间复杂度：O(log n)
  空间复杂度：O(1)

其中：
  n = 索引中的键数

算法：
  Search(index, key):
    node = root
    while node is not leaf:
      node = find_child(node, key)
    return search_leaf(node, key)

复杂度证明：
  - B-Tree高度：h = ⌈log_m(n)⌉，其中m是分支因子
  - 每层比较：O(m)
  - 总比较：O(m × h) = O(m × log_m(n)) = O(log n)
```

**覆盖索引查询**：

```text
复杂度分析：
  时间复杂度：O(log n)
  空间复杂度：O(1)

优势：
  - 无需回表
  - 只访问索引
  - 减少I/O操作
```

### 5.2. 连接查询复杂度

**嵌套循环连接**：

```text
复杂度分析：
  时间复杂度：O(n × m)
  空间复杂度：O(1)

其中：
  n = 左表行数
  m = 右表行数

算法：
  for each row1 in table1:
    for each row2 in table2:
      if join_condition(row1, row2):
        return (row1, row2)

优化：
  - 使用索引：O(n × log m)
  - 小表驱动：min(O(n × m), O(m × n))
```

**哈希连接**：

```text
复杂度分析：
  时间复杂度：O(n + m)
  空间复杂度：O(min(n, m))

算法：
  1. 构建哈希表：O(min(n, m))
  2. 探测哈希表：O(max(n, m))
  3. 总复杂度：O(n + m)

SQLite支持：
  - SQLite 3.30+ 支持哈希连接
  - 适用于大表连接
```

**索引连接**：

```text
复杂度分析：
  时间复杂度：O(n × log m)
  空间复杂度：O(1)

其中：
  n = 左表行数
  m = 右表行数（有索引）

算法：
  for each row1 in table1:
    result = index_lookup(table2, row1.key)
    if result:
      return (row1, result)
```

### 5.3. 聚合查询复杂度

**全表扫描聚合**：

```text
复杂度分析：
  时间复杂度：O(n)
  空间复杂度：O(1)

算法：
  result = initial_value
  for each row in table:
    result = aggregate(result, row.value)
  return result

示例：
  COUNT(*): O(n)
  SUM(column): O(n)
  AVG(column): O(n)
```

**分组聚合**：

```text
复杂度分析：
  时间复杂度：O(n log n)
  空间复杂度：O(k)

其中：
  n = 行数
  k = 分组数

算法：
  1. 排序或哈希分组：O(n log n) 或 O(n)
  2. 聚合每组：O(n)
  3. 总复杂度：O(n log n)

SQLite实现：
  - 使用哈希表：O(n) 平均情况
  - 使用排序：O(n log n) 最坏情况
```

### 5.4. 排序查询复杂度

**内存排序**：

```text
复杂度分析：
  时间复杂度：O(n log n)
  空间复杂度：O(n)

算法：
  - 快速排序：O(n log n) 平均，O(n²) 最坏
  - 归并排序：O(n log n) 最坏
  - 堆排序：O(n log n) 最坏

SQLite实现：
  - 使用快速排序
  - 平均复杂度：O(n log n)
```

**外部排序**：

```text
复杂度分析：
  时间复杂度：O(n log n)
  空间复杂度：O(B)

其中：
  B = 可用缓冲区大小

算法：
  1. 分段排序：O(n log B)
  2. 多路归并：O(n log (n/B))
  3. 总复杂度：O(n log n)

SQLite实现：
  - 当数据超过内存时使用外部排序
  - 复杂度：O(n log n)
```

---

## 6. B-Tree操作复杂度

### 6.1. B-Tree查找复杂度

**单键查找**：

```text
复杂度分析：
  时间复杂度：O(log n)
  空间复杂度：O(1)

其中：
  n = B-Tree中的键数

算法：
  Search(node, key):
    if node is leaf:
      return binary_search(node.keys, key)
    else:
      child = find_child(node, key)
      return Search(child, key)

复杂度证明：
  - B-Tree高度：h = ⌈log_m(n)⌉
  - 每层操作：O(m)（m是分支因子）
  - 总操作：O(m × h) = O(log n)
```

**范围查找**：

```text
复杂度分析：
  时间复杂度：O(log n + k)
  空间复杂度：O(1)

其中：
  n = B-Tree中的键数
  k = 结果数量

算法：
  1. 定位起始键：O(log n)
  2. 顺序扫描k个键：O(k)
  3. 总复杂度：O(log n + k)
```

### 6.2. B-Tree插入复杂度

**插入操作**：

```text
复杂度分析：
  时间复杂度：O(log n)
  空间复杂度：O(log n)

算法：
  Insert(node, key, value):
    1. 查找插入位置：O(log n)
    2. 插入键值：O(1)
    3. 如果节点满，分裂：O(1)
    4. 递归向上分裂：O(log n) 最坏情况

复杂度证明：
  - 查找：O(log n)
  - 插入：O(1)
  - 分裂：O(1) 每次，最多O(log n)次
  - 总复杂度：O(log n)
```

**分裂操作**：

```text
复杂度分析：
  时间复杂度：O(1)
  空间复杂度：O(1)

算法：
  Split(node):
    1. 创建新节点：O(1)
    2. 移动一半键值：O(m)（m是节点容量）
    3. 更新父节点：O(1)

注意：
  - 虽然移动键值是O(m)，但m是常数（节点容量）
  - 因此分裂操作是O(1)
```

### 6.3. B-Tree删除复杂度

**删除操作**：

```text
复杂度分析：
  时间复杂度：O(log n)
  空间复杂度：O(log n)

算法：
  Delete(node, key):
    1. 查找键：O(log n)
    2. 删除键：O(1)
    3. 如果节点键数不足，合并：O(1)
    4. 递归向上合并：O(log n) 最坏情况

复杂度证明：
  - 查找：O(log n)
  - 删除：O(1)
  - 合并：O(1) 每次，最多O(log n)次
  - 总复杂度：O(log n)
```

### 6.4. B-Tree范围查询复杂度

**范围扫描**：

```text
复杂度分析：
  时间复杂度：O(log n + k)
  空间复杂度：O(1)

其中：
  n = B-Tree中的键数
  k = 范围内的键数

算法：
  1. 定位范围起始：O(log n)
  2. 顺序扫描范围内的键：O(k)
  3. 总复杂度：O(log n + k)

优势：
  - 利用B-Tree的有序性
  - 避免全表扫描
```

---

## 7. 并发控制复杂度

### 7.1. 锁操作复杂度

**获取锁**：

```text
复杂度分析：
  时间复杂度：O(1)
  空间复杂度：O(1)

算法：
  AcquireLock(lock, mode):
    if lock.available(mode):
      lock.acquire(mode)
      return Success
    else:
      return Busy

复杂度证明：
  - 锁状态检查：O(1)
  - 锁获取：O(1)
  - 总复杂度：O(1)
```

**锁等待**：

```text
复杂度分析：
  时间复杂度：O(1) 平均，O(∞) 最坏
  空间复杂度：O(1)

算法：
  AcquireLockWithTimeout(lock, mode, timeout):
    start = current_time()
    while current_time() - start < timeout:
      if AcquireLock(lock, mode) == Success:
        return Success
      sleep(short_interval)
    return Timeout

复杂度分析：
  - 平均情况：O(1)（锁很快释放）
  - 最坏情况：O(timeout)（等待超时）
```

### 7.2. 事务管理复杂度

**开始事务**：

```text
复杂度分析：
  时间复杂度：O(1)
  空间复杂度：O(1)

操作：
  - 创建事务上下文：O(1)
  - 初始化状态：O(1)
  - 总复杂度：O(1)
```

**提交事务**：

```text
复杂度分析：
  时间复杂度：O(k)
  空间复杂度：O(1)

其中：
  k = 事务中的操作数

操作：
  1. 验证所有操作：O(k)
  2. 写入日志：O(k)
  3. 提交：O(1)
  4. 总复杂度：O(k)
```

**回滚事务**：

```text
复杂度分析：
  时间复杂度：O(k)
  空间复杂度：O(1)

其中：
  k = 事务中的操作数

操作：
  1. 撤销所有操作：O(k)
  2. 释放资源：O(k)
  3. 总复杂度：O(k)
```

### 7.3. WAL操作复杂度

**WAL写入**：

```text
复杂度分析：
  时间复杂度：O(1)
  空间复杂度：O(1)

操作：
  - 追加到WAL文件：O(1)（顺序写入）
  - 更新WAL索引：O(1)
  - 总复杂度：O(1)

优势：
  - 顺序写入，性能好
  - 无需随机I/O
```

**Checkpoint操作**：

```text
复杂度分析：
  时间复杂度：O(k)
  空间复杂度：O(1)

其中：
  k = WAL文件中的帧数

操作：
  1. 读取WAL帧：O(k)
  2. 写入数据库页：O(k)
  3. 同步：O(1)
  4. 总复杂度：O(k)
```

---

## 8. 存储操作复杂度

### 8.1. 页面操作复杂度

**页面读取**：

```text
复杂度分析：
  时间复杂度：O(1)
  空间复杂度：O(1)

操作：
  - 计算页面地址：O(1)
  - 读取页面：O(1)（固定大小）
  - 总复杂度：O(1)
```

**页面写入**：

```text
复杂度分析：
  时间复杂度：O(1)
  空间复杂度：O(1)

操作：
  - 计算页面地址：O(1)
  - 写入页面：O(1)（固定大小）
  - 总复杂度：O(1)
```

### 8.2. 缓存操作复杂度

**缓存命中**：

```text
复杂度分析：
  时间复杂度：O(1)
  空间复杂度：O(1)

操作：
  - 哈希查找：O(1) 平均
  - 返回页面：O(1)
  - 总复杂度：O(1)
```

**缓存未命中**：

```text
复杂度分析：
  时间复杂度：O(1)
  空间复杂度：O(1)

操作：
  1. 从磁盘读取：O(1)（页面大小固定）
  2. 插入缓存：O(1)
  3. 总复杂度：O(1)
```

### 8.3. 磁盘I/O复杂度

**顺序读取**：

```text
复杂度分析：
  时间复杂度：O(k)
  空间复杂度：O(1)

其中：
  k = 读取的页面数

操作：
  - 顺序读取k个页面：O(k)
  - 总复杂度：O(k)

优势：
  - 顺序I/O性能好
  - 预读优化
```

**随机读取**：

```text
复杂度分析：
  时间复杂度：O(k)
  空间复杂度：O(1)

其中：
  k = 读取的页面数

操作：
  - 随机读取k个页面：O(k)
  - 总复杂度：O(k)

注意：
  - 虽然复杂度相同，但随机I/O性能差
  - 需要磁盘寻道，实际时间更长
```

---

## 9. 复杂度理论总结

### 9.1. 复杂度总结表

| 操作类型 | 时间复杂度 | 空间复杂度 | 说明 |
|---------|-----------|-----------|------|
| **查询操作** ||||
| 全表扫描 | O(n) | O(1) | n = 行数 |
| 索引查找 | O(log n) | O(1) | n = 索引键数 |
| 覆盖索引 | O(log n) | O(1) | 无需回表 |
| 嵌套循环连接 | O(n × m) | O(1) | n, m = 表行数 |
| 哈希连接 | O(n + m) | O(min(n,m)) | SQLite 3.30+ |
| 分组聚合 | O(n log n) | O(k) | k = 分组数 |
| 排序 | O(n log n) | O(n) | 内存排序 |
| **B-Tree操作** ||||
| 查找 | O(log n) | O(1) | n = 键数 |
| 插入 | O(log n) | O(log n) | 最坏情况 |
| 删除 | O(log n) | O(log n) | 最坏情况 |
| 范围查询 | O(log n + k) | O(1) | k = 结果数 |
| **并发控制** ||||
| 获取锁 | O(1) | O(1) | 平均情况 |
| 提交事务 | O(k) | O(1) | k = 操作数 |
| 回滚事务 | O(k) | O(1) | k = 操作数 |
| WAL写入 | O(1) | O(1) | 顺序写入 |
| Checkpoint | O(k) | O(1) | k = WAL帧数 |
| **存储操作** ||||
| 页面读取 | O(1) | O(1) | 固定大小 |
| 页面写入 | O(1) | O(1) | 固定大小 |
| 缓存操作 | O(1) | O(1) | 平均情况 |

### 9.2. 复杂度优化策略

**优化原则**：

1. **使用索引**：O(n) → O(log n)
2. **覆盖索引**：减少回表，提升性能
3. **批量操作**：减少事务开销
4. **WAL模式**：提升并发性能
5. **缓存优化**：减少磁盘I/O

### 9.3. 实际性能考虑

**复杂度 vs 实际性能**：

- 复杂度是理论分析，实际性能受多种因素影响
- 常数因子：O(n)可能比O(log n)快（如果n很小）
- 缓存效应：缓存命中显著提升性能
- I/O成本：磁盘I/O比内存操作慢得多

### 9.4. 复杂度验证代码

**查询操作复杂度验证**：

```python
import sqlite3
import time
import statistics
import math

def test_query_complexity():
    """验证查询操作复杂度"""
    conn = sqlite3.connect(':memory:')
    cursor = conn.cursor()

# 创建测试表
    cursor.execute('CREATE TABLE test (id INTEGER PRIMARY KEY, value TEXT)')

# 插入不同规模的数据
    sizes = [100, 1000, 10000, 100000]
    times_full_scan = []
    times_index_lookup = []

    for size in sizes:
# 插入数据
        cursor.executemany('INSERT INTO test (value) VALUES (?)',
                          [(f'value_{i}',) for i in range(size)])

# 测试全表扫描 O(n)
        start = time.perf_counter()
        cursor.execute('SELECT * FROM test WHERE value = ?', ('value_0',))
        cursor.fetchone()
        times_full_scan.append(time.perf_counter() - start)

# 创建索引
        cursor.execute('CREATE INDEX idx_value ON test(value)')

# 测试索引查找 O(log n)
        start = time.perf_counter()
        cursor.execute('SELECT * FROM test WHERE value = ?', ('value_0',))
        cursor.fetchone()
        times_index_lookup.append(time.perf_counter() - start)

# 清理
        cursor.execute('DROP TABLE test')
        cursor.execute('CREATE TABLE test (id INTEGER PRIMARY KEY, value TEXT)')

# 验证复杂度
# 全表扫描应该是O(n)，时间应该线性增长
    ratio_full = times_full_scan[-1] / times_full_scan[0]
    size_ratio = sizes[-1] / sizes[0]
    print(f"全表扫描时间比: {ratio_full:.2f}, 数据量比: {size_ratio:.2f}")
    assert ratio_full > size_ratio * 0.5, "全表扫描不符合O(n)"

# 索引查找应该是O(log n)，时间应该对数增长
    ratio_index = times_index_lookup[-1] / times_index_lookup[0]
    log_ratio = math.log(sizes[-1]) / math.log(sizes[0])
    print(f"索引查找时间比: {ratio_index:.2f}, log(n)比: {log_ratio:.2f}")
    assert ratio_index < log_ratio * 2, "索引查找不符合O(log n)"

    conn.close()
    print("✅ 查询操作复杂度验证通过")

# 运行测试
if __name__ == '__main__':
    test_query_complexity()
```

**B-Tree操作复杂度验证**：

```python
import sqlite3
import time
import math

def test_btree_complexity():
    """验证B-Tree操作复杂度"""
    conn = sqlite3.connect(':memory:')
    cursor = conn.cursor()

    cursor.execute('CREATE TABLE test (id INTEGER PRIMARY KEY, value TEXT)')

# 测试插入复杂度 O(log n)
    sizes = [100, 1000, 10000, 100000]
    insert_times = []

    for size in sizes:
        start = time.perf_counter()
        cursor.executemany('INSERT INTO test (value) VALUES (?)',
                          [(f'value_{i}',) for i in range(size)])
        conn.commit()
        insert_times.append(time.perf_counter() - start)

# 清理
        cursor.execute('DELETE FROM test')

# 验证插入复杂度
# 总插入时间应该是O(n log n)，但单次插入是O(log n)
    avg_insert_times = [t / s for t, s in zip(insert_times, sizes)]
    ratio = avg_insert_times[-1] / avg_insert_times[0]
    log_ratio = math.log(sizes[-1]) / math.log(sizes[0])

    print(f"平均插入时间比: {ratio:.2f}, log(n)比: {log_ratio:.2f}")
    assert ratio < log_ratio * 3, "插入操作不符合O(log n)"

# 测试查找复杂度
    cursor.executemany('INSERT INTO test (value) VALUES (?)',
                      [(f'value_{i}',) for i in range(10000)])

    lookup_times = []
    for _ in range(1000):
        start = time.perf_counter()
        cursor.execute('SELECT * FROM test WHERE id = ?', (5000,))
        cursor.fetchone()
        lookup_times.append(time.perf_counter() - start)

    avg_lookup = sum(lookup_times) / len(lookup_times)
    print(f"平均查找时间: {avg_lookup*1000:.3f}ms")
    assert avg_lookup < 0.001, "查找操作应该很快（O(log n)）"

    conn.close()
    print("✅ B-Tree操作复杂度验证通过")

# 运行测试
if __name__ == '__main__':
    test_btree_complexity()
```

**并发控制复杂度验证**：

```python
import sqlite3
import threading
import time

def test_concurrency_complexity():
    """验证并发控制复杂度"""
    conn = sqlite3.connect(':memory:')
    cursor = conn.cursor()

    cursor.execute('CREATE TABLE test (id INTEGER PRIMARY KEY, value INTEGER)')
    cursor.execute('PRAGMA journal_mode=WAL')  # 启用WAL模式

# 测试并发写入
    def writer(thread_id, count):
        local_conn = sqlite3.connect(':memory:')
        local_cursor = local_conn.cursor()
        for i in range(count):
            try:
                local_cursor.execute('INSERT INTO test (value) VALUES (?)', (i,))
                local_conn.commit()
            except sqlite3.OperationalError:
                time.sleep(0.001)  # 等待锁

# 测试并发读取
    def reader(thread_id, count):
        local_conn = sqlite3.connect(':memory:')
        local_cursor = local_conn.cursor()
        for _ in range(count):
            local_cursor.execute('SELECT COUNT(*) FROM test')
            local_cursor.fetchone()

# 并发测试
    start = time.perf_counter()
    threads = []

# 1个写线程
    t1 = threading.Thread(target=writer, args=(1, 100))
    threads.append(t1)

# 5个读线程
    for i in range(5):
        t = threading.Thread(target=reader, args=(i, 100))
        threads.append(t)

    for t in threads:
        t.start()

    for t in threads:
        t.join()

    elapsed = time.perf_counter() - start
    print(f"并发操作时间: {elapsed:.3f}s")

# 验证WAL模式下的并发性能
    assert elapsed < 1.0, "并发操作应该很快（WAL模式）"

    conn.close()
    print("✅ 并发控制复杂度验证通过")

# 运行测试
if __name__ == '__main__':
    test_concurrency_complexity()
```

---

## 10. 🔗 相关资源

- [01.03 存储引擎](../01-核心架构/01.03-存储引擎.md)
- [03.01 性能特征分析](../03-性能优化/03.01-性能特征分析.md)
- [06.02 B-Tree正确性证明](../06-形式化理论/06.02-B-Tree正确性证明.md)

---

## 11. 📚 参考资料

- 《算法导论》
- 《数据结构与算法分析》
- 《数据库系统实现》

---

**最后更新**：2025-01-15
**维护者**：Data-Science Team
