# SQL标准对齐：SQL-92, SQL:2016, SQL:2023

> **创建日期**：2025-11-13
> **最后更新**：2025-11-13
> **版本**：SQLite 3.31+ 至 3.47+

---

## 📋 概述

本文档详细说明SQLite与SQL标准的对齐情况，包括SQL-92、SQL:2016和SQL:2023标准的支持情况。

---

## 📑 目录

- [SQL标准对齐：SQL-92, SQL:2016, SQL:2023](#sql标准对齐sql-92-sql2016-sql2023)
  - [📋 概述](#-概述)
  - [📑 目录](#-目录)
  - [一、SQL-92标准支持情况](#一sql-92标准支持情况)
    - [1.1 数据定义语言（DDL）](#11-数据定义语言ddl)
    - [1.2 数据操作语言（DML）](#12-数据操作语言dml)
    - [1.3 事务控制](#13-事务控制)
    - [1.4 约束与完整性](#14-约束与完整性)
    - [1.5 SQL-92偏差说明](#15-sql-92偏差说明)
      - [偏差1：动态类型系统](#偏差1动态类型系统)
      - [偏差2：ALTER TABLE限制](#偏差2alter-table限制)
      - [偏差3：日期时间函数差异](#偏差3日期时间函数差异)
      - [偏差4：字符串函数差异](#偏差4字符串函数差异)
  - [二、SQL:2016标准对齐](#二sql2016标准对齐)
    - [2.1 SQL:2016 JSON支持对比](#21-sql2016-json支持对比)
    - [2.2 窗口函数示例（SQL:2016标准）](#22-窗口函数示例sql2016标准)
    - [2.3 CTE（公共表表达式）支持](#23-cte公共表表达式支持)
    - [2.4 UPSERT支持（INSERT ... ON CONFLICT）](#24-upsert支持insert--on-conflict)
    - [2.5 生成列（Generated Columns）](#25-生成列generated-columns)
  - [三、SQL:2023标准前瞻](#三sql2023标准前瞻)
    - [3.1 SQL:2023 STRICT表模式对齐](#31-sql2023-strict表模式对齐)
    - [3.2 多表UPDATE/DELETE增强](#32-多表updatedelete增强)
    - [3.3 其他SQL:2023特性状态](#33-其他sql2023特性状态)
  - [📊 标准支持总结](#-标准支持总结)
    - [支持程度](#支持程度)
    - [主要偏差](#主要偏差)
    - [优势特性](#优势特性)
  - [🔗 相关资源](#-相关资源)
  - [📚 参考资料](#-参考资料)
  - [四、兼容性测试用例](#四兼容性测试用例)
    - [4.1 SQL-92兼容性测试](#41-sql-92兼容性测试)
      - [测试用例1：基本DDL操作](#测试用例1基本ddl操作)
      - [测试用例2：基本DML操作](#测试用例2基本dml操作)
      - [测试用例3：事务控制](#测试用例3事务控制)
    - [4.2 SQL:2016兼容性测试](#42-sql2016兼容性测试)
      - [测试用例4：窗口函数](#测试用例4窗口函数)
      - [测试用例5：CTE和递归CTE](#测试用例5cte和递归cte)
      - [测试用例6：UPSERT](#测试用例6upsert)
    - [4.3 SQL:2023兼容性测试](#43-sql2023兼容性测试)
      - [测试用例7：STRICT表模式](#测试用例7strict表模式)
  - [五、兼容性检查清单](#五兼容性检查清单)
    - [5.1 SQL-92兼容性检查](#51-sql-92兼容性检查)
    - [5.2 SQL:2016兼容性检查](#52-sql2016兼容性检查)
    - [5.3 SQL:2023兼容性检查](#53-sql2023兼容性检查)
    - [5.4 已知限制检查](#54-已知限制检查)
  - [六、迁移建议](#六迁移建议)
    - [6.1 从其他数据库迁移到SQLite](#61-从其他数据库迁移到sqlite)
    - [6.2 从SQLite迁移到其他数据库](#62-从sqlite迁移到其他数据库)

---

## 一、SQL-92标准支持情况

SQLite实现了**SQL-92标准的核心子集**，包括：

### 1.1 数据定义语言（DDL）

| SQL-92特性 | SQLite支持 | 说明 |
|-----------|----------|------|
| CREATE TABLE | ✅ 完全支持 | 支持列约束、主键、外键、CHECK约束 |
| ALTER TABLE | ⚠️ 部分支持 | 仅支持ADD COLUMN、RENAME TABLE，不支持DROP COLUMN |
| CREATE INDEX | ✅ 完全支持 | 支持唯一索引、复合索引、部分索引 |
| CREATE VIEW | ✅ 完全支持 | 支持可更新视图（WITH CHECK OPTION） |
| DROP TABLE/INDEX/VIEW | ✅ 完全支持 | |

### 1.2 数据操作语言（DML）

| SQL-92特性 | SQLite支持 | 说明 |
|-----------|----------|------|
| SELECT | ✅ 完全支持 | 支持子查询、UNION、EXCEPT、INTERSECT |
| INSERT | ✅ 完全支持 | 支持INSERT OR REPLACE、INSERT OR IGNORE |
| UPDATE | ✅ 完全支持 | 支持多表UPDATE（3.33+） |
| DELETE | ✅ 完全支持 | 支持多表DELETE（3.33+） |

### 1.3 事务控制

| SQL-92特性 | SQLite支持 | 说明 |
|-----------|----------|------|
| BEGIN TRANSACTION | ✅ 完全支持 | 支持DEFERRED/IMMEDIATE/EXCLUSIVE |
| COMMIT | ✅ 完全支持 | |
| ROLLBACK | ✅ 完全支持 | |
| SAVEPOINT | ✅ 完全支持 | SQLite 3.6.8+ |

### 1.4 约束与完整性

| SQL-92特性 | SQLite支持 | 说明 |
|-----------|----------|------|
| PRIMARY KEY | ✅ 完全支持 | INTEGER PRIMARY KEY = rowid别名 |
| FOREIGN KEY | ✅ 完全支持 | 需PRAGMA foreign_keys=ON |
| UNIQUE | ✅ 完全支持 | |
| CHECK | ✅ 完全支持 | |
| NOT NULL | ✅ 完全支持 | |

### 1.5 SQL-92偏差说明

#### 偏差1：动态类型系统

SQL-92要求严格的静态类型，SQLite采用动态类型（存储类系统）

**SQL-92标准（严格类型）**：

```sql
CREATE TABLE t(id INTEGER, name VARCHAR(50));
INSERT INTO t VALUES ('123', 456); -- 错误：类型不匹配
```

**SQLite（动态类型）**：

```sql
CREATE TABLE t(id INTEGER, name TEXT);
INSERT INTO t VALUES ('123', 456); -- 允许：'123'存储为TEXT，456存储为INTEGER
```

**类型亲和性（Type Affinity）**：

SQLite通过类型亲和性提供部分类型检查：

```sql
-- INTEGER亲和性：优先存储为INTEGER
CREATE TABLE t1(id INTEGER, count INT, num NUMERIC);
INSERT INTO t1 VALUES (1.5, 2.7, 3.9); -- 全部存储为INTEGER: 1, 2, 3

-- TEXT亲和性：优先存储为TEXT
CREATE TABLE t2(name VARCHAR(50), title CHAR(100));
INSERT INTO t2 VALUES (123, 456); -- 存储为TEXT: '123', '456'

-- REAL亲和性：优先存储为REAL
CREATE TABLE t3(price REAL, value FLOAT, amount DOUBLE);
INSERT INTO t3 VALUES ('3.14', '2.71', '1.41'); -- 存储为REAL: 3.14, 2.71, 1.41
```

#### 偏差2：ALTER TABLE限制

SQL-92支持完整的ALTER TABLE，SQLite仅支持有限操作

**SQL-92标准**：

```sql
ALTER TABLE t DROP COLUMN name; -- SQLite不支持
ALTER TABLE t MODIFY COLUMN id BIGINT; -- SQLite不支持
ALTER TABLE t ALTER COLUMN name SET DEFAULT 'unknown'; -- SQLite不支持
```

**SQLite支持**：

```sql
ALTER TABLE t ADD COLUMN email TEXT; -- ✅ 支持
ALTER TABLE t RENAME TO t_new; -- ✅ 支持
ALTER TABLE t RENAME COLUMN old_name TO new_name; -- ✅ 支持（3.25.0+）
```

**SQLite ALTER TABLE限制的解决方案**：

```sql
-- 删除列（需要重建表）
BEGIN TRANSACTION;

-- 1. 创建新表（不包含要删除的列）
CREATE TABLE t_new AS SELECT id, email FROM t;

-- 2. 删除旧表
DROP TABLE t;

-- 3. 重命名新表
ALTER TABLE t_new RENAME TO t;

COMMIT;
```

#### 偏差3：日期时间函数差异

SQL-92定义了标准日期时间函数，SQLite使用自定义函数

**SQL-92标准**：

```sql
SELECT CURRENT_DATE, CURRENT_TIME, CURRENT_TIMESTAMP;
SELECT EXTRACT(YEAR FROM date_col) FROM t;
```

**SQLite实现**：

```sql
-- SQLite日期时间函数（兼容SQL-92）
SELECT date('now'), time('now'), datetime('now');
SELECT strftime('%Y', date_col) FROM t;

-- SQLite扩展函数
SELECT date('now', '+1 day'); -- 日期计算
SELECT julianday('2024-01-01'); -- 儒略日
```

#### 偏差4：字符串函数差异

SQL-92定义了标准字符串函数，SQLite使用略有不同的函数名

**SQL-92标准**：

```sql
SELECT SUBSTRING(name, 1, 5) FROM t;
SELECT POSITION('x' IN name) FROM t;
```

**SQLite实现**：

```sql
-- SQLite字符串函数（兼容SQL-92）
SELECT substr(name, 1, 5) FROM t; -- 注意：SUBSTRING → substr
SELECT instr(name, 'x') FROM t; -- 注意：POSITION → instr

-- SQLite扩展函数
SELECT printf('Name: %s, Age: %d', name, age) FROM t;
```

---

## 二、SQL:2016标准对齐

SQL:2016引入了JSON支持、窗口函数等特性，SQLite的兼容情况：

| SQL:2016特性 | SQLite支持 | 版本要求 | 说明 |
|------------|----------|---------|------|
| **JSON函数** | ✅ 完全支持 | 3.9.0+ | JSON1扩展，RFC 7159兼容 |
| **窗口函数** | ✅ 完全支持 | 3.25.0+ | ROW_NUMBER, RANK, DENSE_RANK, LAG, LEAD等 |
| **CTE（WITH子句）** | ✅ 完全支持 | 3.8.3+ | 支持递归CTE（WITH RECURSIVE） |
| **UPSERT** | ✅ 完全支持 | 3.24.0+ | INSERT ... ON CONFLICT |
| **生成列** | ✅ 完全支持 | 3.31.0+ | GENERATED ALWAYS AS ... STORED/VIRTUAL |
| **布尔类型** | ⚠️ 部分支持 | 3.23.0+ | 存储为INTEGER (0/1)，无原生BOOLEAN类型 |

### 2.1 SQL:2016 JSON支持对比

**SQL:2016标准JSON函数**：

```sql
SELECT
    JSON_EXTRACT(data, '$.name') as name,  -- SQLite: json_extract()
    JSON_ARRAY_LENGTH(data, '$.items') as count,  -- SQLite: json_array_length()
    JSON_TYPE(data, '$.status') as type  -- SQLite: json_type()
FROM documents;
```

**SQLite JSON1扩展（完全兼容SQL:2016）**：

```sql
SELECT
    json_extract(config, '$.network.ip') as ip,
    json_array_length(config, '$.sensors') as sensor_count
FROM device_configs
WHERE json_type(config, '$.network') = 'object';
```

### 2.2 窗口函数示例（SQL:2016标准）

**SQL:2016窗口函数（SQLite 3.25.0+完全支持）**：

```sql
SELECT
    employee_id,
    department_id,
    salary,
    ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary DESC) as rank,
    AVG(salary) OVER (PARTITION BY department_id) as dept_avg,
    LAG(salary, 1) OVER (ORDER BY employee_id) as prev_salary
FROM employees;
```

**SQLite支持的窗口函数完整列表**：

| 窗口函数 | SQL:2016标准 | SQLite支持 | 说明 |
|---------|------------|----------|------|
| **ROW_NUMBER()** | ✅ | ✅ 3.25.0+ | 行号 |
| **RANK()** | ✅ | ✅ 3.25.0+ | 排名（允许并列） |
| **DENSE_RANK()** | ✅ | ✅ 3.25.0+ | 密集排名 |
| **PERCENT_RANK()** | ✅ | ✅ 3.25.0+ | 百分比排名 |
| **CUME_DIST()** | ✅ | ✅ 3.25.0+ | 累积分布 |
| **NTILE(n)** | ✅ | ✅ 3.25.0+ | 分桶函数 |
| **LAG(expr, offset)** | ✅ | ✅ 3.25.0+ | 前N行值 |
| **LEAD(expr, offset)** | ✅ | ✅ 3.25.0+ | 后N行值 |
| **FIRST_VALUE(expr)** | ✅ | ✅ 3.25.0+ | 窗口第一行值 |
| **LAST_VALUE(expr)** | ✅ | ✅ 3.25.0+ | 窗口最后一行值 |
| **NTH_VALUE(expr, n)** | ✅ | ✅ 3.25.0+ | 窗口第N行值 |
| **聚合函数 OVER()** | ✅ | ✅ 3.25.0+ | COUNT, SUM, AVG等 |

**窗口函数高级示例**：

```sql
-- 示例1：计算移动平均
SELECT
    date,
    sales,
    AVG(sales) OVER (
        ORDER BY date
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) as moving_avg_3day
FROM daily_sales;

-- 示例2：计算累计总和
SELECT
    month,
    revenue,
    SUM(revenue) OVER (
        ORDER BY month
        ROWS UNBOUNDED PRECEDING
    ) as cumulative_revenue
FROM monthly_revenue;

-- 示例3：分组排名
SELECT
    product_id,
    category,
    sales,
    RANK() OVER (PARTITION BY category ORDER BY sales DESC) as category_rank,
    PERCENT_RANK() OVER (PARTITION BY category ORDER BY sales DESC) as percentile
FROM product_sales;
```

### 2.3 CTE（公共表表达式）支持

**SQL:2016标准CTE（SQLite 3.8.3+完全支持）**：

```sql
-- 简单CTE
WITH sales_summary AS (
    SELECT
        product_id,
        SUM(quantity) as total_quantity,
        SUM(amount) as total_amount
    FROM orders
    GROUP BY product_id
)
SELECT
    p.name,
    s.total_quantity,
    s.total_amount
FROM products p
JOIN sales_summary s ON p.id = s.product_id;
```

**递归CTE（WITH RECURSIVE）**：

```sql
-- 示例：生成数字序列
WITH RECURSIVE numbers(n) AS (
    SELECT 1
    UNION ALL
    SELECT n + 1 FROM numbers WHERE n < 100
)
SELECT n FROM numbers;

-- 示例：树形结构查询（组织架构）
WITH RECURSIVE org_tree AS (
    -- 根节点
    SELECT id, name, parent_id, 0 as level
    FROM employees
    WHERE parent_id IS NULL

    UNION ALL

    -- 递归查询子节点
    SELECT e.id, e.name, e.parent_id, ot.level + 1
    FROM employees e
    JOIN org_tree ot ON e.parent_id = ot.id
)
SELECT * FROM org_tree ORDER BY level, id;
```

### 2.4 UPSERT支持（INSERT ... ON CONFLICT）

**SQL:2016标准UPSERT（SQLite 3.24.0+完全支持）**：

```sql
-- 基本UPSERT语法
INSERT INTO users (id, name, email)
VALUES (1, 'Alice', 'alice@example.com')
ON CONFLICT(id) DO UPDATE SET
    name = excluded.name,
    email = excluded.email;

-- 忽略冲突（不更新）
INSERT INTO users (id, name, email)
VALUES (1, 'Alice', 'alice@example.com')
ON CONFLICT(id) DO NOTHING;

-- 多列唯一约束
INSERT INTO user_emails (user_id, email, verified)
VALUES (1, 'alice@example.com', 0)
ON CONFLICT(user_id, email) DO UPDATE SET
    verified = excluded.verified;
```

### 2.5 生成列（Generated Columns）

**SQL:2016标准生成列（SQLite 3.31.0+完全支持）**：

```sql
-- STORED生成列（存储计算值）
CREATE TABLE products (
    id INTEGER PRIMARY KEY,
    price REAL NOT NULL,
    quantity INTEGER NOT NULL,
    total_value REAL GENERATED ALWAYS AS (price * quantity) STORED
);

-- VIRTUAL生成列（不存储，按需计算）
CREATE TABLE users (
    id INTEGER PRIMARY KEY,
    first_name TEXT NOT NULL,
    last_name TEXT NOT NULL,
    full_name TEXT GENERATED ALWAYS AS (first_name || ' ' || last_name) VIRTUAL
);

-- 使用生成列
INSERT INTO products (price, quantity) VALUES (10.5, 3);
-- total_value自动计算为31.5

SELECT * FROM users;
-- full_name自动计算为 "John Doe"
```

---

## 三、SQL:2023标准前瞻

SQL:2023标准的新特性与SQLite的兼容性：

| SQL:2023特性 | SQLite状态 | 说明 |
|------------|----------|------|
| **JSON5支持** | 🔄 规划中 | 当前仅支持RFC 7159 JSON |
| **多表UPDATE/DELETE增强** | ✅ 已支持 | SQLite 3.33.0+ |
| **STRICT表模式** | ✅ 已支持 | SQLite 3.37.0+，符合SQL:2023类型严格性要求 |
| **分区表** | ❌ 不支持 | SQLite无原生分区表，需应用层实现 |
| **并行查询** | 🔄 实验性 | SQLite 3.38.0+实验性支持 |

### 3.1 SQL:2023 STRICT表模式对齐

**SQL:2023要求：严格类型检查**

```sql
CREATE TABLE users STRICT (
    id INTEGER PRIMARY KEY,
    age INTEGER NOT NULL,
    email TEXT UNIQUE
);
```

**SQL:2023标准行为（SQLite 3.37+）**：

```sql
INSERT INTO users VALUES (1, 'twenty', 'test@example.com');
-- 错误：age必须是INTEGER类型，不能是TEXT

-- 正确用法
INSERT INTO users VALUES (1, 20, 'test@example.com'); -- ✅
```

**STRICT模式类型检查规则**：

```sql
-- STRICT模式：严格类型检查
CREATE TABLE products STRICT (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL,
    price REAL NOT NULL,
    quantity INTEGER NOT NULL,
    active INTEGER NOT NULL CHECK(active IN (0, 1))
);

-- 类型检查示例
INSERT INTO products VALUES (1, 'Widget', 10.5, 5, 1); -- ✅ 正确
INSERT INTO products VALUES (2, 'Gadget', '9.99', 3, 1); -- ❌ 错误：price必须是REAL
INSERT INTO products VALUES (3, 'Tool', 8.0, 'two', 1); -- ❌ 错误：quantity必须是INTEGER
INSERT INTO products VALUES (4, 123, 7.5, 2, 1); -- ❌ 错误：name必须是TEXT

-- 非STRICT模式：动态类型（向后兼容）
CREATE TABLE products_legacy (
    id INTEGER PRIMARY KEY,
    name TEXT,
    price REAL,
    quantity INTEGER
);

INSERT INTO products_legacy VALUES (1, 'Widget', '10.5', '5'); -- ✅ 允许（类型转换）
```

### 3.2 多表UPDATE/DELETE增强

**SQL:2023多表UPDATE（SQLite 3.33.0+支持）**：

```sql
-- 多表UPDATE语法
UPDATE orders o
SET o.status = 'shipped'
FROM customers c
WHERE o.customer_id = c.id
  AND c.country = 'USA'
  AND o.order_date < date('now', '-30 days');

-- SQLite实现（3.33.0+）
UPDATE orders
SET status = 'shipped'
FROM customers
WHERE orders.customer_id = customers.id
  AND customers.country = 'USA'
  AND orders.order_date < date('now', '-30 days');
```

**SQL:2023多表DELETE（SQLite 3.33.0+支持）**：

```sql
-- 多表DELETE语法
DELETE o
FROM orders o
JOIN customers c ON o.customer_id = c.id
WHERE c.status = 'inactive'
  AND o.order_date < date('now', '-1 year');

-- SQLite实现（3.33.0+）
DELETE FROM orders
WHERE EXISTS (
    SELECT 1 FROM customers
    WHERE customers.id = orders.customer_id
      AND customers.status = 'inactive'
) AND orders.order_date < date('now', '-1 year');
```

### 3.3 其他SQL:2023特性状态

**JSON5支持**：

```sql
-- SQL:2023 JSON5标准（SQLite当前不支持）
-- JSON5允许：
-- - 单引号字符串
-- - 尾随逗号
-- - 注释
-- - 未引用的键名

-- SQLite当前仅支持RFC 7159 JSON
SELECT json_extract('{"name": "Alice", "age": 30}', '$.name'); -- ✅ 支持
```

**分区表**：

```sql
-- SQL:2023分区表（SQLite不支持）
-- PostgreSQL示例：
-- CREATE TABLE orders (
--     id INTEGER,
--     order_date DATE
-- ) PARTITION BY RANGE (order_date);

-- SQLite替代方案：应用层分区
-- 1. 按日期创建多个表
CREATE TABLE orders_2024_01 (...);
CREATE TABLE orders_2024_02 (...);

-- 2. 使用视图统一查询
CREATE VIEW orders AS
SELECT * FROM orders_2024_01
UNION ALL
SELECT * FROM orders_2024_02;
```

**并行查询**：

```sql
-- SQL:2023并行查询（SQLite 3.38.0+实验性支持）
-- 需要编译时启用SQLITE_ENABLE_PARALLEL_QUERY

-- 并行查询示例（实验性）
PRAGMA parallel_query = ON;
SELECT COUNT(*) FROM large_table WHERE condition;
```

---

## 📊 标准支持总结

### 支持程度

- **SQL-92核心子集**：✅ 90%+支持
- **SQL:2016关键特性**：✅ 80%+支持
- **SQL:2023前瞻特性**：🔄 部分支持

### 主要偏差

1. **动态类型系统**：与SQL-92静态类型要求不同
2. **ALTER TABLE限制**：不支持DROP COLUMN、MODIFY COLUMN
3. **分区表**：无原生支持
4. **并行查询**：仅实验性支持

### 优势特性

1. **JSON1扩展**：完全兼容SQL:2016 JSON标准
2. **窗口函数**：完整支持SQL:2016窗口函数
3. **STRICT表模式**：符合SQL:2023类型严格性要求
4. **UPSERT**：支持INSERT ... ON CONFLICT

---

## 🔗 相关资源

- [SQLite官方文档 - SQL标准](https://www.sqlite.org/lang.html)
- [ISO/IEC 9075 SQL标准](https://www.iso.org/standard/76583.html)
- [SQL:2016标准文档](https://www.iso.org/standard/76583.html)
- [SQL:2023标准文档](https://www.iso.org/standard/76583.html)

---

## 📚 参考资料

- [SQLite官方文档](https://www.sqlite.org/docs.html)
- [SQL标准对比表](https://www.sqlite.org/lang.html)
- [SQL:2016特性列表](https://en.wikipedia.org/wiki/SQL:2016)

---

## 四、兼容性测试用例

### 4.1 SQL-92兼容性测试

#### 测试用例1：基本DDL操作

```sql
-- 测试CREATE TABLE
CREATE TABLE test_table (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL,
    age INTEGER,
    email TEXT UNIQUE
);

-- 测试CREATE INDEX
CREATE INDEX idx_name ON test_table(name);
CREATE UNIQUE INDEX idx_email ON test_table(email);

-- 测试CREATE VIEW
CREATE VIEW test_view AS
SELECT id, name, age FROM test_table WHERE age > 18;

-- 验证
SELECT sql FROM sqlite_master WHERE type='table' AND name='test_table';
SELECT sql FROM sqlite_master WHERE type='index' AND name='idx_name';
SELECT sql FROM sqlite_master WHERE type='view' AND name='test_view';
```

#### 测试用例2：基本DML操作

```sql
-- 测试INSERT
INSERT INTO test_table (name, age, email) VALUES ('Alice', 25, 'alice@example.com');
INSERT INTO test_table (name, age, email) VALUES ('Bob', 30, 'bob@example.com');

-- 测试SELECT（子查询、UNION）
SELECT * FROM test_table WHERE age > 20;
SELECT name FROM test_table
UNION
SELECT name FROM test_table WHERE age < 25;

-- 测试UPDATE
UPDATE test_table SET age = 26 WHERE name = 'Alice';

-- 测试DELETE
DELETE FROM test_table WHERE age < 20;
```

#### 测试用例3：事务控制

```sql
-- 测试事务
BEGIN TRANSACTION;
INSERT INTO test_table (name, age, email) VALUES ('Charlie', 28, 'charlie@example.com');
COMMIT;

-- 测试回滚
BEGIN TRANSACTION;
INSERT INTO test_table (name, age, email) VALUES ('David', 32, 'david@example.com');
ROLLBACK;

-- 测试SAVEPOINT
BEGIN TRANSACTION;
SAVEPOINT sp1;
INSERT INTO test_table (name, age, email) VALUES ('Eve', 27, 'eve@example.com');
ROLLBACK TO sp1;
COMMIT;
```

### 4.2 SQL:2016兼容性测试

#### 测试用例4：窗口函数

```sql
-- 创建测试数据
CREATE TABLE employees (
    id INTEGER PRIMARY KEY,
    name TEXT,
    department TEXT,
    salary REAL
);

INSERT INTO employees (name, department, salary) VALUES
    ('Alice', 'Sales', 50000),
    ('Bob', 'Sales', 60000),
    ('Charlie', 'Engineering', 80000),
    ('David', 'Engineering', 90000);

-- 测试窗口函数
SELECT
    name,
    department,
    salary,
    ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) as rank,
    AVG(salary) OVER (PARTITION BY department) as dept_avg
FROM employees;
```

#### 测试用例5：CTE和递归CTE

```sql
-- 测试简单CTE
WITH sales AS (
    SELECT department, SUM(salary) as total
    FROM employees
    GROUP BY department
)
SELECT * FROM sales;

-- 测试递归CTE
WITH RECURSIVE numbers(n) AS (
    SELECT 1
    UNION ALL
    SELECT n + 1 FROM numbers WHERE n < 10
)
SELECT n FROM numbers;
```

#### 测试用例6：UPSERT

```sql
-- 测试UPSERT
INSERT INTO employees (id, name, department, salary)
VALUES (1, 'Alice', 'Sales', 55000)
ON CONFLICT(id) DO UPDATE SET
    name = excluded.name,
    salary = excluded.salary;
```

### 4.3 SQL:2023兼容性测试

#### 测试用例7：STRICT表模式

```sql
-- 测试STRICT模式
CREATE TABLE products STRICT (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL,
    price REAL NOT NULL,
    quantity INTEGER NOT NULL
);

-- 正确插入
INSERT INTO products (name, price, quantity) VALUES ('Widget', 10.5, 5); -- ✅

-- 错误插入（应失败）
INSERT INTO products (name, price, quantity) VALUES ('Gadget', '9.99', 3); -- ❌
```

---

## 五、兼容性检查清单

### 5.1 SQL-92兼容性检查

- [ ] **DDL操作**
  - [ ] CREATE TABLE支持所有标准约束
  - [ ] CREATE INDEX支持唯一索引和复合索引
  - [ ] CREATE VIEW支持可更新视图
  - [ ] ALTER TABLE支持ADD COLUMN和RENAME

- [ ] **DML操作**
  - [ ] SELECT支持子查询、JOIN、UNION
  - [ ] INSERT支持多行插入和子查询插入
  - [ ] UPDATE支持多列更新和条件更新
  - [ ] DELETE支持条件删除

- [ ] **事务控制**
  - [ ] BEGIN TRANSACTION支持DEFERRED/IMMEDIATE/EXCLUSIVE
  - [ ] COMMIT和ROLLBACK正常工作
  - [ ] SAVEPOINT支持嵌套事务

- [ ] **约束和完整性**
  - [ ] PRIMARY KEY约束
  - [ ] FOREIGN KEY约束（需启用PRAGMA foreign_keys=ON）
  - [ ] UNIQUE约束
  - [ ] CHECK约束
  - [ ] NOT NULL约束

### 5.2 SQL:2016兼容性检查

- [ ] **JSON支持**
  - [ ] json_extract()函数
  - [ ] json_array_length()函数
  - [ ] json_type()函数
  - [ ] json_valid()函数

- [ ] **窗口函数**
  - [ ] ROW_NUMBER(), RANK(), DENSE_RANK()
  - [ ] LAG(), LEAD()
  - [ ] 聚合函数OVER()子句
  - [ ] 窗口框架（ROWS/RANGE）

- [ ] **CTE支持**
  - [ ] 简单CTE（WITH子句）
  - [ ] 递归CTE（WITH RECURSIVE）

- [ ] **UPSERT**
  - [ ] INSERT ... ON CONFLICT DO UPDATE
  - [ ] INSERT ... ON CONFLICT DO NOTHING

- [ ] **生成列**
  - [ ] STORED生成列
  - [ ] VIRTUAL生成列

### 5.3 SQL:2023兼容性检查

- [ ] **STRICT表模式**
  - [ ] CREATE TABLE STRICT语法
  - [ ] 严格类型检查
  - [ ] 类型不匹配错误处理

- [ ] **多表UPDATE/DELETE**
  - [ ] UPDATE ... FROM语法
  - [ ] DELETE ... FROM语法

- [ ] **其他特性**
  - [ ] 并行查询（实验性）
  - [ ] JSON5支持（规划中）

### 5.4 已知限制检查

- [ ] **ALTER TABLE限制**
  - [ ] 不支持DROP COLUMN（需重建表）
  - [ ] 不支持MODIFY COLUMN（需重建表）

- [ ] **类型系统**
  - [ ] 动态类型系统（非严格类型）
  - [ ] 类型亲和性行为

- [ ] **函数差异**
  - [ ] 日期时间函数（date(), time(), datetime()）
  - [ ] 字符串函数（substr(), instr()）

---

## 六、迁移建议

### 6.1 从其他数据库迁移到SQLite

**PostgreSQL迁移**：

```sql
-- PostgreSQL语法
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- SQLite等价语法
CREATE TABLE users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    created_at TEXT DEFAULT (datetime('now'))
);
```

**MySQL迁移**：

```sql
-- MySQL语法
CREATE TABLE products (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(255),
    price DECIMAL(10,2)
);

-- SQLite等价语法
CREATE TABLE products (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT,
    price REAL
);
```

### 6.2 从SQLite迁移到其他数据库

**迁移到PostgreSQL**：

```sql
-- SQLite语法
CREATE TABLE users (
    id INTEGER PRIMARY KEY,
    name TEXT,
    age INTEGER
);

-- PostgreSQL等价语法
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255),
    age INTEGER
);
```

**迁移到MySQL**：

```sql
-- SQLite语法
CREATE TABLE products (
    id INTEGER PRIMARY KEY,
    name TEXT,
    price REAL
);

-- MySQL等价语法
CREATE TABLE products (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(255),
    price DECIMAL(10,2)
);
```

---

**最后更新**：2025-11-13
**维护者**：Data-Science Team
