# SQLite åˆ° PostgreSQL æ•°æ®è¿ç§»ä¸è¯­ä¹‰æ¨¡å‹å…¼å®¹æ€§

> **åˆ›å»ºæ—¥æœŸ**ï¼š2025-11-13
> **æœ€åæ›´æ–°**ï¼š2025-11-13
> **é€‚ç”¨ç‰ˆæœ¬**ï¼šSQLite 3.31+ â†’ PostgreSQL 12+

---

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£æ·±å…¥åˆ†æSQLiteåˆ°PostgreSQLæ•°æ®è¿ç§»è¿‡ç¨‹ä¸­çš„è¯­ä¹‰æ¨¡å‹å…¼å®¹æ€§ï¼ŒåŒ…æ‹¬æ•°æ®è¯­ä¹‰ã€ä¸šåŠ¡è¯­ä¹‰ã€é¢†åŸŸæ¨¡å‹è½¬æ¢ï¼Œä»¥åŠè¿ç§»åçš„æ•°æ®åˆ†æå’Œå¤„ç†ç­–ç•¥ã€‚

---

## ğŸ“‘ ç›®å½•

- [SQLite åˆ° PostgreSQL æ•°æ®è¿ç§»ä¸è¯­ä¹‰æ¨¡å‹å…¼å®¹æ€§](#sqlite-åˆ°-postgresql-æ•°æ®è¿ç§»ä¸è¯­ä¹‰æ¨¡å‹å…¼å®¹æ€§)
  - [ğŸ“‹ æ¦‚è¿°](#-æ¦‚è¿°)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [ä¸€ã€è¯­ä¹‰æ¨¡å‹ç†è®ºåŸºç¡€](#ä¸€è¯­ä¹‰æ¨¡å‹ç†è®ºåŸºç¡€)
    - [1.1 æ•°æ®è¯­ä¹‰æ¨¡å‹](#11-æ•°æ®è¯­ä¹‰æ¨¡å‹)
      - [SQLiteæ•°æ®è¯­ä¹‰æ¨¡å‹](#sqliteæ•°æ®è¯­ä¹‰æ¨¡å‹)
      - [PostgreSQLæ•°æ®è¯­ä¹‰æ¨¡å‹](#postgresqlæ•°æ®è¯­ä¹‰æ¨¡å‹)
    - [1.2 ä¸šåŠ¡è¯­ä¹‰æ¨¡å‹](#12-ä¸šåŠ¡è¯­ä¹‰æ¨¡å‹)
      - [ä¸šåŠ¡è¯­ä¹‰å®šä¹‰](#ä¸šåŠ¡è¯­ä¹‰å®šä¹‰)
    - [1.3 é¢†åŸŸæ¨¡å‹](#13-é¢†åŸŸæ¨¡å‹)
      - [é¢†åŸŸæ¨¡å‹å®šä¹‰](#é¢†åŸŸæ¨¡å‹å®šä¹‰)
    - [1.4 è¯­ä¹‰è½¬æ¢ç†è®º](#14-è¯­ä¹‰è½¬æ¢ç†è®º)
      - [è¯­ä¹‰ç­‰ä»·æ€§](#è¯­ä¹‰ç­‰ä»·æ€§)
      - [è¯­ä¹‰è½¬æ¢è§„åˆ™](#è¯­ä¹‰è½¬æ¢è§„åˆ™)
  - [äºŒã€æ•°æ®è¯­ä¹‰å…¼å®¹æ€§åˆ†æ](#äºŒæ•°æ®è¯­ä¹‰å…¼å®¹æ€§åˆ†æ)
    - [2.1 å€¼è¯­ä¹‰æ˜ å°„](#21-å€¼è¯­ä¹‰æ˜ å°„)
      - [æ•´æ•°è¯­ä¹‰æ˜ å°„](#æ•´æ•°è¯­ä¹‰æ˜ å°„)
      - [æµ®ç‚¹æ•°è¯­ä¹‰æ˜ å°„](#æµ®ç‚¹æ•°è¯­ä¹‰æ˜ å°„)
      - [æ–‡æœ¬è¯­ä¹‰æ˜ å°„](#æ–‡æœ¬è¯­ä¹‰æ˜ å°„)
    - [2.2 ç±»å‹è¯­ä¹‰è½¬æ¢](#22-ç±»å‹è¯­ä¹‰è½¬æ¢)
      - [åŠ¨æ€ç±»å‹åˆ°é™æ€ç±»å‹è½¬æ¢](#åŠ¨æ€ç±»å‹åˆ°é™æ€ç±»å‹è½¬æ¢)
      - [ç±»å‹è¯­ä¹‰æŸå¤±åˆ†æ](#ç±»å‹è¯­ä¹‰æŸå¤±åˆ†æ)
    - [2.3 çº¦æŸè¯­ä¹‰è½¬æ¢](#23-çº¦æŸè¯­ä¹‰è½¬æ¢)
      - [CHECKçº¦æŸè¯­ä¹‰è½¬æ¢](#checkçº¦æŸè¯­ä¹‰è½¬æ¢)
      - [å¤–é”®çº¦æŸè¯­ä¹‰è½¬æ¢](#å¤–é”®çº¦æŸè¯­ä¹‰è½¬æ¢)
    - [2.4 å…³ç³»è¯­ä¹‰è½¬æ¢](#24-å…³ç³»è¯­ä¹‰è½¬æ¢)
      - [ä¸€å¯¹ä¸€å…³ç³»è¯­ä¹‰](#ä¸€å¯¹ä¸€å…³ç³»è¯­ä¹‰)
      - [ä¸€å¯¹å¤šå…³ç³»è¯­ä¹‰](#ä¸€å¯¹å¤šå…³ç³»è¯­ä¹‰)
      - [å¤šå¯¹å¤šå…³ç³»è¯­ä¹‰](#å¤šå¯¹å¤šå…³ç³»è¯­ä¹‰)
  - [ä¸‰ã€ä¸šåŠ¡è¯­ä¹‰å…¼å®¹æ€§åˆ†æ](#ä¸‰ä¸šåŠ¡è¯­ä¹‰å…¼å®¹æ€§åˆ†æ)
    - [3.1 ä¸šåŠ¡è§„åˆ™è¯­ä¹‰](#31-ä¸šåŠ¡è§„åˆ™è¯­ä¹‰)
      - [ä¸šåŠ¡è§„åˆ™å®šä¹‰](#ä¸šåŠ¡è§„åˆ™å®šä¹‰)
      - [ä¸šåŠ¡è§„åˆ™è¯­ä¹‰è½¬æ¢](#ä¸šåŠ¡è§„åˆ™è¯­ä¹‰è½¬æ¢)
    - [3.2 ä¸šåŠ¡æµç¨‹è¯­ä¹‰](#32-ä¸šåŠ¡æµç¨‹è¯­ä¹‰)
      - [çŠ¶æ€æµè½¬è¯­ä¹‰](#çŠ¶æ€æµè½¬è¯­ä¹‰)
    - [3.3 ä¸šåŠ¡é€»è¾‘è¯­ä¹‰](#33-ä¸šåŠ¡é€»è¾‘è¯­ä¹‰)
      - [è®¡ç®—é€»è¾‘è¯­ä¹‰](#è®¡ç®—é€»è¾‘è¯­ä¹‰)
    - [3.4 ä¸šåŠ¡çº¦æŸè¯­ä¹‰](#34-ä¸šåŠ¡çº¦æŸè¯­ä¹‰)
      - [å¤æ‚ä¸šåŠ¡çº¦æŸ](#å¤æ‚ä¸šåŠ¡çº¦æŸ)
  - [å››ã€é¢†åŸŸæ¨¡å‹è½¬æ¢](#å››é¢†åŸŸæ¨¡å‹è½¬æ¢)
    - [4.1 å®ä½“æ¨¡å‹è½¬æ¢](#41-å®ä½“æ¨¡å‹è½¬æ¢)
      - [å®ä½“è¯†åˆ«](#å®ä½“è¯†åˆ«)
    - [4.2 å…³ç³»æ¨¡å‹è½¬æ¢](#42-å…³ç³»æ¨¡å‹è½¬æ¢)
      - [èšåˆå…³ç³»è½¬æ¢](#èšåˆå…³ç³»è½¬æ¢)
    - [4.3 èšåˆæ¨¡å‹è½¬æ¢](#43-èšåˆæ¨¡å‹è½¬æ¢)
      - [èšåˆæ ¹è¯†åˆ«](#èšåˆæ ¹è¯†åˆ«)
    - [4.4 å€¼å¯¹è±¡è½¬æ¢](#44-å€¼å¯¹è±¡è½¬æ¢)
      - [å€¼å¯¹è±¡è¯†åˆ«](#å€¼å¯¹è±¡è¯†åˆ«)
  - [äº”ã€æ•°æ®è¿ç§»è¯­ä¹‰ä¿è¯](#äº”æ•°æ®è¿ç§»è¯­ä¹‰ä¿è¯)
    - [5.1 è¯­ä¹‰ç­‰ä»·æ€§éªŒè¯](#51-è¯­ä¹‰ç­‰ä»·æ€§éªŒè¯)
      - [éªŒè¯æ¡†æ¶](#éªŒè¯æ¡†æ¶)
    - [5.2 è¯­ä¹‰å®Œæ•´æ€§æ£€æŸ¥](#52-è¯­ä¹‰å®Œæ•´æ€§æ£€æŸ¥)
      - [å®Œæ•´æ€§æ£€æŸ¥æ¸…å•](#å®Œæ•´æ€§æ£€æŸ¥æ¸…å•)
    - [5.3 è¯­ä¹‰ä¸€è‡´æ€§ä¿è¯](#53-è¯­ä¹‰ä¸€è‡´æ€§ä¿è¯)
      - [ä¸€è‡´æ€§ä¿è¯æœºåˆ¶](#ä¸€è‡´æ€§ä¿è¯æœºåˆ¶)
  - [å…­ã€è¿ç§»åæ•°æ®åˆ†æ](#å…­è¿ç§»åæ•°æ®åˆ†æ)
    - [6.1 æ•°æ®è´¨é‡åˆ†æ](#61-æ•°æ®è´¨é‡åˆ†æ)
      - [æ•°æ®è´¨é‡æŒ‡æ ‡](#æ•°æ®è´¨é‡æŒ‡æ ‡)
    - [6.2 è¯­ä¹‰ä¸€è‡´æ€§åˆ†æ](#62-è¯­ä¹‰ä¸€è‡´æ€§åˆ†æ)
      - [è¯­ä¹‰ä¸€è‡´æ€§æ£€æŸ¥](#è¯­ä¹‰ä¸€è‡´æ€§æ£€æŸ¥)
    - [6.3 æ€§èƒ½è¯­ä¹‰åˆ†æ](#63-æ€§èƒ½è¯­ä¹‰åˆ†æ)
      - [æ€§èƒ½è¯­ä¹‰éªŒè¯](#æ€§èƒ½è¯­ä¹‰éªŒè¯)
    - [6.4 ä¸šåŠ¡è¯­ä¹‰éªŒè¯](#64-ä¸šåŠ¡è¯­ä¹‰éªŒè¯)
      - [ä¸šåŠ¡è¯­ä¹‰éªŒè¯](#ä¸šåŠ¡è¯­ä¹‰éªŒè¯)
  - [ä¸ƒã€æ•°æ®å¤„ç†ç­–ç•¥](#ä¸ƒæ•°æ®å¤„ç†ç­–ç•¥)
    - [7.1 æ•°æ®æ¸…æ´—](#71-æ•°æ®æ¸…æ´—)
      - [æ•°æ®æ¸…æ´—æµç¨‹](#æ•°æ®æ¸…æ´—æµç¨‹)
    - [7.2 æ•°æ®è½¬æ¢](#72-æ•°æ®è½¬æ¢)
      - [æ•°æ®æ ¼å¼è½¬æ¢](#æ•°æ®æ ¼å¼è½¬æ¢)
    - [7.3 æ•°æ®éªŒè¯](#73-æ•°æ®éªŒè¯)
      - [æ•°æ®éªŒè¯æµç¨‹](#æ•°æ®éªŒè¯æµç¨‹)
    - [7.4 æ•°æ®ä¿®å¤](#74-æ•°æ®ä¿®å¤)
      - [æ•°æ®ä¿®å¤ç­–ç•¥](#æ•°æ®ä¿®å¤ç­–ç•¥)
  - [å…«ã€å®æˆ˜æ¡ˆä¾‹](#å…«å®æˆ˜æ¡ˆä¾‹)
    - [8.1 ç”µå•†ç³»ç»Ÿè¿ç§»](#81-ç”µå•†ç³»ç»Ÿè¿ç§»)
    - [8.2 é‡‘èç³»ç»Ÿè¿ç§»](#82-é‡‘èç³»ç»Ÿè¿ç§»)
    - [8.3 æ—¥å¿—ç³»ç»Ÿè¿ç§»](#83-æ—¥å¿—ç³»ç»Ÿè¿ç§»)
  - [ğŸ”— ç›¸å…³èµ„æº](#-ç›¸å…³èµ„æº)
  - [ğŸ“š å‚è€ƒèµ„æ–™](#-å‚è€ƒèµ„æ–™)

---

## ä¸€ã€è¯­ä¹‰æ¨¡å‹ç†è®ºåŸºç¡€

### 1.1 æ•°æ®è¯­ä¹‰æ¨¡å‹

#### SQLiteæ•°æ®è¯­ä¹‰æ¨¡å‹

**æ ¸å¿ƒç‰¹å¾**ï¼š

```
SQLiteæ•°æ®è¯­ä¹‰ = {
    ç±»å‹è¯­ä¹‰: åŠ¨æ€ç±»å‹ï¼Œè¿è¡Œæ—¶ç¡®å®š
    å€¼è¯­ä¹‰: å­˜å‚¨ç±»è¯­ä¹‰ï¼ˆNULL, INTEGER, REAL, TEXT, BLOBï¼‰
    çº¦æŸè¯­ä¹‰: è¿è¡Œæ—¶æ£€æŸ¥ï¼Œå¯ç»•è¿‡
    å…³ç³»è¯­ä¹‰: å¤–é”®å¯é€‰ï¼Œå»¶è¿Ÿæ£€æŸ¥
}
```

**è¯­ä¹‰å±‚æ¬¡**ï¼š

1. **ç‰©ç†è¯­ä¹‰**ï¼šå­˜å‚¨æ ¼å¼ã€ç¼–ç æ–¹å¼
2. **é€»è¾‘è¯­ä¹‰**ï¼šæ•°æ®ç±»å‹ã€çº¦æŸè§„åˆ™
3. **ä¸šåŠ¡è¯­ä¹‰**ï¼šä¸šåŠ¡å«ä¹‰ã€ä¸šåŠ¡è§„åˆ™

#### PostgreSQLæ•°æ®è¯­ä¹‰æ¨¡å‹

**æ ¸å¿ƒç‰¹å¾**ï¼š

```
PostgreSQLæ•°æ®è¯­ä¹‰ = {
    ç±»å‹è¯­ä¹‰: é™æ€ç±»å‹ï¼Œç¼–è¯‘æ—¶ç¡®å®š
    å€¼è¯­ä¹‰: å¼ºç±»å‹è¯­ä¹‰ï¼Œç±»å‹åŒ¹é…
    çº¦æŸè¯­ä¹‰: ç¼–è¯‘æ—¶æ£€æŸ¥ï¼Œä¸å¯ç»•è¿‡
    å…³ç³»è¯­ä¹‰: å¤–é”®å¼ºåˆ¶ï¼Œç«‹å³æ£€æŸ¥
}
```

**è¯­ä¹‰å±‚æ¬¡**ï¼š

1. **ç‰©ç†è¯­ä¹‰**ï¼šTOASTå­˜å‚¨ã€å‹ç¼©
2. **é€»è¾‘è¯­ä¹‰**ï¼šä¸¥æ ¼ç±»å‹ã€çº¦æŸ
3. **ä¸šåŠ¡è¯­ä¹‰**ï¼šé¢†åŸŸæ¨¡å‹ã€ä¸šåŠ¡è§„åˆ™

### 1.2 ä¸šåŠ¡è¯­ä¹‰æ¨¡å‹

#### ä¸šåŠ¡è¯­ä¹‰å®šä¹‰

**ä¸šåŠ¡è¯­ä¹‰ = æ•°æ®åœ¨ä¸šåŠ¡ä¸Šä¸‹æ–‡ä¸­çš„å«ä¹‰**

**ç¤ºä¾‹ï¼šä»·æ ¼è¯­ä¹‰**

```sql
-- SQLite: ä»·æ ¼å­˜å‚¨
CREATE TABLE products (
    id INTEGER PRIMARY KEY,
    price REAL  -- è¯­ä¹‰ï¼šä»·æ ¼ï¼Œå•ä½ï¼šå…ƒï¼Œç²¾åº¦ï¼š2ä½å°æ•°
);

-- ä¸šåŠ¡è¯­ä¹‰ï¼š
-- 1. ä»·æ ¼å¿…é¡» > 0
-- 2. ä»·æ ¼å•ä½ï¼šäººæ°‘å¸å…ƒ
-- 3. ä»·æ ¼ç²¾åº¦ï¼š2ä½å°æ•°
-- 4. ä»·æ ¼èŒƒå›´ï¼š0.01 - 999999.99
```

**PostgreSQLä¸šåŠ¡è¯­ä¹‰è¡¨è¾¾**ï¼š

```sql
-- PostgreSQL: ä»·æ ¼è¯­ä¹‰è¡¨è¾¾
CREATE DOMAIN price_type AS NUMERIC(10,2)
    CHECK (VALUE > 0 AND VALUE <= 999999.99);

CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    price price_type NOT NULL  -- è¯­ä¹‰ï¼šä»·æ ¼ï¼Œå•ä½ï¼šå…ƒï¼Œç²¾åº¦ï¼š2ä½å°æ•°
);
```

### 1.3 é¢†åŸŸæ¨¡å‹

#### é¢†åŸŸæ¨¡å‹å®šä¹‰

**é¢†åŸŸæ¨¡å‹ = ä¸šåŠ¡æ¦‚å¿µåœ¨æ•°æ®æ¨¡å‹ä¸­çš„è¡¨ç¤º**

**ç¤ºä¾‹ï¼šè®¢å•é¢†åŸŸæ¨¡å‹**

**SQLiteé¢†åŸŸæ¨¡å‹**ï¼š

```sql
-- è®¢å•å®ä½“
CREATE TABLE orders (
    id INTEGER PRIMARY KEY,
    user_id INTEGER,           -- è¯­ä¹‰ï¼šç”¨æˆ·IDï¼Œå¤–é”®
    total REAL,                 -- è¯­ä¹‰ï¼šè®¢å•æ€»é¢
    status TEXT,                -- è¯­ä¹‰ï¼šè®¢å•çŠ¶æ€ï¼ˆpending/paid/shippedï¼‰
    created_at INTEGER          -- è¯­ä¹‰ï¼šåˆ›å»ºæ—¶é—´ï¼ˆUnixæ—¶é—´æˆ³ï¼‰
);

-- é¢†åŸŸè¯­ä¹‰ï¼š
-- 1. è®¢å•å±äºç”¨æˆ·ï¼ˆ1å¯¹å¤šå…³ç³»ï¼‰
-- 2. è®¢å•æ€»é¢ = æ‰€æœ‰è®¢å•é¡¹é‡‘é¢ä¹‹å’Œ
-- 3. è®¢å•çŠ¶æ€æµè½¬ï¼špending â†’ paid â†’ shipped
-- 4. è®¢å•åˆ›å»ºæ—¶é—´ä¸å¯ä¿®æ”¹
```

**PostgreSQLé¢†åŸŸæ¨¡å‹**ï¼š

```sql
-- è®¢å•çŠ¶æ€æšä¸¾
CREATE TYPE order_status AS ENUM ('pending', 'paid', 'shipped');

-- è®¢å•å®ä½“
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id),
    total NUMERIC(10,2) NOT NULL CHECK (total > 0),
    status order_status NOT NULL DEFAULT 'pending',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- é¢†åŸŸè¯­ä¹‰è¡¨è¾¾ï¼š
-- 1. å¤–é”®çº¦æŸï¼šè®¢å•å¿…é¡»å±äºæœ‰æ•ˆç”¨æˆ·
-- 2. CHECKçº¦æŸï¼šè®¢å•æ€»é¢å¿…é¡» > 0
-- 3. æšä¸¾ç±»å‹ï¼šè®¢å•çŠ¶æ€åªèƒ½æ˜¯é¢„å®šä¹‰å€¼
-- 4. é»˜è®¤å€¼ï¼šåˆ›å»ºæ—¶é—´è‡ªåŠ¨è®¾ç½®
```

### 1.4 è¯­ä¹‰è½¬æ¢ç†è®º

#### è¯­ä¹‰ç­‰ä»·æ€§

**å®šä¹‰**ï¼šä¸¤ä¸ªæ•°æ®æ¨¡å‹åœ¨è¯­ä¹‰ä¸Šç­‰ä»·ï¼Œå½“ä¸”ä»…å½“ï¼š

1. æ‰€æœ‰ä¸šåŠ¡è§„åˆ™åœ¨ä¸¤ä¸ªæ¨¡å‹ä¸­è¡¨è¾¾ä¸€è‡´
2. æ‰€æœ‰æ•°æ®çº¦æŸåœ¨ä¸¤ä¸ªæ¨¡å‹ä¸­æ•ˆæœç›¸åŒ
3. æ‰€æœ‰ä¸šåŠ¡æ“ä½œåœ¨ä¸¤ä¸ªæ¨¡å‹ä¸­ç»“æœç›¸åŒ

#### è¯­ä¹‰è½¬æ¢è§„åˆ™

**è§„åˆ™1ï¼šç±»å‹è¯­ä¹‰è½¬æ¢**

```
SQLiteç±»å‹è¯­ä¹‰ â†’ PostgreSQLç±»å‹è¯­ä¹‰
- ä¿æŒä¸šåŠ¡è¯­ä¹‰ä¸å˜
- å¢å¼ºç±»å‹çº¦æŸ
- ä¿æŒå€¼è¯­ä¹‰ç­‰ä»·
```

**è§„åˆ™2ï¼šçº¦æŸè¯­ä¹‰è½¬æ¢**

```
SQLiteçº¦æŸè¯­ä¹‰ â†’ PostgreSQLçº¦æŸè¯­ä¹‰
- è¿è¡Œæ—¶çº¦æŸ â†’ ç¼–è¯‘æ—¶çº¦æŸ
- å¯é€‰çº¦æŸ â†’ å¼ºåˆ¶çº¦æŸ
- å»¶è¿Ÿæ£€æŸ¥ â†’ ç«‹å³æ£€æŸ¥
```

**è§„åˆ™3ï¼šå…³ç³»è¯­ä¹‰è½¬æ¢**

```
SQLiteå…³ç³»è¯­ä¹‰ â†’ PostgreSQLå…³ç³»è¯­ä¹‰
- å¯é€‰å¤–é”® â†’ å¼ºåˆ¶å¤–é”®
- å»¶è¿Ÿæ£€æŸ¥ â†’ ç«‹å³æ£€æŸ¥
- çº§è”æ“ä½œå¢å¼º
```

---

## äºŒã€æ•°æ®è¯­ä¹‰å…¼å®¹æ€§åˆ†æ

### 2.1 å€¼è¯­ä¹‰æ˜ å°„

#### æ•´æ•°è¯­ä¹‰æ˜ å°„

**SQLiteæ•´æ•°è¯­ä¹‰**ï¼š

```sql
-- SQLite: INTEGERå­˜å‚¨ç±»
-- è¯­ä¹‰ï¼šä»»æ„å¤§å°çš„æ•´æ•°ï¼ˆ1-8å­—èŠ‚è‡ªé€‚åº”ï¼‰
INSERT INTO users(age) VALUES (25);        -- è¯­ä¹‰ï¼šå¹´é¾„ï¼Œ25å²
INSERT INTO products(stock) VALUES (1000);  -- è¯­ä¹‰ï¼šåº“å­˜ï¼Œ1000ä»¶
INSERT INTO orders(total_cents) VALUES (1999);  -- è¯­ä¹‰ï¼šæ€»é‡‘é¢ï¼Œ19.99å…ƒï¼ˆä»¥åˆ†ä¸ºå•ä½ï¼‰
```

**è¯­ä¹‰åˆ†æ**ï¼š

- **age**: ä¸šåŠ¡è¯­ä¹‰ = å¹´é¾„ï¼ŒèŒƒå›´ 0-150
- **stock**: ä¸šåŠ¡è¯­ä¹‰ = åº“å­˜ï¼ŒèŒƒå›´ >= 0
- **total_cents**: ä¸šåŠ¡è¯­ä¹‰ = é‡‘é¢ï¼ˆåˆ†ï¼‰ï¼ŒèŒƒå›´ >= 0

**PostgreSQLè¯­ä¹‰æ˜ å°„**ï¼š

```sql
-- PostgreSQL: åŸºäºä¸šåŠ¡è¯­ä¹‰é€‰æ‹©ç±»å‹
CREATE TABLE users (
    age SMALLINT CHECK (age >= 0 AND age <= 150)  -- è¯­ä¹‰ï¼šå¹´é¾„ï¼ŒèŒƒå›´çº¦æŸ
);

CREATE TABLE products (
    stock INTEGER CHECK (stock >= 0)  -- è¯­ä¹‰ï¼šåº“å­˜ï¼Œéè´Ÿçº¦æŸ
);

CREATE TABLE orders (
    total_cents BIGINT CHECK (total_cents >= 0)  -- è¯­ä¹‰ï¼šé‡‘é¢ï¼ˆåˆ†ï¼‰ï¼Œå¤§æ•´æ•°
);
```

#### æµ®ç‚¹æ•°è¯­ä¹‰æ˜ å°„

**SQLiteæµ®ç‚¹æ•°è¯­ä¹‰**ï¼š

```sql
-- SQLite: REALå­˜å‚¨ç±»
-- è¯­ä¹‰ï¼šIEEE 754åŒç²¾åº¦æµ®ç‚¹æ•°
INSERT INTO products(price) VALUES (19.99);      -- è¯­ä¹‰ï¼šä»·æ ¼ï¼Œ19.99å…ƒ
INSERT INTO measurements(value) VALUES (3.14159);  -- è¯­ä¹‰ï¼šæµ‹é‡å€¼ï¼Œ3.14159
```

**è¯­ä¹‰åˆ†æ**ï¼š

- **price**: ä¸šåŠ¡è¯­ä¹‰ = ä»·æ ¼ï¼Œç²¾åº¦è¦æ±‚2ä½å°æ•°
- **value**: ä¸šåŠ¡è¯­ä¹‰ = æµ‹é‡å€¼ï¼Œç²¾åº¦è¦æ±‚é«˜

**PostgreSQLè¯­ä¹‰æ˜ å°„**ï¼š

```sql
-- PostgreSQL: åŸºäºä¸šåŠ¡è¯­ä¹‰é€‰æ‹©ç±»å‹
CREATE TABLE products (
    price NUMERIC(10,2) CHECK (price > 0)  -- è¯­ä¹‰ï¼šä»·æ ¼ï¼Œå›ºå®šç²¾åº¦
);

CREATE TABLE measurements (
    value DOUBLE PRECISION  -- è¯­ä¹‰ï¼šæµ‹é‡å€¼ï¼Œé«˜ç²¾åº¦
);
```

#### æ–‡æœ¬è¯­ä¹‰æ˜ å°„

**SQLiteæ–‡æœ¬è¯­ä¹‰**ï¼š

```sql
-- SQLite: TEXTå­˜å‚¨ç±»
-- è¯­ä¹‰ï¼šUTF-8/UTF-16æ–‡æœ¬
INSERT INTO users(email) VALUES ('user@example.com');  -- è¯­ä¹‰ï¼šé‚®ç®±åœ°å€
INSERT INTO products(name) VALUES ('å•†å“åç§°');        -- è¯­ä¹‰ï¼šå•†å“åç§°
INSERT INTO articles(content) VALUES ('æ–‡ç« å†…å®¹...');   -- è¯­ä¹‰ï¼šæ–‡ç« å†…å®¹
```

**è¯­ä¹‰åˆ†æ**ï¼š

- **email**: ä¸šåŠ¡è¯­ä¹‰ = é‚®ç®±åœ°å€ï¼Œæ ¼å¼çº¦æŸï¼Œé•¿åº¦é™åˆ¶
- **name**: ä¸šåŠ¡è¯­ä¹‰ = å•†å“åç§°ï¼Œé•¿åº¦é™åˆ¶
- **content**: ä¸šåŠ¡è¯­ä¹‰ = æ–‡ç« å†…å®¹ï¼Œæ— é•¿åº¦é™åˆ¶

**PostgreSQLè¯­ä¹‰æ˜ å°„**ï¼š

```sql
-- PostgreSQL: åŸºäºä¸šåŠ¡è¯­ä¹‰é€‰æ‹©ç±»å‹å’Œçº¦æŸ
CREATE TABLE users (
    email VARCHAR(255) CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}$')
);

CREATE TABLE products (
    name VARCHAR(200) NOT NULL
);

CREATE TABLE articles (
    content TEXT  -- è¯­ä¹‰ï¼šæ–‡ç« å†…å®¹ï¼Œæ— é•¿åº¦é™åˆ¶
);
```

### 2.2 ç±»å‹è¯­ä¹‰è½¬æ¢

#### åŠ¨æ€ç±»å‹åˆ°é™æ€ç±»å‹è½¬æ¢

**è½¬æ¢ç­–ç•¥**ï¼š

**ç­–ç•¥1ï¼šä¸¥æ ¼è½¬æ¢ï¼ˆæ¨èï¼‰**

```sql
-- SQLite: åŠ¨æ€ç±»å‹
CREATE TABLE mixed_data (
    id INTEGER PRIMARY KEY,
    value NUMERIC  -- å¯ä»¥å­˜å‚¨ä»»ä½•ç±»å‹
);

-- æ•°æ®åˆ†æï¼šæ£€æŸ¥å®é™…å­˜å‚¨ç±»å‹
-- å‘ç°ï¼švalueåˆ—å®é™…å­˜å‚¨çš„éƒ½æ˜¯æ•´æ•°

-- PostgreSQL: ä¸¥æ ¼ç±»å‹
CREATE TABLE mixed_data (
    id SERIAL PRIMARY KEY,
    value INTEGER NOT NULL  -- åŸºäºæ•°æ®åˆ†æç¡®å®šç±»å‹
);
```

**ç­–ç•¥2ï¼šå…¼å®¹è½¬æ¢ï¼ˆä¿å®ˆï¼‰**

```sql
-- PostgreSQL: ä¿æŒçµæ´»æ€§
CREATE TABLE mixed_data (
    id SERIAL PRIMARY KEY,
    value TEXT  -- è½¬æ¢ä¸ºæ–‡æœ¬ï¼Œä¿æŒçµæ´»æ€§
);
```

#### ç±»å‹è¯­ä¹‰æŸå¤±åˆ†æ

**æŸå¤±ç±»å‹1ï¼šç²¾åº¦è¯­ä¹‰æŸå¤±**

```sql
-- SQLite: REALå­˜å‚¨
INSERT INTO prices(amount) VALUES (19.999999);

-- ä¸šåŠ¡è¯­ä¹‰ï¼šä»·æ ¼ï¼ŒæœŸæœ›ç²¾åº¦2ä½å°æ•°
-- å®é™…å­˜å‚¨ï¼š19.999999ï¼ˆ6ä½å°æ•°ï¼‰

-- PostgreSQL: NUMERIC(10,2)
-- è½¬æ¢åï¼š20.00
-- è¯­ä¹‰æŸå¤±ï¼šç²¾åº¦ä»6ä½é™åˆ°2ä½
-- å½±å“ï¼šå¯èƒ½å½±å“ç²¾ç¡®è®¡ç®—
```

**æŸå¤±ç±»å‹2ï¼šèŒƒå›´è¯­ä¹‰æŸå¤±**

```sql
-- SQLite: INTEGERï¼ˆ8å­—èŠ‚ï¼‰
INSERT INTO big_ids(id) VALUES (9223372036854775807);

-- ä¸šåŠ¡è¯­ä¹‰ï¼šå¤§æ•´æ•°ID

-- PostgreSQL: INTEGERï¼ˆ4å­—èŠ‚ï¼‰
-- è½¬æ¢å¤±è´¥ï¼šå€¼è¶…å‡ºèŒƒå›´
-- è§£å†³æ–¹æ¡ˆï¼šä½¿ç”¨BIGINT
```

### 2.3 çº¦æŸè¯­ä¹‰è½¬æ¢

#### CHECKçº¦æŸè¯­ä¹‰è½¬æ¢

**SQLite CHECKçº¦æŸ**ï¼š

```sql
CREATE TABLE products (
    id INTEGER PRIMARY KEY,
    price REAL CHECK (price > 0),
    stock INTEGER CHECK (stock >= 0 AND stock <= 10000)
);
```

**è¯­ä¹‰åˆ†æ**ï¼š

- **price > 0**: ä¸šåŠ¡è¯­ä¹‰ = ä»·æ ¼å¿…é¡»ä¸ºæ­£æ•°
- **stockèŒƒå›´**: ä¸šåŠ¡è¯­ä¹‰ = åº“å­˜èŒƒå›´ 0-10000

**PostgreSQL CHECKçº¦æŸ**ï¼š

```sql
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    price NUMERIC(10,2) CHECK (price > 0),  -- è¯­ä¹‰ï¼šä»·æ ¼å¿…é¡»ä¸ºæ­£æ•°
    stock INTEGER CHECK (stock >= 0 AND stock <= 10000)  -- è¯­ä¹‰ï¼šåº“å­˜èŒƒå›´
);
```

**è¯­ä¹‰ç­‰ä»·æ€§**ï¼šâœ… å®Œå…¨ç­‰ä»·

#### å¤–é”®çº¦æŸè¯­ä¹‰è½¬æ¢

**SQLiteå¤–é”®è¯­ä¹‰**ï¼š

```sql
-- SQLite: å¯é€‰å¤–é”®
CREATE TABLE orders (
    id INTEGER PRIMARY KEY,
    user_id INTEGER  -- è¯­ä¹‰ï¼šç”¨æˆ·IDï¼Œä½†å¯èƒ½æ— æ•ˆ
);

-- ä¸šåŠ¡è¯­ä¹‰ï¼šè®¢å•å¿…é¡»å±äºæœ‰æ•ˆç”¨æˆ·
-- ä½†SQLiteä¸å¼ºåˆ¶æ£€æŸ¥
```

**PostgreSQLå¤–é”®è¯­ä¹‰**ï¼š

```sql
-- PostgreSQL: å¼ºåˆ¶å¤–é”®
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id)  -- è¯­ä¹‰ï¼šè®¢å•å¿…é¡»å±äºæœ‰æ•ˆç”¨æˆ·
);

-- ä¸šåŠ¡è¯­ä¹‰ï¼šè®¢å•å¿…é¡»å±äºæœ‰æ•ˆç”¨æˆ·
-- PostgreSQLå¼ºåˆ¶æ£€æŸ¥
```

**è¯­ä¹‰å¢å¼º**ï¼šPostgreSQLå¢å¼ºäº†ä¸šåŠ¡è¯­ä¹‰çš„å¼ºåˆ¶åŠ›

### 2.4 å…³ç³»è¯­ä¹‰è½¬æ¢

#### ä¸€å¯¹ä¸€å…³ç³»è¯­ä¹‰

**SQLiteä¸€å¯¹ä¸€å…³ç³»**ï¼š

```sql
-- SQLite: ä¸€å¯¹ä¸€å…³ç³»ï¼ˆåº”ç”¨å±‚ä¿è¯ï¼‰
CREATE TABLE users (
    id INTEGER PRIMARY KEY,
    name TEXT
);

CREATE TABLE user_profiles (
    user_id INTEGER PRIMARY KEY,  -- è¯­ä¹‰ï¼šä¸€å¯¹ä¸€å…³ç³»
    bio TEXT
);
```

**PostgreSQLä¸€å¯¹ä¸€å…³ç³»**ï¼š

```sql
-- PostgreSQL: ä¸€å¯¹ä¸€å…³ç³»ï¼ˆæ•°æ®åº“å±‚ä¿è¯ï¼‰
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL
);

CREATE TABLE user_profiles (
    user_id INTEGER PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    bio TEXT,
    CONSTRAINT unique_user_profile UNIQUE (user_id)  -- è¯­ä¹‰ï¼šä¸€å¯¹ä¸€å…³ç³»
);
```

#### ä¸€å¯¹å¤šå…³ç³»è¯­ä¹‰

**SQLiteä¸€å¯¹å¤šå…³ç³»**ï¼š

```sql
-- SQLite: ä¸€å¯¹å¤šå…³ç³»
CREATE TABLE users (
    id INTEGER PRIMARY KEY,
    name TEXT
);

CREATE TABLE orders (
    id INTEGER PRIMARY KEY,
    user_id INTEGER  -- è¯­ä¹‰ï¼šå¤šå¯¹ä¸€å…³ç³»ï¼ˆå¤šä¸ªè®¢å•å±äºä¸€ä¸ªç”¨æˆ·ï¼‰
);
```

**PostgreSQLä¸€å¯¹å¤šå…³ç³»**ï¼š

```sql
-- PostgreSQL: ä¸€å¯¹å¤šå…³ç³»ï¼ˆå¤–é”®çº¦æŸï¼‰
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL
);

CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE
    -- è¯­ä¹‰ï¼šå¤šå¯¹ä¸€å…³ç³»ï¼Œçº§è”åˆ é™¤
);
```

#### å¤šå¯¹å¤šå…³ç³»è¯­ä¹‰

**SQLiteå¤šå¯¹å¤šå…³ç³»**ï¼š

```sql
-- SQLite: å¤šå¯¹å¤šå…³ç³»ï¼ˆä¸­é—´è¡¨ï¼‰
CREATE TABLE users (
    id INTEGER PRIMARY KEY,
    name TEXT
);

CREATE TABLE roles (
    id INTEGER PRIMARY KEY,
    name TEXT
);

CREATE TABLE user_roles (
    user_id INTEGER,
    role_id INTEGER,
    PRIMARY KEY (user_id, role_id)  -- è¯­ä¹‰ï¼šå¤šå¯¹å¤šå…³ç³»
);
```

**PostgreSQLå¤šå¯¹å¤šå…³ç³»**ï¼š

```sql
-- PostgreSQL: å¤šå¯¹å¤šå…³ç³»ï¼ˆå¤–é”®çº¦æŸï¼‰
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL
);

CREATE TABLE roles (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL
);

CREATE TABLE user_roles (
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role_id INTEGER NOT NULL REFERENCES roles(id) ON DELETE CASCADE,
    PRIMARY KEY (user_id, role_id)  -- è¯­ä¹‰ï¼šå¤šå¯¹å¤šå…³ç³»ï¼Œçº§è”åˆ é™¤
);
```

---

## ä¸‰ã€ä¸šåŠ¡è¯­ä¹‰å…¼å®¹æ€§åˆ†æ

### 3.1 ä¸šåŠ¡è§„åˆ™è¯­ä¹‰

#### ä¸šåŠ¡è§„åˆ™å®šä¹‰

**ä¸šåŠ¡è§„åˆ™ = ä¸šåŠ¡é¢†åŸŸçš„çº¦æŸå’Œé€»è¾‘**

**ç¤ºä¾‹ï¼šç”µå•†ç³»ç»Ÿä¸šåŠ¡è§„åˆ™**

**è§„åˆ™1ï¼šè®¢å•æ€»é¢è®¡ç®—**

```sql
-- SQLite: ä¸šåŠ¡è§„åˆ™ï¼ˆåº”ç”¨å±‚å®ç°ï¼‰
-- è§„åˆ™ï¼šè®¢å•æ€»é¢ = æ‰€æœ‰è®¢å•é¡¹é‡‘é¢ä¹‹å’Œ

-- åº”ç”¨å±‚ä»£ç 
def calculate_order_total(order_id):
    items = db.execute("SELECT price, quantity FROM order_items WHERE order_id = ?", order_id)
    total = sum(item.price * item.quantity for item in items)
    db.execute("UPDATE orders SET total = ? WHERE id = ?", total, order_id)
```

**PostgreSQL: ä¸šåŠ¡è§„åˆ™ï¼ˆæ•°æ®åº“å±‚å®ç°ï¼‰**

```sql
-- PostgreSQL: ä½¿ç”¨ç”Ÿæˆåˆ—æˆ–è§¦å‘å™¨
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    total NUMERIC(10,2) GENERATED ALWAYS AS (
        SELECT COALESCE(SUM(price * quantity), 0)
        FROM order_items
        WHERE order_id = orders.id
    ) STORED
);

-- è¯­ä¹‰ï¼šè®¢å•æ€»é¢è‡ªåŠ¨è®¡ç®—ï¼Œä¿è¯ä¸€è‡´æ€§
```

#### ä¸šåŠ¡è§„åˆ™è¯­ä¹‰è½¬æ¢

**è½¬æ¢ç­–ç•¥**ï¼š

**ç­–ç•¥1ï¼šæ•°æ®åº“å±‚å®ç°ï¼ˆæ¨èï¼‰**

- ä¼˜ç‚¹ï¼šæ•°æ®ä¸€è‡´æ€§ä¿è¯
- ç¼ºç‚¹ï¼šæ•°æ®åº“é€»è¾‘å¤æ‚

**ç­–ç•¥2ï¼šåº”ç”¨å±‚å®ç°ï¼ˆå…¼å®¹ï¼‰**

- ä¼˜ç‚¹ï¼šé€»è¾‘é›†ä¸­
- ç¼ºç‚¹ï¼šéœ€è¦ä¿è¯ä¸€è‡´æ€§

### 3.2 ä¸šåŠ¡æµç¨‹è¯­ä¹‰

#### çŠ¶æ€æµè½¬è¯­ä¹‰

**SQLiteçŠ¶æ€æµè½¬**ï¼š

```sql
-- SQLite: çŠ¶æ€å­˜å‚¨
CREATE TABLE orders (
    id INTEGER PRIMARY KEY,
    status TEXT  -- è¯­ä¹‰ï¼šè®¢å•çŠ¶æ€
);

-- åº”ç”¨å±‚çŠ¶æ€æµè½¬é€»è¾‘
def update_order_status(order_id, new_status):
    current_status = get_order_status(order_id)

    # ä¸šåŠ¡è§„åˆ™ï¼šçŠ¶æ€æµè½¬
    valid_transitions = {
        'pending': ['paid', 'cancelled'],
        'paid': ['shipped', 'refunded'],
        'shipped': ['delivered'],
        'delivered': [],
        'cancelled': [],
        'refunded': []
    }

    if new_status not in valid_transitions.get(current_status, []):
        raise ValueError("Invalid status transition")

    db.execute("UPDATE orders SET status = ? WHERE id = ?", new_status, order_id)
```

**PostgreSQLçŠ¶æ€æµè½¬**ï¼š

```sql
-- PostgreSQL: çŠ¶æ€æšä¸¾ + è§¦å‘å™¨
CREATE TYPE order_status AS ENUM ('pending', 'paid', 'shipped', 'delivered', 'cancelled', 'refunded');

CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    status order_status NOT NULL DEFAULT 'pending'
);

-- çŠ¶æ€æµè½¬è§¦å‘å™¨
CREATE OR REPLACE FUNCTION validate_order_status_transition()
RETURNS TRIGGER AS $$
BEGIN
    -- ä¸šåŠ¡è§„åˆ™ï¼šçŠ¶æ€æµè½¬éªŒè¯
    IF (OLD.status = 'pending' AND NEW.status NOT IN ('paid', 'cancelled')) OR
       (OLD.status = 'paid' AND NEW.status NOT IN ('shipped', 'refunded')) OR
       (OLD.status = 'shipped' AND NEW.status != 'delivered') OR
       (OLD.status IN ('delivered', 'cancelled', 'refunded')) THEN
        RAISE EXCEPTION 'Invalid status transition from % to %', OLD.status, NEW.status;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER order_status_transition_trigger
    BEFORE UPDATE ON orders
    FOR EACH ROW
    WHEN (OLD.status IS DISTINCT FROM NEW.status)
    EXECUTE FUNCTION validate_order_status_transition();

-- è¯­ä¹‰ï¼šçŠ¶æ€æµè½¬åœ¨æ•°æ®åº“å±‚ä¿è¯
```

### 3.3 ä¸šåŠ¡é€»è¾‘è¯­ä¹‰

#### è®¡ç®—é€»è¾‘è¯­ä¹‰

**SQLiteè®¡ç®—é€»è¾‘**ï¼š

```sql
-- SQLite: åº”ç”¨å±‚è®¡ç®—
-- ä¸šåŠ¡é€»è¾‘ï¼šè®¡ç®—è®¢å•æŠ˜æ‰£

def calculate_discount(order_id):
    order = db.execute("SELECT total, user_id FROM orders WHERE id = ?", order_id).fetchone()
    user = db.execute("SELECT vip_level FROM users WHERE id = ?", order.user_id).fetchone()

    # ä¸šåŠ¡é€»è¾‘ï¼šVIPç”¨æˆ·æŠ˜æ‰£
    if user.vip_level == 'gold':
        discount = order.total * 0.1  -- 10%æŠ˜æ‰£
    elif user.vip_level == 'silver':
        discount = order.total * 0.05  -- 5%æŠ˜æ‰£
    else:
        discount = 0

    return discount
```

**PostgreSQLè®¡ç®—é€»è¾‘**ï¼š

```sql
-- PostgreSQL: æ•°æ®åº“å‡½æ•°
CREATE OR REPLACE FUNCTION calculate_discount(order_id INTEGER)
RETURNS NUMERIC(10,2) AS $$
DECLARE
    order_total NUMERIC(10,2);
    user_vip_level VARCHAR(20);
    discount NUMERIC(10,2);
BEGIN
    -- è·å–è®¢å•ä¿¡æ¯
    SELECT o.total, u.vip_level
    INTO order_total, user_vip_level
    FROM orders o
    JOIN users u ON o.user_id = u.id
    WHERE o.id = order_id;

    -- ä¸šåŠ¡é€»è¾‘ï¼šVIPç”¨æˆ·æŠ˜æ‰£
    IF user_vip_level = 'gold' THEN
        discount := order_total * 0.1;
    ELSIF user_vip_level = 'silver' THEN
        discount := order_total * 0.05;
    ELSE
        discount := 0;
    END IF;

    RETURN discount;
END;
$$ LANGUAGE plpgsql;

-- è¯­ä¹‰ï¼šè®¡ç®—é€»è¾‘åœ¨æ•°æ®åº“å±‚å®ç°
```

### 3.4 ä¸šåŠ¡çº¦æŸè¯­ä¹‰

#### å¤æ‚ä¸šåŠ¡çº¦æŸ

**SQLiteä¸šåŠ¡çº¦æŸ**ï¼š

```sql
-- SQLite: åº”ç”¨å±‚çº¦æŸ
-- ä¸šåŠ¡çº¦æŸï¼šç”¨æˆ·ä¸èƒ½åŒæ—¶æ‹¥æœ‰è¶…è¿‡3ä¸ªæœªå®Œæˆè®¢å•

def create_order(user_id):
    # æ£€æŸ¥çº¦æŸ
    pending_count = db.execute(
        "SELECT COUNT(*) FROM orders WHERE user_id = ? AND status = 'pending'",
        user_id
    ).fetchone()[0]

    if pending_count >= 3:
        raise ValueError("User cannot have more than 3 pending orders")

    # åˆ›å»ºè®¢å•
    db.execute("INSERT INTO orders (user_id, status) VALUES (?, 'pending')", user_id)
```

**PostgreSQLä¸šåŠ¡çº¦æŸ**ï¼š

```sql
-- PostgreSQL: æ•°æ®åº“çº¦æŸ
CREATE OR REPLACE FUNCTION check_pending_orders_limit()
RETURNS TRIGGER AS $$
DECLARE
    pending_count INTEGER;
BEGIN
    -- ä¸šåŠ¡çº¦æŸï¼šæ£€æŸ¥æœªå®Œæˆè®¢å•æ•°é‡
    SELECT COUNT(*) INTO pending_count
    FROM orders
    WHERE user_id = NEW.user_id AND status = 'pending';

    IF pending_count >= 3 THEN
        RAISE EXCEPTION 'User cannot have more than 3 pending orders';
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER pending_orders_limit_trigger
    BEFORE INSERT ON orders
    FOR EACH ROW
    WHEN (NEW.status = 'pending')
    EXECUTE FUNCTION check_pending_orders_limit();

-- è¯­ä¹‰ï¼šä¸šåŠ¡çº¦æŸåœ¨æ•°æ®åº“å±‚ä¿è¯
```

---

## å››ã€é¢†åŸŸæ¨¡å‹è½¬æ¢

### 4.1 å®ä½“æ¨¡å‹è½¬æ¢

#### å®ä½“è¯†åˆ«

**SQLiteå®ä½“æ¨¡å‹**ï¼š

```sql
-- ç”¨æˆ·å®ä½“
CREATE TABLE users (
    id INTEGER PRIMARY KEY,
    name TEXT,
    email TEXT,
    created_at INTEGER
);

-- å®ä½“è¯­ä¹‰ï¼š
-- 1. ç”¨æˆ·æ˜¯ä¸šåŠ¡å®ä½“
-- 2. ç”¨æˆ·æœ‰å”¯ä¸€æ ‡è¯†ï¼ˆidï¼‰
-- 3. ç”¨æˆ·æœ‰å±æ€§ï¼ˆname, email, created_atï¼‰
```

**PostgreSQLå®ä½“æ¨¡å‹**ï¼š

```sql
-- ç”¨æˆ·å®ä½“ï¼ˆå¢å¼ºè¯­ä¹‰ï¼‰
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) NOT NULL UNIQUE,  -- è¯­ä¹‰ï¼šé‚®ç®±å”¯ä¸€
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- å®ä½“è¯­ä¹‰å¢å¼ºï¼š
-- 1. ç±»å‹çº¦æŸï¼šnameå’Œemailéç©º
-- 2. å”¯ä¸€æ€§çº¦æŸï¼šemailå”¯ä¸€
-- 3. é»˜è®¤å€¼ï¼šcreated_atè‡ªåŠ¨è®¾ç½®
```

### 4.2 å…³ç³»æ¨¡å‹è½¬æ¢

#### èšåˆå…³ç³»è½¬æ¢

**SQLiteèšåˆå…³ç³»**ï¼š

```sql
-- SQLite: è®¢å•èšåˆ
CREATE TABLE orders (
    id INTEGER PRIMARY KEY,
    user_id INTEGER,
    total REAL
);

CREATE TABLE order_items (
    id INTEGER PRIMARY KEY,
    order_id INTEGER,
    product_id INTEGER,
    quantity INTEGER,
    price REAL
);

-- èšåˆè¯­ä¹‰ï¼šè®¢å•èšåˆè®¢å•é¡¹ï¼ˆåº”ç”¨å±‚ä¿è¯ï¼‰
```

**PostgreSQLèšåˆå…³ç³»**ï¼š

```sql
-- PostgreSQL: è®¢å•èšåˆï¼ˆæ•°æ®åº“å±‚ä¿è¯ï¼‰
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    total NUMERIC(10,2) NOT NULL
);

CREATE TABLE order_items (
    id SERIAL PRIMARY KEY,
    order_id INTEGER NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
    product_id INTEGER NOT NULL REFERENCES products(id),
    quantity INTEGER NOT NULL CHECK (quantity > 0),
    price NUMERIC(10,2) NOT NULL CHECK (price > 0)
);

-- èšåˆè¯­ä¹‰ï¼šçº§è”åˆ é™¤ä¿è¯èšåˆå®Œæ•´æ€§
```

### 4.3 èšåˆæ¨¡å‹è½¬æ¢

#### èšåˆæ ¹è¯†åˆ«

**SQLiteèšåˆæ¨¡å‹**ï¼š

```sql
-- SQLite: è®¢å•èšåˆï¼ˆåº”ç”¨å±‚ç®¡ç†ï¼‰
-- èšåˆæ ¹ï¼šorders
-- èšåˆæˆå‘˜ï¼šorder_items

-- åº”ç”¨å±‚ä»£ç 
class Order:
    def __init__(self, order_id):
        self.id = order_id
        self.items = []  # èšåˆæˆå‘˜

    def add_item(self, product_id, quantity, price):
        # ä¸šåŠ¡è§„åˆ™ï¼šèšåˆå†…é€»è¾‘
        self.items.append({
            'product_id': product_id,
            'quantity': quantity,
            'price': price
        })

    def save(self):
        # ä¿å­˜èšåˆ
        db.execute("INSERT INTO orders ...")
        for item in self.items:
            db.execute("INSERT INTO order_items ...", item)
```

**PostgreSQLèšåˆæ¨¡å‹**ï¼š

```sql
-- PostgreSQL: è®¢å•èšåˆï¼ˆæ•°æ®åº“å±‚ä¿è¯ï¼‰
-- èšåˆæ ¹ï¼šorders
-- èšåˆæˆå‘˜ï¼šorder_items

-- ä½¿ç”¨å¤–é”®å’Œçº§è”æ“ä½œä¿è¯èšåˆå®Œæ•´æ€§
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    -- èšåˆæ ¹å±æ€§
);

CREATE TABLE order_items (
    id SERIAL PRIMARY KEY,
    order_id INTEGER NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
    -- èšåˆæˆå‘˜å±æ€§
);

-- è¯­ä¹‰ï¼šæ•°æ®åº“å±‚ä¿è¯èšåˆå®Œæ•´æ€§
```

### 4.4 å€¼å¯¹è±¡è½¬æ¢

#### å€¼å¯¹è±¡è¯†åˆ«

**SQLiteå€¼å¯¹è±¡**ï¼š

```sql
-- SQLite: åœ°å€å€¼å¯¹è±¡ï¼ˆæ‰å¹³åŒ–å­˜å‚¨ï¼‰
CREATE TABLE users (
    id INTEGER PRIMARY KEY,
    name TEXT,
    address_street TEXT,
    address_city TEXT,
    address_zip TEXT
);

-- å€¼å¯¹è±¡è¯­ä¹‰ï¼šåœ°å€æ˜¯å€¼å¯¹è±¡ï¼Œæ²¡æœ‰ç‹¬ç«‹æ ‡è¯†
```

**PostgreSQLå€¼å¯¹è±¡**ï¼š

```sql
-- PostgreSQL: åœ°å€å€¼å¯¹è±¡ï¼ˆå¤åˆç±»å‹ï¼‰
CREATE TYPE address_type AS (
    street VARCHAR(255),
    city VARCHAR(100),
    zip VARCHAR(20)
);

CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    address address_type  -- è¯­ä¹‰ï¼šåœ°å€å€¼å¯¹è±¡
);

-- å€¼å¯¹è±¡è¯­ä¹‰ï¼šä½¿ç”¨å¤åˆç±»å‹è¡¨è¾¾å€¼å¯¹è±¡
```

---

## äº”ã€æ•°æ®è¿ç§»è¯­ä¹‰ä¿è¯

### 5.1 è¯­ä¹‰ç­‰ä»·æ€§éªŒè¯

#### éªŒè¯æ¡†æ¶

```python
class SemanticEquivalenceValidator:
    def __init__(self, sqlite_conn, pg_conn):
        self.sqlite_conn = sqlite_conn
        self.pg_conn = pg_conn

    def validate_type_semantics(self, table_name, column_name):
        """éªŒè¯ç±»å‹è¯­ä¹‰ç­‰ä»·æ€§"""
        # 1. æ£€æŸ¥SQLiteå®é™…ç±»å‹
        sqlite_types = self._analyze_sqlite_types(table_name, column_name)

        # 2. æ£€æŸ¥PostgreSQLç±»å‹
        pg_type = self._get_pg_type(table_name, column_name)

        # 3. éªŒè¯è¯­ä¹‰ç­‰ä»·æ€§
        return self._compare_type_semantics(sqlite_types, pg_type)

    def validate_constraint_semantics(self, table_name):
        """éªŒè¯çº¦æŸè¯­ä¹‰ç­‰ä»·æ€§"""
        # 1. æ£€æŸ¥SQLiteçº¦æŸ
        sqlite_constraints = self._get_sqlite_constraints(table_name)

        # 2. æ£€æŸ¥PostgreSQLçº¦æŸ
        pg_constraints = self._get_pg_constraints(table_name)

        # 3. éªŒè¯è¯­ä¹‰ç­‰ä»·æ€§
        return self._compare_constraint_semantics(sqlite_constraints, pg_constraints)

    def validate_relationship_semantics(self, table_name):
        """éªŒè¯å…³ç³»è¯­ä¹‰ç­‰ä»·æ€§"""
        # 1. æ£€æŸ¥SQLiteå…³ç³»
        sqlite_relations = self._get_sqlite_relations(table_name)

        # 2. æ£€æŸ¥PostgreSQLå…³ç³»
        pg_relations = self._get_pg_relations(table_name)

        # 3. éªŒè¯è¯­ä¹‰ç­‰ä»·æ€§
        return self._compare_relationship_semantics(sqlite_relations, pg_relations)
```

### 5.2 è¯­ä¹‰å®Œæ•´æ€§æ£€æŸ¥

#### å®Œæ•´æ€§æ£€æŸ¥æ¸…å•

```python
def check_semantic_integrity(sqlite_conn, pg_conn):
    """è¯­ä¹‰å®Œæ•´æ€§æ£€æŸ¥"""
    checks = {
        'type_semantics': check_type_semantics(sqlite_conn, pg_conn),
        'constraint_semantics': check_constraint_semantics(sqlite_conn, pg_conn),
        'relationship_semantics': check_relationship_semantics(sqlite_conn, pg_conn),
        'business_rule_semantics': check_business_rule_semantics(sqlite_conn, pg_conn),
        'data_semantics': check_data_semantics(sqlite_conn, pg_conn)
    }

    return checks
```

### 5.3 è¯­ä¹‰ä¸€è‡´æ€§ä¿è¯

#### ä¸€è‡´æ€§ä¿è¯æœºåˆ¶

```python
def ensure_semantic_consistency(sqlite_conn, pg_conn, migration_plan):
    """ä¿è¯è¯­ä¹‰ä¸€è‡´æ€§"""
    # 1. é¢„è¿ç§»è¯­ä¹‰åˆ†æ
    pre_analysis = analyze_semantics(sqlite_conn)

    # 2. æ‰§è¡Œè¿ç§»
    execute_migration(sqlite_conn, pg_conn, migration_plan)

    # 3. åè¿ç§»è¯­ä¹‰éªŒè¯
    post_analysis = analyze_semantics(pg_conn)

    # 4. è¯­ä¹‰ä¸€è‡´æ€§éªŒè¯
    consistency = verify_semantic_consistency(pre_analysis, post_analysis)

    if not consistency:
        rollback_migration(pg_conn)
        raise SemanticConsistencyError("Semantic consistency check failed")

    return True
```

---

## å…­ã€è¿ç§»åæ•°æ®åˆ†æ

### 6.1 æ•°æ®è´¨é‡åˆ†æ

#### æ•°æ®è´¨é‡æŒ‡æ ‡

```python
def analyze_data_quality(pg_conn):
    """åˆ†ææ•°æ®è´¨é‡"""
    quality_metrics = {
        'completeness': analyze_completeness(pg_conn),
        'accuracy': analyze_accuracy(pg_conn),
        'consistency': analyze_consistency(pg_conn),
        'validity': analyze_validity(pg_conn)
    }

    return quality_metrics

def analyze_completeness(pg_conn):
    """åˆ†ææ•°æ®å®Œæ•´æ€§"""
    cursor = pg_conn.cursor()

    completeness_report = {}

    # æ£€æŸ¥æ¯ä¸ªè¡¨çš„NULLå€¼æ¯”ä¾‹
    cursor.execute("""
        SELECT table_name, column_name,
               COUNT(*) as total_rows,
               COUNT(*) FILTER (WHERE {column_name} IS NULL) as null_count,
               ROUND(100.0 * COUNT(*) FILTER (WHERE {column_name} IS NULL) / COUNT(*), 2) as null_percentage
        FROM information_schema.columns
        WHERE table_schema = 'public'
        GROUP BY table_name, column_name
    """)

    return cursor.fetchall()
```

### 6.2 è¯­ä¹‰ä¸€è‡´æ€§åˆ†æ

#### è¯­ä¹‰ä¸€è‡´æ€§æ£€æŸ¥

```python
def analyze_semantic_consistency(pg_conn):
    """åˆ†æè¯­ä¹‰ä¸€è‡´æ€§"""
    # 1. æ£€æŸ¥ç±»å‹è¯­ä¹‰ä¸€è‡´æ€§
    type_consistency = check_type_semantic_consistency(pg_conn)

    # 2. æ£€æŸ¥çº¦æŸè¯­ä¹‰ä¸€è‡´æ€§
    constraint_consistency = check_constraint_semantic_consistency(pg_conn)

    # 3. æ£€æŸ¥å…³ç³»è¯­ä¹‰ä¸€è‡´æ€§
    relationship_consistency = check_relationship_semantic_consistency(pg_conn)

    return {
        'type_consistency': type_consistency,
        'constraint_consistency': constraint_consistency,
        'relationship_consistency': relationship_consistency
    }
```

### 6.3 æ€§èƒ½è¯­ä¹‰åˆ†æ

#### æ€§èƒ½è¯­ä¹‰éªŒè¯

```python
def analyze_performance_semantics(pg_conn):
    """åˆ†ææ€§èƒ½è¯­ä¹‰"""
    # 1. æŸ¥è¯¢æ€§èƒ½åˆ†æ
    query_performance = analyze_query_performance(pg_conn)

    # 2. ç´¢å¼•ä½¿ç”¨åˆ†æ
    index_usage = analyze_index_usage(pg_conn)

    # 3. è¿æ¥æ€§èƒ½åˆ†æ
    connection_performance = analyze_connection_performance(pg_conn)

    return {
        'query_performance': query_performance,
        'index_usage': index_usage,
        'connection_performance': connection_performance
    }
```

### 6.4 ä¸šåŠ¡è¯­ä¹‰éªŒè¯

#### ä¸šåŠ¡è¯­ä¹‰éªŒè¯

```python
def validate_business_semantics(pg_conn, business_rules):
    """éªŒè¯ä¸šåŠ¡è¯­ä¹‰"""
    violations = []

    for rule in business_rules:
        result = execute_business_rule_check(pg_conn, rule)
        if not result['passed']:
            violations.append({
                'rule': rule['name'],
                'violations': result['violations']
            })

    return {
        'passed': len(violations) == 0,
        'violations': violations
    }
```

---

## ä¸ƒã€æ•°æ®å¤„ç†ç­–ç•¥

### 7.1 æ•°æ®æ¸…æ´—

#### æ•°æ®æ¸…æ´—æµç¨‹

```python
def clean_migrated_data(pg_conn):
    """æ¸…æ´—è¿ç§»åçš„æ•°æ®"""
    # 1. æ¸…ç†NULLå€¼
    clean_null_values(pg_conn)

    # 2. æ¸…ç†é‡å¤æ•°æ®
    clean_duplicates(pg_conn)

    # 3. æ¸…ç†æ— æ•ˆæ•°æ®
    clean_invalid_data(pg_conn)

    # 4. æ ‡å‡†åŒ–æ•°æ®æ ¼å¼
    normalize_data_format(pg_conn)
```

### 7.2 æ•°æ®è½¬æ¢

#### æ•°æ®æ ¼å¼è½¬æ¢

```python
def transform_data_format(pg_conn):
    """è½¬æ¢æ•°æ®æ ¼å¼"""
    # 1. æ—¥æœŸæ—¶é—´æ ¼å¼è½¬æ¢
    transform_datetime_format(pg_conn)

    # 2. æ•°å€¼æ ¼å¼è½¬æ¢
    transform_numeric_format(pg_conn)

    # 3. æ–‡æœ¬æ ¼å¼è½¬æ¢
    transform_text_format(pg_conn)
```

### 7.3 æ•°æ®éªŒè¯

#### æ•°æ®éªŒè¯æµç¨‹

```python
def validate_migrated_data(pg_conn, validation_rules):
    """éªŒè¯è¿ç§»åçš„æ•°æ®"""
    validation_results = {}

    for rule in validation_rules:
        result = execute_validation_rule(pg_conn, rule)
        validation_results[rule['name']] = result

    return validation_results
```

### 7.4 æ•°æ®ä¿®å¤

#### æ•°æ®ä¿®å¤ç­–ç•¥

```python
def repair_migrated_data(pg_conn, repair_rules):
    """ä¿®å¤è¿ç§»åçš„æ•°æ®"""
    repair_results = {}

    for rule in repair_rules:
        result = execute_repair_rule(pg_conn, rule)
        repair_results[rule['name']] = result

    return repair_results
```

---

## å…«ã€å®æˆ˜æ¡ˆä¾‹

### 8.1 ç”µå•†ç³»ç»Ÿè¿ç§»

**åœºæ™¯**ï¼šç”µå•†ç³»ç»Ÿä»SQLiteè¿ç§»åˆ°PostgreSQL

**è¯­ä¹‰æ¨¡å‹è½¬æ¢**ï¼š

- è®¢å•èšåˆæ¨¡å‹è½¬æ¢
- å•†å“åˆ†ç±»æ ‘æ¨¡å‹è½¬æ¢
- ç”¨æˆ·æƒé™æ¨¡å‹è½¬æ¢

### 8.2 é‡‘èç³»ç»Ÿè¿ç§»

**åœºæ™¯**ï¼šé‡‘èç³»ç»Ÿä»SQLiteè¿ç§»åˆ°PostgreSQL

**è¯­ä¹‰æ¨¡å‹è½¬æ¢**ï¼š

- è´¦æˆ·æ¨¡å‹è½¬æ¢
- äº¤æ˜“æ¨¡å‹è½¬æ¢
- é£æ§è§„åˆ™æ¨¡å‹è½¬æ¢

### 8.3 æ—¥å¿—ç³»ç»Ÿè¿ç§»

**åœºæ™¯**ï¼šæ—¥å¿—ç³»ç»Ÿä»SQLiteè¿ç§»åˆ°PostgreSQL

**è¯­ä¹‰æ¨¡å‹è½¬æ¢**ï¼š

- æ—¥å¿—èšåˆæ¨¡å‹è½¬æ¢
- æ—¶é—´åºåˆ—æ¨¡å‹è½¬æ¢
- ç´¢å¼•æ¨¡å‹è½¬æ¢

---

## ğŸ”— ç›¸å…³èµ„æº

- [10.01 SQLiteåˆ°PostgreSQLè¿ç§»æŒ‡å—](./10.01-SQLiteåˆ°PostgreSQLè¿ç§»æŒ‡å—.md)
- [10.02 SQLå…¼å®¹æ€§æ·±åº¦åˆ†æ](./10.02-SQLå…¼å®¹æ€§æ·±åº¦åˆ†æ.md)
- [10.03 äºŒè¿›åˆ¶å¤åˆ¶ä¸å¢é‡è¿ç§»](./10.03-äºŒè¿›åˆ¶å¤åˆ¶ä¸å¢é‡è¿ç§».md)

---

## ğŸ“š å‚è€ƒèµ„æ–™

- [é¢†åŸŸé©±åŠ¨è®¾è®¡](https://www.domainlanguage.com/ddd/)
- [æ•°æ®è¯­ä¹‰å»ºæ¨¡](https://www.w3.org/TR/vocab-dcat/)
- [PostgreSQLé¢†åŸŸç±»å‹](https://www.postgresql.org/docs/current/extend-type-system.html)

---

**ç»´æŠ¤è€…**ï¼šData-Science Team
**æœ€åæ›´æ–°**ï¼š2025-11-13
