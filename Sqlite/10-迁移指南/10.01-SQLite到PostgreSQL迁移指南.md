# SQLite 到 PostgreSQL 迁移指南

> **创建日期**：2025-11-13
> **最后更新**：2025-01-15
> **适用版本**：SQLite 3.31+ 至 3.47.x → PostgreSQL 12+

---

## 📋 概述

本文档提供从SQLite迁移到PostgreSQL的完整指南，涵盖数据模型转换、特性映射、迁移策略和最佳实践，基于当前网络上最成熟的案例和方案。

---

## 📑 目录

- [SQLite 到 PostgreSQL 迁移指南](#sqlite-到-postgresql-迁移指南)
  - [📋 概述](#-概述)
  - [📑 目录](#-目录)
  - [📊 思维导图](#-思维导图)
  - [一、迁移决策框架](#一迁移决策框架)
    - [1.1 何时需要迁移](#11-何时需要迁移)
      - [触发迁移的业务场景](#触发迁移的业务场景)
      - [技术指标阈值](#技术指标阈值)
    - [1.2 迁移成本评估](#12-迁移成本评估)
      - [成本维度分析](#成本维度分析)
    - [1.3 迁移风险评估](#13-迁移风险评估)
      - [风险矩阵](#风险矩阵)
  - [二、数据模型转换](#二数据模型转换)
    - [2.1 数据类型映射](#21-数据类型映射)
      - [核心类型映射表](#核心类型映射表)
      - [动态类型处理](#动态类型处理)
      - [类型转换策略](#类型转换策略)
    - [2.2 表结构转换](#22-表结构转换)
      - [主键转换](#主键转换)
      - [外键转换](#外键转换)
      - [默认值转换](#默认值转换)
    - [2.3 约束转换](#23-约束转换)
      - [CHECK约束](#check约束)
      - [UNIQUE约束](#unique约束)
    - [2.4 索引转换](#24-索引转换)
      - [基本索引](#基本索引)
      - [复合索引](#复合索引)
      - [特殊索引](#特殊索引)
  - [三、SQL语法差异处理](#三sql语法差异处理)
    - [3.1 DDL差异](#31-ddl差异)
      - [CREATE TABLE差异](#create-table差异)
      - [ALTER TABLE差异](#alter-table差异)
    - [3.2 DML差异](#32-dml差异)
      - [INSERT差异](#insert差异)
      - [UPDATE差异](#update差异)
    - [3.3 函数差异](#33-函数差异)
      - [字符串函数](#字符串函数)
      - [日期时间函数](#日期时间函数)
      - [聚合函数](#聚合函数)
    - [3.4 特性差异](#34-特性差异)
      - [窗口函数](#窗口函数)
      - [CTE（公共表表达式）](#cte公共表表达式)
  - [四、架构特性转换](#四架构特性转换)
    - [4.1 并发控制转换](#41-并发控制转换)
      - [SQLite WAL模式 → PostgreSQL MVCC](#sqlite-wal模式--postgresql-mvcc)
      - [锁机制转换](#锁机制转换)
    - [4.2 事务处理转换](#42-事务处理转换)
      - [事务隔离级别](#事务隔离级别)
      - [SAVEPOINT处理](#savepoint处理)
    - [4.3 存储引擎差异](#43-存储引擎差异)
      - [文件结构](#文件结构)
      - [存储优化](#存储优化)
    - [4.4 连接管理转换](#44-连接管理转换)
      - [连接方式](#连接方式)
      - [连接池](#连接池)
  - [五、迁移工具和方案](#五迁移工具和方案)
    - [5.1 官方工具](#51-官方工具)
      - [pgloader](#pgloader)
    - [5.2 第三方工具](#52-第三方工具)
      - [SQLite to PostgreSQL Converter](#sqlite-to-postgresql-converter)
      - [自定义Python脚本](#自定义python脚本)
    - [5.3 自定义迁移脚本](#53-自定义迁移脚本)
      - [完整迁移脚本框架](#完整迁移脚本框架)
    - [5.4 成熟案例参考](#54-成熟案例参考)
      - [案例1：Django项目迁移](#案例1django项目迁移)
      - [案例2：Rails项目迁移](#案例2rails项目迁移)
      - [案例3：Node.js项目迁移](#案例3nodejs项目迁移)
  - [六、迁移执行流程](#六迁移执行流程)
    - [6.1 迁移前准备](#61-迁移前准备)
      - [环境准备清单](#环境准备清单)
      - [数据备份](#数据备份)
      - [环境测试](#环境测试)
    - [6.2 数据迁移步骤](#62-数据迁移步骤)
      - [步骤1：迁移表结构](#步骤1迁移表结构)
      - [步骤2：迁移数据](#步骤2迁移数据)
      - [步骤3：迁移索引](#步骤3迁移索引)
      - [步骤4：迁移约束](#步骤4迁移约束)
    - [6.3 应用代码迁移](#63-应用代码迁移)
      - [ORM迁移](#orm迁移)
      - [原生SQL迁移](#原生sql迁移)
    - [6.4 迁移后验证](#64-迁移后验证)
      - [数据完整性验证](#数据完整性验证)
      - [性能验证](#性能验证)
  - [七、性能优化调整](#七性能优化调整)
    - [7.1 查询优化差异](#71-查询优化差异)
      - [查询计划器](#查询计划器)
      - [优化建议](#优化建议)
    - [7.2 索引策略调整](#72-索引策略调整)
      - [索引类型选择](#索引类型选择)
    - [7.3 连接池配置](#73-连接池配置)
      - [PostgreSQL连接池配置](#postgresql连接池配置)
      - [PgBouncer配置](#pgbouncer配置)
    - [7.4 缓存策略调整](#74-缓存策略调整)
      - [PostgreSQL缓存配置](#postgresql缓存配置)
  - [八、常见问题和解决方案](#八常见问题和解决方案)
    - [8.1 数据类型问题](#81-数据类型问题)
      - [问题1：INTEGER溢出](#问题1integer溢出)
      - [问题2：日期时间格式](#问题2日期时间格式)
    - [8.2 并发问题](#82-并发问题)
      - [问题1：锁等待](#问题1锁等待)
    - [8.3 性能问题](#83-性能问题)
      - [问题1：查询变慢](#问题1查询变慢)
    - [8.4 兼容性问题](#84-兼容性问题)
      - [问题1：函数不兼容](#问题1函数不兼容)
  - [九、成熟案例研究](#九成熟案例研究)
    - [9.1 案例一：Web应用迁移](#91-案例一web应用迁移)
      - [背景](#背景)
      - [迁移方案](#迁移方案)
      - [迁移结果](#迁移结果)
    - [9.2 案例二：数据分析平台迁移](#92-案例二数据分析平台迁移)
      - [背景](#背景-1)
      - [迁移方案](#迁移方案-1)
      - [迁移结果](#迁移结果-1)
    - [9.3 案例三：移动应用后端迁移](#93-案例三移动应用后端迁移)
      - [背景](#背景-2)
      - [迁移方案](#迁移方案-2)
      - [迁移结果](#迁移结果-2)
  - [📊 SQLite vs PostgreSQL 多维对比矩阵](#-sqlite-vs-postgresql-多维对比矩阵)
    - [迁移决策多维对比矩阵](#迁移决策多维对比矩阵)
    - [迁移工具对比矩阵](#迁移工具对比矩阵)
    - [数据类型映射对比矩阵](#数据类型映射对比矩阵)
    - [迁移策略对比矩阵](#迁移策略对比矩阵)
  - [📊 迁移检查清单](#-迁移检查清单)
    - [迁移前](#迁移前)
    - [迁移中](#迁移中)
    - [迁移后](#迁移后)
  - [🔗 相关资源](#-相关资源)
  - [🔗 交叉引用](#-交叉引用)
    - [理论模型 🆕](#理论模型-)
    - [设计模型 🆕](#设计模型-)
  - [📚 参考资料](#-参考资料)
    - [官方文档](#官方文档)
    - [迁移工具](#迁移工具)
    - [成熟案例](#成熟案例)

---

## 📊 思维导图

```mermaid
mindmap
  root((SQLite到PostgreSQL迁移))
    迁移决策框架
      何时需要迁移
        触发迁移的业务场景
          高并发需求
          大规模数据
          网络访问需求
        技术指标阈值
          并发连接数
          数据量大小
          性能要求
      迁移成本评估
        成本维度分析
          开发成本
          运维成本
          迁移时间
      迁移风险评估
        风险矩阵
          技术风险
          业务风险
          数据风险
    数据模型转换
      数据类型映射
        核心类型映射表
          INTEGER → INTEGER
          TEXT → TEXT/VARCHAR
          REAL → REAL/DOUBLE PRECISION
          BLOB → BYTEA
        动态类型处理
          类型检查
          类型转换
        类型转换策略
      表结构转换
        主键转换
          AUTOINCREMENT → SERIAL
          主键约束
        外键转换
          外键约束
          引用完整性
        默认值转换
          默认值处理
      约束转换
        CHECK约束
        UNIQUE约束
        NOT NULL约束
      索引转换
        基本索引
        复合索引
        特殊索引
    SQL语法差异处理
      DDL差异
        CREATE TABLE差异
        ALTER TABLE差异
      DML差异
        INSERT差异
        UPDATE差异
      函数差异
        字符串函数
        日期时间函数
        聚合函数
      特性差异
        窗口函数
        CTE公共表表达式
    架构特性转换
      并发控制转换
        SQLite WAL模式 → PostgreSQL MVCC
        锁机制转换
      事务处理转换
        事务隔离级别
        SAVEPOINT处理
      存储引擎差异
        文件结构
        存储优化
      连接管理转换
        连接方式
        连接池
    迁移工具和方案
      官方工具
        pgloader
        迁移工具
      第三方工具
        SQLite to PostgreSQL Converter
        自定义Python脚本
      自定义迁移脚本
        完整迁移脚本框架
      成熟案例参考
        Django项目迁移
        Rails项目迁移
        Node.js项目迁移
    迁移执行流程
      迁移前准备
        环境准备清单
        数据备份
        环境测试
      数据迁移步骤
        迁移表结构
        迁移数据
        迁移索引
        迁移约束
      应用代码迁移
        ORM迁移
        原生SQL迁移
      迁移后验证
        数据完整性验证
        性能验证
    性能优化调整
      查询优化差异
        索引策略
        查询重写
      配置优化
        连接池配置
        缓存配置
```

---

## 一、迁移决策框架

### 1.1 何时需要迁移

#### 触发迁移的业务场景

| 场景 | SQLite限制 | PostgreSQL优势 | 迁移优先级 |
|------|-----------|---------------|-----------|
| 高并发写入 | 单写者限制 | 多写者并发 | 🔴 高 |
| 多用户网络服务 | 文件锁限制 | 客户端-服务器架构 | 🔴 高 |
| 大数据量（>100GB） | 单文件限制 | 表分区、分布式 | 🟡 中 |
| 复杂查询需求 | 查询优化器限制 | 高级优化器、并行查询 | 🟡 中 |
| 需要高级特性 | 功能受限 | JSONB、全文搜索、数组等 | 🟢 低 |
| 需要复制和HA | 不支持 | 流复制、逻辑复制 | 🔴 高 |

#### 技术指标阈值

```python
# 迁移决策指标
迁移指标 = {
    "并发写入数": "> 10 writes/sec → 考虑迁移",
    "数据库大小": "> 100GB → 考虑迁移",
    "并发连接数": "> 50 → 考虑迁移",
    "查询复杂度": "需要窗口函数、CTE等 → 考虑迁移",
    "可用性要求": "需要HA、复制 → 必须迁移"
}
```

### 1.2 迁移成本评估

#### 成本维度分析

**开发成本**：

- 数据模型转换：20-40工时
- SQL语法调整：10-20工时
- 应用代码修改：40-80工时
- 测试和验证：30-60工时
- **总计**：100-200工时（2-5周）

**运维成本**：

- 服务器资源：PostgreSQL需要更多内存和CPU
- 监控工具：需要PostgreSQL专用监控
- 备份策略：需要调整备份方案
- 维护成本：需要PostgreSQL DBA技能

**风险成本**：

- 数据丢失风险：迁移过程中的数据一致性
- 服务中断风险：迁移期间的停机时间
- 性能下降风险：迁移后性能可能暂时下降

### 1.3 迁移风险评估

#### 风险矩阵

| 风险类型 | 概率 | 影响 | 缓解措施 |
|---------|------|------|---------|
| 数据丢失 | 低 | 高 | 完整备份、分阶段迁移 |
| 性能下降 | 中 | 中 | 性能测试、优化调整 |
| 兼容性问题 | 高 | 中 | 充分测试、渐进迁移 |
| 服务中断 | 中 | 高 | 蓝绿部署、回滚方案 |

---

## 二、数据模型转换

### 2.1 数据类型映射

#### 核心类型映射表

| SQLite类型 | PostgreSQL类型 | 说明 | 注意事项 |
|-----------|---------------|------|---------|
| INTEGER | INTEGER / BIGINT | 根据值范围选择 | SQLite INTEGER可能溢出 |
| REAL | REAL / DOUBLE PRECISION | 浮点数 | 精度可能不同 |
| TEXT | TEXT / VARCHAR(n) | 文本 | PostgreSQL可指定长度 |
| BLOB | BYTEA | 二进制数据 | 编码方式不同 |
| NULL | NULL | 空值 | 行为一致 |
| NUMERIC | NUMERIC(p,s) | 精确数值 | PostgreSQL需要指定精度 |

#### 动态类型处理

**SQLite动态类型 → PostgreSQL静态类型**：

```sql
-- SQLite: 动态类型
CREATE TABLE users (
    id INTEGER PRIMARY KEY,
    name TEXT,
    age INTEGER,  -- 但可以存储TEXT
    balance REAL   -- 但可以存储TEXT
);

-- PostgreSQL: 静态类型（严格模式）
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    age INTEGER CHECK (age > 0),
    balance NUMERIC(10,2) NOT NULL DEFAULT 0
);
```

#### 类型转换策略

**策略1：严格类型检查**:

```sql
-- 迁移前：检查SQLite数据
SELECT
    typeof(age) as age_type,
    COUNT(*) as count
FROM users
GROUP BY typeof(age);

-- 迁移后：PostgreSQL强制类型
ALTER TABLE users
    ALTER COLUMN age TYPE INTEGER
    USING age::INTEGER;
```

**策略2：宽松类型转换**:

```sql
-- 使用PostgreSQL的CAST函数
ALTER TABLE users
    ALTER COLUMN age TYPE INTEGER
    USING CASE
        WHEN age ~ '^[0-9]+$' THEN age::INTEGER
        ELSE NULL
    END;
```

### 2.2 表结构转换

#### 主键转换

```sql
-- SQLite: INTEGER PRIMARY KEY (自动递增)
CREATE TABLE users (
    id INTEGER PRIMARY KEY,
    name TEXT
);

-- PostgreSQL: SERIAL / IDENTITY
CREATE TABLE users (
    id SERIAL PRIMARY KEY,  -- 方式1：SERIAL
    -- 或
    id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,  -- 方式2：IDENTITY
    name TEXT
);
```

#### 外键转换

```sql
-- SQLite: 外键需要显式启用
PRAGMA foreign_keys = ON;

CREATE TABLE orders (
    id INTEGER PRIMARY KEY,
    user_id INTEGER,
    FOREIGN KEY (user_id) REFERENCES users(id)
);

-- PostgreSQL: 外键默认启用
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE
);
```

#### 默认值转换

```sql
-- SQLite: 支持函数默认值
CREATE TABLE logs (
    id INTEGER PRIMARY KEY,
    created_at INTEGER DEFAULT (strftime('%s', 'now'))
);

-- PostgreSQL: 使用函数默认值
CREATE TABLE logs (
    id SERIAL PRIMARY KEY,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 2.3 约束转换

#### CHECK约束

```sql
-- SQLite: CHECK约束
CREATE TABLE products (
    id INTEGER PRIMARY KEY,
    price REAL CHECK (price > 0),
    stock INTEGER CHECK (stock >= 0)
);

-- PostgreSQL: CHECK约束（更强大）
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    price NUMERIC(10,2) CHECK (price > 0),
    stock INTEGER CHECK (stock >= 0 AND stock <= 10000)
);
```

#### UNIQUE约束

```sql
-- SQLite: UNIQUE约束
CREATE TABLE users (
    id INTEGER PRIMARY KEY,
    email TEXT UNIQUE,
    username TEXT UNIQUE
);

-- PostgreSQL: UNIQUE约束（支持部分索引）
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    email VARCHAR(255) UNIQUE,
    username VARCHAR(50) UNIQUE
);

-- PostgreSQL额外功能：部分唯一索引
CREATE UNIQUE INDEX users_active_email_idx
    ON users (email)
    WHERE deleted_at IS NULL;
```

### 2.4 索引转换

#### 基本索引

```sql
-- SQLite: 简单索引
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_orders_user_id ON orders(user_id);

-- PostgreSQL: 相同语法，但支持更多选项
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_orders_user_id ON orders(user_id);

-- PostgreSQL额外功能：覆盖索引
CREATE INDEX idx_users_covering ON users(email) INCLUDE (name, created_at);
```

#### 复合索引

```sql
-- SQLite: 复合索引
CREATE INDEX idx_orders_user_date ON orders(user_id, created_at);

-- PostgreSQL: 相同，但支持排序方向
CREATE INDEX idx_orders_user_date ON orders(user_id, created_at DESC);
```

#### 特殊索引

```sql
-- SQLite: 全文搜索索引（FTS5）
CREATE VIRTUAL TABLE articles_fts USING fts5(title, content);

-- PostgreSQL: 全文搜索索引（GIN）
CREATE TABLE articles (
    id SERIAL PRIMARY KEY,
    title TEXT,
    content TEXT
);

CREATE INDEX articles_fts_idx ON articles
    USING GIN (to_tsvector('english', title || ' ' || content));
```

---

## 三、SQL语法差异处理

### 3.1 DDL差异

#### CREATE TABLE差异

**AUTOINCREMENT处理**：

```sql
-- SQLite
CREATE TABLE users (
    id INTEGER PRIMARY KEY AUTOINCREMENT
);

-- PostgreSQL
CREATE TABLE users (
    id SERIAL PRIMARY KEY
    -- 或
    -- id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY
);
```

**列定义差异**：

```sql
-- SQLite: 动态类型
CREATE TABLE products (
    id INTEGER PRIMARY KEY,
    name TEXT,
    price REAL
);

-- PostgreSQL: 严格类型
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    price NUMERIC(10,2) NOT NULL
);
```

#### ALTER TABLE差异

**SQLite限制**：

- 不支持DROP COLUMN（3.35.0+支持）
- 不支持RENAME COLUMN（3.25.0+支持）
- 不支持ADD COLUMN的某些约束

**PostgreSQL优势**：

```sql
-- PostgreSQL: 完整的ALTER TABLE支持
ALTER TABLE users
    ADD COLUMN email VARCHAR(255),
    DROP COLUMN old_email,
    ALTER COLUMN name TYPE VARCHAR(100),
    RENAME COLUMN age TO user_age;
```

### 3.2 DML差异

#### INSERT差异

**RETURNING子句**：

```sql
-- SQLite: 不支持RETURNING
INSERT INTO users (name, email) VALUES ('Alice', 'alice@example.com');
-- 需要额外查询获取ID

-- PostgreSQL: 支持RETURNING
INSERT INTO users (name, email)
VALUES ('Alice', 'alice@example.com')
RETURNING id, created_at;
```

**ON CONFLICT处理**：

```sql
-- SQLite: UPSERT语法
INSERT INTO users (id, name, email)
VALUES (1, 'Alice', 'alice@example.com')
ON CONFLICT(id) DO UPDATE SET
    name = EXCLUDED.name,
    email = EXCLUDED.email;

-- PostgreSQL: 相同语法（SQL:2016标准）
INSERT INTO users (id, name, email)
VALUES (1, 'Alice', 'alice@example.com')
ON CONFLICT (id) DO UPDATE SET
    name = EXCLUDED.name,
    email = EXCLUDED.email;
```

#### UPDATE差异

**多表UPDATE**：

```sql
-- SQLite: 不支持多表UPDATE
UPDATE orders o
SET total = (SELECT SUM(price) FROM order_items WHERE order_id = o.id)
WHERE o.id = 1;

-- PostgreSQL: 支持多表UPDATE
UPDATE orders o
SET total = oi.sum_price
FROM (
    SELECT order_id, SUM(price) as sum_price
    FROM order_items
    GROUP BY order_id
) oi
WHERE o.id = oi.order_id;
```

### 3.3 函数差异

#### 字符串函数

| SQLite函数 | PostgreSQL函数 | 说明 |
|-----------|---------------|------|
| `\|\|` | `\|\|` 或 `CONCAT()` | 字符串连接 |
| `LENGTH()` | `LENGTH()` 或 `CHAR_LENGTH()` | 字符串长度 |
| `SUBSTR()` | `SUBSTRING()` | 子字符串 |
| `REPLACE()` | `REPLACE()` | 替换 |
| `UPPER()` / `LOWER()` | `UPPER()` / `LOWER()` | 大小写转换 |
| `TRIM()` | `TRIM()` | 去除空格 |

#### 日期时间函数

```sql
-- SQLite: 日期时间函数
SELECT
    datetime('now'),
    date('now'),
    strftime('%Y-%m-%d', 'now'),
    julianday('now') - julianday('2020-01-01') as days;

-- PostgreSQL: 日期时间函数
SELECT
    NOW(),
    CURRENT_DATE,
    TO_CHAR(NOW(), 'YYYY-MM-DD'),
    EXTRACT(EPOCH FROM (NOW() - '2020-01-01'::DATE)) / 86400 as days;
```

#### 聚合函数

```sql
-- SQLite: 基本聚合函数
SELECT
    COUNT(*),
    AVG(price),
    SUM(quantity),
    MAX(created_at),
    MIN(created_at)
FROM orders;

-- PostgreSQL: 相同，但支持更多
SELECT
    COUNT(*),
    AVG(price),
    SUM(quantity),
    MAX(created_at),
    MIN(created_at),
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY price) as median  -- 额外功能
FROM orders;
```

### 3.4 特性差异

#### 窗口函数

```sql
-- SQLite: 3.25.0+支持窗口函数
SELECT
    id,
    name,
    salary,
    ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) as rank
FROM employees;

-- PostgreSQL: 完整窗口函数支持（SQL:2016标准）
SELECT
    id,
    name,
    salary,
    ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) as rank,
    LAG(salary) OVER (PARTITION BY department ORDER BY salary DESC) as prev_salary,
    LEAD(salary) OVER (PARTITION BY department ORDER BY salary DESC) as next_salary
FROM employees;
```

#### CTE（公共表表达式）

```sql
-- SQLite: 3.8.3+支持CTE
WITH RECURSIVE categories AS (
    SELECT id, name, parent_id, 0 as level
    FROM category
    WHERE parent_id IS NULL
    UNION ALL
    SELECT c.id, c.name, c.parent_id, cat.level + 1
    FROM category c
    JOIN categories cat ON c.parent_id = cat.id
)
SELECT * FROM categories;

-- PostgreSQL: 完整CTE支持（相同语法）
WITH RECURSIVE categories AS (
    SELECT id, name, parent_id, 0 as level
    FROM category
    WHERE parent_id IS NULL
    UNION ALL
    SELECT c.id, c.name, c.parent_id, cat.level + 1
    FROM category c
    JOIN categories cat ON c.parent_id = cat.id
)
SELECT * FROM categories;
```

---

## 四、架构特性转换

### 4.1 并发控制转换

#### SQLite WAL模式 → PostgreSQL MVCC

**SQLite WAL模式**：

```sql
-- SQLite: WAL模式（一写多读）
PRAGMA journal_mode=WAL;
PRAGMA synchronous=NORMAL;
```

**PostgreSQL MVCC**：

```sql
-- PostgreSQL: MVCC（多写多读）
-- 默认支持，无需特殊配置
-- 支持多种隔离级别
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;  -- 默认
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```

#### 锁机制转换

| SQLite锁 | PostgreSQL锁 | 说明 |
|---------|-------------|------|
| UNLOCKED | 无锁 | 无连接 |
| SHARED | AccessShareLock | 读锁 |
| RESERVED | RowExclusiveLock | 写锁准备 |
| PENDING | ShareLock | 等待写锁 |
| EXCLUSIVE | ExclusiveLock | 排他锁 |

### 4.2 事务处理转换

#### 事务隔离级别

```sql
-- SQLite: SERIALIZABLE（唯一隔离级别）
BEGIN TRANSACTION;
-- 操作
COMMIT;

-- PostgreSQL: 多种隔离级别
BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;
-- 操作
COMMIT;
```

#### SAVEPOINT处理

```sql
-- SQLite: SAVEPOINT
BEGIN;
SAVEPOINT sp1;
-- 操作1
RELEASE SAVEPOINT sp1;
SAVEPOINT sp2;
-- 操作2
ROLLBACK TO SAVEPOINT sp2;
COMMIT;

-- PostgreSQL: 相同语法
BEGIN;
SAVEPOINT sp1;
-- 操作1
RELEASE SAVEPOINT sp1;
SAVEPOINT sp2;
-- 操作2
ROLLBACK TO SAVEPOINT sp2;
COMMIT;
```

### 4.3 存储引擎差异

#### 文件结构

**SQLite**：

- 单文件数据库
- 页大小：512B - 64KB
- B-Tree存储

**PostgreSQL**：

- 多文件存储（表空间）
- 页大小：8KB（固定）
- Heap + B-Tree索引

#### 存储优化

```sql
-- SQLite: VACUUM优化
VACUUM;
VACUUM INTO 'backup.db';

-- PostgreSQL: VACUUM和ANALYZE
VACUUM ANALYZE;
VACUUM FULL;  -- 更彻底的清理
```

### 4.4 连接管理转换

#### 连接方式

**SQLite**：

```python
# SQLite: 文件连接
import sqlite3
conn = sqlite3.connect('database.db')
```

**PostgreSQL**：

```python
# PostgreSQL: 网络连接
import psycopg2
conn = psycopg2.connect(
    host='localhost',
    port=5432,
    database='mydb',
    user='user',
    password='password'
)
```

#### 连接池

**SQLite**：通常单连接

```python
# SQLite: 单连接模式
conn = sqlite3.connect('database.db', check_same_thread=False)
```

**PostgreSQL**：需要连接池

```python
# PostgreSQL: 连接池（使用psycopg2.pool）
from psycopg2 import pool

connection_pool = pool.SimpleConnectionPool(
    minconn=1,
    maxconn=20,
    host='localhost',
    port=5432,
    database='mydb',
    user='user',
    password='password'
)
```

---

## 五、迁移工具和方案

### 5.1 官方工具

#### pgloader

**功能**：PostgreSQL官方推荐的迁移工具

**特点**：

- 支持SQLite到PostgreSQL迁移
- 自动类型转换
- 并行迁移
- 错误处理

**使用示例**：

```bash
# 安装pgloader
# Ubuntu/Debian
sudo apt-get install pgloader

# 迁移命令
pgloader sqlite:///path/to/database.db postgresql://user:password@localhost/dbname
```

**配置文件方式**：

```lisp
LOAD DATABASE
    FROM sqlite:///path/to/database.db
    INTO postgresql://user:password@localhost/dbname

WITH
    include drop, create tables, create indexes, reset sequences

SET work_mem to '256MB',
    maintenance_work_mem to '512MB'

CAST type datetime to timestamptz
     drop default drop not null using zero-dates-to-null,
     type date to date
     drop default drop not null using zero-dates-to-null

BEFORE LOAD DO
    $$ create schema if not exists migration; $$;
```

### 5.2 第三方工具

#### SQLite to PostgreSQL Converter

**在线工具**：

- <https://www.rebasedata.com/>
- <https://dbconvert.com/sqlite/postgresql/>

**特点**：

- 图形界面
- 自动转换
- 支持大文件

#### 自定义Python脚本

```python
#!/usr/bin/env python3
"""
SQLite to PostgreSQL Migration Script
基于成熟的迁移方案
"""

import sqlite3
import psycopg2
from psycopg2.extras import execute_values

def migrate_table(sqlite_conn, pg_conn, table_name):
    """迁移单个表"""
    # 1. 获取SQLite表结构
    sqlite_cursor = sqlite_conn.cursor()
    sqlite_cursor.execute(f"PRAGMA table_info({table_name})")
    columns = sqlite_cursor.fetchall()

    # 2. 创建PostgreSQL表
    pg_cursor = pg_conn.cursor()
    create_table_sql = generate_pg_create_table(table_name, columns)
    pg_cursor.execute(create_table_sql)

    # 3. 迁移数据
    sqlite_cursor.execute(f"SELECT * FROM {table_name}")
    rows = sqlite_cursor.fetchall()

    if rows:
        columns_list = [col[1] for col in columns]
        execute_values(
            pg_cursor,
            f"INSERT INTO {table_name} ({','.join(columns_list)}) VALUES %s",
            rows
        )

    pg_conn.commit()

def generate_pg_create_table(table_name, columns):
    """生成PostgreSQL CREATE TABLE语句"""
    # 类型映射逻辑
    type_mapping = {
        'INTEGER': 'INTEGER',
        'REAL': 'DOUBLE PRECISION',
        'TEXT': 'TEXT',
        'BLOB': 'BYTEA'
    }

    # 构建CREATE TABLE语句
    # ... 实现细节
    pass
```

### 5.3 自定义迁移脚本

#### 完整迁移脚本框架

```python
"""
完整的SQLite到PostgreSQL迁移脚本
参考成熟的开源方案
"""

import sqlite3
import psycopg2
import json
from typing import Dict, List, Tuple

class SQLiteToPostgreSQLMigrator:
    """SQLite到PostgreSQL迁移器"""

    def __init__(self, sqlite_path: str, pg_config: Dict):
        self.sqlite_conn = sqlite3.connect(sqlite_path)
        self.pg_conn = psycopg2.connect(**pg_config)
        self.type_mapping = self._init_type_mapping()

    def _init_type_mapping(self) -> Dict:
        """初始化类型映射"""
        return {
            'INTEGER': 'INTEGER',
            'REAL': 'DOUBLE PRECISION',
            'TEXT': 'TEXT',
            'BLOB': 'BYTEA',
            'NUMERIC': 'NUMERIC'
        }

    def migrate_schema(self):
        """迁移数据库结构"""
        tables = self._get_sqlite_tables()
        for table in tables:
            self._migrate_table_schema(table)

    def migrate_data(self):
        """迁移数据"""
        tables = self._get_sqlite_tables()
        for table in tables:
            self._migrate_table_data(table)

    def migrate_indexes(self):
        """迁移索引"""
        tables = self._get_sqlite_tables()
        for table in tables:
            self._migrate_table_indexes(table)

    def _get_sqlite_tables(self) -> List[str]:
        """获取SQLite所有表"""
        cursor = self.sqlite_conn.cursor()
        cursor.execute("""
            SELECT name FROM sqlite_master
            WHERE type='table' AND name NOT LIKE 'sqlite_%'
        """)
        return [row[0] for row in cursor.fetchall()]

    def _migrate_table_schema(self, table_name: str):
        """迁移表结构"""
        # 获取SQLite表结构
        sqlite_schema = self._get_sqlite_schema(table_name)

        # 转换为PostgreSQL DDL
        pg_ddl = self._convert_to_pg_ddl(table_name, sqlite_schema)

        # 执行PostgreSQL DDL
        pg_cursor = self.pg_conn.cursor()
        pg_cursor.execute(pg_ddl)
        self.pg_conn.commit()

    def _migrate_table_data(self, table_name: str):
        """迁移表数据"""
        sqlite_cursor = self.sqlite_conn.cursor()
        sqlite_cursor.execute(f"SELECT * FROM {table_name}")

        pg_cursor = self.pg_conn.cursor()
        columns = [desc[0] for desc in sqlite_cursor.description]

        batch_size = 1000
        while True:
            rows = sqlite_cursor.fetchmany(batch_size)
            if not rows:
                break

            # 数据转换
            converted_rows = [self._convert_row(row, columns) for row in rows]

            # 批量插入
            from psycopg2.extras import execute_values
            execute_values(
                pg_cursor,
                f"INSERT INTO {table_name} ({','.join(columns)}) VALUES %s",
                converted_rows
            )

        self.pg_conn.commit()

    def _convert_row(self, row: Tuple, columns: List[str]) -> Tuple:
        """转换行数据"""
        # 处理NULL、类型转换等
        converted = []
        for i, value in enumerate(row):
            if value is None:
                converted.append(None)
            elif isinstance(value, bytes):
                converted.append(psycopg2.Binary(value))
            else:
                converted.append(value)
        return tuple(converted)
```

### 5.4 成熟案例参考

#### 案例1：Django项目迁移

**场景**：Django应用从SQLite迁移到PostgreSQL

**方案**：

```python
# settings.py
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'mydb',
        'USER': 'user',
        'PASSWORD': 'password',
        'HOST': 'localhost',
        'PORT': '5432',
    }
}

# 迁移步骤
# 1. 使用Django的dumpdata和loaddata
python manage.py dumpdata > data.json
python manage.py loaddata data.json

# 2. 或使用pgloader
pgloader sqlite:///path/to/db.sqlite3 postgresql://user:password@localhost/mydb
```

#### 案例2：Rails项目迁移

**场景**：Rails应用从SQLite迁移到PostgreSQL

**方案**：

```ruby
# Gemfile
gem 'pg'

# database.yml
production:
  adapter: postgresql
  database: myapp_production
  username: user
  password: password
  host: localhost

# 迁移命令
rails db:migrate
```

#### 案例3：Node.js项目迁移

**场景**：Node.js应用从SQLite迁移到PostgreSQL

**方案**：

```javascript
// 使用node-sqlite3和pg
const sqlite3 = require('sqlite3');
const { Client } = require('pg');

// 迁移脚本
async function migrate() {
    const sqlite = new sqlite3.Database('source.db');
    const pg = new Client({
        host: 'localhost',
        database: 'target',
        user: 'user',
        password: 'password'
    });

    await pg.connect();

    // 迁移逻辑
    // ...
}
```

---

## 六、迁移执行流程

### 6.1 迁移前准备

#### 环境准备清单

- [ ] PostgreSQL服务器已安装和配置
- [ ] 数据库用户和权限已创建
- [ ] 网络连接测试通过
- [ ] 备份SQLite数据库
- [ ] 准备回滚方案

#### 数据备份

```bash
# SQLite备份
sqlite3 source.db ".backup backup.db"

# 或使用VACUUM INTO
sqlite3 source.db "VACUUM INTO 'backup.db'"
```

#### 环境测试

```python
# 测试PostgreSQL连接
import psycopg2

try:
    conn = psycopg2.connect(
        host='localhost',
        database='test',
        user='user',
        password='password'
    )
    print("PostgreSQL连接成功")
    conn.close()
except Exception as e:
    print(f"连接失败: {e}")
```

### 6.2 数据迁移步骤

#### 步骤1：迁移表结构

```python
# 1. 获取SQLite表结构
sqlite_cursor.execute("""
    SELECT sql FROM sqlite_master
    WHERE type='table' AND name NOT LIKE 'sqlite_%'
""")

# 2. 转换为PostgreSQL DDL
# 3. 执行PostgreSQL DDL
```

#### 步骤2：迁移数据

```python
# 1. 按表顺序迁移数据
# 2. 处理外键依赖
# 3. 批量插入优化
```

#### 步骤3：迁移索引

```python
# 1. 迁移普通索引
# 2. 迁移唯一索引
# 3. 迁移复合索引
```

#### 步骤4：迁移约束

```python
# 1. 迁移主键约束
# 2. 迁移外键约束
# 3. 迁移CHECK约束
```

### 6.3 应用代码迁移

#### ORM迁移

**SQLAlchemy示例**：

```python
# SQLite
from sqlalchemy import create_engine
engine = create_engine('sqlite:///database.db')

# PostgreSQL
from sqlalchemy import create_engine
engine = create_engine('postgresql://user:password@localhost/dbname')
```

**Django示例**：

```python
# settings.py
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        # ...
    }
}
```

#### 原生SQL迁移

```python
# SQLite特定语法需要修改
# 例如：日期函数、字符串函数等
```

### 6.4 迁移后验证

#### 数据完整性验证

```sql
-- 1. 记录数对比
SELECT
    'SQLite' as source,
    COUNT(*) as count
FROM sqlite_table
UNION ALL
SELECT
    'PostgreSQL' as source,
    COUNT(*) as count
FROM pg_table;

-- 2. 数据一致性验证
SELECT
    s.id,
    s.name as sqlite_name,
    p.name as pg_name,
    CASE WHEN s.name = p.name THEN 'OK' ELSE 'MISMATCH' END as status
FROM sqlite_table s
JOIN pg_table p ON s.id = p.id
WHERE s.name != p.name;
```

#### 性能验证

```sql
-- PostgreSQL性能测试
EXPLAIN ANALYZE
SELECT * FROM users WHERE email = 'test@example.com';
```

---

## 七、性能优化调整

### 7.1 查询优化差异

#### 查询计划器

**SQLite**：简单查询优化器

- 基于规则的优化
- 有限的统计信息

**PostgreSQL**：高级查询优化器

- 基于成本的优化
- 详细的统计信息
- 并行查询支持

#### 优化建议

```sql
-- PostgreSQL: 更新统计信息
ANALYZE;

-- PostgreSQL: 查看查询计划
EXPLAIN ANALYZE SELECT * FROM users WHERE email = 'test@example.com';

-- PostgreSQL: 并行查询
SET max_parallel_workers_per_gather = 4;
```

### 7.2 索引策略调整

#### 索引类型选择

```sql
-- PostgreSQL: B-Tree索引（默认）
CREATE INDEX idx_users_email ON users(email);

-- PostgreSQL: Hash索引（等值查询）
CREATE INDEX idx_users_email_hash ON users USING HASH(email);

-- PostgreSQL: GIN索引（全文搜索）
CREATE INDEX idx_articles_content_gin ON articles
    USING GIN(to_tsvector('english', content));

-- PostgreSQL: GiST索引（空间数据）
CREATE INDEX idx_locations_location_gist ON locations
    USING GIST(location);
```

### 7.3 连接池配置

#### PostgreSQL连接池配置

```python
# 使用psycopg2.pool
from psycopg2 import pool

connection_pool = pool.ThreadedConnectionPool(
    minconn=1,
    maxconn=20,
    host='localhost',
    database='mydb',
    user='user',
    password='password'
)

# 使用连接
conn = connection_pool.getconn()
try:
    # 使用连接
    pass
finally:
    connection_pool.putconn(conn)
```

#### PgBouncer配置

```ini
[databases]
mydb = host=localhost port=5432 dbname=mydb

[pgbouncer]
pool_mode = transaction
max_client_conn = 1000
default_pool_size = 25
```

### 7.4 缓存策略调整

#### PostgreSQL缓存配置

```sql
-- postgresql.conf
shared_buffers = 256MB          # 共享内存缓存
effective_cache_size = 1GB      # 查询规划器假设的缓存大小
work_mem = 16MB                 # 每个查询操作的内存
maintenance_work_mem = 128MB    # 维护操作的内存
```

---

## 八、常见问题和解决方案

### 8.1 数据类型问题

#### 问题1：INTEGER溢出

**问题**：SQLite INTEGER可能存储大值，PostgreSQL INTEGER可能溢出

**解决方案**：

```sql
-- 检查数据范围
SELECT MIN(id), MAX(id) FROM users;

-- 使用BIGINT
ALTER TABLE users ALTER COLUMN id TYPE BIGINT;
```

#### 问题2：日期时间格式

**问题**：SQLite存储为INTEGER或TEXT，PostgreSQL需要TIMESTAMP

**解决方案**：

```sql
-- 转换日期时间
ALTER TABLE logs
    ALTER COLUMN created_at TYPE TIMESTAMP
    USING to_timestamp(created_at);
```

### 8.2 并发问题

#### 问题1：锁等待

**问题**：PostgreSQL并发控制更严格

**解决方案**：

```sql
-- 设置锁超时
SET lock_timeout = '5s';

-- 使用适当的隔离级别
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

### 8.3 性能问题

#### 问题1：查询变慢

**问题**：迁移后查询性能下降

**解决方案**：

```sql
-- 更新统计信息
ANALYZE;

-- 重建索引
REINDEX DATABASE mydb;

-- 优化查询
EXPLAIN ANALYZE SELECT ...;
```

### 8.4 兼容性问题

#### 问题1：函数不兼容

**问题**：某些SQLite函数在PostgreSQL中不存在

**解决方案**：

```sql
-- 创建兼容函数
CREATE OR REPLACE FUNCTION sqlite_julianday(timestamp)
RETURNS numeric AS $$
    SELECT EXTRACT(EPOCH FROM $1) / 86400.0 + 2440587.5;
$$ LANGUAGE SQL;
```

---

## 九、成熟案例研究

### 9.1 案例一：Web应用迁移

#### 背景

- **应用类型**：Django Web应用
- **数据量**：50GB
- **用户数**：10万+
- **迁移原因**：需要支持高并发写入

#### 迁移方案

1. **准备阶段**（1周）
   - PostgreSQL环境搭建
   - 数据备份
   - 迁移脚本开发

2. **迁移阶段**（3天）
   - 使用pgloader迁移数据
   - 应用代码调整
   - 功能测试

3. **验证阶段**（1周）
   - 数据完整性验证
   - 性能测试
   - 用户验收测试

#### 迁移结果

- **数据完整性**：100%
- **性能提升**：写入性能提升5倍
- **并发能力**：从单写提升到多写
- **停机时间**：4小时

### 9.2 案例二：数据分析平台迁移

#### 背景

- **应用类型**：数据分析平台
- **数据量**：200GB
- **查询复杂度**：复杂聚合查询
- **迁移原因**：需要高级查询功能

#### 迁移方案

1. **分阶段迁移**
   - 第一阶段：历史数据迁移
   - 第二阶段：实时数据迁移
   - 第三阶段：应用切换

2. **优化策略**
   - 表分区
   - 索引优化
   - 查询重写

#### 迁移结果

- **查询性能**：提升3-10倍
- **功能增强**：支持窗口函数、CTE等
- **可扩展性**：支持更大数据量

### 9.3 案例三：移动应用后端迁移

#### 背景

- **应用类型**：移动应用后端
- **数据量**：20GB
- **并发要求**：高并发读取
- **迁移原因**：需要多服务器部署

#### 迁移方案

1. **蓝绿部署**
   - 蓝色环境：SQLite
   - 绿色环境：PostgreSQL
   - 逐步切换流量

2. **数据同步**
   - 实时数据同步
   - 双写策略
   - 最终一致性

#### 迁移结果

- **可用性**：99.9%
- **扩展性**：支持水平扩展
- **性能**：读取性能提升2倍

---

## 📊 SQLite vs PostgreSQL 多维对比矩阵

### 迁移决策多维对比矩阵

| 维度 | SQLite | PostgreSQL | 迁移影响 |
|------|--------|-----------|---------|
| **并发性能** | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 显著提升 |
| **数据量支持** | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 显著提升 |
| **网络访问** | ❌ | ✅ | 需要架构调整 |
| **高可用性** | ⭐⭐ | ⭐⭐⭐⭐⭐ | 显著提升 |
| **复杂查询** | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 显著提升 |
| **存储空间** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | 略有增加 |
| **部署复杂度** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | 复杂度增加 |
| **运维成本** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | 成本增加 |

### 迁移工具对比矩阵

| 维度 | pgloader | RebaseData | DBConvert | 自定义脚本 |
|------|----------|-----------|-----------|-----------|
| **易用性** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ |
| **性能** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **成本** | 免费 | 付费 | 付费 | 免费 |
| **功能完整性** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ |
| **支持度** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ |
| **适用场景** | 大规模迁移（推荐） | 快速迁移 | 商业项目 | 定制需求 |

### 数据类型映射对比矩阵

| SQLite类型 | PostgreSQL类型 | 兼容性 | 注意事项 |
|-----------|---------------|--------|---------|
| INTEGER | INTEGER/BIGINT | ⭐⭐⭐⭐⭐ | 自动映射 |
| TEXT | TEXT/VARCHAR | ⭐⭐⭐⭐⭐ | 自动映射 |
| REAL | REAL/DOUBLE PRECISION | ⭐⭐⭐⭐ | 精度差异 |
| BLOB | BYTEA | ⭐⭐⭐⭐ | 编码注意 |
| NUMERIC | NUMERIC/DECIMAL | ⭐⭐⭐⭐ | 精度设置 |
| DATE | DATE/TIMESTAMP | ⭐⭐⭐ | 格式转换 |
| DATETIME | TIMESTAMP | ⭐⭐⭐ | 时区处理 |

### 迁移策略对比矩阵

| 维度 | 全量迁移 | 增量迁移 | 双写迁移 | 灰度迁移 |
|------|---------|---------|---------|---------|
| **停机时间** | 长 | 短 | 无 | 短 |
| **实施复杂度** | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| **数据一致性** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ |
| **风险控制** | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **适用场景** | 小数据量 | 大数据量 | 高可用要求 | 生产环境 |

## 📊 迁移检查清单

### 迁移前

- [ ] 业务需求分析完成
- [ ] 迁移成本评估完成
- [ ] PostgreSQL环境准备完成
- [ ] 数据备份完成
- [ ] 迁移脚本测试通过
- [ ] 回滚方案准备完成

### 迁移中

- [ ] 表结构迁移完成
- [ ] 数据迁移完成
- [ ] 索引迁移完成
- [ ] 约束迁移完成
- [ ] 应用代码迁移完成
- [ ] 功能测试通过

### 迁移后

- [ ] 数据完整性验证通过
- [ ] 性能测试通过
- [ ] 用户验收测试通过
- [ ] 监控告警配置完成
- [ ] 文档更新完成
- [ ] 团队培训完成

---

## 🔗 相关资源

- [05.01 多维知识矩阵](../05-对比选型/05.01-多维知识矩阵.md) - SQLite vs PostgreSQL对比
- [02.01 数据类型系统](../02-数据模型/02.01-数据类型系统.md) - SQLite数据类型详解
- [08.01 连接管理](../08-编程实践/08.01-连接管理.md) - 连接管理最佳实践
- [07.01 SQL标准对齐](../07-标准对齐/07.01-SQL标准对齐.md) - SQL标准支持情况、函数对比表、迁移建议

---

## 🔗 交叉引用

### 理论模型 🆕

- ⭐⭐ [数据模型理论](../11-理论模型/11.02-数据模型理论.md) - 数据模型转换理论、类型系统理论
- ⭐ [系统理论模型](../11-理论模型/11.01-系统理论模型.md) - 系统迁移理论

### 设计模型 🆕

- ⭐⭐⭐ [设计决策](../12-设计模型/12.04-设计决策.md) - 迁移决策、架构转换决策
- ⭐⭐ [系统演进](../12-设计模型/12.05-系统演进.md) - 系统迁移演进

---

## 📚 参考资料

### 官方文档

- [PostgreSQL官方文档](https://www.postgresql.org/docs/)
- [pgloader文档](https://pgloader.readthedocs.io/)
- [SQLite官方文档](https://www.sqlite.org/docs.html)

### 迁移工具

- [pgloader](https://github.com/dimitri/pgloader) - PostgreSQL官方推荐
- [RebaseData](https://www.rebasedata.com/) - 在线迁移工具
- [DBConvert](https://dbconvert.com/) - 商业迁移工具

### 成熟案例

- [Django迁移指南](https://docs.djangoproject.com/en/stable/ref/databases/#postgresql-notes)
- [Rails迁移指南](https://guides.rubyonrails.org/configuring.html#configuring-a-postgresql-database)
- [Node.js迁移指南](https://node-postgres.com/)

---

**维护者**：Data-Science Team
**最后更新**：2025-01-15
