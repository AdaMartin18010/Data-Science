# ç”Ÿäº§çŽ¯å¢ƒæ•°æ®åº“è¿ç§»å®žæˆ˜

> **åˆ›å»ºæ—¥æœŸ**ï¼š2025-12-04
> **åœºæ™¯**ï¼šMySQL â†’ PostgreSQL, SQLite â†’ PostgreSQL
> **éš¾åº¦**ï¼šâ­â­â­â­â­

---

## ðŸ“‘ ç›®å½•

- [ç”Ÿäº§çŽ¯å¢ƒæ•°æ®åº“è¿ç§»å®žæˆ˜](#ç”Ÿäº§çŽ¯å¢ƒæ•°æ®åº“è¿ç§»å®žæˆ˜)
  - [ðŸ“‘ ç›®å½•](#-ç›®å½•)
  - [MySQL â†’ PostgreSQLå®Œæ•´è¿ç§»](#mysql--postgresqlå®Œæ•´è¿ç§»)
    - [é˜¶æ®µ1ï¼šè¯„ä¼°ä¸Žè§„åˆ’](#é˜¶æ®µ1è¯„ä¼°ä¸Žè§„åˆ’)
    - [é˜¶æ®µ2ï¼šSchemaè½¬æ¢](#é˜¶æ®µ2schemaè½¬æ¢)
    - [é˜¶æ®µ3ï¼šæ•°æ®è¿ç§»](#é˜¶æ®µ3æ•°æ®è¿ç§»)
    - [é˜¶æ®µ4ï¼šéªŒè¯ä¸Žåˆ‡æ¢](#é˜¶æ®µ4éªŒè¯ä¸Žåˆ‡æ¢)
  - [SQLite â†’ PostgreSQLè¿ç§»](#sqlite--postgresqlè¿ç§»)
    - [ç®€å•è¿ç§»](#ç®€å•è¿ç§»)
    - [å¤æ‚åœºæ™¯ï¼ˆå¸¦åº”ç”¨æ”¹é€ ï¼‰](#å¤æ‚åœºæ™¯å¸¦åº”ç”¨æ”¹é€ )

## MySQL â†’ PostgreSQLå®Œæ•´è¿ç§»

### é˜¶æ®µ1ï¼šè¯„ä¼°ä¸Žè§„åˆ’

```sql
-- MySQLå…ƒæ•°æ®æ”¶é›†

SELECT
    TABLE_SCHEMA,
    TABLE_NAME,
    TABLE_ROWS,
    DATA_LENGTH / 1024 / 1024 AS data_mb,
    INDEX_LENGTH / 1024 / 1024 AS index_mb
FROM information_schema.TABLES
WHERE TABLE_SCHEMA = 'mydb'
ORDER BY DATA_LENGTH DESC;

-- è¯„ä¼°è¿ç§»å¤æ‚åº¦
SELECT
    COUNT(*) AS table_count,
    SUM(TABLE_ROWS) AS total_rows,
    SUM(DATA_LENGTH) / 1024 / 1024 / 1024 AS total_gb
FROM information_schema.TABLES
WHERE TABLE_SCHEMA = 'mydb';
```

### é˜¶æ®µ2ï¼šSchemaè½¬æ¢

```sql
-- MySQLç‰¹æ€§ â†’ PostgreSQLæ˜ å°„

-- 1. AUTO_INCREMENT â†’ SERIAL
-- MySQL:
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50)
);

-- PostgreSQL:
CREATE TABLE users (
    id SERIAL PRIMARY KEY,  -- æˆ–BIGSERIAL
    name VARCHAR(50)
);

-- 2. æ—¶é—´ç±»åž‹è½¬æ¢
-- MySQL DATETIME â†’ PostgreSQL TIMESTAMP
-- MySQL TIMESTAMP â†’ PostgreSQL TIMESTAMPTZ

-- 3. å­—ç¬¦ä¸²ç±»åž‹
-- MySQL: VARCHAR(255) CHARACTER SET utf8mb4
-- PostgreSQL: VARCHAR(255) ï¼ˆé»˜è®¤UTF-8ï¼‰

-- 4. æ— ç¬¦å·æ•´æ•°
-- MySQL: INT UNSIGNED
-- PostgreSQL: BIGINTï¼ˆæˆ–æ·»åŠ CHECKçº¦æŸï¼‰
CREATE TABLE t (
    id BIGINT CHECK (id >= 0)
);

-- 5. ENUMç±»åž‹
-- MySQL ENUM â†’ PostgreSQLè‡ªå®šä¹‰ç±»åž‹
CREATE TYPE user_status AS ENUM ('active', 'inactive', 'banned');
CREATE TABLE users (
    status user_status
);
```

### é˜¶æ®µ3ï¼šæ•°æ®è¿ç§»

```bash
#!/bin/bash
# MySQL â†’ PostgreSQLæ•°æ®è¿ç§»è„šæœ¬

SOURCE_HOST="mysql-host"
SOURCE_DB="mydb"
SOURCE_USER="root"

TARGET_HOST="pg-host"
TARGET_DB="mydb"
TARGET_USER="postgres"

# æ–¹æ³•1ï¼šä½¿ç”¨pgloaderï¼ˆæŽ¨èï¼‰
pgloader mysql://$SOURCE_USER@$SOURCE_HOST/$SOURCE_DB \
          postgresql://$TARGET_USER@$TARGET_HOST/$TARGET_DB

# æ–¹æ³•2ï¼šCSVä¸­é—´æ ¼å¼
# å¯¼å‡ºMySQL
mysql -h $SOURCE_HOST -u $SOURCE_USER -e \
    "SELECT * FROM users INTO OUTFILE '/tmp/users.csv'
     FIELDS TERMINATED BY ',' ENCLOSED BY '\"'
     LINES TERMINATED BY '\n';"

# å¯¼å…¥PostgreSQL
psql -h $TARGET_HOST -U $TARGET_USER -d $TARGET_DB -c \
    "COPY users FROM '/tmp/users.csv' CSV"

# æ–¹æ³•3ï¼šè‡ªå®šä¹‰Pythonè„šæœ¬ï¼ˆæ›´çµæ´»ï¼‰
python3 migrate.py
```

**Pythonè¿ç§»è„šæœ¬**ï¼š

```python
import pymysql
import psycopg2
from tqdm import tqdm

def migrate_table(mysql_conn, pg_conn, table_name, batch_size=10000):
    """è¿ç§»å•ä¸ªè¡¨"""
    print(f"è¿ç§»è¡¨: {table_name}")

    # 1. èŽ·å–MySQLæ•°æ®
    mysql_cursor = mysql_conn.cursor(pymysql.cursors.SSCursor)  # æœåŠ¡ç«¯æ¸¸æ ‡
    mysql_cursor.execute(f"SELECT * FROM {table_name}")

    # 2. èŽ·å–åˆ—å
    columns = [desc[0] for desc in mysql_cursor.description]
    placeholders = ','.join(['%s'] * len(columns))

    # 3. æ‰¹é‡æ’å…¥PostgreSQL
    pg_cursor = pg_conn.cursor()
    batch = []
    total = 0

    for row in tqdm(mysql_cursor, desc=table_name):
        # æ•°æ®è½¬æ¢
        row = convert_row(row, columns)
        batch.append(row)

        if len(batch) >= batch_size:
            pg_cursor.executemany(
                f"INSERT INTO {table_name} VALUES ({placeholders})",
                batch
            )
            pg_conn.commit()
            total += len(batch)
            batch = []

    # æœ€åŽä¸€æ‰¹
    if batch:
        pg_cursor.executemany(
            f"INSERT INTO {table_name} VALUES ({placeholders})",
            batch
        )
        pg_conn.commit()
        total += len(batch)

    print(f"å®Œæˆ: {total}è¡Œ")

def convert_row(row, columns):
    """æ•°æ®ç±»åž‹è½¬æ¢"""
    converted = []
    for value, col in zip(row, columns):
        if value is None:
            converted.append(None)
        elif isinstance(value, bytes):
            # MySQL BLOB â†’ PostgreSQL BYTEA
            converted.append(value)
        elif col.endswith('_at'):
            # MySQL DATETIME â†’ PostgreSQL TIMESTAMP
            # å·²ç»æ˜¯datetimeå¯¹è±¡ï¼Œæ— éœ€è½¬æ¢
            converted.append(value)
        else:
            converted.append(value)
    return tuple(converted)

# æ‰§è¡Œè¿ç§»
mysql_conn = pymysql.connect(host='mysql-host', user='root', database='mydb')
pg_conn = psycopg2.connect("postgresql://postgres@pg-host/mydb")

tables = ['users', 'orders', 'products']
for table in tables:
    migrate_table(mysql_conn, pg_conn, table)

mysql_conn.close()
pg_conn.close()
```

### é˜¶æ®µ4ï¼šéªŒè¯ä¸Žåˆ‡æ¢

```sql
-- æ•°æ®ä¸€è‡´æ€§éªŒè¯

-- å¯¹æ¯”è¡Œæ•°
-- MySQL:
SELECT COUNT(*) FROM users;
-- PostgreSQL:
SELECT COUNT(*) FROM users;

-- å¯¹æ¯”å…³é”®ç»Ÿè®¡
-- MySQL:
SELECT
    MIN(created_at), MAX(created_at),
    MIN(id), MAX(id),
    SUM(order_total)
FROM orders;

-- PostgreSQL: æ‰§è¡Œç›¸åŒæŸ¥è¯¢å¹¶å¯¹æ¯”

-- å¯¹æ¯”æ•°æ®é‡‡æ ·
-- MySQL:
SELECT * FROM users ORDER BY RAND() LIMIT 100;
-- PostgreSQL:
SELECT * FROM users ORDER BY RANDOM() LIMIT 100;

-- åº”ç”¨åŒå†™æµ‹è¯•ï¼ˆç°åº¦ï¼‰
-- 1. åº”ç”¨åŒæ—¶å†™MySQLå’ŒPostgreSQL
-- 2. è¯»ä»ŽMySQL
-- 3. å®šæœŸå¯¹æ¯”æ•°æ®ä¸€è‡´æ€§
-- 4. é€æ­¥åˆ‡æ¢è¯»æµé‡åˆ°PostgreSQL
-- 5. åœæ­¢MySQLå†™å…¥
```

---

## SQLite â†’ PostgreSQLè¿ç§»

### ç®€å•è¿ç§»

```bash
# æ–¹æ³•1ï¼šSQL dump
sqlite3 app.db .dump > dump.sql

# ç¼–è¾‘dump.sqlï¼ˆä¿®æ”¹è¯­æ³•å·®å¼‚ï¼‰
sed -i 's/AUTOINCREMENT/SERIAL/g' dump.sql
sed -i 's/INTEGER PRIMARY KEY/BIGSERIAL PRIMARY KEY/g' dump.sql

# å¯¼å…¥PostgreSQL
psql -U postgres -d newdb < dump.sql

# æ–¹æ³•2ï¼šä½¿ç”¨pgloader
pgloader sqlite://app.db postgresql://localhost/newdb
```

### å¤æ‚åœºæ™¯ï¼ˆå¸¦åº”ç”¨æ”¹é€ ï¼‰

```python
# åº”ç”¨å±‚è¿ç§»é€‚é…

class DatabaseAdapter:
    """æ•°æ®åº“é€‚é…å™¨ï¼ˆæ”¯æŒSQLiteå’ŒPostgreSQLï¼‰"""

    def __init__(self, db_type, connection_string):
        self.db_type = db_type
        if db_type == 'sqlite':
            self.conn = sqlite3.connect(connection_string)
        elif db_type == 'postgresql':
            self.conn = psycopg2.connect(connection_string)
        else:
            raise ValueError(f"ä¸æ”¯æŒçš„æ•°æ®åº“ç±»åž‹: {db_type}")

    def execute(self, sql, params=None):
        """æ‰§è¡ŒSQLï¼ˆè‡ªåŠ¨é€‚é…å‚æ•°å ä½ç¬¦ï¼‰"""
        if self.db_type == 'postgresql':
            # SQLite ? â†’ PostgreSQL %s
            sql = sql.replace('?', '%s')

        cursor = self.conn.execute(sql, params or ())
        return cursor

    def insert_returning(self, table, data):
        """æ’å…¥å¹¶è¿”å›žIDï¼ˆè‡ªåŠ¨é€‚é…ï¼‰"""
        columns = ', '.join(data.keys())

        if self.db_type == 'sqlite':
            placeholders = ', '.join(['?'] * len(data))
            sql = f"INSERT INTO {table} ({columns}) VALUES ({placeholders})"
            cursor = self.conn.execute(sql, tuple(data.values()))
            return cursor.lastrowid
        else:  # PostgreSQL
            placeholders = ', '.join(['%s'] * len(data))
            sql = f"INSERT INTO {table} ({columns}) VALUES ({placeholders}) RETURNING id"
            cursor = self.conn.execute(sql, tuple(data.values()))
            return cursor.fetchone()[0]

    def upsert(self, table, data, conflict_columns):
        """UPSERTæ“ä½œï¼ˆè‡ªåŠ¨é€‚é…ï¼‰"""
        columns = ', '.join(data.keys())
        values = tuple(data.values())

        if self.db_type == 'sqlite':
            placeholders = ', '.join(['?'] * len(data))
            conflict_cols = ', '.join(conflict_columns)
            set_clause = ', '.join([f"{k} = excluded.{k}" for k in data.keys() if k not in conflict_columns])
            sql = f"""
                INSERT INTO {table} ({columns}) VALUES ({placeholders})
                ON CONFLICT ({conflict_cols}) DO UPDATE SET {set_clause}
            """
            self.conn.execute(sql, values)
        else:  # PostgreSQL
            placeholders = ', '.join(['%s'] * len(data))
            conflict_cols = ', '.join(conflict_columns)
            set_clause = ', '.join([f"{k} = EXCLUDED.{k}" for k in data.keys() if k not in conflict_columns])
            sql = f"""
                INSERT INTO {table} ({columns}) VALUES ({placeholders})
                ON CONFLICT ({conflict_cols}) DO UPDATE SET {set_clause}
            """
            self.conn.execute(sql, values)

        self.conn.commit()

# ä½¿ç”¨ï¼ˆè¿ç§»æœŸé—´æ— éœ€ä¿®æ”¹ä¸šåŠ¡ä»£ç ï¼‰
# db = DatabaseAdapter('sqlite', 'app.db')
db = DatabaseAdapter('postgresql', 'postgresql://localhost/mydb')

# ç»Ÿä¸€çš„API
user_id = db.insert_returning('users', {
    'name': 'Alice',
    'email': 'alice@example.com'
})
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0
**æœ€åŽæ›´æ–°**: 2025-12-04
