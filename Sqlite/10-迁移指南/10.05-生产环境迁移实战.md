# 生产环境数据库迁移实战

> **创建日期**：2025-12-04
> **场景**：MySQL → PostgreSQL, SQLite → PostgreSQL
> **难度**：⭐⭐⭐⭐⭐

---

## MySQL → PostgreSQL完整迁移

### 阶段1：评估与规划

```sql
-- MySQL元数据收集

SELECT
    TABLE_SCHEMA,
    TABLE_NAME,
    TABLE_ROWS,
    DATA_LENGTH / 1024 / 1024 AS data_mb,
    INDEX_LENGTH / 1024 / 1024 AS index_mb
FROM information_schema.TABLES
WHERE TABLE_SCHEMA = 'mydb'
ORDER BY DATA_LENGTH DESC;

-- 评估迁移复杂度
SELECT
    COUNT(*) AS table_count,
    SUM(TABLE_ROWS) AS total_rows,
    SUM(DATA_LENGTH) / 1024 / 1024 / 1024 AS total_gb
FROM information_schema.TABLES
WHERE TABLE_SCHEMA = 'mydb';
```

### 阶段2：Schema转换

```sql
-- MySQL特性 → PostgreSQL映射

-- 1. AUTO_INCREMENT → SERIAL
-- MySQL:
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50)
);

-- PostgreSQL:
CREATE TABLE users (
    id SERIAL PRIMARY KEY,  -- 或BIGSERIAL
    name VARCHAR(50)
);

-- 2. 时间类型转换
-- MySQL DATETIME → PostgreSQL TIMESTAMP
-- MySQL TIMESTAMP → PostgreSQL TIMESTAMPTZ

-- 3. 字符串类型
-- MySQL: VARCHAR(255) CHARACTER SET utf8mb4
-- PostgreSQL: VARCHAR(255) （默认UTF-8）

-- 4. 无符号整数
-- MySQL: INT UNSIGNED
-- PostgreSQL: BIGINT（或添加CHECK约束）
CREATE TABLE t (
    id BIGINT CHECK (id >= 0)
);

-- 5. ENUM类型
-- MySQL ENUM → PostgreSQL自定义类型
CREATE TYPE user_status AS ENUM ('active', 'inactive', 'banned');
CREATE TABLE users (
    status user_status
);
```

### 阶段3：数据迁移

```bash
#!/bin/bash
# MySQL → PostgreSQL数据迁移脚本

SOURCE_HOST="mysql-host"
SOURCE_DB="mydb"
SOURCE_USER="root"

TARGET_HOST="pg-host"
TARGET_DB="mydb"
TARGET_USER="postgres"

# 方法1：使用pgloader（推荐）
pgloader mysql://$SOURCE_USER@$SOURCE_HOST/$SOURCE_DB \
          postgresql://$TARGET_USER@$TARGET_HOST/$TARGET_DB

# 方法2：CSV中间格式
# 导出MySQL
mysql -h $SOURCE_HOST -u $SOURCE_USER -e \
    "SELECT * FROM users INTO OUTFILE '/tmp/users.csv'
     FIELDS TERMINATED BY ',' ENCLOSED BY '\"'
     LINES TERMINATED BY '\n';"

# 导入PostgreSQL
psql -h $TARGET_HOST -U $TARGET_USER -d $TARGET_DB -c \
    "COPY users FROM '/tmp/users.csv' CSV"

# 方法3：自定义Python脚本（更灵活）
python3 migrate.py
```

**Python迁移脚本**：

```python
import pymysql
import psycopg2
from tqdm import tqdm

def migrate_table(mysql_conn, pg_conn, table_name, batch_size=10000):
    """迁移单个表"""
    print(f"迁移表: {table_name}")

    # 1. 获取MySQL数据
    mysql_cursor = mysql_conn.cursor(pymysql.cursors.SSCursor)  # 服务端游标
    mysql_cursor.execute(f"SELECT * FROM {table_name}")

    # 2. 获取列名
    columns = [desc[0] for desc in mysql_cursor.description]
    placeholders = ','.join(['%s'] * len(columns))

    # 3. 批量插入PostgreSQL
    pg_cursor = pg_conn.cursor()
    batch = []
    total = 0

    for row in tqdm(mysql_cursor, desc=table_name):
        # 数据转换
        row = convert_row(row, columns)
        batch.append(row)

        if len(batch) >= batch_size:
            pg_cursor.executemany(
                f"INSERT INTO {table_name} VALUES ({placeholders})",
                batch
            )
            pg_conn.commit()
            total += len(batch)
            batch = []

    # 最后一批
    if batch:
        pg_cursor.executemany(
            f"INSERT INTO {table_name} VALUES ({placeholders})",
            batch
        )
        pg_conn.commit()
        total += len(batch)

    print(f"完成: {total}行")

def convert_row(row, columns):
    """数据类型转换"""
    converted = []
    for value, col in zip(row, columns):
        if value is None:
            converted.append(None)
        elif isinstance(value, bytes):
            # MySQL BLOB → PostgreSQL BYTEA
            converted.append(value)
        elif col.endswith('_at'):
            # MySQL DATETIME → PostgreSQL TIMESTAMP
            # 已经是datetime对象，无需转换
            converted.append(value)
        else:
            converted.append(value)
    return tuple(converted)

# 执行迁移
mysql_conn = pymysql.connect(host='mysql-host', user='root', database='mydb')
pg_conn = psycopg2.connect("postgresql://postgres@pg-host/mydb")

tables = ['users', 'orders', 'products']
for table in tables:
    migrate_table(mysql_conn, pg_conn, table)

mysql_conn.close()
pg_conn.close()
```

### 阶段4：验证与切换

```sql
-- 数据一致性验证

-- 对比行数
-- MySQL:
SELECT COUNT(*) FROM users;
-- PostgreSQL:
SELECT COUNT(*) FROM users;

-- 对比关键统计
-- MySQL:
SELECT
    MIN(created_at), MAX(created_at),
    MIN(id), MAX(id),
    SUM(order_total)
FROM orders;

-- PostgreSQL: 执行相同查询并对比

-- 对比数据采样
-- MySQL:
SELECT * FROM users ORDER BY RAND() LIMIT 100;
-- PostgreSQL:
SELECT * FROM users ORDER BY RANDOM() LIMIT 100;

-- 应用双写测试（灰度）
-- 1. 应用同时写MySQL和PostgreSQL
-- 2. 读从MySQL
-- 3. 定期对比数据一致性
-- 4. 逐步切换读流量到PostgreSQL
-- 5. 停止MySQL写入
```

---

## SQLite → PostgreSQL迁移

### 简单迁移

```bash
# 方法1：SQL dump
sqlite3 app.db .dump > dump.sql

# 编辑dump.sql（修改语法差异）
sed -i 's/AUTOINCREMENT/SERIAL/g' dump.sql
sed -i 's/INTEGER PRIMARY KEY/BIGSERIAL PRIMARY KEY/g' dump.sql

# 导入PostgreSQL
psql -U postgres -d newdb < dump.sql

# 方法2：使用pgloader
pgloader sqlite://app.db postgresql://localhost/newdb
```

### 复杂场景（带应用改造）

```python
# 应用层迁移适配

class DatabaseAdapter:
    """数据库适配器（支持SQLite和PostgreSQL）"""

    def __init__(self, db_type, connection_string):
        self.db_type = db_type
        if db_type == 'sqlite':
            self.conn = sqlite3.connect(connection_string)
        elif db_type == 'postgresql':
            self.conn = psycopg2.connect(connection_string)
        else:
            raise ValueError(f"不支持的数据库类型: {db_type}")

    def execute(self, sql, params=None):
        """执行SQL（自动适配参数占位符）"""
        if self.db_type == 'postgresql':
            # SQLite ? → PostgreSQL %s
            sql = sql.replace('?', '%s')

        cursor = self.conn.execute(sql, params or ())
        return cursor

    def insert_returning(self, table, data):
        """插入并返回ID（自动适配）"""
        columns = ', '.join(data.keys())

        if self.db_type == 'sqlite':
            placeholders = ', '.join(['?'] * len(data))
            sql = f"INSERT INTO {table} ({columns}) VALUES ({placeholders})"
            cursor = self.conn.execute(sql, tuple(data.values()))
            return cursor.lastrowid
        else:  # PostgreSQL
            placeholders = ', '.join(['%s'] * len(data))
            sql = f"INSERT INTO {table} ({columns}) VALUES ({placeholders}) RETURNING id"
            cursor = self.conn.execute(sql, tuple(data.values()))
            return cursor.fetchone()[0]

    def upsert(self, table, data, conflict_columns):
        """UPSERT操作（自动适配）"""
        columns = ', '.join(data.keys())
        values = tuple(data.values())

        if self.db_type == 'sqlite':
            placeholders = ', '.join(['?'] * len(data))
            conflict_cols = ', '.join(conflict_columns)
            set_clause = ', '.join([f"{k} = excluded.{k}" for k in data.keys() if k not in conflict_columns])
            sql = f"""
                INSERT INTO {table} ({columns}) VALUES ({placeholders})
                ON CONFLICT ({conflict_cols}) DO UPDATE SET {set_clause}
            """
            self.conn.execute(sql, values)
        else:  # PostgreSQL
            placeholders = ', '.join(['%s'] * len(data))
            conflict_cols = ', '.join(conflict_columns)
            set_clause = ', '.join([f"{k} = EXCLUDED.{k}" for k in data.keys() if k not in conflict_columns])
            sql = f"""
                INSERT INTO {table} ({columns}) VALUES ({placeholders})
                ON CONFLICT ({conflict_cols}) DO UPDATE SET {set_clause}
            """
            self.conn.execute(sql, values)

        self.conn.commit()

# 使用（迁移期间无需修改业务代码）
# db = DatabaseAdapter('sqlite', 'app.db')
db = DatabaseAdapter('postgresql', 'postgresql://localhost/mydb')

# 统一的API
user_id = db.insert_returning('users', {
    'name': 'Alice',
    'email': 'alice@example.com'
})
```

---

**文档版本**: v1.0.0
**最后更新**: 2025-12-04
