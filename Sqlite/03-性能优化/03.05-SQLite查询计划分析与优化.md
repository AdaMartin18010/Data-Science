# SQLite查询计划分析与优化

> **创建日期**: 2025-12-04
> **版本**: SQLite 3.47.x
> **难度**: ⭐⭐⭐⭐⭐

---

## EXPLAIN QUERY PLAN详解

### 输出格式

```sql
-- 示例查询
EXPLAIN QUERY PLAN
SELECT * FROM orders o
JOIN users u ON o.user_id = u.id
WHERE o.created_at > '2025-01-01';

-- 输出格式：
-- id | parent | notused | detail
-- ---+--------+---------+-------------------------------------
--  2 |   0    |    0    | SCAN orders AS o
--  3 |   0    |    0    | SEARCH users AS u USING INTEGER PRIMARY KEY (rowid=?)

字段说明：
• id: 操作ID（树形结构）
• parent: 父操作ID
• notused: 保留字段
• detail: 操作描述
```

---

## 操作类型解析

### SCAN（表扫描）

```sql
-- ❌ 全表扫描（慢）
EXPLAIN QUERY PLAN
SELECT * FROM users WHERE email = 'alice@example.com';

-- 输出:
-- SCAN users

-- 原因：email列无索引

-- ✅ 创建索引后
CREATE INDEX idx_users_email ON users(email);

EXPLAIN QUERY PLAN
SELECT * FROM users WHERE email = 'alice@example.com';

-- 输出:
-- SEARCH users USING INDEX idx_users_email (email=?)
```

### SEARCH（索引查找）

```sql
-- 索引查找类型

-- 1. 主键查找（最快）
EXPLAIN QUERY PLAN
SELECT * FROM users WHERE id = 123;
-- SEARCH users USING INTEGER PRIMARY KEY (rowid=?)

-- 2. 索引等值查找
EXPLAIN QUERY PLAN
SELECT * FROM users WHERE email = 'alice@example.com';
-- SEARCH users USING INDEX idx_users_email (email=?)

-- 3. 索引范围查找
EXPLAIN QUERY PLAN
SELECT * FROM orders WHERE created_at > '2025-01-01';
-- SEARCH orders USING INDEX idx_orders_created (created_at>?)

-- 4. 覆盖索引（Index-Only Scan）
CREATE INDEX idx_users_email_name ON users(email, name);

EXPLAIN QUERY PLAN
SELECT email, name FROM users WHERE email = 'alice@example.com';
-- SEARCH users USING COVERING INDEX idx_users_email_name (email=?)
-- (注：COVERING表示无需回表)
```

### USE TEMP B-TREE（临时排序）

```sql
-- ❌ 需要临时排序
EXPLAIN QUERY PLAN
SELECT * FROM users ORDER BY created_at DESC;

-- 输出:
-- SCAN users
-- USE TEMP B-TREE FOR ORDER BY

-- ✅ 创建索引后
CREATE INDEX idx_users_created ON users(created_at DESC);

EXPLAIN QUERY PLAN
SELECT * FROM users ORDER BY created_at DESC;

-- 输出:
-- SCAN users USING INDEX idx_users_created
-- (无USE TEMP B-TREE，直接从索引返回有序结果)
```

---

## JOIN优化

### NESTED LOOP JOIN

```sql
-- 表结构
CREATE TABLE orders (
    id INTEGER PRIMARY KEY,
    user_id INTEGER,
    total DECIMAL(10, 2)
);

CREATE TABLE users (
    id INTEGER PRIMARY KEY,
    name TEXT
);

-- ❌ 无索引JOIN（慢）
EXPLAIN QUERY PLAN
SELECT * FROM orders o
JOIN users u ON o.user_id = u.id;

-- 输出:
--  2 | 0 | 0 | SCAN orders AS o
--  3 | 0 | 0 | SEARCH users AS u USING INTEGER PRIMARY KEY (rowid=?)

-- 分析：
-- • 外层：SCAN orders（全表扫描）
-- • 内层：SEARCH users（主键查找）
-- • 复杂度：O(N * log M)，N=orders行数，M=users行数

-- ✅ 添加外键索引
CREATE INDEX idx_orders_user_id ON orders(user_id);

EXPLAIN QUERY PLAN
SELECT * FROM orders o
JOIN users u ON o.user_id = u.id;

-- 输出:
--  2 | 0 | 0 | SCAN orders AS o USING INDEX idx_orders_user_id
--  3 | 0 | 0 | SEARCH users AS u USING INTEGER PRIMARY KEY (rowid=?)

-- 改进：即使是SCAN，也使用索引顺序，IO效率更高
```

### JOIN顺序

```sql
-- SQLite的JOIN顺序启发式规则：
-- 1. 小表在外层
-- 2. 带索引的表在内层
-- 3. WHERE条件过滤的表在外层

-- 示例：强制JOIN顺序
EXPLAIN QUERY PLAN
SELECT * FROM
    users u
    CROSS JOIN orders o  -- CROSS JOIN强制顺序
WHERE u.id = o.user_id;
```

---

## 子查询优化

### 子查询扁平化

```sql
-- ❌ 相关子查询（慢）
EXPLAIN QUERY PLAN
SELECT * FROM users u
WHERE EXISTS (
    SELECT 1 FROM orders o
    WHERE o.user_id = u.id
);

-- 输出:
--  2 | 0 | 0 | SCAN users AS u
--  5 | 0 | 0 | SEARCH orders AS o USING INDEX idx_orders_user_id (user_id=?)

-- 分析：每行users都要执行子查询（N次）

-- ✅ 使用JOIN代替
EXPLAIN QUERY PLAN
SELECT DISTINCT u.* FROM users u
JOIN orders o ON o.user_id = u.id;

-- 输出:
--  2 | 0 | 0 | SCAN users AS u
--  3 | 0 | 0 | SEARCH orders AS o USING INDEX idx_orders_user_id (user_id=?)
--  6 | 0 | 0 | USE TEMP B-TREE FOR DISTINCT

-- 改进：单次扫描
```

### IN子查询

```sql
-- SQLite会自动优化IN子查询

EXPLAIN QUERY PLAN
SELECT * FROM orders
WHERE user_id IN (SELECT id FROM users WHERE name LIKE 'A%');

-- 输出:
--  3 | 0 | 0 | SCAN users
--  5 | 0 | 0 | SEARCH orders USING INDEX idx_orders_user_id (user_id=?)

-- SQLite自动将IN转换为JOIN
```

---

## 索引设计策略

### 复合索引列顺序

```sql
-- 查询：WHERE user_id = ? AND status = ? ORDER BY created_at

-- ❌ 错误顺序
CREATE INDEX idx_bad ON orders(status, user_id, created_at);

EXPLAIN QUERY PLAN
SELECT * FROM orders
WHERE user_id = 123 AND status = 'paid'
ORDER BY created_at;
-- 输出：USE TEMP B-TREE FOR ORDER BY（需要排序）

-- ✅ 正确顺序：等值过滤 > 范围过滤/排序
CREATE INDEX idx_good ON orders(user_id, status, created_at);

EXPLAIN QUERY PLAN
SELECT * FROM orders
WHERE user_id = 123 AND status = 'paid'
ORDER BY created_at;
-- 输出：SEARCH orders USING INDEX idx_good（无需排序）

-- 规则：
-- 1. 等值条件列在前
-- 2. 范围条件或ORDER BY列在后
-- 3. 高选择性列在前
```

### 部分索引

```sql
-- 场景：只查询未完成的订单

-- ❌ 普通索引（包含所有行）
CREATE INDEX idx_orders_status ON orders(status);
-- 索引大小：所有行

-- ✅ 部分索引（只包含特定行）
CREATE INDEX idx_orders_pending ON orders(status)
WHERE status IN ('pending', 'paid');
-- 索引大小：只有pending和paid的行

EXPLAIN QUERY PLAN
SELECT * FROM orders WHERE status = 'pending';
-- 输出：SEARCH orders USING INDEX idx_orders_pending
```

### 表达式索引

```sql
-- 场景：经常查询小写email

-- ❌ 无法使用索引
CREATE INDEX idx_users_email ON users(email);

SELECT * FROM users WHERE LOWER(email) = 'alice@example.com';
-- SCAN users（函数包裹导致索引失效）

-- ✅ 表达式索引
CREATE INDEX idx_users_email_lower ON users(LOWER(email));

EXPLAIN QUERY PLAN
SELECT * FROM users WHERE LOWER(email) = 'alice@example.com';
-- SEARCH users USING INDEX idx_users_email_lower
```

---

## 实战案例分析

### 案例1：复杂查询优化

```sql
-- 需求：查询最近30天活跃用户的订单统计

-- ❌ 原始查询（慢：5.2秒）
EXPLAIN QUERY PLAN
SELECT
    u.id,
    u.name,
    COUNT(o.id) as order_count,
    SUM(o.total) as total_amount
FROM users u
LEFT JOIN orders o ON o.user_id = u.id
WHERE o.created_at > datetime('now', '-30 days')
GROUP BY u.id
ORDER BY total_amount DESC;

-- 输出:
--  SCAN users AS u
--  SEARCH orders AS o USING INDEX idx_orders_user_id
--  USE TEMP B-TREE FOR GROUP BY
--  USE TEMP B-TREE FOR ORDER BY

-- 问题分析：
-- 1. 全表扫描users（100万行）
-- 2. 每个user JOIN orders
-- 3. 临时排序和分组

-- ✅ 优化1：先过滤orders
EXPLAIN QUERY PLAN
WITH recent_orders AS (
    SELECT user_id, id, total
    FROM orders
    WHERE created_at > datetime('now', '-30 days')
)
SELECT
    u.id,
    u.name,
    COUNT(o.id) as order_count,
    SUM(o.total) as total_amount
FROM users u
JOIN recent_orders o ON o.user_id = u.id
GROUP BY u.id
ORDER BY total_amount DESC;

-- 改进：只JOIN活跃用户（假设10万行）

-- ✅ 优化2：物化视图（定期刷新）
CREATE TABLE IF NOT EXISTS user_order_stats (
    user_id INTEGER PRIMARY KEY,
    order_count INTEGER,
    total_amount DECIMAL(10, 2),
    last_updated TIMESTAMP
);

-- 增量更新脚本（每小时运行）
INSERT OR REPLACE INTO user_order_stats
SELECT
    user_id,
    COUNT(*) as order_count,
    SUM(total) as total_amount,
    CURRENT_TIMESTAMP
FROM orders
WHERE created_at > datetime('now', '-30 days')
GROUP BY user_id;

-- 查询物化视图（快：0.01秒）
SELECT * FROM user_order_stats
ORDER BY total_amount DESC;

-- 性能提升：5.2秒 → 0.01秒（520倍）
```

### 案例2：分页查询优化

```sql
-- 需求：分页查询订单

-- ❌ OFFSET分页（慢）
EXPLAIN QUERY PLAN
SELECT * FROM orders
ORDER BY created_at DESC
LIMIT 100 OFFSET 100000;

-- 输出:
--  SCAN orders USING INDEX idx_orders_created

-- 问题：需要跳过前100000行（IO密集）

-- ✅ Keyset分页（快）
-- 首页
SELECT * FROM orders
ORDER BY created_at DESC, id DESC
LIMIT 100;

-- 下一页（使用上页最后一条记录）
SELECT * FROM orders
WHERE (created_at, id) < ('2025-12-03 10:00:00', 12345)
ORDER BY created_at DESC, id DESC
LIMIT 100;

EXPLAIN QUERY PLAN ...
-- 输出：SEARCH orders USING INDEX（精确定位）

-- 性能对比：
-- OFFSET 100000: 2.5秒
-- Keyset分页: 0.02秒（125倍提升）
```

---

## 性能监控工具

### Python脚本

```python
import sqlite3
import time

class QueryAnalyzer:
    def __init__(self, db_path):
        self.conn = sqlite3.connect(db_path)

    def analyze(self, sql, params=()):
        """分析查询性能"""
        # 1. 查询计划
        plan = self.conn.execute(f"EXPLAIN QUERY PLAN {sql}", params).fetchall()
        print("=== Query Plan ===")
        for row in plan:
            print(f"  {row}")

        # 2. 执行时间
        start = time.time()
        cursor = self.conn.execute(sql, params)
        results = cursor.fetchall()
        elapsed = (time.time() - start) * 1000

        print(f"\n=== Performance ===")
        print(f"  Rows: {len(results)}")
        print(f"  Time: {elapsed:.2f}ms")

        # 3. 索引建议
        self._suggest_indexes(sql)

        return results

    def _suggest_indexes(self, sql):
        """索引建议"""
        print(f"\n=== Index Suggestions ===")

        # 检测WHERE条件中的列
        import re
        where_match = re.search(r'WHERE\s+(.+?)(?:ORDER|GROUP|LIMIT|$)', sql, re.IGNORECASE)
        if where_match:
            where_clause = where_match.group(1)
            # 提取列名（简单正则）
            columns = re.findall(r'(\w+)\s*[=<>]', where_clause)
            if columns:
                print(f"  Consider indexes on: {', '.join(set(columns))}")

        # 检测ORDER BY
        order_match = re.search(r'ORDER\s+BY\s+(.+?)(?:LIMIT|$)', sql, re.IGNORECASE)
        if order_match:
            order_clause = order_match.group(1)
            print(f"  Consider index on ORDER BY: {order_clause}")

# 使用
analyzer = QueryAnalyzer('app.db')
analyzer.analyze('''
    SELECT * FROM orders
    WHERE user_id = ? AND status = ?
    ORDER BY created_at DESC
    LIMIT 10
''', (123, 'paid'))
```

---

**文档版本**: v1.0.0
**最后更新**: 2025-12-04
