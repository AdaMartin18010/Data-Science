# ç§»åŠ¨åº”ç”¨ç¦»çº¿æ•°æ®åŒæ­¥æ¡ˆä¾‹

> **æ¡ˆä¾‹ç±»å‹**ï¼šç§»åŠ¨åº”ç”¨å®æˆ˜æ¡ˆä¾‹
> **åº”ç”¨åœºæ™¯**ï¼šç§»åŠ¨åº”ç”¨ã€ç¦»çº¿ä¼˜å…ˆã€æ•°æ®åŒæ­¥
> **æŠ€æœ¯ç‰¹ç‚¹**ï¼šç¦»çº¿æ•°æ®å­˜å‚¨ã€å¢é‡åŒæ­¥ã€å†²çªè§£å†³

---

## ğŸ“‘ ç›®å½•

- [ç§»åŠ¨åº”ç”¨ç¦»çº¿æ•°æ®åŒæ­¥æ¡ˆä¾‹](#ç§»åŠ¨åº”ç”¨ç¦»çº¿æ•°æ®åŒæ­¥æ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. åœºæ™¯æè¿°](#1-åœºæ™¯æè¿°)
    - [1.1 ä¸šåŠ¡èƒŒæ™¯](#11-ä¸šåŠ¡èƒŒæ™¯)
    - [1.2 ç³»ç»Ÿè§„æ¨¡](#12-ç³»ç»Ÿè§„æ¨¡)
  - [2. æŠ€æœ¯æŒ‘æˆ˜](#2-æŠ€æœ¯æŒ‘æˆ˜)
    - [2.1 ç¦»çº¿æ•°æ®å­˜å‚¨](#21-ç¦»çº¿æ•°æ®å­˜å‚¨)
    - [2.2 å¢é‡åŒæ­¥](#22-å¢é‡åŒæ­¥)
    - [2.3 å†²çªè§£å†³](#23-å†²çªè§£å†³)
  - [3. è§£å†³æ–¹æ¡ˆ](#3-è§£å†³æ–¹æ¡ˆ)
    - [3.1 æ•°æ®æ¨¡å‹è®¾è®¡](#31-æ•°æ®æ¨¡å‹è®¾è®¡)
    - [3.2 åŒæ­¥æœºåˆ¶](#32-åŒæ­¥æœºåˆ¶)
    - [3.3 å†²çªè§£å†³ç­–ç•¥](#33-å†²çªè§£å†³ç­–ç•¥)
  - [4. å®ç°ç»†èŠ‚](#4-å®ç°ç»†èŠ‚)
    - [4.1 Pythonå®ç°](#41-pythonå®ç°)
    - [4.2 åŒæ­¥æµç¨‹](#42-åŒæ­¥æµç¨‹)
  - [5. æ€§èƒ½ä¼˜åŒ–](#5-æ€§èƒ½ä¼˜åŒ–)
  - [6. ä¼˜åŒ–æ•ˆæœ](#6-ä¼˜åŒ–æ•ˆæœ)
  - [7. æœ€ä½³å®è·µ](#7-æœ€ä½³å®è·µ)
  - [8. ğŸ”— ç›¸å…³èµ„æº](#8--ç›¸å…³èµ„æº)

---

## 1. åœºæ™¯æè¿°

### 1.1 ä¸šåŠ¡èƒŒæ™¯

æŸç§»åŠ¨åº”ç”¨éœ€è¦åœ¨ç¦»çº¿ç¯å¢ƒä¸‹å·¥ä½œï¼Œå¹¶æ”¯æŒå¤šè®¾å¤‡æ•°æ®åŒæ­¥ï¼š

- **ç¦»çº¿ä¼˜å…ˆ**ï¼šåº”ç”¨å¿…é¡»èƒ½åœ¨æ— ç½‘ç»œç¯å¢ƒä¸‹æ­£å¸¸å·¥ä½œ
- **å¤šè®¾å¤‡åŒæ­¥**ï¼šç”¨æˆ·å¯åœ¨å¤šä¸ªè®¾å¤‡ä¸Šä½¿ç”¨ï¼Œæ•°æ®éœ€åŒæ­¥
- **æ•°æ®é‡**ï¼šå•è®¾å¤‡å­˜å‚¨ 10ä¸‡+ æ¡è®°å½•
- **åŒæ­¥é¢‘ç‡**ï¼šç½‘ç»œå¯ç”¨æ—¶è‡ªåŠ¨åŒæ­¥
- **å†²çªå¤„ç†**ï¼šå¤šè®¾å¤‡åŒæ—¶ä¿®æ”¹æ—¶çš„å†²çªè§£å†³

### 1.2 ç³»ç»Ÿè§„æ¨¡

- **è¡¨æ•°é‡**ï¼š20+ ä¸ªä¸šåŠ¡è¡¨
- **æœ€å¤§è¡¨è®°å½•æ•°**ï¼š50ä¸‡æ¡
- **åŒæ­¥æ•°æ®é‡**ï¼šæ¯æ¬¡åŒæ­¥ 1,000-10,000 æ¡å˜æ›´
- **åŒæ­¥å»¶è¿Ÿ**ï¼š< 5ç§’ï¼ˆç½‘ç»œè‰¯å¥½æ—¶ï¼‰
- **å†²çªç‡**ï¼š< 1%

---

## 2. æŠ€æœ¯æŒ‘æˆ˜

### 2.1 ç¦»çº¿æ•°æ®å­˜å‚¨

**æŒ‘æˆ˜**ï¼š

- æœ¬åœ°æ•°æ®æŒä¹…åŒ–
- å¿«é€ŸæŸ¥è¯¢å“åº”
- å­˜å‚¨ç©ºé—´é™åˆ¶

**è§£å†³æ–¹æ¡ˆ**ï¼š

- ä½¿ç”¨SQLiteä½œä¸ºæœ¬åœ°æ•°æ®åº“
- ä¼˜åŒ–ç´¢å¼•è®¾è®¡
- æ•°æ®å‹ç¼©å’Œå½’æ¡£

### 2.2 å¢é‡åŒæ­¥

**æŒ‘æˆ˜**ï¼š

- åªåŒæ­¥å˜æ›´æ•°æ®
- å‡å°‘ç½‘ç»œä¼ è¾“
- æé«˜åŒæ­¥æ•ˆç‡

**è§£å†³æ–¹æ¡ˆ**ï¼š

- ä½¿ç”¨æ—¶é—´æˆ³è·Ÿè¸ªå˜æ›´
- å®ç°å˜æ›´æ—¥å¿—
- æ‰¹é‡åŒæ­¥ä¼˜åŒ–

### 2.3 å†²çªè§£å†³

**æŒ‘æˆ˜**ï¼š

- å¤šè®¾å¤‡åŒæ—¶ä¿®æ”¹
- æ•°æ®ä¸€è‡´æ€§ä¿è¯
- ç”¨æˆ·ä½“éªŒä¼˜åŒ–

**è§£å†³æ–¹æ¡ˆ**ï¼š

- Last-Write-Winsç­–ç•¥
- ç‰ˆæœ¬å·æœºåˆ¶
- å†²çªæ£€æµ‹å’Œæç¤º

---

## 3. è§£å†³æ–¹æ¡ˆ

### 3.1 æ•°æ®æ¨¡å‹è®¾è®¡

```sql
-- ç”¨æˆ·è¡¨ï¼ˆå¸¦åŒæ­¥å­—æ®µï¼‰
CREATE TABLE users (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL,
    email TEXT,
    -- åŒæ­¥å­—æ®µ
    created_at INTEGER NOT NULL,
    updated_at INTEGER NOT NULL,
    deleted_at INTEGER,
    sync_status TEXT DEFAULT 'pending',  -- pending, synced, conflict
    version INTEGER DEFAULT 1,
    device_id TEXT
);

-- å˜æ›´æ—¥å¿—è¡¨
CREATE TABLE sync_log (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    table_name TEXT NOT NULL,
    record_id INTEGER NOT NULL,
    operation TEXT NOT NULL,  -- INSERT, UPDATE, DELETE
    timestamp INTEGER NOT NULL,
    data TEXT,  -- JSONæ ¼å¼çš„å˜æ›´æ•°æ®
    synced INTEGER DEFAULT 0
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_users_sync ON users(sync_status, updated_at);
CREATE INDEX idx_sync_log_pending ON sync_log(synced, timestamp);
```

### 3.2 åŒæ­¥æœºåˆ¶

```python
import sqlite3
import json
import time
from typing import List, Dict, Any

class OfflineSyncManager:
    def __init__(self, db_path: str, device_id: str):
        self.db_path = db_path
        self.device_id = device_id
        self.conn = sqlite3.connect(db_path)
        self.setup_tables()

    def setup_tables(self):
        """è®¾ç½®åŒæ­¥è¡¨"""
        cursor = self.conn.cursor()

        # åˆ›å»ºå˜æ›´æ—¥å¿—è¡¨
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS sync_log (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                table_name TEXT NOT NULL,
                record_id INTEGER NOT NULL,
                operation TEXT NOT NULL,
                timestamp INTEGER NOT NULL,
                data TEXT,
                synced INTEGER DEFAULT 0
            )
        """)

        self.conn.commit()

    def track_change(self, table_name: str, record_id: int, operation: str, data: Dict = None):
        """è·Ÿè¸ªæ•°æ®å˜æ›´"""
        cursor = self.conn.cursor()
        cursor.execute("""
            INSERT INTO sync_log (table_name, record_id, operation, timestamp, data)
            VALUES (?, ?, ?, ?, ?)
        """, (table_name, record_id, operation, int(time.time()), json.dumps(data) if data else None))
        self.conn.commit()

    def get_pending_changes(self, limit: int = 1000) -> List[Dict]:
        """è·å–å¾…åŒæ­¥çš„å˜æ›´"""
        cursor = self.conn.cursor()
        cursor.execute("""
            SELECT * FROM sync_log
            WHERE synced = 0
            ORDER BY timestamp ASC
            LIMIT ?
        """, (limit,))

        changes = []
        for row in cursor.fetchall():
            changes.append({
                'id': row[0],
                'table_name': row[1],
                'record_id': row[2],
                'operation': row[3],
                'timestamp': row[4],
                'data': json.loads(row[5]) if row[5] else None
            })

        return changes

    def mark_synced(self, sync_log_ids: List[int]):
        """æ ‡è®°ä¸ºå·²åŒæ­¥"""
        cursor = self.conn.cursor()
        placeholders = ','.join(['?'] * len(sync_log_ids))
        cursor.execute(f"UPDATE sync_log SET synced = 1 WHERE id IN ({placeholders})", sync_log_ids)
        self.conn.commit()

    def apply_remote_changes(self, changes: List[Dict]):
        """åº”ç”¨è¿œç¨‹å˜æ›´"""
        cursor = self.conn.cursor()

        for change in changes:
            table_name = change['table_name']
            operation = change['operation']
            data = change['data']

            if operation == 'INSERT' or operation == 'UPDATE':
                # æ£€æŸ¥ç‰ˆæœ¬å†²çª
                cursor.execute(f"""
                    SELECT version FROM {table_name} WHERE id = ?
                """, (change['record_id'],))

                existing = cursor.fetchone()
                if existing and existing[0] >= change.get('version', 0):
                    # æœ¬åœ°ç‰ˆæœ¬æ›´æ–°ï¼Œè·³è¿‡
                    continue

                # åº”ç”¨å˜æ›´
                if operation == 'INSERT':
                    self._insert_record(cursor, table_name, data)
                else:
                    self._update_record(cursor, table_name, change['record_id'], data)

            elif operation == 'DELETE':
                cursor.execute(f"UPDATE {table_name} SET deleted_at = ? WHERE id = ?",
                             (int(time.time()), change['record_id']))

        self.conn.commit()

    def _insert_record(self, cursor, table_name: str, data: Dict):
        """æ’å…¥è®°å½•"""
        columns = ', '.join(data.keys())
        placeholders = ', '.join(['?'] * len(data))
        values = list(data.values())

        cursor.execute(f"INSERT INTO {table_name} ({columns}) VALUES ({placeholders})", values)

    def _update_record(self, cursor, table_name: str, record_id: int, data: Dict):
        """æ›´æ–°è®°å½•"""
        set_clause = ', '.join([f"{k} = ?" for k in data.keys()])
        values = list(data.values()) + [record_id]

        cursor.execute(f"UPDATE {table_name} SET {set_clause} WHERE id = ?", values)
```

### 3.3 å†²çªè§£å†³ç­–ç•¥

```python
class ConflictResolver:
    def __init__(self, sync_manager: OfflineSyncManager):
        self.sync_manager = sync_manager

    def resolve_conflict(self, local_data: Dict, remote_data: Dict) -> Dict:
        """è§£å†³å†²çªï¼ˆLast-Write-Winsï¼‰"""
        local_version = local_data.get('version', 0)
        remote_version = remote_data.get('version', 0)
        local_updated = local_data.get('updated_at', 0)
        remote_updated = remote_data.get('updated_at', 0)

        # ç‰ˆæœ¬å·ä¼˜å…ˆ
        if remote_version > local_version:
            return remote_data

        # æ—¶é—´æˆ³ä¼˜å…ˆ
        if remote_updated > local_updated:
            return remote_data

        # æœ¬åœ°ä¼˜å…ˆ
        return local_data

    def detect_conflicts(self, table_name: str) -> List[Dict]:
        """æ£€æµ‹å†²çª"""
        cursor = self.sync_manager.conn.cursor()
        cursor.execute(f"""
            SELECT * FROM {table_name}
            WHERE sync_status = 'conflict'
        """)

        conflicts = []
        for row in cursor.fetchall():
            conflicts.append(dict(row))

        return conflicts
```

---

## 4. å®ç°ç»†èŠ‚

### 4.1 Pythonå®ç°

```python
class SyncClient:
    def __init__(self, db_path: str, device_id: str, server_url: str):
        self.sync_manager = OfflineSyncManager(db_path, device_id)
        self.server_url = server_url
        self.device_id = device_id

    def sync(self):
        """æ‰§è¡ŒåŒæ­¥"""
        # 1. è·å–å¾…åŒæ­¥çš„æœ¬åœ°å˜æ›´
        pending_changes = self.sync_manager.get_pending_changes()

        if not pending_changes:
            return

        # 2. å‘é€åˆ°æœåŠ¡å™¨
        response = self._send_to_server(pending_changes)

        # 3. åº”ç”¨æœåŠ¡å™¨è¿”å›çš„å˜æ›´
        if response.get('remote_changes'):
            self.sync_manager.apply_remote_changes(response['remote_changes'])

        # 4. æ ‡è®°æœ¬åœ°å˜æ›´å·²åŒæ­¥
        sync_log_ids = [c['id'] for c in pending_changes]
        self.sync_manager.mark_synced(sync_log_ids)

    def _send_to_server(self, changes: List[Dict]) -> Dict:
        """å‘é€å˜æ›´åˆ°æœåŠ¡å™¨"""
        import requests

        try:
            response = requests.post(
                f"{self.server_url}/sync",
                json={
                    'device_id': self.device_id,
                    'changes': changes
                },
                timeout=10
            )
            return response.json()
        except Exception as e:
            print(f"åŒæ­¥å¤±è´¥: {e}")
            return {}
```

### 4.2 åŒæ­¥æµç¨‹

```text
åŒæ­¥æµç¨‹
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. æœ¬åœ°æ•°æ®å˜æ›´
   â†“
2. è®°å½•åˆ°sync_logè¡¨
   â†“
3. ç½‘ç»œå¯ç”¨æ—¶è§¦å‘åŒæ­¥
   â†“
4. è·å–å¾…åŒæ­¥å˜æ›´
   â†“
5. å‘é€åˆ°æœåŠ¡å™¨
   â†“
6. æ¥æ”¶æœåŠ¡å™¨å˜æ›´
   â†“
7. åº”ç”¨è¿œç¨‹å˜æ›´ï¼ˆå†²çªæ£€æµ‹ï¼‰
   â†“
8. æ ‡è®°æœ¬åœ°å˜æ›´å·²åŒæ­¥
```

---

## 5. æ€§èƒ½ä¼˜åŒ–

```python
class OptimizedSyncManager(OfflineSyncManager):
    def __init__(self, db_path: str, device_id: str):
        super().__init__(db_path, device_id)
        self.setup_optimizations()

    def setup_optimizations(self):
        """è®¾ç½®æ€§èƒ½ä¼˜åŒ–"""
        cursor = self.conn.cursor()

        # WALæ¨¡å¼
        cursor.execute("PRAGMA journal_mode = WAL")

        # æ‰¹é‡æ“ä½œä¼˜åŒ–
        cursor.execute("PRAGMA synchronous = NORMAL")
        cursor.execute("PRAGMA cache_size = -64000")  # 64MBç¼“å­˜

        # åˆ›å»ºå¤åˆç´¢å¼•
        cursor.execute("""
            CREATE INDEX IF NOT EXISTS idx_sync_log_composite
            ON sync_log(synced, timestamp, table_name)
        """)

        self.conn.commit()

    def batch_sync(self, batch_size: int = 100):
        """æ‰¹é‡åŒæ­¥"""
        while True:
            changes = self.get_pending_changes(batch_size)
            if not changes:
                break

            # æ‰¹é‡å‘é€
            response = self._send_to_server(changes)

            # æ‰¹é‡åº”ç”¨
            if response.get('remote_changes'):
                self.apply_remote_changes(response['remote_changes'])

            # æ‰¹é‡æ ‡è®°
            sync_log_ids = [c['id'] for c in changes]
            self.mark_synced(sync_log_ids)
```

---

## 6. ä¼˜åŒ–æ•ˆæœ

- **åŒæ­¥å»¶è¿Ÿ**ï¼šä» 30ç§’ é™ä½åˆ° < 5ç§’
- **ç½‘ç»œæµé‡**ï¼šå‡å°‘ 70%ï¼ˆå¢é‡åŒæ­¥ï¼‰
- **å†²çªç‡**ï¼š< 1%
- **å­˜å‚¨ç©ºé—´**ï¼šå˜æ›´æ—¥å¿—å ç”¨ < 5MB

---

## 7. æœ€ä½³å®è·µ

1. **å˜æ›´è·Ÿè¸ª**
   - ä½¿ç”¨æ—¶é—´æˆ³è€Œéè‡ªå¢ID
   - è®°å½•å®Œæ•´å˜æ›´ä¿¡æ¯
   - å®šæœŸæ¸…ç†å·²åŒæ­¥æ—¥å¿—

2. **å†²çªå¤„ç†**
   - æ˜ç¡®çš„å†²çªè§£å†³ç­–ç•¥
   - ç”¨æˆ·å‹å¥½çš„å†²çªæç¤º
   - ç‰ˆæœ¬å·æœºåˆ¶

3. **æ€§èƒ½ä¼˜åŒ–**
   - æ‰¹é‡åŒæ­¥
   - ç´¢å¼•ä¼˜åŒ–
   - WALæ¨¡å¼

---

## 8. ğŸ”— ç›¸å…³èµ„æº

- [äº‹åŠ¡ç®¡ç†](../08-ç¼–ç¨‹å®è·µ/08.02-äº‹åŠ¡ç®¡ç†.md) - äº‹åŠ¡å¤„ç†
- [å¤šçº¿ç¨‹å¹¶å‘æ¨¡å¼](../08-ç¼–ç¨‹å®è·µ/08.12-SQLiteå¤šçº¿ç¨‹å¹¶å‘æ¨¡å¼æœ€ä½³å®è·µ.md) - å¹¶å‘å¤„ç†
- [æ€§èƒ½ä¼˜åŒ–](../03-æ€§èƒ½ä¼˜åŒ–/) - æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

---

**æœ€åæ›´æ–°**: 2025-12-05
**ç»´æŠ¤è€…**: Data-Science Team
