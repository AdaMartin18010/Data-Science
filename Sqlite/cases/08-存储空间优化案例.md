# 存储空间优化案例

> **案例类型**：性能优化实战案例
> **应用场景**：移动应用、嵌入式系统、资源受限环境
> **技术特点**：存储空间优化、数据压缩、碎片整理

---

## 📑 目录

- [存储空间优化案例](#存储空间优化案例)
  - [📑 目录](#-目录)
  - [一、场景描述](#一场景描述)
    - [1.1 业务背景](#11-业务背景)
    - [1.2 系统规模](#12-系统规模)
  - [二、技术挑战](#二技术挑战)
    - [2.1 存储空间挑战](#21-存储空间挑战)
    - [2.2 数据冗余挑战](#22-数据冗余挑战)
    - [2.3 碎片化挑战](#23-碎片化挑战)
  - [三、优化方案](#三优化方案)
    - [3.1 数据类型优化](#31-数据类型优化)
    - [3.2 表结构优化](#32-表结构优化)
    - [3.3 索引优化](#33-索引优化)
    - [3.4 数据压缩](#34-数据压缩)
    - [3.5 碎片整理](#35-碎片整理)
    - [3.6 数据归档](#36-数据归档)
  - [四、优化效果](#四优化效果)
    - [4.1 存储空间节省](#41-存储空间节省)
    - [4.2 性能影响](#42-性能影响)
    - [4.3 成本降低](#43-成本降低)
  - [五、最佳实践](#五最佳实践)
    - [5.1 数据类型选择最佳实践](#51-数据类型选择最佳实践)
    - [5.2 表设计最佳实践](#52-表设计最佳实践)
    - [5.3 索引设计最佳实践](#53-索引设计最佳实践)
  - [🔗 相关资源](#-相关资源)

---

## 一、场景描述

### 1.1 业务背景

某移动应用需要在有限的存储空间中存储大量用户数据。系统要求：

- **存储空间限制**：应用可用存储空间 < 100MB
- **数据量**：需要存储 100万+ 条记录
- **数据增长**：日均新增 10,000 条记录
- **性能要求**：查询响应时间 < 100ms
- **存储周期**：数据保存 30 天

### 1.2 系统规模

- **数据库文件大小**：初始 50MB，优化后目标 < 30MB
- **表数量**：15+ 个业务表
- **最大表记录数**：100万条
- **索引数量**：20+ 个索引
- **存储空间节省目标**：40%+

---

## 二、技术挑战

### 2.1 存储空间挑战

**挑战**：

- 数据库文件过大，超出存储限制
- 数据类型选择不当，浪费存储空间
- 索引占用大量空间
- 数据冗余严重

**影响**：

- 应用无法安装或运行
- 用户体验差
- 存储成本高

### 2.2 数据冗余挑战

**挑战**：

- 重复数据占用空间
- 未使用的列占用空间
- 过长的文本字段
- 不必要的索引

**影响**：

- 存储空间浪费
- 备份和恢复时间长
- 性能下降

### 2.3 碎片化挑战

**挑战**：

- 删除操作后空间无法回收
- 频繁更新导致碎片化
- 碎片化影响查询性能
- VACUUM操作耗时

**影响**：

- 存储空间浪费
- 查询性能下降
- 维护成本高

---

## 三、优化方案

### 3.1 数据类型优化

**优化前设计**：

```sql
-- 原始设计：浪费空间
CREATE TABLE users (
    id TEXT PRIMARY KEY,              -- TEXT类型，浪费空间
    name TEXT,                        -- 未限制长度
    email TEXT,                       -- 未限制长度
    age TEXT,                         -- 应该用INTEGER
    created_at TEXT,                  -- 应该用INTEGER时间戳
    status TEXT                       -- 应该用INTEGER或BOOLEAN
);
```

**优化后设计**：

```sql
-- 优化后设计：节省空间
CREATE TABLE users (
    id INTEGER PRIMARY KEY,           -- INTEGER类型，节省空间
    name TEXT,                        -- 保持TEXT（需要）
    email TEXT,                       -- 保持TEXT（需要）
    age INTEGER,                      -- INTEGER类型，节省空间
    created_at INTEGER,               -- INTEGER时间戳，节省空间
    status INTEGER                    -- INTEGER类型，节省空间
);

-- 空间节省对比
-- TEXT id (UUID): ~36字节
-- INTEGER id: 8字节
-- 节省：78%
```

### 3.2 表结构优化

**列顺序优化**：

```sql
-- 优化列顺序：常用列在前，不常用列在后
CREATE TABLE orders (
    id INTEGER PRIMARY KEY,           -- 最常用
    user_id INTEGER NOT NULL,         -- 常用
    status INTEGER NOT NULL,          -- 常用
    amount REAL NOT NULL,             -- 常用
    created_at INTEGER NOT NULL,      -- 常用
    updated_at INTEGER,               -- 不常用
    notes TEXT,                       -- 很少用
    metadata TEXT                     -- 很少用
);
```

**NULL值优化**：

```sql
-- 避免不必要的NULL值
CREATE TABLE products (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL,               -- 必须字段，NOT NULL
    price REAL NOT NULL,              -- 必须字段，NOT NULL
    description TEXT,                 -- 可选字段，允许NULL
    category_id INTEGER               -- 可选字段，允许NULL
);
```

### 3.3 索引优化

**索引选择优化**：

```sql
-- 只创建必要的索引
CREATE TABLE logs (
    id INTEGER PRIMARY KEY,
    user_id INTEGER NOT NULL,
    action TEXT NOT NULL,
    timestamp INTEGER NOT NULL,
    details TEXT
);

-- 只创建常用查询的索引
CREATE INDEX idx_user_time ON logs(user_id, timestamp DESC);
-- 不创建不常用的索引，节省空间

-- 使用部分索引（只索引常用数据）
CREATE INDEX idx_recent_logs ON logs(timestamp DESC)
WHERE timestamp > strftime('%s', 'now', '-7 days');
```

**覆盖索引优化**：

```sql
-- 覆盖索引：包含查询所需的所有列
CREATE INDEX idx_user_action_time ON logs(user_id, action, timestamp DESC);

-- 查询时使用覆盖索引，避免回表
SELECT user_id, action, timestamp
FROM logs
WHERE user_id = 123
ORDER BY timestamp DESC
LIMIT 100;
```

### 3.4 数据压缩

**文本压缩**：

```python
import sqlite3
import gzip
import json

def compress_text(text):
    """压缩文本数据"""
    if text is None:
        return None
    return gzip.compress(text.encode('utf-8'))

def decompress_text(compressed):
    """解压文本数据"""
    if compressed is None:
        return None
    return gzip.decompress(compressed).decode('utf-8')

# 使用示例
def store_compressed_data(conn, data):
    """存储压缩数据"""
    cursor = conn.cursor()
    compressed = compress_text(json.dumps(data))
    cursor.execute(
        'INSERT INTO data_table (compressed_data) VALUES (?)',
        (compressed,)
    )
    conn.commit()

# 空间节省：通常可节省50-70%
```

**JSON数据优化**：

```sql
-- 使用JSON存储结构化数据，避免多表JOIN
CREATE TABLE user_profiles (
    id INTEGER PRIMARY KEY,
    user_id INTEGER NOT NULL,
    profile_data TEXT,  -- JSON格式，压缩存储
    -- 避免创建多个关联表
);

-- 使用生成列提取常用字段
CREATE TABLE user_profiles (
    id INTEGER PRIMARY KEY,
    user_id INTEGER NOT NULL,
    profile_data TEXT,
    name TEXT GENERATED ALWAYS AS (json_extract(profile_data, '$.name')) VIRTUAL,
    email TEXT GENERATED ALWAYS AS (json_extract(profile_data, '$.email')) VIRTUAL
);
```

### 3.5 碎片整理

**VACUUM操作**：

```python
def vacuum_database(conn):
    """执行VACUUM整理碎片"""
    # 1. 执行VACUUM回收空间
    conn.execute('VACUUM')

    # 2. 重新分析统计信息
    conn.execute('ANALYZE')

    # 3. 检查数据库完整性
    cursor = conn.cursor()
    cursor.execute('PRAGMA integrity_check')
    result = cursor.fetchone()
    if result[0] != 'ok':
        raise RuntimeError(f"数据库完整性检查失败: {result[0]}")

# 定期执行VACUUM（如每周一次）
# 空间回收：通常可回收10-30%空间
```

**增量VACUUM**：

```sql
-- 增量VACUUM：逐步回收空间，不阻塞操作
PRAGMA incremental_vacuum(1000);  -- 回收1000页

-- 适合大数据库，避免长时间阻塞
```

### 3.6 数据归档

**数据归档策略**：

```python
def archive_old_data(conn, table, days=30):
    """归档旧数据"""
    cutoff_timestamp = int(time.time()) - (days * 24 * 3600)

    cursor = conn.cursor()

    # 1. 导出旧数据到归档表
    cursor.execute(f"""
        CREATE TABLE {table}_archive AS
        SELECT * FROM {table}
        WHERE created_at < ?
    """, (cutoff_timestamp,))

    # 2. 删除旧数据
    cursor.execute(f"""
        DELETE FROM {table}
        WHERE created_at < ?
    """, (cutoff_timestamp,))

    # 3. 执行VACUUM回收空间
    conn.execute('VACUUM')

    conn.commit()

# 定期归档，保持数据库大小可控
```

---

## 四、优化效果

### 4.1 存储空间节省

**优化前后对比**：

| 优化项 | 优化前 | 优化后 | 节省比例 |
|--------|--------|--------|---------|
| 数据库文件大小 | 50MB | 28MB | -44% |
| 索引占用空间 | 12MB | 6MB | -50% |
| 数据占用空间 | 35MB | 20MB | -43% |
| 碎片化空间 | 3MB | 0.5MB | -83% |

### 4.2 性能影响

**优化前后对比**：

| 操作类型 | 优化前 | 优化后 | 变化 |
|---------|--------|--------|------|
| 查询性能 | 基准 | +5% | 略有提升 |
| 插入性能 | 基准 | -2% | 略有下降 |
| 索引维护 | 基准 | -10% | 显著降低 |

### 4.3 成本降低

**优化前后对比**：

| 指标 | 优化前 | 优化后 | 改善 |
|------|--------|--------|------|
| 存储成本 | 基准 | -44% | 显著降低 |
| 备份时间 | 基准 | -44% | 显著降低 |
| 恢复时间 | 基准 | -44% | 显著降低 |

---

## 五、最佳实践

### 5.1 数据类型选择最佳实践

1. **使用INTEGER代替TEXT**
   - ID字段使用INTEGER PRIMARY KEY
   - 数值字段使用INTEGER或REAL
   - 时间戳使用INTEGER

2. **避免过长的TEXT字段**
   - 限制TEXT字段长度（如适用）
   - 使用压缩存储大文本
   - 考虑外部存储大文件

3. **使用合适的数值类型**
   - 小整数使用INTEGER
   - 浮点数使用REAL
   - 布尔值使用INTEGER（0/1）

### 5.2 表设计最佳实践

1. **列顺序优化**
   - 常用列在前，不常用列在后
   - 固定长度列在前，可变长度列在后
   - 减少NULL值使用

2. **避免数据冗余**
   - 使用规范化设计
   - 避免重复数据
   - 使用外键关联

3. **合理使用JSON**
   - 结构化数据使用JSON存储
   - 使用生成列提取常用字段
   - 避免过度嵌套

### 5.3 索引设计最佳实践

1. **只创建必要索引**
   - 只为常用查询创建索引
   - 避免过度索引
   - 定期审查索引使用情况

2. **使用部分索引**
   - 只索引常用数据
   - 减少索引大小
   - 提升索引维护性能

3. **使用覆盖索引**
   - 包含查询所需的所有列
   - 避免回表查询
   - 提升查询性能

### 5.4 数据管理最佳实践

1. **定期归档**
   - 定期归档旧数据
   - 保持数据库大小可控
   - 执行VACUUM回收空间

2. **碎片整理**
   - 定期执行VACUUM
   - 大数据库使用增量VACUUM
   - 监控碎片化率

3. **数据压缩**
   - 压缩大文本数据
   - 使用JSON存储结构化数据
   - 考虑外部存储大文件

---

## 🔗 相关资源

- [02.01 数据类型系统](../02-数据模型/02.01-数据类型系统.md) - 数据类型选择
- [02.02 表结构设计](../02-数据模型/02.02-表结构设计.md) - 表设计最佳实践
- [03.02 优化策略](../03-性能优化/03.02-优化策略.md) - 索引优化策略
- [08.04 PRAGMA配置](../08-编程实践/08.04-PRAGMA配置.md) - PRAGMA配置详解

---

**维护者**：Data-Science Team
**最后更新**：2025-01-15
