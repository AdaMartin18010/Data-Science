# SQLite 知识库章节编号规范

> **创建日期**: 2025-01-15
> **最后更新**: 2025-01-15
> **版本**: v2.0.0
> **状态**: ✅ 已生效

---

## 一、 📋 目录

- [SQLite 知识库章节编号规范](#sqlite-知识库章节编号规范)
  - [一、 📋 目录](#一--目录)
  - [二、 规范目的](#二-规范目的)
  - [三、 编号格式](#三-编号格式)
    - [三.1. 1. 1. 1. 一级标题（章节）](#三1-1-1-1-一级标题章节)
    - [六.1. 1. 1. 1. 二级标题（子章节）](#六1-1-1-1-二级标题子章节)
    - [六.5. 5. 5. 5. 三级标题（子子章节）](#六5-5-5-5-三级标题子子章节)
    - [六.6. 6. 6. 6. 四级标题（子子子章节）](#六6-6-6-6-四级标题子子子章节)
  - [七、 编号规则](#七-编号规则)
    - [七.1. 1. 1. 1. 编号连续性](#七1-1-1-1-编号连续性)
    - [七.2. 2. 2. 2. 编号独立性](#七2-2-2-2-编号独立性)
    - [七.3. 3. 3. 3. 编号层级](#七3-3-3-3-编号层级)
    - [七.4. 4. 4. 4. 特殊章节](#七4-4-4-4-特殊章节)
  - [八、 示例](#八-示例)
    - [八.1. 1. 1. 1. 完整示例](#八1-1-1-1-完整示例)
    - [13.2. 严格模式语法](#132-严格模式语法)
  - [14、 🔗 相关资源](#14--相关资源)
  - [15、 📚 参考资料](#15--参考资料)
  - [16、 检查清单](#16-检查清单)
  - [17、 迁移指南](#17-迁移指南)
    - [17.1. 从旧格式迁移](#171-从旧格式迁移)
    - [19.2. 迁移步骤](#192-迁移步骤)
    - [19.3. 批量迁移工具](#193-批量迁移工具)

---

## 二、 规范目的

统一SQLite知识库所有文档的章节编号格式，提升文档的专业性和可读性。

**目标**：

- 统一章节编号格式
- 清晰的目录层级结构
- 便于导航和引用
- 提升文档专业性

---

## 三、 编号格式

### 三.1. 1. 1. 1. 一级标题（章节）

**格式**：使用中文数字（一、二、三、四、五、六、七、八、九、十...）

**Markdown格式**：

```markdown
## 四、 章节名称

## 五、 章节名称

## 六、 章节名称
```

**说明**：

- 一级标题使用 `##`（两个#）
- 编号使用中文数字
- 编号后使用顿号（、）
- 标题后不使用标点

**示例**：

- ✅ `## 一、核心架构`
- ✅ `## 二、数据模型`
- ✅ `## 三、性能优化`
- ❌ `## 1. 核心架构`（错误：应使用中文数字）
- ❌ `## 一 核心架构`（错误：缺少顿号）

### 六.1. 1. 1. 1. 二级标题（子章节）

**格式**：使用数字编号（1.1, 1.2, 2.1, 2.2...）

**Markdown格式**：

```markdown
### 六.2. 2. 2. 2. 子章节名称

### 六.3. 3. 3. 3. 子章节名称

### 六.4. 4. 4. 4. 子章节名称
```

**说明**：

- 二级标题使用 `###`（三个#）
- 编号格式：`一级编号.二级编号`
- 编号后使用空格（不是顿号）
- 标题后不使用标点

**示例**：

- ✅ `### 1.1 存储类`
- ✅ `### 1.2 类型亲和性`
- ✅ `### 2.1 表结构设计`
- ❌ `### 1.1. 存储类`（错误：编号后不应有句号）
- ❌ `### 一.1 存储类`（错误：应使用数字）

### 六.5. 5. 5. 5. 三级标题（子子章节）

**格式**：使用数字编号（1.1.1, 1.1.2, 2.1.1...）

**Markdown格式**：

```markdown
#### 6.5.1. 子子章节名称

#### 6.5.2. 子子章节名称

#### 6.5.3. 子子章节名称
```

**说明**：

- 三级标题使用 `####`（四个#）
- 编号格式：`一级编号.二级编号.三级编号`
- 编号后使用空格
- 标题后不使用标点

**示例**：

- ✅ `#### 1.1.1 五种存储类`
- ✅ `#### 1.1.2 动态类型系统`
- ❌ `#### 1.1.1. 五种存储类`（错误：编号后不应有句号）

### 六.6. 6. 6. 6. 四级标题（子子子章节）

**格式**：使用数字编号（1.1.1.1, 1.1.1.2...）

**Markdown格式**：

```markdown
#### 6.6.1. 子子子章节名称

##### 子子子章节名称
```

**说明**：

- 四级标题使用 `#####`（五个#）
- 编号格式：`一级编号.二级编号.三级编号.四级编号`
- 编号后使用空格
- 标题后不使用标点

**注意**：四级标题应谨慎使用，仅在必要时使用。

---

## 七、 编号规则

### 七.1. 1. 1. 1. 编号连续性

- 每个级别的编号必须连续
- 不能跳过编号（如：1.1, 1.3 是错误的，应该是 1.1, 1.2）
- 编号从1开始

### 七.2. 2. 2. 2. 编号独立性

- 每个一级章节的二级编号从1.1开始
- 每个二级章节的三级编号从1.1.1开始
- 每个三级章节的四级编号从1.1.1.1开始

### 七.3. 3. 3. 3. 编号层级

- 最多使用四级标题
- 避免过深的层级（建议不超过四级）

### 七.4. 4. 4. 4. 特殊章节

**概述、目录、思维导图等**：

- 这些章节不使用编号
- 使用特殊标记，如：`## 📋 概述`、`## 📑 目录`

**相关资源、参考资料**：

- 文档末尾的章节不使用编号
- 使用特殊标记，如：`## 🔗 相关资源`、`## 📚 参考资料`

---

## 八、 示例

### 八.1. 1. 1. 1. 完整示例

```markdown
# 数据类型系统：存储类与类型亲和性

> **创建日期**：2025-11-13
> **最后更新**：2025-11-13
> **版本**：SQLite 3.31+ 至 3.47+

---

## 九、 📋 概述

SQLite3采用独特的动态类型系统...

---

## 十、 📑 目录

- [一、存储类（Storage Classes）](#一存储类storage-classes)
  - [1.1 五种存储类](#11-五种存储类)
  - [1.2 动态类型系统](#12-动态类型系统)
  - [1.3 存储类优先级](#13-存储类优先级)
- [二、类型亲和性（Type Affinity）](#二类型亲和性type-affinity)
  - [2.1 亲和性概念](#21-亲和性概念)
  - [2.2 五种类型亲和性](#22-五种类型亲和性)
- [三、严格表模式（Strict Tables）3.37+](#三严格表模式strict-tables337)
  - [3.1 严格模式概述](#31-严格模式概述)
  - [3.2 严格模式语法](#32-严格模式语法)

---

## 11、 存储类（Storage Classes）

### 11.1. 五种存储类

SQLite支持五种存储类...

### 11.2. 动态类型系统

**核心特性**：

SQLite使用动态类型系统...

### 11.3. 存储类优先级

当值可以转换为多种存储类时...

---

## 12、 类型亲和性（Type Affinity）

### 12.1. 亲和性概念

**定义**：类型亲和性是列声明类型到存储类的映射规则...

### 12.2. 五种类型亲和性

| 声明类型示例 | 亲和类型 | ... |
|------------|--------|-----|
| ... | ... | ... |

---

## 13、 严格表模式（Strict Tables）3.37+

### 13.1. 严格模式概述

**STRICT表模式**（3.37+）：

```sql
CREATE TABLE users (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL
) STRICT;
```

### 13.2. 严格模式语法

严格模式的语法规则...

---

## 14、 🔗 相关资源

- [相关文档链接](./相关文档.md)

---

## 15、 📚 参考资料

- [SQLite官方文档](https://www.sqlite.org/docs.html)

---

**最后更新**：2025-11-13
**维护者**：Data-Science Team

---

## 16、 检查清单

创建或更新文档时，请检查：

- [ ] 一级标题使用中文数字（一、二、三...）
- [ ] 二级标题使用数字编号（1.1, 1.2...）
- [ ] 三级标题使用数字编号（1.1.1, 1.1.2...）
- [ ] 四级标题使用数字编号（1.1.1.1...）
- [ ] 编号连续且正确
- [ ] 编号层级不超过四级
- [ ] 特殊章节（概述、目录等）使用特殊标记
- [ ] 目录中的链接与标题一致

---

## 17、 迁移指南

### 17.1. 从旧格式迁移

**旧格式示例**（不统一）：

```markdown
## 18、 核心架构
### 18.1. 编译执行模型
#### 18.1.1. 前端编译系统
```

**新格式**（统一）：

```markdown
## 19、 核心架构
### 19.1. 编译执行模型
#### 19.1.1. 前端编译系统
```

### 19.2. 迁移步骤

1. **识别一级标题**：找到所有 `##` 开头的标题
2. **转换编号**：将数字编号转换为中文数字
   - `## 1.` → `## 一、`
   - `## 2.` → `## 二、`
   - `## 3.` → `## 三、`
3. **检查二级标题**：确保使用 `1.1, 1.2` 格式
4. **检查三级标题**：确保使用 `1.1.1, 1.1.2` 格式
5. **更新目录**：更新文档目录中的链接

### 19.3. 批量迁移工具

可以使用脚本批量转换：

```python
# 示例：批量转换一级标题
import re

def convert_headers(content):
# 转换一级标题：## 1. → ## 一、
    chinese_numbers = ['一', '二', '三', '四', '五', '六', '七', '八', '九', '十']

    def replace_header(match):
        num = int(match.group(1))
        if 1 <= num <= 10:
            return f"## {chinese_numbers[num-1]}、"
        return match.group(0)

    pattern = r'^## (\d+)\.\s+'
    content = re.sub(pattern, replace_header, content, flags=re.MULTILINE)
    return content
```

---

**最后更新**: 2025-01-15
**维护者**: Data-Science Team
**状态**: ✅ 已生效
