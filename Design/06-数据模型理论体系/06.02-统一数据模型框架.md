# ç»Ÿä¸€æ•°æ®æ¨¡å‹æ¡†æ¶ï¼šå¤šæ¨¡å‹æ•°æ®åº“çš„ç»Ÿä¸€ç†è®ºæ¡†æ¶

> **åˆ›å»ºæ—¥æœŸ**ï¼š2025-01-15
> **æœ€åæ›´æ–°**ï¼š2025-12-01
> **ç‰ˆæœ¬**ï¼šv2.0
> **çŠ¶æ€**ï¼šå·²å®Œæˆ âœ…

---

## ğŸ“‹ ç›®å½•

- [ç»Ÿä¸€æ•°æ®æ¨¡å‹æ¡†æ¶ï¼šå¤šæ¨¡å‹æ•°æ®åº“çš„ç»Ÿä¸€ç†è®ºæ¡†æ¶](#ç»Ÿä¸€æ•°æ®æ¨¡å‹æ¡†æ¶å¤šæ¨¡å‹æ•°æ®åº“çš„ç»Ÿä¸€ç†è®ºæ¡†æ¶)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2. ç»Ÿä¸€æ¡†æ¶å®šä¹‰](#2-ç»Ÿä¸€æ¡†æ¶å®šä¹‰)
    - [2.1. ç»Ÿä¸€æ•°æ®æ¨¡å‹æ¡†æ¶](#21-ç»Ÿä¸€æ•°æ®æ¨¡å‹æ¡†æ¶)
    - [2.2. æ¨¡å‹æ³¨å†Œ](#22-æ¨¡å‹æ³¨å†Œ)
    - [2.3. ç»Ÿä¸€æ•°æ®æ¨¡å‹çš„å½¢å¼åŒ–å®šä¹‰](#23-ç»Ÿä¸€æ•°æ®æ¨¡å‹çš„å½¢å¼åŒ–å®šä¹‰)
  - [3. è·¨æ¨¡å‹æŸ¥è¯¢ä¼˜åŒ–](#3-è·¨æ¨¡å‹æŸ¥è¯¢ä¼˜åŒ–)
    - [3.1. è·¨æ¨¡å‹æŸ¥è¯¢è®¡åˆ’](#31-è·¨æ¨¡å‹æŸ¥è¯¢è®¡åˆ’)
    - [3.2. æŸ¥è¯¢ä¼˜åŒ–ç®—æ³•](#32-æŸ¥è¯¢ä¼˜åŒ–ç®—æ³•)
    - [3.3. è·¨æ¨¡å‹æŸ¥è¯¢æ‰§è¡Œ](#33-è·¨æ¨¡å‹æŸ¥è¯¢æ‰§è¡Œ)
  - [4. æ¨¡å‹é—´è½¬æ¢](#4-æ¨¡å‹é—´è½¬æ¢)
    - [4.1. è½¬æ¢è§„åˆ™](#41-è½¬æ¢è§„åˆ™)
    - [4.2. è½¬æ¢ç¤ºä¾‹](#42-è½¬æ¢ç¤ºä¾‹)
      - [4.2.1. å…³ç³»æ¨¡å‹åˆ°å›¾æ¨¡å‹è½¬æ¢](#421-å…³ç³»æ¨¡å‹åˆ°å›¾æ¨¡å‹è½¬æ¢)
      - [4.2.2. æ–‡æ¡£æ¨¡å‹åˆ°å…³ç³»æ¨¡å‹è½¬æ¢](#422-æ–‡æ¡£æ¨¡å‹åˆ°å…³ç³»æ¨¡å‹è½¬æ¢)
      - [4.2.3. è½¬æ¢æ­£ç¡®æ€§ä¿è¯](#423-è½¬æ¢æ­£ç¡®æ€§ä¿è¯)
  - [5. ç»Ÿä¸€æ¡†æ¶å®ç°](#5-ç»Ÿä¸€æ¡†æ¶å®ç°)
    - [5.1. æ¡†æ¶æ¶æ„](#51-æ¡†æ¶æ¶æ„)
    - [5.2. ç»Ÿä¸€æŸ¥è¯¢è¯­è¨€](#52-ç»Ÿä¸€æŸ¥è¯¢è¯­è¨€)
    - [5.3. ç»Ÿä¸€äº‹åŠ¡æ¨¡å‹](#53-ç»Ÿä¸€äº‹åŠ¡æ¨¡å‹)
  - [6. åº”ç”¨æ¡ˆä¾‹](#6-åº”ç”¨æ¡ˆä¾‹)
    - [6.1. PostgreSQLå¤šæ¨¡å‹åº”ç”¨](#61-postgresqlå¤šæ¨¡å‹åº”ç”¨)
    - [6.2. å¤šæ¨¡å‹æ•°æ®ä»“åº“](#62-å¤šæ¨¡å‹æ•°æ®ä»“åº“)
  - [7. è·¨æ¨¡å‹æŸ¥è¯¢ä¼˜åŒ–è¯¦ç»†åˆ†æ](#7-è·¨æ¨¡å‹æŸ¥è¯¢ä¼˜åŒ–è¯¦ç»†åˆ†æ)
    - [7.1. æŸ¥è¯¢åˆ†è§£ç­–ç•¥](#71-æŸ¥è¯¢åˆ†è§£ç­–ç•¥)
    - [7.2. æŸ¥è¯¢ä¼˜åŒ–è§„åˆ™](#72-æŸ¥è¯¢ä¼˜åŒ–è§„åˆ™)
    - [7.3. æŸ¥è¯¢ä»£ä»·ä¼°ç®—](#73-æŸ¥è¯¢ä»£ä»·ä¼°ç®—)
  - [8. 2025å¤šæ¨¡æ€ç»Ÿä¸€æ¡†æ¶](#8-2025å¤šæ¨¡æ€ç»Ÿä¸€æ¡†æ¶)
    - [8.1. PostgreSQLå¤šæ¨¡æ€ç»Ÿä¸€æ¶æ„](#81-postgresqlå¤šæ¨¡æ€ç»Ÿä¸€æ¶æ„)
    - [8.2. å¤šæ¨¡æ€ç»Ÿä¸€æŸ¥è¯¢](#82-å¤šæ¨¡æ€ç»Ÿä¸€æŸ¥è¯¢)
    - [8.3. 2025æ¨¡å‹å¯¹æ¯”çŸ©é˜µ](#83-2025æ¨¡å‹å¯¹æ¯”çŸ©é˜µ)
    - [8.4. ç»Ÿä¸€æ¡†æ¶æ¼”è¿›è·¯çº¿](#84-ç»Ÿä¸€æ¡†æ¶æ¼”è¿›è·¯çº¿)
  - [9. å‚è€ƒèµ„æ–™](#9-å‚è€ƒèµ„æ–™)
    - [9.1. é¡¹ç›®æ–‡æ¡£](#91-é¡¹ç›®æ–‡æ¡£)
    - [9.2. æŠ€æœ¯èµ„æº](#92-æŠ€æœ¯èµ„æº)

---

## 1. æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›ç»Ÿä¸€æ•°æ®æ¨¡å‹æ¡†æ¶ï¼Œå»ºç«‹å¤šæ¨¡å‹æ•°æ®åº“çš„ç»Ÿä¸€ç†è®ºæ¡†æ¶ï¼Œæ”¯æŒä¸åŒæ•°æ®æ¨¡å‹ä¹‹é—´çš„æ— ç¼é›†æˆå’ŒæŸ¥è¯¢ã€‚

---

## 2. ç»Ÿä¸€æ¡†æ¶å®šä¹‰

### 2.1. ç»Ÿä¸€æ•°æ®æ¨¡å‹æ¡†æ¶

**ç»Ÿä¸€æ¡†æ¶å®šä¹‰**ï¼š

```haskell
-- ç»Ÿä¸€æ•°æ®æ¨¡å‹æ¡†æ¶
data UnifiedDataModelFramework = UnifiedFramework {
    models :: [DataModel],
    mappings :: [ModelMapping],
    queries :: [UnifiedQuery],
    transactions :: [UnifiedTransaction]
}

-- ç»Ÿä¸€æŸ¥è¯¢æ¥å£
class UnifiedQueryInterface q where
    type Model q :: DataModelType
    type Result q :: *

    execute :: q -> Instance (Model q) -> Result q
    optimize :: q -> q
    validate :: q -> Bool
```

### 2.2. æ¨¡å‹æ³¨å†Œ

**æ¨¡å‹æ³¨å†Œ**ï¼š

```haskell
-- æ¨¡å‹æ³¨å†Œ
registerModel :: DataModel -> UnifiedFramework -> UnifiedFramework
registerModel model framework =
    framework {
        models = model : models framework,
        mappings = addMappings model (mappings framework)
    }
```

**æ¨¡å‹æ³¨å†Œç¤ºä¾‹**ï¼š

```haskell
-- æ³¨å†Œå…³ç³»æ¨¡å‹
relationalFramework = registerModel relationalModel emptyFramework

-- æ³¨å†Œæ–‡æ¡£æ¨¡å‹
documentFramework = registerModel documentModel relationalFramework

-- æ³¨å†Œå›¾æ¨¡å‹
graphFramework = registerModel graphModel documentFramework
```

### 2.3. ç»Ÿä¸€æ•°æ®æ¨¡å‹çš„å½¢å¼åŒ–å®šä¹‰

**ç»Ÿä¸€æ•°æ®æ¨¡å‹å®šä¹‰**ï¼š

```text
ç»Ÿä¸€æ•°æ®æ¨¡å‹ UDM = (S, O, Q, T) å…¶ä¸­ï¼š

- S: ç»Ÿä¸€æ¨¡å¼é›†åˆ
  S = {Schemaâ‚, Schemaâ‚‚, ..., Schemaâ‚™}
  æ¯ä¸ªSchemaáµ¢å¯¹åº”ä¸€ä¸ªæ•°æ®æ¨¡å‹

- O: ç»Ÿä¸€æ“ä½œé›†åˆ
  O = {opâ‚, opâ‚‚, ..., opâ‚˜}
  æ¯ä¸ªopâ±¼æ˜¯è·¨æ¨¡å‹æ“ä½œ

- Q: ç»Ÿä¸€æŸ¥è¯¢è¯­è¨€
  Q = {qâ‚, qâ‚‚, ..., qâ‚–}
  æ¯ä¸ªqáµ¢æ˜¯ç»Ÿä¸€æŸ¥è¯¢è¡¨è¾¾å¼

- T: ç»Ÿä¸€äº‹åŠ¡æ¨¡å‹
  T = (ACID, Isolation, Consistency)
  è·¨æ¨¡å‹äº‹åŠ¡ä¿è¯
```

**ç»Ÿä¸€æ•°æ®æ¨¡å‹æ€§è´¨**ï¼š

```text
å®šç†ï¼šç»Ÿä¸€æ•°æ®æ¨¡å‹æ¡†æ¶ä¿æŒå„æ¨¡å‹çš„æ€§è´¨

å¯¹äºç»Ÿä¸€æ¡†æ¶ UDM = (S, O, Q, T)ï¼š

1. æ¨¡å¼ä¿æŒæ€§ï¼š
   å¯¹äºæ¯ä¸ªæ¨¡å‹Máµ¢ï¼Œå­˜åœ¨Schemaáµ¢ âˆˆ S
   ä½¿å¾—Schemaáµ¢ä¿æŒMáµ¢çš„æ‰€æœ‰æ¨¡å¼æ€§è´¨

2. æ“ä½œä¿æŒæ€§ï¼š
   å¯¹äºæ¯ä¸ªæ¨¡å‹æ“ä½œopáµ¢ï¼Œå­˜åœ¨ç»Ÿä¸€æ“ä½œop' âˆˆ O
   ä½¿å¾—op'åœ¨è¯­ä¹‰ä¸Šç­‰ä»·äºopáµ¢

3. æŸ¥è¯¢ä¿æŒæ€§ï¼š
   å¯¹äºæ¯ä¸ªæ¨¡å‹æŸ¥è¯¢qáµ¢ï¼Œå­˜åœ¨ç»Ÿä¸€æŸ¥è¯¢q' âˆˆ Q
   ä½¿å¾—q'åœ¨è¯­ä¹‰ä¸Šç­‰ä»·äºqáµ¢

4. äº‹åŠ¡ä¿æŒæ€§ï¼š
   ç»Ÿä¸€äº‹åŠ¡æ¨¡å‹Tä¿è¯å„æ¨¡å‹çš„ACIDæ€§è´¨
```

---

## 3. è·¨æ¨¡å‹æŸ¥è¯¢ä¼˜åŒ–

### 3.1. è·¨æ¨¡å‹æŸ¥è¯¢è®¡åˆ’

**è·¨æ¨¡å‹æŸ¥è¯¢ä¼˜åŒ–**ï¼š

```text
è·¨æ¨¡å‹æŸ¥è¯¢ä¼˜åŒ–ï¼š
  1. è¯†åˆ«æ¶‰åŠçš„æ¨¡å‹
  2. é€‰æ‹©æœ€ä¼˜æ‰§è¡Œæ¨¡å‹
  3. ç”Ÿæˆæ¨¡å‹ç‰¹å®šæŸ¥è¯¢
  4. æ‰§è¡ŒæŸ¥è¯¢
  5. è½¬æ¢ç»“æœ
  6. åˆå¹¶ç»“æœ
```

### 3.2. æŸ¥è¯¢ä¼˜åŒ–ç®—æ³•

**ä¼˜åŒ–ç®—æ³•**ï¼š

```haskell
-- è·¨æ¨¡å‹æŸ¥è¯¢ä¼˜åŒ–
optimizeCrossModelQuery :: UnifiedQuery -> OptimizedQuery
optimizeCrossModelQuery query =
    let models = identifyModels query
        optimalModel = selectOptimalModel models
        modelQueries = generateModelQueries query optimalModel
    in OptimizedQuery {
        model = optimalModel,
        queries = modelQueries,
        resultTransformer = createResultTransformer query
    }
```

**æŸ¥è¯¢ä¼˜åŒ–ç­–ç•¥**ï¼š

```haskell
-- è¯†åˆ«æŸ¥è¯¢æ¶‰åŠçš„æ¨¡å‹
identifyModels :: UnifiedQuery -> [DataModel]
identifyModels query =
    extractModels (querySchema query)

-- é€‰æ‹©æœ€ä¼˜æ‰§è¡Œæ¨¡å‹
selectOptimalModel :: [DataModel] -> DataModel
selectOptimalModel models =
    -- é€‰æ‹©ä»£ä»·æœ€å°çš„æ¨¡å‹
    minimumBy (compare `on` estimateCost) models

-- ç”Ÿæˆæ¨¡å‹ç‰¹å®šæŸ¥è¯¢
generateModelQueries :: UnifiedQuery -> DataModel -> [ModelQuery]
generateModelQueries unifiedQuery targetModel =
    map (translateQuery targetModel) (queryComponents unifiedQuery)

-- åˆ›å»ºç»“æœè½¬æ¢å™¨
createResultTransformer :: UnifiedQuery -> ResultTransformer
createResultTransformer query =
    ResultTransformer {
        transform = \results -> mergeResults (querySchema query) results
    }
```

**æŸ¥è¯¢ä¼˜åŒ–ç¤ºä¾‹**ï¼š

```text
ç»Ÿä¸€æŸ¥è¯¢ï¼š
  SELECT user.name, order.total
  FROM users user
  JOIN orders order ON user.id = order.user_id
  WHERE user.age > 25

æ¶‰åŠæ¨¡å‹ï¼š
  - å…³ç³»æ¨¡å‹ï¼šusersè¡¨
  - å…³ç³»æ¨¡å‹ï¼šordersè¡¨

ä¼˜åŒ–ç­–ç•¥ï¼š
  1. è¯†åˆ«ä¸¤ä¸ªè¡¨éƒ½åœ¨å…³ç³»æ¨¡å‹ä¸­
  2. é€‰æ‹©å…³ç³»æ¨¡å‹ä½œä¸ºæ‰§è¡Œæ¨¡å‹
  3. ç”ŸæˆSQLæŸ¥è¯¢
  4. æ‰§è¡ŒæŸ¥è¯¢
  5. è¿”å›ç»“æœ
```

### 3.3. è·¨æ¨¡å‹æŸ¥è¯¢æ‰§è¡Œ

**æŸ¥è¯¢æ‰§è¡Œæµç¨‹**ï¼š

```haskell
-- è·¨æ¨¡å‹æŸ¥è¯¢æ‰§è¡Œ
executeCrossModelQuery :: UnifiedQuery -> Instance -> Result
executeCrossModelQuery query instance =
    let optimizedQuery = optimizeCrossModelQuery query
        modelInstances = partitionInstance instance (queryModels query)
        modelResults = map (executeModelQuery optimizedQuery) modelInstances
        unifiedResult = mergeResults modelResults
    in unifiedResult

-- æ‰§è¡Œæ¨¡å‹ç‰¹å®šæŸ¥è¯¢
executeModelQuery :: OptimizedQuery -> ModelInstance -> ModelResult
executeModelQuery optQuery modelInstance =
    execute (modelQuery optQuery) modelInstance

-- åˆå¹¶ç»“æœ
mergeResults :: [ModelResult] -> UnifiedResult
mergeResults results =
    foldl mergeResult emptyResult results
```

---

## 4. æ¨¡å‹é—´è½¬æ¢

### 4.1. è½¬æ¢è§„åˆ™

**è½¬æ¢è§„åˆ™å®šä¹‰**ï¼š

```haskell
-- æ¨¡å‹è½¬æ¢è§„åˆ™
data ConversionRule = ConversionRule {
    sourceModel :: DataModel,
    targetModel :: DataModel,
    transformation :: TransformationFunction
}

-- è½¬æ¢è§„åˆ™åº”ç”¨
applyConversion :: ConversionRule -> Instance -> Instance
applyConversion rule instance =
    transformation rule instance
```

### 4.2. è½¬æ¢ç¤ºä¾‹

#### 4.2.1. å…³ç³»æ¨¡å‹åˆ°å›¾æ¨¡å‹è½¬æ¢

**è½¬æ¢è§„åˆ™**ï¼š

```text
å…³ç³»æ¨¡å‹ï¼š
  Table: users (id, name)
  Table: follows (follower_id, followee_id)

å›¾æ¨¡å‹ï¼š
  Node: users (id, name)
  Edge: follows (follower -> followee)
```

**è½¬æ¢ç®—æ³•**ï¼š

```haskell
-- å…³ç³»æ¨¡å‹åˆ°å›¾æ¨¡å‹è½¬æ¢
relationalToGraph :: RelationalSchema -> GraphSchema
relationalToGraph relSchema =
    GraphSchema {
        nodeTypes = map tableToNodeType (tables relSchema),
        edgeTypes = map foreignKeyToEdgeType (foreignKeys relSchema)
    }

-- è¡¨åˆ°èŠ‚ç‚¹ç±»å‹
tableToNodeType :: Table -> NodeType
tableToNodeType table = NodeType {
    name = tableName table,
    properties = map fieldToProperty (tableFields table)
}

-- å¤–é”®åˆ°è¾¹ç±»å‹
foreignKeyToEdgeType :: ForeignKey -> EdgeType
foreignKeyToEdgeType fk = EdgeType {
    name = relationshipName fk,
    sourceNodeType = targetTable fk,
    targetNodeType = sourceTable fk,
    properties = []
}
```

#### 4.2.2. æ–‡æ¡£æ¨¡å‹åˆ°å…³ç³»æ¨¡å‹è½¬æ¢

**è½¬æ¢è§„åˆ™**ï¼š

```text
æ–‡æ¡£æ¨¡å‹ï¼š
  Collection: users {
    id, name, email,
    orders: [{
      id, total
    }]
  }

å…³ç³»æ¨¡å‹ï¼š
  Table: users (id, name, email)
  Table: orders (id, user_id, total)
  ForeignKey: orders.user_id -> users.id
```

**è½¬æ¢ç®—æ³•**ï¼š

```haskell
-- æ–‡æ¡£æ¨¡å‹åˆ°å…³ç³»æ¨¡å‹è½¬æ¢
documentToRelational :: DocumentSchema -> RelationalSchema
documentToRelational docSchema =
    RelationalSchema {
        tables = map collectionToTable (collections docSchema),
        foreignKeys = map embeddingToForeignKey (embeddings docSchema)
    }

-- é›†åˆåˆ°è¡¨
collectionToTable :: Collection -> Table
collectionToTable coll = Table {
    name = collectionName coll,
    fields = map propertyToField (properties coll),
    -- åµŒå…¥å­—æ®µè½¬æ¢ä¸ºå¤–é”®
    foreignKeys = []
}

-- åµŒå…¥åˆ°å¤–é”®
embeddingToForeignKey :: Embedding -> ForeignKey
embeddingToForeignKey emb = ForeignKey {
    sourceTable = targetCollection emb,
    targetTable = sourceCollection emb,
    sourceField = "id",
    targetField = embeddingName emb ++ "_id"
}
```

#### 4.2.3. è½¬æ¢æ­£ç¡®æ€§ä¿è¯

**è½¬æ¢æ­£ç¡®æ€§å®šç†**ï¼š

```text
å®šç†ï¼šæ¨¡å‹è½¬æ¢ä¿æŒæ•°æ®å®Œæ•´æ€§

å¯¹äºè½¬æ¢å‡½æ•° f: ModelA -> ModelBï¼š

1. æ•°æ®å®Œæ•´æ€§ï¼š
   å¯¹äºModelAä¸­çš„æ¯ä¸ªæ•°æ®å®ä¾‹Iï¼Œ
   f(I)åœ¨ModelBä¸­ä¿æŒIçš„æ‰€æœ‰æ•°æ®

2. æŸ¥è¯¢è¯­ä¹‰ç­‰ä»·ï¼š
   å¯¹äºModelAä¸­çš„æŸ¥è¯¢Qï¼Œ
   å­˜åœ¨ModelBä¸­çš„æŸ¥è¯¢Q'ä½¿å¾—ï¼š
   Q'(f(I)) = f(Q(I))

3. çº¦æŸä¿æŒï¼š
   å¯¹äºModelAä¸­çš„çº¦æŸCï¼Œ
   f(I)æ»¡è¶³f(C)å½“ä¸”ä»…å½“Iæ»¡è¶³C

è¯æ˜ï¼š
é€šè¿‡è½¬æ¢è§„åˆ™çš„ç»“æ„ä¿æŒæ€§è´¨å’Œè¯­ä¹‰ç­‰ä»·æ€§ç›´æ¥å¾—åˆ° âœ…
```

## 5. ç»Ÿä¸€æ¡†æ¶å®ç°

### 5.1. æ¡†æ¶æ¶æ„

**ç»Ÿä¸€æ¡†æ¶æ¶æ„**ï¼š

```text
ç»Ÿä¸€æ•°æ®æ¨¡å‹æ¡†æ¶æ¶æ„ï¼š

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     ç»Ÿä¸€æŸ¥è¯¢æ¥å£ (UnifiedQuery)      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ æŸ¥è¯¢è§£æ  â”‚  â”‚ æŸ¥è¯¢ä¼˜åŒ–  â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     æ¨¡å‹é€‚é…å±‚ (ModelAdapter)       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚å…³ç³»æ¨¡å‹â”‚  â”‚æ–‡æ¡£æ¨¡å‹â”‚  â”‚å›¾æ¨¡å‹â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     è½¬æ¢å±‚ (Transformation)         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚æ¨¡å¼è½¬æ¢   â”‚  â”‚æ•°æ®è½¬æ¢   â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     å­˜å‚¨å±‚ (Storage)                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚PostgreSQLâ”‚ â”‚MongoDBâ”‚ â”‚Neo4jâ”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”˜      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.2. ç»Ÿä¸€æŸ¥è¯¢è¯­è¨€

**ç»Ÿä¸€æŸ¥è¯¢è¯­è¨€å®šä¹‰**ï¼š

```haskell
-- ç»Ÿä¸€æŸ¥è¯¢è¯­è¨€è¯­æ³•
data UnifiedQuery =
    SelectQuery {
        select :: [Expression],
        from :: [TableRef],
        where_ :: Maybe Condition,
        join :: [JoinClause]
    }
  | UnionQuery {
        left :: UnifiedQuery,
        right :: UnifiedQuery
    }
  | CrossModelQuery {
        models :: [DataModel],
        query :: UnifiedQuery
    }

-- è¡¨å¼•ç”¨ï¼ˆå¯ä»¥æ˜¯ä¸åŒæ¨¡å‹çš„è¡¨ï¼‰
data TableRef =
    RelationalTable String
  | DocumentCollection String
  | GraphNodeType String
  | VectorIndex String
```

**ç»Ÿä¸€æŸ¥è¯¢ç¤ºä¾‹**ï¼š

```text
è·¨æ¨¡å‹æŸ¥è¯¢ç¤ºä¾‹ï¼š

SELECT user.name, order.total, graph.friends
FROM relational.users user
JOIN relational.orders order ON user.id = order.user_id
JOIN graph.friends graph ON user.id = graph.user_id
WHERE user.age > 25

è¿™ä¸ªæŸ¥è¯¢æ¶‰åŠï¼š
- å…³ç³»æ¨¡å‹ï¼šusersè¡¨ã€ordersè¡¨
- å›¾æ¨¡å‹ï¼šfriendså…³ç³»

ç»Ÿä¸€æ¡†æ¶ä¼šï¼š
1. è¯†åˆ«æ¶‰åŠçš„æ¨¡å‹
2. ç”Ÿæˆå„æ¨¡å‹çš„å­æŸ¥è¯¢
3. æ‰§è¡Œå­æŸ¥è¯¢
4. åˆå¹¶ç»“æœ
```

### 5.3. ç»Ÿä¸€äº‹åŠ¡æ¨¡å‹

**ç»Ÿä¸€äº‹åŠ¡å®šä¹‰**ï¼š

```haskell
-- ç»Ÿä¸€äº‹åŠ¡
data UnifiedTransaction = UnifiedTransaction {
    operations :: [UnifiedOperation],
    isolation :: IsolationLevel,
    consistency :: ConsistencyLevel
}

-- ç»Ÿä¸€æ“ä½œ
data UnifiedOperation =
    RelationalOp RelationalOperation
  | DocumentOp DocumentOperation
  | GraphOp GraphOperation
  | CrossModelOp CrossModelOperation

-- ç»Ÿä¸€äº‹åŠ¡æ‰§è¡Œ
executeUnifiedTransaction :: UnifiedTransaction -> TransactionResult
executeUnifiedTransaction trans =
    -- ä¸¤é˜¶æ®µæäº¤
    let prepareResult = map prepareOperation (operations trans)
        commitResult = if all isPrepared prepareResult
                      then map commitOperation (operations trans)
                      else map abortOperation (operations trans)
    in TransactionResult commitResult
```

**ç»Ÿä¸€äº‹åŠ¡ä¿è¯**ï¼š

```text
ç»Ÿä¸€äº‹åŠ¡æ¨¡å‹ä¿è¯ï¼š

1. åŸå­æ€§ï¼ˆAtomicityï¼‰ï¼š
   è·¨æ¨¡å‹æ“ä½œè¦ä¹ˆå…¨éƒ¨æˆåŠŸï¼Œè¦ä¹ˆå…¨éƒ¨å›æ»š

2. ä¸€è‡´æ€§ï¼ˆConsistencyï¼‰ï¼š
   è·¨æ¨¡å‹æ•°æ®ä¿æŒä¸€è‡´çŠ¶æ€

3. éš”ç¦»æ€§ï¼ˆIsolationï¼‰ï¼š
   å¹¶å‘äº‹åŠ¡äº’ä¸å¹²æ‰°

4. æŒä¹…æ€§ï¼ˆDurabilityï¼‰ï¼š
   æäº¤çš„äº‹åŠ¡æŒä¹…ä¿å­˜
```

---

## 6. åº”ç”¨æ¡ˆä¾‹

### 6.1. PostgreSQLå¤šæ¨¡å‹åº”ç”¨

**PostgreSQLç»Ÿä¸€æ¡†æ¶å®ç°**ï¼š

```text
PostgreSQLç»Ÿä¸€æ•°æ®æ¨¡å‹æ¡†æ¶ï¼š

1. å…³ç³»æ¨¡å‹ï¼šåŸç”Ÿæ”¯æŒ
   - è¡¨ã€è§†å›¾ã€ç´¢å¼•

2. æ–‡æ¡£æ¨¡å‹ï¼šJSONBæ”¯æŒ
   - JSONBåˆ—ã€JSONBç´¢å¼•ã€JSONBæŸ¥è¯¢

3. å›¾æ¨¡å‹ï¼šApache AGEæ‰©å±•
   - CypheræŸ¥è¯¢ã€å›¾éå†ã€å›¾ç®—æ³•

4. å‘é‡æ¨¡å‹ï¼špgvectoræ‰©å±•
   - å‘é‡å­˜å‚¨ã€å‘é‡ç´¢å¼•ã€ç›¸ä¼¼åº¦æœç´¢

5. æ—¶åºæ¨¡å‹ï¼šTimescaleDBæ‰©å±•
   - è¶…è¡¨ã€è¿ç»­èšåˆã€æ—¶é—´åˆ†åŒº

ç»Ÿä¸€æŸ¥è¯¢ç¤ºä¾‹ï¼š
  SELECT u.name, u.orders, v.embedding
  FROM users u
  JOIN vector_embeddings v ON u.id = v.user_id
  WHERE v.embedding <-> query_vector < 0.5
```

### 6.2. å¤šæ¨¡å‹æ•°æ®ä»“åº“

**æ•°æ®ä»“åº“ç»Ÿä¸€æ¡†æ¶**ï¼š

```text
å¤šæ¨¡å‹æ•°æ®ä»“åº“æ¶æ„ï¼š

1. å…³ç³»æ¨¡å‹ï¼šäº‹å®è¡¨å’Œç»´åº¦è¡¨
2. åˆ—å¼æ¨¡å‹ï¼šåˆ†ææŸ¥è¯¢ä¼˜åŒ–
3. æ—¶åºæ¨¡å‹ï¼šæ—¶é—´åºåˆ—æ•°æ®
4. å‘é‡æ¨¡å‹ï¼šç›¸ä¼¼åº¦åˆ†æ

ç»Ÿä¸€æŸ¥è¯¢ï¼š
  SELECT fact.sales, dim.product_name, ts.timestamp, vec.similarity
  FROM relational.facts fact
  JOIN relational.dimensions dim ON fact.product_id = dim.id
  JOIN timeseries.metrics ts ON fact.id = ts.fact_id
  JOIN vector.similarities vec ON dim.id = vec.product_id
  WHERE ts.timestamp > '2024-01-01'
    AND vec.similarity > 0.8
```

---

## 7. è·¨æ¨¡å‹æŸ¥è¯¢ä¼˜åŒ–è¯¦ç»†åˆ†æ

### 7.1. æŸ¥è¯¢åˆ†è§£ç­–ç•¥

**æŸ¥è¯¢åˆ†è§£ç®—æ³•**ï¼š

```haskell
-- æŸ¥è¯¢åˆ†è§£
decomposeQuery :: UnifiedQuery -> [ModelSpecificQuery]
decomposeQuery query =
    let modelQueries = groupByModel (extractModelQueries query)
        optimizedQueries = map optimizeModelQuery modelQueries
    in optimizedQueries

-- æŒ‰æ¨¡å‹åˆ†ç»„
groupByModel :: [Query] -> Map Model [Query]
groupByModel queries =
    foldl addToModel empty queries
    where
        addToModel acc query =
            insertWith (++) (getModel query) [query] acc
```

**æŸ¥è¯¢åˆ†è§£å†³ç­–æ ‘**ï¼š

```mermaid
flowchart TD
    A[ç»Ÿä¸€æŸ¥è¯¢] --> B{æ¶‰åŠæ¨¡å‹æ•°é‡}

    B -->|å•æ¨¡å‹| C[å•æ¨¡å‹æŸ¥è¯¢]
    B -->|å¤šæ¨¡å‹| D[è·¨æ¨¡å‹æŸ¥è¯¢]

    C --> E[ç›´æ¥æ‰§è¡Œ]

    D --> F{æŸ¥è¯¢ç±»å‹}
    F -->|JOIN| G[åˆ†è§£ä¸ºå­æŸ¥è¯¢+JOIN]
    F -->|UNION| H[åˆ†è§£ä¸ºå­æŸ¥è¯¢+UNION]
    F -->|åµŒå¥—æŸ¥è¯¢| I[é€’å½’åˆ†è§£]

    G --> J[ä¼˜åŒ–å„å­æŸ¥è¯¢]
    H --> J
    I --> J

    J --> K[åˆå¹¶ç»“æœ]
```

### 7.2. æŸ¥è¯¢ä¼˜åŒ–è§„åˆ™

**è·¨æ¨¡å‹æŸ¥è¯¢ä¼˜åŒ–è§„åˆ™**ï¼š

```haskell
-- æŸ¥è¯¢ä¼˜åŒ–è§„åˆ™
data OptimizationRule =
    PushDownFilter FilterCondition
  | PushDownProjection [Attribute]
  | ReorderJoins [JoinOrder]
  | UseIndex IndexHint

-- åº”ç”¨ä¼˜åŒ–è§„åˆ™
applyOptimizationRules :: [OptimizationRule] -> UnifiedQuery -> UnifiedQuery
applyOptimizationRules rules query =
    foldl applyRule query rules

-- ä¸‹æ¨è¿‡æ»¤æ¡ä»¶
pushDownFilter :: FilterCondition -> UnifiedQuery -> UnifiedQuery
pushDownFilter condition query =
    query {
        where_ = combineConditions (where_ query) condition,
        from = map (addFilterToTable condition) (from query)
    }
```

**ä¼˜åŒ–è§„åˆ™åº”ç”¨çŸ©é˜µ**ï¼š

| ä¼˜åŒ–è§„åˆ™ | å…³ç³»æ¨¡å‹ | æ–‡æ¡£æ¨¡å‹ | å›¾æ¨¡å‹ | å‘é‡æ¨¡å‹ | æ—¶åºæ¨¡å‹ |
|---------|---------|---------|--------|---------|---------|
| **ä¸‹æ¨è¿‡æ»¤** | â­â­â­â­â­ | â­â­â­â­ | â­â­â­ | â­â­â­â­ | â­â­â­â­â­ |
| **ä¸‹æ¨æŠ•å½±** | â­â­â­â­â­ | â­â­â­â­ | â­â­â­ | â­â­â­ | â­â­â­â­ |
| **é‡æ’åºJOIN** | â­â­â­â­â­ | â­â­â­ | â­â­ | â­â­ | â­â­â­ |
| **ä½¿ç”¨ç´¢å¼•** | â­â­â­â­â­ | â­â­â­â­ | â­â­â­â­ | â­â­â­â­â­ | â­â­â­â­ |

### 7.3. æŸ¥è¯¢ä»£ä»·ä¼°ç®—

**è·¨æ¨¡å‹æŸ¥è¯¢ä»£ä»·æ¨¡å‹**ï¼š

```haskell
-- æŸ¥è¯¢ä»£ä»·
data QueryCost = QueryCost {
    ioCost :: Double,
    cpuCost :: Double,
    networkCost :: Double,
    totalCost :: Double
}

-- ä¼°ç®—æŸ¥è¯¢ä»£ä»·
estimateQueryCost :: UnifiedQuery -> QueryCost
estimateQueryCost query =
    let subQueries = decomposeQuery query
        subCosts = map estimateSubQueryCost subQueries
        mergeCost = estimateMergeCost query
    in sumCosts subCosts + mergeCost

-- ä¼°ç®—å­æŸ¥è¯¢ä»£ä»·
estimateSubQueryCost :: ModelSpecificQuery -> QueryCost
estimateSubQueryCost query =
    case getModel query of
        RelationalModel -> estimateRelationalCost query
        DocumentModel -> estimateDocumentCost query
        GraphModel -> estimateGraphCost query
        VectorModel -> estimateVectorCost query
        TimeSeriesModel -> estimateTimeSeriesCost query
```

**ä»£ä»·ä¼°ç®—å…¬å¼**ï¼š

```text
è·¨æ¨¡å‹æŸ¥è¯¢æ€»ä»£ä»·ï¼š

Cost(Q) = Î£áµ¢ Cost(Qáµ¢) + Cost(Merge)

å…¶ä¸­ï¼š
- Cost(Qáµ¢) æ˜¯ç¬¬iä¸ªå­æŸ¥è¯¢çš„ä»£ä»·
- Cost(Merge) æ˜¯ç»“æœåˆå¹¶çš„ä»£ä»·

å­æŸ¥è¯¢ä»£ä»·ï¼š

Cost(Qáµ¢) = IO_Cost(Qáµ¢) + CPU_Cost(Qáµ¢) + Network_Cost(Qáµ¢)

åˆå¹¶ä»£ä»·ï¼š

Cost(Merge) =
    if JOIN then Cost(Join) + Cost(Filter)
    else if UNION then Cost(Union)
    else 0
```

---

## 8. 2025å¤šæ¨¡æ€ç»Ÿä¸€æ¡†æ¶

### 8.1. PostgreSQLå¤šæ¨¡æ€ç»Ÿä¸€æ¶æ„

**ç»Ÿä¸€å­˜å‚¨æ¶æ„**ï¼š

```mermaid
flowchart TB
    subgraph Client["å®¢æˆ·ç«¯å±‚"]
        SQL[SQLå®¢æˆ·ç«¯]
        API[REST API]
        SDK[SDK]
    end

    subgraph Query["ç»Ÿä¸€æŸ¥è¯¢å±‚"]
        Parser[SQLè§£æå™¨]
        Planner[æŸ¥è¯¢è®¡åˆ’å™¨]
        Executor[æ‰§è¡Œå™¨]
    end

    subgraph Storage["å¤šæ¨¡æ€å­˜å‚¨å±‚"]
        Rel[(å…³ç³»è¡¨)]
        Vec[(å‘é‡åˆ—)]
        Graph[(å›¾æ‰©å±•)]
        TS[(æ—¶åºè¡¨)]
        Doc[(JSONB)]
    end

    SQL --> Parser
    API --> Parser
    SDK --> Parser

    Parser --> Planner
    Planner --> Executor

    Executor --> Rel
    Executor --> Vec
    Executor --> Graph
    Executor --> TS
    Executor --> Doc
```

**ç»Ÿä¸€Schemaè®¾è®¡**ï¼š

```sql
-- 2025å¤šæ¨¡æ€ç»Ÿä¸€Schema
CREATE TABLE unified_knowledge_base (
    -- æ ¸å¿ƒæ ‡è¯†
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    -- å…³ç³»æ¨¡å‹
    category_id INTEGER REFERENCES categories(id),
    tags TEXT[],

    -- æ–‡æ¡£æ¨¡å‹ (JSONB)
    metadata JSONB NOT NULL DEFAULT '{}',
    content_structured JSONB,

    -- å‘é‡æ¨¡å‹ (pgvector)
    embedding vector(1536),

    -- æ—¶åºæ¨¡å‹ (TimescaleDB)
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),

    -- å›¾æ¨¡å‹é¢„ç•™ (Apache AGE)
    graph_node_id BIGINT,

    -- å…¨æ–‡æœç´¢
    tsv tsvector GENERATED ALWAYS AS (
        to_tsvector('chinese', COALESCE(metadata->>'title', '') || ' ' ||
                              COALESCE(metadata->>'content', ''))
    ) STORED
);

-- å¤šæ¨¡æ€ç´¢å¼•
CREATE INDEX idx_unified_embedding ON unified_knowledge_base
USING hnsw (embedding vector_cosine_ops);

CREATE INDEX idx_unified_category ON unified_knowledge_base(category_id);

CREATE INDEX idx_unified_metadata ON unified_knowledge_base
USING gin (metadata jsonb_path_ops);

CREATE INDEX idx_unified_tsv ON unified_knowledge_base
USING gin (tsv);

CREATE INDEX idx_unified_time ON unified_knowledge_base(created_at DESC);
```

### 8.2. å¤šæ¨¡æ€ç»Ÿä¸€æŸ¥è¯¢

**ç»Ÿä¸€æŸ¥è¯¢å‡½æ•°**ï¼š

```sql
-- å¤šæ¨¡æ€ç»Ÿä¸€æŸ¥è¯¢
CREATE OR REPLACE FUNCTION unified_search(
    query_text TEXT,
    query_embedding vector(1536),
    category_filter INTEGER DEFAULT NULL,
    time_start TIMESTAMPTZ DEFAULT NULL,
    time_end TIMESTAMPTZ DEFAULT NULL,
    search_mode TEXT DEFAULT 'hybrid',  -- 'vector', 'keyword', 'hybrid'
    limit_n INTEGER DEFAULT 10
) RETURNS TABLE (
    id UUID,
    metadata JSONB,
    score FLOAT,
    match_type TEXT
) AS $$
BEGIN
    RETURN QUERY
    WITH
    -- å‘é‡æ£€ç´¢
    vector_results AS (
        SELECT
            k.id,
            k.metadata,
            1 - (k.embedding <=> query_embedding) AS score,
            'vector'::TEXT AS match_type
        FROM unified_knowledge_base k
        WHERE
            (category_filter IS NULL OR k.category_id = category_filter)
            AND (time_start IS NULL OR k.created_at >= time_start)
            AND (time_end IS NULL OR k.created_at <= time_end)
            AND search_mode IN ('vector', 'hybrid')
        ORDER BY k.embedding <=> query_embedding
        LIMIT limit_n * 2
    ),
    -- å…³é”®è¯æ£€ç´¢
    keyword_results AS (
        SELECT
            k.id,
            k.metadata,
            ts_rank_cd(k.tsv, plainto_tsquery('chinese', query_text))::FLOAT AS score,
            'keyword'::TEXT AS match_type
        FROM unified_knowledge_base k
        WHERE
            k.tsv @@ plainto_tsquery('chinese', query_text)
            AND (category_filter IS NULL OR k.category_id = category_filter)
            AND (time_start IS NULL OR k.created_at >= time_start)
            AND (time_end IS NULL OR k.created_at <= time_end)
            AND search_mode IN ('keyword', 'hybrid')
        ORDER BY ts_rank_cd(k.tsv, plainto_tsquery('chinese', query_text)) DESC
        LIMIT limit_n * 2
    ),
    -- RRFèåˆ
    fused_results AS (
        SELECT
            COALESCE(v.id, k.id) AS id,
            COALESCE(v.metadata, k.metadata) AS metadata,
            COALESCE(1.0 / (60 + ROW_NUMBER() OVER (ORDER BY v.score DESC NULLS LAST)), 0) +
            COALESCE(1.0 / (60 + ROW_NUMBER() OVER (ORDER BY k.score DESC NULLS LAST)), 0) AS score,
            CASE
                WHEN v.id IS NOT NULL AND k.id IS NOT NULL THEN 'hybrid'
                WHEN v.id IS NOT NULL THEN 'vector'
                ELSE 'keyword'
            END AS match_type
        FROM vector_results v
        FULL OUTER JOIN keyword_results k ON v.id = k.id
    )
    SELECT * FROM fused_results
    ORDER BY score DESC
    LIMIT limit_n;
END;
$$ LANGUAGE plpgsql;
```

### 8.3. 2025æ¨¡å‹å¯¹æ¯”çŸ©é˜µ

| æ¨¡å‹ç±»å‹ | PostgreSQLå®ç° | ç´¢å¼•ç±»å‹ | æŸ¥è¯¢è¯­æ³• | å…¸å‹åœºæ™¯ |
|---------|---------------|---------|---------|---------|
| **å…³ç³»æ¨¡å‹** | åŸç”Ÿè¡¨ | B-tree, Hash | SQL | äº‹åŠ¡å¤„ç† |
| **æ–‡æ¡£æ¨¡å‹** | JSONB | GIN | `->`, `->>`, `@>` | çµæ´»Schema |
| **å‘é‡æ¨¡å‹** | pgvector | HNSW, IVFFlat | `<->`, `<=>` | è¯­ä¹‰æœç´¢ |
| **å›¾æ¨¡å‹** | Apache AGE | å›¾ç´¢å¼• | Cypher | å…³ç³»åˆ†æ |
| **æ—¶åºæ¨¡å‹** | TimescaleDB | æ—¶é—´ç´¢å¼• | SQL + è¿ç»­èšåˆ | IoTç›‘æ§ |
| **å…¨æ–‡æ¨¡å‹** | tsvector | GIN | `@@` | æ–‡æœ¬æœç´¢ |

### 8.4. ç»Ÿä¸€æ¡†æ¶æ¼”è¿›è·¯çº¿

```mermaid
timeline
    title å¤šæ¨¡æ€æ•°æ®åº“æ¼”è¿›
    2020 : PostgreSQL 13
         : JSONBæˆç†Ÿ
    2022 : pgvectorå‘å¸ƒ
         : å‘é‡æ£€ç´¢
    2023 : PostgreSQL 16
         : å¹¶è¡ŒæŸ¥è¯¢å¢å¼º
    2024 : pgvector 0.7
         : HNSWä¼˜åŒ–
         : æ··åˆæ£€ç´¢
    2025 : PostgreSQL 17
         : ç»Ÿä¸€å¤šæ¨¡æ€
         : AIåŸç”Ÿ
```

---

## 9. å‚è€ƒèµ„æ–™

### 9.1. é¡¹ç›®æ–‡æ¡£

- [æ•°æ®åº“è®¾è®¡ç†è®ºæ‰©å±•è®¡åˆ’](../00-æ•°æ®åº“è®¾è®¡ç†è®ºæ‰©å±•è®¡åˆ’.md)
- [å¤šæ¨¡å‹æ•°æ®åº“ç†è®º](../01-ç†è®ºæ¨¡å‹/01.03-å¤šæ¨¡å‹æ•°æ®åº“ç†è®º.md)
- [æ•°æ®æ¨¡å‹èŒƒç•´è®ºè¡¨ç¤º](./06.01-æ•°æ®æ¨¡å‹èŒƒç•´è®ºè¡¨ç¤º.md)
- [å‘é‡æ•°æ®åº“è®¾è®¡](../07-æ•°æ®åº“è®¾è®¡å®è·µ/07.10-å‘é‡æ•°æ®åº“è®¾è®¡.md)

### 9.2. æŠ€æœ¯èµ„æº

- [PostgreSQLå®˜æ–¹æ–‡æ¡£](https://www.postgresql.org/docs/)
- [pgvector GitHub](https://github.com/pgvector/pgvector)
- [TimescaleDBæ–‡æ¡£](https://docs.timescale.com/)

---

**æœ€åæ›´æ–°**ï¼š2025-12-01
**ç»´æŠ¤è€…**ï¼šData-Science Team
**çŠ¶æ€**ï¼šå·²å®Œæˆ âœ…
