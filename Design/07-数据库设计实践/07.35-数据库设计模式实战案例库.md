# æ•°æ®åº“è®¾è®¡æ¨¡å¼å®æˆ˜æ¡ˆä¾‹åº“ï¼šçœŸå®åœºæ™¯ä¸è§£å†³æ–¹æ¡ˆ

> **åˆ›å»ºæ—¥æœŸ**ï¼š2025-01-15
> **æœ€åæ›´æ–°**ï¼š2025-01-15
> **ç‰ˆæœ¬**ï¼šv1.0
> **çŠ¶æ€**ï¼šå®æ–½ä¸­

---

## ğŸ“‹ ç›®å½•

- [æ•°æ®åº“è®¾è®¡æ¨¡å¼å®æˆ˜æ¡ˆä¾‹åº“ï¼šçœŸå®åœºæ™¯ä¸è§£å†³æ–¹æ¡ˆ](#æ•°æ®åº“è®¾è®¡æ¨¡å¼å®æˆ˜æ¡ˆä¾‹åº“çœŸå®åœºæ™¯ä¸è§£å†³æ–¹æ¡ˆ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1. æ¡ˆä¾‹åˆ†ç±»](#11-æ¡ˆä¾‹åˆ†ç±»)
  - [2. ç”µå•†å¹³å°æ¡ˆä¾‹](#2-ç”µå•†å¹³å°æ¡ˆä¾‹)
    - [2.1. åœºæ™¯æè¿°](#21-åœºæ™¯æè¿°)
    - [2.2. è®¾è®¡æ–¹æ¡ˆ](#22-è®¾è®¡æ–¹æ¡ˆ)
    - [2.3. æ ¸å¿ƒåŠŸèƒ½å®ç°](#23-æ ¸å¿ƒåŠŸèƒ½å®ç°)
  - [3. ç¤¾äº¤ç½‘ç»œæ¡ˆä¾‹](#3-ç¤¾äº¤ç½‘ç»œæ¡ˆä¾‹)
    - [3.1. åœºæ™¯æè¿°](#31-åœºæ™¯æè¿°)
    - [3.2. è®¾è®¡æ–¹æ¡ˆ](#32-è®¾è®¡æ–¹æ¡ˆ)
    - [3.3. æ ¸å¿ƒåŠŸèƒ½å®ç°](#33-æ ¸å¿ƒåŠŸèƒ½å®ç°)
  - [4. é‡‘èæ”¯ä»˜æ¡ˆä¾‹](#4-é‡‘èæ”¯ä»˜æ¡ˆä¾‹)
    - [4.1. åœºæ™¯æè¿°](#41-åœºæ™¯æè¿°)
    - [4.2. è®¾è®¡æ–¹æ¡ˆ](#42-è®¾è®¡æ–¹æ¡ˆ)
    - [4.3. æ ¸å¿ƒåŠŸèƒ½å®ç°](#43-æ ¸å¿ƒåŠŸèƒ½å®ç°)
  - [5. å†…å®¹ç®¡ç†æ¡ˆä¾‹](#5-å†…å®¹ç®¡ç†æ¡ˆä¾‹)
    - [5.1. åœºæ™¯æè¿°](#51-åœºæ™¯æè¿°)
    - [5.2. è®¾è®¡æ–¹æ¡ˆ](#52-è®¾è®¡æ–¹æ¡ˆ)
    - [5.3. æ ¸å¿ƒåŠŸèƒ½å®ç°](#53-æ ¸å¿ƒåŠŸèƒ½å®ç°)
  - [6. IoTç›‘æ§æ¡ˆä¾‹](#6-iotç›‘æ§æ¡ˆä¾‹)
    - [6.1. åœºæ™¯æè¿°](#61-åœºæ™¯æè¿°)
    - [6.2. è®¾è®¡æ–¹æ¡ˆ](#62-è®¾è®¡æ–¹æ¡ˆ)
    - [6.3. æ ¸å¿ƒåŠŸèƒ½å®ç°](#63-æ ¸å¿ƒåŠŸèƒ½å®ç°)
  - [7. æ¨èç³»ç»Ÿæ¡ˆä¾‹](#7-æ¨èç³»ç»Ÿæ¡ˆä¾‹)
    - [7.1. åœºæ™¯æè¿°](#71-åœºæ™¯æè¿°)
    - [7.2. è®¾è®¡æ–¹æ¡ˆ](#72-è®¾è®¡æ–¹æ¡ˆ)
    - [7.3. æ ¸å¿ƒåŠŸèƒ½å®ç°](#73-æ ¸å¿ƒåŠŸèƒ½å®ç°)
  - [8. ä¼ä¸šçŸ¥è¯†åº“æ¡ˆä¾‹](#8-ä¼ä¸šçŸ¥è¯†åº“æ¡ˆä¾‹)
    - [8.1. åœºæ™¯æè¿°](#81-åœºæ™¯æè¿°)
    - [8.2. è®¾è®¡æ–¹æ¡ˆ](#82-è®¾è®¡æ–¹æ¡ˆ)
    - [8.3. æ ¸å¿ƒåŠŸèƒ½å®ç°](#83-æ ¸å¿ƒåŠŸèƒ½å®ç°)
  - [9. å¤šç§Ÿæˆ·SaaSæ¡ˆä¾‹](#9-å¤šç§Ÿæˆ·saasæ¡ˆä¾‹)
    - [9.1. åœºæ™¯æè¿°](#91-åœºæ™¯æè¿°)
    - [9.2. è®¾è®¡æ–¹æ¡ˆ](#92-è®¾è®¡æ–¹æ¡ˆ)
    - [9.3. æ ¸å¿ƒåŠŸèƒ½å®ç°](#93-æ ¸å¿ƒåŠŸèƒ½å®ç°)
  - [10. å®æ—¶åˆ†ææ¡ˆä¾‹](#10-å®æ—¶åˆ†ææ¡ˆä¾‹)
    - [10.1. åœºæ™¯æè¿°](#101-åœºæ™¯æè¿°)
    - [10.2. è®¾è®¡æ–¹æ¡ˆ](#102-è®¾è®¡æ–¹æ¡ˆ)
    - [10.3. æ ¸å¿ƒåŠŸèƒ½å®ç°](#103-æ ¸å¿ƒåŠŸèƒ½å®ç°)
  - [11. å‚è€ƒèµ„æ–™](#11-å‚è€ƒèµ„æ–™)

---

## 1. æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›æ•°æ®åº“è®¾è®¡æ¨¡å¼çš„å®æˆ˜æ¡ˆä¾‹åº“ï¼ŒåŒ…å«çœŸå®åœºæ™¯å’Œè§£å†³æ–¹æ¡ˆã€‚

### 1.1. æ¡ˆä¾‹åˆ†ç±»

```mermaid
mindmap
  root((å®æˆ˜æ¡ˆä¾‹åº“))
    ç”µå•†å¹³å°
      è®¢å•ç³»ç»Ÿ
      å•†å“ç®¡ç†
      åº“å­˜ç®¡ç†
    ç¤¾äº¤ç½‘ç»œ
      ç”¨æˆ·å…³ç³»
      å†…å®¹å‘å¸ƒ
      æ¶ˆæ¯ç³»ç»Ÿ
    é‡‘èæ”¯ä»˜
      æ”¯ä»˜å¤„ç†
      è´¦æˆ·ç®¡ç†
      äº¤æ˜“è®°å½•
    å†…å®¹ç®¡ç†
      æ–‡ç« ç³»ç»Ÿ
      åª’ä½“ç®¡ç†
      æ ‡ç­¾ç³»ç»Ÿ
    IoTç›‘æ§
      è®¾å¤‡ç®¡ç†
      æ•°æ®é‡‡é›†
      å‘Šè­¦ç³»ç»Ÿ
    æ¨èç³»ç»Ÿ
      ç”¨æˆ·ç”»åƒ
      ç‰©å“ç‰¹å¾
      æ¨èç®—æ³•
    ä¼ä¸šçŸ¥è¯†åº“
      çŸ¥è¯†å›¾è°±
      æ–‡æ¡£ç®¡ç†
      æœç´¢ç³»ç»Ÿ
    å¤šç§Ÿæˆ·SaaS
      ç§Ÿæˆ·éš”ç¦»
      èµ„æºç®¡ç†
      æ•°æ®å®‰å…¨
    å®æ—¶åˆ†æ
      æ•°æ®ä»“åº“
      å®æ—¶è®¡ç®—
      æŠ¥è¡¨ç³»ç»Ÿ
```

---

## 2. ç”µå•†å¹³å°æ¡ˆä¾‹

### 2.1. åœºæ™¯æè¿°

**ä¸šåŠ¡éœ€æ±‚**ï¼š

- æ”¯æŒåƒä¸‡çº§ç”¨æˆ·
- æ—¥è®¢å•é‡ç™¾ä¸‡çº§
- å•†å“SKUç™¾ä¸‡çº§
- å®æ—¶åº“å­˜ç®¡ç†
- è®¢å•çŠ¶æ€è¿½è¸ª
- æ”¯ä»˜æµç¨‹å®Œæ•´

### 2.2. è®¾è®¡æ–¹æ¡ˆ

**æ ¸å¿ƒè¡¨ç»“æ„**ï¼š

```sql
-- ç”¨æˆ·è¡¨ï¼ˆåˆ†è¡¨ï¼‰
CREATE TABLE user_domain.users_0 (
    user_id BIGSERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL UNIQUE,
    phone VARCHAR(20),
    password_hash TEXT NOT NULL,
    status VARCHAR(20) DEFAULT 'active',
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
) PARTITION BY HASH (user_id);

-- å•†å“è¡¨ï¼ˆåˆ†è¡¨ï¼‰
CREATE TABLE product_domain.products (
    product_id BIGSERIAL PRIMARY KEY,
    product_name VARCHAR(200) NOT NULL,
    category_id INTEGER NOT NULL,
    price DECIMAL(12, 2) NOT NULL,
    stock INTEGER NOT NULL DEFAULT 0,
    sales_count INTEGER DEFAULT 0,
    status VARCHAR(20) DEFAULT 'active',
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
) PARTITION BY HASH (product_id);

-- è®¢å•è¡¨ï¼ˆæŒ‰æœˆåˆ†åŒºï¼‰
CREATE TABLE order_domain.orders (
    order_id BIGINT PRIMARY KEY,
    user_id BIGINT NOT NULL,
    order_sn VARCHAR(64) UNIQUE NOT NULL,
    total_amount DECIMAL(12, 2) NOT NULL,
    actual_payment DECIMAL(12, 2) NOT NULL,
    payment_status VARCHAR(20) DEFAULT 'pending',
    order_status VARCHAR(20) DEFAULT 'created',
    shipping_address JSONB,
    payment_method VARCHAR(50),
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    payment_at TIMESTAMPTZ,
    shipped_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ
) PARTITION BY RANGE (created_at);

-- è®¢å•æ˜ç»†è¡¨
CREATE TABLE order_domain.order_items (
    item_id BIGSERIAL PRIMARY KEY,
    order_id BIGINT NOT NULL,
    product_id BIGINT NOT NULL,
    quantity INTEGER NOT NULL,
    price DECIMAL(12, 2) NOT NULL,
    amount DECIMAL(12, 2) NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
) PARTITION BY RANGE (created_at);

-- åº“å­˜è¡¨ï¼ˆåˆ†è¡¨ï¼‰
CREATE TABLE inventory_domain.stock (
    stock_id BIGSERIAL PRIMARY KEY,
    product_id BIGINT NOT NULL UNIQUE,
    available_stock INTEGER NOT NULL DEFAULT 0,
    reserved_stock INTEGER NOT NULL DEFAULT 0,
    total_stock INTEGER NOT NULL DEFAULT 0,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
) PARTITION BY HASH (product_id);
```

**å…³é”®è®¾è®¡ç‚¹**ï¼š

- ç”¨æˆ·è¡¨æŒ‰HASHåˆ†è¡¨ï¼ˆ10ä¸ªåˆ†è¡¨ï¼‰
- å•†å“è¡¨æŒ‰HASHåˆ†è¡¨ï¼ˆ10ä¸ªåˆ†è¡¨ï¼‰
- è®¢å•è¡¨æŒ‰æœˆåˆ†åŒºï¼ˆè‡ªåŠ¨åˆ›å»ºåˆ†åŒºï¼‰
- åº“å­˜è¡¨æŒ‰HASHåˆ†è¡¨ï¼ˆ10ä¸ªåˆ†è¡¨ï¼‰
- è®¢å•çŠ¶æ€è§¦å‘å™¨è‡ªåŠ¨æ›´æ–°åº“å­˜

### 2.3. æ ¸å¿ƒåŠŸèƒ½å®ç°

**åº“å­˜æ‰£å‡å‡½æ•°**ï¼š

```sql
CREATE OR REPLACE FUNCTION inventory_domain.decrease_stock(
    p_product_id BIGINT,
    p_quantity INTEGER
)
RETURNS BOOLEAN AS $$
DECLARE
    v_available_stock INTEGER;
BEGIN
    -- æ£€æŸ¥å¯ç”¨åº“å­˜
    SELECT available_stock INTO v_available_stock
    FROM inventory_domain.stock
    WHERE product_id = p_product_id
    FOR UPDATE;

    IF v_available_stock < p_quantity THEN
        RETURN FALSE;
    END IF;

    -- æ‰£å‡åº“å­˜
    UPDATE inventory_domain.stock
    SET available_stock = available_stock - p_quantity,
        reserved_stock = reserved_stock + p_quantity,
        updated_at = CURRENT_TIMESTAMP
    WHERE product_id = p_product_id;

    RETURN TRUE;
END;
$$ LANGUAGE plpgsql;
```

**è®¢å•åˆ›å»ºå‡½æ•°**ï¼š

```sql
CREATE OR REPLACE FUNCTION order_domain.create_order(
    p_user_id BIGINT,
    p_items JSONB,
    p_shipping_address JSONB,
    p_payment_method VARCHAR(50)
)
RETURNS BIGINT AS $$
DECLARE
    v_order_id BIGINT;
    v_total_amount DECIMAL(12, 2) := 0;
    v_item JSONB;
BEGIN
    -- ç”Ÿæˆè®¢å•ID
    v_order_id := nextval('order_domain.order_id_seq');

    -- è®¡ç®—æ€»é‡‘é¢å¹¶æ‰£å‡åº“å­˜
    FOR v_item IN SELECT * FROM jsonb_array_elements(p_items)
    LOOP
        -- æ‰£å‡åº“å­˜
        IF NOT inventory_domain.decrease_stock(
            (v_item->>'product_id')::BIGINT,
            (v_item->>'quantity')::INTEGER
        ) THEN
            RAISE EXCEPTION 'Insufficient stock for product %', v_item->>'product_id';
        END IF;

        -- ç´¯åŠ æ€»é‡‘é¢
        v_total_amount := v_total_amount +
            (v_item->>'price')::DECIMAL(12, 2) * (v_item->>'quantity')::INTEGER;
    END LOOP;

    -- åˆ›å»ºè®¢å•
    INSERT INTO order_domain.orders (
        order_id, user_id, order_sn, total_amount, actual_payment,
        shipping_address, payment_method, order_status
    )
    VALUES (
        v_order_id, p_user_id, 'ORD' || v_order_id, v_total_amount, v_total_amount,
        p_shipping_address, p_payment_method, 'created'
    );

    -- åˆ›å»ºè®¢å•æ˜ç»†
    INSERT INTO order_domain.order_items (order_id, product_id, quantity, price, amount)
    SELECT
        v_order_id,
        (item->>'product_id')::BIGINT,
        (item->>'quantity')::INTEGER,
        (item->>'price')::DECIMAL(12, 2),
        (item->>'price')::DECIMAL(12, 2) * (item->>'quantity')::INTEGER
    FROM jsonb_array_elements(p_items) AS item;

    RETURN v_order_id;
END;
$$ LANGUAGE plpgsql;
```

---

## 3. ç¤¾äº¤ç½‘ç»œæ¡ˆä¾‹

### 3.1. åœºæ™¯æè¿°

**ä¸šåŠ¡éœ€æ±‚**ï¼š

- æ”¯æŒäº¿çº§ç”¨æˆ·
- ç”¨æˆ·å…³ç³»ç®¡ç†ï¼ˆå…³æ³¨ã€ç²‰ä¸ï¼‰
- å†…å®¹å‘å¸ƒï¼ˆæ–‡å­—ã€å›¾ç‰‡ã€è§†é¢‘ï¼‰
- æ¶ˆæ¯ç³»ç»Ÿï¼ˆç§ä¿¡ã€é€šçŸ¥ï¼‰
- å®æ—¶Feedæµ

### 3.2. è®¾è®¡æ–¹æ¡ˆ

**æ ¸å¿ƒè¡¨ç»“æ„**ï¼š

```sql
-- ç”¨æˆ·è¡¨ï¼ˆåˆ†è¡¨ï¼‰
CREATE TABLE social_domain.users (
    user_id BIGSERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    nickname VARCHAR(100),
    avatar_url TEXT,
    bio TEXT,
    follower_count INTEGER DEFAULT 0,
    following_count INTEGER DEFAULT 0,
    post_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
) PARTITION BY HASH (user_id);

-- ç”¨æˆ·å…³ç³»è¡¨ï¼ˆåˆ†è¡¨ï¼‰
CREATE TABLE social_domain.user_relations (
    relation_id BIGSERIAL PRIMARY KEY,
    follower_id BIGINT NOT NULL,
    following_id BIGINT NOT NULL,
    status VARCHAR(20) DEFAULT 'active',
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    UNIQUE (follower_id, following_id)
) PARTITION BY HASH (follower_id);

-- å†…å®¹è¡¨ï¼ˆåˆ†è¡¨ï¼‰
CREATE TABLE social_domain.posts (
    post_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL,
    content_type VARCHAR(20) NOT NULL, -- text, image, video
    content TEXT,
    media_urls JSONB,
    like_count INTEGER DEFAULT 0,
    comment_count INTEGER DEFAULT 0,
    share_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
) PARTITION BY HASH (user_id);

-- Feedæµè¡¨ï¼ˆåˆ†è¡¨ï¼‰
CREATE TABLE social_domain.feeds (
    feed_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL,
    post_id BIGINT NOT NULL,
    post_user_id BIGINT NOT NULL,
    score DOUBLE PRECISION NOT NULL, -- æ’åºåˆ†æ•°
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
) PARTITION BY HASH (user_id);

-- æ¶ˆæ¯è¡¨ï¼ˆåˆ†è¡¨ï¼‰
CREATE TABLE social_domain.messages (
    message_id BIGSERIAL PRIMARY KEY,
    sender_id BIGINT NOT NULL,
    receiver_id BIGINT NOT NULL,
    message_type VARCHAR(20) NOT NULL, -- text, image, system
    content TEXT NOT NULL,
    is_read BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
) PARTITION BY HASH (receiver_id);
```

**å…³é”®è®¾è®¡ç‚¹**ï¼š

- ç”¨æˆ·è¡¨æŒ‰HASHåˆ†è¡¨ï¼ˆ100ä¸ªåˆ†è¡¨ï¼‰
- ç”¨æˆ·å…³ç³»è¡¨æŒ‰follower_idåˆ†è¡¨ï¼ˆ100ä¸ªåˆ†è¡¨ï¼‰
- å†…å®¹è¡¨æŒ‰user_idåˆ†è¡¨ï¼ˆ100ä¸ªåˆ†è¡¨ï¼‰
- Feedæµè¡¨æŒ‰user_idåˆ†è¡¨ï¼ˆ100ä¸ªåˆ†è¡¨ï¼‰
- æ¶ˆæ¯è¡¨æŒ‰receiver_idåˆ†è¡¨ï¼ˆ100ä¸ªåˆ†è¡¨ï¼‰

### 3.3. æ ¸å¿ƒåŠŸèƒ½å®ç°

**å…³æ³¨ç”¨æˆ·å‡½æ•°**ï¼š

```sql
CREATE OR REPLACE FUNCTION social_domain.follow_user(
    p_follower_id BIGINT,
    p_following_id BIGINT
)
RETURNS BOOLEAN AS $$
BEGIN
    -- æ£€æŸ¥æ˜¯å¦å·²å…³æ³¨
    IF EXISTS (
        SELECT 1 FROM social_domain.user_relations
        WHERE follower_id = p_follower_id AND following_id = p_following_id
    ) THEN
        RETURN FALSE;
    END IF;

    -- åˆ›å»ºå…³æ³¨å…³ç³»
    INSERT INTO social_domain.user_relations (follower_id, following_id)
    VALUES (p_follower_id, p_following_id);

    -- æ›´æ–°å…³æ³¨æ•°
    UPDATE social_domain.users
    SET following_count = following_count + 1
    WHERE user_id = p_follower_id;

    -- æ›´æ–°ç²‰ä¸æ•°
    UPDATE social_domain.users
    SET follower_count = follower_count + 1
    WHERE user_id = p_following_id;

    RETURN TRUE;
END;
$$ LANGUAGE plpgsql;
```

**ç”ŸæˆFeedæµå‡½æ•°**ï¼š

```sql
CREATE OR REPLACE FUNCTION social_domain.generate_feed(
    p_user_id BIGINT,
    p_limit INTEGER DEFAULT 20
)
RETURNS TABLE (
    post_id BIGINT,
    user_id BIGINT,
    content TEXT,
    created_at TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        p.post_id,
        p.user_id,
        p.content,
        p.created_at
    FROM social_domain.posts p
    WHERE p.user_id IN (
        SELECT following_id
        FROM social_domain.user_relations
        WHERE follower_id = p_user_id AND status = 'active'
    )
    ORDER BY p.created_at DESC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;
```

---

## 4. é‡‘èæ”¯ä»˜æ¡ˆä¾‹

### 4.1. åœºæ™¯æè¿°

**ä¸šåŠ¡éœ€æ±‚**ï¼š

- é«˜å¹¶å‘æ”¯ä»˜å¤„ç†
- èµ„é‡‘å®‰å…¨ä¿è¯
- äº¤æ˜“è®°å½•å®Œæ•´
- è´¦æˆ·ä½™é¢ç®¡ç†
- å¯¹è´¦åŠŸèƒ½

### 4.2. è®¾è®¡æ–¹æ¡ˆ

**æ ¸å¿ƒè¡¨ç»“æ„**ï¼š

```sql
-- è´¦æˆ·è¡¨ï¼ˆåˆ†è¡¨ï¼‰
CREATE TABLE finance_domain.accounts (
    account_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL UNIQUE,
    balance DECIMAL(18, 2) NOT NULL DEFAULT 0,
    frozen_balance DECIMAL(18, 2) NOT NULL DEFAULT 0,
    currency VARCHAR(10) DEFAULT 'CNY',
    status VARCHAR(20) DEFAULT 'active',
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
) PARTITION BY HASH (user_id);

-- äº¤æ˜“è®°å½•è¡¨ï¼ˆæŒ‰æœˆåˆ†åŒºï¼‰
CREATE TABLE finance_domain.transactions (
    transaction_id BIGSERIAL PRIMARY KEY,
    account_id BIGINT NOT NULL,
    transaction_type VARCHAR(20) NOT NULL, -- deposit, withdraw, transfer, payment
    amount DECIMAL(18, 2) NOT NULL,
    balance_before DECIMAL(18, 2) NOT NULL,
    balance_after DECIMAL(18, 2) NOT NULL,
    status VARCHAR(20) DEFAULT 'pending', -- pending, completed, failed
    related_transaction_id BIGINT,
    remark TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMPTZ
) PARTITION BY RANGE (created_at);

-- æ”¯ä»˜è®¢å•è¡¨ï¼ˆæŒ‰æœˆåˆ†åŒºï¼‰
CREATE TABLE finance_domain.payment_orders (
    order_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL,
    account_id BIGINT NOT NULL,
    order_sn VARCHAR(64) UNIQUE NOT NULL,
    amount DECIMAL(18, 2) NOT NULL,
    payment_method VARCHAR(50) NOT NULL,
    status VARCHAR(20) DEFAULT 'pending',
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    paid_at TIMESTAMPTZ
) PARTITION BY RANGE (created_at);
```

**å…³é”®è®¾è®¡ç‚¹**ï¼š

- è´¦æˆ·è¡¨æŒ‰HASHåˆ†è¡¨ï¼ˆ10ä¸ªåˆ†è¡¨ï¼‰
- äº¤æ˜“è®°å½•è¡¨æŒ‰æœˆåˆ†åŒºï¼ˆè‡ªåŠ¨åˆ›å»ºåˆ†åŒºï¼‰
- æ”¯ä»˜è®¢å•è¡¨æŒ‰æœˆåˆ†åŒºï¼ˆè‡ªåŠ¨åˆ›å»ºåˆ†åŒºï¼‰
- ä½¿ç”¨äº‹åŠ¡ä¿è¯èµ„é‡‘å®‰å…¨

### 4.3. æ ¸å¿ƒåŠŸèƒ½å®ç°

**æ”¯ä»˜å¤„ç†å‡½æ•°**ï¼š

```sql
CREATE OR REPLACE FUNCTION finance_domain.process_payment(
    p_account_id BIGINT,
    p_amount DECIMAL(18, 2),
    p_order_sn VARCHAR(64),
    p_payment_method VARCHAR(50)
)
RETURNS BIGINT AS $$
DECLARE
    v_transaction_id BIGINT;
    v_balance_before DECIMAL(18, 2);
    v_balance_after DECIMAL(18, 2);
BEGIN
    -- æ£€æŸ¥è´¦æˆ·ä½™é¢
    SELECT balance INTO v_balance_before
    FROM finance_domain.accounts
    WHERE account_id = p_account_id AND status = 'active'
    FOR UPDATE;

    IF v_balance_before < p_amount THEN
        RAISE EXCEPTION 'Insufficient balance';
    END IF;

    -- è®¡ç®—ä½™é¢
    v_balance_after := v_balance_before - p_amount;

    -- æ›´æ–°è´¦æˆ·ä½™é¢
    UPDATE finance_domain.accounts
    SET balance = v_balance_after,
        updated_at = CURRENT_TIMESTAMP
    WHERE account_id = p_account_id;

    -- åˆ›å»ºäº¤æ˜“è®°å½•
    INSERT INTO finance_domain.transactions (
        account_id, transaction_type, amount,
        balance_before, balance_after, status
    )
    VALUES (
        p_account_id, 'payment', p_amount,
        v_balance_before, v_balance_after, 'completed'
    )
    RETURNING transaction_id INTO v_transaction_id;

    -- åˆ›å»ºæ”¯ä»˜è®¢å•
    INSERT INTO finance_domain.payment_orders (
        user_id, account_id, order_sn, amount, payment_method, status, paid_at
    )
    SELECT
        user_id, p_account_id, p_order_sn, p_amount, p_payment_method,
        'completed', CURRENT_TIMESTAMP
    FROM finance_domain.accounts
    WHERE account_id = p_account_id;

    RETURN v_transaction_id;
END;
$$ LANGUAGE plpgsql;
```

---

## 5. å†…å®¹ç®¡ç†æ¡ˆä¾‹

### 5.1. åœºæ™¯æè¿°

**ä¸šåŠ¡éœ€æ±‚**ï¼š

- æ–‡ç« ç®¡ç†ç³»ç»Ÿ
- åª’ä½“æ–‡ä»¶ç®¡ç†
- æ ‡ç­¾ç³»ç»Ÿ
- å…¨æ–‡æœç´¢
- è¯„è®ºç³»ç»Ÿ

### 5.2. è®¾è®¡æ–¹æ¡ˆ

**æ ¸å¿ƒè¡¨ç»“æ„**ï¼š

```sql
-- æ–‡ç« è¡¨
CREATE TABLE cms_domain.articles (
    article_id BIGSERIAL PRIMARY KEY,
    author_id BIGINT NOT NULL,
    title VARCHAR(200) NOT NULL,
    content TEXT NOT NULL,
    excerpt TEXT,
    status VARCHAR(20) DEFAULT 'draft', -- draft, published, archived
    view_count INTEGER DEFAULT 0,
    like_count INTEGER DEFAULT 0,
    comment_count INTEGER DEFAULT 0,
    published_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- å…¨æ–‡æœç´¢ç´¢å¼•
CREATE INDEX idx_articles_content_fts ON cms_domain.articles
USING GIN(to_tsvector('english', title || ' ' || content));

-- æ ‡ç­¾è¡¨
CREATE TABLE cms_domain.tags (
    tag_id SERIAL PRIMARY KEY,
    tag_name VARCHAR(50) NOT NULL UNIQUE,
    tag_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- æ–‡ç« æ ‡ç­¾å…³è”è¡¨
CREATE TABLE cms_domain.article_tags (
    article_id BIGINT NOT NULL REFERENCES cms_domain.articles(article_id),
    tag_id INTEGER NOT NULL REFERENCES cms_domain.tags(tag_id),
    PRIMARY KEY (article_id, tag_id)
);

-- åª’ä½“æ–‡ä»¶è¡¨
CREATE TABLE cms_domain.media (
    media_id BIGSERIAL PRIMARY KEY,
    article_id BIGINT REFERENCES cms_domain.articles(article_id),
    media_type VARCHAR(20) NOT NULL, -- image, video, audio
    file_url TEXT NOT NULL,
    file_size BIGINT,
    mime_type VARCHAR(100),
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- è¯„è®ºè¡¨ï¼ˆåˆ†è¡¨ï¼‰
CREATE TABLE cms_domain.comments (
    comment_id BIGSERIAL PRIMARY KEY,
    article_id BIGINT NOT NULL,
    user_id BIGINT NOT NULL,
    parent_comment_id BIGINT REFERENCES cms_domain.comments(comment_id),
    content TEXT NOT NULL,
    like_count INTEGER DEFAULT 0,
    status VARCHAR(20) DEFAULT 'active',
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
) PARTITION BY HASH (article_id);
```

**å…³é”®è®¾è®¡ç‚¹**ï¼š

- æ–‡ç« è¡¨ä½¿ç”¨GINç´¢å¼•æ”¯æŒå…¨æ–‡æœç´¢
- æ ‡ç­¾è¡¨ä½¿ç”¨å…³è”è¡¨è®¾è®¡
- è¯„è®ºè¡¨æŒ‰article_idåˆ†è¡¨ï¼ˆ10ä¸ªåˆ†è¡¨ï¼‰
- åª’ä½“æ–‡ä»¶è¡¨æ”¯æŒå¤šç§åª’ä½“ç±»å‹

### 5.3. æ ¸å¿ƒåŠŸèƒ½å®ç°

**å…¨æ–‡æœç´¢å‡½æ•°**ï¼š

```sql
CREATE OR REPLACE FUNCTION cms_domain.search_articles(
    p_query TEXT,
    p_limit INTEGER DEFAULT 20
)
RETURNS TABLE (
    article_id BIGINT,
    title VARCHAR(200),
    excerpt TEXT,
    rank DOUBLE PRECISION
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        a.article_id,
        a.title,
        a.excerpt,
        ts_rank(to_tsvector('english', a.title || ' ' || a.content),
                plainto_tsquery('english', p_query)) AS rank
    FROM cms_domain.articles a
    WHERE a.status = 'published'
      AND to_tsvector('english', a.title || ' ' || a.content)
          @@ plainto_tsquery('english', p_query)
    ORDER BY rank DESC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;
```

---

## 6. IoTç›‘æ§æ¡ˆä¾‹

### 6.1. åœºæ™¯æè¿°

**ä¸šåŠ¡éœ€æ±‚**ï¼š

- è®¾å¤‡ç®¡ç†ï¼ˆç™¾ä¸‡çº§è®¾å¤‡ï¼‰
- æ•°æ®é‡‡é›†ï¼ˆæ¯ç§’ç™¾ä¸‡æ¡æ•°æ®ï¼‰
- å®æ—¶å‘Šè­¦
- å†å²æ•°æ®æŸ¥è¯¢
- æ•°æ®åˆ†æ

### 6.2. è®¾è®¡æ–¹æ¡ˆ

**æ ¸å¿ƒè¡¨ç»“æ„**ï¼š

```sql
-- è®¾å¤‡è¡¨
CREATE TABLE iot_domain.devices (
    device_id BIGSERIAL PRIMARY KEY,
    device_name VARCHAR(200) NOT NULL,
    device_type VARCHAR(50) NOT NULL,
    location VARCHAR(200),
    status VARCHAR(20) DEFAULT 'online',
    tags JSONB,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- æŒ‡æ ‡å®šä¹‰è¡¨
CREATE TABLE iot_domain.metrics (
    metric_id SERIAL PRIMARY KEY,
    metric_name VARCHAR(200) NOT NULL UNIQUE,
    metric_type VARCHAR(50) NOT NULL, -- counter, gauge, histogram
    unit VARCHAR(20),
    description TEXT
);

-- ç›‘æ§æ•°æ®è¡¨ï¼ˆæ—¶åºæ•°æ®ï¼Œä½¿ç”¨TimescaleDBï¼‰
CREATE TABLE iot_domain.metric_data (
    time TIMESTAMPTZ NOT NULL,
    device_id BIGINT NOT NULL REFERENCES iot_domain.devices(device_id),
    metric_id INTEGER NOT NULL REFERENCES iot_domain.metrics(metric_id),
    value DOUBLE PRECISION NOT NULL,
    labels JSONB,
    PRIMARY KEY (time, device_id, metric_id)
);

-- è½¬æ¢ä¸ºè¶…è¡¨
SELECT create_hypertable('iot_domain.metric_data', 'time',
    chunk_time_interval => INTERVAL '1 day'
);

-- å‘Šè­¦è§„åˆ™è¡¨
CREATE TABLE iot_domain.alert_rules (
    rule_id SERIAL PRIMARY KEY,
    rule_name VARCHAR(200) NOT NULL,
    device_id BIGINT REFERENCES iot_domain.devices(device_id),
    metric_id INTEGER NOT NULL REFERENCES iot_domain.metrics(metric_id),
    condition_type VARCHAR(20) NOT NULL, -- gt, lt, eq
    threshold_value DOUBLE PRECISION NOT NULL,
    severity VARCHAR(20) NOT NULL, -- critical, warning, info
    is_active BOOLEAN DEFAULT TRUE
);

-- å‘Šè­¦è®°å½•è¡¨
CREATE TABLE iot_domain.alerts (
    alert_id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES iot_domain.alert_rules(rule_id),
    device_id BIGINT NOT NULL,
    metric_id INTEGER NOT NULL,
    alert_value DOUBLE PRECISION NOT NULL,
    status VARCHAR(20) DEFAULT 'firing', -- firing, resolved
    started_at TIMESTAMPTZ NOT NULL,
    resolved_at TIMESTAMPTZ
);
```

**å…³é”®è®¾è®¡ç‚¹**ï¼š

- ä½¿ç”¨TimescaleDBå¤„ç†æ—¶åºæ•°æ®
- æŒ‰å¤©åˆ†åŒºï¼ˆchunk_time_intervalï¼‰
- å‘Šè­¦è§„åˆ™æ”¯æŒå¤šç§æ¡ä»¶
- å‘Šè­¦è®°å½•è¿½è¸ªå‘Šè­¦çŠ¶æ€

### 6.3. æ ¸å¿ƒåŠŸèƒ½å®ç°

**æ•°æ®é‡‡é›†å‡½æ•°**ï¼š

```sql
CREATE OR REPLACE FUNCTION iot_domain.insert_metric_data(
    p_device_id BIGINT,
    p_metric_id INTEGER,
    p_value DOUBLE PRECISION,
    p_labels JSONB DEFAULT '{}'::JSONB
)
RETURNS VOID AS $$
BEGIN
    INSERT INTO iot_domain.metric_data (
        time, device_id, metric_id, value, labels
    )
    VALUES (
        CURRENT_TIMESTAMP, p_device_id, p_metric_id, p_value, p_labels
    );
END;
$$ LANGUAGE plpgsql;
```

**å‘Šè­¦æ£€æµ‹å‡½æ•°**ï¼š

```sql
CREATE OR REPLACE FUNCTION iot_domain.check_alerts()
RETURNS TABLE (
    rule_id INTEGER,
    device_id BIGINT,
    metric_id INTEGER,
    alert_value DOUBLE PRECISION
) AS $$
BEGIN
    RETURN QUERY
    WITH recent_metrics AS (
        SELECT
            device_id,
            metric_id,
            AVG(value) AS avg_value
        FROM iot_domain.metric_data
        WHERE time >= CURRENT_TIMESTAMP - INTERVAL '5 minutes'
        GROUP BY device_id, metric_id
    )
    SELECT
        ar.rule_id,
        rm.device_id,
        rm.metric_id,
        rm.avg_value AS alert_value
    FROM iot_domain.alert_rules ar
    JOIN recent_metrics rm ON ar.metric_id = rm.metric_id
    WHERE ar.is_active = TRUE
      AND (
          (ar.device_id IS NULL OR ar.device_id = rm.device_id) AND
          (
              (ar.condition_type = 'gt' AND rm.avg_value > ar.threshold_value) OR
              (ar.condition_type = 'lt' AND rm.avg_value < ar.threshold_value) OR
              (ar.condition_type = 'eq' AND rm.avg_value = ar.threshold_value)
          )
      )
      AND NOT EXISTS (
          SELECT 1 FROM iot_domain.alerts a
          WHERE a.rule_id = ar.rule_id
            AND a.device_id = rm.device_id
            AND a.status = 'firing'
      );
END;
$$ LANGUAGE plpgsql;
```

---

## 7. æ¨èç³»ç»Ÿæ¡ˆä¾‹

### 7.1. åœºæ™¯æè¿°

**ä¸šåŠ¡éœ€æ±‚**ï¼š

- ç”¨æˆ·ç”»åƒç®¡ç†
- ç‰©å“ç‰¹å¾ç®¡ç†
- æ¨èç®—æ³•æ”¯æŒ
- æ¨èç»“æœå­˜å‚¨
- æ¨èæ•ˆæœè¯„ä¼°

### 7.2. è®¾è®¡æ–¹æ¡ˆ

**æ ¸å¿ƒè¡¨ç»“æ„**ï¼š

```sql
-- ç”¨æˆ·ç”»åƒè¡¨ï¼ˆåˆ†è¡¨ï¼‰
CREATE TABLE recommendation_domain.user_profiles (
    user_id BIGINT PRIMARY KEY,
    age INTEGER,
    gender VARCHAR(10),
    interests JSONB,
    behavior_vector vector(128), -- è¡Œä¸ºå‘é‡
    preference_vector vector(128), -- åå¥½å‘é‡
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
) PARTITION BY HASH (user_id);

-- ç‰©å“ç‰¹å¾è¡¨ï¼ˆåˆ†è¡¨ï¼‰
CREATE TABLE recommendation_domain.item_features (
    item_id BIGINT PRIMARY KEY,
    category VARCHAR(50),
    tags JSONB,
    content_vector vector(128), -- å†…å®¹å‘é‡
    popularity_score DOUBLE PRECISION DEFAULT 0,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
) PARTITION BY HASH (item_id);

-- ç”¨æˆ·è¡Œä¸ºè¡¨ï¼ˆåˆ†è¡¨ï¼‰
CREATE TABLE recommendation_domain.user_behaviors (
    behavior_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL,
    item_id BIGINT NOT NULL,
    behavior_type VARCHAR(20) NOT NULL, -- view, click, purchase, like
    behavior_score DOUBLE PRECISION DEFAULT 1.0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
) PARTITION BY HASH (user_id);

-- æ¨èç»“æœè¡¨ï¼ˆåˆ†è¡¨ï¼‰
CREATE TABLE recommendation_domain.recommendations (
    recommendation_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL,
    item_id BIGINT NOT NULL,
    recommendation_type VARCHAR(20) NOT NULL, -- collaborative, content, hybrid
    score DOUBLE PRECISION NOT NULL,
    rank INTEGER NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    UNIQUE (user_id, item_id, recommendation_type)
) PARTITION BY HASH (user_id);

-- å‘é‡ç´¢å¼•ï¼ˆHNSWï¼‰
CREATE INDEX idx_user_profiles_behavior_vector ON recommendation_domain.user_profiles
USING hnsw (behavior_vector vector_cosine_ops);

CREATE INDEX idx_item_features_content_vector ON recommendation_domain.item_features
USING hnsw (content_vector vector_cosine_ops);
```

**å…³é”®è®¾è®¡ç‚¹**ï¼š

- ç”¨æˆ·ç”»åƒè¡¨ä½¿ç”¨å‘é‡å­˜å‚¨è¡Œä¸ºç‰¹å¾
- ç‰©å“ç‰¹å¾è¡¨ä½¿ç”¨å‘é‡å­˜å‚¨å†…å®¹ç‰¹å¾
- æ¨èç»“æœè¡¨å­˜å‚¨æ¨èç»“æœå’Œåˆ†æ•°
- ä½¿ç”¨HNSWç´¢å¼•æ”¯æŒå‘é‡ç›¸ä¼¼åº¦æœç´¢

### 7.3. æ ¸å¿ƒåŠŸèƒ½å®ç°

**ååŒè¿‡æ»¤æ¨èå‡½æ•°**ï¼š

```sql
CREATE OR REPLACE FUNCTION recommendation_domain.collaborative_filtering(
    p_user_id BIGINT,
    p_limit INTEGER DEFAULT 20
)
RETURNS TABLE (
    item_id BIGINT,
    score DOUBLE PRECISION
) AS $$
BEGIN
    RETURN QUERY
    WITH user_similarity AS (
        SELECT
            ub2.item_id,
            SUM(ub1.behavior_score * ub2.behavior_score) AS similarity_score
        FROM recommendation_domain.user_behaviors ub1
        JOIN recommendation_domain.user_behaviors ub2
            ON ub1.item_id = ub2.item_id AND ub1.user_id != ub2.user_id
        WHERE ub1.user_id = p_user_id
        GROUP BY ub2.item_id
    )
    SELECT
        us.item_id,
        us.similarity_score AS score
    FROM user_similarity us
    WHERE NOT EXISTS (
        SELECT 1 FROM recommendation_domain.user_behaviors ub
        WHERE ub.user_id = p_user_id AND ub.item_id = us.item_id
    )
    ORDER BY us.similarity_score DESC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;
```

**å†…å®¹æ¨èå‡½æ•°ï¼ˆå‘é‡ç›¸ä¼¼åº¦ï¼‰**ï¼š

```sql
CREATE OR REPLACE FUNCTION recommendation_domain.content_based_recommendation(
    p_user_id BIGINT,
    p_limit INTEGER DEFAULT 20
)
RETURNS TABLE (
    item_id BIGINT,
    score DOUBLE PRECISION
) AS $$
DECLARE
    v_user_vector vector(128);
BEGIN
    -- è·å–ç”¨æˆ·åå¥½å‘é‡
    SELECT preference_vector INTO v_user_vector
    FROM recommendation_domain.user_profiles
    WHERE user_id = p_user_id;

    IF v_user_vector IS NULL THEN
        RETURN;
    END IF;

    -- åŸºäºå‘é‡ç›¸ä¼¼åº¦æ¨è
    RETURN QUERY
    SELECT
        if.item_id,
        1 - (if.content_vector <=> v_user_vector) AS score
    FROM recommendation_domain.item_features if
    WHERE NOT EXISTS (
        SELECT 1 FROM recommendation_domain.user_behaviors ub
        WHERE ub.user_id = p_user_id AND ub.item_id = if.item_id
    )
    ORDER BY if.content_vector <=> v_user_vector
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;
```

---

## 8. ä¼ä¸šçŸ¥è¯†åº“æ¡ˆä¾‹

### 8.1. åœºæ™¯æè¿°

**ä¸šåŠ¡éœ€æ±‚**ï¼š

- çŸ¥è¯†å›¾è°±ç®¡ç†
- æ–‡æ¡£ç®¡ç†
- æ™ºèƒ½æœç´¢
- çŸ¥è¯†æ¨ç†
- é—®ç­”ç³»ç»Ÿ

### 8.2. è®¾è®¡æ–¹æ¡ˆ

**æ ¸å¿ƒè¡¨ç»“æ„**ï¼š

```sql
-- å®ä½“è¡¨ï¼ˆçŸ¥è¯†å›¾è°±ï¼‰
CREATE TABLE knowledge_domain.entities (
    entity_id BIGSERIAL PRIMARY KEY,
    entity_type VARCHAR(50) NOT NULL,
    entity_name VARCHAR(200) NOT NULL,
    properties JSONB NOT NULL DEFAULT '{}',
    embedding vector(768), -- å‘é‡åµŒå…¥
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- å…³ç³»è¡¨ï¼ˆä¸‰å…ƒç»„ï¼‰
CREATE TABLE knowledge_domain.relations (
    relation_id BIGSERIAL PRIMARY KEY,
    subject_id BIGINT NOT NULL REFERENCES knowledge_domain.entities(entity_id),
    predicate VARCHAR(100) NOT NULL,
    object_id BIGINT NOT NULL REFERENCES knowledge_domain.entities(entity_id),
    properties JSONB NOT NULL DEFAULT '{}',
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    UNIQUE (subject_id, predicate, object_id)
);

-- æ–‡æ¡£è¡¨
CREATE TABLE knowledge_domain.documents (
    document_id BIGSERIAL PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    content TEXT NOT NULL,
    content_type VARCHAR(50) NOT NULL, -- text, pdf, markdown
    embedding vector(768), -- æ–‡æ¡£å‘é‡
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- æ–‡æ¡£å®ä½“å…³è”è¡¨
CREATE TABLE knowledge_domain.document_entities (
    document_id BIGINT NOT NULL REFERENCES knowledge_domain.documents(document_id),
    entity_id BIGINT NOT NULL REFERENCES knowledge_domain.entities(entity_id),
    PRIMARY KEY (document_id, entity_id)
);

-- å‘é‡ç´¢å¼•ï¼ˆHNSWï¼‰
CREATE INDEX idx_entities_embedding ON knowledge_domain.entities
USING hnsw (embedding vector_cosine_ops);

CREATE INDEX idx_documents_embedding ON knowledge_domain.documents
USING hnsw (embedding vector_cosine_ops);

-- å…¨æ–‡æœç´¢ç´¢å¼•
CREATE INDEX idx_documents_content_fts ON knowledge_domain.documents
USING GIN(to_tsvector('english', title || ' ' || content));
```

**å…³é”®è®¾è®¡ç‚¹**ï¼š

- å®ä½“è¡¨ä½¿ç”¨å‘é‡å­˜å‚¨å®ä½“åµŒå…¥
- å…³ç³»è¡¨å­˜å‚¨ä¸‰å…ƒç»„ï¼ˆçŸ¥è¯†å›¾è°±ï¼‰
- æ–‡æ¡£è¡¨æ”¯æŒå…¨æ–‡æœç´¢å’Œå‘é‡æœç´¢
- ä½¿ç”¨HNSWç´¢å¼•æ”¯æŒå‘é‡ç›¸ä¼¼åº¦æœç´¢

### 8.3. æ ¸å¿ƒåŠŸèƒ½å®ç°

**çŸ¥è¯†å›¾è°±æŸ¥è¯¢å‡½æ•°**ï¼š

```sql
CREATE OR REPLACE FUNCTION knowledge_domain.query_knowledge_graph(
    p_entity_name VARCHAR(200),
    p_depth INTEGER DEFAULT 2
)
RETURNS TABLE (
    entity_id BIGINT,
    entity_name VARCHAR(200),
    relation_path TEXT,
    depth INTEGER
) AS $$
BEGIN
    RETURN QUERY
    WITH RECURSIVE graph_traversal AS (
        -- èµ·å§‹å®ä½“
        SELECT
            e.entity_id,
            e.entity_name,
            ''::TEXT AS relation_path,
            0 AS depth
        FROM knowledge_domain.entities e
        WHERE e.entity_name = p_entity_name

        UNION ALL

        -- é€’å½’æŸ¥è¯¢å…³ç³»
        SELECT
            e.entity_id,
            e.entity_name,
            gt.relation_path || ' -> ' || r.predicate || ' -> ' || e.entity_name,
            gt.depth + 1
        FROM graph_traversal gt
        JOIN knowledge_domain.relations r ON r.subject_id = gt.entity_id
        JOIN knowledge_domain.entities e ON e.entity_id = r.object_id
        WHERE gt.depth < p_depth
    )
    SELECT
        gt.entity_id,
        gt.entity_name,
        gt.relation_path,
        gt.depth
    FROM graph_traversal gt
    ORDER BY gt.depth, gt.entity_name;
END;
$$ LANGUAGE plpgsql;
```

**æ··åˆæœç´¢å‡½æ•°ï¼ˆå‘é‡+å…¨æ–‡ï¼‰**ï¼š

```sql
CREATE OR REPLACE FUNCTION knowledge_domain.hybrid_search(
    p_query_text TEXT,
    p_query_vector vector(768),
    p_limit INTEGER DEFAULT 20
)
RETURNS TABLE (
    document_id BIGINT,
    title VARCHAR(200),
    score DOUBLE PRECISION
) AS $$
BEGIN
    RETURN QUERY
    WITH vector_results AS (
        SELECT
            d.document_id,
            d.title,
            1 - (d.embedding <=> p_query_vector) AS vector_score,
            ROW_NUMBER() OVER (ORDER BY d.embedding <=> p_query_vector) AS rank
        FROM knowledge_domain.documents d
        ORDER BY d.embedding <=> p_query_vector
        LIMIT p_limit * 2
    ),
    text_results AS (
        SELECT
            d.document_id,
            d.title,
            ts_rank(to_tsvector('english', d.title || ' ' || d.content),
                    plainto_tsquery('english', p_query_text)) AS text_score,
            ROW_NUMBER() OVER (ORDER BY ts_rank(to_tsvector('english', d.title || ' ' || d.content),
                    plainto_tsquery('english', p_query_text)) DESC) AS rank
        FROM knowledge_domain.documents d
        WHERE to_tsvector('english', d.title || ' ' || d.content)
              @@ plainto_tsquery('english', p_query_text)
        ORDER BY text_score DESC
        LIMIT p_limit * 2
    ),
    combined_results AS (
        SELECT
            COALESCE(v.document_id, t.document_id) AS document_id,
            COALESCE(v.title, t.title) AS title,
            COALESCE(v.vector_score, 0) * 0.6 +
            COALESCE(t.text_score, 0) * 0.4 AS combined_score
        FROM vector_results v
        FULL OUTER JOIN text_results t ON v.document_id = t.document_id
    )
    SELECT
        cr.document_id,
        cr.title,
        cr.combined_score AS score
    FROM combined_results cr
    ORDER BY cr.combined_score DESC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;
```

---

## 9. å¤šç§Ÿæˆ·SaaSæ¡ˆä¾‹

### 9.1. åœºæ™¯æè¿°

**ä¸šåŠ¡éœ€æ±‚**ï¼š

- å¤šç§Ÿæˆ·éš”ç¦»
- èµ„æºç®¡ç†
- æ•°æ®å®‰å…¨
- ç§Ÿæˆ·é…ç½®
- è®¡è´¹ç®¡ç†

### 9.2. è®¾è®¡æ–¹æ¡ˆ

**æ ¸å¿ƒè¡¨ç»“æ„**ï¼š

```sql
-- ç§Ÿæˆ·è¡¨
CREATE TABLE saas_domain.tenants (
    tenant_id BIGSERIAL PRIMARY KEY,
    tenant_name VARCHAR(200) NOT NULL UNIQUE,
    max_users INTEGER DEFAULT 10,
    max_storage_gb INTEGER DEFAULT 10,
    max_api_calls INTEGER DEFAULT 10000,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- ç”¨æˆ·è¡¨ï¼ˆå…±äº«ï¼ŒRLSéš”ç¦»ï¼‰
CREATE TABLE saas_domain.users (
    user_id BIGSERIAL PRIMARY KEY,
    tenant_id BIGINT NOT NULL REFERENCES saas_domain.tenants(tenant_id),
    username VARCHAR(100) NOT NULL,
    email VARCHAR(200) NOT NULL UNIQUE,
    password_hash TEXT NOT NULL,
    is_admin BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    UNIQUE (tenant_id, username)
);

-- å¯ç”¨RLS
ALTER TABLE saas_domain.users ENABLE ROW LEVEL SECURITY;

-- RLSç­–ç•¥å‡½æ•°
CREATE OR REPLACE FUNCTION saas_domain.get_current_tenant_id()
RETURNS BIGINT AS $$
BEGIN
    RETURN current_setting('app.current_tenant_id', TRUE)::BIGINT;
END;
$$ LANGUAGE plpgsql STABLE;

-- RLSç­–ç•¥
CREATE POLICY tenant_isolation_policy ON saas_domain.users
    FOR ALL
    USING (tenant_id = saas_domain.get_current_tenant_id())
    WITH CHECK (tenant_id = saas_domain.get_current_tenant_id());

-- é¡¹ç›®è¡¨ï¼ˆå…±äº«ï¼ŒRLSéš”ç¦»ï¼‰
CREATE TABLE saas_domain.projects (
    project_id BIGSERIAL PRIMARY KEY,
    tenant_id BIGINT NOT NULL REFERENCES saas_domain.tenants(tenant_id),
    project_name VARCHAR(200) NOT NULL,
    description TEXT,
    status VARCHAR(50) DEFAULT 'active',
    created_by BIGINT NOT NULL REFERENCES saas_domain.users(user_id),
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    UNIQUE (tenant_id, project_name)
);

ALTER TABLE saas_domain.projects ENABLE ROW LEVEL SECURITY;

CREATE POLICY tenant_isolation_policy ON saas_domain.projects
    FOR ALL
    USING (tenant_id = saas_domain.get_current_tenant_id())
    WITH CHECK (tenant_id = saas_domain.get_current_tenant_id());

-- èµ„æºä½¿ç”¨ç»Ÿè®¡è¡¨
CREATE TABLE saas_domain.resource_usage (
    usage_id BIGSERIAL PRIMARY KEY,
    tenant_id BIGINT NOT NULL REFERENCES saas_domain.tenants(tenant_id),
    usage_date DATE NOT NULL,
    user_count INTEGER DEFAULT 0,
    storage_gb DOUBLE PRECISION DEFAULT 0,
    api_calls INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    UNIQUE (tenant_id, usage_date)
);
```

**å…³é”®è®¾è®¡ç‚¹**ï¼š

- ä½¿ç”¨RLSå®ç°å¤šç§Ÿæˆ·éš”ç¦»
- ç§Ÿæˆ·è¡¨ç®¡ç†ç§Ÿæˆ·é…ç½®å’Œé™åˆ¶
- èµ„æºä½¿ç”¨ç»Ÿè®¡è¡¨è¿½è¸ªèµ„æºä½¿ç”¨æƒ…å†µ
- æ‰€æœ‰è¡¨éƒ½å¯ç”¨RLSç­–ç•¥

### 9.3. æ ¸å¿ƒåŠŸèƒ½å®ç°

**ç§Ÿæˆ·èµ„æºæ£€æŸ¥å‡½æ•°**ï¼š

```sql
CREATE OR REPLACE FUNCTION saas_domain.check_tenant_limits(
    p_tenant_id BIGINT,
    p_resource_type VARCHAR(50)
)
RETURNS BOOLEAN AS $$
DECLARE
    v_max_limit INTEGER;
    v_current_usage INTEGER;
BEGIN
    IF p_resource_type = 'users' THEN
        SELECT max_users INTO v_max_limit
        FROM saas_domain.tenants
        WHERE tenant_id = p_tenant_id;

        SELECT COUNT(*) INTO v_current_usage
        FROM saas_domain.users
        WHERE tenant_id = p_tenant_id;

        RETURN v_current_usage < v_max_limit;
    ELSIF p_resource_type = 'api_calls' THEN
        SELECT max_api_calls INTO v_max_limit
        FROM saas_domain.tenants
        WHERE tenant_id = p_tenant_id;

        SELECT COALESCE(SUM(api_calls), 0) INTO v_current_usage
        FROM saas_domain.resource_usage
        WHERE tenant_id = p_tenant_id
          AND usage_date = CURRENT_DATE;

        RETURN v_current_usage < v_max_limit;
    END IF;

    RETURN TRUE;
END;
$$ LANGUAGE plpgsql;
```

---

## 10. å®æ—¶åˆ†ææ¡ˆä¾‹

### 10.1. åœºæ™¯æè¿°

**ä¸šåŠ¡éœ€æ±‚**ï¼š

- å®æ—¶æ•°æ®é‡‡é›†
- å®æ—¶è®¡ç®—
- å®æ—¶æŠ¥è¡¨
- æ•°æ®ä»“åº“
- OLAPåˆ†æ

### 10.2. è®¾è®¡æ–¹æ¡ˆ

**æ ¸å¿ƒè¡¨ç»“æ„**ï¼š

```sql
-- æ•°æ®æºè¡¨
CREATE TABLE analytics_domain.data_sources (
    source_id SERIAL PRIMARY KEY,
    source_name VARCHAR(200) NOT NULL UNIQUE,
    source_type VARCHAR(50) NOT NULL, -- kafka, api, database
    config JSONB NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- å®æ—¶æ•°æ®è¡¨ï¼ˆæ—¶åºæ•°æ®ï¼Œä½¿ç”¨TimescaleDBï¼‰
CREATE TABLE analytics_domain.real_time_data (
    time TIMESTAMPTZ NOT NULL,
    source_id INTEGER NOT NULL REFERENCES analytics_domain.data_sources(source_id),
    metric_name VARCHAR(200) NOT NULL,
    metric_value DOUBLE PRECISION NOT NULL,
    dimensions JSONB,
    PRIMARY KEY (time, source_id, metric_name)
);

-- è½¬æ¢ä¸ºè¶…è¡¨
SELECT create_hypertable('analytics_domain.real_time_data', 'time',
    chunk_time_interval => INTERVAL '1 hour'
);

-- æ•°æ®ä»“åº“è¡¨ï¼ˆåˆ—å¼å­˜å‚¨ï¼Œä½¿ç”¨ClickHouseæˆ–cstore_fdwï¼‰
CREATE TABLE analytics_domain.data_warehouse (
    date DATE NOT NULL,
    hour INTEGER NOT NULL,
    source_id INTEGER NOT NULL,
    metric_name VARCHAR(200) NOT NULL,
    metric_value DOUBLE PRECISION NOT NULL,
    dimensions JSONB,
    PRIMARY KEY (date, hour, source_id, metric_name)
);

-- ç‰©åŒ–è§†å›¾ï¼ˆå®æ—¶èšåˆï¼‰
CREATE MATERIALIZED VIEW analytics_domain.mv_hourly_metrics
AS
SELECT
    time_bucket('1 hour', time) AS hour,
    source_id,
    metric_name,
    AVG(metric_value) AS avg_value,
    MAX(metric_value) AS max_value,
    MIN(metric_value) AS min_value,
    COUNT(*) AS count
FROM analytics_domain.real_time_data
GROUP BY hour, source_id, metric_name;
```

**å…³é”®è®¾è®¡ç‚¹**ï¼š

- ä½¿ç”¨TimescaleDBå¤„ç†å®æ—¶æ—¶åºæ•°æ®
- ä½¿ç”¨ç‰©åŒ–è§†å›¾å®ç°å®æ—¶èšåˆ
- æ•°æ®ä»“åº“è¡¨æ”¯æŒOLAPåˆ†æ
- æŒ‰å°æ—¶åˆ†åŒºä¼˜åŒ–æŸ¥è¯¢æ€§èƒ½

### 10.3. æ ¸å¿ƒåŠŸèƒ½å®ç°

**å®æ—¶æ•°æ®æ’å…¥å‡½æ•°**ï¼š

```sql
CREATE OR REPLACE FUNCTION analytics_domain.insert_real_time_data(
    p_source_id INTEGER,
    p_metric_name VARCHAR(200),
    p_metric_value DOUBLE PRECISION,
    p_dimensions JSONB DEFAULT '{}'::JSONB
)
RETURNS VOID AS $$
BEGIN
    INSERT INTO analytics_domain.real_time_data (
        time, source_id, metric_name, metric_value, dimensions
    )
    VALUES (
        CURRENT_TIMESTAMP, p_source_id, p_metric_name, p_metric_value, p_dimensions
    );
END;
$$ LANGUAGE plpgsql;
```

**å®æ—¶æŠ¥è¡¨æŸ¥è¯¢å‡½æ•°**ï¼š

```sql
CREATE OR REPLACE FUNCTION analytics_domain.get_real_time_report(
    p_source_id INTEGER,
    p_start_time TIMESTAMPTZ,
    p_end_time TIMESTAMPTZ
)
RETURNS TABLE (
    metric_name VARCHAR(200),
    avg_value DOUBLE PRECISION,
    max_value DOUBLE PRECISION,
    min_value DOUBLE PRECISION,
    count BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        rtd.metric_name,
        AVG(rtd.metric_value) AS avg_value,
        MAX(rtd.metric_value) AS max_value,
        MIN(rtd.metric_value) AS min_value,
        COUNT(*) AS count
    FROM analytics_domain.real_time_data rtd
    WHERE rtd.source_id = p_source_id
      AND rtd.time >= p_start_time
      AND rtd.time <= p_end_time
    GROUP BY rtd.metric_name
    ORDER BY rtd.metric_name;
END;
$$ LANGUAGE plpgsql;
```

---

## 11. å‚è€ƒèµ„æ–™

- [æ•°æ®åº“è®¾è®¡æ¡ˆä¾‹æ·±åº¦è§£æ](./07.16-æ•°æ®åº“è®¾è®¡æ¡ˆä¾‹æ·±åº¦è§£æ.md)
- [æ•°æ®åº“è®¾è®¡æ¨¡å¼å®æˆ˜æ¼”ç»ƒ](./07.28-æ•°æ®åº“è®¾è®¡æ¨¡å¼å®æˆ˜æ¼”ç»ƒ.md)
- [æ•°æ®åº“è®¾è®¡æ¨¡å¼æ€»ç»“ä¸ç´¢å¼•](./07.27-æ•°æ®åº“è®¾è®¡æ¨¡å¼æ€»ç»“ä¸ç´¢å¼•.md)

---

**æœ€åæ›´æ–°**ï¼š2025-01-15
**ç»´æŠ¤è€…**ï¼šData-Science Team
**çŠ¶æ€**ï¼šå®æ–½ä¸­
