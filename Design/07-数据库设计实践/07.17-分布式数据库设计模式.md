# åˆ†å¸ƒå¼æ•°æ®åº“è®¾è®¡æ¨¡å¼ï¼šå¾®æœåŠ¡ä¸æ•°æ®ä¸€è‡´æ€§

> **åˆ›å»ºæ—¥æœŸ**ï¼š2025-01-15
> **æœ€åæ›´æ–°**ï¼š2025-01-15
> **ç‰ˆæœ¬**ï¼šv1.0
> **çŠ¶æ€**ï¼šå®æ–½ä¸­

---

## ğŸ“‹ ç›®å½•

- [åˆ†å¸ƒå¼æ•°æ®åº“è®¾è®¡æ¨¡å¼ï¼šå¾®æœåŠ¡ä¸æ•°æ®ä¸€è‡´æ€§](#åˆ†å¸ƒå¼æ•°æ®åº“è®¾è®¡æ¨¡å¼å¾®æœåŠ¡ä¸æ•°æ®ä¸€è‡´æ€§)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1. åˆ†å¸ƒå¼è®¾è®¡æŒ‘æˆ˜](#11-åˆ†å¸ƒå¼è®¾è®¡æŒ‘æˆ˜)
    - [1.2. åˆ†å¸ƒå¼æ¨¡å¼é€‰æ‹©å†³ç­–æ ‘](#12-åˆ†å¸ƒå¼æ¨¡å¼é€‰æ‹©å†³ç­–æ ‘)
  - [2. å¾®æœåŠ¡æ•°æ®åº“è®¾è®¡](#2-å¾®æœåŠ¡æ•°æ®åº“è®¾è®¡)
    - [2.1. Database per Serviceæ¨¡å¼](#21-database-per-serviceæ¨¡å¼)
    - [2.2. å…±äº«æ•°æ®åº“åæ¨¡å¼](#22-å…±äº«æ•°æ®åº“åæ¨¡å¼)
  - [3. åˆ†å¸ƒå¼äº‹åŠ¡æ¨¡å¼](#3-åˆ†å¸ƒå¼äº‹åŠ¡æ¨¡å¼)
    - [3.1. Sagaæ¨¡å¼](#31-sagaæ¨¡å¼)
    - [3.2. ä¸¤é˜¶æ®µæäº¤ï¼ˆ2PCï¼‰](#32-ä¸¤é˜¶æ®µæäº¤2pc)
  - [4. æ•°æ®ä¸€è‡´æ€§æ¨¡å¼](#4-æ•°æ®ä¸€è‡´æ€§æ¨¡å¼)
    - [4.1. æœ€ç»ˆä¸€è‡´æ€§æ¨¡å¼](#41-æœ€ç»ˆä¸€è‡´æ€§æ¨¡å¼)
    - [4.2. CQRSæ¨¡å¼](#42-cqrsæ¨¡å¼)
  - [5. æ•°æ®åŒæ­¥æ¨¡å¼](#5-æ•°æ®åŒæ­¥æ¨¡å¼)
    - [5.1. äº‹ä»¶é©±åŠ¨åŒæ­¥](#51-äº‹ä»¶é©±åŠ¨åŒæ­¥)
    - [5.2. CDCå˜æ›´æ•è·](#52-cdcå˜æ›´æ•è·)
  - [6. å®é™…åº”ç”¨æ¡ˆä¾‹](#6-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [6.1. ç”µå•†å¾®æœåŠ¡æ¶æ„æ¡ˆä¾‹](#61-ç”µå•†å¾®æœåŠ¡æ¶æ„æ¡ˆä¾‹)
  - [7. å‚è€ƒèµ„æ–™](#7-å‚è€ƒèµ„æ–™)

---

## 1. æ¦‚è¿°

åˆ†å¸ƒå¼æ•°æ®åº“è®¾è®¡éœ€è¦è€ƒè™‘æœåŠ¡è§£è€¦ã€æ•°æ®ä¸€è‡´æ€§ã€äº‹åŠ¡ç®¡ç†ç­‰å¤æ‚é—®é¢˜ã€‚

### 1.1. åˆ†å¸ƒå¼è®¾è®¡æŒ‘æˆ˜

```mermaid
mindmap
  root((åˆ†å¸ƒå¼è®¾è®¡æŒ‘æˆ˜))
    æœåŠ¡è§£è€¦
      æ•°æ®åº“éš”ç¦»
      æœåŠ¡ç‹¬ç«‹éƒ¨ç½²
      æ•°æ®æ‰€æœ‰æƒ
    æ•°æ®ä¸€è‡´æ€§
      å¼ºä¸€è‡´æ€§
      æœ€ç»ˆä¸€è‡´æ€§
      å› æœä¸€è‡´æ€§
    äº‹åŠ¡ç®¡ç†
      æœ¬åœ°äº‹åŠ¡
      åˆ†å¸ƒå¼äº‹åŠ¡
      Sagaæ¨¡å¼
    æ•°æ®åŒæ­¥
      äº‹ä»¶é©±åŠ¨
      æ¶ˆæ¯é˜Ÿåˆ—
      CDCå˜æ›´æ•è·
```

### 1.2. åˆ†å¸ƒå¼æ¨¡å¼é€‰æ‹©å†³ç­–æ ‘

```mermaid
flowchart TD
    A[é€‰æ‹©åˆ†å¸ƒå¼æ¨¡å¼] --> B{ä¸€è‡´æ€§è¦æ±‚}

    B -->|å¼ºä¸€è‡´æ€§| C[åˆ†å¸ƒå¼äº‹åŠ¡]
    B -->|æœ€ç»ˆä¸€è‡´æ€§| D{åŒæ­¥æ–¹å¼}

    C --> E[ä¸¤é˜¶æ®µæäº¤]
    C --> F[Sagaæ¨¡å¼]

    D -->|å®æ—¶| G[äº‹ä»¶é©±åŠ¨]
    D -->|æ‰¹é‡| H[CDCåŒæ­¥]

    E --> I[å®ç°å®Œæˆ]
    F --> I
    G --> I
    H --> I
```

---

## 2. å¾®æœåŠ¡æ•°æ®åº“è®¾è®¡

### 2.1. Database per Serviceæ¨¡å¼

**æ¨¡å¼å®šä¹‰**ï¼š

```text
æ¯ä¸ªå¾®æœåŠ¡æ‹¥æœ‰ç‹¬ç«‹çš„æ•°æ®åº“ï¼ŒæœåŠ¡é—´é€šè¿‡APIé€šä¿¡ï¼Œä¸ç›´æ¥è®¿é—®å…¶ä»–æœåŠ¡çš„æ•°æ®åº“ã€‚
```

**Schemaè®¾è®¡**ï¼š

```sql
-- ============================================
-- ç”¨æˆ·æœåŠ¡æ•°æ®åº“
-- ============================================

CREATE SCHEMA user_service;

CREATE TABLE user_service.users (
    user_id BIGSERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL UNIQUE,
    password_hash TEXT NOT NULL,
    profile_data JSONB,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- è®¢å•æœåŠ¡æ•°æ®åº“
-- ============================================

CREATE SCHEMA order_service;

CREATE TABLE order_service.orders (
    order_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL,  -- å¼•ç”¨ç”¨æˆ·æœåŠ¡ï¼Œä½†ä¸ä½¿ç”¨å¤–é”®
    order_number VARCHAR(50) NOT NULL UNIQUE,
    order_status VARCHAR(20) NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- æ³¨æ„ï¼šä¸ä½¿ç”¨å¤–é”®çº¦æŸï¼Œå› ä¸ºuser_idå¼•ç”¨çš„æ˜¯å¦ä¸€ä¸ªæ•°æ®åº“
-- é€šè¿‡åº”ç”¨å±‚æˆ–äº‹ä»¶ä¿è¯æ•°æ®ä¸€è‡´æ€§
```

### 2.2. å…±äº«æ•°æ®åº“åæ¨¡å¼

**åæ¨¡å¼ç¤ºä¾‹**ï¼š

```sql
-- âŒ åæ¨¡å¼ï¼šå¤šä¸ªæœåŠ¡å…±äº«æ•°æ®åº“
CREATE SCHEMA shared_db;

-- ç”¨æˆ·æœåŠ¡è¡¨
CREATE TABLE shared_db.users (...);
-- è®¢å•æœåŠ¡è¡¨
CREATE TABLE shared_db.orders (...);
-- å•†å“æœåŠ¡è¡¨
CREATE TABLE shared_db.products (...);

-- é—®é¢˜ï¼š
-- 1. æœåŠ¡è€¦åˆåº¦é«˜
-- 2. æ— æ³•ç‹¬ç«‹éƒ¨ç½²
-- 3. Schemaå˜æ›´å½±å“æ‰€æœ‰æœåŠ¡
-- 4. éš¾ä»¥æ‰©å±•
```

**è§£å†³æ–¹æ¡ˆ**ï¼š

```sql
-- âœ… æ­£ç¡®ï¼šæ¯ä¸ªæœåŠ¡ç‹¬ç«‹æ•°æ®åº“
-- ç”¨æˆ·æœåŠ¡æ•°æ®åº“
CREATE DATABASE user_service_db;
-- è®¢å•æœåŠ¡æ•°æ®åº“
CREATE DATABASE order_service_db;
-- å•†å“æœåŠ¡æ•°æ®åº“
CREATE DATABASE product_service_db;
```

---

## 3. åˆ†å¸ƒå¼äº‹åŠ¡æ¨¡å¼

### 3.1. Sagaæ¨¡å¼

**Sagaæ¨¡å¼å®šä¹‰**ï¼š

```text
å°†é•¿äº‹åŠ¡åˆ†è§£ä¸ºå¤šä¸ªæœ¬åœ°äº‹åŠ¡ï¼Œæ¯ä¸ªæœ¬åœ°äº‹åŠ¡æœ‰å¯¹åº”çš„è¡¥å¿æ“ä½œã€‚
å¦‚æœæŸä¸ªæ­¥éª¤å¤±è´¥ï¼Œæ‰§è¡Œå·²å®Œæˆçš„æ­¥éª¤çš„è¡¥å¿æ“ä½œã€‚
```

**Sagaå®ç°Schema**ï¼š

```sql
CREATE SCHEMA saga_pattern;

-- Sagaå®ä¾‹è¡¨
CREATE TABLE saga_pattern.saga_instances (
    saga_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    saga_type VARCHAR(100) NOT NULL,
    status VARCHAR(20) NOT NULL CHECK (status IN ('pending', 'executing', 'completed', 'compensating', 'failed')),
    current_step INTEGER DEFAULT 0,
    total_steps INTEGER NOT NULL,
    payload JSONB NOT NULL,
    result JSONB,
    error_message TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_saga_instances_status ON saga_pattern.saga_instances(status, created_at DESC);

-- Sagaæ­¥éª¤è¡¨
CREATE TABLE saga_pattern.saga_steps (
    step_id BIGSERIAL PRIMARY KEY,
    saga_id UUID NOT NULL REFERENCES saga_pattern.saga_instances(saga_id) ON DELETE CASCADE,
    step_order INTEGER NOT NULL,
    step_name VARCHAR(100) NOT NULL,
    service_name VARCHAR(100) NOT NULL,
    action_type VARCHAR(20) NOT NULL CHECK (action_type IN ('action', 'compensation')),
    status VARCHAR(20) NOT NULL CHECK (status IN ('pending', 'executing', 'completed', 'failed', 'compensated')),
    request_payload JSONB,
    response_payload JSONB,
    error_message TEXT,
    executed_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ,
    UNIQUE(saga_id, step_order, action_type)
);

CREATE INDEX idx_saga_steps_saga ON saga_pattern.saga_steps(saga_id, step_order);

-- Sagaæ‰§è¡Œå‡½æ•°
CREATE OR REPLACE FUNCTION execute_saga_step(
    p_saga_id UUID,
    p_step_order INTEGER,
    p_service_name VARCHAR,
    p_action_payload JSONB
)
RETURNS JSONB AS $$
DECLARE
    v_step_id BIGINT;
    v_result JSONB;
BEGIN
    -- è®°å½•æ­¥éª¤å¼€å§‹
    INSERT INTO saga_pattern.saga_steps (
        saga_id, step_order, step_name, service_name,
        action_type, status, request_payload, executed_at
    )
    VALUES (
        p_saga_id, p_step_order, 'step_' || p_step_order, p_service_name,
        'action', 'executing', p_action_payload, CURRENT_TIMESTAMP
    )
    RETURNING step_id INTO v_step_id;

    -- è¿™é‡Œåº”è¯¥è°ƒç”¨å®é™…çš„æœåŠ¡API
    -- ç®€åŒ–ç¤ºä¾‹ï¼šå‡è®¾è°ƒç”¨æˆåŠŸ
    v_result := '{"success": true}'::JSONB;

    -- æ›´æ–°æ­¥éª¤çŠ¶æ€
    UPDATE saga_pattern.saga_steps
    SET status = 'completed',
        response_payload = v_result,
        completed_at = CURRENT_TIMESTAMP
    WHERE step_id = v_step_id;

    -- æ›´æ–°SagaçŠ¶æ€
    UPDATE saga_pattern.saga_instances
    SET current_step = p_step_order,
        status = CASE
            WHEN p_step_order >= total_steps THEN 'completed'
            ELSE 'executing'
        END,
        updated_at = CURRENT_TIMESTAMP
    WHERE saga_id = p_saga_id;

    RETURN v_result;
EXCEPTION
    WHEN OTHERS THEN
        -- æ­¥éª¤å¤±è´¥ï¼Œæ ‡è®°ä¸ºå¤±è´¥
        UPDATE saga_pattern.saga_steps
        SET status = 'failed',
            error_message = SQLERRM,
            completed_at = CURRENT_TIMESTAMP
        WHERE step_id = v_step_id;

        -- è§¦å‘è¡¥å¿
        PERFORM compensate_saga(p_saga_id);

        RAISE;
END;
$$ LANGUAGE plpgsql;

-- Sagaè¡¥å¿å‡½æ•°
CREATE OR REPLACE FUNCTION compensate_saga(p_saga_id UUID)
RETURNS VOID AS $$
DECLARE
    v_step RECORD;
BEGIN
    -- æ›´æ–°SagaçŠ¶æ€ä¸ºè¡¥å¿ä¸­
    UPDATE saga_pattern.saga_instances
    SET status = 'compensating'
    WHERE saga_id = p_saga_id;

    -- é€†åºæ‰§è¡Œè¡¥å¿æ“ä½œ
    FOR v_step IN
        SELECT * FROM saga_pattern.saga_steps
        WHERE saga_id = p_saga_id
          AND action_type = 'action'
          AND status = 'completed'
        ORDER BY step_order DESC
    LOOP
        -- æ‰§è¡Œè¡¥å¿æ“ä½œ
        INSERT INTO saga_pattern.saga_steps (
            saga_id, step_order, step_name, service_name,
            action_type, status, request_payload, executed_at
        )
        VALUES (
            p_saga_id, v_step.step_order, 'compensate_' || v_step.step_order,
            v_step.service_name, 'compensation', 'executing',
            v_step.request_payload, CURRENT_TIMESTAMP
        );

        -- è¿™é‡Œåº”è¯¥è°ƒç”¨æœåŠ¡çš„è¡¥å¿API
        -- ç®€åŒ–ç¤ºä¾‹ï¼šå‡è®¾è¡¥å¿æˆåŠŸ

        -- æ›´æ–°è¡¥å¿æ­¥éª¤çŠ¶æ€
        UPDATE saga_pattern.saga_steps
        SET status = 'compensated',
            completed_at = CURRENT_TIMESTAMP
        WHERE saga_id = p_saga_id
          AND step_order = v_step.step_order
          AND action_type = 'compensation';

        -- æ›´æ–°åŸæ­¥éª¤çŠ¶æ€
        UPDATE saga_pattern.saga_steps
        SET status = 'compensated'
        WHERE step_id = v_step.step_id;
    END LOOP;

    -- æ›´æ–°SagaçŠ¶æ€ä¸ºå¤±è´¥
    UPDATE saga_pattern.saga_instances
    SET status = 'failed',
        updated_at = CURRENT_TIMESTAMP
    WHERE saga_id = p_saga_id;
END;
$$ LANGUAGE plpgsql;
```

### 3.2. ä¸¤é˜¶æ®µæäº¤ï¼ˆ2PCï¼‰

**2PCå®ç°Schema**ï¼š

```sql
CREATE SCHEMA two_phase_commit;

-- äº‹åŠ¡åè°ƒå™¨è¡¨
CREATE TABLE two_phase_commit.transactions (
    transaction_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    status VARCHAR(20) NOT NULL CHECK (status IN ('preparing', 'prepared', 'committing', 'committed', 'aborting', 'aborted')),
    participants JSONB NOT NULL,  -- å‚ä¸çš„æœåŠ¡åˆ—è¡¨
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- å‚ä¸è€…çŠ¶æ€è¡¨
CREATE TABLE two_phase_commit.participants (
    participant_id BIGSERIAL PRIMARY KEY,
    transaction_id UUID NOT NULL REFERENCES two_phase_commit.transactions(transaction_id) ON DELETE CASCADE,
    service_name VARCHAR(100) NOT NULL,
    prepare_status VARCHAR(20) CHECK (prepare_status IN ('pending', 'prepared', 'failed')),
    commit_status VARCHAR(20) CHECK (commit_status IN ('pending', 'committed', 'failed')),
    prepare_response JSONB,
    commit_response JSONB,
    UNIQUE(transaction_id, service_name)
);

CREATE INDEX idx_participants_transaction ON two_phase_commit.participants(transaction_id);
```

---

## 4. æ•°æ®ä¸€è‡´æ€§æ¨¡å¼

### 4.1. æœ€ç»ˆä¸€è‡´æ€§æ¨¡å¼

**æœ€ç»ˆä¸€è‡´æ€§å®ç°**ï¼š

```sql
CREATE SCHEMA eventual_consistency;

-- äº‹ä»¶è¡¨ï¼ˆäº‹ä»¶æº¯æºï¼‰
CREATE TABLE eventual_consistency.events (
    event_id BIGSERIAL PRIMARY KEY,
    event_type VARCHAR(100) NOT NULL,
    aggregate_id VARCHAR(200) NOT NULL,
    aggregate_type VARCHAR(100) NOT NULL,
    event_data JSONB NOT NULL,
    event_version INTEGER NOT NULL,
    occurred_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(aggregate_id, aggregate_type, event_version)
);

CREATE INDEX idx_events_aggregate ON eventual_consistency.events(aggregate_id, aggregate_type, event_version);
CREATE INDEX idx_events_type ON eventual_consistency.events(event_type, occurred_at DESC);

-- è¯»æ¨¡å‹è¡¨ï¼ˆç‰©åŒ–è§†å›¾ï¼‰
CREATE TABLE eventual_consistency.read_models (
    model_id BIGSERIAL PRIMARY KEY,
    aggregate_id VARCHAR(200) NOT NULL,
    aggregate_type VARCHAR(100) NOT NULL,
    model_data JSONB NOT NULL,
    last_event_version INTEGER NOT NULL,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(aggregate_id, aggregate_type)
);

CREATE INDEX idx_read_models_aggregate ON eventual_consistency.read_models(aggregate_id, aggregate_type);

-- äº‹ä»¶å¤„ç†å‡½æ•°ï¼ˆæ›´æ–°è¯»æ¨¡å‹ï¼‰
CREATE OR REPLACE FUNCTION process_event(
    p_event_type VARCHAR,
    p_aggregate_id VARCHAR,
    p_aggregate_type VARCHAR,
    p_event_data JSONB
)
RETURNS VOID AS $$
DECLARE
    v_next_version INTEGER;
BEGIN
    -- è·å–ä¸‹ä¸€ä¸ªç‰ˆæœ¬å·
    SELECT COALESCE(MAX(event_version), 0) + 1
    INTO v_next_version
    FROM eventual_consistency.events
    WHERE aggregate_id = p_aggregate_id
      AND aggregate_type = p_aggregate_type;

    -- æ’å…¥äº‹ä»¶
    INSERT INTO eventual_consistency.events (
        event_type, aggregate_id, aggregate_type,
        event_data, event_version
    )
    VALUES (
        p_event_type, p_aggregate_id, p_aggregate_type,
        p_event_data, v_next_version
    );

    -- æ›´æ–°è¯»æ¨¡å‹ï¼ˆç®€åŒ–ç¤ºä¾‹ï¼‰
    INSERT INTO eventual_consistency.read_models (
        aggregate_id, aggregate_type, model_data, last_event_version
    )
    VALUES (
        p_aggregate_id, p_aggregate_type, p_event_data, v_next_version
    )
    ON CONFLICT (aggregate_id, aggregate_type)
    DO UPDATE SET
        model_data = EXCLUDED.model_data,
        last_event_version = EXCLUDED.last_event_version,
        updated_at = CURRENT_TIMESTAMP;
END;
$$ LANGUAGE plpgsql;
```

### 4.2. CQRSæ¨¡å¼

**CQRS Schemaè®¾è®¡**ï¼š

```sql
CREATE SCHEMA cqrs_pattern;

-- å‘½ä»¤è¡¨ï¼ˆå†™æ¨¡å‹ï¼‰
CREATE TABLE cqrs_pattern.commands (
    command_id BIGSERIAL PRIMARY KEY,
    command_type VARCHAR(100) NOT NULL,
    aggregate_id VARCHAR(200) NOT NULL,
    command_data JSONB NOT NULL,
    status VARCHAR(20) NOT NULL CHECK (status IN ('pending', 'processing', 'completed', 'failed')),
    error_message TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    processed_at TIMESTAMPTZ
);

CREATE INDEX idx_commands_aggregate ON cqrs_pattern.commands(aggregate_id, created_at DESC);
CREATE INDEX idx_commands_status ON cqrs_pattern.commands(status, created_at DESC) WHERE status IN ('pending', 'processing');

-- æŸ¥è¯¢è¡¨ï¼ˆè¯»æ¨¡å‹ï¼‰
CREATE TABLE cqrs_pattern.query_models (
    model_id BIGSERIAL PRIMARY KEY,
    aggregate_id VARCHAR(200) NOT NULL UNIQUE,
    model_type VARCHAR(100) NOT NULL,
    model_data JSONB NOT NULL,
    last_command_id BIGINT REFERENCES cqrs_pattern.commands(command_id),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_query_models_type ON cqrs_pattern.query_models(model_type, updated_at DESC);
```

---

## 5. æ•°æ®åŒæ­¥æ¨¡å¼

### 5.1. äº‹ä»¶é©±åŠ¨åŒæ­¥

**äº‹ä»¶é©±åŠ¨Schema**ï¼š

```sql
CREATE SCHEMA event_driven;

-- äº‹ä»¶å‘å¸ƒè¡¨
CREATE TABLE event_driven.event_outbox (
    event_id BIGSERIAL PRIMARY KEY,
    event_type VARCHAR(100) NOT NULL,
    aggregate_id VARCHAR(200) NOT NULL,
    event_data JSONB NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'published', 'failed')),
    retry_count INTEGER DEFAULT 0,
    published_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_event_outbox_status ON event_driven.event_outbox(status, created_at) WHERE status = 'pending';

-- äº‹ä»¶è®¢é˜…è¡¨
CREATE TABLE event_driven.event_inbox (
    event_id BIGSERIAL PRIMARY KEY,
    event_type VARCHAR(100) NOT NULL,
    aggregate_id VARCHAR(200) NOT NULL,
    event_data JSONB NOT NULL,
    source_service VARCHAR(100) NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'processed', 'failed')),
    processed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_event_inbox_status ON event_driven.event_inbox(status, created_at) WHERE status = 'pending';

-- äº‹ä»¶å‘å¸ƒå‡½æ•°ï¼ˆäº‹åŠ¡æ€§å‘ä»¶ç®±æ¨¡å¼ï¼‰
CREATE OR REPLACE FUNCTION publish_event(
    p_event_type VARCHAR,
    p_aggregate_id VARCHAR,
    p_event_data JSONB
)
RETURNS BIGINT AS $$
DECLARE
    v_event_id BIGINT;
BEGIN
    -- åœ¨åŒä¸€ä¸ªäº‹åŠ¡ä¸­æ’å…¥ä¸šåŠ¡æ•°æ®å’Œäº‹ä»¶
    INSERT INTO event_driven.event_outbox (
        event_type, aggregate_id, event_data
    )
    VALUES (
        p_event_type, p_aggregate_id, p_event_data
    )
    RETURNING event_id INTO v_event_id;

    -- è¿™é‡Œåº”è¯¥åŒæ—¶æ’å…¥ä¸šåŠ¡æ•°æ®
    -- ä¿è¯ä¸šåŠ¡æ•°æ®å’Œäº‹ä»¶åœ¨åŒä¸€äº‹åŠ¡ä¸­

    RETURN v_event_id;
END;
$$ LANGUAGE plpgsql;

-- äº‹ä»¶å¤„ç†å‡½æ•°
CREATE OR REPLACE FUNCTION process_pending_events()
RETURNS TABLE (
    event_id BIGINT,
    event_type VARCHAR,
    event_data JSONB
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        e.event_id,
        e.event_type,
        e.event_data
    FROM event_driven.event_outbox e
    WHERE e.status = 'pending'
    ORDER BY e.created_at
    LIMIT 100;

    -- æ ‡è®°ä¸ºå·²å‘å¸ƒ
    UPDATE event_driven.event_outbox
    SET status = 'published',
        published_at = CURRENT_TIMESTAMP
    WHERE event_id IN (
        SELECT event_id FROM event_driven.event_outbox
        WHERE status = 'pending'
        ORDER BY created_at
        LIMIT 100
    );
END;
$$ LANGUAGE plpgsql;
```

### 5.2. CDCå˜æ›´æ•è·

**CDC Schemaè®¾è®¡**ï¼š

```sql
CREATE SCHEMA cdc_pattern;

-- å˜æ›´æ—¥å¿—è¡¨
CREATE TABLE cdc_pattern.change_logs (
    change_id BIGSERIAL PRIMARY KEY,
    table_name VARCHAR(200) NOT NULL,
    record_id VARCHAR(200) NOT NULL,
    change_type VARCHAR(20) NOT NULL CHECK (change_type IN ('INSERT', 'UPDATE', 'DELETE')),
    old_data JSONB,
    new_data JSONB,
    changed_fields TEXT[],
    changed_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    processed BOOLEAN DEFAULT FALSE,
    processed_at TIMESTAMPTZ
) PARTITION BY RANGE (changed_at);

CREATE INDEX idx_change_logs_table ON cdc_pattern.change_logs(table_name, changed_at DESC);
CREATE INDEX idx_change_logs_unprocessed ON cdc_pattern.change_logs(changed_at) WHERE processed = FALSE;

-- é€šç”¨å˜æ›´æ•è·è§¦å‘å™¨
CREATE OR REPLACE FUNCTION capture_table_changes()
RETURNS TRIGGER AS $$
DECLARE
    v_change_type VARCHAR(20);
    v_old_data JSONB;
    v_new_data JSONB;
    v_changed_fields TEXT[];
BEGIN
    -- ç¡®å®šå˜æ›´ç±»å‹
    IF TG_OP = 'DELETE' THEN
        v_change_type := 'DELETE';
        v_old_data := row_to_json(OLD);
        v_new_data := NULL;
    ELSIF TG_OP = 'UPDATE' THEN
        v_change_type := 'UPDATE';
        v_old_data := row_to_json(OLD);
        v_new_data := row_to_json(NEW);

        -- è®¡ç®—å˜æ›´å­—æ®µ
        SELECT array_agg(key)
        INTO v_changed_fields
        FROM jsonb_each(row_to_json(OLD)::JSONB) old_kv
        JOIN jsonb_each(row_to_json(NEW)::JSONB) new_kv ON old_kv.key = new_kv.key
        WHERE old_kv.value IS DISTINCT FROM new_kv.value;
    ELSE
        v_change_type := 'INSERT';
        v_old_data := NULL;
        v_new_data := row_to_json(NEW);
    END IF;

    -- æ’å…¥å˜æ›´æ—¥å¿—
    INSERT INTO cdc_pattern.change_logs (
        table_name, record_id, change_type,
        old_data, new_data, changed_fields
    )
    VALUES (
        TG_TABLE_NAME,
        COALESCE((NEW.id)::TEXT, (OLD.id)::TEXT),
        v_change_type,
        v_old_data,
        v_new_data,
        v_changed_fields
    );

    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

-- ä¸ºè¡¨åˆ›å»ºå˜æ›´æ•è·è§¦å‘å™¨
CREATE TRIGGER users_change_capture
AFTER INSERT OR UPDATE OR DELETE ON user_service.users
FOR EACH ROW
EXECUTE FUNCTION capture_table_changes();
```

---

## 6. å®é™…åº”ç”¨æ¡ˆä¾‹

### 6.1. ç”µå•†å¾®æœåŠ¡æ¶æ„æ¡ˆä¾‹

**å®Œæ•´å¾®æœåŠ¡Schemaè®¾è®¡**ï¼š

```sql
-- ============================================
-- ç”¨æˆ·æœåŠ¡æ•°æ®åº“
-- ============================================

CREATE SCHEMA user_service;

CREATE TABLE user_service.users (
    user_id BIGSERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL UNIQUE,
    password_hash TEXT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- ç”¨æˆ·äº‹ä»¶è¡¨ï¼ˆäº‹ä»¶æº¯æºï¼‰
CREATE TABLE user_service.user_events (
    event_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL,
    event_type VARCHAR(50) NOT NULL,
    event_data JSONB NOT NULL,
    occurred_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_user_events_user ON user_service.user_events(user_id, occurred_at);

-- ============================================
-- è®¢å•æœåŠ¡æ•°æ®åº“
-- ============================================

CREATE SCHEMA order_service;

CREATE TABLE order_service.orders (
    order_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL,  -- å¼•ç”¨ç”¨æˆ·æœåŠ¡ï¼Œæ— å¤–é”®
    order_number VARCHAR(50) NOT NULL UNIQUE,
    order_status VARCHAR(20) NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- è®¢å•äº‹ä»¶è¡¨
CREATE TABLE order_service.order_events (
    event_id BIGSERIAL PRIMARY KEY,
    order_id BIGINT NOT NULL,
    event_type VARCHAR(50) NOT NULL,
    event_data JSONB NOT NULL,
    occurred_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- äº‹ä»¶åŒæ­¥è¡¨ï¼ˆè·¨æœåŠ¡æ•°æ®åŒæ­¥ï¼‰
-- ============================================

CREATE SCHEMA event_sync;

-- ç”¨æˆ·æ•°æ®åŒæ­¥è¡¨ï¼ˆè®¢å•æœåŠ¡ä¸­çš„ç”¨æˆ·æ•°æ®å‰¯æœ¬ï¼‰
CREATE TABLE event_sync.user_snapshots (
    user_id BIGINT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,
    last_synced_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    version INTEGER NOT NULL DEFAULT 1
);

-- åŒæ­¥ç”¨æˆ·æ•°æ®å‡½æ•°ï¼ˆç”±ç”¨æˆ·æœåŠ¡äº‹ä»¶è§¦å‘ï¼‰
CREATE OR REPLACE FUNCTION sync_user_to_order_service(
    p_user_id BIGINT,
    p_username VARCHAR,
    p_email VARCHAR
)
RETURNS VOID AS $$
BEGIN
    INSERT INTO event_sync.user_snapshots (user_id, username, email)
    VALUES (p_user_id, p_username, p_email)
    ON CONFLICT (user_id)
    DO UPDATE SET
        username = EXCLUDED.username,
        email = EXCLUDED.email,
        last_synced_at = CURRENT_TIMESTAMP,
        version = user_snapshots.version + 1;
END;
$$ LANGUAGE plpgsql;
```

---

## 7. å‚è€ƒèµ„æ–™

- [ç°ä»£æ•°æ®åº“è®¾è®¡æ¨¡å¼](./07.05-ç°ä»£æ•°æ®åº“è®¾è®¡æ¨¡å¼.md)
- [æ•°æ®åº“è®¾è®¡æœ€ä½³å®è·µåº“](./07.14-æ•°æ®åº“è®¾è®¡æœ€ä½³å®è·µåº“.md)
- [æ•°æ®åº“è¿ç§»ä¸ç‰ˆæœ¬ç®¡ç†](./07.07-æ•°æ®åº“è¿ç§»ä¸ç‰ˆæœ¬ç®¡ç†.md)

---

**æœ€åæ›´æ–°**ï¼š2025-01-15
**ç»´æŠ¤è€…**ï¼šData-Science Team
**çŠ¶æ€**ï¼šå®æ–½ä¸­
