# æ•°æ®åº“å¤‡ä»½ä¸æ¢å¤è®¾è®¡æ¨¡å¼ï¼šæ•°æ®ä¿æŠ¤ä¸ç¾éš¾æ¢å¤

> **åˆ›å»ºæ—¥æœŸ**ï¼š2025-01-15
> **æœ€åæ›´æ–°**ï¼š2025-12-01
> **ç‰ˆæœ¬**ï¼šv2.0 (å¢å¼ºç‰ˆ)
> **çŠ¶æ€**ï¼šå·²å®Œæˆ âœ…

---

## ğŸ“‹ ç›®å½•

- [æ•°æ®åº“å¤‡ä»½ä¸æ¢å¤è®¾è®¡æ¨¡å¼ï¼šæ•°æ®ä¿æŠ¤ä¸ç¾éš¾æ¢å¤](#æ•°æ®åº“å¤‡ä»½ä¸æ¢å¤è®¾è®¡æ¨¡å¼æ•°æ®ä¿æŠ¤ä¸ç¾éš¾æ¢å¤)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1. å¤‡ä»½æ¢å¤åº”ç”¨åœºæ™¯](#11-å¤‡ä»½æ¢å¤åº”ç”¨åœºæ™¯)
    - [1.2. å¤‡ä»½ç­–ç•¥é€‰æ‹©å†³ç­–æ ‘](#12-å¤‡ä»½ç­–ç•¥é€‰æ‹©å†³ç­–æ ‘)
  - [2. å¤‡ä»½ç­–ç•¥è®¾è®¡](#2-å¤‡ä»½ç­–ç•¥è®¾è®¡)
    - [2.1. å¤‡ä»½ç±»å‹å¯¹æ¯”](#21-å¤‡ä»½ç±»å‹å¯¹æ¯”)
    - [2.2. å¤‡ä»½ç­–ç•¥è®¾è®¡åŸåˆ™](#22-å¤‡ä»½ç­–ç•¥è®¾è®¡åŸåˆ™)
  - [3. PostgreSQLå¤‡ä»½å®ç°](#3-postgresqlå¤‡ä»½å®ç°)
    - [3.1. pg\_dumpå®Œæ•´å¤‡ä»½](#31-pg_dumpå®Œæ•´å¤‡ä»½)
    - [3.2. pg\_basebackupç‰©ç†å¤‡ä»½](#32-pg_basebackupç‰©ç†å¤‡ä»½)
    - [3.3. WALå½’æ¡£é…ç½®](#33-walå½’æ¡£é…ç½®)
  - [4. å¤‡ä»½å­˜å‚¨ä¸ç®¡ç†](#4-å¤‡ä»½å­˜å‚¨ä¸ç®¡ç†)
    - [4.1. å¤‡ä»½å…ƒæ•°æ®ç®¡ç†](#41-å¤‡ä»½å…ƒæ•°æ®ç®¡ç†)
    - [4.2. å¤‡ä»½è®°å½•å‡½æ•°](#42-å¤‡ä»½è®°å½•å‡½æ•°)
  - [5. æ¢å¤ç­–ç•¥è®¾è®¡](#5-æ¢å¤ç­–ç•¥è®¾è®¡)
    - [5.1. å®Œæ•´æ¢å¤æµç¨‹](#51-å®Œæ•´æ¢å¤æµç¨‹)
    - [5.2. pg\_restoreæ¢å¤](#52-pg_restoreæ¢å¤)
    - [5.3. æ—¶é—´ç‚¹æ¢å¤ï¼ˆPITRï¼‰](#53-æ—¶é—´ç‚¹æ¢å¤pitr)
  - [6. ç¾éš¾æ¢å¤è®¾è®¡](#6-ç¾éš¾æ¢å¤è®¾è®¡)
    - [6.1. ç¾éš¾æ¢å¤è®¡åˆ’](#61-ç¾éš¾æ¢å¤è®¡åˆ’)
    - [6.2. å¼‚åœ°å¤‡ä»½è®¾è®¡](#62-å¼‚åœ°å¤‡ä»½è®¾è®¡)
  - [7. å¤‡ä»½éªŒè¯ä¸æµ‹è¯•](#7-å¤‡ä»½éªŒè¯ä¸æµ‹è¯•)
    - [7.1. å¤‡ä»½éªŒè¯å‡½æ•°](#71-å¤‡ä»½éªŒè¯å‡½æ•°)
    - [7.2. æ¢å¤æµ‹è¯•å‡½æ•°](#72-æ¢å¤æµ‹è¯•å‡½æ•°)
  - [8. å®é™…åº”ç”¨æ¡ˆä¾‹](#8-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [8.1. ä¼ä¸šçº§å¤‡ä»½ç³»ç»Ÿè®¾è®¡](#81-ä¼ä¸šçº§å¤‡ä»½ç³»ç»Ÿè®¾è®¡)
  - [9. 2024-2025æœ€æ–°è¶‹åŠ¿](#9-2024-2025æœ€æ–°è¶‹åŠ¿)
    - [9.1. å¤‡ä»½æŠ€æœ¯æ¼”è¿›](#91-å¤‡ä»½æŠ€æœ¯æ¼”è¿›)
    - [9.2. å¤‡ä»½æ–¹æ¡ˆé€‰å‹çŸ©é˜µ](#92-å¤‡ä»½æ–¹æ¡ˆé€‰å‹çŸ©é˜µ)
    - [9.3. äº‘åŸç”Ÿå¤‡ä»½æ¶æ„](#93-äº‘åŸç”Ÿå¤‡ä»½æ¶æ„)
    - [9.4. pgBackResté…ç½®ç¤ºä¾‹](#94-pgbackresté…ç½®ç¤ºä¾‹)
  - [10. å‚è€ƒèµ„æ–™](#10-å‚è€ƒèµ„æ–™)
    - [10.1. æƒå¨æ–‡çŒ®](#101-æƒå¨æ–‡çŒ®)
    - [10.2. åœ¨çº¿èµ„æº](#102-åœ¨çº¿èµ„æº)
    - [10.3. ç›¸å…³æ–‡æ¡£](#103-ç›¸å…³æ–‡æ¡£)

---

## 1. æ¦‚è¿°

æ•°æ®åº“å¤‡ä»½ä¸æ¢å¤æ˜¯ä¿éšœæ•°æ®å®‰å…¨çš„å…³é”®ï¼Œéœ€è¦è®¾è®¡åˆç†çš„å¤‡ä»½ç­–ç•¥å’Œæ¢å¤æµç¨‹ã€‚

### 1.1. å¤‡ä»½æ¢å¤åº”ç”¨åœºæ™¯

```mermaid
mindmap
  root((å¤‡ä»½æ¢å¤åœºæ™¯))
    æ•°æ®ä¿æŠ¤
      é˜²æ­¢æ•°æ®ä¸¢å¤±
      é˜²æ­¢è¯¯æ“ä½œ
      é˜²æ­¢ç¡¬ä»¶æ•…éšœ
    ç¾éš¾æ¢å¤
      æ•°æ®ä¸­å¿ƒæ•…éšœ
      è‡ªç„¶ç¾å®³
      äººä¸ºç ´å
    åˆè§„è¦æ±‚
      æ•°æ®ä¿ç•™
      å®¡è®¡è¦æ±‚
      æ³•è§„è¦æ±‚
    æ•°æ®è¿ç§»
      ç‰ˆæœ¬å‡çº§
      ç¯å¢ƒè¿ç§»
      æ•°æ®å½’æ¡£
```

### 1.2. å¤‡ä»½ç­–ç•¥é€‰æ‹©å†³ç­–æ ‘

```mermaid
flowchart TD
    A[é€‰æ‹©å¤‡ä»½ç­–ç•¥] --> B{æ•°æ®é‡è¦æ€§}

    B -->|å…³é”®æ•°æ®| C[å®Œæ•´å¤‡ä»½+å¢é‡å¤‡ä»½]
    B -->|ä¸€èˆ¬æ•°æ®| D{æ•°æ®å˜åŒ–é¢‘ç‡}

    C --> E[è®¾è®¡å®Œæˆ]

    D -->|é«˜é¢‘å˜åŒ–| F[å®Œæ•´å¤‡ä»½+å¢é‡å¤‡ä»½]
    D -->|ä½é¢‘å˜åŒ–| G[å®Œæ•´å¤‡ä»½]

    F --> E
    G --> E
```

---

## 2. å¤‡ä»½ç­–ç•¥è®¾è®¡

### 2.1. å¤‡ä»½ç±»å‹å¯¹æ¯”

**å¤‡ä»½ç±»å‹å¯¹æ¯”çŸ©é˜µ**ï¼š

| å¤‡ä»½ç±»å‹ | ç‰¹ç‚¹ | æ¢å¤é€Ÿåº¦ | å­˜å‚¨ç©ºé—´ | é€‚ç”¨åœºæ™¯ |
|---------|------|---------|---------|---------|
| **å®Œæ•´å¤‡ä»½** | å¤‡ä»½æ‰€æœ‰æ•°æ® | å¿« | å¤§ | å®šæœŸå…¨é‡å¤‡ä»½ |
| **å¢é‡å¤‡ä»½** | å¤‡ä»½å˜æ›´æ•°æ® | æ…¢ | å° | é¢‘ç¹å¤‡ä»½ |
| **å·®å¼‚å¤‡ä»½** | å¤‡ä»½ä¸Šæ¬¡å®Œæ•´å¤‡ä»½åçš„å˜æ›´ | ä¸­ | ä¸­ | å¹³è¡¡æ–¹æ¡ˆ |
| **è¿ç»­å½’æ¡£** | å®æ—¶å½’æ¡£WAL | å¿« | ä¸­ | é«˜å¯ç”¨ç³»ç»Ÿ |

### 2.2. å¤‡ä»½ç­–ç•¥è®¾è®¡åŸåˆ™

**å¤‡ä»½ç­–ç•¥åŸåˆ™**ï¼š

```text
1. 3-2-1åŸåˆ™ï¼š
   - 3ä»½æ•°æ®å‰¯æœ¬
   - 2ç§ä¸åŒå­˜å‚¨ä»‹è´¨
   - 1ä»½å¼‚åœ°å¤‡ä»½

2. RTOï¼ˆæ¢å¤æ—¶é—´ç›®æ ‡ï¼‰ï¼š
   - å…³é”®ç³»ç»Ÿï¼š< 1å°æ—¶
   - ä¸€èˆ¬ç³»ç»Ÿï¼š< 24å°æ—¶

3. RPOï¼ˆæ¢å¤ç‚¹ç›®æ ‡ï¼‰ï¼š
   - å…³é”®ç³»ç»Ÿï¼š< 15åˆ†é’Ÿ
   - ä¸€èˆ¬ç³»ç»Ÿï¼š< 24å°æ—¶

4. å¤‡ä»½ä¿ç•™ç­–ç•¥ï¼š
   - æ¯æ—¥å¤‡ä»½ï¼šä¿ç•™30å¤©
   - æ¯å‘¨å¤‡ä»½ï¼šä¿ç•™12å‘¨
   - æ¯æœˆå¤‡ä»½ï¼šä¿ç•™12ä¸ªæœˆ
   - æ¯å¹´å¤‡ä»½ï¼šä¿ç•™7å¹´
```

---

## 3. PostgreSQLå¤‡ä»½å®ç°

### 3.1. pg_dumpå®Œæ•´å¤‡ä»½

**pg_dumpå¤‡ä»½è„šæœ¬**ï¼š

```bash
#!/bin/bash
# PostgreSQLå®Œæ•´å¤‡ä»½è„šæœ¬

# é…ç½®
DB_NAME="my_database"
DB_USER="postgres"
BACKUP_DIR="/backup/postgresql"
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="${BACKUP_DIR}/${DB_NAME}_${DATE}.sql"

# åˆ›å»ºå¤‡ä»½ç›®å½•
mkdir -p ${BACKUP_DIR}

# æ‰§è¡Œå¤‡ä»½
pg_dump -U ${DB_USER} -d ${DB_NAME} -F c -f ${BACKUP_FILE}.dump

# å‹ç¼©å¤‡ä»½
gzip ${BACKUP_FILE}.dump

# åˆ é™¤30å¤©å‰çš„å¤‡ä»½
find ${BACKUP_DIR} -name "${DB_NAME}_*.dump.gz" -mtime +30 -delete

echo "Backup completed: ${BACKUP_FILE}.dump.gz"
```

**pg_dumpå¹¶è¡Œå¤‡ä»½**ï¼š

```bash
#!/bin/bash
# PostgreSQLå¹¶è¡Œå¤‡ä»½ï¼ˆå¤§æ•°æ®é‡ï¼‰

DB_NAME="my_database"
DB_USER="postgres"
BACKUP_DIR="/backup/postgresql"
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="${BACKUP_DIR}/${DB_NAME}_${DATE}"

# å¹¶è¡Œå¤‡ä»½ï¼ˆä½¿ç”¨-jå‚æ•°ï¼‰
pg_dump -U ${DB_USER} -d ${DB_NAME} -F d -j 4 -f ${BACKUP_FILE}

# å‹ç¼©å¤‡ä»½ç›®å½•
tar -czf ${BACKUP_FILE}.tar.gz ${BACKUP_FILE}
rm -rf ${BACKUP_FILE}

echo "Parallel backup completed: ${BACKUP_FILE}.tar.gz"
```

### 3.2. pg_basebackupç‰©ç†å¤‡ä»½

**pg_basebackupå¤‡ä»½è„šæœ¬**ï¼š

```bash
#!/bin/bash
# PostgreSQLç‰©ç†å¤‡ä»½è„šæœ¬

DB_USER="postgres"
BACKUP_DIR="/backup/postgresql/base"
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_PATH="${BACKUP_DIR}/base_${DATE}"

# åˆ›å»ºå¤‡ä»½ç›®å½•
mkdir -p ${BACKUP_PATH}

# æ‰§è¡Œç‰©ç†å¤‡ä»½
pg_basebackup -U ${DB_USER} -D ${BACKUP_PATH} -Ft -z -P

# åˆ é™¤30å¤©å‰çš„å¤‡ä»½
find ${BACKUP_DIR} -name "base_*" -type d -mtime +30 -exec rm -rf {} \;

echo "Physical backup completed: ${BACKUP_PATH}"
```

### 3.3. WALå½’æ¡£é…ç½®

**WALå½’æ¡£é…ç½®**ï¼š

```sql
-- postgresql.confé…ç½®
wal_level = replica
archive_mode = on
archive_command = 'cp %p /backup/wal_archive/%f'
archive_timeout = 300  -- 5åˆ†é’Ÿå¼ºåˆ¶å½’æ¡£

-- æ£€æŸ¥å½’æ¡£çŠ¶æ€
SELECT * FROM pg_stat_archiver;
```

**WALå½’æ¡£è„šæœ¬**ï¼š

```bash
#!/bin/bash
# WALå½’æ¡£è„šæœ¬

WAL_FILE=$1
ARCHIVE_DIR="/backup/wal_archive"

# å¤åˆ¶WALæ–‡ä»¶åˆ°å½’æ¡£ç›®å½•
cp ${WAL_FILE} ${ARCHIVE_DIR}/$(basename ${WAL_FILE})

# å‹ç¼©æ—§WALæ–‡ä»¶ï¼ˆ7å¤©å‰ï¼‰
find ${ARCHIVE_DIR} -name "*.wal" -mtime +7 -exec gzip {} \;

# åˆ é™¤30å¤©å‰çš„å‹ç¼©WALæ–‡ä»¶
find ${ARCHIVE_DIR} -name "*.wal.gz" -mtime +30 -delete
```

---

## 4. å¤‡ä»½å­˜å‚¨ä¸ç®¡ç†

### 4.1. å¤‡ä»½å…ƒæ•°æ®ç®¡ç†

**å¤‡ä»½å…ƒæ•°æ®Schemaè®¾è®¡**ï¼š

```sql
CREATE SCHEMA backup_management;

-- å¤‡ä»½è®°å½•è¡¨
CREATE TABLE backup_management.backup_records (
    backup_id BIGSERIAL PRIMARY KEY,
    database_name VARCHAR(100) NOT NULL,
    backup_type VARCHAR(20) NOT NULL CHECK (backup_type IN ('full', 'incremental', 'differential', 'wal')),
    backup_method VARCHAR(50) NOT NULL,  -- pg_dump, pg_basebackup, continuous_archiving
    backup_file_path TEXT NOT NULL,
    backup_size BIGINT NOT NULL,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ,
    duration INTERVAL,
    status VARCHAR(20) NOT NULL CHECK (status IN ('running', 'completed', 'failed')),
    error_message TEXT,
    checksum VARCHAR(64),  -- å¤‡ä»½æ–‡ä»¶æ ¡éªŒå’Œ
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_backup_records_database ON backup_management.backup_records(database_name, start_time DESC);
CREATE INDEX idx_backup_records_status ON backup_management.backup_records(status, start_time DESC);
CREATE INDEX idx_backup_records_type ON backup_management.backup_records(backup_type, start_time DESC);

-- å¤‡ä»½éªŒè¯è®°å½•è¡¨
CREATE TABLE backup_management.backup_verifications (
    verification_id BIGSERIAL PRIMARY KEY,
    backup_id BIGINT NOT NULL REFERENCES backup_management.backup_records(backup_id) ON DELETE CASCADE,
    verification_type VARCHAR(50) NOT NULL,  -- checksum, restore_test, integrity_check
    verification_status VARCHAR(20) NOT NULL CHECK (verification_status IN ('passed', 'failed')),
    verification_result JSONB,
    verified_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    verified_by VARCHAR(100)
);

CREATE INDEX idx_backup_verifications_backup ON backup_management.backup_verifications(backup_id);
CREATE INDEX idx_backup_verifications_status ON backup_management.backup_verifications(verification_status, verified_at DESC);
```

### 4.2. å¤‡ä»½è®°å½•å‡½æ•°

**å¤‡ä»½è®°å½•å‡½æ•°**ï¼š

```sql
-- è®°å½•å¤‡ä»½å¼€å§‹
CREATE OR REPLACE FUNCTION record_backup_start(
    p_database_name VARCHAR,
    p_backup_type VARCHAR,
    p_backup_method VARCHAR,
    p_backup_file_path TEXT
)
RETURNS BIGINT AS $$
DECLARE
    v_backup_id BIGINT;
BEGIN
    INSERT INTO backup_management.backup_records (
        database_name,
        backup_type,
        backup_method,
        backup_file_path,
        backup_size,
        start_time,
        status
    )
    VALUES (
        p_database_name,
        p_backup_type,
        p_backup_method,
        p_backup_file_path,
        0,
        CURRENT_TIMESTAMP,
        'running'
    )
    RETURNING backup_id INTO v_backup_id;

    RETURN v_backup_id;
END;
$$ LANGUAGE plpgsql;

-- è®°å½•å¤‡ä»½å®Œæˆ
CREATE OR REPLACE FUNCTION record_backup_complete(
    p_backup_id BIGINT,
    p_backup_size BIGINT,
    p_checksum VARCHAR DEFAULT NULL
)
RETURNS VOID AS $$
DECLARE
    v_start_time TIMESTAMPTZ;
BEGIN
    SELECT start_time INTO v_start_time
    FROM backup_management.backup_records
    WHERE backup_id = p_backup_id;

    UPDATE backup_management.backup_records
    SET end_time = CURRENT_TIMESTAMP,
        duration = CURRENT_TIMESTAMP - v_start_time,
        backup_size = p_backup_size,
        checksum = p_checksum,
        status = 'completed'
    WHERE backup_id = p_backup_id;
END;
$$ LANGUAGE plpgsql;

-- è®°å½•å¤‡ä»½å¤±è´¥
CREATE OR REPLACE FUNCTION record_backup_failure(
    p_backup_id BIGINT,
    p_error_message TEXT
)
RETURNS VOID AS $$
DECLARE
    v_start_time TIMESTAMPTZ;
BEGIN
    SELECT start_time INTO v_start_time
    FROM backup_management.backup_records
    WHERE backup_id = p_backup_id;

    UPDATE backup_management.backup_records
    SET end_time = CURRENT_TIMESTAMP,
        duration = CURRENT_TIMESTAMP - v_start_time,
        status = 'failed',
        error_message = p_error_message
    WHERE backup_id = p_backup_id;
END;
$$ LANGUAGE plpgsql;
```

---

## 5. æ¢å¤ç­–ç•¥è®¾è®¡

### 5.1. å®Œæ•´æ¢å¤æµç¨‹

**å®Œæ•´æ¢å¤æµç¨‹è®¾è®¡**ï¼š

```mermaid
flowchart TD
    A[å¼€å§‹æ¢å¤] --> B{æ¢å¤ç±»å‹}

    B -->|å®Œæ•´æ¢å¤| C[åœæ­¢æ•°æ®åº“]
    B -->|æ—¶é—´ç‚¹æ¢å¤| D[å‡†å¤‡WALå½’æ¡£]

    C --> E[æ¢å¤åŸºç¡€å¤‡ä»½]
    D --> F[æ¢å¤åŸºç¡€å¤‡ä»½]

    E --> G[å¯åŠ¨æ•°æ®åº“]
    F --> H[åº”ç”¨WALæ—¥å¿—]

    G --> I[éªŒè¯æ•°æ®]
    H --> I

    I --> J{éªŒè¯é€šè¿‡?}
    J -->|æ˜¯| K[æ¢å¤å®Œæˆ]
    J -->|å¦| L[é‡æ–°æ¢å¤]

    L --> B
```

### 5.2. pg_restoreæ¢å¤

**pg_restoreæ¢å¤è„šæœ¬**ï¼š

```bash
#!/bin/bash
# PostgreSQLæ¢å¤è„šæœ¬

BACKUP_FILE=$1
DB_NAME="my_database"
DB_USER="postgres"

# æ£€æŸ¥å¤‡ä»½æ–‡ä»¶æ˜¯å¦å­˜åœ¨
if [ ! -f "${BACKUP_FILE}" ]; then
    echo "Backup file not found: ${BACKUP_FILE}"
    exit 1
fi

# è§£å‹å¤‡ä»½æ–‡ä»¶ï¼ˆå¦‚æœæ˜¯å‹ç¼©çš„ï¼‰
if [[ ${BACKUP_FILE} == *.gz ]]; then
    gunzip -c ${BACKUP_FILE} > ${BACKUP_FILE%.gz}
    BACKUP_FILE=${BACKUP_FILE%.gz}
fi

# åˆ é™¤ç°æœ‰æ•°æ®åº“ï¼ˆè°¨æ…æ“ä½œï¼‰
dropdb -U ${DB_USER} ${DB_NAME}

# åˆ›å»ºæ–°æ•°æ®åº“
createdb -U ${DB_USER} ${DB_NAME}

# æ¢å¤å¤‡ä»½
if [[ ${BACKUP_FILE} == *.dump ]]; then
    # è‡ªå®šä¹‰æ ¼å¼å¤‡ä»½
    pg_restore -U ${DB_USER} -d ${DB_NAME} -j 4 ${BACKUP_FILE}
elif [[ ${BACKUP_FILE} == *.sql ]]; then
    # SQLæ ¼å¼å¤‡ä»½
    psql -U ${DB_USER} -d ${DB_NAME} < ${BACKUP_FILE}
else
    # ç›®å½•æ ¼å¼å¤‡ä»½
    pg_restore -U ${DB_USER} -d ${DB_NAME} -j 4 ${BACKUP_FILE}
fi

echo "Restore completed"
```

### 5.3. æ—¶é—´ç‚¹æ¢å¤ï¼ˆPITRï¼‰

**PITRæ¢å¤è„šæœ¬**ï¼š

```bash
#!/bin/bash
# PostgreSQLæ—¶é—´ç‚¹æ¢å¤è„šæœ¬

BASE_BACKUP_DIR=$1
TARGET_TIME=$2  # æ ¼å¼ï¼š'2024-01-15 10:30:00'
DB_NAME="my_database"
DB_USER="postgres"
RECOVERY_DIR="/var/lib/postgresql/data"

# 1. åœæ­¢æ•°æ®åº“
systemctl stop postgresql

# 2. æ¸…ç©ºæ•°æ®ç›®å½•ï¼ˆä¿ç•™é…ç½®æ–‡ä»¶ï¼‰
rm -rf ${RECOVERY_DIR}/*

# 3. æ¢å¤åŸºç¡€å¤‡ä»½
tar -xzf ${BASE_BACKUP_DIR}/base.tar.gz -C ${RECOVERY_DIR}

# 4. é…ç½®æ¢å¤å‚æ•°
cat >> ${RECOVERY_DIR}/postgresql.conf << EOF
restore_command = 'cp /backup/wal_archive/%f %p'
recovery_target_time = '${TARGET_TIME}'
EOF

# 5. åˆ›å»ºæ¢å¤æ ‡è®°æ–‡ä»¶
touch ${RECOVERY_DIR}/recovery.signal

# 6. å¯åŠ¨æ•°æ®åº“ï¼ˆè‡ªåŠ¨è¿›å…¥æ¢å¤æ¨¡å¼ï¼‰
systemctl start postgresql

# 7. ç­‰å¾…æ¢å¤å®Œæˆ
echo "Waiting for recovery to complete..."
sleep 30

# 8. æ£€æŸ¥æ¢å¤çŠ¶æ€
psql -U ${DB_USER} -d ${DB_NAME} -c "SELECT pg_is_in_recovery();"

echo "PITR recovery completed"
```

---

## 6. ç¾éš¾æ¢å¤è®¾è®¡

### 6.1. ç¾éš¾æ¢å¤è®¡åˆ’

**ç¾éš¾æ¢å¤è®¡åˆ’Schemaè®¾è®¡**ï¼š

```sql
CREATE SCHEMA disaster_recovery;

-- ç¾éš¾æ¢å¤è®¡åˆ’è¡¨
CREATE TABLE disaster_recovery.recovery_plans (
    plan_id SERIAL PRIMARY KEY,
    plan_name VARCHAR(200) NOT NULL UNIQUE,
    database_name VARCHAR(100) NOT NULL,
    rto_minutes INTEGER NOT NULL,  -- æ¢å¤æ—¶é—´ç›®æ ‡ï¼ˆåˆ†é’Ÿï¼‰
    rpo_minutes INTEGER NOT NULL,  -- æ¢å¤ç‚¹ç›®æ ‡ï¼ˆåˆ†é’Ÿï¼‰
    backup_strategy TEXT NOT NULL,
    recovery_procedure TEXT NOT NULL,
    contact_person VARCHAR(200),
    contact_phone VARCHAR(50),
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- ç¾éš¾æ¢å¤æ¼”ç»ƒè®°å½•è¡¨
CREATE TABLE disaster_recovery.recovery_drills (
    drill_id BIGSERIAL PRIMARY KEY,
    plan_id INTEGER NOT NULL REFERENCES disaster_recovery.recovery_plans(plan_id),
    drill_date TIMESTAMPTZ NOT NULL,
    drill_type VARCHAR(50) NOT NULL,  -- full, partial, table_level
    recovery_time_minutes INTEGER,
    data_loss_minutes INTEGER,
    status VARCHAR(20) NOT NULL CHECK (status IN ('success', 'failed', 'partial')),
    issues TEXT,
    lessons_learned TEXT,
    conducted_by VARCHAR(200),
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_recovery_drills_plan ON disaster_recovery.recovery_drills(plan_id, drill_date DESC);
```

### 6.2. å¼‚åœ°å¤‡ä»½è®¾è®¡

**å¼‚åœ°å¤‡ä»½Schemaè®¾è®¡**ï¼š

```sql
-- å¼‚åœ°å¤‡ä»½é…ç½®è¡¨
CREATE TABLE backup_management.remote_backup_configs (
    config_id SERIAL PRIMARY KEY,
    database_name VARCHAR(100) NOT NULL,
    remote_type VARCHAR(50) NOT NULL,  -- s3, azure_blob, gcs, ftp, rsync
    remote_endpoint TEXT NOT NULL,
    remote_path TEXT NOT NULL,
    credentials JSONB NOT NULL,  -- åŠ å¯†å­˜å‚¨å‡­æ®
    encryption_key_id VARCHAR(50),
    is_active BOOLEAN DEFAULT TRUE,
    sync_schedule VARCHAR(100),  -- cronè¡¨è¾¾å¼
    last_sync_at TIMESTAMPTZ,
    sync_status VARCHAR(20),
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- å¼‚åœ°å¤‡ä»½è®°å½•è¡¨
CREATE TABLE backup_management.remote_backup_records (
    record_id BIGSERIAL PRIMARY KEY,
    backup_id BIGINT NOT NULL REFERENCES backup_management.backup_records(backup_id),
    config_id INTEGER NOT NULL REFERENCES backup_management.remote_backup_configs(config_id),
    remote_file_path TEXT NOT NULL,
    sync_start_time TIMESTAMPTZ NOT NULL,
    sync_end_time TIMESTAMPTZ,
    sync_status VARCHAR(20) NOT NULL CHECK (sync_status IN ('pending', 'syncing', 'completed', 'failed')),
    error_message TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_remote_backup_records_backup ON backup_management.remote_backup_records(backup_id);
CREATE INDEX idx_remote_backup_records_config ON backup_management.remote_backup_records(config_id, sync_start_time DESC);
```

---

## 7. å¤‡ä»½éªŒè¯ä¸æµ‹è¯•

### 7.1. å¤‡ä»½éªŒè¯å‡½æ•°

**å¤‡ä»½éªŒè¯å‡½æ•°**ï¼š

```sql
-- å¤‡ä»½å®Œæ•´æ€§éªŒè¯å‡½æ•°
CREATE OR REPLACE FUNCTION verify_backup_integrity(
    p_backup_id BIGINT
)
RETURNS BOOLEAN AS $$
DECLARE
    v_backup_record RECORD;
    v_file_checksum VARCHAR(64);
    v_stored_checksum VARCHAR(64);
BEGIN
    -- è·å–å¤‡ä»½è®°å½•
    SELECT * INTO v_backup_record
    FROM backup_management.backup_records
    WHERE backup_id = p_backup_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Backup record not found: %', p_backup_id;
    END IF;

    -- è®¡ç®—æ–‡ä»¶æ ¡éªŒå’Œï¼ˆä½¿ç”¨sha256ï¼‰
    -- æ³¨æ„ï¼šè¿™éœ€è¦åœ¨åº”ç”¨å±‚å®ç°ï¼Œå› ä¸ºPostgreSQLæ— æ³•ç›´æ¥è¯»å–æ–‡ä»¶ç³»ç»Ÿ

    -- æ¯”è¾ƒæ ¡éªŒå’Œ
    IF v_file_checksum != v_stored_checksum THEN
        INSERT INTO backup_management.backup_verifications (
            backup_id,
            verification_type,
            verification_status,
            verification_result
        )
        VALUES (
            p_backup_id,
            'checksum',
            'failed',
            jsonb_build_object('error', 'Checksum mismatch')
        );
        RETURN FALSE;
    END IF;

    -- è®°å½•éªŒè¯æˆåŠŸ
    INSERT INTO backup_management.backup_verifications (
        backup_id,
        verification_type,
        verification_status,
        verification_result
    )
    VALUES (
        p_backup_id,
        'checksum',
        'passed',
        jsonb_build_object('checksum', v_file_checksum)
    );

    RETURN TRUE;
END;
$$ LANGUAGE plpgsql;
```

### 7.2. æ¢å¤æµ‹è¯•å‡½æ•°

**æ¢å¤æµ‹è¯•å‡½æ•°**ï¼š

```sql
-- æ¢å¤æµ‹è¯•å‡½æ•°ï¼ˆåœ¨æµ‹è¯•ç¯å¢ƒï¼‰
CREATE OR REPLACE FUNCTION test_backup_restore(
    p_backup_id BIGINT,
    p_test_database_name VARCHAR
)
RETURNS TABLE (
    test_status VARCHAR,
    restore_time INTERVAL,
    data_verification BOOLEAN
) AS $$
DECLARE
    v_backup_record RECORD;
    v_start_time TIMESTAMPTZ;
    v_end_time TIMESTAMPTZ;
    v_restore_success BOOLEAN := FALSE;
    v_data_verified BOOLEAN := FALSE;
BEGIN
    -- è·å–å¤‡ä»½è®°å½•
    SELECT * INTO v_backup_record
    FROM backup_management.backup_records
    WHERE backup_id = p_backup_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Backup record not found: %', p_backup_id;
    END IF;

    v_start_time := CURRENT_TIMESTAMP;

    -- æ‰§è¡Œæ¢å¤ï¼ˆè¿™é‡Œåº”è¯¥è°ƒç”¨æ¢å¤è„šæœ¬ï¼‰
    -- ç®€åŒ–ç¤ºä¾‹ï¼šå‡è®¾æ¢å¤æˆåŠŸ
    v_restore_success := TRUE;

    v_end_time := CURRENT_TIMESTAMP;

    -- éªŒè¯æ•°æ®ï¼ˆæ£€æŸ¥å…³é”®è¡¨çš„æ•°æ®é‡ï¼‰
    -- ç®€åŒ–ç¤ºä¾‹ï¼šå‡è®¾éªŒè¯é€šè¿‡
    v_data_verified := TRUE;

    -- è®°å½•æµ‹è¯•ç»“æœ
    INSERT INTO backup_management.backup_verifications (
        backup_id,
        verification_type,
        verification_status,
        verification_result
    )
    VALUES (
        p_backup_id,
        'restore_test',
        CASE WHEN v_restore_success AND v_data_verified THEN 'passed' ELSE 'failed' END,
        jsonb_build_object(
            'restore_time', v_end_time - v_start_time,
            'data_verified', v_data_verified
        )
    );

    RETURN QUERY
    SELECT
        CASE WHEN v_restore_success AND v_data_verified THEN 'passed' ELSE 'failed' END,
        v_end_time - v_start_time,
        v_data_verified;
END;
$$ LANGUAGE plpgsql;
```

---

## 8. å®é™…åº”ç”¨æ¡ˆä¾‹

### 8.1. ä¼ä¸šçº§å¤‡ä»½ç³»ç»Ÿè®¾è®¡

**å®Œæ•´å¤‡ä»½ç³»ç»ŸSchemaè®¾è®¡**ï¼š

```sql
CREATE SCHEMA enterprise_backup;

-- å¤‡ä»½ä»»åŠ¡è¡¨
CREATE TABLE enterprise_backup.backup_jobs (
    job_id BIGSERIAL PRIMARY KEY,
    job_name VARCHAR(200) NOT NULL UNIQUE,
    database_name VARCHAR(100) NOT NULL,
    backup_type VARCHAR(20) NOT NULL,
    schedule_cron VARCHAR(100) NOT NULL,  -- cronè¡¨è¾¾å¼
    retention_days INTEGER NOT NULL DEFAULT 30,
    is_active BOOLEAN DEFAULT TRUE,
    last_run_at TIMESTAMPTZ,
    next_run_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- å¤‡ä»½ä»»åŠ¡æ‰§è¡Œè®°å½•è¡¨
CREATE TABLE enterprise_backup.backup_job_executions (
    execution_id BIGSERIAL PRIMARY KEY,
    job_id BIGINT NOT NULL REFERENCES enterprise_backup.backup_jobs(job_id),
    backup_id BIGINT REFERENCES backup_management.backup_records(backup_id),
    execution_start_time TIMESTAMPTZ NOT NULL,
    execution_end_time TIMESTAMPTZ,
    execution_status VARCHAR(20) NOT NULL CHECK (execution_status IN ('running', 'completed', 'failed', 'skipped')),
    error_message TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_backup_job_executions_job ON enterprise_backup.backup_job_executions(job_id, execution_start_time DESC);
CREATE INDEX idx_backup_job_executions_status ON enterprise_backup.backup_job_executions(execution_status, execution_start_time DESC);

-- å¤‡ä»½ä»»åŠ¡è°ƒåº¦å‡½æ•°
CREATE OR REPLACE FUNCTION schedule_backup_jobs()
RETURNS VOID AS $$
DECLARE
    v_job RECORD;
    v_next_run TIMESTAMPTZ;
BEGIN
    FOR v_job IN
        SELECT * FROM enterprise_backup.backup_jobs
        WHERE is_active = TRUE
    LOOP
        -- è®¡ç®—ä¸‹æ¬¡è¿è¡Œæ—¶é—´ï¼ˆç®€åŒ–ç¤ºä¾‹ï¼‰
        -- å®é™…åº”è¯¥ä½¿ç”¨cronè§£æåº“
        v_next_run := CURRENT_TIMESTAMP + INTERVAL '1 day';

        UPDATE enterprise_backup.backup_jobs
        SET next_run_at = v_next_run
        WHERE job_id = v_job.job_id;
    END LOOP;
END;
$$ LANGUAGE plpgsql;
```

---

## 9. 2024-2025æœ€æ–°è¶‹åŠ¿

### 9.1. å¤‡ä»½æŠ€æœ¯æ¼”è¿›

```mermaid
timeline
    title æ•°æ®åº“å¤‡ä»½æŠ€æœ¯æ¼”è¿›
    2010 : ä¼ ç»Ÿå¤‡ä»½
         : pg_dump/mysqldump
    2015 : å¢é‡å¤‡ä»½
         : WALå½’æ¡£
    2018 : äº‘åŸç”Ÿå¤‡ä»½
         : S3å­˜å‚¨
    2021 : æŒç»­æ•°æ®ä¿æŠ¤
         : CDP
    2024 : æ™ºèƒ½å¤‡ä»½
         : AIè°ƒåº¦
    2025 : é›¶RPOæ–¹æ¡ˆ
         : å®æ—¶åŒæ­¥
```

### 9.2. å¤‡ä»½æ–¹æ¡ˆé€‰å‹çŸ©é˜µ

| æ–¹æ¡ˆ | RPO | RTO | æˆæœ¬ | å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ |
|------|-----|-----|------|--------|---------|
| **pg_dump** | é«˜ | ä¸­ | ä½ | ä½ | å°å‹ç³»ç»Ÿ |
| **WALå½’æ¡£+PITR** | ä½ | ä¸­ | ä¸­ | ä¸­ | ç”Ÿäº§ç³»ç»Ÿ |
| **æµå¤åˆ¶** | æä½ | ä½ | ä¸­ | ä¸­ | é«˜å¯ç”¨ |
| **pgBackRest** | ä½ | ä½ | ä¸­ | ä¸­ | ä¼ä¸šçº§ |
| **Barman** | ä½ | ä½ | ä¸­ | ä¸­ | ç¾å¤‡ |
| **äº‘æ‰˜ç®¡å¤‡ä»½** | æä½ | ä½ | é«˜ | ä½ | äº‘åŸç”Ÿ |

### 9.3. äº‘åŸç”Ÿå¤‡ä»½æ¶æ„

```mermaid
flowchart TB
    subgraph ç”Ÿäº§ç¯å¢ƒ
        P1[Primary DB]
        P2[Standby DB]
    end

    subgraph å¤‡ä»½æœåŠ¡
        B1[å¤‡ä»½è°ƒåº¦å™¨]
        B2[WALå½’æ¡£å™¨]
        B3[å¢é‡å¤‡ä»½å™¨]
    end

    subgraph äº‘å­˜å‚¨
        S1[S3/å¯¹è±¡å­˜å‚¨]
        S2[è·¨åŒºåŸŸå¤åˆ¶]
        S3[å½’æ¡£å­˜å‚¨]
    end

    P1 --> B2
    P1 --> B3
    B1 --> B2
    B1 --> B3
    B2 --> S1
    B3 --> S1
    S1 --> S2
    S1 --> S3

    P1 --> P2
```

### 9.4. pgBackResté…ç½®ç¤ºä¾‹

```ini
# pgbackrest.conf
[global]
repo1-type=s3
repo1-s3-bucket=my-backup-bucket
repo1-s3-region=us-east-1
repo1-path=/backups
repo1-retention-full=4
repo1-retention-diff=16

compress-type=zst
compress-level=3
process-max=4

[main]
pg1-path=/var/lib/postgresql/data
pg1-port=5432
```

```bash
# å…¨é‡å¤‡ä»½
pgbackrest --stanza=main backup --type=full

# å¢é‡å¤‡ä»½
pgbackrest --stanza=main backup --type=incr

# PITRæ¢å¤
pgbackrest --stanza=main restore --target-time="2025-12-01 10:00:00"
```

---

## 10. å‚è€ƒèµ„æ–™

### 10.1. æƒå¨æ–‡çŒ®

**å¤‡ä»½ä¸æ¢å¤**ï¼š

- PostgreSQL Global Development Group "Backup and Restore"
- "Database Reliability Engineering" by O'Reilly

### 10.2. åœ¨çº¿èµ„æº

| èµ„æº | URL | æè¿° |
|------|-----|------|
| **PostgreSQLå¤‡ä»½** | <https://www.postgresql.org/docs/current/backup.html> | å®˜æ–¹æ–‡æ¡£ |
| **pgBackRest** | <https://pgbackrest.org/> | ä¼ä¸šçº§å¤‡ä»½ |
| **Barman** | <https://pgbarman.org/> | ç¾å¤‡å·¥å…· |

### 10.3. ç›¸å…³æ–‡æ¡£

- [07.23-æ•°æ®åº“å®‰å…¨è®¾è®¡æ¨¡å¼](./07.23-æ•°æ®åº“å®‰å…¨è®¾è®¡æ¨¡å¼.md)
- [07.17-åˆ†å¸ƒå¼æ•°æ®åº“è®¾è®¡æ¨¡å¼](./07.17-åˆ†å¸ƒå¼æ•°æ®åº“è®¾è®¡æ¨¡å¼.md)

---

**æœ€åæ›´æ–°**ï¼š2025-12-01
**ç»´æŠ¤è€…**ï¼šData-Science Team
**çŠ¶æ€**ï¼šå·²å®Œæˆ âœ…
**ç‰ˆæœ¬**ï¼šv2.0 (å¢å¼ºç‰ˆ)
