# 数据库设计模式常见问题FAQ：问题解答与最佳实践

> **创建日期**：2025-01-15
> **最后更新**：2025-01-15
> **版本**：v1.0
> **状态**：实施中

---

## 📋 目录

- [数据库设计模式常见问题FAQ：问题解答与最佳实践](#数据库设计模式常见问题faq问题解答与最佳实践)
  - [📋 目录](#-目录)
  - [1. 概述](#1-概述)
    - [1.1. 问题分类](#11-问题分类)
  - [2. Schema设计常见问题](#2-schema设计常见问题)
    - [2.1. 命名规范问题](#21-命名规范问题)
    - [2.2. 数据类型选择问题](#22-数据类型选择问题)
    - [2.3. 范式化问题](#23-范式化问题)
  - [3. 性能优化常见问题](#3-性能优化常见问题)
    - [3.1. 索引设计问题](#31-索引设计问题)
    - [3.2. 查询优化问题](#32-查询优化问题)
  - [4. 安全设计常见问题](#4-安全设计常见问题)
    - [4.1. 权限控制问题](#41-权限控制问题)
  - [5. 分布式设计常见问题](#5-分布式设计常见问题)
    - [5.1. 事务处理问题](#51-事务处理问题)
  - [6. 专用数据库常见问题](#6-专用数据库常见问题)
    - [6.1. 向量数据库问题](#61-向量数据库问题)
    - [6.2. 知识图谱问题](#62-知识图谱问题)
    - [6.3. 时序数据库问题](#63-时序数据库问题)
  - [7. 设计模式选择常见问题](#7-设计模式选择常见问题)
    - [7.1. 模式对比问题](#71-模式对比问题)
  - [8. 工具使用常见问题](#8-工具使用常见问题)
    - [8.1. 版本管理问题](#81-版本管理问题)
  - [9. 参考资料](#9-参考资料)

---

## 1. 概述

本文档收集数据库设计模式中的常见问题，提供详细的解答和最佳实践建议。

### 1.1. 问题分类

```mermaid
mindmap
  root((常见问题))
    Schema设计
      命名规范
      数据类型选择
      范式化问题
    性能优化
      索引设计
      查询优化
      分区设计
    安全设计
      权限控制
      数据加密
      审计日志
    分布式设计
      事务处理
      数据一致性
      数据同步
    专用数据库
      向量数据库
      知识图谱
      时序数据库
    设计模式选择
      模式对比
      选择决策
      模式组合
```

---

## 2. Schema设计常见问题

### 2.1. 命名规范问题

**Q1: 表名应该使用单数还是复数？**

**A**: 推荐使用复数形式，因为表存储的是多个实体的集合。

```sql
-- 推荐：复数形式
CREATE TABLE users (...);
CREATE TABLE orders (...);
CREATE TABLE products (...);

-- 不推荐：单数形式
CREATE TABLE user (...);
CREATE TABLE order (...);
```

**Q2: 字段名应该使用下划线还是驼峰命名？**

**A**: 推荐使用小写字母+下划线（snake_case），因为：

- SQL标准兼容性更好
- 避免大小写敏感问题
- 更易读

```sql
-- 推荐：下划线命名
CREATE TABLE users (
    user_id BIGSERIAL PRIMARY KEY,
    created_at TIMESTAMPTZ NOT NULL
);

-- 不推荐：驼峰命名
CREATE TABLE users (
    userId BIGSERIAL PRIMARY KEY,
    createdAt TIMESTAMPTZ NOT NULL
);
```

**Q3: 索引命名规范是什么？**

**A**: 推荐使用 `idx_` 前缀 + 表名 + 字段名。

```sql
-- 推荐
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_orders_user_id ON orders(user_id);

-- 不推荐
CREATE INDEX email_index ON users(email);
CREATE INDEX user_id_idx ON orders(user_id);
```

### 2.2. 数据类型选择问题

**Q4: 什么时候使用VARCHAR，什么时候使用TEXT？**

**A**:

- **VARCHAR(n)**: 当字段有明确的长度上限时使用（如用户名、邮箱）
- **TEXT**: 当字段长度不确定或可能很长时使用（如文章内容、描述）

```sql
-- 推荐：有长度限制使用VARCHAR
CREATE TABLE users (
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL
);

-- 推荐：长度不确定使用TEXT
CREATE TABLE articles (
    title VARCHAR(200) NOT NULL,
    content TEXT NOT NULL
);
```

**Q5: 时间字段应该使用TIMESTAMP还是TIMESTAMPTZ？**

**A**: 推荐使用 `TIMESTAMPTZ`（带时区），因为：

- 自动处理时区转换
- 避免时区相关bug
- 符合国际化需求

```sql
-- 推荐：使用TIMESTAMPTZ
CREATE TABLE events (
    event_id BIGSERIAL PRIMARY KEY,
    event_time TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- 不推荐：使用TIMESTAMP（不带时区）
CREATE TABLE events (
    event_id BIGSERIAL PRIMARY KEY,
    event_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);
```

**Q6: 金额字段应该使用什么数据类型？**

**A**: 推荐使用 `NUMERIC` 或 `DECIMAL`，避免使用 `FLOAT` 或 `DOUBLE`，因为：

- 精确计算，避免浮点数误差
- 适合金融场景

```sql
-- 推荐：使用NUMERIC
CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    total_amount NUMERIC(12, 2) NOT NULL  -- 12位数字，2位小数
);

-- 不推荐：使用FLOAT
CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    total_amount FLOAT NOT NULL  -- 可能有精度问题
);
```

### 2.3. 范式化问题

**Q7: 应该完全范式化还是反范式化？**

**A**: 取决于应用场景：

- **OLTP系统**：推荐范式化（减少冗余、保证一致性）
- **OLAP系统**：可以反范式化（提高查询性能）
- **混合场景**：核心数据范式化，统计数据反范式化

```sql
-- OLTP：范式化设计
CREATE TABLE users (
    user_id BIGSERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL
);

CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(user_id),
    total_amount NUMERIC(12, 2) NOT NULL
);

-- OLAP：反范式化设计（包含用户信息）
CREATE TABLE order_summary (
    order_id BIGSERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL,  -- 反范式化
    total_amount NUMERIC(12, 2) NOT NULL
);
```

---

## 3. 性能优化常见问题

### 3.1. 索引设计问题

**Q8: 应该为所有外键创建索引吗？**

**A**: 是的，推荐为所有外键创建索引，因为：

- 提高JOIN性能
- 提高外键约束检查性能
- 提高DELETE CASCADE性能

```sql
-- 推荐：外键字段创建索引
CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(user_id)
);

CREATE INDEX idx_orders_user_id ON orders(user_id);

-- 不推荐：外键字段没有索引
CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(user_id)
);
-- 缺少索引
```

**Q9: 复合索引的字段顺序如何选择？**

**A**: 遵循"最左前缀"原则，将选择性高的字段放在前面，或者将WHERE条件中最常用的字段放在前面。

```sql
-- 推荐：选择性高的字段在前
CREATE INDEX idx_orders_user_status_date
ON orders(user_id, status, created_at);
-- 如果查询经常使用 user_id + status，这个顺序合适

-- 如果查询经常使用 status + created_at，应该调整顺序
CREATE INDEX idx_orders_status_date_user
ON orders(status, created_at, user_id);
```

**Q10: 什么时候使用部分索引？**

**A**: 当查询只涉及表中的一部分数据时，使用部分索引可以：

- 减少索引大小
- 提高索引效率
- 减少维护成本

```sql
-- 推荐：只索引活跃用户
CREATE INDEX idx_users_active_email
ON users(email)
WHERE status = 'active';

-- 推荐：只索引未完成的订单
CREATE INDEX idx_orders_pending
ON orders(user_id, created_at)
WHERE status IN ('pending', 'processing');
```

### 3.2. 查询优化问题

**Q11: 如何优化慢查询？**

**A**: 优化步骤：

1. 使用 `EXPLAIN ANALYZE` 分析查询计划
2. 检查是否使用了索引
3. 检查是否有全表扫描
4. 优化JOIN顺序
5. 考虑使用物化视图

```sql
-- 1. 分析查询计划
EXPLAIN ANALYZE
SELECT u.username, o.total_amount
FROM users u
JOIN orders o ON u.user_id = o.user_id
WHERE u.status = 'active'
ORDER BY o.created_at DESC
LIMIT 10;

-- 2. 如果发现全表扫描，添加索引
CREATE INDEX idx_users_status ON users(status);
CREATE INDEX idx_orders_user_created ON orders(user_id, created_at DESC);

-- 3. 如果查询频繁，考虑物化视图
CREATE MATERIALIZED VIEW mv_active_user_orders AS
SELECT u.username, o.total_amount, o.created_at
FROM users u
JOIN orders o ON u.user_id = o.user_id
WHERE u.status = 'active';

CREATE INDEX ON mv_active_user_orders(created_at DESC);
```

**Q12: 如何优化分页查询？**

**A**: 使用游标分页（cursor-based pagination）替代OFFSET分页，特别是大数据量时。

```sql
-- 不推荐：OFFSET分页（大数据量时性能差）
SELECT * FROM orders
ORDER BY created_at DESC
LIMIT 20 OFFSET 10000;  -- 需要跳过10000行

-- 推荐：游标分页
SELECT * FROM orders
WHERE created_at < '2025-01-01'  -- 上次查询的最后时间
ORDER BY created_at DESC
LIMIT 20;
```

---

## 4. 安全设计常见问题

### 4.1. 权限控制问题

**Q13: 如何实现多租户数据隔离？**

**A**: 推荐使用Row Level Security (RLS)实现行级安全。

```sql
-- 启用RLS
ALTER TABLE orders ENABLE ROW LEVEL SECURITY;

-- 创建策略函数
CREATE OR REPLACE FUNCTION get_current_tenant_id()
RETURNS BIGINT AS $$
BEGIN
    RETURN current_setting('app.current_tenant_id', TRUE)::BIGINT;
END;
$$ LANGUAGE plpgsql STABLE;

-- 创建RLS策略
CREATE POLICY tenant_isolation_policy ON orders
    FOR ALL
    USING (tenant_id = get_current_tenant_id())
    WITH CHECK (tenant_id = get_current_tenant_id());
```

**Q14: 敏感数据如何加密存储？**

**A**: 使用PostgreSQL的 `pgcrypto` 扩展进行字段级加密。

```sql
-- 启用pgcrypto扩展
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- 加密存储密码
CREATE TABLE users (
    user_id BIGSERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    password_hash TEXT NOT NULL  -- 使用pgcrypto加密
);

-- 插入加密数据
INSERT INTO users (username, password_hash)
VALUES ('alice', crypt('password123', gen_salt('bf')));

-- 验证密码
SELECT * FROM users
WHERE username = 'alice'
  AND password_hash = crypt('password123', password_hash);
```

---

## 5. 分布式设计常见问题

### 5.1. 事务处理问题

**Q15: 分布式事务如何选择？2PC还是Saga？**

**A**:

- **2PC**: 适合强一致性要求、短事务、参与方少的场景
- **Saga**: 适合最终一致性可接受、长事务、参与方多的场景

```sql
-- 2PC：适合强一致性
-- 优点：强一致性
-- 缺点：性能低、阻塞时间长

-- Saga：适合最终一致性
-- 优点：性能高、不阻塞
-- 缺点：需要补偿逻辑
```

**Q16: 如何保证分布式数据一致性？**

**A**: 根据业务需求选择一致性模型：

- **强一致性**: 使用2PC、分布式锁
- **最终一致性**: 使用Saga、事件溯源
- **弱一致性**: 使用异步复制

---

## 6. 专用数据库常见问题

### 6.1. 向量数据库问题

**Q17: 什么时候使用向量数据库？**

**A**: 当需要相似度搜索、推荐系统、AI应用时使用向量数据库。

```sql
-- 使用pgvector扩展
CREATE EXTENSION IF NOT EXISTS vector;

CREATE TABLE products (
    product_id BIGSERIAL PRIMARY KEY,
    product_name VARCHAR(200) NOT NULL,
    embedding vector(384) NOT NULL  -- 384维向量
);

-- 创建向量索引
CREATE INDEX idx_products_embedding ON products
USING hnsw (embedding vector_cosine_ops);

-- 相似度搜索
SELECT product_id, product_name,
       1 - (embedding <=> $1::vector) AS similarity
FROM products
ORDER BY embedding <=> $1::vector
LIMIT 10;
```

**Q18: 向量维度如何选择？**

**A**: 取决于使用的嵌入模型：

- **OpenAI text-embedding-ada-002**: 1536维
- **sentence-transformers**: 384维或768维
- **BERT**: 768维

### 6.2. 知识图谱问题

**Q19: 知识图谱应该用关系数据库还是图数据库？**

**A**:

- **关系数据库**: 适合小规模、简单查询、已有PostgreSQL基础设施
- **图数据库**: 适合大规模、复杂图查询、需要图算法

```sql
-- 关系数据库存储知识图谱（三元组）
CREATE TABLE relations (
    relation_id BIGSERIAL PRIMARY KEY,
    subject_id BIGINT NOT NULL,
    predicate VARCHAR(100) NOT NULL,
    object_id BIGINT NOT NULL
);

-- 图数据库（Neo4j Cypher）
CREATE (alice:Person {name: "Alice"})
CREATE (bob:Person {name: "Bob"})
CREATE (alice)-[:KNOWS]->(bob)
```

### 6.3. 时序数据库问题

**Q20: 什么时候使用时序数据库？**

**A**: 当需要存储时间序列数据、IoT数据、监控数据时使用时序数据库。

```sql
-- 使用TimescaleDB
CREATE TABLE sensor_data (
    time TIMESTAMPTZ NOT NULL,
    device_id BIGINT NOT NULL,
    sensor_type VARCHAR(50) NOT NULL,
    value DOUBLE PRECISION NOT NULL,
    PRIMARY KEY (time, device_id, sensor_type)
);

-- 转换为超表
SELECT create_hypertable('sensor_data', 'time');
```

---

## 7. 设计模式选择常见问题

### 7.1. 模式对比问题

**Q21: 多租户应该选择哪种模式？**

**A**:

- **独立数据库**: 大型企业客户、高隔离需求
- **共享数据库+Schema**: 中型SaaS、中等隔离需求
- **共享数据库+RLS**: 小型SaaS、低隔离需求

**Q22: 什么时候使用列式数据库？**

**A**: 当需要：

- OLAP分析查询
- 大数据量聚合
- 数据仓库场景

```sql
-- ClickHouse列式数据库
CREATE TABLE analytics.events (
    event_time DateTime,
    user_id UUID,
    event_type String,
    properties Map(String, String)
) ENGINE = MergeTree()
PARTITION BY toYYYYMM(event_time)
ORDER BY (event_time, user_id);
```

---

## 8. 工具使用常见问题

### 8.1. 版本管理问题

**Q23: Flyway和Liquibase如何选择？**

**A**:

- **Flyway**: 简单、基于SQL、适合小团队
- **Liquibase**: 功能丰富、支持多种格式、适合大团队

**Q24: 如何回滚数据库迁移？**

**A**:

- **Flyway**: 使用 `flyway undo`（需要商业版）或手动编写回滚脚本
- **Liquibase**: 使用 `rollback` 标签定义回滚逻辑

```xml
<!-- Liquibase回滚示例 -->
<changeSet id="1" author="developer">
    <createTable tableName="users">
        <column name="id" type="BIGSERIAL">
            <constraints primaryKey="true"/>
        </column>
    </createTable>
    <rollback>
        <dropTable tableName="users"/>
    </rollback>
</changeSet>
```

---

## 9. 参考资料

- [数据库设计模式最佳实践总结](./07.29-数据库设计模式最佳实践总结.md)
- [数据库设计模式总结与索引](./07.27-数据库设计模式总结与索引.md)
- [数据库设计评审与质量保证](./07.26-数据库设计评审与质量保证.md)

---

**最后更新**：2025-01-15
**维护者**：Data-Science Team
**状态**：实施中
