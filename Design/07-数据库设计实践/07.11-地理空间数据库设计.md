# åœ°ç†ç©ºé—´æ•°æ®åº“è®¾è®¡ï¼šPostGISä¸ç©ºé—´æ•°æ®å»ºæ¨¡

> **åˆ›å»ºæ—¥æœŸ**ï¼š2025-01-15
> **æœ€åæ›´æ–°**ï¼š2025-12-01
> **ç‰ˆæœ¬**ï¼šv2.0 (å¢å¼ºç‰ˆ)
> **çŠ¶æ€**ï¼šå·²å®Œæˆ âœ…

---

## ğŸ“‹ ç›®å½•

- [åœ°ç†ç©ºé—´æ•°æ®åº“è®¾è®¡ï¼šPostGISä¸ç©ºé—´æ•°æ®å»ºæ¨¡](#åœ°ç†ç©ºé—´æ•°æ®åº“è®¾è®¡postgisä¸ç©ºé—´æ•°æ®å»ºæ¨¡)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1. åœ°ç†ç©ºé—´åº”ç”¨åœºæ™¯](#11-åœ°ç†ç©ºé—´åº”ç”¨åœºæ™¯)
    - [1.2. ç©ºé—´æ•°æ®åº“é€‰æ‹©å†³ç­–æ ‘](#12-ç©ºé—´æ•°æ®åº“é€‰æ‹©å†³ç­–æ ‘)
  - [2. åœ°ç†ç©ºé—´æ•°æ®ç±»å‹](#2-åœ°ç†ç©ºé—´æ•°æ®ç±»å‹)
    - [2.1. PostGISå‡ ä½•ç±»å‹](#21-postgiså‡ ä½•ç±»å‹)
    - [2.2. åœ°ç†åæ ‡ç³»ç»Ÿ](#22-åœ°ç†åæ ‡ç³»ç»Ÿ)
  - [3. ç©ºé—´ç´¢å¼•è®¾è®¡](#3-ç©ºé—´ç´¢å¼•è®¾è®¡)
    - [3.1. GISTç´¢å¼•](#31-gistç´¢å¼•)
    - [3.2. ç©ºé—´ç´¢å¼•é€‰æ‹©å†³ç­–æ ‘](#32-ç©ºé—´ç´¢å¼•é€‰æ‹©å†³ç­–æ ‘)
    - [3.3. ç´¢å¼•ç»´æŠ¤](#33-ç´¢å¼•ç»´æŠ¤)
  - [4. ç©ºé—´æŸ¥è¯¢è®¾è®¡](#4-ç©ºé—´æŸ¥è¯¢è®¾è®¡)
    - [4.1. é™„è¿‘æœç´¢ï¼ˆKNNæŸ¥è¯¢ï¼‰](#41-é™„è¿‘æœç´¢knnæŸ¥è¯¢)
    - [4.2. èŒƒå›´æŸ¥è¯¢](#42-èŒƒå›´æŸ¥è¯¢)
    - [4.3. ç©ºé—´å…³ç³»æŸ¥è¯¢](#43-ç©ºé—´å…³ç³»æŸ¥è¯¢)
    - [4.4. ç©ºé—´èšåˆæŸ¥è¯¢](#44-ç©ºé—´èšåˆæŸ¥è¯¢)
  - [5. åœ°ç†ç©ºé—´åº”ç”¨æ¡ˆä¾‹](#5-åœ°ç†ç©ºé—´åº”ç”¨æ¡ˆä¾‹)
    - [5.1. ä½ç½®æœåŠ¡ï¼ˆLBSï¼‰Schemaè®¾è®¡](#51-ä½ç½®æœåŠ¡lbsschemaè®¾è®¡)
    - [5.2. è·¯å¾„è§„åˆ’Schemaè®¾è®¡](#52-è·¯å¾„è§„åˆ’schemaè®¾è®¡)
    - [5.3. åœ°ç†ç¼–ç ç³»ç»Ÿ](#53-åœ°ç†ç¼–ç ç³»ç»Ÿ)
  - [6. æ€§èƒ½ä¼˜åŒ–](#6-æ€§èƒ½ä¼˜åŒ–)
    - [6.1. ç©ºé—´ç´¢å¼•ä¼˜åŒ–](#61-ç©ºé—´ç´¢å¼•ä¼˜åŒ–)
    - [6.2. ç©ºé—´æŸ¥è¯¢ä¼˜åŒ–](#62-ç©ºé—´æŸ¥è¯¢ä¼˜åŒ–)
    - [6.3. ç©ºé—´æ•°æ®åˆ†åŒº](#63-ç©ºé—´æ•°æ®åˆ†åŒº)
  - [7. 2024-2025æœ€æ–°è¶‹åŠ¿](#7-2024-2025æœ€æ–°è¶‹åŠ¿)
    - [7.1. åœ°ç†ç©ºé—´æŠ€æœ¯æ¼”è¿›](#71-åœ°ç†ç©ºé—´æŠ€æœ¯æ¼”è¿›)
    - [7.2. ç©ºé—´æ•°æ®åº“é€‰å‹çŸ©é˜µ](#72-ç©ºé—´æ•°æ®åº“é€‰å‹çŸ©é˜µ)
    - [7.3. H3å…­è¾¹å½¢ç©ºé—´ç´¢å¼•](#73-h3å…­è¾¹å½¢ç©ºé—´ç´¢å¼•)
    - [7.4. ç©ºé—´+å‘é‡èåˆ](#74-ç©ºé—´å‘é‡èåˆ)
  - [8. å‚è€ƒèµ„æ–™](#8-å‚è€ƒèµ„æ–™)
    - [8.1. æƒå¨æ–‡çŒ®](#81-æƒå¨æ–‡çŒ®)
    - [8.2. åœ¨çº¿èµ„æº](#82-åœ¨çº¿èµ„æº)
    - [8.3. ç›¸å…³æ–‡æ¡£](#83-ç›¸å…³æ–‡æ¡£)

---

## 1. æ¦‚è¿°

åœ°ç†ç©ºé—´æ•°æ®åº“ç”¨äºå­˜å‚¨å’ŒæŸ¥è¯¢åœ°ç†ä½ç½®æ•°æ®ï¼Œæ”¯æŒåœ°å›¾åº”ç”¨ã€ä½ç½®æœåŠ¡ã€GISç³»ç»Ÿç­‰ã€‚

### 1.1. åœ°ç†ç©ºé—´åº”ç”¨åœºæ™¯

```mermaid
mindmap
  root((åœ°ç†ç©ºé—´åº”ç”¨))
    åœ°å›¾æœåŠ¡
      ä½ç½®æœç´¢
      è·¯å¾„è§„åˆ’
      åœ°ç†ç¼–ç 
    ä½ç½®æœåŠ¡
      LBSåº”ç”¨
      é™„è¿‘æœç´¢
      åœ°ç†å›´æ 
    GISç³»ç»Ÿ
      ç©ºé—´åˆ†æ
      åœ°ç†ç»Ÿè®¡
      ç©ºé—´å¯è§†åŒ–
    ç‰©è”ç½‘
      è®¾å¤‡å®šä½
      è½¨è¿¹è¿½è¸ª
      åŒºåŸŸç›‘æ§
```

### 1.2. ç©ºé—´æ•°æ®åº“é€‰æ‹©å†³ç­–æ ‘

```mermaid
flowchart TD
    A[é€‰æ‹©ç©ºé—´æ•°æ®åº“] --> B{æ•°æ®åº“ç³»ç»Ÿ}

    B -->|PostgreSQL| C[PostGIS]
    B -->|MySQL| D[MySQL Spatial]
    B -->|MongoDB| E[MongoDB Geospatial]
    B -->|ä¸“ç”¨GIS| F[PostGIS/GeoServer]

    C --> G[è®¾è®¡å®Œæˆ]
    D --> G
    E --> G
    F --> G
```

---

## 2. åœ°ç†ç©ºé—´æ•°æ®ç±»å‹

### 2.1. PostGISå‡ ä½•ç±»å‹

**åŸºæœ¬å‡ ä½•ç±»å‹**ï¼š

```sql
-- å¯ç”¨PostGISæ‰©å±•
CREATE EXTENSION IF NOT EXISTS postgis;
CREATE EXTENSION IF NOT EXISTS postgis_topology;

-- ç‚¹ï¼ˆPointï¼‰
CREATE TABLE locations (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    location GEOMETRY(POINT, 4326) NOT NULL,  -- WGS84åæ ‡ç³»
    address TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- çº¿ï¼ˆLineStringï¼‰
CREATE TABLE routes (
    id BIGSERIAL PRIMARY KEY,
    route_name VARCHAR(200) NOT NULL,
    path GEOMETRY(LINESTRING, 4326) NOT NULL,
    distance_meters DECIMAL(10,2),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- å¤šè¾¹å½¢ï¼ˆPolygonï¼‰
CREATE TABLE regions (
    id BIGSERIAL PRIMARY KEY,
    region_name VARCHAR(200) NOT NULL,
    boundary GEOMETRY(POLYGON, 4326) NOT NULL,
    area_sqkm DECIMAL(12,2),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- å¤šç‚¹ï¼ˆMultiPointï¼‰
CREATE TABLE clusters (
    id BIGSERIAL PRIMARY KEY,
    cluster_name VARCHAR(200),
    points GEOMETRY(MULTIPOINT, 4326) NOT NULL
);

-- å¤šçº¿ï¼ˆMultiLineStringï¼‰
CREATE TABLE road_networks (
    id BIGSERIAL PRIMARY KEY,
    network_name VARCHAR(200),
    roads GEOMETRY(MULTILINESTRING, 4326) NOT NULL
);

-- å¤šå¤šè¾¹å½¢ï¼ˆMultiPolygonï¼‰
CREATE TABLE countries (
    id BIGSERIAL PRIMARY KEY,
    country_name VARCHAR(100) NOT NULL,
    territory GEOMETRY(MULTIPOLYGON, 4326) NOT NULL,
    area_sqkm DECIMAL(15,2)
);
```

### 2.2. åœ°ç†åæ ‡ç³»ç»Ÿ

**å¸¸ç”¨åæ ‡ç³»**ï¼š

| åæ ‡ç³» | EPSGä»£ç  | ç”¨é€” | èŒƒå›´ |
|--------|---------|------|------|
| **WGS84** | 4326 | å…¨çƒå®šä½ | å…¨çƒ |
| **Web Mercator** | 3857 | Webåœ°å›¾ | å…¨çƒ |
| **GCJ-02** | - | ä¸­å›½åŠ å¯† | ä¸­å›½ |
| **BD-09** | - | ç™¾åº¦åæ ‡ | ä¸­å›½ |

**åæ ‡ç³»è½¬æ¢**ï¼š

```sql
-- åˆ›å»ºä¸åŒåæ ‡ç³»çš„æ•°æ®
CREATE TABLE locations_wgs84 (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(200),
    location GEOMETRY(POINT, 4326)  -- WGS84
);

CREATE TABLE locations_mercator (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(200),
    location GEOMETRY(POINT, 3857)  -- Web Mercator
);

-- åæ ‡ç³»è½¬æ¢
INSERT INTO locations_mercator (name, location)
SELECT
    name,
    ST_Transform(location, 3857)  -- è½¬æ¢ä¸ºWeb Mercator
FROM locations_wgs84;
```

---

## 3. ç©ºé—´ç´¢å¼•è®¾è®¡

### 3.1. GISTç´¢å¼•

**GISTï¼ˆGeneralized Search Treeï¼‰ç´¢å¼•**ï¼šPostGISçš„æ ‡å‡†ç©ºé—´ç´¢å¼•ã€‚

```sql
-- åˆ›å»ºGISTç©ºé—´ç´¢å¼•
CREATE INDEX idx_locations_location_gist
ON locations
USING GIST (location);

-- å¤åˆç´¢å¼•ï¼ˆç©ºé—´+å±æ€§ï¼‰
CREATE INDEX idx_locations_location_name_gist
ON locations
USING GIST (location, name);

-- è¦†ç›–ç´¢å¼•ï¼ˆåŒ…å«å¸¸ç”¨åˆ—ï¼‰
CREATE INDEX idx_locations_covering
ON locations
USING GIST (location)
INCLUDE (name, address);
```

### 3.2. ç©ºé—´ç´¢å¼•é€‰æ‹©å†³ç­–æ ‘

```mermaid
flowchart TD
    A[é€‰æ‹©ç©ºé—´ç´¢å¼•] --> B{æ•°æ®ç‰¹æ€§}

    B -->|ç‚¹æ•°æ®| C[GISTç´¢å¼•]
    B -->|çº¿/é¢æ•°æ®| D[GISTç´¢å¼•]
    B -->|é«˜ç»´æ•°æ®| E[è€ƒè™‘SP-GIST]

    C --> F[åˆ›å»ºç´¢å¼•]
    D --> F
    E --> G{PostgreSQLç‰ˆæœ¬}

    G -->|>=9.2| H[SP-GIST]
    G -->|<9.2| F

    H --> F
    F --> I[ç´¢å¼•åˆ›å»ºå®Œæˆ]
```

### 3.3. ç´¢å¼•ç»´æŠ¤

**ç©ºé—´ç´¢å¼•ç»Ÿè®¡ä¿¡æ¯**ï¼š

```sql
-- æ›´æ–°ç©ºé—´ç´¢å¼•ç»Ÿè®¡
ANALYZE locations;

-- æŸ¥çœ‹ç´¢å¼•ä½¿ç”¨æƒ…å†µ
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
  AND tablename = 'locations';
```

---

## 4. ç©ºé—´æŸ¥è¯¢è®¾è®¡

### 4.1. é™„è¿‘æœç´¢ï¼ˆKNNæŸ¥è¯¢ï¼‰

**æŸ¥æ‰¾æœ€è¿‘çš„Nä¸ªç‚¹**ï¼š

```sql
-- æŸ¥æ‰¾è·ç¦»æŒ‡å®šç‚¹æœ€è¿‘çš„10ä¸ªä½ç½®
SELECT
    id,
    name,
    address,
    ST_Distance(
        location,
        ST_SetSRID(ST_MakePoint(116.3974, 39.9093), 4326)::geography
    ) AS distance_meters
FROM locations
ORDER BY location <-> ST_SetSRID(ST_MakePoint(116.3974, 39.9093), 4326)
LIMIT 10;

-- ä½¿ç”¨åœ°ç†ç±»å‹ï¼ˆè‡ªåŠ¨è®¡ç®—çƒé¢è·ç¦»ï¼‰
ALTER TABLE locations
ADD COLUMN location_geog GEOGRAPHY(POINT, 4326);

UPDATE locations
SET location_geog = location::geography;

-- åœ°ç†ç±»å‹KNNæŸ¥è¯¢ï¼ˆæ›´å‡†ç¡®ï¼‰
SELECT
    id,
    name,
    ST_Distance(
        location_geog,
        ST_SetSRID(ST_MakePoint(116.3974, 39.9093), 4326)::geography
    ) AS distance_meters
FROM locations
ORDER BY location_geog <-> ST_SetSRID(ST_MakePoint(116.3974, 39.9093), 4326)::geography
LIMIT 10;
```

### 4.2. èŒƒå›´æŸ¥è¯¢

**æŸ¥æ‰¾æŒ‡å®šèŒƒå›´å†…çš„ç‚¹**ï¼š

```sql
-- æŸ¥æ‰¾åœ†å½¢èŒƒå›´å†…çš„ç‚¹ï¼ˆåŠå¾„1å…¬é‡Œï¼‰
SELECT
    id,
    name,
    address,
    ST_Distance(
        location_geog,
        ST_SetSRID(ST_MakePoint(116.3974, 39.9093), 4326)::geography
    ) AS distance_meters
FROM locations
WHERE ST_DWithin(
    location_geog,
    ST_SetSRID(ST_MakePoint(116.3974, 39.9093), 4326)::geography,
    1000  -- 1000ç±³
);

-- æŸ¥æ‰¾çŸ©å½¢èŒƒå›´å†…çš„ç‚¹
SELECT
    id,
    name,
    address
FROM locations
WHERE ST_Within(
    location,
    ST_MakeEnvelope(
        116.3, 39.8,  -- å·¦ä¸‹è§’
        116.5, 40.0,  -- å³ä¸Šè§’
        4326
    )
);

-- æŸ¥æ‰¾å¤šè¾¹å½¢èŒƒå›´å†…çš„ç‚¹
SELECT
    id,
    name,
    address
FROM locations
WHERE ST_Within(
    location,
    ST_GeomFromText(
        'POLYGON((116.3 39.8, 116.5 39.8, 116.5 40.0, 116.3 40.0, 116.3 39.8))',
        4326
    )
);
```

### 4.3. ç©ºé—´å…³ç³»æŸ¥è¯¢

**ç©ºé—´å…³ç³»åˆ¤æ–­**ï¼š

```sql
-- åˆ¤æ–­ç‚¹æ˜¯å¦åœ¨å¤šè¾¹å½¢å†…
SELECT
    l.id,
    l.name,
    r.region_name
FROM locations l
JOIN regions r ON ST_Within(l.location, r.boundary);

-- åˆ¤æ–­çº¿æ˜¯å¦ä¸å¤šè¾¹å½¢ç›¸äº¤
SELECT
    r.id,
    r.route_name,
    reg.region_name
FROM routes r
JOIN regions reg ON ST_Intersects(r.path, reg.boundary);

-- è®¡ç®—ä¸¤ä¸ªå‡ ä½•ä½“çš„è·ç¦»
SELECT
    ST_Distance(
        ST_SetSRID(ST_MakePoint(116.3974, 39.9093), 4326)::geography,
        location_geog
    ) AS distance_meters
FROM locations
WHERE id = 1;

-- è®¡ç®—ç¼“å†²åŒº
SELECT
    id,
    name,
    ST_Buffer(location_geog, 500) AS buffer_500m  -- 500ç±³ç¼“å†²åŒº
FROM locations
WHERE id = 1;
```

### 4.4. ç©ºé—´èšåˆæŸ¥è¯¢

**ç©ºé—´ç»Ÿè®¡**ï¼š

```sql
-- è®¡ç®—åŒºåŸŸå†…çš„ç‚¹æ•°é‡
SELECT
    r.region_name,
    COUNT(l.id) AS location_count,
    ST_Area(r.boundary::geography) / 1000000 AS area_sqkm
FROM regions r
LEFT JOIN locations l ON ST_Within(l.location, r.boundary)
GROUP BY r.id, r.region_name, r.boundary;

-- è®¡ç®—ç‚¹çš„å‡¸åŒ…ï¼ˆConvex Hullï¼‰
SELECT
    ST_ConvexHull(ST_Collect(location)) AS convex_hull
FROM locations;

-- è®¡ç®—ç‚¹çš„ä¸­å¿ƒç‚¹
SELECT
    ST_Centroid(ST_Collect(location)) AS center_point
FROM locations;

-- è®¡ç®—æœ€å°è¾¹ç•ŒçŸ©å½¢ï¼ˆMBRï¼‰
SELECT
    ST_Envelope(ST_Collect(location)) AS bounding_box
FROM locations;
```

---

## 5. åœ°ç†ç©ºé—´åº”ç”¨æ¡ˆä¾‹

### 5.1. ä½ç½®æœåŠ¡ï¼ˆLBSï¼‰Schemaè®¾è®¡

**å®Œæ•´çš„LBSç³»ç»ŸSchema**ï¼š

```sql
CREATE SCHEMA lbs_system;

-- ç”¨æˆ·ä½ç½®è¡¨
CREATE TABLE lbs_system.user_locations (
    location_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL,
    location GEOGRAPHY(POINT, 4326) NOT NULL,
    accuracy DECIMAL(10,2),  -- ç²¾åº¦ï¼ˆç±³ï¼‰
    altitude DECIMAL(10,2),  -- æµ·æ‹”ï¼ˆç±³ï¼‰
    speed DECIMAL(5,2),  -- é€Ÿåº¦ï¼ˆm/sï¼‰
    heading DECIMAL(5,2),  -- æ–¹å‘ï¼ˆåº¦ï¼‰
    location_time TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) PARTITION BY RANGE (location_time);

-- æŒ‰æœˆåˆ†åŒº
CREATE TABLE lbs_system.user_locations_2024_01
PARTITION OF lbs_system.user_locations
FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

CREATE INDEX idx_user_locations_user ON lbs_system.user_locations(user_id, location_time DESC);
CREATE INDEX idx_user_locations_location_gist
ON lbs_system.user_locations USING GIST (location);

-- åœ°ç†å›´æ è¡¨
CREATE TABLE lbs_system.geofences (
    geofence_id BIGSERIAL PRIMARY KEY,
    geofence_name VARCHAR(200) NOT NULL,
    boundary GEOGRAPHY(POLYGON, 4326) NOT NULL,
    geofence_type VARCHAR(50),  -- circle, polygon, custom
    radius_meters DECIMAL(10,2),  -- åœ†å½¢å›´æ åŠå¾„
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_geofences_boundary_gist
ON lbs_system.geofences USING GIST (boundary);

-- å›´æ äº‹ä»¶è¡¨
CREATE TABLE lbs_system.geofence_events (
    event_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL,
    geofence_id BIGINT REFERENCES lbs_system.geofences(geofence_id),
    event_type VARCHAR(20) NOT NULL,  -- ENTER, EXIT, INSIDE
    location GEOGRAPHY(POINT, 4326) NOT NULL,
    event_time TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) PARTITION BY RANGE (event_time);

CREATE INDEX idx_geofence_events_user ON lbs_system.geofence_events(user_id, event_time DESC);

-- å›´æ æ£€æµ‹è§¦å‘å™¨
CREATE OR REPLACE FUNCTION check_geofence_events()
RETURNS TRIGGER AS $$
DECLARE
    v_geofence RECORD;
    v_previous_location GEOGRAPHY;
    v_was_inside BOOLEAN;
    v_is_inside BOOLEAN;
BEGIN
    -- è·å–ç”¨æˆ·ä¸Šä¸€ä¸ªä½ç½®
    SELECT location INTO v_previous_location
    FROM lbs_system.user_locations
    WHERE user_id = NEW.user_id
      AND location_time < NEW.location_time
    ORDER BY location_time DESC
    LIMIT 1;

    -- æ£€æŸ¥æ‰€æœ‰æ´»è·ƒçš„å›´æ 
    FOR v_geofence IN
        SELECT * FROM lbs_system.geofences WHERE is_active = TRUE
    LOOP
        -- æ£€æŸ¥æ˜¯å¦åœ¨å›´æ å†…
        v_is_inside := ST_Within(NEW.location::geometry, v_geofence.boundary::geometry);

        IF v_previous_location IS NOT NULL THEN
            v_was_inside := ST_Within(v_previous_location::geometry, v_geofence.boundary::geometry);
        ELSE
            v_was_inside := FALSE;
        END IF;

        -- æ£€æµ‹è¿›å…¥äº‹ä»¶
        IF NOT v_was_inside AND v_is_inside THEN
            INSERT INTO lbs_system.geofence_events
            (user_id, geofence_id, event_type, location, event_time)
            VALUES (NEW.user_id, v_geofence.geofence_id, 'ENTER', NEW.location, NEW.location_time);
        END IF;

        -- æ£€æµ‹ç¦»å¼€äº‹ä»¶
        IF v_was_inside AND NOT v_is_inside THEN
            INSERT INTO lbs_system.geofence_events
            (user_id, geofence_id, event_type, location, event_time)
            VALUES (NEW.user_id, v_geofence.geofence_id, 'EXIT', NEW.location, NEW.location_time);
        END IF;
    END LOOP;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER geofence_check_trigger
AFTER INSERT ON lbs_system.user_locations
FOR EACH ROW
EXECUTE FUNCTION check_geofence_events();
```

### 5.2. è·¯å¾„è§„åˆ’Schemaè®¾è®¡

**è·¯å¾„è§„åˆ’ç³»ç»Ÿ**ï¼š

```sql
CREATE SCHEMA routing_system;

-- é“è·¯ç½‘ç»œè¡¨
CREATE TABLE routing_system.road_network (
    road_id BIGSERIAL PRIMARY KEY,
    road_name VARCHAR(200),
    road_type VARCHAR(50),  -- highway, street, path
    geometry GEOGRAPHY(LINESTRING, 4326) NOT NULL,
    length_meters DECIMAL(10,2),
    max_speed_kmh INTEGER,
    one_way BOOLEAN DEFAULT FALSE,
    toll BOOLEAN DEFAULT FALSE,
    metadata JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_road_network_geometry_gist
ON routing_system.road_network USING GIST (geometry);

-- é“è·¯èŠ‚ç‚¹è¡¨ï¼ˆç”¨äºè·¯å¾„è§„åˆ’ï¼‰
CREATE TABLE routing_system.road_nodes (
    node_id BIGSERIAL PRIMARY KEY,
    location GEOGRAPHY(POINT, 4326) NOT NULL,
    node_type VARCHAR(50),  -- intersection, endpoint
    metadata JSONB
);

CREATE INDEX idx_road_nodes_location_gist
ON routing_system.road_nodes USING GIST (location);

-- è·¯å¾„è§„åˆ’ç»“æœè¡¨
CREATE TABLE routing_system.route_results (
    route_id BIGSERIAL PRIMARY KEY,
    start_point GEOGRAPHY(POINT, 4326) NOT NULL,
    end_point GEOGRAPHY(POINT, 4326) NOT NULL,
    route_path GEOGRAPHY(LINESTRING, 4326) NOT NULL,
    total_distance_meters DECIMAL(10,2) NOT NULL,
    estimated_time_seconds INTEGER,
    route_type VARCHAR(50),  -- fastest, shortest, scenic
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_route_results_path_gist
ON routing_system.route_results USING GIST (route_path);
```

### 5.3. åœ°ç†ç¼–ç ç³»ç»Ÿ

**åœ°å€ä¸åæ ‡äº’è½¬**ï¼š

```sql
CREATE SCHEMA geocoding;

-- åœ°ç†ç¼–ç ç¼“å­˜è¡¨
CREATE TABLE geocoding.address_cache (
    cache_id BIGSERIAL PRIMARY KEY,
    address TEXT NOT NULL,
    normalized_address TEXT,
    location GEOGRAPHY(POINT, 4326),
    address_components JSONB,  -- {country, province, city, district, street}
    confidence_score DECIMAL(3,2),
    geocoding_service VARCHAR(50),  -- google, baidu, gaode
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(address, geocoding_service)
);

CREATE INDEX idx_address_cache_location_gist
ON geocoding.address_cache USING GIST (location);
CREATE INDEX idx_address_cache_address ON geocoding.address_cache USING GIN (address gin_trgm_ops);

-- åå‘åœ°ç†ç¼–ç ç¼“å­˜ï¼ˆåæ ‡â†’åœ°å€ï¼‰
CREATE TABLE geocoding.reverse_geocoding_cache (
    cache_id BIGSERIAL PRIMARY KEY,
    location GEOGRAPHY(POINT, 4326) NOT NULL,
    address TEXT,
    address_components JSONB,
    confidence_score DECIMAL(3,2),
    geocoding_service VARCHAR(50),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(location, geocoding_service)
);

CREATE INDEX idx_reverse_geocoding_location_gist
ON geocoding.reverse_geocoding_cache USING GIST (location);
```

---

## 6. æ€§èƒ½ä¼˜åŒ–

### 6.1. ç©ºé—´ç´¢å¼•ä¼˜åŒ–

**ç´¢å¼•å‚æ•°è°ƒä¼˜**ï¼š

```sql
-- GISTç´¢å¼•å‚æ•°
-- pages_per_range: æ¯ä¸ªèŒƒå›´åŒ…å«çš„é¡µé¢æ•°ï¼ˆé»˜è®¤128ï¼‰
CREATE INDEX idx_locations_optimized
ON locations
USING GIST (location)
WITH (fillfactor = 90);  -- é¢„ç•™10%ç©ºé—´ç”¨äºæ›´æ–°

-- éƒ¨åˆ†ç´¢å¼•ï¼ˆåªç´¢å¼•æ´»è·ƒæ•°æ®ï¼‰
CREATE INDEX idx_locations_active_gist
ON locations
USING GIST (location)
WHERE status = 'active';
```

### 6.2. ç©ºé—´æŸ¥è¯¢ä¼˜åŒ–

**æŸ¥è¯¢ä¼˜åŒ–æŠ€å·§**ï¼š

```sql
-- 1. ä½¿ç”¨ç©ºé—´ç´¢å¼•æç¤º
SET enable_seqscan = OFF;  -- å¼ºåˆ¶ä½¿ç”¨ç´¢å¼•ï¼ˆä»…æµ‹è¯•ç”¨ï¼‰

-- 2. é™åˆ¶æœç´¢èŒƒå›´
SELECT *
FROM locations
WHERE ST_DWithin(
    location_geog,
    ST_SetSRID(ST_MakePoint(116.3974, 39.9093), 4326)::geography,
    1000
)
AND ST_X(location::geometry) BETWEEN 116.3 AND 116.5  -- å¿«é€Ÿè¿‡æ»¤
AND ST_Y(location::geometry) BETWEEN 39.8 AND 40.0;

-- 3. ä½¿ç”¨è¾¹ç•Œæ¡†é¢„è¿‡æ»¤
SELECT *
FROM locations
WHERE location && ST_MakeEnvelope(116.3, 39.8, 116.5, 40.0, 4326)  -- å¿«é€Ÿè¾¹ç•Œæ¡†æ£€æŸ¥
  AND ST_DWithin(
      location_geog,
      ST_SetSRID(ST_MakePoint(116.3974, 39.9093), 4326)::geography,
      1000
  );
```

### 6.3. ç©ºé—´æ•°æ®åˆ†åŒº

**æŒ‰ç©ºé—´èŒƒå›´åˆ†åŒº**ï¼š

```sql
-- æŒ‰åœ°ç†åŒºåŸŸåˆ†åŒº
CREATE TABLE locations_china (
    id BIGSERIAL,
    name VARCHAR(200),
    location GEOGRAPHY(POINT, 4326),
    CONSTRAINT check_china_bounds CHECK (
        ST_X(location::geometry) BETWEEN 73 AND 135 AND
        ST_Y(location::geometry) BETWEEN 18 AND 54
    )
) PARTITION BY RANGE (ST_X(location::geometry));

-- åˆ›å»ºåˆ†åŒº
CREATE TABLE locations_china_east
PARTITION OF locations_china
FOR VALUES FROM (100) TO (135);

CREATE TABLE locations_china_west
PARTITION OF locations_china
FOR VALUES FROM (73) TO (100);
```

---

## 7. 2024-2025æœ€æ–°è¶‹åŠ¿

### 7.1. åœ°ç†ç©ºé—´æŠ€æœ¯æ¼”è¿›

```mermaid
timeline
    title åœ°ç†ç©ºé—´æ•°æ®åº“æ¼”è¿›
    2005 : PostGIS 1.0
         : åŸºç¡€ç©ºé—´åŠŸèƒ½
    2012 : PostGIS 2.0
         : æ …æ ¼æ”¯æŒ
    2017 : PostGIS 3.0
         : æ€§èƒ½ä¼˜åŒ–
    2022 : H3/S2é›†æˆ
         : ç©ºé—´ç´¢å¼•é©æ–°
    2024 : å‘é‡+ç©ºé—´èåˆ
         : LLMåœ°ç†ç†è§£
    2025 : 3D/æ—¶ç©ºæ•°æ®
         : æ•°å­—å­ªç”Ÿ
```

### 7.2. ç©ºé—´æ•°æ®åº“é€‰å‹çŸ©é˜µ

| æ•°æ®åº“ | ç±»å‹ | 3Dæ”¯æŒ | æ …æ ¼ | å‘é‡èåˆ | é€‚ç”¨åœºæ™¯ |
|-------|------|--------|------|---------|---------|
| **PostGIS** | PGæ‰©å±• | âœ… | âœ… | pgvector | é€šç”¨GIS |
| **H3-pg** | PGæ‰©å±• | âŒ | âŒ | âœ… | å…­è¾¹å½¢ç´¢å¼• |
| **MongoDB** | åŸç”Ÿ | âŒ | âŒ | âœ… | ç®€å•åœ°ç† |
| **Elasticsearch** | æœç´¢ | âŒ | âŒ | âŒ | åœ°ç†æœç´¢ |
| **BigQuery GIS** | äº‘åŸç”Ÿ | âŒ | âœ… | âŒ | å¤§æ•°æ®åˆ†æ |

### 7.3. H3å…­è¾¹å½¢ç©ºé—´ç´¢å¼•

```sql
-- å®‰è£…H3æ‰©å±•
CREATE EXTENSION IF NOT EXISTS h3;

-- H3ç©ºé—´ç´¢å¼•è¡¨
CREATE TABLE locations_h3 (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(200),
    location GEOGRAPHY(POINT, 4326),
    h3_index_res9 h3index,  -- åˆ†è¾¨ç‡9 (~175mè¾¹é•¿)
    h3_index_res7 h3index   -- åˆ†è¾¨ç‡7 (~1.2kmè¾¹é•¿)
);

-- è‡ªåŠ¨è®¡ç®—H3ç´¢å¼•
CREATE OR REPLACE FUNCTION update_h3_index()
RETURNS TRIGGER AS $$
BEGIN
    NEW.h3_index_res9 := h3_lat_lng_to_cell(
        ST_Y(NEW.location::geometry),
        ST_X(NEW.location::geometry),
        9
    );
    NEW.h3_index_res7 := h3_lat_lng_to_cell(
        ST_Y(NEW.location::geometry),
        ST_X(NEW.location::geometry),
        7
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_h3_index
BEFORE INSERT OR UPDATE ON locations_h3
FOR EACH ROW EXECUTE FUNCTION update_h3_index();

-- H3é‚»åŸŸæŸ¥è¯¢ï¼ˆæ¯”ä¼ ç»ŸST_DWithinæ›´å¿«ï¼‰
SELECT *
FROM locations_h3
WHERE h3_index_res9 = ANY(
    h3_grid_disk(h3_lat_lng_to_cell(39.9, 116.4, 9), 2)
);
```

### 7.4. ç©ºé—´+å‘é‡èåˆ

```sql
-- ç©ºé—´+è¯­ä¹‰æ··åˆæ£€ç´¢
CREATE TABLE geo_pois (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(200),
    description TEXT,
    location GEOGRAPHY(POINT, 4326),
    embedding vector(1536),  -- è¯­ä¹‰å‘é‡
    categories TEXT[]
);

-- æ··åˆç©ºé—´è¯­ä¹‰æœç´¢
CREATE OR REPLACE FUNCTION geo_semantic_search(
    p_lat FLOAT,
    p_lng FLOAT,
    p_radius_meters INTEGER,
    p_query_embedding vector(1536),
    p_limit INTEGER DEFAULT 10
)
RETURNS TABLE (
    id UUID,
    name VARCHAR,
    distance_meters FLOAT,
    semantic_score FLOAT,
    combined_score FLOAT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        g.id,
        g.name,
        ST_Distance(g.location, ST_SetSRID(ST_MakePoint(p_lng, p_lat), 4326)::geography)::FLOAT AS distance_meters,
        (1 - (g.embedding <=> p_query_embedding))::FLOAT AS semantic_score,
        -- ç»¼åˆåˆ†æ•°ï¼šè·ç¦»è¶Šè¿‘è¶Šå¥½ï¼Œè¯­ä¹‰è¶Šç›¸ä¼¼è¶Šå¥½
        (0.5 * (1 - LEAST(ST_Distance(g.location, ST_SetSRID(ST_MakePoint(p_lng, p_lat), 4326)::geography) / p_radius_meters, 1))
         + 0.5 * (1 - (g.embedding <=> p_query_embedding)))::FLOAT AS combined_score
    FROM geo_pois g
    WHERE ST_DWithin(g.location, ST_SetSRID(ST_MakePoint(p_lng, p_lat), 4326)::geography, p_radius_meters)
    ORDER BY combined_score DESC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;
```

---

## 8. å‚è€ƒèµ„æ–™

### 8.1. æƒå¨æ–‡çŒ®

**åœ°ç†ç©ºé—´ç†è®º**ï¼š

- Rigaux, P. et al. "Spatial Databases: With Application to GIS"
- PostGIS Development Team "PostGIS Manual"

### 8.2. åœ¨çº¿èµ„æº

| èµ„æº | URL | æè¿° |
|------|-----|------|
| **PostGIS** | <https://postgis.net/> | å®˜æ–¹æ–‡æ¡£ |
| **H3** | <https://h3geo.org/> | å…­è¾¹å½¢ç´¢å¼• |
| **OpenStreetMap** | <https://www.openstreetmap.org/> | åœ°ç†æ•°æ® |

### 8.3. ç›¸å…³æ–‡æ¡£

- [07.01-Schemaè®¾è®¡æ–¹æ³•è®º](./07.01-Schemaè®¾è®¡æ–¹æ³•è®º.md)
- [07.10-å‘é‡æ•°æ®åº“è®¾è®¡](./07.10-å‘é‡æ•°æ®åº“è®¾è®¡.md)

---

**æœ€åæ›´æ–°**ï¼š2025-12-01
**ç»´æŠ¤è€…**ï¼šData-Science Team
**çŠ¶æ€**ï¼šå·²å®Œæˆ âœ…
**ç‰ˆæœ¬**ï¼šv2.0 (å¢å¼ºç‰ˆ)
