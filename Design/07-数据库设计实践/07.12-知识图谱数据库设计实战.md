# çŸ¥è¯†å›¾è°±æ•°æ®åº“è®¾è®¡å®æˆ˜ï¼šä»Schemaåˆ°æŸ¥è¯¢ä¼˜åŒ–

> **åˆ›å»ºæ—¥æœŸ**ï¼š2025-01-15
> **æœ€åæ›´æ–°**ï¼š2025-01-15
> **ç‰ˆæœ¬**ï¼šv1.0
> **çŠ¶æ€**ï¼šå®æ–½ä¸­

---

## ğŸ“‹ ç›®å½•

- [çŸ¥è¯†å›¾è°±æ•°æ®åº“è®¾è®¡å®æˆ˜ï¼šä»Schemaåˆ°æŸ¥è¯¢ä¼˜åŒ–](#çŸ¥è¯†å›¾è°±æ•°æ®åº“è®¾è®¡å®æˆ˜ä»schemaåˆ°æŸ¥è¯¢ä¼˜åŒ–)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1. çŸ¥è¯†å›¾è°±å­˜å‚¨æ–¹æ¡ˆé€‰æ‹©å†³ç­–æ ‘](#11-çŸ¥è¯†å›¾è°±å­˜å‚¨æ–¹æ¡ˆé€‰æ‹©å†³ç­–æ ‘)
  - [2. çŸ¥è¯†å›¾è°±Schemaè®¾è®¡](#2-çŸ¥è¯†å›¾è°±schemaè®¾è®¡)
    - [2.1. ä¸‰å…ƒç»„å­˜å‚¨Schemaï¼ˆå…³ç³»æ•°æ®åº“ï¼‰](#21-ä¸‰å…ƒç»„å­˜å‚¨schemaå…³ç³»æ•°æ®åº“)
    - [2.2. ä¼˜åŒ–Schemaè®¾è®¡ï¼ˆæ”¯æŒå¿«é€ŸæŸ¥è¯¢ï¼‰](#22-ä¼˜åŒ–schemaè®¾è®¡æ”¯æŒå¿«é€ŸæŸ¥è¯¢)
    - [2.3. åˆ†åŒºè¡¨è®¾è®¡ï¼ˆå¤§è§„æ¨¡æ•°æ®ï¼‰](#23-åˆ†åŒºè¡¨è®¾è®¡å¤§è§„æ¨¡æ•°æ®)
  - [3. å…³ç³»æ•°æ®åº“å­˜å‚¨çŸ¥è¯†å›¾è°±](#3-å…³ç³»æ•°æ®åº“å­˜å‚¨çŸ¥è¯†å›¾è°±)
    - [3.1. åŸºç¡€æŸ¥è¯¢å‡½æ•°](#31-åŸºç¡€æŸ¥è¯¢å‡½æ•°)
    - [3.2. å›¾æ¨¡å¼åŒ¹é…æŸ¥è¯¢](#32-å›¾æ¨¡å¼åŒ¹é…æŸ¥è¯¢)
  - [4. Neo4jå›¾æ•°æ®åº“è®¾è®¡](#4-neo4jå›¾æ•°æ®åº“è®¾è®¡)
    - [4.1. Neo4j Schemaè®¾è®¡](#41-neo4j-schemaè®¾è®¡)
    - [4.2. Neo4jæ•°æ®å¯¼å…¥](#42-neo4jæ•°æ®å¯¼å…¥)
    - [4.3. Neo4jæŸ¥è¯¢ä¼˜åŒ–](#43-neo4jæŸ¥è¯¢ä¼˜åŒ–)
  - [5. PostgreSQLå›¾æ‰©å±•è®¾è®¡](#5-postgresqlå›¾æ‰©å±•è®¾è®¡)
    - [5.1. Apache AGEé›†æˆ](#51-apache-ageé›†æˆ)
    - [5.2. PostgreSQLå›¾æŸ¥è¯¢](#52-postgresqlå›¾æŸ¥è¯¢)
  - [6. çŸ¥è¯†å›¾è°±æŸ¥è¯¢ä¼˜åŒ–](#6-çŸ¥è¯†å›¾è°±æŸ¥è¯¢ä¼˜åŒ–)
    - [6.1. æŸ¥è¯¢ä¼˜åŒ–ç­–ç•¥](#61-æŸ¥è¯¢ä¼˜åŒ–ç­–ç•¥)
    - [6.2. ç´¢å¼•ä¼˜åŒ–](#62-ç´¢å¼•ä¼˜åŒ–)
    - [6.3. æŸ¥è¯¢é‡å†™ä¼˜åŒ–](#63-æŸ¥è¯¢é‡å†™ä¼˜åŒ–)
  - [7. å®é™…åº”ç”¨æ¡ˆä¾‹](#7-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [7.1. ä¼ä¸šçŸ¥è¯†å›¾è°±æ¡ˆä¾‹](#71-ä¼ä¸šçŸ¥è¯†å›¾è°±æ¡ˆä¾‹)
    - [7.2. æ¨èç³»ç»ŸçŸ¥è¯†å›¾è°±æ¡ˆä¾‹](#72-æ¨èç³»ç»ŸçŸ¥è¯†å›¾è°±æ¡ˆä¾‹)
  - [8. å‚è€ƒèµ„æ–™](#8-å‚è€ƒèµ„æ–™)

---

## 1. æ¦‚è¿°

çŸ¥è¯†å›¾è°±æ•°æ®åº“è®¾è®¡éœ€è¦å¹³è¡¡å­˜å‚¨æ•ˆç‡ã€æŸ¥è¯¢æ€§èƒ½å’Œè¯­ä¹‰è¡¨è¾¾èƒ½åŠ›ã€‚

### 1.1. çŸ¥è¯†å›¾è°±å­˜å‚¨æ–¹æ¡ˆé€‰æ‹©å†³ç­–æ ‘

```mermaid
flowchart TD
    A[é€‰æ‹©çŸ¥è¯†å›¾è°±å­˜å‚¨æ–¹æ¡ˆ] --> B{æ•°æ®è§„æ¨¡}

    B -->|å°è§„æ¨¡<1000ä¸‡ä¸‰å…ƒç»„| C{æŸ¥è¯¢æ¨¡å¼}
    B -->|å¤§è§„æ¨¡>1000ä¸‡ä¸‰å…ƒç»„| D{ç³»ç»Ÿè¦æ±‚}

    C -->|ç®€å•æŸ¥è¯¢| E[å…³ç³»æ•°æ®åº“]
    C -->|å¤æ‚å›¾æŸ¥è¯¢| F[å›¾æ•°æ®åº“]

    D -->|é«˜æ€§èƒ½| G[åŸç”Ÿå›¾æ•°æ®åº“]
    D -->|é›†æˆéœ€æ±‚| H[å…³ç³»æ•°æ®åº“+å›¾æ‰©å±•]

    E --> I[PostgreSQL/MySQL]
    F --> J[Neo4j/ArangoDB]
    G --> K[Neo4j/Amazon Neptune]
    H --> L[PostgreSQL+AGE]
```

---

## 2. çŸ¥è¯†å›¾è°±Schemaè®¾è®¡

### 2.1. ä¸‰å…ƒç»„å­˜å‚¨Schemaï¼ˆå…³ç³»æ•°æ®åº“ï¼‰

**åŸºç¡€ä¸‰å…ƒç»„è¡¨è®¾è®¡**ï¼š

```sql
CREATE SCHEMA knowledge_graph;

-- å®ä½“è¡¨
CREATE TABLE knowledge_graph.entities (
    entity_id BIGSERIAL PRIMARY KEY,
    entity_uri VARCHAR(500) UNIQUE NOT NULL,
    entity_type VARCHAR(100) NOT NULL,  -- Person, Company, Locationç­‰
    entity_name VARCHAR(200),
    properties JSONB,  -- å®ä½“å±æ€§
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_entities_uri ON knowledge_graph.entities(entity_uri);
CREATE INDEX idx_entities_type ON knowledge_graph.entities(entity_type);
CREATE INDEX idx_entities_name ON knowledge_graph.entities(entity_name);
CREATE INDEX idx_entities_properties ON knowledge_graph.entities USING GIN (properties);

-- å…³ç³»è¡¨
CREATE TABLE knowledge_graph.relations (
    relation_id SERIAL PRIMARY KEY,
    relation_uri VARCHAR(500) UNIQUE NOT NULL,
    relation_name VARCHAR(200) NOT NULL,
    relation_type VARCHAR(100),  -- SYMMETRIC, TRANSITIVE, INVERSEç­‰
    domain_entity_type VARCHAR(100),  -- å®šä¹‰åŸŸå®ä½“ç±»å‹
    range_entity_type VARCHAR(100),  -- å€¼åŸŸå®ä½“ç±»å‹
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_relations_uri ON knowledge_graph.relations(relation_uri);
CREATE INDEX idx_relations_type ON knowledge_graph.relations(relation_type);

-- ä¸‰å…ƒç»„è¡¨ï¼ˆæ ¸å¿ƒè¡¨ï¼‰
CREATE TABLE knowledge_graph.triples (
    triple_id BIGSERIAL PRIMARY KEY,
    subject_id BIGINT NOT NULL REFERENCES knowledge_graph.entities(entity_id) ON DELETE CASCADE,
    predicate_id INTEGER NOT NULL REFERENCES knowledge_graph.relations(relation_id),
    object_id BIGINT NOT NULL REFERENCES knowledge_graph.entities(entity_id) ON DELETE CASCADE,
    confidence DECIMAL(5,4) DEFAULT 1.0,  -- ç½®ä¿¡åº¦
    source VARCHAR(200),  -- æ•°æ®æ¥æº
    properties JSONB,  -- å…³ç³»å±æ€§
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(subject_id, predicate_id, object_id)
);

-- ä¸‰å…ƒç»„ç´¢å¼•ï¼ˆå…³é”®æ€§èƒ½ä¼˜åŒ–ï¼‰
CREATE INDEX idx_triples_subject ON knowledge_graph.triples(subject_id);
CREATE INDEX idx_triples_predicate ON knowledge_graph.triples(predicate_id);
CREATE INDEX idx_triples_object ON knowledge_graph.triples(object_id);
CREATE INDEX idx_triples_spo ON knowledge_graph.triples(subject_id, predicate_id, object_id);
CREATE INDEX idx_triples_ops ON knowledge_graph.triples(object_id, predicate_id, subject_id);  -- åå‘æŸ¥è¯¢
CREATE INDEX idx_triples_properties ON knowledge_graph.triples USING GIN (properties);

-- å®ä½“ç±»å‹è¡¨ï¼ˆæœ¬ä½“ï¼‰
CREATE TABLE knowledge_graph.entity_types (
    type_id SERIAL PRIMARY KEY,
    type_uri VARCHAR(500) UNIQUE NOT NULL,
    type_name VARCHAR(200) NOT NULL,
    parent_type_id INTEGER REFERENCES knowledge_graph.entity_types(type_id),
    properties_schema JSONB,  -- å±æ€§æ¨¡å¼å®šä¹‰
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_entity_types_parent ON knowledge_graph.entity_types(parent_type_id);

-- å®ä½“ç±»å‹å…³è”è¡¨
CREATE TABLE knowledge_graph.entity_type_assignments (
    entity_id BIGINT NOT NULL REFERENCES knowledge_graph.entities(entity_id) ON DELETE CASCADE,
    type_id INTEGER NOT NULL REFERENCES knowledge_graph.entity_types(type_id) ON DELETE CASCADE,
    PRIMARY KEY (entity_id, type_id)
);

CREATE INDEX idx_entity_type_assignments_entity ON knowledge_graph.entity_type_assignments(entity_id);
CREATE INDEX idx_entity_type_assignments_type ON knowledge_graph.entity_type_assignments(type_id);
```

### 2.2. ä¼˜åŒ–Schemaè®¾è®¡ï¼ˆæ”¯æŒå¿«é€ŸæŸ¥è¯¢ï¼‰

**ç‰©åŒ–è§†å›¾ä¼˜åŒ–**ï¼š

```sql
-- å¸¸ç”¨æŸ¥è¯¢æ¨¡å¼ç‰©åŒ–è§†å›¾
CREATE MATERIALIZED VIEW knowledge_graph.entity_out_degree AS
SELECT
    e.entity_id,
    e.entity_uri,
    e.entity_type,
    COUNT(t.triple_id) AS out_degree
FROM knowledge_graph.entities e
LEFT JOIN knowledge_graph.triples t ON e.entity_id = t.subject_id
GROUP BY e.entity_id, e.entity_uri, e.entity_type;

CREATE INDEX idx_entity_out_degree_degree ON knowledge_graph.entity_out_degree(out_degree DESC);

CREATE MATERIALIZED VIEW knowledge_graph.entity_in_degree AS
SELECT
    e.entity_id,
    e.entity_uri,
    e.entity_type,
    COUNT(t.triple_id) AS in_degree
FROM knowledge_graph.entities e
LEFT JOIN knowledge_graph.triples t ON e.entity_id = t.object_id
GROUP BY e.entity_id, e.entity_uri, e.entity_type;

CREATE INDEX idx_entity_in_degree_degree ON knowledge_graph.entity_in_degree(in_degree DESC);

-- åˆ·æ–°ç‰©åŒ–è§†å›¾å‡½æ•°
CREATE OR REPLACE FUNCTION refresh_kg_materialized_views()
RETURNS VOID AS $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY knowledge_graph.entity_out_degree;
    REFRESH MATERIALIZED VIEW CONCURRENTLY knowledge_graph.entity_in_degree;
END;
$$ LANGUAGE plpgsql;
```

### 2.3. åˆ†åŒºè¡¨è®¾è®¡ï¼ˆå¤§è§„æ¨¡æ•°æ®ï¼‰

**æŒ‰å®ä½“ç±»å‹åˆ†åŒº**ï¼š

```sql
-- ä¸‰å…ƒç»„åˆ†åŒºè¡¨ï¼ˆæŒ‰ä¸»ä½“å®ä½“ç±»å‹åˆ†åŒºï¼‰
CREATE TABLE knowledge_graph.triples_partitioned (
    triple_id BIGSERIAL,
    subject_id BIGINT NOT NULL,
    predicate_id INTEGER NOT NULL,
    object_id BIGINT NOT NULL,
    confidence DECIMAL(5,4) DEFAULT 1.0,
    source VARCHAR(200),
    properties JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (triple_id, subject_id)
) PARTITION BY HASH (subject_id);

-- åˆ›å»ºåˆ†åŒºï¼ˆç¤ºä¾‹ï¼š4ä¸ªåˆ†åŒºï¼‰
CREATE TABLE knowledge_graph.triples_partitioned_0
PARTITION OF knowledge_graph.triples_partitioned
FOR VALUES WITH (MODULUS 4, REMAINDER 0);

CREATE TABLE knowledge_graph.triples_partitioned_1
PARTITION OF knowledge_graph.triples_partitioned
FOR VALUES WITH (MODULUS 4, REMAINDER 1);

CREATE TABLE knowledge_graph.triples_partitioned_2
PARTITION OF knowledge_graph.triples_partitioned
FOR VALUES WITH (MODULUS 4, REMAINDER 2);

CREATE TABLE knowledge_graph.triples_partitioned_3
PARTITION OF knowledge_graph.triples_partitioned
FOR VALUES WITH (MODULUS 4, REMAINDER 3);
```

---

## 3. å…³ç³»æ•°æ®åº“å­˜å‚¨çŸ¥è¯†å›¾è°±

### 3.1. åŸºç¡€æŸ¥è¯¢å‡½æ•°

**å•è·³æŸ¥è¯¢**ï¼š

```sql
-- æŸ¥æ‰¾å®ä½“çš„æ‰€æœ‰å‡ºè¾¹
CREATE OR REPLACE FUNCTION get_entity_outgoing_relations(
    p_entity_uri VARCHAR(500)
)
RETURNS TABLE (
    relation_name VARCHAR(200),
    target_entity_uri VARCHAR(500),
    target_entity_name VARCHAR(200),
    properties JSONB
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        r.relation_name,
        e2.entity_uri AS target_entity_uri,
        e2.entity_name AS target_entity_name,
        t.properties
    FROM knowledge_graph.triples t
    JOIN knowledge_graph.entities e1 ON t.subject_id = e1.entity_id
    JOIN knowledge_graph.relations r ON t.predicate_id = r.relation_id
    JOIN knowledge_graph.entities e2 ON t.object_id = e2.entity_id
    WHERE e1.entity_uri = p_entity_uri;
END;
$$ LANGUAGE plpgsql;

-- æŸ¥æ‰¾å®ä½“çš„æ‰€æœ‰å…¥è¾¹
CREATE OR REPLACE FUNCTION get_entity_incoming_relations(
    p_entity_uri VARCHAR(500)
)
RETURNS TABLE (
    relation_name VARCHAR(200),
    source_entity_uri VARCHAR(500),
    source_entity_name VARCHAR(200),
    properties JSONB
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        r.relation_name,
        e1.entity_uri AS source_entity_uri,
        e1.entity_name AS source_entity_name,
        t.properties
    FROM knowledge_graph.triples t
    JOIN knowledge_graph.entities e1 ON t.subject_id = e1.entity_id
    JOIN knowledge_graph.relations r ON t.predicate_id = r.relation_id
    JOIN knowledge_graph.entities e2 ON t.object_id = e2.entity_id
    WHERE e2.entity_uri = p_entity_uri;
END;
$$ LANGUAGE plpgsql;
```

**å¤šè·³æŸ¥è¯¢ï¼ˆè·¯å¾„æŸ¥è¯¢ï¼‰**ï¼š

```sql
-- é€’å½’æŸ¥è¯¢ï¼šæŸ¥æ‰¾ä¸¤ä¸ªå®ä½“ä¹‹é—´çš„è·¯å¾„
CREATE OR REPLACE FUNCTION find_path_between_entities(
    p_start_entity_uri VARCHAR(500),
    p_end_entity_uri VARCHAR(500),
    p_max_depth INTEGER DEFAULT 5
)
RETURNS TABLE (
    path_length INTEGER,
    path_triples JSONB
) AS $$
DECLARE
    v_start_id BIGINT;
    v_end_id BIGINT;
BEGIN
    -- è·å–å®ä½“ID
    SELECT entity_id INTO v_start_id
    FROM knowledge_graph.entities
    WHERE entity_uri = p_start_entity_uri;

    SELECT entity_id INTO v_end_id
    FROM knowledge_graph.entities
    WHERE entity_uri = p_end_entity_uri;

    -- é€’å½’æŸ¥è¯¢è·¯å¾„
    RETURN QUERY
    WITH RECURSIVE path_search AS (
        -- åŸºç¡€æƒ…å†µï¼šç›´æ¥è¿æ¥
        SELECT
            t.subject_id AS current_entity,
            t.object_id AS target_entity,
            1 AS depth,
            ARRAY[t.triple_id] AS path_triple_ids,
            ARRAY[jsonb_build_object(
                'subject', e1.entity_uri,
                'predicate', r.relation_name,
                'object', e2.entity_uri
            )] AS path_triples
        FROM knowledge_graph.triples t
        JOIN knowledge_graph.entities e1 ON t.subject_id = e1.entity_id
        JOIN knowledge_graph.relations r ON t.predicate_id = r.relation_id
        JOIN knowledge_graph.entities e2 ON t.object_id = e2.entity_id
        WHERE t.subject_id = v_start_id

        UNION

        -- é€’å½’æƒ…å†µï¼šæ‰©å±•è·¯å¾„
        SELECT
            t.object_id AS current_entity,
            CASE WHEN t.object_id = v_end_id THEN v_end_id ELSE NULL END AS target_entity,
            ps.depth + 1 AS depth,
            ps.path_triple_ids || t.triple_id,
            ps.path_triples || jsonb_build_object(
                'subject', e1.entity_uri,
                'predicate', r.relation_name,
                'object', e2.entity_uri
            )
        FROM path_search ps
        JOIN knowledge_graph.triples t ON ps.current_entity = t.subject_id
        JOIN knowledge_graph.entities e1 ON t.subject_id = e1.entity_id
        JOIN knowledge_graph.relations r ON t.predicate_id = r.relation_id
        JOIN knowledge_graph.entities e2 ON t.object_id = e2.entity_id
        WHERE ps.depth < p_max_depth
          AND t.triple_id != ALL(ps.path_triple_ids)  -- é¿å…å¾ªç¯
          AND ps.target_entity IS NULL  -- æœªæ‰¾åˆ°ç›®æ ‡
    )
    SELECT
        depth AS path_length,
        path_triples
    FROM path_search
    WHERE target_entity = v_end_id
    ORDER BY depth
    LIMIT 10;
END;
$$ LANGUAGE plpgsql;
```

### 3.2. å›¾æ¨¡å¼åŒ¹é…æŸ¥è¯¢

**å­å›¾æ¨¡å¼åŒ¹é…**ï¼š

```sql
-- æŸ¥æ‰¾åŒ¹é…ç‰¹å®šæ¨¡å¼çš„å­å›¾
CREATE OR REPLACE FUNCTION match_graph_pattern(
    p_pattern JSONB
)
RETURNS TABLE (
    match_id BIGINT,
    matched_entities JSONB,
    matched_relations JSONB
) AS $$
DECLARE
    v_pattern_nodes JSONB;
    v_pattern_edges JSONB;
BEGIN
    v_pattern_nodes := p_pattern->'nodes';
    v_pattern_edges := p_pattern->'edges';

    -- å®ç°å›¾æ¨¡å¼åŒ¹é…é€»è¾‘
    -- è¿™é‡Œç®€åŒ–ç¤ºä¾‹ï¼Œå®é™…éœ€è¦å®ç°å­å›¾åŒæ„ç®—æ³•

    RETURN QUERY
    SELECT
        ROW_NUMBER() OVER ()::BIGINT AS match_id,
        '{}'::JSONB AS matched_entities,
        '{}'::JSONB AS matched_relations;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨ç¤ºä¾‹
-- SELECT * FROM match_graph_pattern('{
--   "nodes": [
--     {"type": "Person", "name": "Alice"},
--     {"type": "Company"}
--   ],
--   "edges": [
--     {"from": 0, "to": 1, "relation": "worksAt"}
--   ]
-- }'::JSONB);
```

---

## 4. Neo4jå›¾æ•°æ®åº“è®¾è®¡

### 4.1. Neo4j Schemaè®¾è®¡

**èŠ‚ç‚¹å’Œå…³ç³»è®¾è®¡**ï¼š

```cypher
// åˆ›å»ºèŠ‚ç‚¹çº¦æŸ
CREATE CONSTRAINT person_id IF NOT EXISTS
FOR (p:Person) REQUIRE p.id IS UNIQUE;

CREATE CONSTRAINT company_id IF NOT EXISTS
FOR (c:Company) REQUIRE c.id IS UNIQUE;

CREATE CONSTRAINT location_id IF NOT EXISTS
FOR (l:Location) REQUIRE l.id IS UNIQUE;

// åˆ›å»ºç´¢å¼•
CREATE INDEX person_name IF NOT EXISTS FOR (p:Person) ON (p.name);
CREATE INDEX company_name IF NOT EXISTS FOR (c:Company) ON (c.name);
CREATE INDEX location_name IF NOT EXISTS FOR (l:Location) ON (l.name);

// åˆ›å»ºå…³ç³»ç´¢å¼•
CREATE INDEX works_at_since IF NOT EXISTS
FOR ()-[r:WORKS_AT]-() ON (r.since);
```

### 4.2. Neo4jæ•°æ®å¯¼å…¥

**æ‰¹é‡å¯¼å…¥è„šæœ¬**ï¼š

```cypher
// ä½¿ç”¨LOAD CSVå¯¼å…¥
LOAD CSV WITH HEADERS FROM 'file:///entities.csv' AS row
CREATE (e:Entity {
    id: row.id,
    uri: row.uri,
    type: row.type,
    name: row.name,
    properties: apoc.convert.fromJsonMap(row.properties)
});

// å¯¼å…¥å…³ç³»
LOAD CSV WITH HEADERS FROM 'file:///triples.csv' AS row
MATCH (s:Entity {id: row.subject_id})
MATCH (o:Entity {id: row.object_id})
CREATE (s)-[r:RELATION {
    type: row.predicate,
    confidence: toFloat(row.confidence),
    source: row.source
}]->(o);
```

### 4.3. Neo4jæŸ¥è¯¢ä¼˜åŒ–

**æŸ¥è¯¢ä¼˜åŒ–æŠ€å·§**ï¼š

```cypher
// 1. ä½¿ç”¨ç´¢å¼•æç¤º
MATCH (p:Person)
USING INDEX p:Person(name)
WHERE p.name = 'Alice'
RETURN p;

// 2. é™åˆ¶æŸ¥è¯¢æ·±åº¦
MATCH path = (a:Person {name: 'Alice'})-[*1..3]-(b:Person {name: 'Bob'})
RETURN path
LIMIT 10;

// 3. ä½¿ç”¨PROFILEåˆ†ææŸ¥è¯¢è®¡åˆ’
PROFILE
MATCH (p:Person)-[:WORKS_AT]->(c:Company)
WHERE p.age > 25
RETURN p.name, c.name;

// 4. ä½¿ç”¨EXPLAINæŸ¥çœ‹æ‰§è¡Œè®¡åˆ’
EXPLAIN
MATCH (p:Person)-[:KNOWS*2..4]-(friend:Person)
RETURN DISTINCT friend.name;
```

---

## 5. PostgreSQLå›¾æ‰©å±•è®¾è®¡

### 5.1. Apache AGEé›†æˆ

**Apache AGE Schemaè®¾è®¡**ï¼š

```sql
-- å¯ç”¨Apache AGEæ‰©å±•
CREATE EXTENSION IF NOT EXISTS age;

-- åˆ›å»ºå›¾
SELECT create_graph('knowledge_graph');

-- åˆ›å»ºèŠ‚ç‚¹æ ‡ç­¾
SELECT * FROM cypher('knowledge_graph', $$
    CREATE (p:Person {
        id: 1,
        name: 'Alice',
        age: 30
    })
    RETURN p
$$) AS (p agtype);

-- åˆ›å»ºå…³ç³»
SELECT * FROM cypher('knowledge_graph', $$
    MATCH (p:Person {id: 1})
    MATCH (c:Company {id: 1})
    CREATE (p)-[r:WORKS_AT {
        since: '2020-01-01',
        position: 'Engineer'
    }]->(c)
    RETURN r
$$) AS (r agtype);
```

### 5.2. PostgreSQLå›¾æŸ¥è¯¢

**CypheræŸ¥è¯¢ç¤ºä¾‹**ï¼š

```sql
-- æŸ¥æ‰¾ä¸€ä¸ªäººçš„æ‰€æœ‰åŒäº‹
SELECT * FROM cypher('knowledge_graph', $$
    MATCH (p1:Person {name: 'Alice'})-[:WORKS_AT]->(c:Company)<-[:WORKS_AT]-(p2:Person)
    WHERE p1 <> p2
    RETURN p2.name AS colleague_name
$$) AS (colleague_name agtype);

-- æŸ¥æ‰¾ä¸¤ä¸ªå®ä½“ä¹‹é—´çš„æœ€çŸ­è·¯å¾„
SELECT * FROM cypher('knowledge_graph', $$
    MATCH path = shortestPath(
        (a:Person {name: 'Alice'})-[*]-(b:Person {name: 'Bob'})
    )
    RETURN path
$$) AS (path agtype);
```

---

## 6. çŸ¥è¯†å›¾è°±æŸ¥è¯¢ä¼˜åŒ–

### 6.1. æŸ¥è¯¢ä¼˜åŒ–ç­–ç•¥

**ä¼˜åŒ–å†³ç­–æ ‘**ï¼š

```mermaid
flowchart TD
    A[çŸ¥è¯†å›¾è°±æŸ¥è¯¢ä¼˜åŒ–] --> B{æŸ¥è¯¢ç±»å‹}

    B -->|å•è·³æŸ¥è¯¢| C[ä½¿ç”¨ç´¢å¼•]
    B -->|å¤šè·³æŸ¥è¯¢| D{æŸ¥è¯¢æ·±åº¦}
    B -->|æ¨¡å¼åŒ¹é…| E[æŸ¥è¯¢é‡å†™]

    C --> F[å®ä½“ç´¢å¼•]
    C --> G[å…³ç³»ç´¢å¼•]

    D -->|æ·±åº¦<=3| H[é€’å½’CTE]
    D -->|æ·±åº¦>3| I[ç‰©åŒ–è·¯å¾„]

    E --> J[å­å›¾åˆ†è§£]
    E --> K[æ¨¡å¼ç´¢å¼•]

    F --> L[ä¼˜åŒ–å®Œæˆ]
    G --> L
    H --> L
    I --> L
    J --> L
    K --> L
```

### 6.2. ç´¢å¼•ä¼˜åŒ–

**å¤åˆç´¢å¼•è®¾è®¡**ï¼š

```sql
-- é’ˆå¯¹å¸¸è§æŸ¥è¯¢æ¨¡å¼çš„å¤åˆç´¢å¼•
CREATE INDEX idx_triples_subject_predicate
ON knowledge_graph.triples(subject_id, predicate_id);

CREATE INDEX idx_triples_object_predicate
ON knowledge_graph.triples(object_id, predicate_id);

-- éƒ¨åˆ†ç´¢å¼•ï¼ˆåªç´¢å¼•æ´»è·ƒæ•°æ®ï¼‰
CREATE INDEX idx_triples_active
ON knowledge_graph.triples(subject_id, predicate_id, object_id)
WHERE confidence >= 0.8;

-- è¡¨è¾¾å¼ç´¢å¼•ï¼ˆæ”¯æŒå±æ€§æŸ¥è¯¢ï¼‰
CREATE INDEX idx_entities_name_lower
ON knowledge_graph.entities(LOWER(entity_name));
```

### 6.3. æŸ¥è¯¢é‡å†™ä¼˜åŒ–

**æŸ¥è¯¢é‡å†™è§„åˆ™**ï¼š

```sql
-- ä¼˜åŒ–ï¼šå°†å¤šè¡¨JOINæ”¹ä¸ºå•è¡¨æŸ¥è¯¢
-- åŸå§‹æŸ¥è¯¢ï¼ˆæ…¢ï¼‰
SELECT e1.entity_name, r.relation_name, e2.entity_name
FROM knowledge_graph.triples t
JOIN knowledge_graph.entities e1 ON t.subject_id = e1.entity_id
JOIN knowledge_graph.relations r ON t.predicate_id = r.relation_id
JOIN knowledge_graph.entities e2 ON t.object_id = e2.entity_id
WHERE e1.entity_uri = 'http://example.org/Alice';

-- ä¼˜åŒ–æŸ¥è¯¢ï¼ˆå¿«ï¼‰
WITH subject_entity AS (
    SELECT entity_id FROM knowledge_graph.entities
    WHERE entity_uri = 'http://example.org/Alice'
)
SELECT
    e1.entity_name,
    r.relation_name,
    e2.entity_name
FROM knowledge_graph.triples t
CROSS JOIN subject_entity se
JOIN knowledge_graph.entities e1 ON t.subject_id = e1.entity_id
JOIN knowledge_graph.relations r ON t.predicate_id = r.relation_id
JOIN knowledge_graph.entities e2 ON t.object_id = e2.entity_id
WHERE t.subject_id = se.entity_id;
```

---

## 7. å®é™…åº”ç”¨æ¡ˆä¾‹

### 7.1. ä¼ä¸šçŸ¥è¯†å›¾è°±æ¡ˆä¾‹

**Schemaè®¾è®¡**ï¼š

```sql
-- ä¼ä¸šçŸ¥è¯†å›¾è°±Schema
CREATE SCHEMA enterprise_kg;

-- äººå‘˜å®ä½“
CREATE TABLE enterprise_kg.persons (
    person_id BIGSERIAL PRIMARY KEY,
    employee_id VARCHAR(50) UNIQUE NOT NULL,
    name VARCHAR(200) NOT NULL,
    email VARCHAR(200),
    department VARCHAR(100),
    position VARCHAR(100),
    properties JSONB
);

-- é¡¹ç›®å®ä½“
CREATE TABLE enterprise_kg.projects (
    project_id BIGSERIAL PRIMARY KEY,
    project_code VARCHAR(50) UNIQUE NOT NULL,
    project_name VARCHAR(200) NOT NULL,
    status VARCHAR(50),
    start_date DATE,
    end_date DATE,
    properties JSONB
);

-- æŠ€èƒ½å®ä½“
CREATE TABLE enterprise_kg.skills (
    skill_id BIGSERIAL PRIMARY KEY,
    skill_name VARCHAR(100) UNIQUE NOT NULL,
    category VARCHAR(50),
    properties JSONB
);

-- å…³ç³»è¡¨
CREATE TABLE enterprise_kg.person_project_relations (
    person_id BIGINT REFERENCES enterprise_kg.persons(person_id),
    project_id BIGINT REFERENCES enterprise_kg.projects(project_id),
    role VARCHAR(50),  -- LEADER, MEMBER, CONSULTANT
    start_date DATE,
    end_date DATE,
    PRIMARY KEY (person_id, project_id)
);

CREATE TABLE enterprise_kg.person_skill_relations (
    person_id BIGINT REFERENCES enterprise_kg.persons(person_id),
    skill_id BIGINT REFERENCES enterprise_kg.skills(skill_id),
    proficiency_level INTEGER CHECK (proficiency_level BETWEEN 1 AND 5),
    certified BOOLEAN DEFAULT FALSE,
    PRIMARY KEY (person_id, skill_id)
);

-- æŸ¥è¯¢ï¼šæŸ¥æ‰¾å…·æœ‰ç‰¹å®šæŠ€èƒ½çš„é¡¹ç›®æˆå‘˜
CREATE OR REPLACE FUNCTION find_project_members_with_skill(
    p_project_code VARCHAR(50),
    p_skill_name VARCHAR(100),
    p_min_proficiency INTEGER DEFAULT 3
)
RETURNS TABLE (
    person_name VARCHAR(200),
    role VARCHAR(50),
    proficiency_level INTEGER
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        p.name AS person_name,
        ppr.role,
        psr.proficiency_level
    FROM enterprise_kg.persons p
    JOIN enterprise_kg.person_project_relations ppr ON p.person_id = ppr.person_id
    JOIN enterprise_kg.projects prj ON ppr.project_id = prj.project_id
    JOIN enterprise_kg.person_skill_relations psr ON p.person_id = psr.person_id
    JOIN enterprise_kg.skills s ON psr.skill_id = s.skill_id
    WHERE prj.project_code = p_project_code
      AND s.skill_name = p_skill_name
      AND psr.proficiency_level >= p_min_proficiency;
END;
$$ LANGUAGE plpgsql;
```

### 7.2. æ¨èç³»ç»ŸçŸ¥è¯†å›¾è°±æ¡ˆä¾‹

**æ¨èç³»ç»ŸSchema**ï¼š

```sql
CREATE SCHEMA recommendation_kg;

-- ç”¨æˆ·å®ä½“
CREATE TABLE recommendation_kg.users (
    user_id BIGSERIAL PRIMARY KEY,
    username VARCHAR(100) UNIQUE NOT NULL,
    age INTEGER,
    gender VARCHAR(10),
    location VARCHAR(100),
    properties JSONB
);

-- å•†å“å®ä½“
CREATE TABLE recommendation_kg.items (
    item_id BIGSERIAL PRIMARY KEY,
    item_name VARCHAR(200) NOT NULL,
    category VARCHAR(100),
    price DECIMAL(10,2),
    properties JSONB
);

-- ç”¨æˆ·-å•†å“å…³ç³»ï¼ˆè´­ä¹°ã€æµè§ˆã€æ”¶è—ç­‰ï¼‰
CREATE TABLE recommendation_kg.user_item_relations (
    user_id BIGINT REFERENCES recommendation_kg.users(user_id),
    item_id BIGINT REFERENCES recommendation_kg.items(item_id),
    relation_type VARCHAR(50) NOT NULL,  -- PURCHASED, VIEWED, LIKED, RATED
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    rating INTEGER CHECK (rating BETWEEN 1 AND 5),
    PRIMARY KEY (user_id, item_id, relation_type)
);

-- å•†å“ç›¸ä¼¼åº¦å…³ç³»ï¼ˆåŸºäºçŸ¥è¯†å›¾è°±è®¡ç®—ï¼‰
CREATE TABLE recommendation_kg.item_similarity (
    item1_id BIGINT REFERENCES recommendation_kg.items(item_id),
    item2_id BIGINT REFERENCES recommendation_kg.items(item_id),
    similarity_score DECIMAL(5,4) NOT NULL,
    similarity_type VARCHAR(50),  -- CATEGORY, BRAND, FEATURE
    PRIMARY KEY (item1_id, item2_id),
    CHECK (item1_id < item2_id)  -- é¿å…é‡å¤
);

-- æ¨èæŸ¥è¯¢ï¼šåŸºäºçŸ¥è¯†å›¾è°±çš„ååŒè¿‡æ»¤
CREATE OR REPLACE FUNCTION recommend_items_by_kg(
    p_user_id BIGINT,
    p_top_k INTEGER DEFAULT 10
)
RETURNS TABLE (
    item_id BIGINT,
    item_name VARCHAR(200),
    recommendation_score DECIMAL(5,4),
    reason TEXT
) AS $$
BEGIN
    RETURN QUERY
    WITH user_purchased_items AS (
        SELECT item_id
        FROM recommendation_kg.user_item_relations
        WHERE user_id = p_user_id
          AND relation_type = 'PURCHASED'
    ),
    similar_users AS (
        SELECT DISTINCT uir2.user_id
        FROM recommendation_kg.user_item_relations uir1
        JOIN recommendation_kg.user_item_relations uir2
            ON uir1.item_id = uir2.item_id
        WHERE uir1.user_id = p_user_id
          AND uir2.user_id <> p_user_id
          AND uir1.relation_type = 'PURCHASED'
          AND uir2.relation_type = 'PURCHASED'
    ),
    candidate_items AS (
        SELECT DISTINCT uir.item_id
        FROM recommendation_kg.user_item_relations uir
        JOIN similar_users su ON uir.user_id = su.user_id
        WHERE uir.relation_type = 'PURCHASED'
          AND uir.item_id NOT IN (SELECT item_id FROM user_purchased_items)
    )
    SELECT
        i.item_id,
        i.item_name,
        COUNT(*)::DECIMAL / (SELECT COUNT(*) FROM similar_users) AS recommendation_score,
        'Similar users also purchased' AS reason
    FROM candidate_items ci
    JOIN recommendation_kg.items i ON ci.item_id = i.item_id
    GROUP BY i.item_id, i.item_name
    ORDER BY recommendation_score DESC
    LIMIT p_top_k;
END;
$$ LANGUAGE plpgsql;
```

---

## 8. å‚è€ƒèµ„æ–™

- [çŸ¥è¯†å›¾è°±ç†è®º](../01-ç†è®ºæ¨¡å‹/01.04-çŸ¥è¯†å›¾è°±ç†è®º.md)
- [çŸ¥è¯†æ¨ç†ä¸å½’çº³ç†è®º](../01-ç†è®ºæ¨¡å‹/01.06-çŸ¥è¯†æ¨ç†ä¸å½’çº³ç†è®º.md)
- [PostgreSQLå›¾æ•°æ®åº“åŠŸèƒ½](../../PostgreSQL/04-é«˜çº§ç‰¹æ€§/03.06-å›¾æ•°æ®åº“åŠŸèƒ½.md)

---

**æœ€åæ›´æ–°**ï¼š2025-01-15
**ç»´æŠ¤è€…**ï¼šData-Science Team
**çŠ¶æ€**ï¼šå®æ–½ä¸­
