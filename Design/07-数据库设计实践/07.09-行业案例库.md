# è¡Œä¸šæ¡ˆä¾‹åº“ï¼šæ•°æ®åº“è®¾è®¡çš„å®é™…åº”ç”¨æ¡ˆä¾‹

> **åˆ›å»ºæ—¥æœŸ**ï¼š2025-01-15
> **æœ€åæ›´æ–°**ï¼š2025-12-01
> **ç‰ˆæœ¬**ï¼šv2.0 (å¢å¼ºç‰ˆ)
> **çŠ¶æ€**ï¼šå·²å®Œæˆ âœ…

---

## ğŸ“‹ ç›®å½•

- [è¡Œä¸šæ¡ˆä¾‹åº“ï¼šæ•°æ®åº“è®¾è®¡çš„å®é™…åº”ç”¨æ¡ˆä¾‹](#è¡Œä¸šæ¡ˆä¾‹åº“æ•°æ®åº“è®¾è®¡çš„å®é™…åº”ç”¨æ¡ˆä¾‹)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1. æ¡ˆä¾‹åˆ†ç±»](#11-æ¡ˆä¾‹åˆ†ç±»)
  - [2. ç”µå•†è¡Œä¸šæ¡ˆä¾‹](#2-ç”µå•†è¡Œä¸šæ¡ˆä¾‹)
    - [2.1. å¤§å‹ç”µå•†å¹³å°Schemaè®¾è®¡](#21-å¤§å‹ç”µå•†å¹³å°schemaè®¾è®¡)
    - [2.2. è®¾è®¡å†³ç­–è¯´æ˜](#22-è®¾è®¡å†³ç­–è¯´æ˜)
  - [3. é‡‘èè¡Œä¸šæ¡ˆä¾‹](#3-é‡‘èè¡Œä¸šæ¡ˆä¾‹)
    - [3.1. é“¶è¡Œæ ¸å¿ƒç³»ç»ŸSchemaè®¾è®¡](#31-é“¶è¡Œæ ¸å¿ƒç³»ç»Ÿschemaè®¾è®¡)
    - [3.2. é£æ§ç³»ç»Ÿè®¾è®¡](#32-é£æ§ç³»ç»Ÿè®¾è®¡)
  - [4. ç¤¾äº¤ç½‘ç»œæ¡ˆä¾‹](#4-ç¤¾äº¤ç½‘ç»œæ¡ˆä¾‹)
    - [4.1. ç¤¾äº¤ç½‘ç»œæ ¸å¿ƒSchema](#41-ç¤¾äº¤ç½‘ç»œæ ¸å¿ƒschema)
  - [5. ç‰©è”ç½‘æ¡ˆä¾‹](#5-ç‰©è”ç½‘æ¡ˆä¾‹)
    - [5.1. IoTè®¾å¤‡æ•°æ®Schema](#51-iotè®¾å¤‡æ•°æ®schema)
  - [6. å†…å®¹ç®¡ç†ç³»ç»Ÿæ¡ˆä¾‹](#6-å†…å®¹ç®¡ç†ç³»ç»Ÿæ¡ˆä¾‹)
    - [6.1. CMS Schemaè®¾è®¡](#61-cms-schemaè®¾è®¡)
  - [7. 2024-2025è¡Œä¸šæ¡ˆä¾‹è¶‹åŠ¿](#7-2024-2025è¡Œä¸šæ¡ˆä¾‹è¶‹åŠ¿)
    - [7.1. è¡Œä¸šæ•°æ®åº“è®¾è®¡æ¼”è¿›](#71-è¡Œä¸šæ•°æ®åº“è®¾è®¡æ¼”è¿›)
    - [7.2. è¡Œä¸šæ¡ˆä¾‹é€‰å‹çŸ©é˜µ](#72-è¡Œä¸šæ¡ˆä¾‹é€‰å‹çŸ©é˜µ)
    - [7.3. AIåº”ç”¨è¡Œä¸šæ¡ˆä¾‹](#73-aiåº”ç”¨è¡Œä¸šæ¡ˆä¾‹)
  - [8. å‚è€ƒèµ„æ–™](#8-å‚è€ƒèµ„æ–™)
    - [8.1. æƒå¨æ–‡çŒ®](#81-æƒå¨æ–‡çŒ®)
    - [8.2. åœ¨çº¿èµ„æº](#82-åœ¨çº¿èµ„æº)
    - [8.3. ç›¸å…³æ–‡æ¡£](#83-ç›¸å…³æ–‡æ¡£)

---

## 1. æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›ä¸åŒè¡Œä¸šçš„æ•°æ®åº“è®¾è®¡å®é™…æ¡ˆä¾‹ï¼Œæ¯ä¸ªæ¡ˆä¾‹åŒ…å«å®Œæ•´çš„Schemaè®¾è®¡ã€è®¾è®¡å†³ç­–å’Œä¼˜åŒ–ç­–ç•¥ã€‚

### 1.1. æ¡ˆä¾‹åˆ†ç±»

```mermaid
mindmap
  root((è¡Œä¸šæ¡ˆä¾‹))
    ç”µå•†è¡Œä¸š
      å•†å“ç®¡ç†
      è®¢å•å¤„ç†
      åº“å­˜ç®¡ç†
      æ”¯ä»˜ç³»ç»Ÿ
    é‡‘èè¡Œä¸š
      è´¦æˆ·ç®¡ç†
      äº¤æ˜“è®°å½•
      é£æ§ç³»ç»Ÿ
      æŠ¥è¡¨ç³»ç»Ÿ
    ç¤¾äº¤ç½‘ç»œ
      ç”¨æˆ·å…³ç³»
      å†…å®¹å‘å¸ƒ
      æ¶ˆæ¯ç³»ç»Ÿ
      æ¨èç³»ç»Ÿ
    ç‰©è”ç½‘
      è®¾å¤‡ç®¡ç†
      æ•°æ®é‡‡é›†
      å®æ—¶ç›‘æ§
      æ•°æ®åˆ†æ
    å†…å®¹ç®¡ç†
      æ–‡ç« ç®¡ç†
      åª’ä½“å­˜å‚¨
      æƒé™æ§åˆ¶
      ç‰ˆæœ¬ç®¡ç†
```

---

## 2. ç”µå•†è¡Œä¸šæ¡ˆä¾‹

### 2.1. å¤§å‹ç”µå•†å¹³å°Schemaè®¾è®¡

**ä¸šåŠ¡ç‰¹ç‚¹**ï¼š

- é«˜å¹¶å‘è¯»å†™
- æµ·é‡å•†å“æ•°æ®
- å¤æ‚è®¢å•æµç¨‹
- å®æ—¶åº“å­˜ç®¡ç†

**å®Œæ•´Schemaè®¾è®¡**ï¼š

```sql
-- ============================================
-- ç”¨æˆ·åŸŸ
-- ============================================

CREATE SCHEMA user_domain;

-- ç”¨æˆ·ä¸»è¡¨ï¼ˆåˆ†è¡¨è®¾è®¡ï¼‰
CREATE TABLE user_domain.users_0 (
    user_id BIGINT PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    phone VARCHAR(20) UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    status VARCHAR(20) DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) PARTITION BY HASH (user_id);

-- ç”¨æˆ·åˆ†è¡¨ï¼ˆæŒ‰user_idå“ˆå¸Œï¼‰
CREATE TABLE user_domain.users_0_p0 PARTITION OF user_domain.users_0
    FOR VALUES WITH (MODULUS 4, REMAINDER 0);
CREATE TABLE user_domain.users_0_p1 PARTITION OF user_domain.users_0
    FOR VALUES WITH (MODULUS 4, REMAINDER 1);
CREATE TABLE user_domain.users_0_p2 PARTITION OF user_domain.users_0
    FOR VALUES WITH (MODULUS 4, REMAINDER 2);
CREATE TABLE user_domain.users_0_p3 PARTITION OF user_domain.users_0
    FOR VALUES WITH (MODULUS 4, REMAINDER 3);

-- ç”¨æˆ·åœ°å€è¡¨
CREATE TABLE user_domain.addresses (
    address_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL,
    address_type VARCHAR(20) NOT NULL,  -- home, work, other
    recipient_name VARCHAR(100) NOT NULL,
    phone VARCHAR(20) NOT NULL,
    province VARCHAR(50) NOT NULL,
    city VARCHAR(50) NOT NULL,
    district VARCHAR(50) NOT NULL,
    street VARCHAR(200) NOT NULL,
    postal_code VARCHAR(10),
    is_default BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_addresses_user ON user_domain.addresses(user_id);
CREATE INDEX idx_addresses_user_default ON user_domain.addresses(user_id, is_default)
    WHERE is_default = TRUE;

-- ============================================
-- å•†å“åŸŸ
-- ============================================

CREATE SCHEMA product_domain;

-- å•†å“åˆ†ç±»è¡¨ï¼ˆæ ‘å½¢ç»“æ„ï¼‰
CREATE TABLE product_domain.categories (
    category_id BIGSERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    parent_id BIGINT REFERENCES product_domain.categories(category_id),
    level INTEGER NOT NULL,
    path TEXT NOT NULL,  -- è·¯å¾„ï¼š/1/2/3
    sort_order INTEGER DEFAULT 0,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_categories_parent ON product_domain.categories(parent_id);
CREATE INDEX idx_categories_path ON product_domain.categories USING GIN (path gin_trgm_ops);

-- å•†å“ä¸»è¡¨
CREATE TABLE product_domain.products (
    product_id BIGSERIAL PRIMARY KEY,
    spu_code VARCHAR(50) UNIQUE NOT NULL,  -- å•†å“ç¼–ç 
    name VARCHAR(200) NOT NULL,
    title VARCHAR(300),  -- SEOæ ‡é¢˜
    description TEXT,
    category_id BIGINT NOT NULL REFERENCES product_domain.categories(category_id),
    brand_id BIGINT,
    price DECIMAL(10,2) NOT NULL CHECK (price > 0),
    original_price DECIMAL(10,2),
    cost_price DECIMAL(10,2),  -- æˆæœ¬ä»·
    weight DECIMAL(8,2),
    volume DECIMAL(8,2),
    status VARCHAR(20) DEFAULT 'draft',  -- draft, active, inactive, deleted
    sales_count INTEGER DEFAULT 0,
    view_count INTEGER DEFAULT 0,
    rating_average DECIMAL(3,2) DEFAULT 0 CHECK (rating_average >= 0 AND rating_average <= 5),
    rating_count INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) PARTITION BY RANGE (created_at);

-- æŒ‰æœˆåˆ†åŒº
CREATE TABLE product_domain.products_2024_01 PARTITION OF product_domain.products
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

CREATE INDEX idx_products_category ON product_domain.products(category_id);
CREATE INDEX idx_products_status ON product_domain.products(status) WHERE status = 'active';
CREATE INDEX idx_products_price ON product_domain.products(price);
CREATE INDEX idx_products_rating ON product_domain.products(rating_average DESC, rating_count DESC);
CREATE INDEX idx_products_search ON product_domain.products USING GIN (
    to_tsvector('english', name || ' ' || COALESCE(title, '') || ' ' || COALESCE(description, ''))
);

-- å•†å“SKUè¡¨ï¼ˆè§„æ ¼ï¼‰
CREATE TABLE product_domain.product_skus (
    sku_id BIGSERIAL PRIMARY KEY,
    product_id BIGINT NOT NULL REFERENCES product_domain.products(product_id) ON DELETE CASCADE,
    sku_code VARCHAR(50) UNIQUE NOT NULL,
    attributes JSONB NOT NULL,  -- {"color": "red", "size": "L", "material": "cotton"}
    price DECIMAL(10,2) NOT NULL,
    cost_price DECIMAL(10,2),
    stock INTEGER DEFAULT 0 CHECK (stock >= 0),
    reserved_stock INTEGER DEFAULT 0 CHECK (reserved_stock >= 0),  -- å·²é¢„è®¢åº“å­˜
    available_stock INTEGER GENERATED ALWAYS AS (stock - reserved_stock) STORED,
    weight DECIMAL(8,2),
    barcode VARCHAR(50),
    is_default BOOLEAN DEFAULT FALSE,
    status VARCHAR(20) DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_product_skus_product ON product_domain.product_skus(product_id);
CREATE INDEX idx_product_skus_code ON product_domain.product_skus(sku_code);
CREATE INDEX idx_product_skus_stock ON product_domain.product_skus(available_stock)
    WHERE status = 'active';
CREATE INDEX idx_product_skus_attributes ON product_domain.product_skus USING GIN (attributes);

-- åº“å­˜å˜æ›´æ—¥å¿—ï¼ˆç”¨äºåº“å­˜è¿½æº¯ï¼‰
CREATE TABLE product_domain.stock_logs (
    log_id BIGSERIAL PRIMARY KEY,
    sku_id BIGINT NOT NULL REFERENCES product_domain.product_skus(sku_id),
    change_type VARCHAR(20) NOT NULL,  -- IN, OUT, RESERVE, RELEASE, ADJUST
    quantity INTEGER NOT NULL,
    before_stock INTEGER NOT NULL,
    after_stock INTEGER NOT NULL,
    reference_type VARCHAR(50),  -- ORDER, RETURN, ADJUSTMENT
    reference_id BIGINT,
    operator_id BIGINT,
    remark TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) PARTITION BY RANGE (created_at);

CREATE INDEX idx_stock_logs_sku ON product_domain.stock_logs(sku_id, created_at DESC);
CREATE INDEX idx_stock_logs_reference ON product_domain.stock_logs(reference_type, reference_id);

-- ============================================
-- è®¢å•åŸŸ
-- ============================================

CREATE SCHEMA order_domain;

-- è®¢å•ä¸»è¡¨
CREATE TABLE order_domain.orders (
    order_id BIGSERIAL PRIMARY KEY,
    order_number VARCHAR(50) UNIQUE NOT NULL,
    user_id BIGINT NOT NULL,
    order_type VARCHAR(20) DEFAULT 'normal',  -- normal, group, presale
    total_amount DECIMAL(10,2) NOT NULL CHECK (total_amount > 0),
    discount_amount DECIMAL(10,2) DEFAULT 0,
    shipping_fee DECIMAL(10,2) DEFAULT 0,
    final_amount DECIMAL(10,2) NOT NULL,
    payment_amount DECIMAL(10,2) DEFAULT 0,
    refund_amount DECIMAL(10,2) DEFAULT 0,
    status VARCHAR(20) DEFAULT 'pending',  -- pending, paid, shipped, completed, cancelled, refunded
    payment_status VARCHAR(20) DEFAULT 'unpaid',  -- unpaid, paid, partial_refund, refunded
    shipping_status VARCHAR(20) DEFAULT 'unshipped',  -- unshipped, shipped, delivered
    shipping_address JSONB NOT NULL,
    payment_method VARCHAR(50),
    payment_transaction_id VARCHAR(100),
    remark TEXT,
    order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    paid_at TIMESTAMP,
    shipped_at TIMESTAMP,
    completed_at TIMESTAMP,
    cancelled_at TIMESTAMP,
    cancel_reason TEXT
) PARTITION BY RANGE (order_date);

-- æŒ‰æœˆåˆ†åŒº
CREATE TABLE order_domain.orders_2024_01 PARTITION OF order_domain.orders
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

CREATE INDEX idx_orders_user ON order_domain.orders(user_id, order_date DESC);
CREATE INDEX idx_orders_number ON order_domain.orders(order_number);
CREATE INDEX idx_orders_status ON order_domain.orders(status);
CREATE INDEX idx_orders_payment_status ON order_domain.orders(payment_status);
CREATE INDEX idx_orders_date ON order_domain.orders(order_date DESC);

-- è®¢å•é¡¹è¡¨
CREATE TABLE order_domain.order_items (
    item_id BIGSERIAL PRIMARY KEY,
    order_id BIGINT NOT NULL,
    product_id BIGINT NOT NULL,
    sku_id BIGINT,
    product_name VARCHAR(200) NOT NULL,  -- å¿«ç…§
    product_image VARCHAR(500),
    sku_attributes JSONB,  -- å¿«ç…§
    price DECIMAL(10,2) NOT NULL,  -- è®¢å•æ—¶çš„ä»·æ ¼
    cost_price DECIMAL(10,2),  -- æˆæœ¬ä»·
    quantity INTEGER NOT NULL CHECK (quantity > 0),
    subtotal DECIMAL(10,2) NOT NULL,
    discount_amount DECIMAL(10,2) DEFAULT 0,
    final_amount DECIMAL(10,2) NOT NULL,
    refund_quantity INTEGER DEFAULT 0,
    refund_amount DECIMAL(10,2) DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (order_id) REFERENCES order_domain.orders(order_id) ON DELETE CASCADE
) PARTITION BY RANGE (created_at);

CREATE INDEX idx_order_items_order ON order_domain.order_items(order_id);
CREATE INDEX idx_order_items_product ON order_domain.order_items(product_id);
CREATE INDEX idx_order_items_sku ON order_domain.order_items(sku_id);

-- è®¢å•çŠ¶æ€å˜æ›´æ—¥å¿—
CREATE TABLE order_domain.order_status_logs (
    log_id BIGSERIAL PRIMARY KEY,
    order_id BIGINT NOT NULL,
    old_status VARCHAR(20),
    new_status VARCHAR(20) NOT NULL,
    changed_by VARCHAR(50),  -- user_id or system
    change_reason TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) PARTITION BY RANGE (created_at);

CREATE INDEX idx_order_status_logs_order ON order_domain.order_status_logs(order_id, created_at DESC);

-- ============================================
-- è´­ç‰©è½¦åŸŸ
-- ============================================

CREATE SCHEMA cart_domain;

-- è´­ç‰©è½¦è¡¨
CREATE TABLE cart_domain.carts (
    cart_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL UNIQUE,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_carts_user ON cart_domain.carts(user_id);

-- è´­ç‰©è½¦é¡¹è¡¨
CREATE TABLE cart_domain.cart_items (
    item_id BIGSERIAL PRIMARY KEY,
    cart_id BIGINT NOT NULL REFERENCES cart_domain.carts(cart_id) ON DELETE CASCADE,
    product_id BIGINT NOT NULL,
    sku_id BIGINT,
    quantity INTEGER NOT NULL CHECK (quantity > 0),
    added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(cart_id, product_id, sku_id)
);

CREATE INDEX idx_cart_items_cart ON cart_domain.cart_items(cart_id);
CREATE INDEX idx_cart_items_product ON cart_domain.cart_items(product_id);

-- ============================================
-- æ”¯ä»˜åŸŸ
-- ============================================

CREATE SCHEMA payment_domain;

-- æ”¯ä»˜è®°å½•è¡¨
CREATE TABLE payment_domain.payments (
    payment_id BIGSERIAL PRIMARY KEY,
    order_id BIGINT NOT NULL,
    payment_number VARCHAR(50) UNIQUE NOT NULL,
    payment_method VARCHAR(50) NOT NULL,  -- alipay, wechat, credit_card
    amount DECIMAL(10,2) NOT NULL,
    status VARCHAR(20) DEFAULT 'pending',  -- pending, processing, success, failed, refunded
    transaction_id VARCHAR(100),
    third_party_response JSONB,
    paid_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) PARTITION BY RANGE (created_at);

CREATE INDEX idx_payments_order ON payment_domain.payments(order_id);
CREATE INDEX idx_payments_number ON payment_domain.payments(payment_number);
CREATE INDEX idx_payments_status ON payment_domain.payments(status);
CREATE INDEX idx_payments_transaction ON payment_domain.payments(transaction_id);

-- ============================================
-- è§¦å‘å™¨ï¼šè‡ªåŠ¨æ›´æ–°å•†å“è¯„åˆ†
-- ============================================

CREATE SCHEMA review_domain;

CREATE TABLE review_domain.reviews (
    review_id BIGSERIAL PRIMARY KEY,
    product_id BIGINT NOT NULL,
    user_id BIGINT NOT NULL,
    order_id BIGINT,
    sku_id BIGINT,
    rating INTEGER NOT NULL CHECK (rating >= 1 AND rating <= 5),
    title VARCHAR(200),
    content TEXT,
    images TEXT[],
    is_anonymous BOOLEAN DEFAULT FALSE,
    helpful_count INTEGER DEFAULT 0,
    status VARCHAR(20) DEFAULT 'pending',  -- pending, approved, rejected
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(product_id, user_id, order_id)
);

CREATE INDEX idx_reviews_product ON review_domain.reviews(product_id, rating DESC, created_at DESC);
CREATE INDEX idx_reviews_user ON review_domain.reviews(user_id);
CREATE INDEX idx_reviews_order ON review_domain.reviews(order_id);

-- æ›´æ–°å•†å“è¯„åˆ†çš„è§¦å‘å™¨å‡½æ•°
CREATE OR REPLACE FUNCTION update_product_rating()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE product_domain.products
    SET
        rating_average = (
            SELECT AVG(rating)::DECIMAL(3,2)
            FROM review_domain.reviews
            WHERE product_id = NEW.product_id AND status = 'approved'
        ),
        rating_count = (
            SELECT COUNT(*)
            FROM review_domain.reviews
            WHERE product_id = NEW.product_id AND status = 'approved'
        )
    WHERE id = NEW.product_id;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER product_rating_update
AFTER INSERT OR UPDATE ON review_domain.reviews
FOR EACH ROW
WHEN (NEW.status = 'approved')
EXECUTE FUNCTION update_product_rating();
```

### 2.2. è®¾è®¡å†³ç­–è¯´æ˜

**å…³é”®è®¾è®¡å†³ç­–**ï¼š

1. **åˆ†è¡¨ç­–ç•¥**ï¼š
   - ç”¨æˆ·è¡¨æŒ‰user_idå“ˆå¸Œåˆ†è¡¨ï¼Œæ”¯æŒæ°´å¹³æ‰©å±•
   - è®¢å•è¡¨æŒ‰æ—¶é—´åˆ†åŒºï¼Œä¾¿äºå†å²æ•°æ®ç®¡ç†

2. **åº“å­˜ç®¡ç†**ï¼š
   - ä½¿ç”¨reserved_stockå­—æ®µå¤„ç†è®¢å•é¢„è®¢
   - available_stockä½¿ç”¨ç”Ÿæˆåˆ—è‡ªåŠ¨è®¡ç®—
   - stock_logsè¡¨è®°å½•æ‰€æœ‰åº“å­˜å˜æ›´

3. **ä»·æ ¼å¿«ç…§**ï¼š
   - è®¢å•é¡¹å­˜å‚¨å•†å“ä»·æ ¼å¿«ç…§ï¼Œä¿è¯å†å²ä»·æ ¼å‡†ç¡®æ€§

4. **æœç´¢ä¼˜åŒ–**ï¼š
   - ä½¿ç”¨å…¨æ–‡æœç´¢ç´¢å¼•ä¼˜åŒ–å•†å“æœç´¢
   - JSONBç´¢å¼•æ”¯æŒSKUå±æ€§æŸ¥è¯¢

---

## 3. é‡‘èè¡Œä¸šæ¡ˆä¾‹

### 3.1. é“¶è¡Œæ ¸å¿ƒç³»ç»ŸSchemaè®¾è®¡

**ä¸šåŠ¡ç‰¹ç‚¹**ï¼š

- å¼ºä¸€è‡´æ€§è¦æ±‚
- é«˜å¹¶å‘äº¤æ˜“
- ä¸¥æ ¼å®¡è®¡è¦æ±‚
- å®æ—¶é£æ§

**æ ¸å¿ƒè¡¨è®¾è®¡**ï¼š

```sql
CREATE SCHEMA banking_core;

-- è´¦æˆ·è¡¨
CREATE TABLE banking_core.accounts (
    account_id BIGSERIAL PRIMARY KEY,
    account_number VARCHAR(50) UNIQUE NOT NULL,
    customer_id BIGINT NOT NULL,
    account_type VARCHAR(20) NOT NULL,  -- savings, checking, credit
    currency VARCHAR(3) NOT NULL DEFAULT 'CNY',
    balance DECIMAL(15,2) NOT NULL DEFAULT 0 CHECK (balance >= 0),
    available_balance DECIMAL(15,2) NOT NULL DEFAULT 0,
    frozen_amount DECIMAL(15,2) DEFAULT 0,
    status VARCHAR(20) DEFAULT 'active',  -- active, frozen, closed
    opened_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    closed_at TIMESTAMP,
    version INTEGER DEFAULT 0  -- ä¹è§‚é”ç‰ˆæœ¬å·
);

CREATE INDEX idx_accounts_customer ON banking_core.accounts(customer_id);
CREATE INDEX idx_accounts_number ON banking_core.accounts(account_number);
CREATE INDEX idx_accounts_type ON banking_core.accounts(account_type, status);

-- äº¤æ˜“è®°å½•è¡¨ï¼ˆåˆ†åŒºè¡¨ï¼‰
CREATE TABLE banking_core.transactions (
    transaction_id BIGSERIAL,
    transaction_number VARCHAR(50) UNIQUE NOT NULL,
    account_id BIGINT NOT NULL REFERENCES banking_core.accounts(account_id),
    transaction_type VARCHAR(20) NOT NULL,  -- deposit, withdrawal, transfer, interest
    amount DECIMAL(15,2) NOT NULL,
    balance_before DECIMAL(15,2) NOT NULL,
    balance_after DECIMAL(15,2) NOT NULL,
    counterparty_account VARCHAR(50),
    description TEXT,
    status VARCHAR(20) DEFAULT 'pending',  -- pending, completed, failed, cancelled
    transaction_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (transaction_id, transaction_date)
) PARTITION BY RANGE (transaction_date);

-- æŒ‰æœˆåˆ†åŒº
CREATE TABLE banking_core.transactions_2024_01 PARTITION OF banking_core.transactions
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

CREATE INDEX idx_transactions_account ON banking_core.transactions(account_id, transaction_date DESC);
CREATE INDEX idx_transactions_number ON banking_core.transactions(transaction_number);
CREATE INDEX idx_transactions_date ON banking_core.transactions(transaction_date DESC);

-- è´¦æˆ·ä½™é¢å˜æ›´ï¼ˆä½¿ç”¨äº‹ä»¶æº¯æºï¼‰
CREATE TABLE banking_core.account_balance_events (
    event_id BIGSERIAL PRIMARY KEY,
    account_id BIGINT NOT NULL,
    event_type VARCHAR(20) NOT NULL,  -- DEPOSIT, WITHDRAWAL, TRANSFER_IN, TRANSFER_OUT
    amount DECIMAL(15,2) NOT NULL,
    balance_before DECIMAL(15,2) NOT NULL,
    balance_after DECIMAL(15,2) NOT NULL,
    transaction_id BIGINT,
    event_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) PARTITION BY RANGE (event_date);

CREATE INDEX idx_balance_events_account ON banking_core.account_balance_events(account_id, event_date DESC);

-- è´¦æˆ·ä½™é¢å¿«ç…§ï¼ˆå®šæœŸç”Ÿæˆï¼Œç”¨äºå¿«é€ŸæŸ¥è¯¢ï¼‰
CREATE TABLE banking_core.account_balance_snapshots (
    snapshot_id BIGSERIAL PRIMARY KEY,
    account_id BIGINT NOT NULL,
    balance DECIMAL(15,2) NOT NULL,
    snapshot_date DATE NOT NULL,
    UNIQUE(account_id, snapshot_date)
);

CREATE INDEX idx_balance_snapshots_account ON banking_core.account_balance_snapshots(account_id, snapshot_date DESC);
```

### 3.2. é£æ§ç³»ç»Ÿè®¾è®¡

```sql
CREATE SCHEMA risk_control;

-- é£æ§è§„åˆ™è¡¨
CREATE TABLE risk_control.rules (
    rule_id BIGSERIAL PRIMARY KEY,
    rule_name VARCHAR(100) NOT NULL,
    rule_type VARCHAR(50) NOT NULL,  -- AMOUNT_LIMIT, FREQUENCY_LIMIT, PATTERN_DETECTION
    rule_config JSONB NOT NULL,
    priority INTEGER DEFAULT 0,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- é£æ§äº‹ä»¶è¡¨
CREATE TABLE risk_control.risk_events (
    event_id BIGSERIAL PRIMARY KEY,
    transaction_id BIGINT,
    account_id BIGINT NOT NULL,
    rule_id BIGINT REFERENCES risk_control.rules(rule_id),
    risk_level VARCHAR(20) NOT NULL,  -- low, medium, high, critical
    risk_score DECIMAL(5,2) NOT NULL,
    event_data JSONB NOT NULL,
    action_taken VARCHAR(50),  -- ALLOW, BLOCK, REVIEW
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) PARTITION BY RANGE (created_at);

CREATE INDEX idx_risk_events_account ON risk_control.risk_events(account_id, created_at DESC);
CREATE INDEX idx_risk_events_transaction ON risk_control.risk_events(transaction_id);
CREATE INDEX idx_risk_events_level ON risk_control.risk_events(risk_level, created_at DESC);
```

---

## 4. ç¤¾äº¤ç½‘ç»œæ¡ˆä¾‹

### 4.1. ç¤¾äº¤ç½‘ç»œæ ¸å¿ƒSchema

```sql
CREATE SCHEMA social_network;

-- ç”¨æˆ·è¡¨
CREATE TABLE social_network.users (
    user_id BIGSERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    nickname VARCHAR(100),
    avatar_url VARCHAR(500),
    bio TEXT,
    status VARCHAR(20) DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ç”¨æˆ·å…³ç³»è¡¨ï¼ˆå…³æ³¨/ç²‰ä¸ï¼‰
CREATE TABLE social_network.user_relations (
    relation_id BIGSERIAL PRIMARY KEY,
    follower_id BIGINT NOT NULL REFERENCES social_network.users(user_id),
    followee_id BIGINT NOT NULL REFERENCES social_network.users(user_id),
    relation_type VARCHAR(20) DEFAULT 'follow',  -- follow, block, mute
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(follower_id, followee_id, relation_type),
    CHECK (follower_id != followee_id)
);

CREATE INDEX idx_relations_follower ON social_network.user_relations(follower_id);
CREATE INDEX idx_relations_followee ON social_network.user_relations(followee_id);

-- å†…å®¹è¡¨ï¼ˆå¸–å­ï¼‰
CREATE TABLE social_network.posts (
    post_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES social_network.users(user_id),
    content TEXT NOT NULL,
    media_urls TEXT[],
    visibility VARCHAR(20) DEFAULT 'public',  -- public, friends, private
    like_count INTEGER DEFAULT 0,
    comment_count INTEGER DEFAULT 0,
    share_count INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) PARTITION BY RANGE (created_at);

CREATE INDEX idx_posts_user ON social_network.posts(user_id, created_at DESC);
CREATE INDEX idx_posts_created ON social_network.posts(created_at DESC);
CREATE INDEX idx_posts_content ON social_network.posts USING GIN (to_tsvector('english', content));

-- ç‚¹èµè¡¨
CREATE TABLE social_network.likes (
    like_id BIGSERIAL PRIMARY KEY,
    post_id BIGINT NOT NULL,
    user_id BIGINT NOT NULL REFERENCES social_network.users(user_id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(post_id, user_id)
);

CREATE INDEX idx_likes_post ON social_network.likes(post_id);
CREATE INDEX idx_likes_user ON social_network.likes(user_id);
```

---

## 5. ç‰©è”ç½‘æ¡ˆä¾‹

### 5.1. IoTè®¾å¤‡æ•°æ®Schema

```sql
CREATE SCHEMA iot;

-- è®¾å¤‡è¡¨
CREATE TABLE iot.devices (
    device_id BIGSERIAL PRIMARY KEY,
    device_code VARCHAR(50) UNIQUE NOT NULL,
    device_type VARCHAR(50) NOT NULL,
    location VARCHAR(200),
    status VARCHAR(20) DEFAULT 'online',
    last_heartbeat TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_devices_type ON iot.devices(device_type);
CREATE INDEX idx_devices_status ON iot.devices(status);

-- ä¼ æ„Ÿå™¨æ•°æ®è¡¨ï¼ˆæ—¶åºæ•°æ®ï¼‰
CREATE TABLE iot.sensor_data (
    data_id BIGSERIAL,
    device_id BIGINT NOT NULL REFERENCES iot.devices(device_id),
    sensor_type VARCHAR(50) NOT NULL,
    value DECIMAL(10,4) NOT NULL,
    unit VARCHAR(20),
    quality INTEGER DEFAULT 100,  -- æ•°æ®è´¨é‡ 0-100
    collected_at TIMESTAMP NOT NULL,
    PRIMARY KEY (data_id, collected_at)
) PARTITION BY RANGE (collected_at);

-- æŒ‰å°æ—¶åˆ†åŒºï¼ˆé«˜é¢‘æ•°æ®ï¼‰
CREATE TABLE iot.sensor_data_2024_01_01_00 PARTITION OF iot.sensor_data
    FOR VALUES FROM ('2024-01-01 00:00:00') TO ('2024-01-01 01:00:00');

CREATE INDEX idx_sensor_data_device ON iot.sensor_data(device_id, collected_at DESC);
CREATE INDEX idx_sensor_data_type ON iot.sensor_data(sensor_type, collected_at DESC);

-- æ•°æ®èšåˆè¡¨ï¼ˆæŒ‰åˆ†é’Ÿèšåˆï¼‰
CREATE TABLE iot.sensor_data_aggregated (
    agg_id BIGSERIAL PRIMARY KEY,
    device_id BIGINT NOT NULL,
    sensor_type VARCHAR(50) NOT NULL,
    minute_timestamp TIMESTAMP NOT NULL,
    min_value DECIMAL(10,4),
    max_value DECIMAL(10,4),
    avg_value DECIMAL(10,4),
    count INTEGER NOT NULL,
    UNIQUE(device_id, sensor_type, minute_timestamp)
);

CREATE INDEX idx_sensor_agg_device ON iot.sensor_data_aggregated(device_id, minute_timestamp DESC);
```

---

## 6. å†…å®¹ç®¡ç†ç³»ç»Ÿæ¡ˆä¾‹

### 6.1. CMS Schemaè®¾è®¡

```sql
CREATE SCHEMA cms;

-- æ–‡ç« è¡¨
CREATE TABLE cms.articles (
    article_id BIGSERIAL PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    slug VARCHAR(200) UNIQUE NOT NULL,
    content TEXT NOT NULL,
    excerpt TEXT,
    author_id BIGINT NOT NULL,
    category_id BIGINT,
    status VARCHAR(20) DEFAULT 'draft',  -- draft, published, archived
    published_at TIMESTAMP,
    view_count INTEGER DEFAULT 0,
    like_count INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_articles_author ON cms.articles(author_id);
CREATE INDEX idx_articles_status ON cms.articles(status, published_at DESC);
CREATE INDEX idx_articles_slug ON cms.articles(slug);
CREATE INDEX idx_articles_search ON cms.articles USING GIN (
    to_tsvector('english', title || ' ' || COALESCE(excerpt, '') || ' ' || content)
);

-- æ–‡ç« ç‰ˆæœ¬è¡¨ï¼ˆç‰ˆæœ¬æ§åˆ¶ï¼‰
CREATE TABLE cms.article_versions (
    version_id BIGSERIAL PRIMARY KEY,
    article_id BIGINT NOT NULL REFERENCES cms.articles(article_id),
    version_number INTEGER NOT NULL,
    title VARCHAR(200) NOT NULL,
    content TEXT NOT NULL,
    author_id BIGINT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(article_id, version_number)
);

CREATE INDEX idx_article_versions_article ON cms.article_versions(article_id, version_number DESC);
```

---

## 7. 2024-2025è¡Œä¸šæ¡ˆä¾‹è¶‹åŠ¿

### 7.1. è¡Œä¸šæ•°æ®åº“è®¾è®¡æ¼”è¿›

```mermaid
timeline
    title è¡Œä¸šæ•°æ®åº“è®¾è®¡æ¼”è¿›
    2015 : ä¼ ç»ŸCRUD
         : å•ä½“æ¶æ„
    2018 : å¾®æœåŠ¡æ¶æ„
         : Database per Service
    2021 : å¤šæ¨¡æ€æ•°æ®
         : å‘é‡+å›¾+å…³ç³»
    2024 : AIåŸç”Ÿåº”ç”¨
         : RAG/Agent
    2025 : è‡ªé€‚åº”æ¶æ„
         : æ™ºèƒ½ä¼˜åŒ–
```

### 7.2. è¡Œä¸šæ¡ˆä¾‹é€‰å‹çŸ©é˜µ

| è¡Œä¸š | æ ¸å¿ƒéœ€æ±‚ | æ¨èæ¶æ„ | å…³é”®æŠ€æœ¯ |
|------|---------|---------|---------|
| **ç”µå•†** | é«˜å¹¶å‘ã€å¤æ‚ä¸šåŠ¡ | å¾®æœåŠ¡+CQRS | PG+Redis+ES |
| **é‡‘è** | å¼ºä¸€è‡´æ€§ã€å®¡è®¡ | åˆ†å¸ƒå¼äº‹åŠ¡ | PG+å®¡è®¡æ—¥å¿— |
| **ç¤¾äº¤** | å…³ç³»ç½‘ç»œ | å›¾æ•°æ®åº“ | Neo4j/AGE |
| **IoT** | é«˜é¢‘å†™å…¥ | æ—¶åºæ•°æ®åº“ | TimescaleDB |
| **AIåº”ç”¨** | è¯­ä¹‰æ£€ç´¢ | å‘é‡æ•°æ®åº“ | pgvector |
| **æ¸¸æˆ** | ä½å»¶è¿Ÿ | å†…å­˜æ•°æ®åº“ | Redis |

### 7.3. AIåº”ç”¨è¡Œä¸šæ¡ˆä¾‹

```sql
-- AIåº”ç”¨è¡Œä¸šå…¸å‹Schema
CREATE SCHEMA ai_app;

-- çŸ¥è¯†åº“è¡¨
CREATE TABLE ai_app.knowledge_base (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(200) NOT NULL,
    description TEXT,
    embedding_model VARCHAR(100) DEFAULT 'text-embedding-3-small',
    chunk_size INTEGER DEFAULT 500,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- æ–‡æ¡£å—è¡¨
CREATE TABLE ai_app.documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    kb_id UUID REFERENCES ai_app.knowledge_base(id),
    content TEXT NOT NULL,
    embedding vector(1536),
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_docs_embedding ON ai_app.documents
    USING ivfflat (embedding vector_cosine_ops) WITH (lists = 100);

-- å¯¹è¯è¡¨
CREATE TABLE ai_app.conversations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL,
    title VARCHAR(500),
    model VARCHAR(100) DEFAULT 'gpt-4',
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- æ¶ˆæ¯è¡¨
CREATE TABLE ai_app.messages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    conversation_id UUID REFERENCES ai_app.conversations(id),
    role VARCHAR(20) CHECK (role IN ('user', 'assistant', 'system')),
    content TEXT NOT NULL,
    tokens INTEGER,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- RAGæ£€ç´¢å‡½æ•°
CREATE OR REPLACE FUNCTION ai_app.rag_search(
    p_kb_id UUID,
    p_query_embedding vector(1536),
    p_limit INTEGER DEFAULT 5
)
RETURNS TABLE (id UUID, content TEXT, similarity FLOAT) AS $$
BEGIN
    RETURN QUERY
    SELECT d.id, d.content, 1 - (d.embedding <=> p_query_embedding) AS similarity
    FROM ai_app.documents d
    WHERE d.kb_id = p_kb_id
    ORDER BY d.embedding <=> p_query_embedding
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;
```

---

## 8. å‚è€ƒèµ„æ–™

### 8.1. æƒå¨æ–‡çŒ®

**è¡Œä¸šå®è·µ**ï¼š

- Richardson, C. "Microservices Patterns"
- Fowler, M. "Patterns of Enterprise Application Architecture"

### 8.2. åœ¨çº¿èµ„æº

| èµ„æº | URL | æè¿° |
|------|-----|------|
| **AWSæ¶æ„ä¸­å¿ƒ** | <https://aws.amazon.com/architecture/> | äº‘åŸç”Ÿæ¡ˆä¾‹ |
| **Azureæ¶æ„** | <https://docs.microsoft.com/azure/architecture/> | è¡Œä¸šæ–¹æ¡ˆ |

### 8.3. ç›¸å…³æ–‡æ¡£

- [07.01-Schemaè®¾è®¡æ–¹æ³•è®º](./07.01-Schemaè®¾è®¡æ–¹æ³•è®º.md)
- [07.16-æ•°æ®åº“è®¾è®¡æ¡ˆä¾‹æ·±åº¦è§£æ](./07.16-æ•°æ®åº“è®¾è®¡æ¡ˆä¾‹æ·±åº¦è§£æ.md)
- [07.10-å‘é‡æ•°æ®åº“è®¾è®¡](./07.10-å‘é‡æ•°æ®åº“è®¾è®¡.md)

---

**æœ€åæ›´æ–°**ï¼š2025-12-01
**ç»´æŠ¤è€…**ï¼šData-Science Team
**çŠ¶æ€**ï¼šå·²å®Œæˆ âœ…
**ç‰ˆæœ¬**ï¼šv2.0 (å¢å¼ºç‰ˆ)
