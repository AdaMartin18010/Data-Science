# æ•°æ®åº“è®¾è®¡å·¥å…·ä¸æ¨¡æ¿åº“ï¼šå®ç”¨å·¥å…·é›†åˆ

> **åˆ›å»ºæ—¥æœŸ**ï¼š2025-01-15
> **æœ€åæ›´æ–°**ï¼š2025-01-15
> **ç‰ˆæœ¬**ï¼šv1.0
> **çŠ¶æ€**ï¼šå®æ–½ä¸­

---

## ğŸ“‹ ç›®å½•

- [æ•°æ®åº“è®¾è®¡å·¥å…·ä¸æ¨¡æ¿åº“ï¼šå®ç”¨å·¥å…·é›†åˆ](#æ•°æ®åº“è®¾è®¡å·¥å…·ä¸æ¨¡æ¿åº“å®ç”¨å·¥å…·é›†åˆ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1. å·¥å…·åˆ†ç±»](#11-å·¥å…·åˆ†ç±»)
  - [2. Schemaè®¾è®¡æ£€æŸ¥æ¸…å•](#2-schemaè®¾è®¡æ£€æŸ¥æ¸…å•)
    - [2.1. Schemaè®¾è®¡æ£€æŸ¥æ¸…å•](#21-schemaè®¾è®¡æ£€æŸ¥æ¸…å•)
    - [2.2. ç´¢å¼•è®¾è®¡æ£€æŸ¥æ¸…å•](#22-ç´¢å¼•è®¾è®¡æ£€æŸ¥æ¸…å•)
    - [2.3. æ€§èƒ½æ£€æŸ¥æ¸…å•](#23-æ€§èƒ½æ£€æŸ¥æ¸…å•)
  - [3. DDLç”Ÿæˆå·¥å…·](#3-ddlç”Ÿæˆå·¥å…·)
    - [3.1. Python DDLç”Ÿæˆå™¨](#31-python-ddlç”Ÿæˆå™¨)
    - [3.2. SQLæ¨¡æ¿åº“](#32-sqlæ¨¡æ¿åº“)
  - [4. æ•°æ®åº“è®¾è®¡æ¨¡æ¿](#4-æ•°æ®åº“è®¾è®¡æ¨¡æ¿)
    - [4.1. ç”¨æˆ·è®¤è¯ç³»ç»Ÿæ¨¡æ¿](#41-ç”¨æˆ·è®¤è¯ç³»ç»Ÿæ¨¡æ¿)
    - [4.2. å¤šç§Ÿæˆ·ç³»ç»Ÿæ¨¡æ¿](#42-å¤šç§Ÿæˆ·ç³»ç»Ÿæ¨¡æ¿)
  - [5. ä»£ç ç”Ÿæˆå·¥å…·](#5-ä»£ç ç”Ÿæˆå·¥å…·)
    - [5.1. Pythonæ¨¡å‹ç”Ÿæˆå™¨](#51-pythonæ¨¡å‹ç”Ÿæˆå™¨)
  - [6. æ•°æ®åº“è®¾è®¡å·¥å…·](#6-æ•°æ®åº“è®¾è®¡å·¥å…·)
    - [6.1. SchemaéªŒè¯å·¥å…·](#61-schemaéªŒè¯å·¥å…·)
    - [6.2. æ•°æ®åº“æ–‡æ¡£ç”Ÿæˆå·¥å…·](#62-æ•°æ®åº“æ–‡æ¡£ç”Ÿæˆå·¥å…·)
  - [7. å‚è€ƒèµ„æ–™](#7-å‚è€ƒèµ„æ–™)

---

## 1. æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›æ•°æ®åº“è®¾è®¡çš„å®ç”¨å·¥å…·ã€æ¨¡æ¿å’Œæ£€æŸ¥æ¸…å•ï¼Œå¸®åŠ©å¿«é€Ÿã€è§„èŒƒåœ°è¿›è¡Œæ•°æ®åº“è®¾è®¡ã€‚

### 1.1. å·¥å…·åˆ†ç±»

```mermaid
mindmap
  root((è®¾è®¡å·¥å…·))
    æ£€æŸ¥æ¸…å•
      Schemaæ£€æŸ¥
      ç´¢å¼•æ£€æŸ¥
      æ€§èƒ½æ£€æŸ¥
      å®‰å…¨æ£€æŸ¥
    DDLç”Ÿæˆ
      Pythonç”Ÿæˆå™¨
      SQLæ¨¡æ¿
      å…ƒæ•°æ®é©±åŠ¨
    è®¾è®¡æ¨¡æ¿
      åŸºç¡€è¡¨æ¨¡æ¿
      å…³è”è¡¨æ¨¡æ¿
      å®¡è®¡è¡¨æ¨¡æ¿
      è½¯åˆ é™¤æ¨¡æ¿
    ä»£ç ç”Ÿæˆ
      æ¨¡å‹ä»£ç 
      APIä»£ç 
      æµ‹è¯•ä»£ç 
    è®¾è®¡å·¥å…·
      å¯è§†åŒ–å·¥å…·
      ç‰ˆæœ¬æ§åˆ¶
      æ–‡æ¡£ç”Ÿæˆ
```

---

## 2. Schemaè®¾è®¡æ£€æŸ¥æ¸…å•

### 2.1. Schemaè®¾è®¡æ£€æŸ¥æ¸…å•

**å®Œæ•´æ£€æŸ¥æ¸…å•**ï¼š

```markdown
## Schemaè®¾è®¡æ£€æŸ¥æ¸…å•

### å‘½åè§„èŒƒ
- [ ] è¡¨åä½¿ç”¨å¤æ•°å½¢å¼ï¼ˆusers, ordersï¼‰
- [ ] è¡¨åä½¿ç”¨å°å†™å­—æ¯å’Œä¸‹åˆ’çº¿
- [ ] åˆ—åæ¸…æ™°æ˜ç¡®ï¼Œä¸ä½¿ç”¨ç¼©å†™
- [ ] ä¸»é”®å‘½åä¸º `{table}_id`ï¼ˆå¦‚ `user_id`ï¼‰
- [ ] å¤–é”®å‘½åä¸º `{referenced_table}_id`
- [ ] å¸ƒå°”å­—æ®µä½¿ç”¨ `is_` æˆ– `has_` å‰ç¼€
- [ ] æ—¶é—´å­—æ®µä½¿ç”¨ `_at` åç¼€ï¼ˆcreated_at, updated_atï¼‰

### æ•°æ®ç±»å‹
- [ ] ä¸»é”®ä½¿ç”¨ BIGSERIALï¼ˆæ”¯æŒå¤§IDï¼‰
- [ ] è´§å¸ä½¿ç”¨ DECIMAL(10,2)
- [ ] æ–‡æœ¬ä½¿ç”¨ VARCHARï¼ˆå›ºå®šé•¿åº¦ï¼‰æˆ– TEXTï¼ˆå¯å˜é•¿åº¦ï¼‰
- [ ] æ—¶é—´æˆ³ä½¿ç”¨ TIMESTAMPTZï¼ˆéœ€è¦æ—¶åŒºï¼‰
- [ ] å¸ƒå°”å€¼ä½¿ç”¨ BOOLEAN
- [ ] JSONæ•°æ®ä½¿ç”¨ JSONB

### çº¦æŸè®¾è®¡
- [ ] æ‰€æœ‰è¡¨éƒ½æœ‰ä¸»é”®
- [ ] å¤–é”®éƒ½æœ‰ REFERENCES çº¦æŸ
- [ ] å¤–é”®æœ‰ ON DELETE ç­–ç•¥ï¼ˆRESTRICT/CASCADE/SET NULLï¼‰
- [ ] å”¯ä¸€çº¦æŸä½¿ç”¨ UNIQUE
- [ ] æ£€æŸ¥çº¦æŸä½¿ç”¨ CHECK
- [ ] NOT NULL çº¦æŸæ˜ç¡®æŒ‡å®š

### ç´¢å¼•è®¾è®¡
- [ ] ä¸»é”®è‡ªåŠ¨åˆ›å»ºç´¢å¼•
- [ ] å¤–é”®è‡ªåŠ¨åˆ›å»ºç´¢å¼•
- [ ] å¸¸ç”¨æŸ¥è¯¢åˆ—æœ‰ç´¢å¼•
- [ ] å¤åˆç´¢å¼•åˆ—é¡ºåºåˆç†ï¼ˆé«˜é€‰æ‹©æ€§åœ¨å‰ï¼‰
- [ ] éƒ¨åˆ†ç´¢å¼•ç”¨äºè¿‡æ»¤æ¡ä»¶
- [ ] è¦†ç›–ç´¢å¼•åŒ…å«æŸ¥è¯¢æ‰€éœ€åˆ—

### æ€§èƒ½ä¼˜åŒ–
- [ ] å¤§è¡¨ä½¿ç”¨åˆ†åŒºï¼ˆæ—¶é—´åºåˆ—æ•°æ®ï¼‰
- [ ] å¸¸ç”¨æŸ¥è¯¢ä½¿ç”¨ç‰©åŒ–è§†å›¾
- [ ] ç»Ÿè®¡ä¿¡æ¯å®šæœŸæ›´æ–°ï¼ˆANALYZEï¼‰
- [ ] ç´¢å¼•å®šæœŸç»´æŠ¤ï¼ˆREINDEXï¼‰

### å®‰å…¨è®¾è®¡
- [ ] æ•æ„Ÿæ•°æ®åŠ å¯†å­˜å‚¨
- [ ] å¯†ç ä½¿ç”¨å“ˆå¸Œå­˜å‚¨
- [ ] è®¿é—®æ§åˆ¶ä½¿ç”¨è§’è‰²å’Œæƒé™
- [ ] å®¡è®¡å­—æ®µè®°å½•æ“ä½œï¼ˆcreated_at, updated_atï¼‰
- [ ] è½¯åˆ é™¤ä½¿ç”¨ deleted_at å­—æ®µ

### æ–‡æ¡£
- [ ] è¡¨æœ‰ COMMENT è¯´æ˜
- [ ] åˆ—æœ‰ COMMENT è¯´æ˜
- [ ] å¤æ‚çº¦æŸæœ‰æ³¨é‡Šè¯´æ˜
- [ ] æ•°æ®å­—å…¸å®Œæ•´
```

### 2.2. ç´¢å¼•è®¾è®¡æ£€æŸ¥æ¸…å•

**ç´¢å¼•æ£€æŸ¥æ¸…å•**ï¼š

```markdown
## ç´¢å¼•è®¾è®¡æ£€æŸ¥æ¸…å•

### ç´¢å¼•åˆ›å»ºåŸåˆ™
- [ ] ä¸º WHERE å­å¥ä¸­çš„åˆ—åˆ›å»ºç´¢å¼•
- [ ] ä¸º JOIN æ¡ä»¶åˆ›å»ºç´¢å¼•
- [ ] ä¸º ORDER BY åˆ—åˆ›å»ºç´¢å¼•
- [ ] ç´¢å¼•é€‰æ‹©æ€§ > 0.1ï¼ˆé«˜é€‰æ‹©æ€§ï¼‰
- [ ] æŸ¥è¯¢é¢‘ç‡ > å†™å…¥é¢‘ç‡ Ã— 10

### ç´¢å¼•ç±»å‹é€‰æ‹©
- [ ] B-Tree ç´¢å¼•ç”¨äºç­‰å€¼å’ŒèŒƒå›´æŸ¥è¯¢
- [ ] GIN ç´¢å¼•ç”¨äºå…¨æ–‡æœç´¢ã€æ•°ç»„ã€JSON
- [ ] GIST ç´¢å¼•ç”¨äºç©ºé—´æ•°æ®
- [ ] HNSW ç´¢å¼•ç”¨äºå‘é‡ç›¸ä¼¼åº¦æœç´¢
- [ ] éƒ¨åˆ†ç´¢å¼•ç”¨äºè¿‡æ»¤æ¡ä»¶

### ç´¢å¼•ç»´æŠ¤
- [ ] å®šæœŸæ£€æŸ¥ç´¢å¼•ä½¿ç”¨æƒ…å†µ
- [ ] åˆ é™¤æœªä½¿ç”¨çš„ç´¢å¼•
- [ ] é‡å»ºç¢ç‰‡åŒ–çš„ç´¢å¼•
- [ ] æ›´æ–°ç»Ÿè®¡ä¿¡æ¯ï¼ˆANALYZEï¼‰
```

### 2.3. æ€§èƒ½æ£€æŸ¥æ¸…å•

**æ€§èƒ½æ£€æŸ¥æ¸…å•**ï¼š

```markdown
## æ€§èƒ½æ£€æŸ¥æ¸…å•

### æŸ¥è¯¢æ€§èƒ½
- [ ] æ…¢æŸ¥è¯¢å·²ä¼˜åŒ–ï¼ˆ< 100msï¼‰
- [ ] ä½¿ç”¨ EXPLAIN ANALYZE åˆ†ææŸ¥è¯¢è®¡åˆ’
- [ ] é¿å…å…¨è¡¨æ‰«æ
- [ ] JOIN æ“ä½œä½¿ç”¨ç´¢å¼•
- [ ] å­æŸ¥è¯¢å·²ä¼˜åŒ–ï¼ˆä½¿ç”¨ JOIN æˆ– EXISTSï¼‰
- [ ] åˆ†é¡µæŸ¥è¯¢ä½¿ç”¨æ¸¸æ ‡åˆ†é¡µï¼ˆå¤§æ•°æ®é›†ï¼‰

### ç´¢å¼•æ€§èƒ½
- [ ] ç´¢å¼•å¤§å°åˆç†ï¼ˆ< è¡¨å¤§å°çš„ 50%ï¼‰
- [ ] ç´¢å¼•ä½¿ç”¨ç‡é«˜ï¼ˆ> 80%ï¼‰
- [ ] å¤åˆç´¢å¼•åˆ—é¡ºåºåˆç†
- [ ] éƒ¨åˆ†ç´¢å¼•å‡å°‘ç´¢å¼•å¤§å°

### è¡¨è®¾è®¡æ€§èƒ½
- [ ] è¡¨å¤§å°åˆç†ï¼ˆè€ƒè™‘åˆ†åŒºï¼‰
- [ ] åˆ—é¡ºåºä¼˜åŒ–ï¼ˆå¸¸ç”¨åˆ—åœ¨å‰ï¼‰
- [ ] æ•°æ®ç±»å‹é€‰æ‹©åˆç†ï¼ˆå‡å°‘å­˜å‚¨ç©ºé—´ï¼‰
- [ ] èŒƒå¼åŒ–ç¨‹åº¦åˆç†ï¼ˆå¹³è¡¡æŸ¥è¯¢å’Œæ›´æ–°æ€§èƒ½ï¼‰
```

---

## 3. DDLç”Ÿæˆå·¥å…·

### 3.1. Python DDLç”Ÿæˆå™¨

**åŸºç¡€DDLç”Ÿæˆå™¨**ï¼š

```python
"""
æ•°æ®åº“DDLç”Ÿæˆå™¨
æ”¯æŒä»Pythonå¯¹è±¡ç”ŸæˆPostgreSQL DDLè¯­å¥
"""

from typing import List, Optional, Dict
from enum import Enum

class DataType(Enum):
    """æ•°æ®ç±»å‹æšä¸¾"""
    BIGSERIAL = "BIGSERIAL"
    BIGINT = "BIGINT"
    INTEGER = "INTEGER"
    VARCHAR = "VARCHAR"
    TEXT = "TEXT"
    DECIMAL = "DECIMAL"
    BOOLEAN = "BOOLEAN"
    TIMESTAMP = "TIMESTAMP"
    TIMESTAMPTZ = "TIMESTAMPTZ"
    JSONB = "JSONB"
    UUID = "UUID"

class Column:
    """åˆ—å®šä¹‰"""
    def __init__(
        self,
        name: str,
        data_type: DataType,
        nullable: bool = True,
        default: Optional[str] = None,
        unique: bool = False,
        check: Optional[str] = None,
        comment: Optional[str] = None
    ):
        self.name = name
        self.data_type = data_type
        self.nullable = nullable
        self.default = default
        self.unique = unique
        self.check = check
        self.comment = comment

    def to_ddl(self) -> str:
        """ç”Ÿæˆåˆ—DDL"""
        ddl = f"{self.name} {self.data_type.value}"

        if not self.nullable:
            ddl += " NOT NULL"

        if self.default:
            ddl += f" DEFAULT {self.default}"

        if self.unique:
            ddl += " UNIQUE"

        if self.check:
            ddl += f" CHECK ({self.check})"

        return ddl

class ForeignKey:
    """å¤–é”®å®šä¹‰"""
    def __init__(
        self,
        columns: List[str],
        references_table: str,
        referenced_columns: List[str],
        on_delete: str = "RESTRICT",
        on_update: str = "RESTRICT"
    ):
        self.columns = columns
        self.references_table = references_table
        self.referenced_columns = referenced_columns
        self.on_delete = on_delete
        self.on_update = on_update

    def to_ddl(self) -> str:
        """ç”Ÿæˆå¤–é”®DDL"""
        cols = ", ".join(self.columns)
        ref_cols = ", ".join(self.referenced_columns)
        return (
            f"FOREIGN KEY ({cols}) "
            f"REFERENCES {self.references_table}({ref_cols}) "
            f"ON DELETE {self.on_delete} "
            f"ON UPDATE {self.on_update}"
        )

class Table:
    """è¡¨å®šä¹‰"""
    def __init__(
        self,
        name: str,
        columns: List[Column],
        primary_key: Optional[List[str]] = None,
        foreign_keys: Optional[List[ForeignKey]] = None,
        indexes: Optional[List[Dict]] = None,
        comment: Optional[str] = None
    ):
        self.name = name
        self.columns = columns
        self.primary_key = primary_key
        self.foreign_keys = foreign_keys or []
        self.indexes = indexes or []
        self.comment = comment

    def to_ddl(self) -> str:
        """ç”Ÿæˆè¡¨DDL"""
        ddl_parts = []

        # CREATE TABLE
        ddl_parts.append(f"CREATE TABLE {self.name} (")

        # Columns
        column_ddls = [f"    {col.to_ddl()}" for col in self.columns]
        ddl_parts.append(",\n".join(column_ddls))

        # Primary Key
        if self.primary_key:
            pk_cols = ", ".join(self.primary_key)
            ddl_parts.append(f",\n    PRIMARY KEY ({pk_cols})")

        # Foreign Keys
        for fk in self.foreign_keys:
            ddl_parts.append(f",\n    {fk.to_ddl()}")

        ddl_parts.append("\n);")

        # Comment
        if self.comment:
            ddl_parts.append(f"\nCOMMENT ON TABLE {self.name} IS '{self.comment}';")

        # Column Comments
        for col in self.columns:
            if col.comment:
                ddl_parts.append(
                    f"\nCOMMENT ON COLUMN {self.name}.{col.name} IS '{col.comment}';"
                )

        # Indexes
        for idx in self.indexes:
            idx_name = idx.get('name', f"idx_{self.name}_{'_'.join(idx['columns'])}")
            idx_cols = ", ".join(idx['columns'])
            idx_type = idx.get('type', 'BTREE')
            idx_where = idx.get('where')

            idx_ddl = f"CREATE INDEX {idx_name} ON {self.name} USING {idx_type} ({idx_cols})"
            if idx_where:
                idx_ddl += f" WHERE {idx_where}"
            idx_ddl += ";"
            ddl_parts.append(f"\n{idx_ddl}")

        return "\n".join(ddl_parts)

# ä½¿ç”¨ç¤ºä¾‹
def generate_users_table():
    """ç”Ÿæˆç”¨æˆ·è¡¨DDL"""
    table = Table(
        name="users",
        columns=[
            Column("user_id", DataType.BIGSERIAL, nullable=False, comment="ç”¨æˆ·ID"),
            Column("username", DataType.VARCHAR, nullable=False, unique=True, comment="ç”¨æˆ·å"),
            Column("email", DataType.VARCHAR, nullable=False, unique=True, comment="é‚®ç®±"),
            Column("password_hash", DataType.TEXT, nullable=False, comment="å¯†ç å“ˆå¸Œ"),
            Column("is_active", DataType.BOOLEAN, default="TRUE", comment="æ˜¯å¦æ¿€æ´»"),
            Column("created_at", DataType.TIMESTAMPTZ, default="CURRENT_TIMESTAMP", comment="åˆ›å»ºæ—¶é—´"),
            Column("updated_at", DataType.TIMESTAMPTZ, default="CURRENT_TIMESTAMP", comment="æ›´æ–°æ—¶é—´")
        ],
        primary_key=["user_id"],
        indexes=[
            {"columns": ["username"], "type": "BTREE"},
            {"columns": ["email"], "type": "BTREE"},
            {"columns": ["is_active"], "type": "BTREE", "where": "is_active = TRUE"}
        ],
        comment="ç”¨æˆ·è¡¨ï¼Œå­˜å‚¨æ‰€æœ‰æ³¨å†Œç”¨æˆ·ä¿¡æ¯"
    )
    return table.to_ddl()

if __name__ == "__main__":
    print(generate_users_table())
```

### 3.2. SQLæ¨¡æ¿åº“

**å¸¸ç”¨è¡¨æ¨¡æ¿**ï¼š

```sql
-- ============================================
-- åŸºç¡€è¡¨æ¨¡æ¿ï¼ˆå¸¦å®¡è®¡å­—æ®µï¼‰
-- ============================================
CREATE TABLE {table_name} (
    {table_name}_id BIGSERIAL PRIMARY KEY,
    -- ä¸šåŠ¡å­—æ®µ
    {business_columns}
    -- å®¡è®¡å­—æ®µ
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_by BIGINT REFERENCES users(user_id),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_by BIGINT REFERENCES users(user_id),
    deleted_at TIMESTAMPTZ NULL,
    version INTEGER NOT NULL DEFAULT 1
);

-- åˆ›å»ºæ›´æ–°æ—¶é—´è§¦å‘å™¨
CREATE TRIGGER update_{table_name}_updated_at
BEFORE UPDATE ON {table_name}
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- åˆ›å»ºè½¯åˆ é™¤ç´¢å¼•
CREATE INDEX idx_{table_name}_deleted_at
ON {table_name}(deleted_at)
WHERE deleted_at IS NULL;

-- ============================================
-- å…³è”è¡¨æ¨¡æ¿
-- ============================================
CREATE TABLE {table1}_{table2} (
    {table1}_id BIGINT NOT NULL REFERENCES {table1}({table1}_id) ON DELETE CASCADE,
    {table2}_id BIGINT NOT NULL REFERENCES {table2}({table2}_id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY ({table1}_id, {table2}_id)
);

CREATE INDEX idx_{table1}_{table2}_{table1} ON {table1}_{table2}({table1}_id);
CREATE INDEX idx_{table1}_{table2}_{table2} ON {table1}_{table2}({table2}_id);

-- ============================================
-- æ—¥å¿—è¡¨æ¨¡æ¿
-- ============================================
CREATE TABLE {table_name}_logs (
    log_id BIGSERIAL PRIMARY KEY,
    {table_name}_id BIGINT NOT NULL REFERENCES {table_name}({table_name}_id),
    action VARCHAR(20) NOT NULL CHECK (action IN ('INSERT', 'UPDATE', 'DELETE')),
    old_data JSONB,
    new_data JSONB,
    changed_fields TEXT[],
    changed_by BIGINT REFERENCES users(user_id),
    changed_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
) PARTITION BY RANGE (changed_at);

CREATE INDEX idx_{table_name}_logs_{table_name}_id
ON {table_name}_logs({table_name}_id, changed_at DESC);
```

---

## 4. æ•°æ®åº“è®¾è®¡æ¨¡æ¿

### 4.1. ç”¨æˆ·è®¤è¯ç³»ç»Ÿæ¨¡æ¿

**å®Œæ•´çš„ç”¨æˆ·è®¤è¯ç³»ç»ŸSchema**ï¼š

```sql
-- ============================================
-- ç”¨æˆ·è®¤è¯ç³»ç»Ÿæ¨¡æ¿
-- ============================================

-- ç”¨æˆ·è¡¨
CREATE TABLE users (
    user_id BIGSERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL UNIQUE,
    password_hash TEXT NOT NULL,
    email_verified BOOLEAN DEFAULT FALSE,
    is_active BOOLEAN DEFAULT TRUE,
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_active ON users(user_id) WHERE is_active = TRUE;

-- è§’è‰²è¡¨
CREATE TABLE roles (
    role_id SERIAL PRIMARY KEY,
    role_name VARCHAR(50) NOT NULL UNIQUE,
    description TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- ç”¨æˆ·è§’è‰²å…³è”è¡¨
CREATE TABLE user_roles (
    user_id BIGINT NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    role_id INTEGER NOT NULL REFERENCES roles(role_id) ON DELETE CASCADE,
    assigned_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    assigned_by BIGINT REFERENCES users(user_id),
    PRIMARY KEY (user_id, role_id)
);

CREATE INDEX idx_user_roles_user ON user_roles(user_id);
CREATE INDEX idx_user_roles_role ON user_roles(role_id);

-- æƒé™è¡¨
CREATE TABLE permissions (
    permission_id SERIAL PRIMARY KEY,
    permission_name VARCHAR(100) NOT NULL UNIQUE,
    resource VARCHAR(100) NOT NULL,
    action VARCHAR(50) NOT NULL,
    description TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- è§’è‰²æƒé™å…³è”è¡¨
CREATE TABLE role_permissions (
    role_id INTEGER NOT NULL REFERENCES roles(role_id) ON DELETE CASCADE,
    permission_id INTEGER NOT NULL REFERENCES permissions(permission_id) ON DELETE CASCADE,
    PRIMARY KEY (role_id, permission_id)
);

-- ä¼šè¯è¡¨
CREATE TABLE sessions (
    session_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id BIGINT NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    token_hash TEXT NOT NULL,
    expires_at TIMESTAMPTZ NOT NULL,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    last_accessed_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_sessions_user ON sessions(user_id);
CREATE INDEX idx_sessions_expires ON sessions(expires_at);
CREATE INDEX idx_sessions_token ON sessions(token_hash);

-- å¯†ç é‡ç½®ä»¤ç‰Œè¡¨
CREATE TABLE password_reset_tokens (
    token_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    token_hash TEXT NOT NULL UNIQUE,
    expires_at TIMESTAMPTZ NOT NULL,
    used_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_password_reset_tokens_user ON password_reset_tokens(user_id);
CREATE INDEX idx_password_reset_tokens_token ON password_reset_tokens(token_hash);
CREATE INDEX idx_password_reset_tokens_expires ON password_reset_tokens(expires_at);
```

### 4.2. å¤šç§Ÿæˆ·ç³»ç»Ÿæ¨¡æ¿

**å¤šç§Ÿæˆ·ç³»ç»ŸSchemaæ¨¡æ¿**ï¼š

```sql
-- ============================================
-- å¤šç§Ÿæˆ·ç³»ç»Ÿæ¨¡æ¿
-- ============================================

-- ç§Ÿæˆ·è¡¨
CREATE TABLE tenants (
    tenant_id BIGSERIAL PRIMARY KEY,
    tenant_name VARCHAR(200) NOT NULL,
    tenant_slug VARCHAR(100) NOT NULL UNIQUE,
    domain VARCHAR(200),
    plan VARCHAR(50) NOT NULL CHECK (plan IN ('free', 'basic', 'premium', 'enterprise')),
    is_active BOOLEAN DEFAULT TRUE,
    subscription_expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_tenants_slug ON tenants(tenant_slug);
CREATE INDEX idx_tenants_domain ON tenants(domain);
CREATE INDEX idx_tenants_active ON tenants(tenant_id) WHERE is_active = TRUE;

-- ç§Ÿæˆ·ç”¨æˆ·å…³è”è¡¨
CREATE TABLE tenant_users (
    tenant_id BIGINT NOT NULL REFERENCES tenants(tenant_id) ON DELETE CASCADE,
    user_id BIGINT NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    role VARCHAR(50) NOT NULL CHECK (role IN ('owner', 'admin', 'member', 'viewer')),
    joined_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (tenant_id, user_id)
);

CREATE INDEX idx_tenant_users_tenant ON tenant_users(tenant_id);
CREATE INDEX idx_tenant_users_user ON tenant_users(user_id);

-- å¤šç§Ÿæˆ·æ•°æ®è¡¨æ¨¡æ¿ï¼ˆæ·»åŠ tenant_idï¼‰
CREATE TABLE {table_name} (
    {table_name}_id BIGSERIAL PRIMARY KEY,
    tenant_id BIGINT NOT NULL REFERENCES tenants(tenant_id) ON DELETE CASCADE,
    -- ä¸šåŠ¡å­—æ®µ
    {business_columns}
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºç§Ÿæˆ·éš”ç¦»ç´¢å¼•
CREATE INDEX idx_{table_name}_tenant ON {table_name}(tenant_id);
CREATE INDEX idx_{table_name}_tenant_created ON {table_name}(tenant_id, created_at DESC);

-- è¡Œçº§å®‰å…¨ç­–ç•¥ï¼ˆPostgreSQLï¼‰
ALTER TABLE {table_name} ENABLE ROW LEVEL SECURITY;

CREATE POLICY {table_name}_tenant_isolation ON {table_name}
    FOR ALL
    TO application_user
    USING (tenant_id = current_setting('app.current_tenant_id')::BIGINT);
```

---

## 5. ä»£ç ç”Ÿæˆå·¥å…·

### 5.1. Pythonæ¨¡å‹ç”Ÿæˆå™¨

**ä»æ•°æ®åº“Schemaç”ŸæˆPythonæ¨¡å‹**ï¼š

```python
"""
ä»PostgreSQL Schemaç”ŸæˆPython SQLAlchemyæ¨¡å‹
"""

import re
from typing import List, Dict

def generate_sqlalchemy_model(table_name: str, columns: List[Dict]) -> str:
    """ç”ŸæˆSQLAlchemyæ¨¡å‹ä»£ç """

    model_class_name = ''.join(word.capitalize() for word in table_name.split('_'))

    lines = [
        f"from sqlalchemy import Column, Integer, String, Boolean, DateTime, ForeignKey, Text, Numeric",
        f"from sqlalchemy.ext.declarative import declarative_base",
        f"from sqlalchemy.orm import relationship",
        f"from datetime import datetime",
        "",
        "Base = declarative_base()",
        "",
        f"class {model_class_name}(Base):",
        f'    __tablename__ = "{table_name}"',
        ""
    ]

    # ç”Ÿæˆåˆ—å®šä¹‰
    for col in columns:
        col_name = col['name']
        col_type = col['type']
        nullable = col.get('nullable', True)
        default = col.get('default')
        primary_key = col.get('primary_key', False)
        foreign_key = col.get('foreign_key')

        # ç±»å‹æ˜ å°„
        type_mapping = {
            'BIGSERIAL': 'Integer',
            'BIGINT': 'Integer',
            'INTEGER': 'Integer',
            'VARCHAR': 'String',
            'TEXT': 'Text',
            'DECIMAL': 'Numeric',
            'BOOLEAN': 'Boolean',
            'TIMESTAMP': 'DateTime',
            'TIMESTAMPTZ': 'DateTime',
            'JSONB': 'JSON'
        }

        sqlalchemy_type = type_mapping.get(col_type, 'String')

        # æ„å»ºåˆ—å®šä¹‰
        col_def = f"    {col_name} = Column("
        col_def += f"{sqlalchemy_type}"

        if not nullable:
            col_def += ", nullable=False"

        if primary_key:
            col_def += ", primary_key=True"

        if default:
            if default == 'CURRENT_TIMESTAMP':
                col_def += ", default=datetime.utcnow"
            else:
                col_def += f", default={default}"

        if foreign_key:
            col_def += f", ForeignKey('{foreign_key}')"

        col_def += ")"
        lines.append(col_def)

    lines.append("")
    lines.append("    def __repr__(self):")
    lines.append(f'        return f"<{model_class_name}(id={{self.{table_name}_id}})>"')

    return "\n".join(lines)

# ä½¿ç”¨ç¤ºä¾‹
columns = [
    {"name": "user_id", "type": "BIGSERIAL", "nullable": False, "primary_key": True},
    {"name": "username", "type": "VARCHAR", "nullable": False, "default": None},
    {"name": "email", "type": "VARCHAR", "nullable": False, "default": None},
    {"name": "created_at", "type": "TIMESTAMPTZ", "nullable": False, "default": "CURRENT_TIMESTAMP"}
]

print(generate_sqlalchemy_model("users", columns))
```

---

## 6. æ•°æ®åº“è®¾è®¡å·¥å…·

### 6.1. SchemaéªŒè¯å·¥å…·

**SchemaéªŒè¯å‡½æ•°**ï¼š

```sql
-- ============================================
-- SchemaéªŒè¯å·¥å…·
-- ============================================

-- æ£€æŸ¥è¡¨æ˜¯å¦æœ‰ä¸»é”®
CREATE OR REPLACE FUNCTION check_table_has_primary_key(p_table_name TEXT)
RETURNS BOOLEAN AS $$
DECLARE
    v_has_pk BOOLEAN;
BEGIN
    SELECT EXISTS(
        SELECT 1
        FROM information_schema.table_constraints
        WHERE table_schema = 'public'
          AND table_name = p_table_name
          AND constraint_type = 'PRIMARY KEY'
    ) INTO v_has_pk;

    RETURN v_has_pk;
END;
$$ LANGUAGE plpgsql;

-- æ£€æŸ¥å¤–é”®æ˜¯å¦æœ‰ç´¢å¼•
CREATE OR REPLACE FUNCTION check_foreign_keys_have_indexes()
RETURNS TABLE (
    table_name TEXT,
    constraint_name TEXT,
    columns TEXT,
    has_index BOOLEAN
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        tc.table_name::TEXT,
        tc.constraint_name::TEXT,
        string_agg(kcu.column_name, ', ' ORDER BY kcu.ordinal_position)::TEXT AS columns,
        EXISTS(
            SELECT 1
            FROM pg_indexes pi
            WHERE pi.tablename = tc.table_name
              AND pi.indexdef LIKE '%' || kcu.column_name || '%'
        ) AS has_index
    FROM information_schema.table_constraints tc
    JOIN information_schema.key_column_usage kcu
        ON tc.constraint_name = kcu.constraint_name
    WHERE tc.constraint_type = 'FOREIGN KEY'
      AND tc.table_schema = 'public'
    GROUP BY tc.table_name, tc.constraint_name
    ORDER BY tc.table_name;
END;
$$ LANGUAGE plpgsql;

-- æ£€æŸ¥è¡¨æ˜¯å¦æœ‰æ³¨é‡Š
CREATE OR REPLACE FUNCTION check_tables_have_comments()
RETURNS TABLE (
    table_name TEXT,
    has_comment BOOLEAN,
    comment TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        t.table_name::TEXT,
        (obj_description(c.oid, 'pg_class') IS NOT NULL) AS has_comment,
        COALESCE(obj_description(c.oid, 'pg_class'), '')::TEXT AS comment
    FROM information_schema.tables t
    JOIN pg_class c ON c.relname = t.table_name
    WHERE t.table_schema = 'public'
      AND t.table_type = 'BASE TABLE'
    ORDER BY t.table_name;
END;
$$ LANGUAGE plpgsql;
```

### 6.2. æ•°æ®åº“æ–‡æ¡£ç”Ÿæˆå·¥å…·

**è‡ªåŠ¨ç”Ÿæˆæ•°æ®åº“æ–‡æ¡£**ï¼š

```sql
-- ============================================
-- æ•°æ®åº“æ–‡æ¡£ç”Ÿæˆå·¥å…·
-- ============================================

-- ç”Ÿæˆè¡¨æ–‡æ¡£
CREATE OR REPLACE FUNCTION generate_table_documentation(p_table_name TEXT)
RETURNS TEXT AS $$
DECLARE
    v_doc TEXT;
    v_table_comment TEXT;
BEGIN
    -- è·å–è¡¨æ³¨é‡Š
    SELECT obj_description(c.oid, 'pg_class')
    INTO v_table_comment
    FROM pg_class c
    WHERE c.relname = p_table_name;

    v_doc := format('## %s\n\n', p_table_name);

    IF v_table_comment IS NOT NULL THEN
        v_doc := v_doc || format('%s\n\n', v_table_comment);
    END IF;

    -- æ·»åŠ åˆ—ä¿¡æ¯
    v_doc := v_doc || '### åˆ—ä¿¡æ¯\n\n';
    v_doc := v_doc || '| åˆ—å | ç±»å‹ | å¯ç©º | é»˜è®¤å€¼ | è¯´æ˜ |\n';
    v_doc := v_doc || '|------|------|------|--------|------|\n';

    FOR rec IN
        SELECT
            c.column_name,
            c.data_type,
            c.is_nullable,
            c.column_default,
            col_description(a.attrelid, a.attnum) AS column_comment
        FROM information_schema.columns c
        JOIN pg_attribute a ON a.attname = c.column_name
        JOIN pg_class pc ON pc.oid = a.attrelid
        WHERE c.table_name = p_table_name
          AND c.table_schema = 'public'
        ORDER BY c.ordinal_position
    LOOP
        v_doc := v_doc || format(
            '| %s | %s | %s | %s | %s |\n',
            rec.column_name,
            rec.data_type,
            rec.is_nullable,
            COALESCE(rec.column_default, '-'),
            COALESCE(rec.column_comment, '-')
        );
    END LOOP;

    RETURN v_doc;
END;
$$ LANGUAGE plpgsql;
```

---

## 7. å‚è€ƒèµ„æ–™

- [Schemaè®¾è®¡æ–¹æ³•è®º](./07.01-Schemaè®¾è®¡æ–¹æ³•è®º.md)
- [æ•°æ®åº“è®¾è®¡æœ€ä½³å®è·µåº“](./07.14-æ•°æ®åº“è®¾è®¡æœ€ä½³å®è·µåº“.md)
- [æ•°æ®åº“è®¾è®¡åæ¨¡å¼ä¸è§£å†³æ–¹æ¡ˆ](./07.06-æ•°æ®åº“è®¾è®¡åæ¨¡å¼ä¸è§£å†³æ–¹æ¡ˆ.md)

---

**æœ€åæ›´æ–°**ï¼š2025-01-15
**ç»´æŠ¤è€…**ï¼šData-Science Team
**çŠ¶æ€**ï¼šå®æ–½ä¸­
