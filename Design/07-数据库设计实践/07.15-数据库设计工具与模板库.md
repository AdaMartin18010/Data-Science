# æ•°æ®åº“è®¾è®¡å·¥å…·ä¸æ¨¡æ¿åº“ï¼šå®ç”¨å·¥å…·é›†åˆ

> **åˆ›å»ºæ—¥æœŸ**ï¼š2025-01-15
> **æœ€åæ›´æ–°**ï¼š2025-12-01
> **ç‰ˆæœ¬**ï¼šv2.0 (å¢å¼ºç‰ˆ)
> **çŠ¶æ€**ï¼šå·²å®Œæˆ âœ…

---

## ğŸ“‹ ç›®å½•

- [æ•°æ®åº“è®¾è®¡å·¥å…·ä¸æ¨¡æ¿åº“ï¼šå®ç”¨å·¥å…·é›†åˆ](#æ•°æ®åº“è®¾è®¡å·¥å…·ä¸æ¨¡æ¿åº“å®ç”¨å·¥å…·é›†åˆ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1. å·¥å…·åˆ†ç±»](#11-å·¥å…·åˆ†ç±»)
  - [2. Schemaè®¾è®¡æ£€æŸ¥æ¸…å•](#2-schemaè®¾è®¡æ£€æŸ¥æ¸…å•)
    - [2.1. Schemaè®¾è®¡æ£€æŸ¥æ¸…å•](#21-schemaè®¾è®¡æ£€æŸ¥æ¸…å•)
  - [Schemaè®¾è®¡æ£€æŸ¥æ¸…å•](#schemaè®¾è®¡æ£€æŸ¥æ¸…å•)
    - [å‘½åè§„èŒƒ](#å‘½åè§„èŒƒ)
    - [æ•°æ®ç±»å‹](#æ•°æ®ç±»å‹)
    - [çº¦æŸè®¾è®¡](#çº¦æŸè®¾è®¡)
    - [ç´¢å¼•è®¾è®¡](#ç´¢å¼•è®¾è®¡)
    - [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
    - [å®‰å…¨è®¾è®¡](#å®‰å…¨è®¾è®¡)
    - [æ–‡æ¡£](#æ–‡æ¡£)
    - [2.2. ç´¢å¼•è®¾è®¡æ£€æŸ¥æ¸…å•](#22-ç´¢å¼•è®¾è®¡æ£€æŸ¥æ¸…å•)
  - [ç´¢å¼•è®¾è®¡æ£€æŸ¥æ¸…å•](#ç´¢å¼•è®¾è®¡æ£€æŸ¥æ¸…å•)
    - [ç´¢å¼•åˆ›å»ºåŸåˆ™](#ç´¢å¼•åˆ›å»ºåŸåˆ™)
    - [ç´¢å¼•ç±»å‹é€‰æ‹©](#ç´¢å¼•ç±»å‹é€‰æ‹©)
    - [ç´¢å¼•ç»´æŠ¤](#ç´¢å¼•ç»´æŠ¤)
    - [2.3. æ€§èƒ½æ£€æŸ¥æ¸…å•](#23-æ€§èƒ½æ£€æŸ¥æ¸…å•)
  - [3. DDLç”Ÿæˆå·¥å…·](#3-ddlç”Ÿæˆå·¥å…·)
    - [3.1. Python DDLç”Ÿæˆå™¨](#31-python-ddlç”Ÿæˆå™¨)
    - [3.2. SQLæ¨¡æ¿åº“](#32-sqlæ¨¡æ¿åº“)
  - [4. æ•°æ®åº“è®¾è®¡æ¨¡æ¿](#4-æ•°æ®åº“è®¾è®¡æ¨¡æ¿)
    - [4.1. ç”¨æˆ·è®¤è¯ç³»ç»Ÿæ¨¡æ¿](#41-ç”¨æˆ·è®¤è¯ç³»ç»Ÿæ¨¡æ¿)
    - [4.2. å¤šç§Ÿæˆ·ç³»ç»Ÿæ¨¡æ¿](#42-å¤šç§Ÿæˆ·ç³»ç»Ÿæ¨¡æ¿)
  - [5. ä»£ç ç”Ÿæˆå·¥å…·](#5-ä»£ç ç”Ÿæˆå·¥å…·)
    - [5.1. Pythonæ¨¡å‹ç”Ÿæˆå™¨](#51-pythonæ¨¡å‹ç”Ÿæˆå™¨)
  - [6. æ•°æ®åº“è®¾è®¡å·¥å…·](#6-æ•°æ®åº“è®¾è®¡å·¥å…·)
    - [6.1. SchemaéªŒè¯å·¥å…·](#61-schemaéªŒè¯å·¥å…·)
    - [6.2. æ•°æ®åº“æ–‡æ¡£ç”Ÿæˆå·¥å…·](#62-æ•°æ®åº“æ–‡æ¡£ç”Ÿæˆå·¥å…·)
  - [7. 2024-2025æ–°å¢å·¥å…·](#7-2024-2025æ–°å¢å·¥å…·)
    - [7.1. AIè¾…åŠ©è®¾è®¡å·¥å…·](#71-aiè¾…åŠ©è®¾è®¡å·¥å…·)
    - [7.2. ç°ä»£è®¾è®¡å·¥å…·å¯¹æ¯”](#72-ç°ä»£è®¾è®¡å·¥å…·å¯¹æ¯”)
    - [7.3. MCPæ•°æ®åº“å·¥å…·](#73-mcpæ•°æ®åº“å·¥å…·)
  - [8. å‚è€ƒèµ„æ–™](#8-å‚è€ƒèµ„æ–™)
    - [8.1. åœ¨çº¿èµ„æº](#81-åœ¨çº¿èµ„æº)
    - [8.2. ç›¸å…³æ–‡æ¡£](#82-ç›¸å…³æ–‡æ¡£)

---

## 1. æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›æ•°æ®åº“è®¾è®¡çš„å®ç”¨å·¥å…·ã€æ¨¡æ¿å’Œæ£€æŸ¥æ¸…å•ï¼Œå¸®åŠ©å¿«é€Ÿã€è§„èŒƒåœ°è¿›è¡Œæ•°æ®åº“è®¾è®¡ã€‚

### 1.1. å·¥å…·åˆ†ç±»

```mermaid
mindmap
  root((è®¾è®¡å·¥å…·))
    æ£€æŸ¥æ¸…å•
      Schemaæ£€æŸ¥
      ç´¢å¼•æ£€æŸ¥
      æ€§èƒ½æ£€æŸ¥
      å®‰å…¨æ£€æŸ¥
    DDLç”Ÿæˆ
      Pythonç”Ÿæˆå™¨
      SQLæ¨¡æ¿
      å…ƒæ•°æ®é©±åŠ¨
    è®¾è®¡æ¨¡æ¿
      åŸºç¡€è¡¨æ¨¡æ¿
      å…³è”è¡¨æ¨¡æ¿
      å®¡è®¡è¡¨æ¨¡æ¿
      è½¯åˆ é™¤æ¨¡æ¿
    ä»£ç ç”Ÿæˆ
      æ¨¡å‹ä»£ç 
      APIä»£ç 
      æµ‹è¯•ä»£ç 
    è®¾è®¡å·¥å…·
      å¯è§†åŒ–å·¥å…·
      ç‰ˆæœ¬æ§åˆ¶
      æ–‡æ¡£ç”Ÿæˆ
```

---

## 2. Schemaè®¾è®¡æ£€æŸ¥æ¸…å•

### 2.1. Schemaè®¾è®¡æ£€æŸ¥æ¸…å•

**å®Œæ•´æ£€æŸ¥æ¸…å•**ï¼š

## Schemaè®¾è®¡æ£€æŸ¥æ¸…å•

### å‘½åè§„èŒƒ

**è¡¨å‘½åè§„èŒƒ**ï¼š

- **è¡¨åä½¿ç”¨å¤æ•°å½¢å¼**ï¼šä½¿ç”¨å¤æ•°å½¢å¼å‘½åè¡¨ï¼Œå¦‚ `users`ã€`orders`ã€`products`ï¼Œè¡¨ç¤ºè¡¨çš„é›†åˆæ€§è´¨
- **è¡¨åä½¿ç”¨å°å†™å­—æ¯å’Œä¸‹åˆ’çº¿**ï¼šä½¿ç”¨å°å†™å­—æ¯å’Œä¸‹åˆ’çº¿åˆ†éš”å•è¯ï¼Œå¦‚ `user_profiles`ã€`order_items`
- **åˆ—åæ¸…æ™°æ˜ç¡®**ï¼šåˆ—ååº”è¯¥æ¸…æ™°æ˜ç¡®ï¼Œä¸ä½¿ç”¨ç¼©å†™ï¼Œå¦‚ä½¿ç”¨ `user_name` è€Œä¸æ˜¯ `uname`
- **ä¸»é”®å‘½åè§„èŒƒ**ï¼šä¸»é”®å‘½åä¸º `{table}_id`ï¼Œå¦‚ `user_id`ã€`order_id`
- **å¤–é”®å‘½åè§„èŒƒ**ï¼šå¤–é”®å‘½åä¸º `{referenced_table}_id`ï¼Œå¦‚ `user_id`ã€`product_id`
- **å¸ƒå°”å­—æ®µå‘½å**ï¼šå¸ƒå°”å­—æ®µä½¿ç”¨ `is_` æˆ– `has_` å‰ç¼€ï¼Œå¦‚ `is_active`ã€`has_permission`
- **æ—¶é—´å­—æ®µå‘½å**ï¼šæ—¶é—´å­—æ®µä½¿ç”¨ `_at` åç¼€ï¼Œå¦‚ `created_at`ã€`updated_at`ã€`deleted_at`

**ç¤ºä¾‹**ï¼š

```sql
-- å¥½çš„å‘½åç¤ºä¾‹
CREATE TABLE users (
    user_id BIGSERIAL PRIMARY KEY,
    user_name VARCHAR(100) NOT NULL,
    email VARCHAR(255) NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- ä¸å¥½çš„å‘½åç¤ºä¾‹
CREATE TABLE user (  -- åº”è¯¥ä½¿ç”¨å¤æ•°
    id SERIAL,  -- åº”è¯¥ä½¿ç”¨ user_id
    name VARCHAR(100),  -- åº”è¯¥ä½¿ç”¨ user_name
    active BOOLEAN,  -- åº”è¯¥ä½¿ç”¨ is_active
    create_time TIMESTAMP  -- åº”è¯¥ä½¿ç”¨ created_at
);
```

### æ•°æ®ç±»å‹

**æ•°æ®ç±»å‹é€‰æ‹©è§„èŒƒ**ï¼š

- **ä¸»é”®ç±»å‹**ï¼šä¸»é”®ä½¿ç”¨ `BIGSERIAL`ï¼ˆPostgreSQLï¼‰æˆ– `BIGINT AUTO_INCREMENT`ï¼ˆMySQLï¼‰ï¼Œæ”¯æŒå¤§IDï¼Œé¿å…æº¢å‡º
- **è´§å¸ç±»å‹**ï¼šè´§å¸ä½¿ç”¨ `DECIMAL(10,2)` æˆ– `NUMERIC(10,2)`ï¼Œç¡®ä¿ç²¾åº¦ï¼Œé¿å…æµ®ç‚¹æ•°è¯¯å·®
- **æ–‡æœ¬ç±»å‹**ï¼šæ–‡æœ¬ä½¿ç”¨ `VARCHAR(n)`ï¼ˆå›ºå®šé•¿åº¦ï¼‰æˆ– `TEXT`ï¼ˆå¯å˜é•¿åº¦ï¼‰ï¼Œæ ¹æ®å®é™…éœ€æ±‚é€‰æ‹©
- **æ—¶é—´æˆ³ç±»å‹**ï¼šæ—¶é—´æˆ³ä½¿ç”¨ `TIMESTAMPTZ`ï¼ˆPostgreSQLï¼‰æˆ– `TIMESTAMP`ï¼ˆMySQLï¼‰ï¼Œéœ€è¦æ—¶åŒºæ—¶ä½¿ç”¨å¸¦æ—¶åŒºçš„ç±»å‹
- **å¸ƒå°”ç±»å‹**ï¼šå¸ƒå°”å€¼ä½¿ç”¨ `BOOLEAN`ï¼Œè€Œä¸æ˜¯ `INTEGER` æˆ– `CHAR(1)`
- **JSONæ•°æ®**ï¼šJSONæ•°æ®ä½¿ç”¨ `JSONB`ï¼ˆPostgreSQLï¼‰æˆ– `JSON`ï¼ˆMySQLï¼‰ï¼Œæ”¯æŒé«˜æ•ˆæŸ¥è¯¢å’Œç´¢å¼•

**ç¤ºä¾‹**ï¼š

```sql
-- å¥½çš„æ•°æ®ç±»å‹é€‰æ‹©
CREATE TABLE products (
    product_id BIGSERIAL PRIMARY KEY,
    product_name VARCHAR(255) NOT NULL,
    description TEXT,
    price DECIMAL(10,2) NOT NULL,
    is_available BOOLEAN DEFAULT TRUE,
    metadata JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ä¸å¥½çš„æ•°æ®ç±»å‹é€‰æ‹©
CREATE TABLE products (
    id INTEGER,  -- åº”è¯¥ä½¿ç”¨ BIGSERIAL
    name CHAR(100),  -- åº”è¯¥ä½¿ç”¨ VARCHAR(255)
    price FLOAT,  -- åº”è¯¥ä½¿ç”¨ DECIMAL(10,2)
    available INTEGER,  -- åº”è¯¥ä½¿ç”¨ BOOLEAN
    created_at TIMESTAMP  -- åº”è¯¥ä½¿ç”¨ TIMESTAMPTZ
);
```

### çº¦æŸè®¾è®¡

**çº¦æŸè®¾è®¡è§„èŒƒ**ï¼š

- **ä¸»é”®çº¦æŸ**ï¼šæ‰€æœ‰è¡¨éƒ½åº”è¯¥æœ‰ä¸»é”®ï¼Œç¡®ä¿æ¯è¡Œæ•°æ®çš„å”¯ä¸€æ ‡è¯†
- **å¤–é”®çº¦æŸ**ï¼šå¤–é”®éƒ½åº”è¯¥æœ‰ `REFERENCES` çº¦æŸï¼Œç¡®ä¿å‚ç…§å®Œæ•´æ€§
- **å¤–é”®åˆ é™¤ç­–ç•¥**ï¼šå¤–é”®åº”è¯¥æœ‰ `ON DELETE` ç­–ç•¥ï¼ˆ`RESTRICT`ã€`CASCADE`ã€`SET NULL`ï¼‰ï¼Œæ ¹æ®ä¸šåŠ¡éœ€æ±‚é€‰æ‹©
- **å”¯ä¸€çº¦æŸ**ï¼šå”¯ä¸€çº¦æŸä½¿ç”¨ `UNIQUE`ï¼Œç¡®ä¿åˆ—å€¼çš„å”¯ä¸€æ€§
- **æ£€æŸ¥çº¦æŸ**ï¼šæ£€æŸ¥çº¦æŸä½¿ç”¨ `CHECK`ï¼Œç¡®ä¿åˆ—å€¼æ»¡è¶³ç‰¹å®šæ¡ä»¶
- **éç©ºçº¦æŸ**ï¼š`NOT NULL` çº¦æŸåº”è¯¥æ˜ç¡®æŒ‡å®šï¼Œç¡®ä¿åˆ—å€¼ä¸ä¸ºç©º

**ç¤ºä¾‹**ï¼š

```sql
-- å¥½çš„çº¦æŸè®¾è®¡
CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(user_id) ON DELETE RESTRICT,
    order_number VARCHAR(50) UNIQUE NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL CHECK (total_amount >= 0),
    status VARCHAR(20) NOT NULL CHECK (status IN ('pending', 'processing', 'completed', 'cancelled')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- ä¸å¥½çš„çº¦æŸè®¾è®¡
CREATE TABLE orders (
    id SERIAL,  -- ç¼ºå°‘ PRIMARY KEY
    user_id INTEGER,  -- ç¼ºå°‘ REFERENCES çº¦æŸ
    order_number VARCHAR(50),  -- ç¼ºå°‘ UNIQUE çº¦æŸ
    total_amount DECIMAL(10,2),  -- ç¼ºå°‘ CHECK çº¦æŸ
    status VARCHAR(20)  -- ç¼ºå°‘ CHECK çº¦æŸ
);
```

### ç´¢å¼•è®¾è®¡

**ç´¢å¼•è®¾è®¡è§„èŒƒ**ï¼š

- **ä¸»é”®ç´¢å¼•**ï¼šä¸»é”®è‡ªåŠ¨åˆ›å»ºç´¢å¼•ï¼Œæ— éœ€æ‰‹åŠ¨åˆ›å»º
- **å¤–é”®ç´¢å¼•**ï¼šå¤–é”®åº”è¯¥è‡ªåŠ¨åˆ›å»ºç´¢å¼•ï¼Œæé«˜JOINæŸ¥è¯¢æ€§èƒ½
- **å¸¸ç”¨æŸ¥è¯¢åˆ—ç´¢å¼•**ï¼šå¸¸ç”¨æŸ¥è¯¢åˆ—åº”è¯¥æœ‰ç´¢å¼•ï¼Œç‰¹åˆ«æ˜¯WHEREå­å¥ä¸­çš„åˆ—
- **å¤åˆç´¢å¼•åˆ—é¡ºåº**ï¼šå¤åˆç´¢å¼•åˆ—é¡ºåºåº”è¯¥åˆç†ï¼Œé«˜é€‰æ‹©æ€§åˆ—åœ¨å‰
- **éƒ¨åˆ†ç´¢å¼•**ï¼šéƒ¨åˆ†ç´¢å¼•ç”¨äºè¿‡æ»¤æ¡ä»¶ï¼Œå‡å°‘ç´¢å¼•å¤§å°
- **è¦†ç›–ç´¢å¼•**ï¼šè¦†ç›–ç´¢å¼•åŒ…å«æŸ¥è¯¢æ‰€éœ€åˆ—ï¼Œé¿å…å›è¡¨æŸ¥è¯¢

**ç¤ºä¾‹**ï¼š

```sql
-- å¥½çš„ç´¢å¼•è®¾è®¡
CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,  -- ä¸»é”®è‡ªåŠ¨åˆ›å»ºç´¢å¼•
    user_id BIGINT NOT NULL REFERENCES users(user_id),
    order_date DATE NOT NULL,
    status VARCHAR(20) NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL
);

-- ä¸ºå¸¸ç”¨æŸ¥è¯¢åˆ—åˆ›å»ºç´¢å¼•
CREATE INDEX idx_orders_user_id ON orders(user_id);  -- å¤–é”®ç´¢å¼•
CREATE INDEX idx_orders_order_date ON orders(order_date);  -- æ—¥æœŸæŸ¥è¯¢ç´¢å¼•
CREATE INDEX idx_orders_status ON orders(status);  -- çŠ¶æ€æŸ¥è¯¢ç´¢å¼•

-- å¤åˆç´¢å¼•ï¼ˆé«˜é€‰æ‹©æ€§åˆ—åœ¨å‰ï¼‰
CREATE INDEX idx_orders_user_date ON orders(user_id, order_date);

-- éƒ¨åˆ†ç´¢å¼•ï¼ˆåªç´¢å¼•æ´»è·ƒè®¢å•ï¼‰
CREATE INDEX idx_orders_active ON orders(order_id) WHERE status = 'pending';

-- è¦†ç›–ç´¢å¼•ï¼ˆåŒ…å«æŸ¥è¯¢æ‰€éœ€åˆ—ï¼‰
CREATE INDEX idx_orders_user_status_amount ON orders(user_id, status) INCLUDE (total_amount);
```

### æ€§èƒ½ä¼˜åŒ–

**æ€§èƒ½ä¼˜åŒ–è§„èŒƒ**ï¼š

- **å¤§è¡¨åˆ†åŒº**ï¼šå¤§è¡¨ä½¿ç”¨åˆ†åŒºï¼ˆæ—¶é—´åºåˆ—æ•°æ®ï¼‰ï¼Œæé«˜æŸ¥è¯¢æ€§èƒ½å’Œç®¡ç†æ•ˆç‡
- **ç‰©åŒ–è§†å›¾**ï¼šå¸¸ç”¨æŸ¥è¯¢ä½¿ç”¨ç‰©åŒ–è§†å›¾ï¼Œé¢„è®¡ç®—æŸ¥è¯¢ç»“æœ
- **ç»Ÿè®¡ä¿¡æ¯æ›´æ–°**ï¼šç»Ÿè®¡ä¿¡æ¯å®šæœŸæ›´æ–°ï¼ˆ`ANALYZE`ï¼‰ï¼Œç¡®ä¿æŸ¥è¯¢ä¼˜åŒ–å™¨ä½¿ç”¨å‡†ç¡®çš„ç»Ÿè®¡ä¿¡æ¯
- **ç´¢å¼•ç»´æŠ¤**ï¼šç´¢å¼•å®šæœŸç»´æŠ¤ï¼ˆ`REINDEX`ï¼‰ï¼Œé‡å»ºç¢ç‰‡åŒ–çš„ç´¢å¼•

**ç¤ºä¾‹**ï¼š

```sql
-- å¤§è¡¨åˆ†åŒºï¼ˆæŒ‰æœˆåˆ†åŒºï¼‰
CREATE TABLE orders (
    order_id BIGSERIAL,
    user_id BIGINT NOT NULL,
    order_date DATE NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    PRIMARY KEY (order_id, order_date)
) PARTITION BY RANGE (order_date);

CREATE TABLE orders_2024_01 PARTITION OF orders
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

CREATE TABLE orders_2024_02 PARTITION OF orders
    FOR VALUES FROM ('2024-02-01') TO ('2024-03-01');

-- ç‰©åŒ–è§†å›¾ï¼ˆé¢„è®¡ç®—æŸ¥è¯¢ç»“æœï¼‰
CREATE MATERIALIZED VIEW monthly_sales AS
SELECT
    DATE_TRUNC('month', order_date) AS month,
    COUNT(*) AS order_count,
    SUM(total_amount) AS total_sales
FROM orders
GROUP BY DATE_TRUNC('month', order_date);

-- å®šæœŸåˆ·æ–°ç‰©åŒ–è§†å›¾
REFRESH MATERIALIZED VIEW CONCURRENTLY monthly_sales;

-- å®šæœŸæ›´æ–°ç»Ÿè®¡ä¿¡æ¯
ANALYZE orders;

-- å®šæœŸé‡å»ºç´¢å¼•
REINDEX TABLE orders;
```

### å®‰å…¨è®¾è®¡

**å®‰å…¨è®¾è®¡è§„èŒƒ**ï¼š

- **æ•æ„Ÿæ•°æ®åŠ å¯†**ï¼šæ•æ„Ÿæ•°æ®åŠ å¯†å­˜å‚¨ï¼Œä½¿ç”¨ `pgcrypto` æ‰©å±•æˆ–åº”ç”¨å±‚åŠ å¯†
- **å¯†ç å“ˆå¸Œ**ï¼šå¯†ç ä½¿ç”¨å“ˆå¸Œå­˜å‚¨ï¼Œä½¿ç”¨ `bcrypt` æˆ– `argon2` ç­‰å®‰å…¨å“ˆå¸Œç®—æ³•
- **è®¿é—®æ§åˆ¶**ï¼šè®¿é—®æ§åˆ¶ä½¿ç”¨è§’è‰²å’Œæƒé™ï¼Œå®ç°ç»†ç²’åº¦çš„æƒé™ç®¡ç†
- **å®¡è®¡å­—æ®µ**ï¼šå®¡è®¡å­—æ®µè®°å½•æ“ä½œï¼ˆ`created_at`ã€`updated_at`ã€`created_by`ã€`updated_by`ï¼‰
- **è½¯åˆ é™¤**ï¼šè½¯åˆ é™¤ä½¿ç”¨ `deleted_at` å­—æ®µï¼Œè€Œä¸æ˜¯ç‰©ç†åˆ é™¤

**ç¤ºä¾‹**ï¼š

```sql
-- æ•æ„Ÿæ•°æ®åŠ å¯†
CREATE EXTENSION IF NOT EXISTS pgcrypto;

CREATE TABLE users (
    user_id BIGSERIAL PRIMARY KEY,
    user_name VARCHAR(100) NOT NULL,
    email VARCHAR(255) NOT NULL,
    password_hash TEXT NOT NULL,  -- ä½¿ç”¨ bcrypt å“ˆå¸Œ
    phone_number TEXT,  -- åŠ å¯†å­˜å‚¨
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ  -- è½¯åˆ é™¤
);

-- å¯†ç å“ˆå¸Œå‡½æ•°ï¼ˆåº”ç”¨å±‚å®ç°ï¼‰
-- password_hash = bcrypt.hash(password, salt_rounds=12)

-- æ•æ„Ÿæ•°æ®åŠ å¯†å‡½æ•°
CREATE OR REPLACE FUNCTION encrypt_phone(phone TEXT)
RETURNS TEXT AS $$
BEGIN
    RETURN pgp_sym_encrypt(phone, current_setting('app.encryption_key'));
END;
$$ LANGUAGE plpgsql;

-- è®¿é—®æ§åˆ¶ï¼ˆRLSç­–ç•¥ï¼‰
ALTER TABLE users ENABLE ROW LEVEL SECURITY;

CREATE POLICY user_access_policy ON users
    FOR ALL
    TO authenticated_users
    USING (user_id = current_user_id());
```

### æ–‡æ¡£

**æ–‡æ¡£è§„èŒƒ**ï¼š

- **è¡¨æ³¨é‡Š**ï¼šè¡¨åº”è¯¥æœ‰ `COMMENT` è¯´æ˜ï¼Œæè¿°è¡¨çš„ç”¨é€”å’Œä¸šåŠ¡å«ä¹‰
- **åˆ—æ³¨é‡Š**ï¼šåˆ—åº”è¯¥æœ‰ `COMMENT` è¯´æ˜ï¼Œæè¿°åˆ—çš„ç”¨é€”å’Œæ•°æ®ç±»å‹
- **çº¦æŸæ³¨é‡Š**ï¼šå¤æ‚çº¦æŸåº”è¯¥æœ‰æ³¨é‡Šè¯´æ˜ï¼Œè§£é‡Šçº¦æŸçš„ä¸šåŠ¡å«ä¹‰
- **æ•°æ®å­—å…¸**ï¼šæ•°æ®å­—å…¸åº”è¯¥å®Œæ•´ï¼ŒåŒ…å«æ‰€æœ‰è¡¨å’Œåˆ—çš„è¯´æ˜

**ç¤ºä¾‹**ï¼š

```sql
-- è¡¨æ³¨é‡Š
COMMENT ON TABLE users IS 'ç”¨æˆ·è¡¨ï¼Œå­˜å‚¨ç³»ç»Ÿç”¨æˆ·çš„åŸºæœ¬ä¿¡æ¯';

-- åˆ—æ³¨é‡Š
COMMENT ON COLUMN users.user_id IS 'ç”¨æˆ·IDï¼Œä¸»é”®ï¼Œè‡ªå¢';
COMMENT ON COLUMN users.user_name IS 'ç”¨æˆ·åï¼Œå”¯ä¸€ï¼Œç”¨äºç™»å½•';
COMMENT ON COLUMN users.email IS 'ç”¨æˆ·é‚®ç®±ï¼Œå”¯ä¸€ï¼Œç”¨äºç™»å½•å’Œé€šçŸ¥';
COMMENT ON COLUMN users.password_hash IS 'å¯†ç å“ˆå¸Œå€¼ï¼Œä½¿ç”¨bcryptç®—æ³•';
COMMENT ON COLUMN users.created_at IS 'åˆ›å»ºæ—¶é—´ï¼Œè‡ªåŠ¨è®¾ç½®';
COMMENT ON COLUMN users.updated_at IS 'æ›´æ–°æ—¶é—´ï¼Œè‡ªåŠ¨æ›´æ–°';
COMMENT ON COLUMN users.deleted_at IS 'åˆ é™¤æ—¶é—´ï¼Œè½¯åˆ é™¤æ ‡è®°';

-- çº¦æŸæ³¨é‡Š
COMMENT ON CONSTRAINT users_email_key ON users IS 'é‚®ç®±å”¯ä¸€çº¦æŸï¼Œç¡®ä¿æ¯ä¸ªé‚®ç®±åªèƒ½æ³¨å†Œä¸€ä¸ªè´¦æˆ·';
COMMENT ON CONSTRAINT users_user_name_check ON users IS 'ç”¨æˆ·åé•¿åº¦æ£€æŸ¥ï¼Œç¡®ä¿ç”¨æˆ·åé•¿åº¦åœ¨3-50å­—ç¬¦ä¹‹é—´';
```

### 2.2. ç´¢å¼•è®¾è®¡æ£€æŸ¥æ¸…å•

**ç´¢å¼•æ£€æŸ¥æ¸…å•**ï¼š

## ç´¢å¼•è®¾è®¡æ£€æŸ¥æ¸…å•

### ç´¢å¼•åˆ›å»ºåŸåˆ™

**ç´¢å¼•åˆ›å»ºåŸåˆ™**ï¼š

- **WHEREå­å¥ç´¢å¼•**ï¼šä¸ºWHEREå­å¥ä¸­çš„åˆ—åˆ›å»ºç´¢å¼•ï¼Œç‰¹åˆ«æ˜¯é¢‘ç¹æŸ¥è¯¢çš„åˆ—
- **JOINæ¡ä»¶ç´¢å¼•**ï¼šä¸ºJOINæ¡ä»¶åˆ›å»ºç´¢å¼•ï¼Œæé«˜JOINæŸ¥è¯¢æ€§èƒ½
- **ORDER BYç´¢å¼•**ï¼šä¸ºORDER BYåˆ—åˆ›å»ºç´¢å¼•ï¼Œé¿å…æ’åºæ“ä½œ
- **ç´¢å¼•é€‰æ‹©æ€§**ï¼šç´¢å¼•é€‰æ‹©æ€§åº”è¯¥ > 0.1ï¼ˆé«˜é€‰æ‹©æ€§ï¼‰ï¼Œé€‰æ‹©æ€§ = ä¸åŒå€¼æ•°é‡ / æ€»è¡Œæ•°
- **æŸ¥è¯¢é¢‘ç‡**ï¼šæŸ¥è¯¢é¢‘ç‡åº”è¯¥ > å†™å…¥é¢‘ç‡ Ã— 10ï¼Œç¡®ä¿ç´¢å¼•å¸¦æ¥çš„æŸ¥è¯¢æ€§èƒ½æå‡å¤§äºå†™å…¥æ€§èƒ½æŸå¤±

**ç¤ºä¾‹**ï¼š

```sql
-- ä¸ºWHEREå­å¥åˆ›å»ºç´¢å¼•
CREATE INDEX idx_users_email ON users(email);  -- WHERE email = ?
CREATE INDEX idx_orders_status ON orders(status);  -- WHERE status = ?

-- ä¸ºJOINæ¡ä»¶åˆ›å»ºç´¢å¼•
CREATE INDEX idx_orders_user_id ON orders(user_id);  -- JOIN users ON orders.user_id = users.user_id

-- ä¸ºORDER BYåˆ›å»ºç´¢å¼•
CREATE INDEX idx_orders_order_date ON orders(order_date);  -- ORDER BY order_date

-- æ£€æŸ¥ç´¢å¼•é€‰æ‹©æ€§
SELECT
    COUNT(DISTINCT status)::FLOAT / COUNT(*) AS selectivity
FROM orders;
-- é€‰æ‹©æ€§ > 0.1 è¡¨ç¤ºç´¢å¼•æœ‰æ•ˆ

-- æ£€æŸ¥æŸ¥è¯¢é¢‘ç‡ vs å†™å…¥é¢‘ç‡
SELECT
    schemaname,
    tablename,
    idx_scan AS index_scans,  -- ç´¢å¼•æ‰«ææ¬¡æ•°
    idx_tup_read AS tuples_read,  -- è¯»å–çš„å…ƒç»„æ•°
    idx_tup_fetch AS tuples_fetched  -- è·å–çš„å…ƒç»„æ•°
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
ORDER BY idx_scan DESC;
```

### ç´¢å¼•ç±»å‹é€‰æ‹©

**ç´¢å¼•ç±»å‹é€‰æ‹©è§„èŒƒ**ï¼š

- **B-Treeç´¢å¼•**ï¼šB-Treeç´¢å¼•ç”¨äºç­‰å€¼å’ŒèŒƒå›´æŸ¥è¯¢ï¼Œæ˜¯é»˜è®¤ç´¢å¼•ç±»å‹
- **GINç´¢å¼•**ï¼šGINç´¢å¼•ç”¨äºå…¨æ–‡æœç´¢ã€æ•°ç»„ã€JSONï¼Œæ”¯æŒå¤šå€¼æŸ¥è¯¢
- **GiSTç´¢å¼•**ï¼šGiSTç´¢å¼•ç”¨äºç©ºé—´æ•°æ®ï¼Œæ”¯æŒç©ºé—´æŸ¥è¯¢
- **HNSWç´¢å¼•**ï¼šHNSWç´¢å¼•ç”¨äºå‘é‡ç›¸ä¼¼åº¦æœç´¢ï¼Œæ”¯æŒé«˜ç»´å‘é‡æ£€ç´¢
- **éƒ¨åˆ†ç´¢å¼•**ï¼šéƒ¨åˆ†ç´¢å¼•ç”¨äºè¿‡æ»¤æ¡ä»¶ï¼Œåªç´¢å¼•æ»¡è¶³æ¡ä»¶çš„è¡Œ

**ç¤ºä¾‹**ï¼š

```sql
-- B-Treeç´¢å¼•ï¼ˆé»˜è®¤ï¼Œç­‰å€¼å’ŒèŒƒå›´æŸ¥è¯¢ï¼‰
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_orders_order_date ON orders(order_date);

-- GINç´¢å¼•ï¼ˆå…¨æ–‡æœç´¢ã€æ•°ç»„ã€JSONï¼‰
CREATE INDEX idx_products_tags_gin ON products USING GIN(tags);
CREATE INDEX idx_products_metadata_gin ON products USING GIN(metadata);

-- GiSTç´¢å¼•ï¼ˆç©ºé—´æ•°æ®ï¼‰
CREATE INDEX idx_locations_geom_gist ON locations USING GIST(geom);

-- HNSWç´¢å¼•ï¼ˆå‘é‡ç›¸ä¼¼åº¦æœç´¢ï¼‰
CREATE INDEX idx_products_embedding_hnsw ON products USING hnsw(embedding vector_cosine_ops);

-- éƒ¨åˆ†ç´¢å¼•ï¼ˆåªç´¢å¼•æ´»è·ƒè®¢å•ï¼‰
CREATE INDEX idx_orders_active ON orders(order_id) WHERE status = 'pending';
```

### ç´¢å¼•ç»´æŠ¤

**ç´¢å¼•ç»´æŠ¤è§„èŒƒ**ï¼š

- **å®šæœŸæ£€æŸ¥ç´¢å¼•ä½¿ç”¨æƒ…å†µ**ï¼šå®šæœŸæ£€æŸ¥ç´¢å¼•ä½¿ç”¨æƒ…å†µï¼Œè¯†åˆ«æœªä½¿ç”¨çš„ç´¢å¼•
- **åˆ é™¤æœªä½¿ç”¨çš„ç´¢å¼•**ï¼šåˆ é™¤æœªä½¿ç”¨çš„ç´¢å¼•ï¼Œå‡å°‘å­˜å‚¨ç©ºé—´å’Œç»´æŠ¤å¼€é”€
- **é‡å»ºç¢ç‰‡åŒ–çš„ç´¢å¼•**ï¼šé‡å»ºç¢ç‰‡åŒ–çš„ç´¢å¼•ï¼Œæé«˜æŸ¥è¯¢æ€§èƒ½
- **æ›´æ–°ç»Ÿè®¡ä¿¡æ¯**ï¼šæ›´æ–°ç»Ÿè®¡ä¿¡æ¯ï¼ˆ`ANALYZE`ï¼‰ï¼Œç¡®ä¿æŸ¥è¯¢ä¼˜åŒ–å™¨ä½¿ç”¨å‡†ç¡®çš„ç»Ÿè®¡ä¿¡æ¯

**ç¤ºä¾‹**ï¼š

```sql
-- æ£€æŸ¥ç´¢å¼•ä½¿ç”¨æƒ…å†µ
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan AS index_scans,
    idx_tup_read AS tuples_read,
    idx_tup_fetch AS tuples_fetched
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
ORDER BY idx_scan ASC;  -- æ‰«ææ¬¡æ•°å°‘çš„ç´¢å¼•å¯èƒ½æ˜¯æœªä½¿ç”¨çš„

-- æ£€æŸ¥æœªä½¿ç”¨çš„ç´¢å¼•ï¼ˆæ‰«ææ¬¡æ•°ä¸º0ï¼‰
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
  AND idx_scan = 0
  AND indexname NOT LIKE '%_pkey';  -- æ’é™¤ä¸»é”®ç´¢å¼•

-- åˆ é™¤æœªä½¿ç”¨çš„ç´¢å¼•
DROP INDEX IF EXISTS idx_unused_index;

-- é‡å»ºç¢ç‰‡åŒ–çš„ç´¢å¼•
REINDEX INDEX CONCURRENTLY idx_orders_order_date;

-- æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
ANALYZE orders;
```

### 2.3. æ€§èƒ½æ£€æŸ¥æ¸…å•

**æ€§èƒ½æ£€æŸ¥æ¸…å•**ï¼š

```markdown
## æ€§èƒ½æ£€æŸ¥æ¸…å•

### æŸ¥è¯¢æ€§èƒ½
- [ ] æ…¢æŸ¥è¯¢å·²ä¼˜åŒ–ï¼ˆ< 100msï¼‰
- [ ] ä½¿ç”¨ EXPLAIN ANALYZE åˆ†ææŸ¥è¯¢è®¡åˆ’
- [ ] é¿å…å…¨è¡¨æ‰«æ
- [ ] JOIN æ“ä½œä½¿ç”¨ç´¢å¼•
- [ ] å­æŸ¥è¯¢å·²ä¼˜åŒ–ï¼ˆä½¿ç”¨ JOIN æˆ– EXISTSï¼‰
- [ ] åˆ†é¡µæŸ¥è¯¢ä½¿ç”¨æ¸¸æ ‡åˆ†é¡µï¼ˆå¤§æ•°æ®é›†ï¼‰

### ç´¢å¼•æ€§èƒ½
- [ ] ç´¢å¼•å¤§å°åˆç†ï¼ˆ< è¡¨å¤§å°çš„ 50%ï¼‰
- [ ] ç´¢å¼•ä½¿ç”¨ç‡é«˜ï¼ˆ> 80%ï¼‰
- [ ] å¤åˆç´¢å¼•åˆ—é¡ºåºåˆç†
- [ ] éƒ¨åˆ†ç´¢å¼•å‡å°‘ç´¢å¼•å¤§å°

### è¡¨è®¾è®¡æ€§èƒ½
- [ ] è¡¨å¤§å°åˆç†ï¼ˆè€ƒè™‘åˆ†åŒºï¼‰
- [ ] åˆ—é¡ºåºä¼˜åŒ–ï¼ˆå¸¸ç”¨åˆ—åœ¨å‰ï¼‰
- [ ] æ•°æ®ç±»å‹é€‰æ‹©åˆç†ï¼ˆå‡å°‘å­˜å‚¨ç©ºé—´ï¼‰
- [ ] èŒƒå¼åŒ–ç¨‹åº¦åˆç†ï¼ˆå¹³è¡¡æŸ¥è¯¢å’Œæ›´æ–°æ€§èƒ½ï¼‰
```

---

## 3. DDLç”Ÿæˆå·¥å…·

### 3.1. Python DDLç”Ÿæˆå™¨

**åŸºç¡€DDLç”Ÿæˆå™¨**ï¼š

```python
"""
æ•°æ®åº“DDLç”Ÿæˆå™¨
æ”¯æŒä»Pythonå¯¹è±¡ç”ŸæˆPostgreSQL DDLè¯­å¥
"""

from typing import List, Optional, Dict
from enum import Enum

class DataType(Enum):
    """æ•°æ®ç±»å‹æšä¸¾"""
    BIGSERIAL = "BIGSERIAL"
    BIGINT = "BIGINT"
    INTEGER = "INTEGER"
    VARCHAR = "VARCHAR"
    TEXT = "TEXT"
    DECIMAL = "DECIMAL"
    BOOLEAN = "BOOLEAN"
    TIMESTAMP = "TIMESTAMP"
    TIMESTAMPTZ = "TIMESTAMPTZ"
    JSONB = "JSONB"
    UUID = "UUID"

class Column:
    """åˆ—å®šä¹‰"""
    def __init__(
        self,
        name: str,
        data_type: DataType,
        nullable: bool = True,
        default: Optional[str] = None,
        unique: bool = False,
        check: Optional[str] = None,
        comment: Optional[str] = None
    ):
        self.name = name
        self.data_type = data_type
        self.nullable = nullable
        self.default = default
        self.unique = unique
        self.check = check
        self.comment = comment

    def to_ddl(self) -> str:
        """ç”Ÿæˆåˆ—DDL"""
        ddl = f"{self.name} {self.data_type.value}"

        if not self.nullable:
            ddl += " NOT NULL"

        if self.default:
            ddl += f" DEFAULT {self.default}"

        if self.unique:
            ddl += " UNIQUE"

        if self.check:
            ddl += f" CHECK ({self.check})"

        return ddl

class ForeignKey:
    """å¤–é”®å®šä¹‰"""
    def __init__(
        self,
        columns: List[str],
        references_table: str,
        referenced_columns: List[str],
        on_delete: str = "RESTRICT",
        on_update: str = "RESTRICT"
    ):
        self.columns = columns
        self.references_table = references_table
        self.referenced_columns = referenced_columns
        self.on_delete = on_delete
        self.on_update = on_update

    def to_ddl(self) -> str:
        """ç”Ÿæˆå¤–é”®DDL"""
        cols = ", ".join(self.columns)
        ref_cols = ", ".join(self.referenced_columns)
        return (
            f"FOREIGN KEY ({cols}) "
            f"REFERENCES {self.references_table}({ref_cols}) "
            f"ON DELETE {self.on_delete} "
            f"ON UPDATE {self.on_update}"
        )

class Table:
    """è¡¨å®šä¹‰"""
    def __init__(
        self,
        name: str,
        columns: List[Column],
        primary_key: Optional[List[str]] = None,
        foreign_keys: Optional[List[ForeignKey]] = None,
        indexes: Optional[List[Dict]] = None,
        comment: Optional[str] = None
    ):
        self.name = name
        self.columns = columns
        self.primary_key = primary_key
        self.foreign_keys = foreign_keys or []
        self.indexes = indexes or []
        self.comment = comment

    def to_ddl(self) -> str:
        """ç”Ÿæˆè¡¨DDL"""
        ddl_parts = []

        # CREATE TABLE
        ddl_parts.append(f"CREATE TABLE {self.name} (")

        # Columns
        column_ddls = [f"    {col.to_ddl()}" for col in self.columns]
        ddl_parts.append(",\n".join(column_ddls))

        # Primary Key
        if self.primary_key:
            pk_cols = ", ".join(self.primary_key)
            ddl_parts.append(f",\n    PRIMARY KEY ({pk_cols})")

        # Foreign Keys
        for fk in self.foreign_keys:
            ddl_parts.append(f",\n    {fk.to_ddl()}")

        ddl_parts.append("\n);")

        # Comment
        if self.comment:
            ddl_parts.append(f"\nCOMMENT ON TABLE {self.name} IS '{self.comment}';")

        # Column Comments
        for col in self.columns:
            if col.comment:
                ddl_parts.append(
                    f"\nCOMMENT ON COLUMN {self.name}.{col.name} IS '{col.comment}';"
                )

        # Indexes
        for idx in self.indexes:
            idx_name = idx.get('name', f"idx_{self.name}_{'_'.join(idx['columns'])}")
            idx_cols = ", ".join(idx['columns'])
            idx_type = idx.get('type', 'BTREE')
            idx_where = idx.get('where')

            idx_ddl = f"CREATE INDEX {idx_name} ON {self.name} USING {idx_type} ({idx_cols})"
            if idx_where:
                idx_ddl += f" WHERE {idx_where}"
            idx_ddl += ";"
            ddl_parts.append(f"\n{idx_ddl}")

        return "\n".join(ddl_parts)

# ä½¿ç”¨ç¤ºä¾‹
def generate_users_table():
    """ç”Ÿæˆç”¨æˆ·è¡¨DDL"""
    table = Table(
        name="users",
        columns=[
            Column("user_id", DataType.BIGSERIAL, nullable=False, comment="ç”¨æˆ·ID"),
            Column("username", DataType.VARCHAR, nullable=False, unique=True, comment="ç”¨æˆ·å"),
            Column("email", DataType.VARCHAR, nullable=False, unique=True, comment="é‚®ç®±"),
            Column("password_hash", DataType.TEXT, nullable=False, comment="å¯†ç å“ˆå¸Œ"),
            Column("is_active", DataType.BOOLEAN, default="TRUE", comment="æ˜¯å¦æ¿€æ´»"),
            Column("created_at", DataType.TIMESTAMPTZ, default="CURRENT_TIMESTAMP", comment="åˆ›å»ºæ—¶é—´"),
            Column("updated_at", DataType.TIMESTAMPTZ, default="CURRENT_TIMESTAMP", comment="æ›´æ–°æ—¶é—´")
        ],
        primary_key=["user_id"],
        indexes=[
            {"columns": ["username"], "type": "BTREE"},
            {"columns": ["email"], "type": "BTREE"},
            {"columns": ["is_active"], "type": "BTREE", "where": "is_active = TRUE"}
        ],
        comment="ç”¨æˆ·è¡¨ï¼Œå­˜å‚¨æ‰€æœ‰æ³¨å†Œç”¨æˆ·ä¿¡æ¯"
    )
    return table.to_ddl()

if __name__ == "__main__":
    print(generate_users_table())
```

### 3.2. SQLæ¨¡æ¿åº“

**å¸¸ç”¨è¡¨æ¨¡æ¿**ï¼š

```sql
-- ============================================
-- åŸºç¡€è¡¨æ¨¡æ¿ï¼ˆå¸¦å®¡è®¡å­—æ®µï¼‰
-- ============================================
CREATE TABLE {table_name} (
    {table_name}_id BIGSERIAL PRIMARY KEY,
    -- ä¸šåŠ¡å­—æ®µ
    {business_columns}
    -- å®¡è®¡å­—æ®µ
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_by BIGINT REFERENCES users(user_id),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_by BIGINT REFERENCES users(user_id),
    deleted_at TIMESTAMPTZ NULL,
    version INTEGER NOT NULL DEFAULT 1
);

-- åˆ›å»ºæ›´æ–°æ—¶é—´è§¦å‘å™¨
CREATE TRIGGER update_{table_name}_updated_at
BEFORE UPDATE ON {table_name}
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- åˆ›å»ºè½¯åˆ é™¤ç´¢å¼•
CREATE INDEX idx_{table_name}_deleted_at
ON {table_name}(deleted_at)
WHERE deleted_at IS NULL;

-- ============================================
-- å…³è”è¡¨æ¨¡æ¿
-- ============================================
CREATE TABLE {table1}_{table2} (
    {table1}_id BIGINT NOT NULL REFERENCES {table1}({table1}_id) ON DELETE CASCADE,
    {table2}_id BIGINT NOT NULL REFERENCES {table2}({table2}_id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY ({table1}_id, {table2}_id)
);

CREATE INDEX idx_{table1}_{table2}_{table1} ON {table1}_{table2}({table1}_id);
CREATE INDEX idx_{table1}_{table2}_{table2} ON {table1}_{table2}({table2}_id);

-- ============================================
-- æ—¥å¿—è¡¨æ¨¡æ¿
-- ============================================
CREATE TABLE {table_name}_logs (
    log_id BIGSERIAL PRIMARY KEY,
    {table_name}_id BIGINT NOT NULL REFERENCES {table_name}({table_name}_id),
    action VARCHAR(20) NOT NULL CHECK (action IN ('INSERT', 'UPDATE', 'DELETE')),
    old_data JSONB,
    new_data JSONB,
    changed_fields TEXT[],
    changed_by BIGINT REFERENCES users(user_id),
    changed_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
) PARTITION BY RANGE (changed_at);

CREATE INDEX idx_{table_name}_logs_{table_name}_id
ON {table_name}_logs({table_name}_id, changed_at DESC);
```

---

## 4. æ•°æ®åº“è®¾è®¡æ¨¡æ¿

### 4.1. ç”¨æˆ·è®¤è¯ç³»ç»Ÿæ¨¡æ¿

**å®Œæ•´çš„ç”¨æˆ·è®¤è¯ç³»ç»ŸSchema**ï¼š

```sql
-- ============================================
-- ç”¨æˆ·è®¤è¯ç³»ç»Ÿæ¨¡æ¿
-- ============================================

-- ç”¨æˆ·è¡¨
CREATE TABLE users (
    user_id BIGSERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL UNIQUE,
    password_hash TEXT NOT NULL,
    email_verified BOOLEAN DEFAULT FALSE,
    is_active BOOLEAN DEFAULT TRUE,
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_active ON users(user_id) WHERE is_active = TRUE;

-- è§’è‰²è¡¨
CREATE TABLE roles (
    role_id SERIAL PRIMARY KEY,
    role_name VARCHAR(50) NOT NULL UNIQUE,
    description TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- ç”¨æˆ·è§’è‰²å…³è”è¡¨
CREATE TABLE user_roles (
    user_id BIGINT NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    role_id INTEGER NOT NULL REFERENCES roles(role_id) ON DELETE CASCADE,
    assigned_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    assigned_by BIGINT REFERENCES users(user_id),
    PRIMARY KEY (user_id, role_id)
);

CREATE INDEX idx_user_roles_user ON user_roles(user_id);
CREATE INDEX idx_user_roles_role ON user_roles(role_id);

-- æƒé™è¡¨
CREATE TABLE permissions (
    permission_id SERIAL PRIMARY KEY,
    permission_name VARCHAR(100) NOT NULL UNIQUE,
    resource VARCHAR(100) NOT NULL,
    action VARCHAR(50) NOT NULL,
    description TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- è§’è‰²æƒé™å…³è”è¡¨
CREATE TABLE role_permissions (
    role_id INTEGER NOT NULL REFERENCES roles(role_id) ON DELETE CASCADE,
    permission_id INTEGER NOT NULL REFERENCES permissions(permission_id) ON DELETE CASCADE,
    PRIMARY KEY (role_id, permission_id)
);

-- ä¼šè¯è¡¨
CREATE TABLE sessions (
    session_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id BIGINT NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    token_hash TEXT NOT NULL,
    expires_at TIMESTAMPTZ NOT NULL,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    last_accessed_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_sessions_user ON sessions(user_id);
CREATE INDEX idx_sessions_expires ON sessions(expires_at);
CREATE INDEX idx_sessions_token ON sessions(token_hash);

-- å¯†ç é‡ç½®ä»¤ç‰Œè¡¨
CREATE TABLE password_reset_tokens (
    token_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    token_hash TEXT NOT NULL UNIQUE,
    expires_at TIMESTAMPTZ NOT NULL,
    used_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_password_reset_tokens_user ON password_reset_tokens(user_id);
CREATE INDEX idx_password_reset_tokens_token ON password_reset_tokens(token_hash);
CREATE INDEX idx_password_reset_tokens_expires ON password_reset_tokens(expires_at);
```

### 4.2. å¤šç§Ÿæˆ·ç³»ç»Ÿæ¨¡æ¿

**å¤šç§Ÿæˆ·ç³»ç»ŸSchemaæ¨¡æ¿**ï¼š

```sql
-- ============================================
-- å¤šç§Ÿæˆ·ç³»ç»Ÿæ¨¡æ¿
-- ============================================

-- ç§Ÿæˆ·è¡¨
CREATE TABLE tenants (
    tenant_id BIGSERIAL PRIMARY KEY,
    tenant_name VARCHAR(200) NOT NULL,
    tenant_slug VARCHAR(100) NOT NULL UNIQUE,
    domain VARCHAR(200),
    plan VARCHAR(50) NOT NULL CHECK (plan IN ('free', 'basic', 'premium', 'enterprise')),
    is_active BOOLEAN DEFAULT TRUE,
    subscription_expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_tenants_slug ON tenants(tenant_slug);
CREATE INDEX idx_tenants_domain ON tenants(domain);
CREATE INDEX idx_tenants_active ON tenants(tenant_id) WHERE is_active = TRUE;

-- ç§Ÿæˆ·ç”¨æˆ·å…³è”è¡¨
CREATE TABLE tenant_users (
    tenant_id BIGINT NOT NULL REFERENCES tenants(tenant_id) ON DELETE CASCADE,
    user_id BIGINT NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    role VARCHAR(50) NOT NULL CHECK (role IN ('owner', 'admin', 'member', 'viewer')),
    joined_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (tenant_id, user_id)
);

CREATE INDEX idx_tenant_users_tenant ON tenant_users(tenant_id);
CREATE INDEX idx_tenant_users_user ON tenant_users(user_id);

-- å¤šç§Ÿæˆ·æ•°æ®è¡¨æ¨¡æ¿ï¼ˆæ·»åŠ tenant_idï¼‰
CREATE TABLE {table_name} (
    {table_name}_id BIGSERIAL PRIMARY KEY,
    tenant_id BIGINT NOT NULL REFERENCES tenants(tenant_id) ON DELETE CASCADE,
    -- ä¸šåŠ¡å­—æ®µ
    {business_columns}
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºç§Ÿæˆ·éš”ç¦»ç´¢å¼•
CREATE INDEX idx_{table_name}_tenant ON {table_name}(tenant_id);
CREATE INDEX idx_{table_name}_tenant_created ON {table_name}(tenant_id, created_at DESC);

-- è¡Œçº§å®‰å…¨ç­–ç•¥ï¼ˆPostgreSQLï¼‰
ALTER TABLE {table_name} ENABLE ROW LEVEL SECURITY;

CREATE POLICY {table_name}_tenant_isolation ON {table_name}
    FOR ALL
    TO application_user
    USING (tenant_id = current_setting('app.current_tenant_id')::BIGINT);
```

---

## 5. ä»£ç ç”Ÿæˆå·¥å…·

### 5.1. Pythonæ¨¡å‹ç”Ÿæˆå™¨

**ä»æ•°æ®åº“Schemaç”ŸæˆPythonæ¨¡å‹**ï¼š

```python
"""
ä»PostgreSQL Schemaç”ŸæˆPython SQLAlchemyæ¨¡å‹
"""

import re
from typing import List, Dict

def generate_sqlalchemy_model(table_name: str, columns: List[Dict]) -> str:
    """ç”ŸæˆSQLAlchemyæ¨¡å‹ä»£ç """

    model_class_name = ''.join(word.capitalize() for word in table_name.split('_'))

    lines = [
        f"from sqlalchemy import Column, Integer, String, Boolean, DateTime, ForeignKey, Text, Numeric",
        f"from sqlalchemy.ext.declarative import declarative_base",
        f"from sqlalchemy.orm import relationship",
        f"from datetime import datetime",
        "",
        "Base = declarative_base()",
        "",
        f"class {model_class_name}(Base):",
        f'    __tablename__ = "{table_name}"',
        ""
    ]

    # ç”Ÿæˆåˆ—å®šä¹‰
    for col in columns:
        col_name = col['name']
        col_type = col['type']
        nullable = col.get('nullable', True)
        default = col.get('default')
        primary_key = col.get('primary_key', False)
        foreign_key = col.get('foreign_key')

        # ç±»å‹æ˜ å°„
        type_mapping = {
            'BIGSERIAL': 'Integer',
            'BIGINT': 'Integer',
            'INTEGER': 'Integer',
            'VARCHAR': 'String',
            'TEXT': 'Text',
            'DECIMAL': 'Numeric',
            'BOOLEAN': 'Boolean',
            'TIMESTAMP': 'DateTime',
            'TIMESTAMPTZ': 'DateTime',
            'JSONB': 'JSON'
        }

        sqlalchemy_type = type_mapping.get(col_type, 'String')

        # æ„å»ºåˆ—å®šä¹‰
        col_def = f"    {col_name} = Column("
        col_def += f"{sqlalchemy_type}"

        if not nullable:
            col_def += ", nullable=False"

        if primary_key:
            col_def += ", primary_key=True"

        if default:
            if default == 'CURRENT_TIMESTAMP':
                col_def += ", default=datetime.utcnow"
            else:
                col_def += f", default={default}"

        if foreign_key:
            col_def += f", ForeignKey('{foreign_key}')"

        col_def += ")"
        lines.append(col_def)

    lines.append("")
    lines.append("    def __repr__(self):")
    lines.append(f'        return f"<{model_class_name}(id={{self.{table_name}_id}})>"')

    return "\n".join(lines)

# ä½¿ç”¨ç¤ºä¾‹
columns = [
    {"name": "user_id", "type": "BIGSERIAL", "nullable": False, "primary_key": True},
    {"name": "username", "type": "VARCHAR", "nullable": False, "default": None},
    {"name": "email", "type": "VARCHAR", "nullable": False, "default": None},
    {"name": "created_at", "type": "TIMESTAMPTZ", "nullable": False, "default": "CURRENT_TIMESTAMP"}
]

print(generate_sqlalchemy_model("users", columns))
```

---

## 6. æ•°æ®åº“è®¾è®¡å·¥å…·

### 6.1. SchemaéªŒè¯å·¥å…·

**SchemaéªŒè¯å‡½æ•°**ï¼š

```sql
-- ============================================
-- SchemaéªŒè¯å·¥å…·
-- ============================================

-- æ£€æŸ¥è¡¨æ˜¯å¦æœ‰ä¸»é”®
CREATE OR REPLACE FUNCTION check_table_has_primary_key(p_table_name TEXT)
RETURNS BOOLEAN AS $$
DECLARE
    v_has_pk BOOLEAN;
BEGIN
    SELECT EXISTS(
        SELECT 1
        FROM information_schema.table_constraints
        WHERE table_schema = 'public'
          AND table_name = p_table_name
          AND constraint_type = 'PRIMARY KEY'
    ) INTO v_has_pk;

    RETURN v_has_pk;
END;
$$ LANGUAGE plpgsql;

-- æ£€æŸ¥å¤–é”®æ˜¯å¦æœ‰ç´¢å¼•
CREATE OR REPLACE FUNCTION check_foreign_keys_have_indexes()
RETURNS TABLE (
    table_name TEXT,
    constraint_name TEXT,
    columns TEXT,
    has_index BOOLEAN
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        tc.table_name::TEXT,
        tc.constraint_name::TEXT,
        string_agg(kcu.column_name, ', ' ORDER BY kcu.ordinal_position)::TEXT AS columns,
        EXISTS(
            SELECT 1
            FROM pg_indexes pi
            WHERE pi.tablename = tc.table_name
              AND pi.indexdef LIKE '%' || kcu.column_name || '%'
        ) AS has_index
    FROM information_schema.table_constraints tc
    JOIN information_schema.key_column_usage kcu
        ON tc.constraint_name = kcu.constraint_name
    WHERE tc.constraint_type = 'FOREIGN KEY'
      AND tc.table_schema = 'public'
    GROUP BY tc.table_name, tc.constraint_name
    ORDER BY tc.table_name;
END;
$$ LANGUAGE plpgsql;

-- æ£€æŸ¥è¡¨æ˜¯å¦æœ‰æ³¨é‡Š
CREATE OR REPLACE FUNCTION check_tables_have_comments()
RETURNS TABLE (
    table_name TEXT,
    has_comment BOOLEAN,
    comment TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        t.table_name::TEXT,
        (obj_description(c.oid, 'pg_class') IS NOT NULL) AS has_comment,
        COALESCE(obj_description(c.oid, 'pg_class'), '')::TEXT AS comment
    FROM information_schema.tables t
    JOIN pg_class c ON c.relname = t.table_name
    WHERE t.table_schema = 'public'
      AND t.table_type = 'BASE TABLE'
    ORDER BY t.table_name;
END;
$$ LANGUAGE plpgsql;
```

### 6.2. æ•°æ®åº“æ–‡æ¡£ç”Ÿæˆå·¥å…·

**è‡ªåŠ¨ç”Ÿæˆæ•°æ®åº“æ–‡æ¡£**ï¼š

```sql
-- ============================================
-- æ•°æ®åº“æ–‡æ¡£ç”Ÿæˆå·¥å…·
-- ============================================

-- ç”Ÿæˆè¡¨æ–‡æ¡£
CREATE OR REPLACE FUNCTION generate_table_documentation(p_table_name TEXT)
RETURNS TEXT AS $$
DECLARE
    v_doc TEXT;
    v_table_comment TEXT;
BEGIN
    -- è·å–è¡¨æ³¨é‡Š
    SELECT obj_description(c.oid, 'pg_class')
    INTO v_table_comment
    FROM pg_class c
    WHERE c.relname = p_table_name;

    v_doc := format('## %s\n\n', p_table_name);

    IF v_table_comment IS NOT NULL THEN
        v_doc := v_doc || format('%s\n\n', v_table_comment);
    END IF;

    -- æ·»åŠ åˆ—ä¿¡æ¯
    v_doc := v_doc || '### åˆ—ä¿¡æ¯\n\n';
    v_doc := v_doc || '| åˆ—å | ç±»å‹ | å¯ç©º | é»˜è®¤å€¼ | è¯´æ˜ |\n';
    v_doc := v_doc || '|------|------|------|--------|------|\n';

    FOR rec IN
        SELECT
            c.column_name,
            c.data_type,
            c.is_nullable,
            c.column_default,
            col_description(a.attrelid, a.attnum) AS column_comment
        FROM information_schema.columns c
        JOIN pg_attribute a ON a.attname = c.column_name
        JOIN pg_class pc ON pc.oid = a.attrelid
        WHERE c.table_name = p_table_name
          AND c.table_schema = 'public'
        ORDER BY c.ordinal_position
    LOOP
        v_doc := v_doc || format(
            '| %s | %s | %s | %s | %s |\n',
            rec.column_name,
            rec.data_type,
            rec.is_nullable,
            COALESCE(rec.column_default, '-'),
            COALESCE(rec.column_comment, '-')
        );
    END LOOP;

    RETURN v_doc;
END;
$$ LANGUAGE plpgsql;
```

---

## 7. 2024-2025æ–°å¢å·¥å…·

### 7.1. AIè¾…åŠ©è®¾è®¡å·¥å…·

```mermaid
flowchart TB
    subgraph AIè®¾è®¡åŠ©æ‰‹
        A1[éœ€æ±‚åˆ†æ]
        A2[Schemaç”Ÿæˆ]
        A3[SQLä¼˜åŒ–]
        A4[æ–‡æ¡£ç”Ÿæˆ]
    end

    subgraph å·¥å…·é“¾
        T1[ChatGPT/Claude]
        T2[GitHub Copilot]
        T3[Cursor AI]
        T4[ä¸“ç”¨MCPå·¥å…·]
    end

    A1 --> T1
    A2 --> T2
    A3 --> T3
    A4 --> T4
```

### 7.2. ç°ä»£è®¾è®¡å·¥å…·å¯¹æ¯”

| å·¥å…·ç±»åˆ« | å·¥å…·åç§° | ç‰¹ç‚¹ | é€‚ç”¨åœºæ™¯ |
|---------|---------|------|---------|
| **å¯è§†åŒ–å»ºæ¨¡** | dbdiagram.io | åœ¨çº¿ã€ä»£ç é©±åŠ¨ | å¿«é€Ÿå»ºæ¨¡ |
| **å¯è§†åŒ–å»ºæ¨¡** | pgModeler | å¼€æºã€åŠŸèƒ½å…¨é¢ | PostgreSQL |
| **è¿ç§»ç®¡ç†** | Flyway | Javaç”Ÿæ€ã€ç‰ˆæœ¬æ§åˆ¶ | ä¼ä¸šçº§ |
| **è¿ç§»ç®¡ç†** | Alembic | Pythonç”Ÿæ€ã€SQLAlchemy | Pythoné¡¹ç›® |
| **æ–‡æ¡£ç”Ÿæˆ** | SchemaSpy | è‡ªåŠ¨ç”ŸæˆERå›¾ | æ–‡æ¡£åŒ– |
| **AIè¾…åŠ©** | AI2sql | è‡ªç„¶è¯­è¨€è½¬SQL | å¿«é€Ÿå¼€å‘ |

### 7.3. MCPæ•°æ®åº“å·¥å…·

```python
# MCPæ•°æ®åº“è®¾è®¡å·¥å…·ç¤ºä¾‹
from mcp.server import Server
from mcp.types import Tool, TextContent

server = Server("db-design-tools")

@server.tool("analyze_schema")
async def analyze_schema(schema_sql: str) -> TextContent:
    """åˆ†æSchemaè®¾è®¡è´¨é‡"""
    issues = []

    # æ£€æŸ¥å‘½åè§„èŒƒ
    if not all(name.islower() for name in extract_table_names(schema_sql)):
        issues.append("è¡¨ååº”ä½¿ç”¨å°å†™")

    # æ£€æŸ¥ä¸»é”®
    if "PRIMARY KEY" not in schema_sql.upper():
        issues.append("ç¼ºå°‘ä¸»é”®å®šä¹‰")

    # æ£€æŸ¥ç´¢å¼•
    if "CREATE INDEX" not in schema_sql.upper():
        issues.append("å»ºè®®æ·»åŠ ç´¢å¼•")

    return TextContent(
        type="text",
        text=f"åˆ†æç»“æœï¼š\n" + "\n".join(issues) if issues else "Schemaè®¾è®¡ç¬¦åˆè§„èŒƒ"
    )

@server.tool("generate_ddl")
async def generate_ddl(table_spec: dict) -> TextContent:
    """æ ¹æ®è§„æ ¼ç”ŸæˆDDL"""
    ddl = f"CREATE TABLE {table_spec['name']} (\n"
    columns = []
    for col in table_spec['columns']:
        col_def = f"    {col['name']} {col['type']}"
        if col.get('not_null'):
            col_def += " NOT NULL"
        if col.get('default'):
            col_def += f" DEFAULT {col['default']}"
        columns.append(col_def)
    ddl += ",\n".join(columns)
    ddl += "\n);"
    return TextContent(type="text", text=ddl)
```

---

## 8. å‚è€ƒèµ„æ–™

### 8.1. åœ¨çº¿èµ„æº

| èµ„æº | URL | æè¿° |
|------|-----|------|
| **dbdiagram.io** | <https://dbdiagram.io> | åœ¨çº¿ERå»ºæ¨¡ |
| **pgModeler** | <https://pgmodeler.io> | PostgreSQLå»ºæ¨¡ |
| **Flyway** | <https://flywaydb.org> | æ•°æ®åº“è¿ç§» |
| **SchemaSpy** | <https://schemaspy.org> | æ–‡æ¡£ç”Ÿæˆ |

### 8.2. ç›¸å…³æ–‡æ¡£

- [07.01-Schemaè®¾è®¡æ–¹æ³•è®º](./07.01-Schemaè®¾è®¡æ–¹æ³•è®º.md)
- [07.14-æ•°æ®åº“è®¾è®¡æœ€ä½³å®è·µåº“](./07.14-æ•°æ®åº“è®¾è®¡æœ€ä½³å®è·µåº“.md)
- [07.06-æ•°æ®åº“è®¾è®¡åæ¨¡å¼ä¸è§£å†³æ–¹æ¡ˆ](./07.06-æ•°æ®åº“è®¾è®¡åæ¨¡å¼ä¸è§£å†³æ–¹æ¡ˆ.md)

---

**æœ€åæ›´æ–°**ï¼š2025-12-01
**ç»´æŠ¤è€…**ï¼šData-Science Team
**çŠ¶æ€**ï¼šå·²å®Œæˆ âœ…
**ç‰ˆæœ¬**ï¼šv2.0 (å¢å¼ºç‰ˆ)
