# å‘é‡æ•°æ®åº“è®¾è®¡ï¼šEmbeddingå­˜å‚¨ä¸ç›¸ä¼¼åº¦æ£€ç´¢

> **åˆ›å»ºæ—¥æœŸ**ï¼š2025-01-15
> **æœ€åæ›´æ–°**ï¼š2025-01-15
> **ç‰ˆæœ¬**ï¼šv1.0
> **çŠ¶æ€**ï¼šå®æ–½ä¸­

---

## ğŸ“‹ ç›®å½•

- [å‘é‡æ•°æ®åº“è®¾è®¡ï¼šEmbeddingå­˜å‚¨ä¸ç›¸ä¼¼åº¦æ£€ç´¢](#å‘é‡æ•°æ®åº“è®¾è®¡embeddingå­˜å‚¨ä¸ç›¸ä¼¼åº¦æ£€ç´¢)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1. å‘é‡æ•°æ®åº“åº”ç”¨åœºæ™¯](#11-å‘é‡æ•°æ®åº“åº”ç”¨åœºæ™¯)
    - [1.2. å‘é‡æ•°æ®åº“é€‰æ‹©å†³ç­–æ ‘](#12-å‘é‡æ•°æ®åº“é€‰æ‹©å†³ç­–æ ‘)
  - [2. å‘é‡æ•°æ®åº“åŸºç¡€](#2-å‘é‡æ•°æ®åº“åŸºç¡€)
    - [2.1. å‘é‡EmbeddingåŸºç¡€](#21-å‘é‡embeddingåŸºç¡€)
    - [2.2. ç›¸ä¼¼åº¦åº¦é‡](#22-ç›¸ä¼¼åº¦åº¦é‡)
  - [3. å‘é‡ç´¢å¼•è®¾è®¡](#3-å‘é‡ç´¢å¼•è®¾è®¡)
    - [3.1. HNSWç´¢å¼•ï¼ˆPostgreSQL pgvectorï¼‰](#31-hnswç´¢å¼•postgresql-pgvector)
    - [3.2. IVFFlatç´¢å¼•](#32-ivfflatç´¢å¼•)
    - [3.3. ç´¢å¼•æ€§èƒ½å¯¹æ¯”](#33-ç´¢å¼•æ€§èƒ½å¯¹æ¯”)
  - [4. æ··åˆæ£€ç´¢è®¾è®¡](#4-æ··åˆæ£€ç´¢è®¾è®¡)
    - [4.1. å‘é‡+å…³é”®è¯æ··åˆæ£€ç´¢](#41-å‘é‡å…³é”®è¯æ··åˆæ£€ç´¢)
    - [4.2. RRFï¼ˆReciprocal Rank Fusionï¼‰èåˆ](#42-rrfreciprocal-rank-fusionèåˆ)
  - [5. RAGç³»ç»Ÿè®¾è®¡](#5-ragç³»ç»Ÿè®¾è®¡)
    - [5.1. RAGçŸ¥è¯†åº“Schemaè®¾è®¡](#51-ragçŸ¥è¯†åº“schemaè®¾è®¡)
    - [5.2. RAGæ£€ç´¢æµç¨‹](#52-ragæ£€ç´¢æµç¨‹)
    - [5.3. ä¸Šä¸‹æ–‡çª—å£æ„å»º](#53-ä¸Šä¸‹æ–‡çª—å£æ„å»º)
  - [6. å‘é‡æ•°æ®åº“Schemaè®¾è®¡](#6-å‘é‡æ•°æ®åº“schemaè®¾è®¡)
    - [6.1. å¤šæ¨¡æ€å‘é‡å­˜å‚¨](#61-å¤šæ¨¡æ€å‘é‡å­˜å‚¨)
    - [6.2. å‘é‡ç‰ˆæœ¬ç®¡ç†](#62-å‘é‡ç‰ˆæœ¬ç®¡ç†)
  - [7. æ€§èƒ½ä¼˜åŒ–](#7-æ€§èƒ½ä¼˜åŒ–)
    - [7.1. ç´¢å¼•å‚æ•°è°ƒä¼˜](#71-ç´¢å¼•å‚æ•°è°ƒä¼˜)
    - [7.2. æ‰¹é‡æ’å…¥ä¼˜åŒ–](#72-æ‰¹é‡æ’å…¥ä¼˜åŒ–)
    - [7.3. å‘é‡å‹ç¼©](#73-å‘é‡å‹ç¼©)
  - [8. å‚è€ƒèµ„æ–™](#8-å‚è€ƒèµ„æ–™)

---

## 1. æ¦‚è¿°

å‘é‡æ•°æ®åº“æ˜¯AIæ—¶ä»£çš„å…³é”®åŸºç¡€è®¾æ–½ï¼Œç”¨äºå­˜å‚¨å’Œæ£€ç´¢é«˜ç»´å‘é‡ï¼ˆEmbeddingï¼‰ï¼Œæ”¯æŒè¯­ä¹‰æœç´¢ã€æ¨èç³»ç»Ÿã€RAGç­‰åº”ç”¨ã€‚

### 1.1. å‘é‡æ•°æ®åº“åº”ç”¨åœºæ™¯

```mermaid
mindmap
  root((å‘é‡æ•°æ®åº“åº”ç”¨))
    è¯­ä¹‰æœç´¢
      æ–‡æ¡£æ£€ç´¢
      å›¾åƒæœç´¢
      è§†é¢‘æ£€ç´¢
    æ¨èç³»ç»Ÿ
      å•†å“æ¨è
      å†…å®¹æ¨è
      ç”¨æˆ·æ¨è
    RAGç³»ç»Ÿ
      çŸ¥è¯†åº“æ£€ç´¢
      ä¸Šä¸‹æ–‡å¢å¼º
      é—®ç­”ç³»ç»Ÿ
    AIåº”ç”¨
      ç›¸ä¼¼åº¦åŒ¹é…
      èšç±»åˆ†æ
      å¼‚å¸¸æ£€æµ‹
```

### 1.2. å‘é‡æ•°æ®åº“é€‰æ‹©å†³ç­–æ ‘

```mermaid
flowchart TD
    A[é€‰æ‹©å‘é‡æ•°æ®åº“] --> B{æ•°æ®è§„æ¨¡}

    B -->|å°è§„æ¨¡| C{é›†æˆéœ€æ±‚}
    B -->|å¤§è§„æ¨¡| D{æ€§èƒ½è¦æ±‚}

    C -->|PostgreSQLé›†æˆ| E[pgvector]
    C -->|ç‹¬ç«‹éƒ¨ç½²| F[Qdrant/Milvus]

    D -->|é«˜æ€§èƒ½| G[Pinecone/Weaviate]
    D -->|å¼€æº| H[Milvus/Qdrant]

    E --> I[è®¾è®¡å®Œæˆ]
    F --> I
    G --> I
    H --> I
```

---

## 2. å‘é‡æ•°æ®åº“åŸºç¡€

### 2.1. å‘é‡EmbeddingåŸºç¡€

**å‘é‡Embeddingå®šä¹‰**ï¼š

```text
ç»™å®šæ–‡æ¡£é›†åˆ D = {dâ‚, dâ‚‚, ..., dâ‚™}ï¼Œ
Embeddingå‡½æ•° f: D â†’ â„áµˆ å°†æ–‡æ¡£æ˜ å°„åˆ°dç»´å‘é‡ç©ºé—´ã€‚

æ€§è´¨ï¼š
1. è¯­ä¹‰ç›¸ä¼¼æ€§ï¼šç›¸ä¼¼æ–‡æ¡£çš„å‘é‡è·ç¦»è¿‘
2. ç»´åº¦å›ºå®šï¼šæ‰€æœ‰å‘é‡ç»´åº¦ç›¸åŒ
3. å½’ä¸€åŒ–ï¼šé€šå¸¸L2å½’ä¸€åŒ–ï¼Œ||v|| = 1
```

**å¸¸è§Embeddingæ¨¡å‹**ï¼š

| æ¨¡å‹ | ç»´åº¦ | ç‰¹ç‚¹ | é€‚ç”¨åœºæ™¯ |
|------|------|------|---------|
| **OpenAI text-embedding-ada-002** | 1536 | é€šç”¨æ–‡æœ¬ | æ–‡æ¡£æ£€ç´¢ã€è¯­ä¹‰æœç´¢ |
| **sentence-transformers** | 384-768 | å¤šè¯­è¨€æ”¯æŒ | å¤šè¯­è¨€æ£€ç´¢ |
| **BGE (BAAI)** | 768-1024 | ä¸­æ–‡ä¼˜åŒ– | ä¸­æ–‡è¯­ä¹‰æœç´¢ |
| **Cohere embed** | 1024 | é•¿æ–‡æœ¬ä¼˜åŒ– | é•¿æ–‡æ¡£æ£€ç´¢ |
| **Image Embeddings** | 512-2048 | å›¾åƒç‰¹å¾ | å›¾åƒæœç´¢ |

### 2.2. ç›¸ä¼¼åº¦åº¦é‡

**ä½™å¼¦ç›¸ä¼¼åº¦**ï¼ˆæœ€å¸¸ç”¨ï¼‰ï¼š

```sql
-- PostgreSQL pgvector
SELECT
    id,
    content,
    1 - (embedding <=> query_embedding) AS cosine_similarity
FROM documents
ORDER BY embedding <=> query_embedding
LIMIT 10;
```

**æ¬§æ°è·ç¦»**ï¼š

```sql
SELECT
    id,
    content,
    embedding <-> query_embedding AS euclidean_distance
FROM documents
ORDER BY embedding <-> query_embedding
LIMIT 10;
```

**ç‚¹ç§¯**ï¼ˆå½’ä¸€åŒ–å‘é‡ï¼‰ï¼š

```sql
SELECT
    id,
    content,
    embedding <#> query_embedding AS negative_dot_product
FROM documents
ORDER BY embedding <#> query_embedding
LIMIT 10;
```

---

## 3. å‘é‡ç´¢å¼•è®¾è®¡

### 3.1. HNSWç´¢å¼•ï¼ˆPostgreSQL pgvectorï¼‰

**HNSWï¼ˆHierarchical Navigable Small Worldï¼‰**ï¼šå¤šå±‚å›¾ç´¢å¼•ç»“æ„ã€‚

```sql
-- åˆ›å»ºå‘é‡è¡¨
CREATE TABLE document_embeddings (
    id BIGSERIAL PRIMARY KEY,
    document_id BIGINT NOT NULL,
    content TEXT NOT NULL,
    embedding vector(1536) NOT NULL,  -- OpenAI ada-002ç»´åº¦
    metadata JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºHNSWç´¢å¼•
CREATE INDEX idx_document_embeddings_hnsw
ON document_embeddings
USING hnsw (embedding vector_cosine_ops)
WITH (m = 16, ef_construction = 64);

-- æŸ¥è¯¢å‚æ•°è¯´æ˜ï¼š
-- m: æ¯ä¸ªèŠ‚ç‚¹çš„æœ€å¤§è¿æ¥æ•°ï¼ˆé»˜è®¤16ï¼‰
-- ef_construction: æ„å»ºæ—¶çš„æœç´¢å®½åº¦ï¼ˆé»˜è®¤64ï¼‰
-- ef_search: æŸ¥è¯¢æ—¶çš„æœç´¢å®½åº¦ï¼ˆé»˜è®¤40ï¼ŒæŸ¥è¯¢æ—¶è®¾ç½®ï¼‰
```

**ç´¢å¼•é€‰æ‹©å†³ç­–æ ‘**ï¼š

```mermaid
flowchart TD
    A[é€‰æ‹©å‘é‡ç´¢å¼•] --> B{æ•°æ®è§„æ¨¡}

    B -->|å°è§„æ¨¡<100ä¸‡| C[IVFFlat]
    B -->|å¤§è§„æ¨¡>100ä¸‡| D{HNSW}

    C --> E[å¿«é€Ÿæ„å»º]
    D --> F[é«˜æ€§èƒ½æŸ¥è¯¢]

    E --> G[ç´¢å¼•åˆ›å»ºå®Œæˆ]
    F --> G
```

### 3.2. IVFFlatç´¢å¼•

**IVFFlatï¼ˆInverted File Indexï¼‰**ï¼šåŸºäºèšç±»çš„ç´¢å¼•ã€‚

```sql
-- åˆ›å»ºIVFFlatç´¢å¼•
CREATE INDEX idx_document_embeddings_ivfflat
ON document_embeddings
USING ivfflat (embedding vector_cosine_ops)
WITH (lists = 100);

-- listså‚æ•°ï¼šèšç±»ä¸­å¿ƒæ•°é‡
-- å»ºè®®ï¼šlists = rows / 1000ï¼ˆè‡³å°‘100ï¼‰
```

### 3.3. ç´¢å¼•æ€§èƒ½å¯¹æ¯”

| ç´¢å¼•ç±»å‹ | æ„å»ºé€Ÿåº¦ | æŸ¥è¯¢é€Ÿåº¦ | å†…å­˜å ç”¨ | é€‚ç”¨åœºæ™¯ |
|---------|---------|---------|---------|---------|
| **HNSW** | æ…¢ | å¿« | é«˜ | æŸ¥è¯¢é¢‘ç¹ï¼Œæ•°æ®é‡å¤§ |
| **IVFFlat** | å¿« | ä¸­ | ä½ | æ•°æ®é‡å¤§ï¼ŒæŸ¥è¯¢è¾ƒå°‘ |
| **æ— ç´¢å¼•** | - | æ…¢ | ä½ | å°æ•°æ®é›† |

---

## 4. æ··åˆæ£€ç´¢è®¾è®¡

### 4.1. å‘é‡+å…³é”®è¯æ··åˆæ£€ç´¢

**PostgreSQLå®ç°**ï¼š

```sql
-- åˆ›å»ºæ··åˆæ£€ç´¢è¡¨
CREATE TABLE hybrid_search_documents (
    id BIGSERIAL PRIMARY KEY,
    document_id BIGINT NOT NULL,
    title VARCHAR(500) NOT NULL,
    content TEXT NOT NULL,
    embedding vector(1536) NOT NULL,
    keywords TEXT[],  -- å…³é”®è¯æ•°ç»„
    category VARCHAR(50),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- å…¨æ–‡æœç´¢ç´¢å¼•
CREATE INDEX idx_hybrid_search_fts
ON hybrid_search_documents
USING GIN (to_tsvector('english', title || ' ' || content));

-- å‘é‡ç´¢å¼•
CREATE INDEX idx_hybrid_search_vector
ON hybrid_search_documents
USING hnsw (embedding vector_cosine_ops);

-- æ··åˆæ£€ç´¢æŸ¥è¯¢
WITH vector_results AS (
    SELECT
        id,
        document_id,
        title,
        content,
        1 - (embedding <=> $1::vector) AS vector_score
    FROM hybrid_search_documents
    ORDER BY embedding <=> $1::vector
    LIMIT 50
),
keyword_results AS (
    SELECT
        id,
        document_id,
        title,
        content,
        ts_rank(to_tsvector('english', title || ' ' || content),
                plainto_tsquery('english', $2)) AS keyword_score
    FROM hybrid_search_documents
    WHERE to_tsvector('english', title || ' ' || content)
          @@ plainto_tsquery('english', $2)
    ORDER BY keyword_score DESC
    LIMIT 50
),
combined_results AS (
    SELECT
        COALESCE(v.id, k.id) AS id,
        COALESCE(v.document_id, k.document_id) AS document_id,
        COALESCE(v.title, k.title) AS title,
        COALESCE(v.content, k.content) AS content,
        COALESCE(v.vector_score, 0) * 0.6 +
        COALESCE(k.keyword_score, 0) * 0.4 AS combined_score
    FROM vector_results v
    FULL OUTER JOIN keyword_results k ON v.id = k.id
)
SELECT
    id,
    document_id,
    title,
    LEFT(content, 200) AS content_preview,
    combined_score
FROM combined_results
ORDER BY combined_score DESC
LIMIT 10;
```

### 4.2. RRFï¼ˆReciprocal Rank Fusionï¼‰èåˆ

**RRFç®—æ³•**ï¼š

```sql
-- RRFèåˆå‡½æ•°
CREATE OR REPLACE FUNCTION rrf_fusion(
    vector_rank INTEGER,
    keyword_rank INTEGER,
    k INTEGER DEFAULT 60
)
RETURNS DECIMAL AS $$
BEGIN
    RETURN
        COALESCE(1.0 / (k + vector_rank), 0) +
        COALESCE(1.0 / (k + keyword_rank), 0);
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨RRFçš„æ··åˆæ£€ç´¢
WITH vector_ranked AS (
    SELECT
        id,
        ROW_NUMBER() OVER (ORDER BY embedding <=> $1::vector) AS rank
    FROM hybrid_search_documents
),
keyword_ranked AS (
    SELECT
        id,
        ROW_NUMBER() OVER (
            ORDER BY ts_rank(to_tsvector('english', title || ' ' || content),
                            plainto_tsquery('english', $2)) DESC
        ) AS rank
    FROM hybrid_search_documents
    WHERE to_tsvector('english', title || ' ' || content)
          @@ plainto_tsquery('english', $2)
)
SELECT
    h.id,
    h.title,
    h.content,
    rrf_fusion(v.rank, k.rank) AS rrf_score
FROM hybrid_search_documents h
LEFT JOIN vector_ranked v ON h.id = v.id
LEFT JOIN keyword_ranked k ON h.id = k.id
WHERE v.rank IS NOT NULL OR k.rank IS NOT NULL
ORDER BY rrf_score DESC
LIMIT 10;
```

---

## 5. RAGç³»ç»Ÿè®¾è®¡

### 5.1. RAGçŸ¥è¯†åº“Schemaè®¾è®¡

**å®Œæ•´RAGç³»ç»ŸSchema**ï¼š

```sql
CREATE SCHEMA rag_system;

-- æ–‡æ¡£æºè¡¨
CREATE TABLE rag_system.document_sources (
    source_id BIGSERIAL PRIMARY KEY,
    source_name VARCHAR(200) NOT NULL,
    source_type VARCHAR(50) NOT NULL,  -- file, url, database
    source_path TEXT,
    metadata JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- æ–‡æ¡£è¡¨
CREATE TABLE rag_system.documents (
    document_id BIGSERIAL PRIMARY KEY,
    source_id BIGINT REFERENCES rag_system.document_sources(source_id),
    title VARCHAR(500),
    content TEXT NOT NULL,
    content_hash VARCHAR(64) UNIQUE,  -- å†…å®¹å»é‡
    document_type VARCHAR(50),  -- pdf, markdown, html
    metadata JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_documents_source ON rag_system.documents(source_id);
CREATE INDEX idx_documents_hash ON rag_system.documents(content_hash);

-- æ–‡æ¡£å—è¡¨ï¼ˆChunkingï¼‰
CREATE TABLE rag_system.document_chunks (
    chunk_id BIGSERIAL PRIMARY KEY,
    document_id BIGINT NOT NULL REFERENCES rag_system.documents(document_id) ON DELETE CASCADE,
    chunk_index INTEGER NOT NULL,
    content TEXT NOT NULL,
    content_length INTEGER NOT NULL,
    embedding vector(1536),  -- OpenAI ada-002
    metadata JSONB,  -- åŒ…å«ä½ç½®ä¿¡æ¯ã€ä¸Šä¸‹æ–‡ç­‰
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(document_id, chunk_index)
);

-- å‘é‡ç´¢å¼•
CREATE INDEX idx_chunks_embedding_hnsw
ON rag_system.document_chunks
USING hnsw (embedding vector_cosine_ops)
WITH (m = 16, ef_construction = 64);

CREATE INDEX idx_chunks_document ON rag_system.document_chunks(document_id, chunk_index);

-- æŸ¥è¯¢å†å²è¡¨
CREATE TABLE rag_system.query_history (
    query_id BIGSERIAL PRIMARY KEY,
    query_text TEXT NOT NULL,
    query_embedding vector(1536),
    retrieved_chunks INTEGER[],
    response_text TEXT,
    metadata JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_query_history_created ON rag_system.query_history(created_at DESC);

-- æŸ¥è¯¢-æ–‡æ¡£å…³è”è¡¨ï¼ˆç”¨äºåé¦ˆå­¦ä¹ ï¼‰
CREATE TABLE rag_system.query_chunk_relevance (
    relevance_id BIGSERIAL PRIMARY KEY,
    query_id BIGINT REFERENCES rag_system.query_history(query_id),
    chunk_id BIGINT REFERENCES rag_system.document_chunks(chunk_id),
    relevance_score DECIMAL(3,2) CHECK (relevance_score >= 0 AND relevance_score <= 1),
    feedback_type VARCHAR(20),  -- positive, negative, neutral
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(query_id, chunk_id)
);

CREATE INDEX idx_relevance_query ON rag_system.query_chunk_relevance(query_id);
CREATE INDEX idx_relevance_chunk ON rag_system.query_chunk_relevance(chunk_id);
```

### 5.2. RAGæ£€ç´¢æµç¨‹

**æ£€ç´¢æµç¨‹å†³ç­–æ ‘**ï¼š

```mermaid
flowchart TD
    A[ç”¨æˆ·æŸ¥è¯¢] --> B[ç”ŸæˆQuery Embedding]
    B --> C[å‘é‡ç›¸ä¼¼åº¦æ£€ç´¢]
    C --> D[è·å–Top-K Chunks]

    D --> E{éœ€è¦é‡æ’åº?}
    E -->|æ˜¯| F[Cross-Encoderé‡æ’åº]
    E -->|å¦| G[è¿”å›ç»“æœ]

    F --> H[é‡æ–°æ’åº]
    H --> G

    G --> I[æ„å»ºä¸Šä¸‹æ–‡]
    I --> J[LLMç”Ÿæˆå›ç­”]
```

**RAGæ£€ç´¢å®ç°**ï¼š

```sql
-- RAGæ£€ç´¢å‡½æ•°
CREATE OR REPLACE FUNCTION rag_retrieve(
    p_query_embedding vector(1536),
    p_query_text TEXT,
    p_top_k INTEGER DEFAULT 10,
    p_similarity_threshold DECIMAL DEFAULT 0.7
)
RETURNS TABLE (
    chunk_id BIGINT,
    document_id BIGINT,
    content TEXT,
    similarity DECIMAL,
    metadata JSONB
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        c.chunk_id,
        c.document_id,
        c.content,
        1 - (c.embedding <=> p_query_embedding) AS similarity,
        c.metadata
    FROM rag_system.document_chunks c
    WHERE c.embedding IS NOT NULL
      AND 1 - (c.embedding <=> p_query_embedding) >= p_similarity_threshold
    ORDER BY c.embedding <=> p_query_embedding
    LIMIT p_top_k;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨ç¤ºä¾‹
SELECT * FROM rag_retrieve(
    (SELECT embedding FROM rag_system.query_history WHERE query_id = 1),
    'What is machine learning?',
    10,
    0.7
);
```

### 5.3. ä¸Šä¸‹æ–‡çª—å£æ„å»º

**ä¸Šä¸‹æ–‡æ„å»ºå‡½æ•°**ï¼š

```sql
-- æ„å»ºä¸Šä¸‹æ–‡çª—å£ï¼ˆåŒ…å«ç›¸é‚»chunksï¼‰
CREATE OR REPLACE FUNCTION build_context_window(
    p_chunk_ids BIGINT[],
    p_context_size INTEGER DEFAULT 2
)
RETURNS TABLE (
    chunk_id BIGINT,
    document_id BIGINT,
    chunk_index INTEGER,
    content TEXT,
    is_retrieved BOOLEAN
) AS $$
BEGIN
    RETURN QUERY
    WITH retrieved_chunks AS (
        SELECT
            chunk_id,
            document_id,
            chunk_index
        FROM rag_system.document_chunks
        WHERE chunk_id = ANY(p_chunk_ids)
    ),
    context_chunks AS (
        SELECT DISTINCT
            c.chunk_id,
            c.document_id,
            c.chunk_index,
            c.content,
            (c.chunk_id = ANY(p_chunk_ids)) AS is_retrieved
        FROM rag_system.document_chunks c
        JOIN retrieved_chunks r ON c.document_id = r.document_id
        WHERE c.chunk_index BETWEEN
            r.chunk_index - p_context_size AND
            r.chunk_index + p_context_size
    )
    SELECT
        chunk_id,
        document_id,
        chunk_index,
        content,
        is_retrieved
    FROM context_chunks
    ORDER BY document_id, chunk_index;
END;
$$ LANGUAGE plpgsql;
```

---

## 6. å‘é‡æ•°æ®åº“Schemaè®¾è®¡

### 6.1. å¤šæ¨¡æ€å‘é‡å­˜å‚¨

**æ”¯æŒæ–‡æœ¬ã€å›¾åƒã€éŸ³é¢‘ç­‰å¤šç§æ¨¡æ€**ï¼š

```sql
CREATE SCHEMA multimodal_vectors;

-- å¤šæ¨¡æ€å‘é‡è¡¨
CREATE TABLE multimodal_vectors.embeddings (
    embedding_id BIGSERIAL PRIMARY KEY,
    entity_id BIGINT NOT NULL,
    entity_type VARCHAR(50) NOT NULL,  -- text, image, audio, video
    modality VARCHAR(50) NOT NULL,  -- text_embedding, image_embedding, etc.
    embedding vector(1536) NOT NULL,
    model_name VARCHAR(100) NOT NULL,  -- ä½¿ç”¨çš„æ¨¡å‹åç§°
    original_content TEXT,  -- åŸå§‹å†…å®¹ï¼ˆæ–‡æœ¬ï¼‰æˆ–è·¯å¾„ï¼ˆåª’ä½“ï¼‰
    metadata JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- å¤šæ¨¡æ€ç´¢å¼•
CREATE INDEX idx_multimodal_embeddings_vector
ON multimodal_vectors.embeddings
USING hnsw (embedding vector_cosine_ops);

CREATE INDEX idx_multimodal_embeddings_entity
ON multimodal_vectors.embeddings(entity_type, entity_id);

-- è·¨æ¨¡æ€æ£€ç´¢
CREATE OR REPLACE FUNCTION cross_modal_search(
    p_query_embedding vector(1536),
    p_target_modality VARCHAR(50),
    p_top_k INTEGER DEFAULT 10
)
RETURNS TABLE (
    embedding_id BIGINT,
    entity_id BIGINT,
    entity_type VARCHAR(50),
    modality VARCHAR(50),
    similarity DECIMAL,
    original_content TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        e.embedding_id,
        e.entity_id,
        e.entity_type,
        e.modality,
        1 - (e.embedding <=> p_query_embedding) AS similarity,
        e.original_content
    FROM multimodal_vectors.embeddings e
    WHERE e.modality = p_target_modality
    ORDER BY e.embedding <=> p_query_embedding
    LIMIT p_top_k;
END;
$$ LANGUAGE plpgsql;
```

### 6.2. å‘é‡ç‰ˆæœ¬ç®¡ç†

**æ”¯æŒEmbeddingæ¨¡å‹ç‰ˆæœ¬ç®¡ç†**ï¼š

```sql
CREATE SCHEMA vector_versions;

-- å‘é‡ç‰ˆæœ¬è¡¨
CREATE TABLE vector_versions.embedding_versions (
    version_id BIGSERIAL PRIMARY KEY,
    entity_id BIGINT NOT NULL,
    model_name VARCHAR(100) NOT NULL,
    model_version VARCHAR(50) NOT NULL,
    embedding_dimension INTEGER NOT NULL,
    embedding vector NOT NULL,  -- åŠ¨æ€ç»´åº¦
    is_current BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(entity_id, model_name, model_version)
);

-- ç‰ˆæœ¬åˆ‡æ¢
CREATE OR REPLACE FUNCTION switch_embedding_version(
    p_entity_id BIGINT,
    p_model_name VARCHAR(100),
    p_target_version VARCHAR(50)
)
RETURNS VOID AS $$
BEGIN
    -- æ ‡è®°æ—§ç‰ˆæœ¬ä¸ºéå½“å‰
    UPDATE vector_versions.embedding_versions
    SET is_current = FALSE
    WHERE entity_id = p_entity_id
      AND model_name = p_model_name
      AND is_current = TRUE;

    -- æ ‡è®°æ–°ç‰ˆæœ¬ä¸ºå½“å‰
    UPDATE vector_versions.embedding_versions
    SET is_current = TRUE
    WHERE entity_id = p_entity_id
      AND model_name = p_model_name
      AND model_version = p_target_version;
END;
$$ LANGUAGE plpgsql;
```

---

## 7. æ€§èƒ½ä¼˜åŒ–

### 7.1. ç´¢å¼•å‚æ•°è°ƒä¼˜

**HNSWå‚æ•°ä¼˜åŒ–**ï¼š

```sql
-- æŸ¥è¯¢æ€§èƒ½ä¼˜åŒ–
SET hnsw.ef_search = 100;  -- å¢åŠ æœç´¢å®½åº¦ï¼Œæé«˜å¬å›ç‡

-- é’ˆå¯¹ä¸åŒåœºæ™¯çš„å‚æ•°
-- é«˜å¬å›ç‡åœºæ™¯
CREATE INDEX idx_high_recall
ON document_embeddings
USING hnsw (embedding vector_cosine_ops)
WITH (m = 32, ef_construction = 200);

-- å¿«é€ŸæŸ¥è¯¢åœºæ™¯
CREATE INDEX idx_fast_query
ON document_embeddings
USING hnsw (embedding vector_cosine_ops)
WITH (m = 16, ef_construction = 64);
```

### 7.2. æ‰¹é‡æ’å…¥ä¼˜åŒ–

**æ‰¹é‡æ’å…¥å‘é‡**ï¼š

```sql
-- æ‰¹é‡æ’å…¥å‡½æ•°
CREATE OR REPLACE FUNCTION batch_insert_embeddings(
    p_embeddings vector(1536)[],
    p_contents TEXT[],
    p_metadata JSONB[]
)
RETURNS INTEGER AS $$
DECLARE
    v_count INTEGER;
BEGIN
    INSERT INTO rag_system.document_chunks (content, embedding, metadata)
    SELECT
        unnest(p_contents),
        unnest(p_embeddings),
        unnest(p_metadata);

    GET DIAGNOSTICS v_count = ROW_COUNT;
    RETURN v_count;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨ç¤ºä¾‹
SELECT batch_insert_embeddings(
    ARRAY[
        '[0.1, 0.2, ...]'::vector(1536),
        '[0.3, 0.4, ...]'::vector(1536)
    ],
    ARRAY['Content 1', 'Content 2'],
    ARRAY['{"source": "doc1"}'::jsonb, '{"source": "doc2"}'::jsonb]
);
```

### 7.3. å‘é‡å‹ç¼©

**é‡åŒ–å‹ç¼©å­˜å‚¨**ï¼š

```sql
-- å‘é‡å‹ç¼©è¡¨ï¼ˆå­˜å‚¨é‡åŒ–åçš„å‘é‡ï¼‰
CREATE TABLE document_embeddings_compressed (
    id BIGSERIAL PRIMARY KEY,
    document_id BIGINT NOT NULL,
    embedding_quantized BYTEA,  -- é‡åŒ–åçš„å‘é‡
    embedding_original vector(1536),  -- åŸå§‹å‘é‡ï¼ˆå¯é€‰ï¼‰
    quantization_bits INTEGER DEFAULT 8,  -- é‡åŒ–ä½æ•°
    scale_factor DECIMAL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- é‡åŒ–å‡½æ•°ï¼ˆç®€åŒ–ç¤ºä¾‹ï¼‰
CREATE OR REPLACE FUNCTION quantize_vector(
    p_vector vector(1536),
    p_bits INTEGER DEFAULT 8
)
RETURNS BYTEA AS $$
DECLARE
    v_min DECIMAL;
    v_max DECIMAL;
    v_scale DECIMAL;
    v_quantized BYTEA;
BEGIN
    -- è®¡ç®—ç¼©æ”¾å› å­
    SELECT MIN(unnest), MAX(unnest) INTO v_min, v_max
    FROM unnest(p_vector::DECIMAL[]);

    v_scale := POWER(2, p_bits) / (v_max - v_min);

    -- é‡åŒ–ï¼ˆç®€åŒ–å®ç°ï¼‰
    -- å®é™…å®ç°éœ€è¦æ›´å¤æ‚çš„ç¼–ç 

    RETURN v_quantized;
END;
$$ LANGUAGE plpgsql;
```

---

## 8. å‚è€ƒèµ„æ–™

- [PostgreSQLå‘é‡æ”¯æŒ](../../PostgreSQL/03-é«˜çº§ç‰¹æ€§/03.05-å‘é‡æ•°æ®åº“æ”¯æŒ.md)
- [RAGç³»ç»Ÿè®¾è®¡](../../PostgreSQL/09-åº”ç”¨è®¾è®¡/è¡Œä¸šæ¡ˆä¾‹/å‘é‡æ£€ç´¢ä¸RAG.md)
- [çŸ¥è¯†å›¾è°±ç†è®º](../01-ç†è®ºæ¨¡å‹/01.04-çŸ¥è¯†å›¾è°±ç†è®º.md)

---

**æœ€åæ›´æ–°**ï¼š2025-01-15
**ç»´æŠ¤è€…**ï¼šData-Science Team
**çŠ¶æ€**ï¼šå®æ–½ä¸­
