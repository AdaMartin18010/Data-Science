# å‘é‡ä¸çŸ¥è¯†å›¾è°±èåˆè®¾è®¡ï¼šæ··åˆæ£€ç´¢ä¸æ™ºèƒ½é—®ç­”

> **åˆ›å»ºæ—¥æœŸ**ï¼š2025-01-15
> **æœ€åæ›´æ–°**ï¼š2025-12-01
> **ç‰ˆæœ¬**ï¼šv2.0 (å¢å¼ºç‰ˆ)
> **çŠ¶æ€**ï¼šå®æ–½ä¸­

---

## ğŸ“‹ ç›®å½•

- [å‘é‡ä¸çŸ¥è¯†å›¾è°±èåˆè®¾è®¡ï¼šæ··åˆæ£€ç´¢ä¸æ™ºèƒ½é—®ç­”](#å‘é‡ä¸çŸ¥è¯†å›¾è°±èåˆè®¾è®¡æ··åˆæ£€ç´¢ä¸æ™ºèƒ½é—®ç­”)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1. èåˆä¼˜åŠ¿](#11-èåˆä¼˜åŠ¿)
    - [1.2. èåˆæ–¹æ¡ˆé€‰æ‹©å†³ç­–æ ‘](#12-èåˆæ–¹æ¡ˆé€‰æ‹©å†³ç­–æ ‘)
  - [2. å‘é‡+çŸ¥è¯†å›¾è°±èåˆæ¶æ„](#2-å‘é‡çŸ¥è¯†å›¾è°±èåˆæ¶æ„)
    - [2.1. èåˆæ¶æ„è®¾è®¡](#21-èåˆæ¶æ„è®¾è®¡)
    - [2.2. æ•°æ®åŒæ­¥æœºåˆ¶](#22-æ•°æ®åŒæ­¥æœºåˆ¶)
  - [3. æ··åˆæ£€ç´¢Schemaè®¾è®¡](#3-æ··åˆæ£€ç´¢schemaè®¾è®¡)
    - [3.1. å‘é‡+çŸ¥è¯†å›¾è°±æ··åˆæ£€ç´¢è¡¨](#31-å‘é‡çŸ¥è¯†å›¾è°±æ··åˆæ£€ç´¢è¡¨)
    - [3.2. æ··åˆæ£€ç´¢å‡½æ•°](#32-æ··åˆæ£€ç´¢å‡½æ•°)
  - [4. çŸ¥è¯†å¢å¼ºçš„RAGç³»ç»Ÿ](#4-çŸ¥è¯†å¢å¼ºçš„ragç³»ç»Ÿ)
    - [4.1. KG-RAGæ¶æ„](#41-kg-ragæ¶æ„)
    - [4.2. KG-RAGæ£€ç´¢å‡½æ•°](#42-kg-ragæ£€ç´¢å‡½æ•°)
  - [5. å›¾å¢å¼ºçš„å‘é‡æ£€ç´¢](#5-å›¾å¢å¼ºçš„å‘é‡æ£€ç´¢)
    - [5.1. å›¾ç»“æ„å¢å¼ºçš„å‘é‡æ£€ç´¢](#51-å›¾ç»“æ„å¢å¼ºçš„å‘é‡æ£€ç´¢)
  - [6. æ™ºèƒ½é—®ç­”ç³»ç»Ÿè®¾è®¡](#6-æ™ºèƒ½é—®ç­”ç³»ç»Ÿè®¾è®¡)
    - [6.1. é—®ç­”ç³»ç»ŸSchema](#61-é—®ç­”ç³»ç»Ÿschema)
    - [6.2. æ™ºèƒ½é—®ç­”å‡½æ•°](#62-æ™ºèƒ½é—®ç­”å‡½æ•°)
  - [7. å®é™…åº”ç”¨æ¡ˆä¾‹](#7-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [7.1. ä¼ä¸šçŸ¥è¯†ç®¡ç†ç³»ç»Ÿ](#71-ä¼ä¸šçŸ¥è¯†ç®¡ç†ç³»ç»Ÿ)
  - [8. GraphRAGæ·±åº¦æ¶æ„](#8-graphragæ·±åº¦æ¶æ„)
    - [8.1. GraphRAGæ ¸å¿ƒåŸç†](#81-graphragæ ¸å¿ƒåŸç†)
    - [8.2. GraphRAG Schemaè®¾è®¡](#82-graphrag-schemaè®¾è®¡)
  - [9. 2024-2025æœ€æ–°è¶‹åŠ¿](#9-2024-2025æœ€æ–°è¶‹åŠ¿)
    - [9.1. èåˆæŠ€æœ¯æ¼”è¿›](#91-èåˆæŠ€æœ¯æ¼”è¿›)
    - [9.2. èåˆæ–¹æ¡ˆå¯¹æ¯”](#92-èåˆæ–¹æ¡ˆå¯¹æ¯”)
  - [10. å‚è€ƒèµ„æ–™](#10-å‚è€ƒèµ„æ–™)
    - [10.1. æƒå¨æ–‡çŒ®](#101-æƒå¨æ–‡çŒ®)
    - [10.2. åœ¨çº¿èµ„æº](#102-åœ¨çº¿èµ„æº)
    - [10.3. ç›¸å…³æ–‡æ¡£](#103-ç›¸å…³æ–‡æ¡£)

---

## 1. æ¦‚è¿°

å‘é‡æ•°æ®åº“å’ŒçŸ¥è¯†å›¾è°±å„æœ‰ä¼˜åŠ¿ï¼Œèåˆä¸¤è€…å¯ä»¥å®ç°æ›´å¼ºå¤§çš„è¯­ä¹‰ç†è§£å’Œæ¨ç†èƒ½åŠ›ã€‚

### 1.1. èåˆä¼˜åŠ¿

```mermaid
mindmap
  root((å‘é‡+çŸ¥è¯†å›¾è°±èåˆ))
    å‘é‡æ•°æ®åº“ä¼˜åŠ¿
      è¯­ä¹‰ç›¸ä¼¼åº¦
      æ¨¡ç³ŠåŒ¹é…
      å¤šæ¨¡æ€æ”¯æŒ
    çŸ¥è¯†å›¾è°±ä¼˜åŠ¿
      ç»“æ„åŒ–çŸ¥è¯†
      å…³ç³»æ¨ç†
      å¯è§£é‡Šæ€§
    èåˆä»·å€¼
      ç²¾ç¡®+æ¨¡ç³Šæ£€ç´¢
      è¯­ä¹‰+ç»“æ„åŒ–æŸ¥è¯¢
      æ£€ç´¢+æ¨ç†èƒ½åŠ›
      å¯è§£é‡Šçš„AI
```

### 1.2. èåˆæ–¹æ¡ˆé€‰æ‹©å†³ç­–æ ‘

```mermaid
flowchart TD
    A[é€‰æ‹©èåˆæ–¹æ¡ˆ] --> B{åº”ç”¨åœºæ™¯}

    B -->|è¯­ä¹‰æœç´¢| C[å‘é‡ä¸ºä¸»+KGéªŒè¯]
    B -->|çŸ¥è¯†é—®ç­”| D[KGä¸ºä¸»+å‘é‡æ£€ç´¢]
    B -->|æ··åˆæ£€ç´¢| E[å‘é‡+KGå¹¶è¡Œ]
    B -->|æ¨ç†é—®ç­”| F[KGæ¨ç†+å‘é‡æ’åº]

    C --> G[å®ç°å®Œæˆ]
    D --> G
    E --> G
    F --> G
```

---

## 2. å‘é‡+çŸ¥è¯†å›¾è°±èåˆæ¶æ„

### 2.1. èåˆæ¶æ„è®¾è®¡

**ä¸‰å±‚èåˆæ¶æ„**ï¼š

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  åº”ç”¨å±‚ï¼šæ™ºèƒ½é—®ç­”ã€è¯­ä¹‰æœç´¢          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  èåˆå±‚ï¼šæ··åˆæ£€ç´¢ã€ç»“æœèåˆ          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  å­˜å‚¨å±‚ï¼šå‘é‡DB + çŸ¥è¯†å›¾è°±DB         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2. æ•°æ®åŒæ­¥æœºåˆ¶

**å‘é‡ä¸çŸ¥è¯†å›¾è°±æ•°æ®åŒæ­¥Schema**ï¼š

```sql
CREATE SCHEMA hybrid_search;

-- ç»Ÿä¸€å®ä½“è¡¨ï¼ˆè¿æ¥å‘é‡å’ŒçŸ¥è¯†å›¾è°±ï¼‰
CREATE TABLE hybrid_search.unified_entities (
    entity_id BIGSERIAL PRIMARY KEY,
    entity_uri VARCHAR(500) UNIQUE NOT NULL,
    entity_type VARCHAR(100) NOT NULL,
    entity_name VARCHAR(200) NOT NULL,

    -- å‘é‡ç›¸å…³
    embedding_id BIGINT,  -- å…³è”å‘é‡æ•°æ®åº“ä¸­çš„ID
    embedding_model VARCHAR(100),  -- ä½¿ç”¨çš„Embeddingæ¨¡å‹
    embedding_ready BOOLEAN DEFAULT FALSE,

    -- çŸ¥è¯†å›¾è°±ç›¸å…³
    kg_node_id BIGINT,  -- å…³è”çŸ¥è¯†å›¾è°±ä¸­çš„èŠ‚ç‚¹ID
    kg_ready BOOLEAN DEFAULT FALSE,

    -- å…ƒæ•°æ®
    properties JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_unified_entities_uri ON hybrid_search.unified_entities(entity_uri);
CREATE INDEX idx_unified_entities_type ON hybrid_search.unified_entities(entity_type);
CREATE INDEX idx_unified_entities_embedding ON hybrid_search.unified_entities(embedding_id) WHERE embedding_ready = TRUE;
CREATE INDEX idx_unified_entities_kg ON hybrid_search.unified_entities(kg_node_id) WHERE kg_ready = TRUE;

-- åŒæ­¥çŠ¶æ€è¡¨
CREATE TABLE hybrid_search.sync_status (
    sync_id BIGSERIAL PRIMARY KEY,
    entity_id BIGINT NOT NULL REFERENCES hybrid_search.unified_entities(entity_id),
    sync_type VARCHAR(50) NOT NULL,  -- VECTOR_TO_KG, KG_TO_VECTOR, BIDIRECTIONAL
    sync_status VARCHAR(50) NOT NULL,  -- PENDING, SYNCING, COMPLETED, FAILED
    last_sync_at TIMESTAMP,
    error_message TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_sync_status_entity ON hybrid_search.sync_status(entity_id);
CREATE INDEX idx_sync_status_status ON hybrid_search.sync_status(sync_status);
```

---

## 3. æ··åˆæ£€ç´¢Schemaè®¾è®¡

### 3.1. å‘é‡+çŸ¥è¯†å›¾è°±æ··åˆæ£€ç´¢è¡¨

**æ··åˆæ£€ç´¢ç»“æœè¡¨**ï¼š

```sql
-- å‘é‡æ£€ç´¢ç»“æœè¡¨
CREATE TABLE hybrid_search.vector_search_results (
    result_id BIGSERIAL PRIMARY KEY,
    query_id BIGINT NOT NULL,
    entity_id BIGINT NOT NULL REFERENCES hybrid_search.unified_entities(entity_id),
    vector_score DECIMAL(5,4) NOT NULL,
    rank_position INTEGER NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_vector_results_query ON hybrid_search.vector_search_results(query_id, rank_position);

-- çŸ¥è¯†å›¾è°±æ£€ç´¢ç»“æœè¡¨
CREATE TABLE hybrid_search.kg_search_results (
    result_id BIGSERIAL PRIMARY KEY,
    query_id BIGINT NOT NULL,
    entity_id BIGINT NOT NULL REFERENCES hybrid_search.unified_entities(entity_id),
    kg_score DECIMAL(5,4) NOT NULL,  -- åŸºäºå›¾ç»“æ„è®¡ç®—çš„åˆ†æ•°
    reasoning_path TEXT,  -- æ¨ç†è·¯å¾„
    rank_position INTEGER NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_kg_results_query ON hybrid_search.kg_search_results(query_id, rank_position);

-- æ··åˆæ£€ç´¢æŸ¥è¯¢è¡¨
CREATE TABLE hybrid_search.hybrid_queries (
    query_id BIGSERIAL PRIMARY KEY,
    query_text TEXT NOT NULL,
    query_embedding vector(1536),  -- OpenAI ada-002
    query_type VARCHAR(50),  -- SEMANTIC, STRUCTURAL, HYBRID
    vector_weight DECIMAL(3,2) DEFAULT 0.6,  -- å‘é‡æ£€ç´¢æƒé‡
    kg_weight DECIMAL(3,2) DEFAULT 0.4,  -- çŸ¥è¯†å›¾è°±æ£€ç´¢æƒé‡
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_hybrid_queries_embedding
ON hybrid_search.hybrid_queries
USING hnsw (query_embedding vector_cosine_ops);
```

### 3.2. æ··åˆæ£€ç´¢å‡½æ•°

**RRFèåˆæ£€ç´¢**ï¼š

```sql
-- æ··åˆæ£€ç´¢å‡½æ•°ï¼ˆRRFèåˆï¼‰
CREATE OR REPLACE FUNCTION hybrid_search_rrf(
    p_query_text TEXT,
    p_query_embedding vector(1536),
    p_top_k INTEGER DEFAULT 20,
    p_vector_weight DECIMAL DEFAULT 0.6,
    p_kg_weight DECIMAL DEFAULT 0.4,
    p_k INTEGER DEFAULT 60  -- RRFå‚æ•°
)
RETURNS TABLE (
    entity_id BIGINT,
    entity_uri VARCHAR(500),
    entity_name VARCHAR(200),
    combined_score DECIMAL(5,4),
    vector_score DECIMAL(5,4),
    kg_score DECIMAL(5,4),
    reasoning_path TEXT
) AS $$
DECLARE
    v_query_id BIGINT;
BEGIN
    -- è®°å½•æŸ¥è¯¢
    INSERT INTO hybrid_search.hybrid_queries
    (query_text, query_embedding, query_type, vector_weight, kg_weight)
    VALUES (p_query_text, p_query_embedding, 'HYBRID', p_vector_weight, p_kg_weight)
    RETURNING query_id INTO v_query_id;

    -- å‘é‡æ£€ç´¢
    INSERT INTO hybrid_search.vector_search_results (query_id, entity_id, vector_score, rank_position)
    SELECT
        v_query_id,
        ue.entity_id,
        1 - (ue.embedding <=> p_query_embedding) AS vector_score,
        ROW_NUMBER() OVER (ORDER BY ue.embedding <=> p_query_embedding) AS rank_position
    FROM hybrid_search.unified_entities ue
    JOIN rag_system.document_chunks dc ON ue.embedding_id = dc.chunk_id
    WHERE ue.embedding_ready = TRUE
      AND dc.embedding IS NOT NULL
    ORDER BY dc.embedding <=> p_query_embedding
    LIMIT p_top_k;

    -- çŸ¥è¯†å›¾è°±æ£€ç´¢ï¼ˆåŸºäºå®ä½“åç§°å’Œå…³ç³»ï¼‰
    INSERT INTO hybrid_search.kg_search_results (query_id, entity_id, kg_score, reasoning_path, rank_position)
    WITH entity_matches AS (
        SELECT
            ue.entity_id,
            CASE
                WHEN ue.entity_name ILIKE '%' || p_query_text || '%' THEN 0.8
                WHEN EXISTS(
                    SELECT 1 FROM knowledge_graph.triples t
                    JOIN knowledge_graph.entities e ON t.object_id = e.entity_id
                    WHERE t.subject_id = ue.kg_node_id
                      AND e.entity_name ILIKE '%' || p_query_text || '%'
                ) THEN 0.6
                ELSE 0.4
            END AS kg_score,
            'Direct match' AS reasoning_path
        FROM hybrid_search.unified_entities ue
        WHERE ue.kg_ready = TRUE
    )
    SELECT
        v_query_id,
        em.entity_id,
        em.kg_score,
        em.reasoning_path,
        ROW_NUMBER() OVER (ORDER BY em.kg_score DESC) AS rank_position
    FROM entity_matches em
    ORDER BY em.kg_score DESC
    LIMIT p_top_k;

    -- RRFèåˆ
    RETURN QUERY
    WITH vector_ranked AS (
        SELECT
            entity_id,
            vector_score,
            rank_position AS vector_rank
        FROM hybrid_search.vector_search_results
        WHERE query_id = v_query_id
    ),
    kg_ranked AS (
        SELECT
            entity_id,
            kg_score,
            reasoning_path,
            rank_position AS kg_rank
        FROM hybrid_search.kg_search_results
        WHERE query_id = v_query_id
    ),
    rrf_scores AS (
        SELECT
            COALESCE(v.entity_id, k.entity_id) AS entity_id,
            COALESCE(1.0 / (p_k + v.vector_rank), 0) * p_vector_weight +
            COALESCE(1.0 / (p_k + k.kg_rank), 0) * p_kg_weight AS combined_score,
            v.vector_score,
            k.kg_score,
            k.reasoning_path
        FROM vector_ranked v
        FULL OUTER JOIN kg_ranked k ON v.entity_id = k.entity_id
    )
    SELECT
        ue.entity_id,
        ue.entity_uri,
        ue.entity_name,
        rs.combined_score,
        rs.vector_score,
        rs.kg_score,
        rs.reasoning_path
    FROM rrf_scores rs
    JOIN hybrid_search.unified_entities ue ON rs.entity_id = ue.entity_id
    ORDER BY rs.combined_score DESC
    LIMIT p_top_k;
END;
$$ LANGUAGE plpgsql;
```

---

## 4. çŸ¥è¯†å¢å¼ºçš„RAGç³»ç»Ÿ

### 4.1. KG-RAGæ¶æ„

**çŸ¥è¯†å›¾è°±å¢å¼ºçš„RAGç³»ç»ŸSchema**ï¼š

```sql
CREATE SCHEMA kg_rag;

-- KG-RAGæŸ¥è¯¢è¡¨
CREATE TABLE kg_rag.queries (
    query_id BIGSERIAL PRIMARY KEY,
    query_text TEXT NOT NULL,
    query_embedding vector(1536),
    query_type VARCHAR(50),  -- FACTUAL, RELATIONAL, COMPLEX
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- KG-RAGæ£€ç´¢ç»“æœè¡¨
CREATE TABLE kg_rag.retrieval_results (
    result_id BIGSERIAL PRIMARY KEY,
    query_id BIGINT NOT NULL REFERENCES kg_rag.queries(query_id),

    -- å‘é‡æ£€ç´¢ç»“æœ
    chunk_id BIGINT REFERENCES rag_system.document_chunks(chunk_id),
    vector_score DECIMAL(5,4),

    -- çŸ¥è¯†å›¾è°±æ£€ç´¢ç»“æœ
    entity_id BIGINT REFERENCES hybrid_search.unified_entities(entity_id),
    kg_path TEXT,  -- çŸ¥è¯†å›¾è°±æ¨ç†è·¯å¾„
    kg_score DECIMAL(5,4),

    -- èåˆç»“æœ
    combined_score DECIMAL(5,4),
    retrieval_type VARCHAR(50),  -- VECTOR_ONLY, KG_ONLY, HYBRID

    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_retrieval_results_query ON kg_rag.retrieval_results(query_id, combined_score DESC);
```

### 4.2. KG-RAGæ£€ç´¢å‡½æ•°

**çŸ¥è¯†å›¾è°±å¢å¼ºçš„æ£€ç´¢**ï¼š

```sql
-- KG-RAGæ£€ç´¢å‡½æ•°
CREATE OR REPLACE FUNCTION kg_rag_retrieve(
    p_query_text TEXT,
    p_query_embedding vector(1536),
    p_top_k INTEGER DEFAULT 10,
    p_use_kg BOOLEAN DEFAULT TRUE
)
RETURNS TABLE (
    chunk_id BIGINT,
    content TEXT,
    entity_id BIGINT,
    entity_name VARCHAR(200),
    kg_context TEXT,
    score DECIMAL(5,4)
) AS $$
DECLARE
    v_query_id BIGINT;
    v_entities TEXT[];
BEGIN
    -- è®°å½•æŸ¥è¯¢
    INSERT INTO kg_rag.queries (query_text, query_embedding)
    VALUES (p_query_text, p_query_embedding)
    RETURNING query_id INTO v_query_id;

    -- å¦‚æœä½¿ç”¨çŸ¥è¯†å›¾è°±ï¼Œå…ˆè¿›è¡Œå®ä½“è¯†åˆ«å’Œæ£€ç´¢
    IF p_use_kg THEN
        -- ä»æŸ¥è¯¢ä¸­æå–å®ä½“ï¼ˆç®€åŒ–ç¤ºä¾‹ï¼Œå®é™…éœ€è¦ä½¿ç”¨NERæ¨¡å‹ï¼‰
        SELECT array_agg(entity_name) INTO v_entities
        FROM hybrid_search.unified_entities
        WHERE entity_name = ANY(string_to_array(p_query_text, ' '));

        -- åŸºäºå®ä½“æ£€ç´¢ç›¸å…³æ–‡æ¡£å—
        RETURN QUERY
        WITH kg_entities AS (
            SELECT DISTINCT entity_id
            FROM hybrid_search.unified_entities
            WHERE entity_name = ANY(v_entities)
        ),
        kg_related_chunks AS (
            SELECT DISTINCT
                dc.chunk_id,
                dc.content,
                ue.entity_id,
                ue.entity_name,
                -- è·å–å®ä½“åœ¨çŸ¥è¯†å›¾è°±ä¸­çš„ä¸Šä¸‹æ–‡
                (SELECT string_agg(
                    format('%s %s %s',
                        e1.entity_name,
                        r.relation_name,
                        e2.entity_name),
                    '; '
                )
                FROM knowledge_graph.triples t
                JOIN knowledge_graph.entities e1 ON t.subject_id = e1.entity_id
                JOIN knowledge_graph.relations r ON t.predicate_id = r.relation_id
                JOIN knowledge_graph.entities e2 ON t.object_id = e2.entity_id
                WHERE t.subject_id = ue.kg_node_id
                LIMIT 5) AS kg_context,
                -- è®¡ç®—åˆ†æ•°ï¼šå‘é‡ç›¸ä¼¼åº¦ + KGç›¸å…³æ€§
                0.7 * (1 - (dc.embedding <=> p_query_embedding)) +
                0.3 * CASE WHEN ue.entity_id IS NOT NULL THEN 1.0 ELSE 0.0 END AS score
            FROM rag_system.document_chunks dc
            LEFT JOIN hybrid_search.unified_entities ue ON dc.chunk_id = ue.embedding_id
            LEFT JOIN kg_entities ke ON ue.entity_id = ke.entity_id
            WHERE dc.embedding IS NOT NULL
              AND (ke.entity_id IS NOT NULL OR ue.entity_id IS NOT NULL)
        )
        SELECT
            chunk_id,
            content,
            entity_id,
            entity_name,
            kg_context,
            score
        FROM kg_related_chunks
        ORDER BY score DESC
        LIMIT p_top_k;
    ELSE
        -- çº¯å‘é‡æ£€ç´¢
        RETURN QUERY
        SELECT
            dc.chunk_id,
            dc.content,
            NULL::BIGINT AS entity_id,
            NULL::VARCHAR AS entity_name,
            NULL::TEXT AS kg_context,
            1 - (dc.embedding <=> p_query_embedding) AS score
        FROM rag_system.document_chunks dc
        WHERE dc.embedding IS NOT NULL
        ORDER BY dc.embedding <=> p_query_embedding
        LIMIT p_top_k;
    END IF;
END;
$$ LANGUAGE plpgsql;
```

---

## 5. å›¾å¢å¼ºçš„å‘é‡æ£€ç´¢

### 5.1. å›¾ç»“æ„å¢å¼ºçš„å‘é‡æ£€ç´¢

**åˆ©ç”¨å›¾ç»“æ„ä¼˜åŒ–å‘é‡æ£€ç´¢**ï¼š

```sql
-- å›¾ç»“æ„å¢å¼ºçš„å‘é‡æ£€ç´¢å‡½æ•°
CREATE OR REPLACE FUNCTION graph_enhanced_vector_search(
    p_query_embedding vector(1536),
    p_start_entity_id BIGINT,
    p_max_hops INTEGER DEFAULT 2,
    p_top_k INTEGER DEFAULT 10
)
RETURNS TABLE (
    entity_id BIGINT,
    entity_name VARCHAR(200),
    hop_distance INTEGER,
    vector_score DECIMAL(5,4),
    graph_score DECIMAL(5,4),
    combined_score DECIMAL(5,4),
    path TEXT
) AS $$
BEGIN
    RETURN QUERY
    WITH RECURSIVE graph_neighbors AS (
        -- åŸºç¡€ï¼šèµ·å§‹å®ä½“
        SELECT
            ue.entity_id,
            ue.entity_name,
            0 AS hop_distance,
            ARRAY[ue.entity_id] AS path
        FROM hybrid_search.unified_entities ue
        WHERE ue.entity_id = p_start_entity_id

        UNION

        -- é€’å½’ï¼šé‚»å±…å®ä½“
        SELECT
            ue2.entity_id,
            ue2.entity_name,
            gn.hop_distance + 1,
            gn.path || ue2.entity_id
        FROM graph_neighbors gn
        JOIN knowledge_graph.triples t ON gn.entity_id = t.subject_id
        JOIN hybrid_search.unified_entities ue2 ON t.object_id = ue2.kg_node_id
        WHERE gn.hop_distance < p_max_hops
          AND ue2.entity_id != ALL(gn.path)  -- é¿å…å¾ªç¯
    ),
    vector_scores AS (
        SELECT
            gn.entity_id,
            gn.entity_name,
            gn.hop_distance,
            gn.path,
            1 - (ue.embedding <=> p_query_embedding) AS vector_score
        FROM graph_neighbors gn
        JOIN hybrid_search.unified_entities ue ON gn.entity_id = ue.entity_id
        JOIN rag_system.document_chunks dc ON ue.embedding_id = dc.chunk_id
        WHERE ue.embedding_ready = TRUE
          AND dc.embedding IS NOT NULL
    )
    SELECT
        vs.entity_id,
        vs.entity_name,
        vs.hop_distance,
        vs.vector_score,
        -- å›¾ç»“æ„åˆ†æ•°ï¼šè·ç¦»è¶Šè¿‘åˆ†æ•°è¶Šé«˜
        (1.0 / (vs.hop_distance + 1)) AS graph_score,
        -- ç»„åˆåˆ†æ•°ï¼šå‘é‡ç›¸ä¼¼åº¦ + å›¾ç»“æ„
        0.7 * vs.vector_score + 0.3 * (1.0 / (vs.hop_distance + 1)) AS combined_score,
        array_to_string(vs.path, ' -> ') AS path
    FROM vector_scores vs
    ORDER BY combined_score DESC
    LIMIT p_top_k;
END;
$$ LANGUAGE plpgsql;
```

---

## 6. æ™ºèƒ½é—®ç­”ç³»ç»Ÿè®¾è®¡

### 6.1. é—®ç­”ç³»ç»ŸSchema

**å®Œæ•´çš„æ™ºèƒ½é—®ç­”ç³»ç»ŸSchema**ï¼š

```sql
CREATE SCHEMA intelligent_qa;

-- é—®ç­”ä¼šè¯è¡¨
CREATE TABLE intelligent_qa.sessions (
    session_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT,
    session_name VARCHAR(200),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- é—®ç­”è®°å½•è¡¨
CREATE TABLE intelligent_qa.qa_records (
    record_id BIGSERIAL PRIMARY KEY,
    session_id BIGINT NOT NULL REFERENCES intelligent_qa.sessions(session_id),
    question_text TEXT NOT NULL,
    question_embedding vector(1536),
    answer_text TEXT,
    answer_type VARCHAR(50),  -- FACTUAL, RELATIONAL, REASONING
    retrieval_method VARCHAR(50),  -- VECTOR, KG, HYBRID
    retrieved_chunks INTEGER[],
    retrieved_entities BIGINT[],
    reasoning_path TEXT,
    confidence_score DECIMAL(5,4),
    user_feedback VARCHAR(20),  -- POSITIVE, NEGATIVE, NEUTRAL
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_qa_records_session ON intelligent_qa.qa_records(session_id, created_at DESC);
CREATE INDEX idx_qa_records_question ON intelligent_qa.qa_records USING GIN (question_text gin_trgm_ops);

-- é—®ç­”ä¸Šä¸‹æ–‡è¡¨ï¼ˆå¤šè½®å¯¹è¯ï¼‰
CREATE TABLE intelligent_qa.conversation_context (
    context_id BIGSERIAL PRIMARY KEY,
    session_id BIGINT NOT NULL REFERENCES intelligent_qa.sessions(session_id),
    turn_number INTEGER NOT NULL,
    question_text TEXT NOT NULL,
    answer_text TEXT,
    context_entities BIGINT[],  -- ä¸Šä¸‹æ–‡ä¸­çš„å®ä½“
    context_relations TEXT[],  -- ä¸Šä¸‹æ–‡ä¸­çš„å…³ç³»
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(session_id, turn_number)
);

CREATE INDEX idx_conversation_context_session ON intelligent_qa.conversation_context(session_id, turn_number);
```

### 6.2. æ™ºèƒ½é—®ç­”å‡½æ•°

**å¤šè½®å¯¹è¯é—®ç­”å‡½æ•°**ï¼š

```sql
-- æ™ºèƒ½é—®ç­”å‡½æ•°ï¼ˆæ”¯æŒå¤šè½®å¯¹è¯ï¼‰
CREATE OR REPLACE FUNCTION intelligent_qa_answer(
    p_session_id BIGINT,
    p_question_text TEXT,
    p_question_embedding vector(1536),
    p_use_context BOOLEAN DEFAULT TRUE
)
RETURNS TABLE (
    answer_text TEXT,
    answer_type VARCHAR(50),
    confidence_score DECIMAL(5,4),
    retrieved_chunks INTEGER[],
    reasoning_path TEXT
) AS $$
DECLARE
    v_context_entities BIGINT[];
    v_context_relations TEXT[];
    v_retrieved_chunks INTEGER[];
    v_answer_type VARCHAR(50);
    v_reasoning_path TEXT;
BEGIN
    -- è·å–ä¸Šä¸‹æ–‡ï¼ˆå¦‚æœæ˜¯å¤šè½®å¯¹è¯ï¼‰
    IF p_use_context THEN
        SELECT
            array_agg(DISTINCT unnest(context_entities)),
            array_agg(DISTINCT unnest(context_relations))
        INTO v_context_entities, v_context_relations
        FROM intelligent_qa.conversation_context
        WHERE session_id = p_session_id
          AND turn_number >= (
              SELECT MAX(turn_number) - 3
              FROM intelligent_qa.conversation_context
              WHERE session_id = p_session_id
          );
    END IF;

    -- åˆ¤æ–­é—®é¢˜ç±»å‹
    IF p_question_text ~* '(who|what|when|where|why|how)' THEN
        v_answer_type := 'FACTUAL';
    ELSIF p_question_text ~* '(relationship|related|connected)' THEN
        v_answer_type := 'RELATIONAL';
    ELSE
        v_answer_type := 'REASONING';
    END IF;

    -- æ ¹æ®é—®é¢˜ç±»å‹é€‰æ‹©æ£€ç´¢æ–¹æ³•
    IF v_answer_type = 'RELATIONAL' OR v_context_entities IS NOT NULL THEN
        -- ä½¿ç”¨çŸ¥è¯†å›¾è°±æ£€ç´¢
        SELECT
            array_agg(chunk_id),
            string_agg(reasoning_path, '; ')
        INTO v_retrieved_chunks, v_reasoning_path
        FROM kg_rag_retrieve(
            p_question_text,
            p_question_embedding,
            5,
            TRUE
        );
    ELSE
        -- ä½¿ç”¨å‘é‡æ£€ç´¢
        SELECT array_agg(chunk_id)
        INTO v_retrieved_chunks
        FROM (
            SELECT chunk_id
            FROM rag_system.document_chunks
            WHERE embedding IS NOT NULL
            ORDER BY embedding <=> p_question_embedding
            LIMIT 5
        ) subq;
    END IF;

    -- ç”Ÿæˆç­”æ¡ˆï¼ˆç®€åŒ–ç¤ºä¾‹ï¼Œå®é™…éœ€è¦ä½¿ç”¨LLMï¼‰
    -- è¿™é‡Œè¿”å›æ£€ç´¢åˆ°çš„å†…å®¹ä½œä¸ºç­”æ¡ˆ
    RETURN QUERY
    SELECT
        string_agg(dc.content, E'\n\n') AS answer_text,
        v_answer_type AS answer_type,
        0.8::DECIMAL AS confidence_score,
        v_retrieved_chunks AS retrieved_chunks,
        v_reasoning_path AS reasoning_path
    FROM rag_system.document_chunks dc
    WHERE dc.chunk_id = ANY(v_retrieved_chunks);
END;
$$ LANGUAGE plpgsql;
```

---

## 7. å®é™…åº”ç”¨æ¡ˆä¾‹

### 7.1. ä¼ä¸šçŸ¥è¯†ç®¡ç†ç³»ç»Ÿ

**èåˆå‘é‡å’ŒçŸ¥è¯†å›¾è°±çš„ä¼ä¸šçŸ¥è¯†åº“**ï¼š

```sql
CREATE SCHEMA enterprise_knowledge;

-- ä¼ä¸šçŸ¥è¯†åº“Schemaï¼ˆèåˆè®¾è®¡ï¼‰
CREATE TABLE enterprise_knowledge.documents (
    document_id BIGSERIAL PRIMARY KEY,
    title VARCHAR(500) NOT NULL,
    content TEXT NOT NULL,
    document_type VARCHAR(50),  -- POLICY, PROCEDURE, FAQ, KNOWLEDGE_BASE
    department VARCHAR(100),
    tags TEXT[],
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- æ–‡æ¡£å—è¡¨ï¼ˆå‘é‡å­˜å‚¨ï¼‰
CREATE TABLE enterprise_knowledge.document_chunks (
    chunk_id BIGSERIAL PRIMARY KEY,
    document_id BIGINT NOT NULL REFERENCES enterprise_knowledge.documents(document_id),
    chunk_index INTEGER NOT NULL,
    content TEXT NOT NULL,
    embedding vector(1536),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(document_id, chunk_index)
);

CREATE INDEX idx_document_chunks_embedding
ON enterprise_knowledge.document_chunks
USING hnsw (embedding vector_cosine_ops);

-- çŸ¥è¯†å®ä½“è¡¨ï¼ˆçŸ¥è¯†å›¾è°±ï¼‰
CREATE TABLE enterprise_knowledge.knowledge_entities (
    entity_id BIGSERIAL PRIMARY KEY,
    entity_name VARCHAR(200) NOT NULL,
    entity_type VARCHAR(100),  -- PERSON, PROCESS, SYSTEM, CONCEPT
    description TEXT,
    chunk_id BIGINT REFERENCES enterprise_knowledge.document_chunks(chunk_id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- çŸ¥è¯†å…³ç³»è¡¨
CREATE TABLE enterprise_knowledge.knowledge_relations (
    relation_id BIGSERIAL PRIMARY KEY,
    source_entity_id BIGINT NOT NULL REFERENCES enterprise_knowledge.knowledge_entities(entity_id),
    target_entity_id BIGINT NOT NULL REFERENCES enterprise_knowledge.knowledge_entities(entity_id),
    relation_type VARCHAR(100),  -- DEPENDS_ON, USES, IMPLEMENTS, RELATED_TO
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ä¼ä¸šçŸ¥è¯†æ£€ç´¢å‡½æ•°ï¼ˆèåˆæ£€ç´¢ï¼‰
CREATE OR REPLACE FUNCTION enterprise_knowledge_search(
    p_query_text TEXT,
    p_query_embedding vector(1536),
    p_department VARCHAR(100) DEFAULT NULL,
    p_top_k INTEGER DEFAULT 10
)
RETURNS TABLE (
    document_id BIGINT,
    title VARCHAR(500),
    content_preview TEXT,
    chunk_id BIGINT,
    score DECIMAL(5,4),
    related_entities TEXT[]
) AS $$
BEGIN
    RETURN QUERY
    WITH vector_results AS (
        SELECT
            dc.chunk_id,
            dc.document_id,
            dc.content,
            1 - (dc.embedding <=> p_query_embedding) AS vector_score
        FROM enterprise_knowledge.document_chunks dc
        JOIN enterprise_knowledge.documents d ON dc.document_id = d.document_id
        WHERE dc.embedding IS NOT NULL
          AND (p_department IS NULL OR d.department = p_department)
        ORDER BY dc.embedding <=> p_query_embedding
        LIMIT p_top_k * 2
    ),
    kg_enhanced AS (
        SELECT
            vr.chunk_id,
            vr.document_id,
            vr.content,
            vr.vector_score,
            -- è·å–ç›¸å…³å®ä½“
            (SELECT array_agg(ke.entity_name)
             FROM enterprise_knowledge.knowledge_entities ke
             WHERE ke.chunk_id = vr.chunk_id
             LIMIT 5) AS related_entities,
            -- å¢å¼ºåˆ†æ•°ï¼šå‘é‡åˆ†æ•° + KGå®ä½“åŒ¹é…
            vr.vector_score +
            CASE
                WHEN EXISTS(
                    SELECT 1 FROM enterprise_knowledge.knowledge_entities ke
                    WHERE ke.chunk_id = vr.chunk_id
                      AND ke.entity_name ILIKE '%' || p_query_text || '%'
                ) THEN 0.2
                ELSE 0.0
            END AS enhanced_score
        FROM vector_results vr
    )
    SELECT
        d.document_id,
        d.title,
        LEFT(ke.content, 200) AS content_preview,
        ke.chunk_id,
        ke.enhanced_score AS score,
        ke.related_entities
    FROM kg_enhanced ke
    JOIN enterprise_knowledge.documents d ON ke.document_id = d.document_id
    ORDER BY ke.enhanced_score DESC
    LIMIT p_top_k;
END;
$$ LANGUAGE plpgsql;
```

---

## 8. GraphRAGæ·±åº¦æ¶æ„

### 8.1. GraphRAGæ ¸å¿ƒåŸç†

```mermaid
flowchart TB
    subgraph çŸ¥è¯†æŠ½å–
        E1[æ–‡æ¡£åˆ†å—]
        E2[å®ä½“æŠ½å–]
        E3[å…³ç³»æŠ½å–]
        E4[å›¾æ„å»º]
    end

    subgraph å›¾ç´¢å¼•
        I1[å®ä½“Embedding]
        I2[ç¤¾åŒºæ£€æµ‹]
        I3[å±‚æ¬¡æ‘˜è¦]
    end

    subgraph æŸ¥è¯¢å¤„ç†
        Q1[é—®é¢˜åˆ†æ]
        Q2[å®ä½“é“¾æ¥]
        Q3[å­å›¾æ£€ç´¢]
        Q4[è·¯å¾„æ¨ç†]
    end

    subgraph ç­”æ¡ˆç”Ÿæˆ
        A1[ä¸Šä¸‹æ–‡æ„å»º]
        A2[LLMç”Ÿæˆ]
        A3[å¼•ç”¨è¿½è¸ª]
    end

    E1 --> E2 --> E3 --> E4
    E4 --> I1
    E4 --> I2
    I2 --> I3

    Q1 --> Q2
    Q2 --> Q3
    Q3 --> Q4

    I1 --> Q2
    I3 --> A1
    Q4 --> A1
    A1 --> A2 --> A3
```

### 8.2. GraphRAG Schemaè®¾è®¡

```sql
-- GraphRAGå®Œæ•´Schema
CREATE SCHEMA graphrag;

-- ç¤¾åŒºè¡¨ï¼ˆLeidenç®—æ³•æ£€æµ‹ï¼‰
CREATE TABLE graphrag.communities (
    community_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    level INTEGER NOT NULL,  -- å±‚æ¬¡çº§åˆ«
    parent_community_id UUID REFERENCES graphrag.communities(community_id),
    member_entities UUID[] NOT NULL,
    summary TEXT,  -- ç¤¾åŒºæ‘˜è¦
    summary_embedding vector(1536),
    entity_count INTEGER,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- GraphRAGæ£€ç´¢å‡½æ•°
CREATE OR REPLACE FUNCTION graphrag_query(
    p_question TEXT,
    p_question_embedding vector(1536),
    p_search_mode VARCHAR DEFAULT 'local'  -- 'local', 'global', 'hybrid'
)
RETURNS TABLE (
    content TEXT,
    source_type VARCHAR,
    relevance_score FLOAT,
    entities JSONB,
    relationships JSONB
) AS $$
BEGIN
    IF p_search_mode = 'local' THEN
        -- æœ¬åœ°æœç´¢ï¼šåŸºäºå®ä½“å’Œå…³ç³»
        RETURN QUERY
        SELECT
            e.description AS content,
            'entity' AS source_type,
            (1 - (e.embedding <=> p_question_embedding))::FLOAT AS relevance_score,
            jsonb_build_object('name', e.entity_name, 'type', e.entity_type) AS entities,
            (SELECT jsonb_agg(jsonb_build_object('type', r.relation_type, 'target', e2.entity_name))
             FROM graphrag.relations r
             JOIN graphrag.entities e2 ON r.target_entity_id = e2.entity_id
             WHERE r.source_entity_id = e.entity_id
             LIMIT 5) AS relationships
        FROM graphrag.entities e
        ORDER BY e.embedding <=> p_question_embedding
        LIMIT 10;

    ELSIF p_search_mode = 'global' THEN
        -- å…¨å±€æœç´¢ï¼šåŸºäºç¤¾åŒºæ‘˜è¦
        RETURN QUERY
        SELECT
            c.summary AS content,
            'community' AS source_type,
            (1 - (c.summary_embedding <=> p_question_embedding))::FLOAT AS relevance_score,
            jsonb_build_object('community_id', c.community_id, 'level', c.level) AS entities,
            NULL::JSONB AS relationships
        FROM graphrag.communities c
        WHERE c.summary_embedding IS NOT NULL
        ORDER BY c.summary_embedding <=> p_question_embedding
        LIMIT 5;

    ELSE
        -- æ··åˆæœç´¢
        RETURN QUERY
        (SELECT * FROM graphrag_query(p_question, p_question_embedding, 'local') LIMIT 5)
        UNION ALL
        (SELECT * FROM graphrag_query(p_question, p_question_embedding, 'global') LIMIT 5);
    END IF;
END;
$$ LANGUAGE plpgsql;
```

---

## 9. 2024-2025æœ€æ–°è¶‹åŠ¿

### 9.1. èåˆæŠ€æœ¯æ¼”è¿›

```mermaid
timeline
    title å‘é‡+çŸ¥è¯†å›¾è°±èåˆæ¼”è¿›
    2020 : åŸºç¡€æ··åˆæ£€ç´¢
    2022 : çŸ¥è¯†å¢å¼ºEmbedding
    2023 : GraphRAGæ¦‚å¿µ
         : Microsoft GraphRAG
    2024 : å±‚æ¬¡åŒ–GraphRAG
         : å¤šè·³æ¨ç†
    2025 : å®æ—¶çŸ¥è¯†æ›´æ–°
         : å¤šæ¨¡æ€å›¾è°±
```

### 9.2. èåˆæ–¹æ¡ˆå¯¹æ¯”

| æ–¹æ¡ˆ | ç‰¹ç‚¹ | ä¼˜åŠ¿ | åŠ£åŠ¿ | é€‚ç”¨åœºæ™¯ |
|------|------|------|------|---------|
| **ç®€å•æ‹¼æ¥** | å‘é‡+KGåˆ†åˆ«æ£€ç´¢ | ç®€å• | æ•ˆæœæœ‰é™ | å¿«é€ŸåŸå‹ |
| **çŸ¥è¯†å¢å¼º** | KGå¢å¼ºå‘é‡ | ç²¾åº¦é«˜ | æ„å»ºå¤æ‚ | é¢†åŸŸRAG |
| **GraphRAG** | å›¾ç¤¾åŒºæ‘˜è¦ | å…¨å±€ç†è§£ | å»¶è¿Ÿé«˜ | å¤æ‚é—®ç­” |
| **æ··åˆæ¨ç†** | å¤šè·³+å‘é‡ | æ¨ç†èƒ½åŠ› | å¤æ‚ | çŸ¥è¯†æ¨ç† |

---

## 10. å‚è€ƒèµ„æ–™

### 10.1. æƒå¨æ–‡çŒ®

**GraphRAGç ”ç©¶**ï¼š

- Microsoft Research (2024). "From Local to Global: A Graph RAG Approach to Query-Focused Summarization"
- Edge, D. et al. (2024). "GraphRAG: Unlocking LLM Discovery on Narrative Private Data"

### 10.2. åœ¨çº¿èµ„æº

| èµ„æº | URL | æè¿° |
|------|-----|------|
| **Microsoft GraphRAG** | <https://github.com/microsoft/graphrag> | å®˜æ–¹å®ç° |
| **LangChain Graph** | <https://python.langchain.com/docs/integrations/graphs/> | å›¾é›†æˆ |
| **LlamaIndex KG** | <https://docs.llamaindex.ai/en/stable/module_guides/indexing/kg/> | çŸ¥è¯†å›¾è°±ç´¢å¼• |

### 10.3. ç›¸å…³æ–‡æ¡£

- [07.10-å‘é‡æ•°æ®åº“è®¾è®¡](./07.10-å‘é‡æ•°æ®åº“è®¾è®¡.md)
- [07.12-çŸ¥è¯†å›¾è°±æ•°æ®åº“è®¾è®¡å®æˆ˜](./07.12-çŸ¥è¯†å›¾è°±æ•°æ®åº“è®¾è®¡å®æˆ˜.md)
- [01-ç†è®ºæ¨¡å‹/01.04-çŸ¥è¯†å›¾è°±ç†è®º](../01-ç†è®ºæ¨¡å‹/01.04-çŸ¥è¯†å›¾è°±ç†è®º.md)

---

**æœ€åæ›´æ–°**ï¼š2025-12-01
**ç»´æŠ¤è€…**ï¼šData-Science Team
**çŠ¶æ€**ï¼šå®æ–½ä¸­
**ç‰ˆæœ¬**ï¼šv2.0 (å¢å¼ºç‰ˆ)
