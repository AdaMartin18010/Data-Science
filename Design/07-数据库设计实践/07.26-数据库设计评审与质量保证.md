# æ•°æ®åº“è®¾è®¡è¯„å®¡ä¸è´¨é‡ä¿è¯ï¼šè®¾è®¡è§„èŒƒä¸æ£€æŸ¥æ¸…å•

> **åˆ›å»ºæ—¥æœŸ**ï¼š2025-01-15
> **æœ€åæ›´æ–°**ï¼š2025-01-15
> **ç‰ˆæœ¬**ï¼šv1.0
> **çŠ¶æ€**ï¼šå®æ–½ä¸­

---

## ğŸ“‹ ç›®å½•

- [æ•°æ®åº“è®¾è®¡è¯„å®¡ä¸è´¨é‡ä¿è¯ï¼šè®¾è®¡è§„èŒƒä¸æ£€æŸ¥æ¸…å•](#æ•°æ®åº“è®¾è®¡è¯„å®¡ä¸è´¨é‡ä¿è¯è®¾è®¡è§„èŒƒä¸æ£€æŸ¥æ¸…å•)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1. è®¾è®¡è¯„å®¡åº”ç”¨åœºæ™¯](#11-è®¾è®¡è¯„å®¡åº”ç”¨åœºæ™¯)
    - [1.2. è¯„å®¡æµç¨‹å†³ç­–æ ‘](#12-è¯„å®¡æµç¨‹å†³ç­–æ ‘)
  - [2. è®¾è®¡è¯„å®¡æµç¨‹](#2-è®¾è®¡è¯„å®¡æµç¨‹)
    - [2.1. è¯„å®¡é˜¶æ®µ](#21-è¯„å®¡é˜¶æ®µ)
    - [2.2. è¯„å®¡æ£€æŸ¥æ¸…å•](#22-è¯„å®¡æ£€æŸ¥æ¸…å•)
  - [3. è®¾è®¡è§„èŒƒæ£€æŸ¥](#3-è®¾è®¡è§„èŒƒæ£€æŸ¥)
    - [3.1. å‘½åè§„èŒƒæ£€æŸ¥](#31-å‘½åè§„èŒƒæ£€æŸ¥)
    - [3.2. ç»“æ„è§„èŒƒæ£€æŸ¥](#32-ç»“æ„è§„èŒƒæ£€æŸ¥)
  - [4. æ€§èƒ½æ£€æŸ¥](#4-æ€§èƒ½æ£€æŸ¥)
    - [4.1. ç´¢å¼•æ£€æŸ¥](#41-ç´¢å¼•æ£€æŸ¥)
    - [4.2. æŸ¥è¯¢æ€§èƒ½æ£€æŸ¥](#42-æŸ¥è¯¢æ€§èƒ½æ£€æŸ¥)
  - [5. å®‰å…¨æ£€æŸ¥](#5-å®‰å…¨æ£€æŸ¥)
    - [5.1. æƒé™æ£€æŸ¥](#51-æƒé™æ£€æŸ¥)
  - [6. è´¨é‡è¯„åˆ†ç³»ç»Ÿ](#6-è´¨é‡è¯„åˆ†ç³»ç»Ÿ)
    - [6.1. è´¨é‡è¯„åˆ†å‡½æ•°](#61-è´¨é‡è¯„åˆ†å‡½æ•°)
    - [6.2. è¯„å®¡æŠ¥å‘Šç”Ÿæˆ](#62-è¯„å®¡æŠ¥å‘Šç”Ÿæˆ)
  - [7. å®é™…åº”ç”¨æ¡ˆä¾‹](#7-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [7.1. å®Œæ•´è¯„å®¡ç³»ç»Ÿè®¾è®¡](#71-å®Œæ•´è¯„å®¡ç³»ç»Ÿè®¾è®¡)
  - [8. å‚è€ƒèµ„æ–™](#8-å‚è€ƒèµ„æ–™)

---

## 1. æ¦‚è¿°

æ•°æ®åº“è®¾è®¡è¯„å®¡ä¸è´¨é‡ä¿è¯æ˜¯ç¡®ä¿è®¾è®¡è´¨é‡çš„å…³é”®ç¯èŠ‚ï¼Œéœ€è¦å»ºç«‹å®Œå–„çš„è¯„å®¡æµç¨‹å’Œè´¨é‡æ£€æŸ¥æ ‡å‡†ã€‚

### 1.1. è®¾è®¡è¯„å®¡åº”ç”¨åœºæ™¯

```mermaid
mindmap
  root((è®¾è®¡è¯„å®¡))
    è®¾è®¡é˜¶æ®µè¯„å®¡
      æ¦‚å¿µæ¨¡å‹è¯„å®¡
      é€»è¾‘æ¨¡å‹è¯„å®¡
      ç‰©ç†æ¨¡å‹è¯„å®¡
    ä»£ç è¯„å®¡
      DDLè¯„å®¡
      å­˜å‚¨è¿‡ç¨‹è¯„å®¡
      è§¦å‘å™¨è¯„å®¡
    æ€§èƒ½è¯„å®¡
      æŸ¥è¯¢æ€§èƒ½
      ç´¢å¼•è®¾è®¡
      åˆ†åŒºè®¾è®¡
    å®‰å…¨è¯„å®¡
      æƒé™è®¾è®¡
      åŠ å¯†è®¾è®¡
      å®¡è®¡è®¾è®¡
```

### 1.2. è¯„å®¡æµç¨‹å†³ç­–æ ‘

```mermaid
flowchart TD
    A[å¼€å§‹è¯„å®¡] --> B{è¯„å®¡ç±»å‹}

    B -->|è®¾è®¡è¯„å®¡| C[è®¾è®¡è§„èŒƒæ£€æŸ¥]
    B -->|ä»£ç è¯„å®¡| D[DDLæ£€æŸ¥]
    B -->|æ€§èƒ½è¯„å®¡| E[æ€§èƒ½æ£€æŸ¥]
    B -->|å®‰å…¨è¯„å®¡| F[å®‰å…¨æ£€æŸ¥]

    C --> G{é€šè¿‡?}
    D --> G
    E --> G
    F --> G

    G -->|æ˜¯| H[è¯„å®¡é€šè¿‡]
    G -->|å¦| I[ä¿®æ”¹è®¾è®¡]

    I --> A
```

---

## 2. è®¾è®¡è¯„å®¡æµç¨‹

### 2.1. è¯„å®¡é˜¶æ®µ

**è¯„å®¡é˜¶æ®µçŸ©é˜µ**ï¼š

| é˜¶æ®µ | è¯„å®¡å†…å®¹ | è¯„å®¡äººå‘˜ | è¯„å®¡æ–¹å¼ | è¾“å‡º |
|------|---------|---------|---------|------|
| **æ¦‚å¿µæ¨¡å‹è¯„å®¡** | ERå›¾ã€ä¸šåŠ¡è§„åˆ™ | ä¸šåŠ¡åˆ†æå¸ˆã€æ¶æ„å¸ˆ | ä¼šè®®è¯„å®¡ | è¯„å®¡æŠ¥å‘Š |
| **é€»è¾‘æ¨¡å‹è¯„å®¡** | è¡¨ç»“æ„ã€å…³ç³» | æ•°æ®åº“è®¾è®¡å¸ˆã€å¼€å‘äººå‘˜ | æ–‡æ¡£è¯„å®¡ | è¯„å®¡æ„è§ |
| **ç‰©ç†æ¨¡å‹è¯„å®¡** | ç´¢å¼•ã€åˆ†åŒºã€æ€§èƒ½ | DBAã€æ€§èƒ½å·¥ç¨‹å¸ˆ | æŠ€æœ¯è¯„å®¡ | ä¼˜åŒ–å»ºè®® |
| **ä»£ç è¯„å®¡** | DDLã€å‡½æ•°ã€è§¦å‘å™¨ | å¼€å‘äººå‘˜ã€DBA | ä»£ç å®¡æŸ¥ | ä»£ç ä¿®æ”¹ |

### 2.2. è¯„å®¡æ£€æŸ¥æ¸…å•

**è®¾è®¡è¯„å®¡æ£€æŸ¥æ¸…å•Schema**ï¼š

```sql
CREATE SCHEMA design_review;

-- è¯„å®¡é¡¹ç›®è¡¨
CREATE TABLE design_review.review_items (
    item_id SERIAL PRIMARY KEY,
    category VARCHAR(50) NOT NULL,  -- naming, structure, performance, security
    item_name VARCHAR(200) NOT NULL,
    description TEXT,
    severity VARCHAR(20) NOT NULL CHECK (severity IN ('critical', 'high', 'medium', 'low')),
    checklist TEXT[],  -- æ£€æŸ¥é¡¹åˆ—è¡¨
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- è®¾è®¡è¯„å®¡è®°å½•è¡¨
CREATE TABLE design_review.review_records (
    review_id BIGSERIAL PRIMARY KEY,
    design_name VARCHAR(200) NOT NULL,
    design_version VARCHAR(50) NOT NULL,
    reviewer_name VARCHAR(100) NOT NULL,
    review_type VARCHAR(50) NOT NULL,  -- concept, logical, physical, code
    review_status VARCHAR(20) NOT NULL CHECK (review_status IN ('pending', 'in_progress', 'approved', 'rejected', 'needs_revision')),
    review_start_time TIMESTAMPTZ NOT NULL,
    review_end_time TIMESTAMPTZ,
    review_score INTEGER CHECK (review_score BETWEEN 0 AND 100),
    review_comments TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_review_records_status ON design_review.review_records(review_status, review_start_time DESC);
CREATE INDEX idx_review_records_design ON design_review.review_records(design_name, design_version);

-- è¯„å®¡é—®é¢˜è®°å½•è¡¨
CREATE TABLE design_review.review_issues (
    issue_id BIGSERIAL PRIMARY KEY,
    review_id BIGINT NOT NULL REFERENCES design_review.review_records(review_id) ON DELETE CASCADE,
    item_id INTEGER NOT NULL REFERENCES design_review.review_items(item_id),
    issue_type VARCHAR(50) NOT NULL,  -- error, warning, suggestion
    issue_description TEXT NOT NULL,
    affected_object VARCHAR(200),  -- è¡¨åã€å­—æ®µåç­‰
    severity VARCHAR(20) NOT NULL,
    status VARCHAR(20) NOT NULL CHECK (status IN ('open', 'fixed', 'wont_fix', 'deferred')),
    fixed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_review_issues_review ON design_review.review_issues(review_id, severity);
CREATE INDEX idx_review_issues_status ON design_review.review_issues(status, created_at DESC);
```

---

## 3. è®¾è®¡è§„èŒƒæ£€æŸ¥

### 3.1. å‘½åè§„èŒƒæ£€æŸ¥

**å‘½åè§„èŒƒæ£€æŸ¥å‡½æ•°**ï¼š

```sql
-- å‘½åè§„èŒƒæ£€æŸ¥å‡½æ•°
CREATE OR REPLACE FUNCTION check_naming_conventions(
    p_schema_name VARCHAR,
    p_table_name VARCHAR
)
RETURNS TABLE (
    object_type VARCHAR,
    object_name VARCHAR,
    issue_type VARCHAR,
    issue_description TEXT
) AS $$
BEGIN
    RETURN QUERY
    -- æ£€æŸ¥è¡¨åï¼šåº”è¯¥ä½¿ç”¨å°å†™å­—æ¯å’Œä¸‹åˆ’çº¿
    SELECT
        'table'::VARCHAR,
        t.table_name::VARCHAR,
        'warning'::VARCHAR,
        'Table name should use lowercase and underscores'::TEXT
    FROM information_schema.tables t
    WHERE t.table_schema = p_schema_name
      AND t.table_name = p_table_name
      AND (t.table_name ~ '[A-Z]' OR t.table_name ~ '-')

    UNION ALL

    -- æ£€æŸ¥å­—æ®µåï¼šåº”è¯¥ä½¿ç”¨å°å†™å­—æ¯å’Œä¸‹åˆ’çº¿
    SELECT
        'column'::VARCHAR,
        c.column_name::VARCHAR,
        'warning'::VARCHAR,
        'Column name should use lowercase and underscores'::TEXT
    FROM information_schema.columns c
    WHERE c.table_schema = p_schema_name
      AND c.table_name = p_table_name
      AND (c.column_name ~ '[A-Z]' OR c.column_name ~ '-')

    UNION ALL

    -- æ£€æŸ¥ç´¢å¼•åï¼šåº”è¯¥ä½¿ç”¨idx_å‰ç¼€
    SELECT
        'index'::VARCHAR,
        i.indexname::VARCHAR,
        'warning'::VARCHAR,
        'Index name should start with idx_'::TEXT
    FROM pg_indexes i
    WHERE i.schemaname = p_schema_name
      AND i.tablename = p_table_name
      AND NOT i.indexname LIKE 'idx_%';
END;
$$ LANGUAGE plpgsql;
```

### 3.2. ç»“æ„è§„èŒƒæ£€æŸ¥

**ç»“æ„è§„èŒƒæ£€æŸ¥å‡½æ•°**ï¼š

```sql
-- ç»“æ„è§„èŒƒæ£€æŸ¥å‡½æ•°
CREATE OR REPLACE FUNCTION check_structure_conventions(
    p_schema_name VARCHAR,
    p_table_name VARCHAR
)
RETURNS TABLE (
    issue_type VARCHAR,
    issue_description TEXT,
    recommendation TEXT
) AS $$
BEGIN
    RETURN QUERY
    -- æ£€æŸ¥æ˜¯å¦æœ‰ä¸»é”®
    SELECT
        'error'::VARCHAR,
        'Table missing primary key'::TEXT,
        'Add PRIMARY KEY constraint'::TEXT
    FROM information_schema.tables t
    WHERE t.table_schema = p_schema_name
      AND t.table_name = p_table_name
      AND NOT EXISTS (
          SELECT 1 FROM information_schema.table_constraints tc
          WHERE tc.table_schema = p_schema_name
            AND tc.table_name = p_table_name
            AND tc.constraint_type = 'PRIMARY KEY'
      )

    UNION ALL

    -- æ£€æŸ¥æ˜¯å¦æœ‰created_atå­—æ®µ
    SELECT
        'warning'::VARCHAR,
        'Table missing created_at timestamp field'::TEXT,
        'Add created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP'::TEXT
    FROM information_schema.tables t
    WHERE t.table_schema = p_schema_name
      AND t.table_name = p_table_name
      AND NOT EXISTS (
          SELECT 1 FROM information_schema.columns c
          WHERE c.table_schema = p_schema_name
            AND c.table_name = p_table_name
            AND c.column_name = 'created_at'
      )

    UNION ALL

    -- æ£€æŸ¥å¤–é”®æ˜¯å¦æœ‰ç´¢å¼•
    SELECT
        'warning'::VARCHAR,
        format('Foreign key column %s missing index', kcu.column_name)::TEXT,
        format('CREATE INDEX idx_%s_%s ON %s.%s(%s)',
               p_table_name, kcu.column_name,
               p_schema_name, p_table_name, kcu.column_name)::TEXT
    FROM information_schema.table_constraints tc
    JOIN information_schema.key_column_usage kcu
        ON tc.constraint_name = kcu.constraint_name
    WHERE tc.table_schema = p_schema_name
      AND tc.table_name = p_table_name
      AND tc.constraint_type = 'FOREIGN KEY'
      AND NOT EXISTS (
          SELECT 1 FROM pg_indexes i
          WHERE i.schemaname = p_schema_name
            AND i.tablename = p_table_name
            AND i.indexdef LIKE '%' || kcu.column_name || '%'
      );
END;
$$ LANGUAGE plpgsql;
```

---

## 4. æ€§èƒ½æ£€æŸ¥

### 4.1. ç´¢å¼•æ£€æŸ¥

**ç´¢å¼•æ£€æŸ¥å‡½æ•°**ï¼š

```sql
-- ç´¢å¼•æ£€æŸ¥å‡½æ•°
CREATE OR REPLACE FUNCTION check_index_design(
    p_schema_name VARCHAR,
    p_table_name VARCHAR
)
RETURNS TABLE (
    issue_type VARCHAR,
    issue_description TEXT,
    recommendation TEXT
) AS $$
BEGIN
    RETURN QUERY
    -- æ£€æŸ¥å¤§è¡¨æ˜¯å¦æœ‰ç´¢å¼•
    WITH table_sizes AS (
        SELECT
            schemaname,
            tablename,
            pg_total_relation_size(schemaname||'.'||tablename) AS total_size,
            n_live_tup AS row_count
        FROM pg_stat_user_tables
        WHERE schemaname = p_schema_name
          AND tablename = p_table_name
    )
    SELECT
        'warning'::VARCHAR,
        'Large table missing indexes'::TEXT,
        'Review query patterns and add appropriate indexes'::TEXT
    FROM table_sizes ts
    WHERE ts.total_size > 1000000000  -- 1GB
      AND ts.row_count > 1000000  -- 1M rows
      AND NOT EXISTS (
          SELECT 1 FROM pg_indexes i
          WHERE i.schemaname = ts.schemaname
            AND i.tablename = ts.tablename
      )

    UNION ALL

    -- æ£€æŸ¥æœªä½¿ç”¨çš„ç´¢å¼•
    SELECT
        'suggestion'::VARCHAR,
        format('Index %s appears unused', i.indexname)::TEXT,
        'Consider dropping unused index'::TEXT
    FROM pg_indexes i
    LEFT JOIN pg_stat_user_indexes si
        ON i.schemaname = si.schemaname
        AND i.tablename = si.tablename
        AND i.indexname = si.indexname
    WHERE i.schemaname = p_schema_name
      AND i.tablename = p_table_name
      AND (si.idx_scan IS NULL OR si.idx_scan = 0)
      AND i.indexname NOT LIKE '%_pkey';  -- æ’é™¤ä¸»é”®ç´¢å¼•
END;
$$ LANGUAGE plpgsql;
```

### 4.2. æŸ¥è¯¢æ€§èƒ½æ£€æŸ¥

**æŸ¥è¯¢æ€§èƒ½æ£€æŸ¥å‡½æ•°**ï¼š

```sql
-- æŸ¥è¯¢æ€§èƒ½æ£€æŸ¥å‡½æ•°
CREATE OR REPLACE FUNCTION check_query_performance()
RETURNS TABLE (
    query_hash BIGINT,
    query_text TEXT,
    mean_exec_time DOUBLE PRECISION,
    calls BIGINT,
    issue_type VARCHAR,
    recommendation TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        pss.queryid AS query_hash,
        pss.query AS query_text,
        pss.mean_exec_time,
        pss.calls,
        CASE
            WHEN pss.mean_exec_time > 1000 THEN 'critical'::VARCHAR
            WHEN pss.mean_exec_time > 500 THEN 'high'::VARCHAR
            WHEN pss.mean_exec_time > 100 THEN 'medium'::VARCHAR
            ELSE 'low'::VARCHAR
        END AS issue_type,
        CASE
            WHEN pss.mean_exec_time > 1000 THEN 'Query is very slow, requires optimization'::TEXT
            WHEN pss.mean_exec_time > 500 THEN 'Query is slow, consider adding indexes'::TEXT
            WHEN pss.mean_exec_time > 100 THEN 'Query performance could be improved'::TEXT
            ELSE 'Query performance is acceptable'::TEXT
        END AS recommendation
    FROM pg_stat_statements pss
    WHERE pss.calls > 100  -- åªæ£€æŸ¥é¢‘ç¹æ‰§è¡Œçš„æŸ¥è¯¢
      AND pss.mean_exec_time > 100  -- åªæ£€æŸ¥æ…¢æŸ¥è¯¢
    ORDER BY pss.mean_exec_time DESC
    LIMIT 50;
END;
$$ LANGUAGE plpgsql;
```

---

## 5. å®‰å…¨æ£€æŸ¥

### 5.1. æƒé™æ£€æŸ¥

**æƒé™æ£€æŸ¥å‡½æ•°**ï¼š

```sql
-- æƒé™æ£€æŸ¥å‡½æ•°
CREATE OR REPLACE FUNCTION check_security_design(
    p_schema_name VARCHAR
)
RETURNS TABLE (
    issue_type VARCHAR,
    issue_description TEXT,
    recommendation TEXT
) AS $$
BEGIN
    RETURN QUERY
    -- æ£€æŸ¥è¡¨æ˜¯å¦å¯ç”¨RLS
    SELECT
        'warning'::VARCHAR,
        format('Table %s.%s not using RLS', t.schemaname, t.tablename)::TEXT,
        'Consider enabling Row Level Security for sensitive data'::TEXT
    FROM pg_tables t
    WHERE t.schemaname = p_schema_name
      AND NOT EXISTS (
          SELECT 1 FROM pg_class c
          JOIN pg_namespace n ON c.relnamespace = n.oid
          WHERE n.nspname = t.schemaname
            AND c.relname = t.tablename
            AND c.relrowsecurity = TRUE
      )

    UNION ALL

    -- æ£€æŸ¥æ˜¯å¦æœ‰æ•æ„Ÿå­—æ®µæœªåŠ å¯†
    SELECT
        'warning'::VARCHAR,
        format('Column %s.%s.%s may contain sensitive data',
               t.schemaname, t.tablename, c.column_name)::TEXT,
        'Consider encrypting sensitive columns'::TEXT
    FROM information_schema.columns c
    JOIN information_schema.tables t
        ON c.table_schema = t.table_schema
        AND c.table_name = t.table_name
    WHERE c.table_schema = p_schema_name
      AND (
          c.column_name ILIKE '%password%' OR
          c.column_name ILIKE '%secret%' OR
          c.column_name ILIKE '%token%' OR
          c.column_name ILIKE '%ssn%' OR
          c.column_name ILIKE '%credit%'
      )
      AND c.data_type NOT IN ('bytea', 'text');  -- å‡è®¾byteaå’Œtextå¯èƒ½å·²åŠ å¯†
END;
$$ LANGUAGE plpgsql;
```

---

## 6. è´¨é‡è¯„åˆ†ç³»ç»Ÿ

### 6.1. è´¨é‡è¯„åˆ†å‡½æ•°

**è´¨é‡è¯„åˆ†å‡½æ•°**ï¼š

```sql
-- è®¾è®¡è´¨é‡è¯„åˆ†å‡½æ•°
CREATE OR REPLACE FUNCTION calculate_design_quality_score(
    p_schema_name VARCHAR,
    p_table_name VARCHAR
)
RETURNS TABLE (
    category VARCHAR,
    score INTEGER,
    max_score INTEGER,
    percentage DOUBLE PRECISION
) AS $$
DECLARE
    v_naming_score INTEGER := 0;
    v_structure_score INTEGER := 0;
    v_performance_score INTEGER := 0;
    v_security_score INTEGER := 0;
    v_total_score INTEGER := 0;
    v_max_total_score INTEGER := 100;
BEGIN
    -- å‘½åè§„èŒƒè¯„åˆ†ï¼ˆ25åˆ†ï¼‰
    SELECT COUNT(*) INTO v_naming_score
    FROM check_naming_conventions(p_schema_name, p_table_name)
    WHERE issue_type = 'error';

    v_naming_score := GREATEST(0, 25 - v_naming_score * 5);

    -- ç»“æ„è§„èŒƒè¯„åˆ†ï¼ˆ25åˆ†ï¼‰
    SELECT COUNT(*) INTO v_structure_score
    FROM check_structure_conventions(p_schema_name, p_table_name)
    WHERE issue_type = 'error';

    v_structure_score := GREATEST(0, 25 - v_structure_score * 5);

    -- æ€§èƒ½è®¾è®¡è¯„åˆ†ï¼ˆ25åˆ†ï¼‰
    SELECT COUNT(*) INTO v_performance_score
    FROM check_index_design(p_schema_name, p_table_name)
    WHERE issue_type IN ('error', 'critical');

    v_performance_score := GREATEST(0, 25 - v_performance_score * 5);

    -- å®‰å…¨è®¾è®¡è¯„åˆ†ï¼ˆ25åˆ†ï¼‰
    SELECT COUNT(*) INTO v_security_score
    FROM check_security_design(p_schema_name)
    WHERE issue_type IN ('error', 'critical');

    v_security_score := GREATEST(0, 25 - v_security_score * 5);

    v_total_score := v_naming_score + v_structure_score + v_performance_score + v_security_score;

    RETURN QUERY
    SELECT 'naming'::VARCHAR, v_naming_score, 25, (v_naming_score::DOUBLE PRECISION / 25 * 100)
    UNION ALL
    SELECT 'structure'::VARCHAR, v_structure_score, 25, (v_structure_score::DOUBLE PRECISION / 25 * 100)
    UNION ALL
    SELECT 'performance'::VARCHAR, v_performance_score, 25, (v_performance_score::DOUBLE PRECISION / 25 * 100)
    UNION ALL
    SELECT 'security'::VARCHAR, v_security_score, 25, (v_security_score::DOUBLE PRECISION / 25 * 100)
    UNION ALL
    SELECT 'total'::VARCHAR, v_total_score, v_max_total_score, (v_total_score::DOUBLE PRECISION / v_max_total_score * 100);
END;
$$ LANGUAGE plpgsql;
```

### 6.2. è¯„å®¡æŠ¥å‘Šç”Ÿæˆ

**è¯„å®¡æŠ¥å‘Šç”Ÿæˆå‡½æ•°**ï¼š

```sql
-- ç”Ÿæˆè¯„å®¡æŠ¥å‘Šå‡½æ•°
CREATE OR REPLACE FUNCTION generate_review_report(
    p_review_id BIGINT
)
RETURNS JSONB AS $$
DECLARE
    v_review_record RECORD;
    v_issues JSONB;
    v_score JSONB;
    v_report JSONB;
BEGIN
    -- è·å–è¯„å®¡è®°å½•
    SELECT * INTO v_review_record
    FROM design_review.review_records
    WHERE review_id = p_review_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Review record not found: %', p_review_id;
    END IF;

    -- è·å–è¯„å®¡é—®é¢˜
    SELECT jsonb_agg(
        jsonb_build_object(
            'issue_id', issue_id,
            'item_name', ri.item_name,
            'issue_type', issue_type,
            'issue_description', issue_description,
            'affected_object', affected_object,
            'severity', severity,
            'status', status
        )
    ) INTO v_issues
    FROM design_review.review_issues ri
    JOIN design_review.review_items ri2 ON ri.item_id = ri2.item_id
    WHERE ri.review_id = p_review_id;

    -- æ„å»ºæŠ¥å‘Š
    v_report := jsonb_build_object(
        'review_id', p_review_id,
        'design_name', v_review_record.design_name,
        'design_version', v_review_record.design_version,
        'reviewer', v_review_record.reviewer_name,
        'review_type', v_review_record.review_type,
        'review_status', v_review_record.review_status,
        'review_score', v_review_record.review_score,
        'review_start_time', v_review_record.review_start_time,
        'review_end_time', v_review_record.review_end_time,
        'review_comments', v_review_record.review_comments,
        'issues', COALESCE(v_issues, '[]'::jsonb),
        'summary', jsonb_build_object(
            'total_issues', (
                SELECT COUNT(*) FROM design_review.review_issues
                WHERE review_id = p_review_id
            ),
            'critical_issues', (
                SELECT COUNT(*) FROM design_review.review_issues
                WHERE review_id = p_review_id AND severity = 'critical'
            ),
            'high_issues', (
                SELECT COUNT(*) FROM design_review.review_issues
                WHERE review_id = p_review_id AND severity = 'high'
            ),
            'open_issues', (
                SELECT COUNT(*) FROM design_review.review_issues
                WHERE review_id = p_review_id AND status = 'open'
            )
        )
    );

    RETURN v_report;
END;
$$ LANGUAGE plpgsql;
```

---

## 7. å®é™…åº”ç”¨æ¡ˆä¾‹

### 7.1. å®Œæ•´è¯„å®¡ç³»ç»Ÿè®¾è®¡

**è¯„å®¡ç³»ç»ŸSchemaè®¾è®¡**ï¼š

```sql
CREATE SCHEMA review_system;

-- è®¾è®¡æ–‡æ¡£è¡¨
CREATE TABLE review_system.design_documents (
    document_id BIGSERIAL PRIMARY KEY,
    design_name VARCHAR(200) NOT NULL,
    design_version VARCHAR(50) NOT NULL,
    design_type VARCHAR(50) NOT NULL,  -- concept, logical, physical
    ddl_content TEXT,
    er_diagram TEXT,  -- ERå›¾æè¿°
    description TEXT,
    author VARCHAR(100) NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'draft' CHECK (status IN ('draft', 'submitted', 'reviewing', 'approved', 'rejected')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(design_name, design_version)
);

CREATE INDEX idx_design_documents_status ON review_system.design_documents(status, created_at DESC);
CREATE INDEX idx_design_documents_author ON review_system.design_documents(author, created_at DESC);

-- è¯„å®¡å·¥ä½œæµè¡¨
CREATE TABLE review_system.review_workflows (
    workflow_id BIGSERIAL PRIMARY KEY,
    document_id BIGINT NOT NULL REFERENCES review_system.design_documents(document_id) ON DELETE CASCADE,
    workflow_step INTEGER NOT NULL,
    step_name VARCHAR(100) NOT NULL,
    reviewer_role VARCHAR(50) NOT NULL,
    reviewer_name VARCHAR(100),
    step_status VARCHAR(20) NOT NULL DEFAULT 'pending' CHECK (step_status IN ('pending', 'in_progress', 'approved', 'rejected')),
    step_comments TEXT,
    step_start_time TIMESTAMPTZ,
    step_end_time TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_review_workflows_document ON review_system.review_workflows(document_id, workflow_step);
CREATE INDEX idx_review_workflows_status ON review_system.review_workflows(step_status, step_start_time DESC);
```

---

## 8. å‚è€ƒèµ„æ–™

- [æ•°æ®åº“è®¾è®¡æœ€ä½³å®è·µåº“](./07.14-æ•°æ®åº“è®¾è®¡æœ€ä½³å®è·µåº“.md)
- [æ•°æ®åº“è®¾è®¡å·¥å…·ä¸æ¨¡æ¿åº“](./07.15-æ•°æ®åº“è®¾è®¡å·¥å…·ä¸æ¨¡æ¿åº“.md)
- [æ•°æ®åº“å®‰å…¨è®¾è®¡æ¨¡å¼](./07.23-æ•°æ®åº“å®‰å…¨è®¾è®¡æ¨¡å¼.md)

---

**æœ€åæ›´æ–°**ï¼š2025-01-15
**ç»´æŠ¤è€…**ï¼šData-Science Team
**çŠ¶æ€**ï¼šå®æ–½ä¸­
