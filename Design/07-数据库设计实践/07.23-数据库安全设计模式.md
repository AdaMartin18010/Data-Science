# æ•°æ®åº“å®‰å…¨è®¾è®¡æ¨¡å¼ï¼šæ•°æ®ä¿æŠ¤ä¸è®¿é—®æ§åˆ¶

> **åˆ›å»ºæ—¥æœŸ**ï¼š2025-01-15
> **æœ€åæ›´æ–°**ï¼š2025-01-15
> **ç‰ˆæœ¬**ï¼šv1.0
> **çŠ¶æ€**ï¼šå®æ–½ä¸­

---

## ğŸ“‹ ç›®å½•

- [æ•°æ®åº“å®‰å…¨è®¾è®¡æ¨¡å¼ï¼šæ•°æ®ä¿æŠ¤ä¸è®¿é—®æ§åˆ¶](#æ•°æ®åº“å®‰å…¨è®¾è®¡æ¨¡å¼æ•°æ®ä¿æŠ¤ä¸è®¿é—®æ§åˆ¶)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1. æ•°æ®åº“å®‰å…¨å¨èƒ](#11-æ•°æ®åº“å®‰å…¨å¨èƒ)
    - [1.2. å®‰å…¨è®¾è®¡å†³ç­–æ ‘](#12-å®‰å…¨è®¾è®¡å†³ç­–æ ‘)
  - [2. è®¿é—®æ§åˆ¶è®¾è®¡](#2-è®¿é—®æ§åˆ¶è®¾è®¡)
    - [2.1. è§’è‰²æƒé™æ¨¡å‹](#21-è§’è‰²æƒé™æ¨¡å‹)
    - [2.2. æƒé™æ£€æŸ¥å‡½æ•°](#22-æƒé™æ£€æŸ¥å‡½æ•°)
    - [2.3. PostgreSQLè¡Œçº§å®‰å…¨ï¼ˆRLSï¼‰æ‰©å±•](#23-postgresqlè¡Œçº§å®‰å…¨rlsæ‰©å±•)
  - [3. æ•°æ®åŠ å¯†è®¾è®¡](#3-æ•°æ®åŠ å¯†è®¾è®¡)
    - [3.1. å­—æ®µçº§åŠ å¯†](#31-å­—æ®µçº§åŠ å¯†)
    - [3.2. é€æ˜æ•°æ®åŠ å¯†ï¼ˆTDEï¼‰](#32-é€æ˜æ•°æ®åŠ å¯†tde)
    - [3.3. ä¼ è¾“åŠ å¯†](#33-ä¼ è¾“åŠ å¯†)
  - [4. æ•°æ®è„±æ•è®¾è®¡](#4-æ•°æ®è„±æ•è®¾è®¡)
    - [4.1. æ•°æ®è„±æ•å‡½æ•°](#41-æ•°æ®è„±æ•å‡½æ•°)
    - [4.2. è§†å›¾è„±æ•](#42-è§†å›¾è„±æ•)
  - [5. å®¡è®¡æ—¥å¿—è®¾è®¡](#5-å®¡è®¡æ—¥å¿—è®¾è®¡)
    - [5.1. å®¡è®¡æ—¥å¿—Schemaè®¾è®¡](#51-å®¡è®¡æ—¥å¿—schemaè®¾è®¡)
    - [5.2. å®¡è®¡è§¦å‘å™¨](#52-å®¡è®¡è§¦å‘å™¨)
    - [5.3. æŸ¥è¯¢å®¡è®¡](#53-æŸ¥è¯¢å®¡è®¡)
  - [6. å®‰å…¨é…ç½®æœ€ä½³å®è·µ](#6-å®‰å…¨é…ç½®æœ€ä½³å®è·µ)
    - [6.1. PostgreSQLå®‰å…¨é…ç½®](#61-postgresqlå®‰å…¨é…ç½®)
    - [6.2. å¯†ç ç­–ç•¥](#62-å¯†ç ç­–ç•¥)
  - [7. å®é™…åº”ç”¨æ¡ˆä¾‹](#7-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [7.1. é‡‘èç³»ç»Ÿå®‰å…¨è®¾è®¡](#71-é‡‘èç³»ç»Ÿå®‰å…¨è®¾è®¡)
  - [8. å‚è€ƒèµ„æ–™](#8-å‚è€ƒèµ„æ–™)

---

## 1. æ¦‚è¿°

æ•°æ®åº“å®‰å…¨è®¾è®¡æ˜¯ä¿æŠ¤æ•°æ®æœºå¯†æ€§ã€å®Œæ•´æ€§å’Œå¯ç”¨æ€§çš„å…³é”®ï¼ŒåŒ…æ‹¬è®¿é—®æ§åˆ¶ã€åŠ å¯†ã€å®¡è®¡ç­‰å¤šä¸ªæ–¹é¢ã€‚

### 1.1. æ•°æ®åº“å®‰å…¨å¨èƒ

```mermaid
mindmap
  root((å®‰å…¨å¨èƒ))
    æ•°æ®æ³„éœ²
      SQLæ³¨å…¥
      æƒé™æ»¥ç”¨
      æ•°æ®çªƒå–
    æ•°æ®ç¯¡æ”¹
      æœªæˆæƒä¿®æ”¹
      æ•°æ®å®Œæ•´æ€§ç ´å
    æœåŠ¡æ‹’ç»
      DDoSæ”»å‡»
      èµ„æºè€—å°½
    åˆè§„é£é™©
      æ•°æ®éšç§
      å®¡è®¡è¦æ±‚
```

### 1.2. å®‰å…¨è®¾è®¡å†³ç­–æ ‘

```mermaid
flowchart TD
    A[å®‰å…¨è®¾è®¡] --> B{æ•°æ®ç±»å‹}

    B -->|æ•æ„Ÿæ•°æ®| C[åŠ å¯†å­˜å‚¨]
    B -->|ä¸€èˆ¬æ•°æ®| D[è®¿é—®æ§åˆ¶]

    C --> E[è®¾è®¡å®Œæˆ]
    D --> F{è®¿é—®æ¨¡å¼}

    F -->|å†…éƒ¨è®¿é—®| G[è§’è‰²æƒé™]
    F -->|å¤–éƒ¨è®¿é—®| H[APIç½‘å…³]

    G --> E
    H --> E
```

---

## 2. è®¿é—®æ§åˆ¶è®¾è®¡

### 2.1. è§’è‰²æƒé™æ¨¡å‹

**RBACï¼ˆåŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶ï¼‰Schemaè®¾è®¡**ï¼š

```sql
CREATE SCHEMA security;

-- ç”¨æˆ·è¡¨
CREATE TABLE security.users (
    user_id BIGSERIAL PRIMARY KEY,
    username VARCHAR(100) NOT NULL UNIQUE,
    email VARCHAR(200) NOT NULL UNIQUE,
    password_hash TEXT NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    last_login_at TIMESTAMPTZ
);

-- è§’è‰²è¡¨
CREATE TABLE security.roles (
    role_id SERIAL PRIMARY KEY,
    role_name VARCHAR(100) NOT NULL UNIQUE,
    description TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- æƒé™è¡¨
CREATE TABLE security.permissions (
    permission_id SERIAL PRIMARY KEY,
    permission_name VARCHAR(100) NOT NULL UNIQUE,
    resource_type VARCHAR(100) NOT NULL,  -- table, schema, database
    resource_name VARCHAR(200) NOT NULL,
    action VARCHAR(50) NOT NULL,  -- SELECT, INSERT, UPDATE, DELETE
    description TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(resource_type, resource_name, action)
);

-- ç”¨æˆ·è§’è‰²å…³è”è¡¨
CREATE TABLE security.user_roles (
    user_id BIGINT NOT NULL REFERENCES security.users(user_id) ON DELETE CASCADE,
    role_id INTEGER NOT NULL REFERENCES security.roles(role_id) ON DELETE CASCADE,
    granted_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    granted_by BIGINT REFERENCES security.users(user_id),
    PRIMARY KEY (user_id, role_id)
);

-- è§’è‰²æƒé™å…³è”è¡¨
CREATE TABLE security.role_permissions (
    role_id INTEGER NOT NULL REFERENCES security.roles(role_id) ON DELETE CASCADE,
    permission_id INTEGER NOT NULL REFERENCES security.permissions(permission_id) ON DELETE CASCADE,
    granted_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (role_id, permission_id)
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_user_roles_user ON security.user_roles(user_id);
CREATE INDEX idx_user_roles_role ON security.user_roles(role_id);
CREATE INDEX idx_role_permissions_role ON security.role_permissions(role_id);
CREATE INDEX idx_role_permissions_permission ON security.role_permissions(permission_id);
```

### 2.2. æƒé™æ£€æŸ¥å‡½æ•°

**æƒé™æ£€æŸ¥å‡½æ•°å®ç°**ï¼š

```sql
-- æ£€æŸ¥ç”¨æˆ·æƒé™å‡½æ•°
CREATE OR REPLACE FUNCTION check_user_permission(
    p_user_id BIGINT,
    p_resource_type VARCHAR,
    p_resource_name VARCHAR,
    p_action VARCHAR
)
RETURNS BOOLEAN AS $$
DECLARE
    v_has_permission BOOLEAN;
BEGIN
    SELECT EXISTS (
        SELECT 1
        FROM security.user_roles ur
        JOIN security.role_permissions rp ON ur.role_id = rp.role_id
        JOIN security.permissions p ON rp.permission_id = p.permission_id
        WHERE ur.user_id = p_user_id
          AND p.resource_type = p_resource_type
          AND p.resource_name = p_resource_name
          AND p.action = p_action
    ) INTO v_has_permission;

    RETURN v_has_permission;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- è·å–ç”¨æˆ·æ‰€æœ‰æƒé™å‡½æ•°
CREATE OR REPLACE FUNCTION get_user_permissions(p_user_id BIGINT)
RETURNS TABLE (
    resource_type VARCHAR,
    resource_name VARCHAR,
    action VARCHAR
) AS $$
BEGIN
    RETURN QUERY
    SELECT DISTINCT
        p.resource_type,
        p.resource_name,
        p.action
    FROM security.user_roles ur
    JOIN security.role_permissions rp ON ur.role_id = rp.role_id
    JOIN security.permissions p ON rp.permission_id = p.permission_id
    WHERE ur.user_id = p_user_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

### 2.3. PostgreSQLè¡Œçº§å®‰å…¨ï¼ˆRLSï¼‰æ‰©å±•

**RLSå®‰å…¨ç­–ç•¥è®¾è®¡**ï¼š

```sql
-- å¯ç”¨RLS
ALTER TABLE business.orders ENABLE ROW LEVEL SECURITY;

-- åˆ›å»ºå®‰å…¨ç­–ç•¥ï¼šç”¨æˆ·åªèƒ½æŸ¥çœ‹è‡ªå·±çš„è®¢å•
CREATE POLICY orders_user_isolation ON business.orders
    FOR SELECT
    USING (user_id = current_user_id());

-- åˆ›å»ºå®‰å…¨ç­–ç•¥ï¼šç®¡ç†å‘˜å¯ä»¥æŸ¥çœ‹æ‰€æœ‰è®¢å•
CREATE POLICY orders_admin_access ON business.orders
    FOR ALL
    USING (
        EXISTS (
            SELECT 1 FROM security.user_roles ur
            JOIN security.roles r ON ur.role_id = r.role_id
            WHERE ur.user_id = current_user_id()
              AND r.role_name = 'admin'
        )
    );

-- åˆ›å»ºå®‰å…¨ç­–ç•¥ï¼šé”€å”®åªèƒ½æŸ¥çœ‹è‡ªå·±è´Ÿè´£çš„è®¢å•
CREATE POLICY orders_sales_access ON business.orders
    FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM business.order_assignments oa
            WHERE oa.order_id = business.orders.order_id
              AND oa.sales_user_id = current_user_id()
        )
    );
```

---

## 3. æ•°æ®åŠ å¯†è®¾è®¡

### 3.1. å­—æ®µçº§åŠ å¯†

**å­—æ®µåŠ å¯†Schemaè®¾è®¡**ï¼š

```sql
-- å¯ç”¨pgcryptoæ‰©å±•
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- æ•æ„Ÿæ•°æ®è¡¨ï¼ˆåŠ å¯†å­—æ®µï¼‰
CREATE TABLE security.sensitive_data (
    data_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL,
    -- åŠ å¯†å­—æ®µ
    encrypted_email BYTEA NOT NULL,
    encrypted_phone BYTEA NOT NULL,
    encrypted_ssn BYTEA NOT NULL,
    -- åŠ å¯†å¯†é’¥IDï¼ˆç”¨äºå¯†é’¥è½®æ¢ï¼‰
    encryption_key_id VARCHAR(50) NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- åŠ å¯†å‡½æ•°
CREATE OR REPLACE FUNCTION encrypt_field(
    p_value TEXT,
    p_key TEXT
)
RETURNS BYTEA AS $$
BEGIN
    RETURN pgp_sym_encrypt(p_value, p_key);
END;
$$ LANGUAGE plpgsql;

-- è§£å¯†å‡½æ•°
CREATE OR REPLACE FUNCTION decrypt_field(
    p_encrypted BYTEA,
    p_key TEXT
)
RETURNS TEXT AS $$
BEGIN
    RETURN pgp_sym_decrypt(p_encrypted, p_key);
END;
$$ LANGUAGE plpgsql;

-- æ’å…¥åŠ å¯†æ•°æ®
INSERT INTO security.sensitive_data (
    user_id,
    encrypted_email,
    encrypted_phone,
    encrypted_ssn,
    encryption_key_id
)
VALUES (
    123,
    encrypt_field('alice@example.com', 'encryption_key_2024'),
    encrypt_field('123-456-7890', 'encryption_key_2024'),
    encrypt_field('123-45-6789', 'encryption_key_2024'),
    'encryption_key_2024'
);

-- æŸ¥è¯¢è§£å¯†æ•°æ®ï¼ˆéœ€è¦å¯†é’¥ï¼‰
SELECT
    data_id,
    user_id,
    decrypt_field(encrypted_email, 'encryption_key_2024') AS email,
    decrypt_field(encrypted_phone, 'encryption_key_2024') AS phone,
    decrypt_field(encrypted_ssn, 'encryption_key_2024') AS ssn
FROM security.sensitive_data
WHERE user_id = 123;
```

### 3.2. é€æ˜æ•°æ®åŠ å¯†ï¼ˆTDEï¼‰

**TDEé…ç½®ç¤ºä¾‹**ï¼š

```sql
-- PostgreSQLé€æ˜æ•°æ®åŠ å¯†ï¼ˆéœ€è¦æ‰©å±•æ”¯æŒï¼‰
-- æ³¨æ„ï¼šPostgreSQLåŸç”Ÿä¸æ”¯æŒTDEï¼Œéœ€è¦ä½¿ç”¨æ‰©å±•å¦‚pg_tde

-- åˆ›å»ºåŠ å¯†è¡¨ç©ºé—´ï¼ˆå¦‚æœæ”¯æŒï¼‰
CREATE TABLESPACE encrypted_tablespace
LOCATION '/var/lib/postgresql/encrypted_data';

-- åœ¨åŠ å¯†è¡¨ç©ºé—´ä¸­åˆ›å»ºè¡¨
CREATE TABLE security.encrypted_table (
    id BIGSERIAL PRIMARY KEY,
    sensitive_data TEXT
) TABLESPACE encrypted_tablespace;
```

### 3.3. ä¼ è¾“åŠ å¯†

**SSL/TLSé…ç½®**ï¼š

```conf
# postgresql.conf
ssl = on
ssl_cert_file = '/etc/ssl/certs/server.crt'
ssl_key_file = '/etc/ssl/private/server.key'
ssl_ca_file = '/etc/ssl/certs/ca.crt'

# pg_hba.conf
hostssl    all    all    0.0.0.0/0    md5
```

---

## 4. æ•°æ®è„±æ•è®¾è®¡

### 4.1. æ•°æ®è„±æ•å‡½æ•°

**æ•°æ®è„±æ•å‡½æ•°å®ç°**ï¼š

```sql
-- é‚®ç®±è„±æ•å‡½æ•°
CREATE OR REPLACE FUNCTION mask_email(p_email TEXT)
RETURNS TEXT AS $$
DECLARE
    v_local_part TEXT;
    v_domain TEXT;
    v_masked_local TEXT;
BEGIN
    -- åˆ†ç¦»æœ¬åœ°éƒ¨åˆ†å’ŒåŸŸå
    v_local_part := split_part(p_email, '@', 1);
    v_domain := split_part(p_email, '@', 2);

    -- è„±æ•æœ¬åœ°éƒ¨åˆ†ï¼ˆä¿ç•™å‰2ä¸ªå­—ç¬¦ï¼‰
    IF length(v_local_part) > 2 THEN
        v_masked_local := left(v_local_part, 2) || repeat('*', length(v_local_part) - 2);
    ELSE
        v_masked_local := repeat('*', length(v_local_part));
    END IF;

    RETURN v_masked_local || '@' || v_domain;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- æ‰‹æœºå·è„±æ•å‡½æ•°
CREATE OR REPLACE FUNCTION mask_phone(p_phone TEXT)
RETURNS TEXT AS $$
BEGIN
    -- ä¿ç•™å‰3ä½å’Œå4ä½ï¼Œä¸­é—´ç”¨*æ›¿ä»£
    IF length(p_phone) >= 7 THEN
        RETURN left(p_phone, 3) || repeat('*', length(p_phone) - 7) || right(p_phone, 4);
    ELSE
        RETURN repeat('*', length(p_phone));
    END IF;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- èº«ä»½è¯å·è„±æ•å‡½æ•°
CREATE OR REPLACE FUNCTION mask_id_card(p_id_card TEXT)
RETURNS TEXT AS $$
BEGIN
    -- ä¿ç•™å‰6ä½å’Œå4ä½ï¼Œä¸­é—´ç”¨*æ›¿ä»£
    IF length(p_id_card) >= 10 THEN
        RETURN left(p_id_card, 6) || repeat('*', length(p_id_card) - 10) || right(p_id_card, 4);
    ELSE
        RETURN repeat('*', length(p_id_card));
    END IF;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- é“¶è¡Œå¡å·è„±æ•å‡½æ•°
CREATE OR REPLACE FUNCTION mask_card_number(p_card_number TEXT)
RETURNS TEXT AS $$
BEGIN
    -- ä¿ç•™å‰4ä½å’Œå4ä½ï¼Œä¸­é—´ç”¨*æ›¿ä»£
    IF length(p_card_number) >= 8 THEN
        RETURN left(p_card_number, 4) || repeat('*', length(p_card_number) - 8) || right(p_card_number, 4);
    ELSE
        RETURN repeat('*', length(p_card_number));
    END IF;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- ä½¿ç”¨ç¤ºä¾‹
SELECT
    user_id,
    mask_email(email) AS masked_email,
    mask_phone(phone) AS masked_phone,
    mask_id_card(id_card) AS masked_id_card
FROM security.users;
```

### 4.2. è§†å›¾è„±æ•

**è„±æ•è§†å›¾è®¾è®¡**ï¼š

```sql
-- åˆ›å»ºè„±æ•è§†å›¾
CREATE VIEW security.users_masked AS
SELECT
    user_id,
    username,
    mask_email(email) AS email,
    mask_phone(phone) AS phone,
    created_at
FROM security.users;

-- æˆäºˆè§†å›¾æƒé™ç»™æ™®é€šç”¨æˆ·
GRANT SELECT ON security.users_masked TO app_user;
```

---

## 5. å®¡è®¡æ—¥å¿—è®¾è®¡

### 5.1. å®¡è®¡æ—¥å¿—Schemaè®¾è®¡

**å®¡è®¡æ—¥å¿—è¡¨è®¾è®¡**ï¼š

```sql
CREATE SCHEMA audit;

-- å®¡è®¡æ—¥å¿—è¡¨
CREATE TABLE audit.audit_logs (
    log_id BIGSERIAL PRIMARY KEY,
    table_name VARCHAR(200) NOT NULL,
    operation VARCHAR(20) NOT NULL CHECK (operation IN ('INSERT', 'UPDATE', 'DELETE', 'SELECT')),
    user_id BIGINT,
    username VARCHAR(100),
    old_data JSONB,
    new_data JSONB,
    changed_fields TEXT[],
    ip_address INET,
    user_agent TEXT,
    session_id VARCHAR(100),
    executed_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
) PARTITION BY RANGE (executed_at);

-- åˆ›å»ºåˆ†åŒºï¼ˆæŒ‰æœˆï¼‰
CREATE TABLE audit.audit_logs_2024_01 PARTITION OF audit.audit_logs
FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

CREATE TABLE audit.audit_logs_2024_02 PARTITION OF audit.audit_logs
FOR VALUES FROM ('2024-02-01') TO ('2024-03-01');

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_audit_logs_table ON audit.audit_logs(table_name, executed_at DESC);
CREATE INDEX idx_audit_logs_user ON audit.audit_logs(user_id, executed_at DESC);
CREATE INDEX idx_audit_logs_operation ON audit.audit_logs(operation, executed_at DESC);
CREATE INDEX idx_audit_logs_executed ON audit.audit_logs(executed_at DESC);
```

### 5.2. å®¡è®¡è§¦å‘å™¨

**é€šç”¨å®¡è®¡è§¦å‘å™¨**ï¼š

```sql
-- é€šç”¨å®¡è®¡è§¦å‘å™¨å‡½æ•°
CREATE OR REPLACE FUNCTION audit_trigger_function()
RETURNS TRIGGER AS $$
DECLARE
    v_old_data JSONB;
    v_new_data JSONB;
    v_changed_fields TEXT[];
BEGIN
    -- è·å–å˜æ›´å­—æ®µ
    IF TG_OP = 'UPDATE' THEN
        v_old_data := row_to_json(OLD)::JSONB;
        v_new_data := row_to_json(NEW)::JSONB;

        -- è®¡ç®—å˜æ›´å­—æ®µ
        SELECT array_agg(key)
        INTO v_changed_fields
        FROM jsonb_each(v_old_data) old_kv
        JOIN jsonb_each(v_new_data) new_kv ON old_kv.key = new_kv.key
        WHERE old_kv.value IS DISTINCT FROM new_kv.value;
    ELSIF TG_OP = 'DELETE' THEN
        v_old_data := row_to_json(OLD)::JSONB;
        v_new_data := NULL;
    ELSE
        v_old_data := NULL;
        v_new_data := row_to_json(NEW)::JSONB;
    END IF;

    -- æ’å…¥å®¡è®¡æ—¥å¿—
    INSERT INTO audit.audit_logs (
        table_name,
        operation,
        user_id,
        username,
        old_data,
        new_data,
        changed_fields,
        ip_address,
        user_agent,
        session_id
    )
    VALUES (
        TG_TABLE_NAME,
        TG_OP,
        current_setting('app.user_id', TRUE)::BIGINT,
        current_setting('app.username', TRUE),
        v_old_data,
        v_new_data,
        v_changed_fields,
        inet_client_addr(),
        current_setting('app.user_agent', TRUE),
        current_setting('app.session_id', TRUE)
    );

    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

-- ä¸ºè¡¨åˆ›å»ºå®¡è®¡è§¦å‘å™¨
CREATE TRIGGER audit_users_trigger
AFTER INSERT OR UPDATE OR DELETE ON security.users
FOR EACH ROW
EXECUTE FUNCTION audit_trigger_function();
```

### 5.3. æŸ¥è¯¢å®¡è®¡

**æŸ¥è¯¢å®¡è®¡å‡½æ•°**ï¼š

```sql
-- æŸ¥è¯¢å®¡è®¡å‡½æ•°
CREATE OR REPLACE FUNCTION audit_query(
    p_table_name VARCHAR,
    p_query_text TEXT,
    p_result_count INTEGER
)
RETURNS VOID AS $$
BEGIN
    INSERT INTO audit.audit_logs (
        table_name,
        operation,
        user_id,
        username,
        new_data,
        ip_address,
        user_agent,
        session_id
    )
    VALUES (
        p_table_name,
        'SELECT',
        current_setting('app.user_id', TRUE)::BIGINT,
        current_setting('app.username', TRUE),
        jsonb_build_object('query', p_query_text, 'result_count', p_result_count),
        inet_client_addr(),
        current_setting('app.user_agent', TRUE),
        current_setting('app.session_id', TRUE)
    );
END;
$$ LANGUAGE plpgsql;
```

---

## 6. å®‰å…¨é…ç½®æœ€ä½³å®è·µ

### 6.1. PostgreSQLå®‰å…¨é…ç½®

**å®‰å…¨é…ç½®æ£€æŸ¥æ¸…å•**ï¼š

```sql
-- 1. æ£€æŸ¥SSLé…ç½®
SHOW ssl;

-- 2. æ£€æŸ¥å¯†ç åŠ å¯†
SHOW password_encryption;

-- 3. æ£€æŸ¥è¿æ¥é™åˆ¶
SHOW max_connections;

-- 4. æ£€æŸ¥æ—¥å¿—é…ç½®
SHOW log_statement;
SHOW log_connections;
SHOW log_disconnections;

-- 5. æ£€æŸ¥å¯†ç ç­–ç•¥ï¼ˆéœ€è¦æ‰©å±•ï¼‰
-- å®‰è£…passwordcheckæ‰©å±•
CREATE EXTENSION IF NOT EXISTS passwordcheck;
```

### 6.2. å¯†ç ç­–ç•¥

**å¯†ç ç­–ç•¥å‡½æ•°**ï¼š

```sql
-- å¯†ç å¤æ‚åº¦æ£€æŸ¥å‡½æ•°
CREATE OR REPLACE FUNCTION check_password_strength(p_password TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    -- æ£€æŸ¥å¯†ç é•¿åº¦ï¼ˆè‡³å°‘8ä½ï¼‰
    IF length(p_password) < 8 THEN
        RAISE EXCEPTION 'Password must be at least 8 characters long';
    END IF;

    -- æ£€æŸ¥æ˜¯å¦åŒ…å«æ•°å­—
    IF NOT (p_password ~ '[0-9]') THEN
        RAISE EXCEPTION 'Password must contain at least one digit';
    END IF;

    -- æ£€æŸ¥æ˜¯å¦åŒ…å«å¤§å†™å­—æ¯
    IF NOT (p_password ~ '[A-Z]') THEN
        RAISE EXCEPTION 'Password must contain at least one uppercase letter';
    END IF;

    -- æ£€æŸ¥æ˜¯å¦åŒ…å«å°å†™å­—æ¯
    IF NOT (p_password ~ '[a-z]') THEN
        RAISE EXCEPTION 'Password must contain at least one lowercase letter';
    END IF;

    -- æ£€æŸ¥æ˜¯å¦åŒ…å«ç‰¹æ®Šå­—ç¬¦
    IF NOT (p_password ~ '[!@#$%^&*(),.?":{}|<>]') THEN
        RAISE EXCEPTION 'Password must contain at least one special character';
    END IF;

    RETURN TRUE;
END;
$$ LANGUAGE plpgsql;

-- å¯†ç æ›´æ–°è§¦å‘å™¨
CREATE OR REPLACE FUNCTION validate_password_trigger()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.password_hash IS DISTINCT FROM OLD.password_hash THEN
        -- è¿™é‡Œåº”è¯¥æ£€æŸ¥æ–°å¯†ç çš„å¤æ‚åº¦
        -- ç®€åŒ–ç¤ºä¾‹ï¼šå‡è®¾password_hashå·²ç»åŠ å¯†
        PERFORM check_password_strength('dummy');  -- å®é™…åº”è¯¥è§£å¯†æ£€æŸ¥
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

---

## 7. å®é™…åº”ç”¨æ¡ˆä¾‹

### 7.1. é‡‘èç³»ç»Ÿå®‰å…¨è®¾è®¡

**é‡‘èç³»ç»Ÿå®‰å…¨Schemaè®¾è®¡**ï¼š

```sql
CREATE SCHEMA finance_security;

-- è´¦æˆ·è¡¨ï¼ˆåŠ å¯†æ•æ„Ÿå­—æ®µï¼‰
CREATE TABLE finance_security.accounts (
    account_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL,
    account_number_encrypted BYTEA NOT NULL,  -- åŠ å¯†è´¦æˆ·å·
    balance DECIMAL(15,2) NOT NULL,
    account_type VARCHAR(50) NOT NULL,
    encryption_key_id VARCHAR(50) NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- äº¤æ˜“è¡¨ï¼ˆå®Œæ•´å®¡è®¡ï¼‰
CREATE TABLE finance_security.transactions (
    transaction_id BIGSERIAL PRIMARY KEY,
    from_account_id BIGINT NOT NULL REFERENCES finance_security.accounts(account_id),
    to_account_id BIGINT NOT NULL REFERENCES finance_security.accounts(account_id),
    amount DECIMAL(15,2) NOT NULL,
    transaction_type VARCHAR(50) NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'pending',
    created_by BIGINT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    approved_by BIGINT,
    approved_at TIMESTAMPTZ
);

-- å¯ç”¨å®¡è®¡
CREATE TRIGGER audit_accounts_trigger
AFTER INSERT OR UPDATE OR DELETE ON finance_security.accounts
FOR EACH ROW
EXECUTE FUNCTION audit_trigger_function();

CREATE TRIGGER audit_transactions_trigger
AFTER INSERT OR UPDATE OR DELETE ON finance_security.transactions
FOR EACH ROW
EXECUTE FUNCTION audit_trigger_function();

-- åˆ›å»ºRLSç­–ç•¥ï¼šç”¨æˆ·åªèƒ½æŸ¥çœ‹è‡ªå·±çš„è´¦æˆ·
ALTER TABLE finance_security.accounts ENABLE ROW LEVEL SECURITY;

CREATE POLICY accounts_user_isolation ON finance_security.accounts
    FOR SELECT
    USING (user_id = current_user_id());
```

---

## 8. å‚è€ƒèµ„æ–™

- [å¤šç§Ÿæˆ·æ•°æ®åº“è®¾è®¡æ¨¡å¼](./07.20-å¤šç§Ÿæˆ·æ•°æ®åº“è®¾è®¡æ¨¡å¼.md)
- [æ•°æ®åº“è®¾è®¡æœ€ä½³å®è·µåº“](./07.14-æ•°æ®åº“è®¾è®¡æœ€ä½³å®è·µåº“.md)
- [PostgreSQLå®‰å…¨æ–‡æ¡£](https://www.postgresql.org/docs/current/security.html)

---

**æœ€åæ›´æ–°**ï¼š2025-01-15
**ç»´æŠ¤è€…**ï¼šData-Science Team
**çŠ¶æ€**ï¼šå®æ–½ä¸­
