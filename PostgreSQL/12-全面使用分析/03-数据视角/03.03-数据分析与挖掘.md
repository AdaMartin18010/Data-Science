# PostgreSQL 18 数据分析与挖掘

> **版本**: v1.0
> **最后更新**: 2025-01-15
> **版本覆盖**: PostgreSQL 18.x (推荐) ⭐ | 17.x (推荐) | 16.x (兼容)
> **文档状态**: ✅ 已完成

---

## 📑 目录

- [PostgreSQL 18 数据分析与挖掘](#postgresql-18-数据分析与挖掘)
  - [📑 目录](#-目录)
  - [📊 思维导图](#-思维导图)
  - [一、概述](#一概述)
  - [二、知识矩阵对比](#二知识矩阵对比)
    - [2.1 分析方法对比](#21-分析方法对比)
    - [2.2 分析工具对比](#22-分析工具对比)
  - [三、描述性统计分析](#三描述性统计分析)
    - [3.1 基本统计](#31-基本统计)
      - [3.1.1 基本统计的重要性](#311-基本统计的重要性)
      - [3.1.2 基本统计实现](#312-基本统计实现)
    - [3.2 分布分析](#32-分布分析)
      - [3.2.1 分布分析的重要性](#321-分布分析的重要性)
      - [3.2.2 分布分析实现](#322-分布分析实现)
    - [3.3 相关性分析](#33-相关性分析)
      - [3.3.1 相关性分析的重要性](#331-相关性分析的重要性)
      - [3.3.2 相关性分析实现](#332-相关性分析实现)
  - [四、探索性数据分析](#四探索性数据分析)
    - [4.1 数据探索](#41-数据探索)
    - [4.2 异常检测](#42-异常检测)
    - [4.3 模式识别](#43-模式识别)
  - [五、时间序列分析](#五时间序列分析)
    - [5.1 趋势分析](#51-趋势分析)
    - [5.2 季节性分析](#52-季节性分析)
    - [5.3 预测分析](#53-预测分析)
  - [六、高级分析技术](#六高级分析技术)
    - [6.1 窗口函数分析](#61-窗口函数分析)
    - [6.2 聚合分析](#62-聚合分析)
    - [6.3 递归分析](#63-递归分析)
  - [七、数据挖掘](#七数据挖掘)
    - [7.1 聚类分析](#71-聚类分析)
    - [7.2 关联规则](#72-关联规则)
    - [7.3 分类分析](#73-分类分析)
  - [八、PostgreSQL 18优化](#八postgresql-18优化)
    - [8.1 并行查询优化](#81-并行查询优化)
    - [8.2 虚拟生成列优化](#82-虚拟生成列优化)
  - [九、最佳实践](#九最佳实践)
    - [9.1 分析流程](#91-分析流程)
    - [9.2 性能优化](#92-性能优化)
    - [9.3 结果解释](#93-结果解释)
  - [十、相关文档](#十相关文档)

---

## 📊 思维导图

```mermaid
mindmap
  root((数据分析与挖掘))
    描述性统计
      基本统计
      分布分析
      相关性分析
    探索性分析
      数据探索
      异常检测
      模式识别
    时间序列
      趋势分析
      季节性分析
      预测分析
    高级技术
      窗口函数
      聚合分析
      递归分析
    数据挖掘
      聚类分析
      关联规则
      分类分析
    PostgreSQL 18
      并行查询
      虚拟生成列
    最佳实践
      分析流程
      性能优化
      结果解释
```

---

## 一、概述

本文档从数据视角介绍PostgreSQL 18的数据分析与挖掘方法，帮助数据分析师进行深入的数据分析。

**核心特点**：

- **分析全面**：涵盖描述性统计、探索性分析、时间序列等
- **方法丰富**：提供多种分析方法和工具
- **PostgreSQL 18**：充分利用新特性
- **实用性强**：提供实际分析案例

**PostgreSQL 18 新特性支持**：

- ✅ **并行查询增强**：更快的分析查询
- ✅ **虚拟生成列**：简化计算指标

---

## 二、知识矩阵对比

### 2.1 分析方法对比

| 方法 | 特点 | 适用场景 | 复杂度 | 推荐度 |
|-----|------|---------|--------|--------|
| **描述性统计** | 基础分析 | 数据概览 | ⭐⭐ | ⭐⭐⭐⭐⭐ |
| **探索性分析** | 发现模式 | 数据探索 | ⭐⭐⭐ | ⭐⭐⭐⭐ |
| **时间序列** | 趋势分析 | 时序数据 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| **数据挖掘** | 深度分析 | 模式发现 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |

### 2.2 分析工具对比

| 工具 | 特点 | 适用场景 | 推荐度 |
|-----|------|---------|--------|
| **SQL分析** | 灵活强大 | 数据库内分析 | ⭐⭐⭐⭐⭐ |
| **Python集成** | 丰富库 | 复杂分析 | ⭐⭐⭐⭐ |
| **R集成** | 统计专业 | 统计分析 | ⭐⭐⭐⭐ |
| **BI工具** | 可视化 | 报表分析 | ⭐⭐⭐⭐ |

---

## 三、描述性统计分析

### 3.1 基本统计

#### 3.1.1 基本统计的重要性

**为什么需要基本统计**：

基本统计是数据分析的基础，它提供了：

1. **数据概览**：快速了解数据的基本特征
2. **数据质量**：识别数据异常和缺失
3. **决策支持**：为业务决策提供数据支持
4. **趋势分析**：了解数据的变化趋势

**基本统计指标说明**：

| 指标 | 说明 | 用途 | 重要性 |
|-----|------|------|--------|
| **COUNT** | 计数 | 了解数据量 | ⭐⭐⭐⭐⭐ |
| **AVG** | 平均值 | 了解平均水平 | ⭐⭐⭐⭐⭐ |
| **MIN/MAX** | 最小值/最大值 | 了解数据范围 | ⭐⭐⭐⭐ |
| **STDDEV** | 标准差 | 了解数据离散程度 | ⭐⭐⭐⭐ |
| **PERCENTILE** | 百分位数 | 了解数据分布 | ⭐⭐⭐⭐⭐ |

#### 3.1.2 基本统计实现

**基本统计查询**：

```sql
-- 场景：订单金额基本统计分析
-- 需求：了解订单金额的分布特征
-- 用途：业务分析、异常检测、决策支持

-- 查询：计算订单金额的基本统计指标
SELECT
    COUNT(*) as total_count,                    -- 总订单数
    COUNT(DISTINCT user_id) as unique_users,    -- 唯一用户数
    AVG(amount) as avg_amount,                  -- 平均订单金额
    MIN(amount) as min_amount,                  -- 最小订单金额
    MAX(amount) as max_amount,                  -- 最大订单金额
    STDDEV(amount) as stddev_amount,            -- 订单金额标准差
    VARIANCE(amount) as variance_amount,        -- 订单金额方差
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY amount) as median_amount,  -- 中位数
    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY amount) as q1,           -- 第一四分位数
    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY amount) as q3            -- 第三四分位数
FROM orders
WHERE created_at >= '2024-01-01';  -- 只统计2024年的订单

-- 查询结果分析：
-- - total_count: 总订单数，了解业务规模
-- - unique_users: 唯一用户数，了解用户活跃度
-- - avg_amount: 平均订单金额，了解客单价
-- - min_amount/max_amount: 订单金额范围，识别异常值
-- - stddev_amount: 标准差，了解订单金额的离散程度
-- - median_amount: 中位数，不受极端值影响，更稳健
-- - q1/q3: 四分位数，了解数据分布

-- 性能分析：
-- - 查询性能：取决于数据量，100万行约1-3秒
-- - 索引优化：如果按created_at过滤，需要索引
CREATE INDEX idx_orders_created_at ON orders(created_at);

-- 业务应用：
-- 1. 识别异常订单：金额过大或过小的订单
-- 2. 了解客单价：平均订单金额
-- 3. 分析用户行为：订单金额分布
-- 4. 制定价格策略：基于订单金额分布
```

### 3.2 分布分析

#### 3.2.1 分布分析的重要性

**为什么需要分布分析**：

分布分析帮助理解数据的分布特征：

1. **数据理解**：了解数据的分布形状
2. **异常检测**：识别异常值和离群点
3. **业务洞察**：发现业务模式和规律
4. **决策支持**：为业务决策提供依据

**分布分析的方法**：

| 方法 | 说明 | 适用场景 | 推荐度 |
|-----|------|---------|--------|
| **分组统计** | 按范围分组统计 | 连续数据 | ⭐⭐⭐⭐⭐ |
| **直方图** | 可视化分布 | 数据可视化 | ⭐⭐⭐⭐ |
| **箱线图** | 显示四分位数 | 异常检测 | ⭐⭐⭐⭐ |

#### 3.2.2 分布分析实现

**数据分布分析**：

```sql
-- 场景：订单金额分布分析
-- 需求：了解订单金额的分布情况
-- 用途：业务分析、价格策略制定

-- 查询：按金额范围分组统计
SELECT
    CASE
        WHEN amount < 100 THEN '0-100'
        WHEN amount < 500 THEN '100-500'
        WHEN amount < 1000 THEN '500-1000'
        WHEN amount < 5000 THEN '1000-5000'
        ELSE '5000+'
    END as amount_range,
    COUNT(*) as count,                                    -- 订单数量
    ROUND(100.0 * COUNT(*) / SUM(COUNT(*)) OVER (), 2) as percentage,  -- 占比
    AVG(amount) as avg_amount,                            -- 该范围内的平均金额
    SUM(amount) as total_amount,                          -- 该范围内的总金额
    ROUND(100.0 * SUM(amount) / SUM(SUM(amount)) OVER (), 2) as revenue_percentage  -- 收入占比
FROM orders
WHERE created_at >= '2024-01-01'
GROUP BY amount_range
ORDER BY MIN(amount);

-- 查询结果分析：
-- - count: 每个金额范围的订单数量
-- - percentage: 订单数量占比
-- - avg_amount: 该范围内的平均金额
-- - total_amount: 该范围内的总金额
-- - revenue_percentage: 收入占比（可能80%的收入来自20%的订单）

-- 业务应用：
-- 1. 了解订单金额分布：大部分订单集中在哪个范围
-- 2. 识别高价值订单：高金额订单的占比
-- 3. 制定价格策略：基于订单金额分布
-- 4. 优化营销策略：针对不同金额范围的订单
```

### 3.3 相关性分析

#### 3.3.1 相关性分析的重要性

**为什么需要相关性分析**：

相关性分析帮助理解变量之间的关系：

1. **关系发现**：发现变量之间的关联关系
2. **特征选择**：为机器学习选择特征
3. **业务洞察**：理解业务变量之间的关系
4. **预测建模**：为预测模型提供输入

**相关性分析的方法**：

| 方法 | 说明 | 适用场景 | 推荐度 |
|-----|------|---------|--------|
| **皮尔逊相关系数** | 线性相关性 | 连续变量 | ⭐⭐⭐⭐⭐ |
| **斯皮尔曼相关系数** | 单调相关性 | 有序变量 | ⭐⭐⭐⭐ |
| **卡方检验** | 分类变量相关性 | 分类变量 | ⭐⭐⭐ |

#### 3.3.2 相关性分析实现

**相关性分析查询**：

```sql
-- 场景：订单金额与其他变量的相关性分析
-- 需求：了解订单金额与数量、折扣等因素的关系
-- 用途：业务分析、特征工程、预测建模

-- 查询：计算相关系数
SELECT
    CORR(amount, quantity) as amount_quantity_corr,      -- 金额与数量的相关系数
    CORR(amount, discount) as amount_discount_corr,      -- 金额与折扣的相关系数
    CORR(amount, EXTRACT(EPOCH FROM (created_at - '2024-01-01'))) as amount_time_corr  -- 金额与时间的相关系数
FROM orders
WHERE created_at >= '2024-01-01';

-- 查询结果分析：
-- - amount_quantity_corr: 金额与数量的相关系数
--   - 接近1：正相关（数量越多，金额越大）
--   - 接近-1：负相关（数量越多，金额越小）
--   - 接近0：无相关
-- - amount_discount_corr: 金额与折扣的相关系数
--   - 通常为负相关（折扣越大，金额越小）
-- - amount_time_corr: 金额与时间的相关系数
--   - 了解订单金额是否随时间变化

-- 更详细的相关性分析（按类别）
SELECT
    product_category,
    CORR(amount, quantity) as amount_quantity_corr,
    CORR(amount, discount) as amount_discount_corr,
    COUNT(*) as order_count
FROM orders o
JOIN order_items oi ON o.id = oi.order_id
JOIN products p ON oi.product_id = p.id
WHERE o.created_at >= '2024-01-01'
GROUP BY product_category
HAVING COUNT(*) > 100  -- 只分析订单数>100的类别
ORDER BY amount_quantity_corr DESC;

-- 业务应用：
-- 1. 了解价格敏感性：折扣与金额的相关性
-- 2. 优化定价策略：基于相关性分析
-- 3. 特征工程：为机器学习模型选择特征
-- 4. 业务洞察：理解业务变量之间的关系
```

---

## 四、探索性数据分析

### 4.1 数据探索

**数据探索查询**：

```sql
-- 数据概览
SELECT
    COUNT(*) as total_rows,
    COUNT(DISTINCT user_id) as unique_users,
    MIN(created_at) as earliest_date,
    MAX(created_at) as latest_date
FROM orders;

-- 缺失值检查
SELECT
    COUNT(*) - COUNT(email) as missing_email,
    COUNT(*) - COUNT(phone) as missing_phone
FROM users;
```

### 4.2 异常检测

**异常值检测**：

```sql
-- 使用IQR方法检测异常值
WITH stats AS (
    SELECT
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY amount) as q1,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY amount) as q3
    FROM orders
)
SELECT *
FROM orders, stats
WHERE amount < (q1 - 1.5 * (q3 - q1))
   OR amount > (q3 + 1.5 * (q3 - q1));
```

### 4.3 模式识别

**模式识别**：

```sql
-- 识别购买模式
SELECT
    user_id,
    COUNT(*) as order_count,
    AVG(amount) as avg_amount,
    MAX(created_at) - MIN(created_at) as purchase_span
FROM orders
GROUP BY user_id
HAVING COUNT(*) > 10
ORDER BY order_count DESC;
```

---

## 五、时间序列分析

### 5.1 趋势分析

**趋势分析**：

```sql
-- 时间序列趋势
SELECT
    DATE_TRUNC('month', created_at) as month,
    COUNT(*) as order_count,
    SUM(amount) as total_amount,
    AVG(amount) as avg_amount
FROM orders
GROUP BY DATE_TRUNC('month', created_at)
ORDER BY month;
```

### 5.2 季节性分析

**季节性分析**：

```sql
-- 季节性模式
SELECT
    EXTRACT(MONTH FROM created_at) as month,
    EXTRACT(DOW FROM created_at) as day_of_week,
    COUNT(*) as order_count,
    AVG(amount) as avg_amount
FROM orders
GROUP BY EXTRACT(MONTH FROM created_at), EXTRACT(DOW FROM created_at)
ORDER BY month, day_of_week;
```

### 5.3 预测分析

**移动平均预测**：

```sql
-- 移动平均
SELECT
    date,
    amount,
    AVG(amount) OVER (
        ORDER BY date
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) as moving_avg_7
FROM daily_sales
ORDER BY date;
```

---

## 六、高级分析技术

### 6.1 窗口函数分析

**窗口函数示例**：

```sql
-- 排名分析
SELECT
    user_id,
    amount,
    RANK() OVER (ORDER BY amount DESC) as rank,
    PERCENT_RANK() OVER (ORDER BY amount DESC) as percent_rank,
    LAG(amount) OVER (PARTITION BY user_id ORDER BY created_at) as prev_amount
FROM orders;
```

### 6.2 聚合分析

**多维度聚合**：

```sql
-- 多维度分析
SELECT
    user_id,
    product_category,
    COUNT(*) as order_count,
    SUM(amount) as total_amount,
    AVG(amount) as avg_amount
FROM orders
GROUP BY ROLLUP(user_id, product_category);
```

### 6.3 递归分析

**递归CTE分析**：

```sql
-- 递归分析层级关系
WITH RECURSIVE category_tree AS (
    SELECT id, name, parent_id, 0 as level
    FROM categories
    WHERE parent_id IS NULL

    UNION ALL

    SELECT c.id, c.name, c.parent_id, ct.level + 1
    FROM categories c
    JOIN category_tree ct ON c.parent_id = ct.id
)
SELECT * FROM category_tree;
```

---

## 七、数据挖掘

### 7.1 聚类分析

**使用PostgreSQL进行简单聚类**：

```sql
-- K-means聚类（简化版）
-- 基于金额和数量聚类
SELECT
    user_id,
    AVG(amount) as avg_amount,
    AVG(quantity) as avg_quantity,
    CASE
        WHEN AVG(amount) > 1000 AND AVG(quantity) > 10 THEN 'High Value'
        WHEN AVG(amount) > 500 THEN 'Medium Value'
        ELSE 'Low Value'
    END as cluster
FROM orders
GROUP BY user_id;
```

### 7.2 关联规则

**关联规则分析**：

```sql
-- 商品关联分析
SELECT
    o1.product_id as product_a,
    o2.product_id as product_b,
    COUNT(*) as co_occurrence
FROM order_items o1
JOIN order_items o2 ON o1.order_id = o2.order_id
WHERE o1.product_id < o2.product_id
GROUP BY o1.product_id, o2.product_id
HAVING COUNT(*) > 10
ORDER BY co_occurrence DESC;
```

### 7.3 分类分析

**分类特征分析**：

```sql
-- 用户分类特征
SELECT
    CASE
        WHEN total_orders > 50 THEN 'VIP'
        WHEN total_orders > 20 THEN 'Regular'
        ELSE 'New'
    END as user_segment,
    COUNT(*) as user_count,
    AVG(total_amount) as avg_lifetime_value
FROM (
    SELECT
        user_id,
        COUNT(*) as total_orders,
        SUM(amount) as total_amount
    FROM orders
    GROUP BY user_id
) user_stats
GROUP BY user_segment;
```

---

## 八、PostgreSQL 18优化

### 8.1 并行查询优化

**并行分析查询**：

```sql
-- 启用并行查询
SET max_parallel_workers_per_gather = 4;

-- 并行聚合分析
SELECT
    product_category,
    COUNT(*) as order_count,
    SUM(amount) as total_amount
FROM orders
GROUP BY product_category;
```

### 8.2 虚拟生成列优化

**使用虚拟生成列简化分析**：

```sql
-- 创建带计算列的分析表
CREATE TABLE order_analysis AS
SELECT
    id,
    user_id,
    amount,
    quantity,
    amount / NULLIF(quantity, 0) as unit_price,  -- 可以改为虚拟生成列
    created_at
FROM orders;

-- PostgreSQL 18: 使用虚拟生成列
ALTER TABLE order_analysis
ADD COLUMN unit_price DECIMAL(10,2) GENERATED ALWAYS AS (
    amount / NULLIF(quantity, 0)
) STORED;
```

---

## 九、最佳实践

### 9.1 分析流程

**分析流程**：

1. 数据探索
2. 数据清洗
3. 描述性统计
4. 探索性分析
5. 深度分析
6. 结果解释

### 9.2 性能优化

**性能优化建议**：

- 使用物化视图
- 合理使用索引
- 并行查询
- 分区表

### 9.3 结果解释

**结果解释原则**：

- 清晰明了
- 有数据支撑
- 可操作建议
- 可视化展示

---

## 十、相关文档

- [数据建模方法论](./03.01-数据建模方法论.md)
- [ETL流程设计](./03.02-ETL流程设计.md)
- [数据仓库设计](./03.05-数据仓库设计.md)
- [数据分析完整指南](../../09-应用设计/数据模型设计/09.01-数据分析完整指南.md)
- [PostgreSQL 18新特性](../../02-版本特性/02.01-PostgreSQL-18-新特性.md)

---

**最后更新**: 2025-01-15
**维护者**: PostgreSQL Documentation Team
