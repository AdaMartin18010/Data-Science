# 集群部署与高可用

> **文档版本**: v2.0
> **最后更新**: 2025-11-12
> **版本覆盖**: PostgreSQL 18.x (推荐) ⭐ | 17.x (推荐) | 16.x (兼容)
> **文档状态**: ✅ 已更新

---

## 📋 目录

- [集群部署与高可用](#集群部署与高可用)
  - [📋 目录](#-目录)
  - [1. 概述](#1-概述)
  - [2. 合并来源与映射](#2-合并来源与映射)
  - [3. 复制架构](#3-复制架构)
    - [3.1 物理复制最小示例](#31-物理复制最小示例)
      - [步骤1: 主库配置](#步骤1-主库配置)
      - [步骤2: 从库初始化](#步骤2-从库初始化)
      - [步骤3: 从库配置](#步骤3-从库配置)
      - [步骤4: 验证复制](#步骤4-验证复制)
    - [3.2 同步策略与仲裁](#32-同步策略与仲裁)
      - [synchronous\_commit级别](#synchronous_commit级别)
      - [synchronous\_standby\_names配置](#synchronous_standby_names配置)
  - [4. 高可用组件](#4-高可用组件)
    - [4.1 Patroni 基本配置示例](#41-patroni-基本配置示例)
      - [步骤1: 安装etcd集群](#步骤1-安装etcd集群)
      - [步骤2: 安装Patroni](#步骤2-安装patroni)
      - [步骤3: 配置keepalived（VIP）](#步骤3-配置keepalivedvip)
      - [步骤4: 配置pgpool-II（读写分离）](#步骤4-配置pgpool-ii读写分离)
  - [5. 故障演练](#5-故障演练)
    - [5.1 故障切换SOP（Patroni）](#51-故障切换soppatroni)
      - [场景1: 主库故障（自动切换）](#场景1-主库故障自动切换)
      - [场景2: 手动切换（维护场景）](#场景2-手动切换维护场景)
      - [场景3: 旧主库恢复](#场景3-旧主库恢复)
    - [5.2 只读副本延迟监控](#52-只读副本延迟监控)
    - [5.3 RTO/RPO评估](#53-rtorpo评估)
  - [6. 后续整合任务](#6-后续整合任务)

---

## 1. 概述

- 主从、同步/异步复制、故障转移、读写分离

## 2. 合并来源与映射

- 1.1.5-分布式与高可用.md
- 1.1.9-分布式PostgreSQL架构设计.md

## 3. 复制架构

- 物理复制/逻辑复制、同步策略、仲裁与漂移

### 3.1 物理复制最小示例

```sql
-- 主库创建复制槽（可选，但推荐避免WAL回收过快）
SELECT * FROM pg_create_physical_replication_slot('replica1');
```

`postgresql.conf`（主库）：

```text
wal_level = replica
max_wal_senders = 10
max_replication_slots = 10
wal_keep_size = '1GB'
```

`pg_hba.conf`：

```text
host replication repl 10.0.0.0/24 md5
```

从库初始化：

```bash
pg_basebackup -h primary -U repl -D $PGDATA -X stream -R -C -S replica1
```

**完整物理复制配置步骤**：

#### 步骤1: 主库配置

```bash
# 1. 创建复制用户
sudo -u postgres psql -c "
CREATE USER repl WITH REPLICATION PASSWORD 'secure_password';
"

# 2. 配置postgresql.conf
sudo nano /etc/postgresql/18/main/postgresql.conf
```

```conf
# 主库配置
wal_level = replica
max_wal_senders = 10
max_replication_slots = 10
wal_keep_size = 1GB
hot_standby = on
hot_standby_feedback = on
```

```bash
# 3. 配置pg_hba.conf
sudo nano /etc/postgresql/18/main/pg_hba.conf
```

```conf
# 允许复制连接
host replication repl 192.168.1.0/24 md5
```

```bash
# 4. 重启PostgreSQL
sudo systemctl restart postgresql

# 5. 创建复制槽
sudo -u postgres psql -c "
SELECT pg_create_physical_replication_slot('replica1');
SELECT pg_create_physical_replication_slot('replica2');
"
```

#### 步骤2: 从库初始化

```bash
# 1. 停止从库（如果已运行）
sudo systemctl stop postgresql

# 2. 备份数据目录（如果存在）
sudo mv /var/lib/postgresql/18/main /var/lib/postgresql/18/main.backup

# 3. 使用pg_basebackup初始化
sudo -u postgres pg_basebackup \
    -h 192.168.1.10 \
    -U repl \
    -D /var/lib/postgresql/18/main \
    -X stream \
    -R \
    -C \
    -S replica1 \
    -P \
    -v

# 参数说明：
# -h: 主库地址
# -U: 复制用户
# -D: 数据目录
# -X stream: 流式传输WAL
# -R: 自动配置recovery
# -C: 创建复制槽
# -S: 复制槽名称
# -P: 显示进度
# -v: 详细输出
```

#### 步骤3: 从库配置

```bash
# 检查standby.signal文件（pg_basebackup -R会自动创建）
cat /var/lib/postgresql/18/main/standby.signal

# 检查postgresql.auto.conf
cat /var/lib/postgresql/18/main/postgresql.auto.conf
```

```conf
# postgresql.auto.conf（自动生成）
primary_conninfo = 'user=repl password=secure_password host=192.168.1.10 port=5432 sslmode=prefer sslcompression=0 gssencmode=prefer krbsrvname=postgres target_session_attrs=any'
primary_slot_name = 'replica1'
```

```bash
# 4. 启动从库
sudo systemctl start postgresql

# 5. 检查复制状态
sudo -u postgres psql -c "
SELECT application_name, state, sync_state,
       pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) AS lag_bytes
FROM pg_stat_replication;
"
```

#### 步骤4: 验证复制

```sql
-- 在主库创建测试数据
CREATE TABLE test_replication (id SERIAL PRIMARY KEY, data TEXT);
INSERT INTO test_replication (data) VALUES ('test1'), ('test2');

-- 在从库验证（需要等待复制）
SELECT * FROM test_replication;
```

### 3.2 同步策略与仲裁

- `synchronous_commit`：local | remote_write | remote_apply | on | off
- `synchronous_standby_names`：指定候选与法定人数（Quorum）：

  ```text
  synchronous_standby_names = 'ANY 1 (node_b, node_c)'
  ```

- 与业务SLA的RPO/RTO权衡：强同步提升一致性但拉高写延迟。

**同步策略详解**：

#### synchronous_commit级别

```sql
-- 1. local（默认，异步）
-- 事务在本地提交即可，不等待从库确认
ALTER SYSTEM SET synchronous_commit = 'local';
-- 优点：性能最好，延迟最低
-- 缺点：主库故障可能丢失数据

-- 2. remote_write
-- 等待WAL写入从库操作系统缓存
ALTER SYSTEM SET synchronous_commit = 'remote_write';
-- 优点：性能较好，数据已到达从库
-- 缺点：从库崩溃仍可能丢失数据

-- 3. remote_apply
-- 等待从库应用WAL（最严格）
ALTER SYSTEM SET synchronous_commit = 'remote_apply';
-- 优点：数据一致性最强
-- 缺点：性能最差，延迟最高

-- 4. on（等同于remote_write）
ALTER SYSTEM SET synchronous_commit = 'on';

-- 5. off（等同于local，已废弃）
-- 不推荐使用
```

#### synchronous_standby_names配置

```conf
# postgresql.conf

# 方式1: 指定单个同步从库
synchronous_standby_names = 'replica1'

# 方式2: 指定多个候选从库，任意一个确认即可
synchronous_standby_names = 'ANY 1 (replica1, replica2, replica3)'

# 方式3: 指定多个候选从库，需要2个确认（Quorum）
synchronous_standby_names = 'ANY 2 (replica1, replica2, replica3)'

# 方式4: 指定优先级（第一个是同步，其他是候选）
synchronous_standby_names = 'FIRST 1 (replica1, replica2, replica3)'

# 方式5: 需要所有列出的从库确认
synchronous_standby_names = 'ALL (replica1, replica2)'
```

**配置示例**：

```bash
# 主库配置（三节点：1主2从）
sudo nano /etc/postgresql/18/main/postgresql.conf
```

```conf
# 同步复制配置
synchronous_commit = 'remote_write'
synchronous_standby_names = 'ANY 1 (replica1, replica2)'

# 从库配置（在从库的postgresql.conf中）
hot_standby = on
hot_standby_feedback = on
```

```bash
# 重新加载配置
sudo systemctl reload postgresql

# 验证同步状态
sudo -u postgres psql -c "
SELECT application_name, sync_state, sync_priority,
       pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) AS lag_bytes
FROM pg_stat_replication;
"
```

**RPO/RTO权衡**：

| 配置 | RPO | RTO | 写延迟 | 适用场景 |
|------|-----|-----|--------|---------|
| `local` | 可能丢失数据 | 快 | 最低 | 非关键业务 |
| `remote_write` | 几乎为0 | 中等 | 低 | 一般业务 |
| `remote_apply` | 0 | 慢 | 高 | 关键业务 |
| `ANY 1` | 几乎为0 | 快 | 低 | 高可用场景 |
| `ANY 2` | 0 | 中等 | 中 | 强一致性场景 |

## 4. 高可用组件

- Patroni、pgpool-II、pgbouncer、keepalived

### 4.1 Patroni 基本配置示例

```yaml
scope: pg
namespace: /service/pg
name: node_a

restapi:
  listen: 0.0.0.0:8008
  connect_address: node_a:8008

etcd:
  hosts: [etcd1:2379, etcd2:2379, etcd3:2379]

postgresql:
  listen: 0.0.0.0:5432
  connect_address: node_a:5432
  data_dir: /var/lib/postgresql/data
  bin_dir: /usr/lib/postgresql/16/bin
  parameters:
    wal_level: replica
    max_wal_senders: 10
    max_replication_slots: 10
    synchronous_commit: 'on'
    synchronous_standby_names: 'ANY 1 (node_b, node_c)'
  pg_hba:
    - host all all 0.0.0.0/0 md5
    - host replication repl 0.0.0.0/0 md5
  authentication:
    replication:
      username: repl
      password: "***"
    superuser:
      username: postgres
      password: "***"
```

**完整Patroni部署**：

#### 步骤1: 安装etcd集群

```bash
# 在每个etcd节点上
wget https://github.com/etcd-io/etcd/releases/download/v3.5.9/etcd-v3.5.9-linux-amd64.tar.gz
tar -xzf etcd-v3.5.9-linux-amd64.tar.gz
sudo mv etcd-v3.5.9-linux-amd64/etcd* /usr/local/bin/

# 创建etcd配置
sudo mkdir -p /etc/etcd
sudo nano /etc/etcd/etcd.conf
```

```conf
# etcd1配置
ETCD_NAME=etcd1
ETCD_DATA_DIR=/var/lib/etcd
ETCD_LISTEN_CLIENT_URLS=http://0.0.0.0:2379
ETCD_ADVERTISE_CLIENT_URLS=http://etcd1:2379
ETCD_INITIAL_CLUSTER="etcd1=http://etcd1:2380,etcd2=http://etcd2:2380,etcd3=http://etcd3:2380"
ETCD_INITIAL_CLUSTER_TOKEN=etcd-cluster-1
ETCD_INITIAL_CLUSTER_STATE=new
```

```bash
# 启动etcd
sudo systemctl start etcd
sudo systemctl enable etcd

# 验证etcd集群
etcdctl --endpoints=http://etcd1:2379,http://etcd2:2379,http://etcd3:2379 endpoint health
```

#### 步骤2: 安装Patroni

```bash
# 安装Patroni
sudo pip3 install patroni[etcd]

# 创建Patroni配置目录
sudo mkdir -p /etc/patroni
sudo nano /etc/patroni/patroni.yml
```

```yaml
# 完整Patroni配置示例
scope: postgres
namespace: /db/postgres
name: node1

restapi:
  listen: 0.0.0.0:8008
  connect_address: node1:8008
  authentication:
    username: admin
    password: admin_password

etcd:
  hosts: etcd1:2379, etcd2:2379, etcd3:2379
  protocol: http

bootstrap:
  dcs:
    ttl: 30
    loop_wait: 10
    retry_timeout: 30
    maximum_lag_on_failover: 1048576
    postgresql:
      use_pg_rewind: true
      parameters:
        wal_level: replica
        hot_standby: on
        max_connections: 100
        max_wal_senders: 10
        max_replication_slots: 10
        wal_keep_size: 1GB
        synchronous_commit: 'on'
        synchronous_standby_names: 'ANY 1 (node2, node3)'
  initdb:
    - encoding: UTF8
    - data-checksums
  pg_hba:
    - host replication repl 0.0.0.0/0 md5
    - host all all 0.0.0.0/0 md5
  users:
    admin:
      password: admin_password
      options:
        - createrole
        - createdb

postgresql:
  listen: 0.0.0.0:5432
  connect_address: node1:5432
  data_dir: /var/lib/postgresql/18/data
  bin_dir: /usr/lib/postgresql/18/bin
  pgpass: /var/lib/postgresql/.pgpass
  parameters:
    unix_socket_directories: '/var/run/postgresql'
  authentication:
    replication:
      username: repl
      password: repl_password
    superuser:
      username: postgres
      password: postgres_password

tags:
  nofailover: false
  noloadbalance: false
  clonefrom: false
  nosync: false
```

```bash
# 创建systemd服务
sudo nano /etc/systemd/system/patroni.service
```

```ini
[Unit]
Description=Patroni PostgreSQL High Availability
After=syslog.target network.target

[Service]
Type=simple
User=postgres
Group=postgres
ExecStart=/usr/local/bin/patroni /etc/patroni/patroni.yml
KillMode=process
TimeoutSec=30
Restart=on-failure

[Install]
WantedBy=multi-user.target
```

```bash
# 启动Patroni
sudo systemctl daemon-reload
sudo systemctl enable patroni
sudo systemctl start patroni

# 检查状态
patronictl -c /etc/patroni/patroni.yml list
```

#### 步骤3: 配置keepalived（VIP）

```bash
# 安装keepalived
sudo apt-get install -y keepalived

# 主节点配置
sudo nano /etc/keepalived/keepalived.conf
```

```conf
vrrp_script chk_patroni {
    script "/usr/local/bin/check_patroni.sh"
    interval 2
    weight -2
    fall 3
    rise 2
}

vrrp_instance VI_1 {
    state MASTER
    interface eth0
    virtual_router_id 51
    priority 101
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass keepalived_pass
    }
    virtual_ipaddress {
        192.168.1.100/24
    }
    track_script {
        chk_patroni
    }
}
```

```bash
# 创建检查脚本
sudo nano /usr/local/bin/check_patroni.sh
```

```bash
#!/bin/bash
# 检查Patroni是否为主节点
if patronictl -c /etc/patroni/patroni.yml list | grep -q "Leader.*node1"; then
    exit 0
else
    exit 1
fi
```

```bash
sudo chmod +x /usr/local/bin/check_patroni.sh
sudo systemctl start keepalived
sudo systemctl enable keepalived
```

#### 步骤4: 配置pgpool-II（读写分离）

```bash
# 安装pgpool-II
sudo apt-get install -y pgpool2

# 配置pgpool.conf
sudo nano /etc/pgpool2/pgpool.conf
```

```conf
listen_addresses = '*'
port = 5432
socket_dir = '/var/run/postgresql'

# 后端节点配置
backend_hostname0 = '192.168.1.100'  # VIP
backend_port0 = 5432
backend_weight0 = 1
backend_flag0 = 'ALLOW_TO_FAILOVER'

backend_hostname1 = 'node2'
backend_port1 = 5432
backend_weight1 = 1
backend_flag1 = 'ALLOW_TO_FAILOVER'

backend_hostname2 = 'node3'
backend_port2 = 5432
backend_weight2 = 1
backend_flag2 = 'ALLOW_TO_FAILOVER'

# 负载均衡
load_balance_mode = on
master_slave_mode = on
master_slave_sub_mode = 'stream'

# 故障转移
failover_on_backend_error = on
```

```bash
# 启动pgpool-II
sudo systemctl start pgpool2
sudo systemctl enable pgpool2
```

虚拟IP/负载均衡：

- 主写 VIP：`keepalived` 绑定主节点；
- 读负载均衡：`pgpool-II`/`haproxy` 转发至只读副本；
- 应用侧强制读写分离与重试策略。

## 5. 故障演练

- 失效与恢复流程、RTO/RPO 评估

### 5.1 故障切换SOP（Patroni）

1) 人为下线主库：`patroni_ctl pause`（演练时）或停止服务；
2) 观察Leader 选举日志与复制延迟，确认新主；
3) 业务侧：写连接指向主写 VIP，读连接检查连接池刷新；
4) 旧主恢复为副本：清理WAL 冲突、重新 `pg_basebackup` 或 `recovery` 追日志。

**完整故障切换流程**：

#### 场景1: 主库故障（自动切换）

```bash
# 1. 模拟主库故障
sudo systemctl stop patroni  # 在主库节点

# 2. 观察Patroni日志（在从库节点）
sudo journalctl -u patroni -f

# 3. 检查新主库选举
patronictl -c /etc/patroni/patroni.yml list

# 4. 验证VIP切换
ip addr show | grep 192.168.1.100

# 5. 验证应用连接
psql -h 192.168.1.100 -U postgres -d mydb -c "SELECT pg_is_in_recovery();"
```

#### 场景2: 手动切换（维护场景）

```bash
# 1. 暂停当前主库
patronictl -c /etc/patroni/patroni.yml pause

# 2. 手动切换
patronictl -c /etc/patroni/patroni.yml switchover

# 3. 恢复旧主库为从库
patronictl -c /etc/patroni/patroni.yml resume

# 4. 验证切换结果
patronictl -c /etc/patroni/patroni.yml list
```

#### 场景3: 旧主库恢复

```bash
# 1. 检查旧主库状态
sudo -u postgres psql -c "SELECT pg_is_in_recovery();"

# 2. 如果WAL冲突，使用pg_rewind
sudo systemctl stop patroni
sudo -u postgres /usr/lib/postgresql/18/bin/pg_rewind \
    --target-server="host=192.168.1.100 port=5432 user=postgres" \
    -D /var/lib/postgresql/18/data

# 3. 配置恢复
sudo -u postgres cat > /var/lib/postgresql/18/data/standby.signal <<EOF
standby_mode = 'on'
primary_conninfo = 'host=192.168.1.100 port=5432 user=repl'
primary_slot_name = 'node1'
EOF

# 4. 启动Patroni
sudo systemctl start patroni

# 5. 验证恢复
patronictl -c /etc/patroni/patroni.yml list
```

### 5.2 只读副本延迟监控

```sql
SELECT application_name, state, sync_state,
       pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) AS byte_lag
FROM pg_stat_replication;
```

**完整监控查询**：

```sql
-- 1. 复制延迟监控
SELECT
    application_name,
    client_addr,
    state,
    sync_state,
    sync_priority,
    pg_wal_lsn_diff(pg_current_wal_lsn(), sent_lsn) AS sent_lag_bytes,
    pg_wal_lsn_diff(sent_lsn, write_lsn) AS write_lag_bytes,
    pg_wal_lsn_diff(write_lsn, flush_lsn) AS flush_lag_bytes,
    pg_wal_lsn_diff(flush_lsn, replay_lsn) AS replay_lag_bytes,
    pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) AS total_lag_bytes,
    EXTRACT(EPOCH FROM (now() - replay_lag_time)) AS replay_lag_seconds
FROM pg_stat_replication
ORDER BY total_lag_bytes DESC;

-- 2. 复制槽状态
SELECT
    slot_name,
    slot_type,
    database,
    active,
    pg_wal_lsn_diff(pg_current_wal_lsn(), restart_lsn) AS lag_bytes,
    pg_size_pretty(pg_wal_lsn_diff(pg_current_wal_lsn(), restart_lsn)) AS lag_size
FROM pg_replication_slots;

-- 3. WAL发送统计
SELECT
    pid,
    usename,
    application_name,
    client_addr,
    state,
    sent_lsn,
    write_lsn,
    flush_lsn,
    replay_lsn,
    sync_state,
    sync_priority
FROM pg_stat_replication;

-- 4. 复制延迟告警查询
SELECT
    application_name,
    pg_size_pretty(pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn)) AS lag_size,
    EXTRACT(EPOCH FROM (now() - replay_lag_time)) AS lag_seconds,
    CASE
        WHEN pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) > 1073741824 THEN 'CRITICAL'  -- >1GB
        WHEN pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) > 536870912 THEN 'WARNING'   -- >512MB
        ELSE 'OK'
    END AS status
FROM pg_stat_replication;
```

**Prometheus监控配置**：

```yaml
# prometheus.yml
scrape_configs:
  - job_name: 'postgres_replication'
    static_configs:
      - targets: ['postgres:5432']
    metrics_path: '/metrics'
    params:
      format: ['prometheus']
```

**Grafana监控面板**：

```promql
# 复制延迟（字节）
pg_replication_lag_bytes{instance="postgres:5432"}

# 复制延迟（秒）
pg_replication_lag_seconds{instance="postgres:5432"}

# 同步状态
pg_replication_sync_state{instance="postgres:5432"}
```

### 5.3 RTO/RPO评估

**RTO（Recovery Time Objective）恢复时间目标**：

```bash
# 测量故障切换时间
START_TIME=$(date +%s)
# 执行故障切换
sudo systemctl stop patroni
# 等待切换完成
while ! patronictl list | grep -q "Leader"; do
    sleep 1
done
END_TIME=$(date +%s)
RTO=$((END_TIME - START_TIME))
echo "RTO: ${RTO} seconds"
```

**RPO（Recovery Point Objective）恢复点目标**：

```sql
-- 检查数据丢失风险
SELECT
    application_name,
    pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) AS lag_bytes,
    CASE
        WHEN pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) = 0 THEN 'RPO = 0'
        ELSE 'RPO > 0'
    END AS rpo_status
FROM pg_stat_replication;
```

**故障演练脚本**：

```bash
#!/bin/bash
# 故障演练脚本

echo "=== PostgreSQL故障演练 ==="

# 1. 记录当前状态
echo "1. 记录当前状态"
patronictl list > /tmp/before_failover.txt
cat /tmp/before_failover.txt

# 2. 模拟主库故障
echo "2. 模拟主库故障"
read -p "输入主库节点名: " PRIMARY_NODE
ssh $PRIMARY_NODE "sudo systemctl stop patroni"

# 3. 等待切换
echo "3. 等待故障切换（最多60秒）"
for i in {1..60}; do
    if patronictl list | grep -q "Leader"; then
        echo "故障切换完成"
        break
    fi
    sleep 1
    echo -n "."
done

# 4. 验证新主库
echo "4. 验证新主库"
patronictl list > /tmp/after_failover.txt
NEW_LEADER=$(patronictl list | grep Leader | awk '{print $2}')
echo "新主库: $NEW_LEADER"

# 5. 验证应用连接
echo "5. 验证应用连接"
psql -h 192.168.1.100 -U postgres -d mydb -c "SELECT pg_is_in_recovery();"

# 6. 恢复旧主库
echo "6. 恢复旧主库"
read -p "是否恢复旧主库? (y/n): " RESTORE
if [ "$RESTORE" = "y" ]; then
    ssh $PRIMARY_NODE "sudo systemctl start patroni"
    sleep 10
    patronictl list
fi

echo "=== 故障演练完成 ==="
```

## 6. 后续整合任务

- 统一术语，提供参考拓扑与脚本清单
  - 三节点（1主2从）强一致与仲裁示意图
  - Patroni + etcd + VIP + pgbouncer/pgpool-II 最小落地脚本

---

## 7. 交叉引用

### 相关文档

#### 部署架构

- ⭐⭐⭐ [主从复制](./05.05-主从复制.md) - 主从复制配置
- ⭐⭐⭐ [读写分离](./05.06-读写分离.md) - 读写分离架构
- ⭐⭐ [分布式架构设计](../分布式部署/05.08-分布式架构设计.md) - 分布式架构
- ⭐⭐ [性能调优实践](../单机部署/05.02-性能调优实践.md) - 性能优化

#### 核心课程

- ⭐⭐⭐ [事务管理与ACID特性](../../01-核心课程/01.04-事务管理与ACID特性.md) - 事务理论
- ⭐⭐ [并发控制与MVCC机制](../../01-核心课程/01.05-并发控制与MVCC机制.md) - 并发控制
- ⭐⭐ [存储管理与数据持久化](../../01-核心课程/01.06-存储管理与数据持久化.md) - 存储管理

#### 运维实践

- ⭐⭐⭐ [监控与诊断](../../06-运维实践/监控与诊断/06.01-监控与诊断.md) - 监控诊断
- ⭐⭐⭐ [备份与恢复](../../06-运维实践/备份与恢复/06.06-备份与恢复.md) - 备份恢复
- ⭐⭐ [故障排查与恢复](../../12-全面使用分析/02-运维视角/02.04-故障排查与恢复.md) - 故障处理

#### 高级特性

- ⭐⭐ [分布式事务处理](../../04-高级特性/03.07-分布式事务处理.md) - 分布式事务

#### 应用架构

- ⭐⭐ [高可用架构设计](../../12-全面使用分析/05-架构视角/05.03-高可用架构设计.md) - 高可用架构理论

---

**文档版本**: v2.0
**最后更新**: 2025-11-22
**维护者**: PostgreSQL Documentation Team
