# PostgreSQL SQLè¯­è¨€è§„èŒƒä¸æ ‡å‡†å®Œæ•´æŒ‡å—

> **ç‰ˆæœ¬**: v3.1
> **æœ€åæ›´æ–°**: 2025-11-22
> **ç‰ˆæœ¬è¦†ç›–**: PostgreSQL 18.x (æ¨è) â­ | 17.x (æ¨è) | 16.x (å…¼å®¹)
> **éš¾åº¦**: â­â­â­
> **åº”ç”¨åœºæ™¯**: SQLè¯­è¨€å­¦ä¹ ã€æ•°æ®åº“å¼€å‘ã€æŸ¥è¯¢ä¼˜åŒ–ã€æ ‡å‡†è§„èŒƒ
> ğŸ†• **PostgreSQL 18 SQLæ”¹è¿›**: æŸ¥è¯¢æ€§èƒ½æå‡30-40%ã€JSONBå¢å¼º15-20%ã€MERGEè¯­å¥ä¼˜åŒ–20%ã€è™šæ‹Ÿç”Ÿæˆåˆ—æ”¯æŒ

---

## ğŸ“‘ ç›®å½•

- [PostgreSQL SQLè¯­è¨€è§„èŒƒä¸æ ‡å‡†å®Œæ•´æŒ‡å—](#postgresql-sqlè¯­è¨€è§„èŒƒä¸æ ‡å‡†å®Œæ•´æŒ‡å—)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [ğŸ“Š æ€ç»´å¯¼å›¾](#-æ€ç»´å¯¼å›¾)
  - [ä¸€ã€å®šä¹‰ä¸å½¢å¼åŒ–](#ä¸€å®šä¹‰ä¸å½¢å¼åŒ–)
    - [1.1 æ¦‚å¿µå®šä¹‰](#11-æ¦‚å¿µå®šä¹‰)
    - [1.2 å½¢å¼åŒ–å®šä¹‰](#12-å½¢å¼åŒ–å®šä¹‰)
    - [1.3 ç†è®ºåŸºç¡€](#13-ç†è®ºåŸºç¡€)
      - [1.3.1 å…³ç³»ä»£æ•°å¯¹åº”å…³ç³»](#131-å…³ç³»ä»£æ•°å¯¹åº”å…³ç³»)
      - [1.3.2 SQLå®Œå¤‡æ€§å®šç†](#132-sqlå®Œå¤‡æ€§å®šç†)
  - [ä¸‰ã€æ ¸å¿ƒè¯­æ³•è§„èŒƒ](#ä¸‰æ ¸å¿ƒè¯­æ³•è§„èŒƒ)
    - [3.1 æ•°æ®å®šä¹‰è¯­è¨€ï¼ˆDDLï¼‰](#31-æ•°æ®å®šä¹‰è¯­è¨€ddl)
      - [2.1.1 è¡¨å®šä¹‰](#211-è¡¨å®šä¹‰)
      - [2.1.2 è§†å›¾å®šä¹‰](#212-è§†å›¾å®šä¹‰)
    - [3.2 æ•°æ®æ“ä½œè¯­è¨€ï¼ˆDMLï¼‰](#32-æ•°æ®æ“ä½œè¯­è¨€dml)
      - [2.2.1 æ’å…¥æ“ä½œ](#221-æ’å…¥æ“ä½œ)
      - [2.2.2 æ›´æ–°æ“ä½œ](#222-æ›´æ–°æ“ä½œ)
      - [2.2.3 åˆ é™¤æ“ä½œ](#223-åˆ é™¤æ“ä½œ)
    - [3.3 æ•°æ®æŸ¥è¯¢è¯­è¨€ï¼ˆDQLï¼‰](#33-æ•°æ®æŸ¥è¯¢è¯­è¨€dql)
      - [2.3.1 åŸºæœ¬æŸ¥è¯¢](#231-åŸºæœ¬æŸ¥è¯¢)
      - [2.3.2 è¿æ¥æŸ¥è¯¢](#232-è¿æ¥æŸ¥è¯¢)
      - [2.3.3 å­æŸ¥è¯¢](#233-å­æŸ¥è¯¢)
    - [3.4 é«˜çº§æŸ¥è¯¢ç‰¹æ€§](#34-é«˜çº§æŸ¥è¯¢ç‰¹æ€§)
      - [2.4.1 çª—å£å‡½æ•°](#241-çª—å£å‡½æ•°)
      - [2.4.2 é€’å½’æŸ¥è¯¢](#242-é€’å½’æŸ¥è¯¢)
      - [2.4.3 å…¬å…±è¡¨è¡¨è¾¾å¼ï¼ˆCTEï¼‰](#243-å…¬å…±è¡¨è¡¨è¾¾å¼cte)
    - [3.5 äº‹åŠ¡æ§åˆ¶è¯­è¨€ï¼ˆTCLï¼‰](#35-äº‹åŠ¡æ§åˆ¶è¯­è¨€tcl)
      - [2.5.1 äº‹åŠ¡ç®¡ç†](#251-äº‹åŠ¡ç®¡ç†)
    - [3.6 æ•°æ®æ§åˆ¶è¯­è¨€ï¼ˆDCLï¼‰](#36-æ•°æ®æ§åˆ¶è¯­è¨€dcl)
      - [2.6.1 æƒé™ç®¡ç†](#261-æƒé™ç®¡ç†)
  - [å››ã€PostgreSQLæ‰©å±•ç‰¹æ€§](#å››postgresqlæ‰©å±•ç‰¹æ€§)
    - [4.1 æ•°æ®ç±»å‹æ‰©å±•](#41-æ•°æ®ç±»å‹æ‰©å±•)
    - [4.2 å‡½æ•°å’Œæ“ä½œç¬¦](#42-å‡½æ•°å’Œæ“ä½œç¬¦)
    - [4.3 ç´¢å¼•ç±»å‹](#43-ç´¢å¼•ç±»å‹)
  - [äº”ã€æ€§èƒ½ä¼˜åŒ–](#äº”æ€§èƒ½ä¼˜åŒ–)
    - [5.1 æŸ¥è¯¢ä¼˜åŒ–](#51-æŸ¥è¯¢ä¼˜åŒ–)
    - [5.2 ç´¢å¼•ä¼˜åŒ–](#52-ç´¢å¼•ä¼˜åŒ–)
  - [å…­ã€ç›¸å…³æ¦‚å¿µ](#å…­ç›¸å…³æ¦‚å¿µ)
    - [6.1 ä¸Šä½æ¦‚å¿µ](#61-ä¸Šä½æ¦‚å¿µ)
    - [6.2 ä¸‹ä½æ¦‚å¿µ](#62-ä¸‹ä½æ¦‚å¿µ)
    - [6.3 å¹³è¡Œæ¦‚å¿µ](#63-å¹³è¡Œæ¦‚å¿µ)
  - [ä¸ƒã€å‚è€ƒèµ„æº](#ä¸ƒå‚è€ƒèµ„æº)
    - [7.1 ç›¸å…³æ–‡æ¡£](#71-ç›¸å…³æ–‡æ¡£)
    - [7.2 å®æˆ˜æ¡ˆä¾‹ä¸ç¤ºä¾‹](#72-å®æˆ˜æ¡ˆä¾‹ä¸ç¤ºä¾‹)
    - [7.3 å‚è€ƒæ–‡çŒ®](#73-å‚è€ƒæ–‡çŒ®)
    - [7.4 Wikidataå¯¹é½](#74-wikidataå¯¹é½)

---

## ğŸ“Š æ€ç»´å¯¼å›¾

```mermaid
mindmap
  root((SQLè¯­è¨€))
    è¯­è¨€ç±»å‹
      DDL
      DML
      DQL
      DCL
      TCL
    æ ¸å¿ƒè¯­æ³•
      è¡¨å®šä¹‰
      æ•°æ®æ“ä½œ
      æŸ¥è¯¢è¯­å¥
      é«˜çº§ç‰¹æ€§
    PostgreSQLæ‰©å±•
      æ•°æ®ç±»å‹
      å‡½æ•°æ“ä½œç¬¦
      ç´¢å¼•ç±»å‹
    æ€§èƒ½ä¼˜åŒ–
      æŸ¥è¯¢ä¼˜åŒ–
      ç´¢å¼•ä¼˜åŒ–
    æ ‡å‡†è§„èŒƒ
      SQLæ ‡å‡†
      ç‰ˆæœ¬å¯¹æ¯”
      å…¼å®¹æ€§
```

---

## ä¸€ã€å®šä¹‰ä¸å½¢å¼åŒ–

### 1.1 æ¦‚å¿µå®šä¹‰

**ä¸­æ–‡å®šä¹‰**: SQLï¼ˆStructured Query Languageï¼‰æ˜¯ä¸€ç§å£°æ˜å¼çš„å…³ç³»æ•°æ®åº“æŸ¥è¯¢è¯­è¨€ï¼Œæ”¯æŒæ•°æ®å®šä¹‰ã€æ“ä½œã€æŸ¥è¯¢å’Œæ§åˆ¶åŠŸèƒ½ï¼Œæ˜¯å…³ç³»æ•°æ®åº“çš„æ ‡å‡†è¯­è¨€ã€‚PostgreSQLå®ç°äº†å®Œæ•´çš„SQL:2023æ ‡å‡†ï¼Œå¹¶æä¾›äº†ä¸°å¯Œçš„æ‰©å±•åŠŸèƒ½ã€‚

**English Definition**: SQL (Structured Query Language) is a declarative relational database query language that supports data definition, manipulation, query, and control functions, serving as the standard language for relational databases. PostgreSQL implements the complete SQL:2023 standard and provides rich extension capabilities.

### 1.2 å½¢å¼åŒ–å®šä¹‰

```latex
% æ•°å­¦ç¬¦å·å®šä¹‰
\newcommand{\sql}{\mathcal{SQL}}
\newcommand{\rel}{\mathcal{R}}
\newcommand{\attr}{\mathcal{A}}
\newcommand{\tuple}{\mathcal{T}}
\newcommand{\query}{\mathcal{Q}}
\newcommand{\result}{\mathcal{Result}}
\newcommand{\db}{\mathcal{D}}
\newcommand{\schema}{\mathcal{S}}

% SQLè¯­è¨€çš„å½¢å¼åŒ–å®šä¹‰
\sql = (DDL, DML, DQL, DCL, TCL)

å…¶ä¸­ï¼š
DDL = \{CREATE, ALTER, DROP, TRUNCATE\} \text{ æ•°æ®å®šä¹‰è¯­è¨€}
DML = \{INSERT, UPDATE, DELETE, MERGE\} \text{ æ•°æ®æ“ä½œè¯­è¨€}
DQL = \{SELECT\} \text{ æ•°æ®æŸ¥è¯¢è¯­è¨€}
DCL = \{GRANT, REVOKE, DENY\} \text{ æ•°æ®æ§åˆ¶è¯­è¨€}
TCL = \{BEGIN, COMMIT, ROLLBACK, SAVEPOINT\} \text{ äº‹åŠ¡æ§åˆ¶è¯­è¨€}
```

### 1.3 ç†è®ºåŸºç¡€

#### 1.3.1 å…³ç³»ä»£æ•°å¯¹åº”å…³ç³»

```latex
\begin{theorem}[SQLä¸å…³ç³»ä»£æ•°ç­‰ä»·æ€§]
SQLè¯­è¨€åœ¨è¡¨è¾¾èƒ½åŠ›ä¸Šç­‰ä»·äºå…³ç³»ä»£æ•°ï¼Œå³ï¼š
\forall q \in \query, \exists \sigma, \pi, \bowtie, \cup, \cap, - \text{ ä½¿å¾— }
\result(q) = f(\sigma, \pi, \bowtie, \cup, \cap, -)
\end{theorem}

\begin{proof}
1. SELECTå¯¹åº”æŠ•å½±æ“ä½œ \pi
2. WHEREå¯¹åº”é€‰æ‹©æ“ä½œ \sigma
3. JOINå¯¹åº”è¿æ¥æ“ä½œ \bowtie
4. UNIONå¯¹åº”å¹¶é›†æ“ä½œ \cup
5. INTERSECTå¯¹åº”äº¤é›†æ“ä½œ \cap
6. EXCEPTå¯¹åº”å·®é›†æ“ä½œ -

å› æ­¤ï¼ŒSQLçš„æ¯ä¸ªæ“ä½œéƒ½å¯ä»¥ç”¨å…³ç³»ä»£æ•°è¡¨ç¤ºï¼Œåä¹‹äº¦ç„¶ã€‚
\end{proof}
```

#### 1.3.2 SQLå®Œå¤‡æ€§å®šç†

```latex
\begin{theorem}[SQLå®Œå¤‡æ€§]
SQLè¯­è¨€æ˜¯å…³ç³»å®Œå¤‡çš„ï¼Œå½“ä¸”ä»…å½“ï¼š
1. æ”¯æŒå…³ç³»ä»£æ•°çš„æ‰€æœ‰åŸºæœ¬æ“ä½œ
2. æ”¯æŒé€’å½’æŸ¥è¯¢ï¼ˆWITH RECURSIVEï¼‰
3. æ”¯æŒèšåˆå‡½æ•°å’Œåˆ†ç»„æ“ä½œ
4. æ”¯æŒå­æŸ¥è¯¢å’ŒåµŒå¥—æŸ¥è¯¢
5. æ”¯æŒçª—å£å‡½æ•°å’ŒOLAPåŠŸèƒ½
\end{theorem}

\begin{proof}
åŸºäºCoddå®šç†ï¼Œå…³ç³»å®Œå¤‡æ€§è¦æ±‚ï¼š
- èƒ½å¤Ÿè¡¨è¾¾å…³ç³»ä»£æ•°çš„æ‰€æœ‰æ“ä½œ
- èƒ½å¤Ÿå¤„ç†é€’å½’å…³ç³»
- èƒ½å¤Ÿè¿›è¡Œå¤æ‚çš„æ•°æ®æ“ä½œ
- èƒ½å¤Ÿæ”¯æŒåˆ†ææŸ¥è¯¢

PostgreSQLçš„SQLå®ç°æ»¡è¶³ä»¥ä¸Šæ‰€æœ‰æ¡ä»¶ï¼Œå› æ­¤æ˜¯å…³ç³»å®Œå¤‡çš„ã€‚
\end{proof}
```

## ä¸‰ã€æ ¸å¿ƒè¯­æ³•è§„èŒƒ

### 3.1 æ•°æ®å®šä¹‰è¯­è¨€ï¼ˆDDLï¼‰

#### 2.1.1 è¡¨å®šä¹‰

```sql
-- æ ‡å‡†è¡¨å®šä¹‰
CREATE TABLE employees (
    emp_id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE,
    dept_id INTEGER REFERENCES departments(dept_id),
    salary DECIMAL(10,2) CHECK (salary > 0),
    hire_date DATE DEFAULT CURRENT_DATE,
    manager_id INTEGER REFERENCES employees(emp_id),
    CONSTRAINT emp_salary_check CHECK (salary >= 0 AND salary <= 1000000)
);

-- ç´¢å¼•å®šä¹‰
CREATE INDEX idx_emp_dept ON employees(dept_id);
CREATE UNIQUE INDEX idx_emp_email ON employees(email);
CREATE INDEX idx_emp_salary ON employees(salary) WHERE salary > 50000;
```

#### 2.1.2 è§†å›¾å®šä¹‰

```sql
-- ç®€å•è§†å›¾
CREATE VIEW emp_summary AS
SELECT
    dept_id,
    COUNT(*) as emp_count,
    AVG(salary) as avg_salary,
    MAX(salary) as max_salary
FROM employees
GROUP BY dept_id;

-- å¯æ›´æ–°è§†å›¾
CREATE VIEW emp_public AS
SELECT emp_id, name, dept_id
FROM employees
WHERE active = true;

-- ç‰©åŒ–è§†å›¾
CREATE MATERIALIZED VIEW emp_stats AS
SELECT
    dept_id,
    COUNT(*) as emp_count,
    AVG(salary) as avg_salary
FROM employees
GROUP BY dept_id;
```

### 3.2 æ•°æ®æ“ä½œè¯­è¨€ï¼ˆDMLï¼‰

#### 2.2.1 æ’å…¥æ“ä½œ

```sql
-- å•è¡Œæ’å…¥
INSERT INTO employees (emp_id, name, dept_id, salary)
VALUES (1001, 'å¼ ä¸‰', 1, 50000);

-- å¤šè¡Œæ’å…¥
INSERT INTO employees (emp_id, name, dept_id, salary) VALUES
    (1002, 'æå››', 1, 55000),
    (1003, 'ç‹äº”', 2, 60000);

-- ä½¿ç”¨RETURNINGå­å¥ï¼ˆPostgreSQLç‰¹æ€§ï¼‰
INSERT INTO employees (name, dept_id, salary)
VALUES ('æ–°å‘˜å·¥', 1, 45000)
RETURNING emp_id, name, salary;

-- ä»æŸ¥è¯¢ç»“æœæ’å…¥
INSERT INTO employees (name, dept_id, salary)
SELECT name, dept_id, salary * 1.1
FROM temp_employees
WHERE salary < 50000;
```

#### 2.2.2 æ›´æ–°æ“ä½œ

```sql
-- ç®€å•æ›´æ–°
UPDATE employees
SET salary = salary * 1.05
WHERE dept_id = 1;

-- ä½¿ç”¨å­æŸ¥è¯¢æ›´æ–°
UPDATE employees
SET salary = (
    SELECT AVG(salary)
    FROM employees e2
    WHERE e2.dept_id = employees.dept_id
)
WHERE salary < (
    SELECT AVG(salary)
    FROM employees e3
    WHERE e3.dept_id = employees.dept_id
);

-- ä½¿ç”¨RETURNINGå­å¥
UPDATE employees
SET salary = salary * 1.1
WHERE dept_id = 2
RETURNING emp_id, name, salary;
```

#### 2.2.3 åˆ é™¤æ“ä½œ

```sql
-- ç®€å•åˆ é™¤
DELETE FROM employees
WHERE emp_id = 1001;

-- ä½¿ç”¨å­æŸ¥è¯¢åˆ é™¤
DELETE FROM employees
WHERE dept_id IN (
    SELECT dept_id
    FROM departments
    WHERE status = 'inactive'
);

-- ä½¿ç”¨RETURNINGå­å¥
DELETE FROM employees
WHERE hire_date < '2020-01-01'
RETURNING emp_id, name, hire_date;
```

#### 2.2.4 MERGEè¯­å¥ï¼ˆPostgreSQL 18ä¼˜åŒ–ï¼‰ğŸ†•

PostgreSQL 18å¯¹MERGEè¯­å¥è¿›è¡Œäº†æ€§èƒ½ä¼˜åŒ–ï¼Œæå‡çº¦20%çš„æ‰§è¡Œæ•ˆç‡ã€‚

**è¯­æ³•**:

```sql
-- MERGEè¯­å¥ï¼šæ ¹æ®æ¡ä»¶æ’å…¥æˆ–æ›´æ–°
MERGE INTO target_table AS t
USING source_table AS s
ON t.id = s.id
WHEN MATCHED THEN
    UPDATE SET
        name = s.name,
        updated_at = CURRENT_TIMESTAMP
WHEN NOT MATCHED THEN
    INSERT (id, name, created_at)
    VALUES (s.id, s.name, CURRENT_TIMESTAMP);
```

**PostgreSQL 18ä¼˜åŒ–**:

1. **æŸ¥è¯¢è®¡åˆ’ä¼˜åŒ–**: æ”¹è¿›MERGEè¯­å¥çš„æŸ¥è¯¢è®¡åˆ’ç”Ÿæˆï¼Œå‡å°‘ä¸å¿…è¦çš„æ‰«æ
2. **æ‰¹é‡å¤„ç†**: ä¼˜åŒ–æ‰¹é‡MERGEæ“ä½œçš„æ€§èƒ½
3. **ç´¢å¼•åˆ©ç”¨**: æ›´å¥½åœ°åˆ©ç”¨ç´¢å¼•åŠ é€ŸMERGEæ“ä½œ

**ä½¿ç”¨åœºæ™¯**:

1. **æ•°æ®åŒæ­¥**

   ```sql
   -- ä»å¤–éƒ¨æ•°æ®æºåŒæ­¥æ•°æ®
   MERGE INTO products AS p
   USING external_products AS e
   ON p.product_id = e.product_id
   WHEN MATCHED AND p.price != e.price THEN
       UPDATE SET price = e.price, updated_at = NOW()
   WHEN NOT MATCHED THEN
       INSERT (product_id, name, price, created_at)
       VALUES (e.product_id, e.name, e.price, NOW());
   ```

2. **å¢é‡æ›´æ–°**

   ```sql
   -- å¢é‡æ›´æ–°ç”¨æˆ·ç»Ÿè®¡
   MERGE INTO user_stats AS us
   USING daily_stats AS ds
   ON us.user_id = ds.user_id AND us.stat_date = ds.stat_date
   WHEN MATCHED THEN
       UPDATE SET
           view_count = us.view_count + ds.view_count,
           last_updated = NOW()
   WHEN NOT MATCHED THEN
       INSERT (user_id, stat_date, view_count, last_updated)
       VALUES (ds.user_id, ds.stat_date, ds.view_count, NOW());
   ```

**æ€§èƒ½å¯¹æ¯”**:

- PostgreSQL 17: MERGEæ“ä½œè€—æ—¶åŸºå‡†
- PostgreSQL 18: MERGEæ“ä½œæ€§èƒ½æå‡çº¦20%
- ä¼˜åŒ–æ•ˆæœï¼šæ‰¹é‡æ“ä½œæ—¶æ›´æ˜æ˜¾ï¼Œå¯æå‡30-40%

### 3.3 æ•°æ®æŸ¥è¯¢è¯­è¨€ï¼ˆDQLï¼‰

#### 2.3.1 åŸºæœ¬æŸ¥è¯¢

```sql
-- åŸºæœ¬SELECT
SELECT emp_id, name, salary
FROM employees
WHERE dept_id = 1
ORDER BY salary DESC;

-- èšåˆæŸ¥è¯¢
SELECT
    dept_id,
    COUNT(*) as emp_count,
    AVG(salary) as avg_salary,
    MIN(salary) as min_salary,
    MAX(salary) as max_salary
FROM employees
GROUP BY dept_id
HAVING COUNT(*) > 5
ORDER BY avg_salary DESC;
```

#### 2.3.2 è¿æ¥æŸ¥è¯¢

```sql
-- å†…è¿æ¥
SELECT e.name, d.dept_name, e.salary
FROM employees e
INNER JOIN departments d ON e.dept_id = d.dept_id;

-- å·¦å¤–è¿æ¥
SELECT e.name, d.dept_name, e.salary
FROM employees e
LEFT JOIN departments d ON e.dept_id = d.dept_id;

-- è‡ªè¿æ¥
SELECT e1.name as employee, e2.name as manager
FROM employees e1
LEFT JOIN employees e2 ON e1.manager_id = e2.emp_id;
```

#### 2.3.3 å­æŸ¥è¯¢

```sql
-- æ ‡é‡å­æŸ¥è¯¢
SELECT name, salary,
    (SELECT AVG(salary) FROM employees e2 WHERE e2.dept_id = e1.dept_id) as dept_avg
FROM employees e1;

-- å­˜åœ¨æ€§æŸ¥è¯¢
SELECT name, salary
FROM employees e
WHERE EXISTS (
    SELECT 1 FROM departments d
    WHERE d.dept_id = e.dept_id AND d.status = 'active'
);

-- INå­æŸ¥è¯¢
SELECT name, salary
FROM employees
WHERE dept_id IN (
    SELECT dept_id FROM departments WHERE budget > 1000000
);
```

### 3.4 é«˜çº§æŸ¥è¯¢ç‰¹æ€§

#### 2.4.1 çª—å£å‡½æ•°

```sql
-- æ’åå‡½æ•°
SELECT
    name,
    salary,
    ROW_NUMBER() OVER (ORDER BY salary DESC) as salary_rank,
    RANK() OVER (ORDER BY salary DESC) as rank,
    DENSE_RANK() OVER (ORDER BY salary DESC) as dense_rank
FROM employees;

-- åˆ†åŒºçª—å£å‡½æ•°
SELECT
    name,
    dept_id,
    salary,
    AVG(salary) OVER (PARTITION BY dept_id) as dept_avg,
    salary - AVG(salary) OVER (PARTITION BY dept_id) as diff_from_avg
FROM employees;
```

#### 2.4.2 é€’å½’æŸ¥è¯¢

```sql
-- é€’å½’CTE
WITH RECURSIVE emp_hierarchy AS (
    -- åŸºç¡€æƒ…å†µï¼šé¡¶çº§ç®¡ç†è€…
    SELECT emp_id, name, manager_id, 1 as level
    FROM employees
    WHERE manager_id IS NULL

    UNION ALL

    -- é€’å½’æƒ…å†µï¼šä¸‹å±å‘˜å·¥
    SELECT e.emp_id, e.name, e.manager_id, eh.level + 1
    FROM employees e
    INNER JOIN emp_hierarchy eh ON e.manager_id = eh.emp_id
)
SELECT * FROM emp_hierarchy ORDER BY level, name;
```

#### 2.4.3 å…¬å…±è¡¨è¡¨è¾¾å¼ï¼ˆCTEï¼‰

```sql
-- ç®€å•CTE
WITH high_earners AS (
    SELECT emp_id, name, salary
    FROM employees
    WHERE salary > 80000
),
dept_stats AS (
    SELECT dept_id, COUNT(*) as emp_count
    FROM employees
    GROUP BY dept_id
)
SELECT h.name, h.salary, d.emp_count
FROM high_earners h
JOIN employees e ON h.emp_id = e.emp_id
JOIN dept_stats d ON e.dept_id = d.dept_id;
```

### 3.5 äº‹åŠ¡æ§åˆ¶è¯­è¨€ï¼ˆTCLï¼‰

#### 2.5.1 äº‹åŠ¡ç®¡ç†

```sql
-- åŸºæœ¬äº‹åŠ¡
BEGIN;
INSERT INTO employees (name, dept_id, salary) VALUES ('æ–°å‘˜å·¥', 1, 50000);
UPDATE departments SET emp_count = emp_count + 1 WHERE dept_id = 1;
COMMIT;

-- ä¿å­˜ç‚¹
BEGIN;
INSERT INTO employees (name, dept_id, salary) VALUES ('å‘˜å·¥1', 1, 50000);
SAVEPOINT sp1;
INSERT INTO employees (name, dept_id, salary) VALUES ('å‘˜å·¥2', 1, 60000);
ROLLBACK TO sp1;  -- å›æ»šåˆ°ä¿å­˜ç‚¹
COMMIT;  -- åªæäº¤ç¬¬ä¸€ä¸ªæ’å…¥
```

### 3.6 æ•°æ®æ§åˆ¶è¯­è¨€ï¼ˆDCLï¼‰

#### 2.6.1 æƒé™ç®¡ç†

```sql
-- åˆ›å»ºè§’è‰²
CREATE ROLE hr_manager;
CREATE ROLE data_analyst;

-- æˆäºˆæƒé™
GRANT SELECT, INSERT, UPDATE ON employees TO hr_manager;
GRANT SELECT ON employees TO data_analyst;
GRANT USAGE ON SCHEMA public TO hr_manager, data_analyst;

-- æ’¤é”€æƒé™
REVOKE UPDATE ON employees FROM hr_manager;

-- è§’è‰²ç»§æ‰¿
GRANT hr_manager TO data_analyst;
```

## å››ã€PostgreSQLæ‰©å±•ç‰¹æ€§

### 4.1 æ•°æ®ç±»å‹æ‰©å±•

```sql
-- JSONæ•°æ®ç±»å‹
CREATE TABLE user_profiles (
    user_id INTEGER PRIMARY KEY,
    profile JSONB,
    created_at TIMESTAMP DEFAULT NOW()
);

-- æ•°ç»„ç±»å‹
CREATE TABLE products (
    product_id INTEGER PRIMARY KEY,
    name VARCHAR(100),
    tags TEXT[],
    prices DECIMAL(10,2)[]
);

-- èŒƒå›´ç±»å‹
CREATE TABLE events (
    event_id INTEGER PRIMARY KEY,
    name VARCHAR(100),
    duration TSRANGE,
    price_range NUMRANGE
);
```

**PostgreSQL 18 JSONBå¢å¼º** ğŸ†•

PostgreSQL 18å¯¹JSONBç±»å‹è¿›è¡Œäº†å¤šé¡¹æ€§èƒ½ä¼˜åŒ–ï¼ŒæŸ¥è¯¢å’Œæ›´æ–°æ€§èƒ½æå‡15-20%ã€‚

**æ€§èƒ½ä¼˜åŒ–**:

1. **æŸ¥è¯¢ä¼˜åŒ–**: æ”¹è¿›JSONBè·¯å¾„æŸ¥è¯¢çš„æ€§èƒ½
2. **ç´¢å¼•ä¼˜åŒ–**: ä¼˜åŒ–GINç´¢å¼•åœ¨JSONBæŸ¥è¯¢ä¸­çš„ä½¿ç”¨
3. **æ›´æ–°ä¼˜åŒ–**: æå‡JSONBéƒ¨åˆ†æ›´æ–°çš„æ•ˆç‡

**ä½¿ç”¨ç¤ºä¾‹**:

```sql
-- JSONBæŸ¥è¯¢ä¼˜åŒ–ï¼ˆPostgreSQL 18ï¼‰
CREATE TABLE user_profiles (
    user_id INTEGER PRIMARY KEY,
    profile JSONB,
    created_at TIMESTAMP DEFAULT NOW()
);

-- åˆ›å»ºGINç´¢å¼•ï¼ˆPostgreSQL 18ä¼˜åŒ–ï¼‰
CREATE INDEX idx_profile_gin ON user_profiles USING GIN (profile);

-- è·¯å¾„æŸ¥è¯¢ï¼ˆæ€§èƒ½æå‡15-20%ï¼‰
SELECT user_id, profile->>'name' as name, profile->'address'->>'city' as city
FROM user_profiles
WHERE profile @> '{"status": "active"}'::jsonb;

-- JSONBæ›´æ–°ï¼ˆæ€§èƒ½æå‡ï¼‰
UPDATE user_profiles
SET profile = jsonb_set(profile, '{last_login}', to_jsonb(NOW()))
WHERE user_id = 1001;

-- æ‰¹é‡æ›´æ–°ï¼ˆPostgreSQL 18ä¼˜åŒ–ï¼‰
UPDATE user_profiles
SET profile = profile || '{"updated_at": "' || NOW()::TEXT || '"}'::jsonb
WHERE profile->>'status' = 'active';
```

**æ€§èƒ½å¯¹æ¯”**:

- PostgreSQL 17: JSONBæŸ¥è¯¢å’Œæ›´æ–°åŸºå‡†æ€§èƒ½
- PostgreSQL 18: JSONBæŸ¥è¯¢æ€§èƒ½æå‡15-20%
- PostgreSQL 18: JSONBæ›´æ–°æ€§èƒ½æå‡15-20%
- PostgreSQL 18: GINç´¢å¼•æŸ¥è¯¢æ€§èƒ½æå‡20-30%

**æœ€ä½³å®è·µ**:

- ä½¿ç”¨GINç´¢å¼•åŠ é€ŸJSONBæŸ¥è¯¢
- ä½¿ç”¨`@>`æ“ä½œç¬¦è¿›è¡ŒåŒ…å«æŸ¥è¯¢
- ä½¿ç”¨`jsonb_set`è¿›è¡Œéƒ¨åˆ†æ›´æ–°
- PostgreSQL 18çš„JSONBä¼˜åŒ–åœ¨å¤æ‚æŸ¥è¯¢ä¸­æ•ˆæœæ›´æ˜æ˜¾

### 4.2 å‡½æ•°å’Œæ“ä½œç¬¦

```sql
-- è‡ªå®šä¹‰å‡½æ•°
CREATE OR REPLACE FUNCTION calculate_bonus(emp_salary DECIMAL, performance_score INTEGER)
RETURNS DECIMAL AS $$
BEGIN
    RETURN emp_salary * (performance_score / 100.0) * 0.1;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨å‡½æ•°
SELECT name, salary, calculate_bonus(salary, 85) as bonus
FROM employees;

-- JSONæ“ä½œç¬¦
SELECT profile->>'name' as user_name,
       profile->'address'->>'city' as city
FROM user_profiles
WHERE profile ? 'address';
```

### 4.3 ç´¢å¼•ç±»å‹

```sql
-- GINç´¢å¼•ï¼ˆç”¨äºæ•°ç»„å’ŒJSONï¼‰
CREATE INDEX idx_profile_gin ON user_profiles USING GIN (profile);
CREATE INDEX idx_tags_gin ON products USING GIN (tags);

-- GiSTç´¢å¼•ï¼ˆç”¨äºå‡ ä½•å’ŒèŒƒå›´ç±»å‹ï¼‰
CREATE INDEX idx_duration_gist ON events USING GIST (duration);

-- éƒ¨åˆ†ç´¢å¼•
CREATE INDEX idx_high_salary ON employees (salary) WHERE salary > 100000;

-- è¡¨è¾¾å¼ç´¢å¼•
CREATE INDEX idx_name_lower ON employees (LOWER(name));
```

## äº”ã€æ€§èƒ½ä¼˜åŒ–

### 5.1 æŸ¥è¯¢ä¼˜åŒ–

```sql
-- ä½¿ç”¨EXPLAINåˆ†ææŸ¥è¯¢è®¡åˆ’
EXPLAIN (ANALYZE, BUFFERS)
SELECT e.name, d.dept_name
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id
WHERE e.salary > 50000;

-- ä½¿ç”¨LIMITä¼˜åŒ–
SELECT name, salary
FROM employees
ORDER BY salary DESC
LIMIT 10;

-- é¿å…SELECT *
SELECT emp_id, name, salary  -- åªé€‰æ‹©éœ€è¦çš„åˆ—
FROM employees
WHERE dept_id = 1;
```

### 5.2 ç´¢å¼•ä¼˜åŒ–

```sql
-- å¤åˆç´¢å¼•
CREATE INDEX idx_emp_dept_salary ON employees (dept_id, salary);

-- è¦†ç›–ç´¢å¼•
CREATE INDEX idx_emp_covering ON employees (dept_id) INCLUDE (name, salary);

-- ç´¢å¼•ä½¿ç”¨ç»Ÿè®¡
SELECT schemaname, tablename, indexname, idx_scan, idx_tup_read, idx_tup_fetch
FROM pg_stat_user_indexes
ORDER BY idx_scan DESC;
```

## å…­ã€ç›¸å…³æ¦‚å¿µ

### 6.1 ä¸Šä½æ¦‚å¿µ

- **æŸ¥è¯¢è¯­è¨€**: æ›´å¹¿æ³›çš„è¯­è¨€ç±»åˆ«
- **å…³ç³»æ•°æ®åº“**: æ•°æ®æ¨¡å‹ç±»å‹
- **å£°æ˜å¼è¯­è¨€**: ç¼–ç¨‹èŒƒå¼

### 6.2 ä¸‹ä½æ¦‚å¿µ

- **DDL**: æ•°æ®å®šä¹‰è¯­è¨€
- **DML**: æ•°æ®æ“ä½œè¯­è¨€
- **DQL**: æ•°æ®æŸ¥è¯¢è¯­è¨€
- **DCL**: æ•°æ®æ§åˆ¶è¯­è¨€
- **TCL**: äº‹åŠ¡æ§åˆ¶è¯­è¨€

### 6.3 å¹³è¡Œæ¦‚å¿µ

- **NoSQLæŸ¥è¯¢è¯­è¨€**: éå…³ç³»å‹æŸ¥è¯¢è¯­è¨€
- **å…³ç³»ä»£æ•°**: æ•°å­¦åŸºç¡€
- **å…³ç³»æ¼”ç®—**: é€»è¾‘åŸºç¡€

---

## ä¸ƒã€å‚è€ƒèµ„æº

### 7.1 ç›¸å…³æ–‡æ¡£

- [å…³ç³»æ•°æ®æ¨¡å‹ä¸ç†è®º](./01.02-å…³ç³»æ•°æ®æ¨¡å‹ä¸ç†è®º.md) - å…³ç³»æ•°æ®æ¨¡å‹
- [äº‹åŠ¡ç®¡ç†ä¸ACIDç‰¹æ€§](./01.04-äº‹åŠ¡ç®¡ç†ä¸ACIDç‰¹æ€§.md) - äº‹åŠ¡ç®¡ç†
- [æŸ¥è¯¢ä¼˜åŒ–å™¨åŸç†](../03-æŸ¥è¯¢ä¸ä¼˜åŒ–/02.01-æŸ¥è¯¢ä¼˜åŒ–å™¨åŸç†.md) - æŸ¥è¯¢ä¼˜åŒ–

### 7.2 å®æˆ˜æ¡ˆä¾‹ä¸ç¤ºä¾‹

- [å¯è¿è¡Œç¤ºä¾‹é¡¹ç›®](../examples/README.md) â­ - 8ä¸ªå®Œæ•´çš„Docker Composeç¤ºä¾‹
- [SQLç¤ºä¾‹è„šæœ¬](../sql/README.md) - SQLè„šæœ¬ç¤ºä¾‹
- [AIé›†æˆå¿«é€Ÿå¼€å§‹](../00-é¡¹ç›®å¯¼èˆª/AIé›†æˆå¿«é€Ÿå¼€å§‹.md) - 30åˆ†é’Ÿå¿«é€Ÿå…¥é—¨

### 7.3 å‚è€ƒæ–‡çŒ®

1. ISO/IEC 9075:2023. Information technology â€” Database languages â€” SQL
2. PostgreSQL Global Development Group. (2025). PostgreSQL 18 Documentation. <https://www.postgresql.org/docs/18/>
3. Codd, E. F. (1970). A relational model of data for large shared data banks. Communications of the ACM, 13(6), 377-387.
4. Date, C. J. (2003). An Introduction to Database Systems (8th ed.). Addison-Wesley.

### 7.4 Wikidataå¯¹é½

- **Wikidata ID**: Q202218
- **ç›¸å…³å±æ€§**:
  - P31: Q202218 (instance of: programming language)
  - P178: Q9366 (developer: PostgreSQL Global Development Group)
  - P348: SQL:2023 (software version)
  - P856: <https://www.postgresql.org/docs/current/sql.html> (official website)
- **å¤–éƒ¨é“¾æ¥**:
  - <https://www.postgresql.org/docs/current/sql.html>
  - <https://www.iso.org/standard/76583.html>

---

**æ–‡æ¡£ç‰ˆæœ¬**: v3.0
**æœ€åæ›´æ–°**: 2025-01-15
**ç»´æŠ¤è€…**: Data Science Team
