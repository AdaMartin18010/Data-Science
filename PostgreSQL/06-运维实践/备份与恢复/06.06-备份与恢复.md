# 备份与恢复

> **文档版本**: v2.0
> **最后更新**: 2025-11-12
> **版本覆盖**: PostgreSQL 18.x (推荐) ⭐ | 17.x (推荐) | 16.x (兼容)
> **文档状态**: ✅ 已更新
> 🆕 **PostgreSQL 18 新特性**
>
> PostgreSQL 18引入了**增量备份**功能，可显著减少备份时间（最多95%）和存储空间（最多99%），这是生产环境的重大改进！

---

## 📋 目录

- [备份与恢复](#备份与恢复)
  - [📋 目录](#-目录)
  - [1. 策略总览](#1-策略总览)
    - [1.1 备份策略选择](#11-备份策略选择)
  - [2. 逻辑备份](#2-逻辑备份)
    - [2.1 逻辑备份详解](#21-逻辑备份详解)
  - [3. 物理备份与WAL归档](#3-物理备份与wal归档)
    - [3.1 WAL归档配置详解](#31-wal归档配置详解)
    - [3.2 物理备份详解](#32-物理备份详解)
    - [3.3 物理备份恢复](#33-物理备份恢复)
  - [4. 增量备份（PostgreSQL 18新特性）](#4-增量备份postgresql-18新特性)
    - [4.1 功能说明](#41-功能说明)
    - [4.2 基本使用](#42-基本使用)
    - [4.3 生产环境备份策略](#43-生产环境备份策略)
      - [策略A：周全量 + 日增量](#策略a周全量--日增量)
      - [策略B：月全量 + 日增量](#策略b月全量--日增量)
    - [4.4 性能对比](#44-性能对比)
    - [4.5 恢复流程](#45-恢复流程)
    - [4.6 监控与告警](#46-监控与告警)
    - [4.7 最佳实践](#47-最佳实践)
      - [✅ DO - 推荐做法](#-do---推荐做法)
      - [❌ DON'T - 避免做法](#-dont---避免做法)
    - [4.8 故障排查](#48-故障排查)
      - [问题1: 增量备份失败](#问题1-增量备份失败)
      - [问题2: 恢复时缺少中间备份](#问题2-恢复时缺少中间备份)
      - [问题3: 存储空间不足](#问题3-存储空间不足)
    - [4.9 生产案例](#49-生产案例)
      - [案例：电商平台（5TB数据库）](#案例电商平台5tb数据库)
  - [5. 时间点恢复（PITR）](#5-时间点恢复pitr)
    - [5.1 PITR详细流程](#51-pitr详细流程)
    - [5.2 PITR故障排查](#52-pitr故障排查)
  - [5. 灾备与演练](#5-灾备与演练)
    - [5.1 级联复制配置](#51-级联复制配置)
    - [5.2 灾备演练SOP](#52-灾备演练sop)
  - [6. 合规与安全](#6-合规与安全)
    - [6.1 备份加密](#61-备份加密)
    - [6.2 备份留存策略](#62-备份留存策略)
    - [6.3 备份审计](#63-备份审计)
  - [7. 常见问题](#7-常见问题)
    - [7.1 归档堵塞问题](#71-归档堵塞问题)
    - [7.2 基线过旧问题](#72-基线过旧问题)
    - [7.3 跨版本还原](#73-跨版本还原)
  - [8. 交叉引用](#8-交叉引用)
    - [8.1 实战案例与示例](#81-实战案例与示例)

---

## 1. 策略总览

- **逻辑备份**：`pg_dump/pg_restore`，适合结构迁移与小中规模数据
- **物理备份**：`pg_basebackup` + WAL 归档，适合大规模与PITR
- **增量备份** (⭐ PG17新增)：仅备份变更数据，大幅减少备份时间和存储
- **频次与RPO/RTO**：全量 + 增量（WAL），按业务SLA制定窗口；多区域/多副本冗余

### 1.1 备份策略选择

| 备份类型 | 适用场景 | 备份时间 | 恢复时间 | 存储空间 | PostgreSQL版本 |
|---------|---------|---------|---------|---------|--------------|
| 逻辑备份 | 小型数据库(<100GB) | 中等 | 慢 | 中等 | 所有版本 |
| 物理全量备份 | 中大型数据库 | 长 | 快 | 大 | 所有版本 |
| **增量备份** | **大型数据库(>500GB)** | **极快** ⭐ | **快** | **极小** ⭐ | **18+** |
| WAL归档 | PITR需求 | 持续 | 快 | 持续增长 | 所有版本 |

## 2. 逻辑备份

```bash
# 单库逻辑备份
pg_dump -h <host> -U <user> -F c -j 4 -d mydb -f mydb_$(date +%F).dump

# 还原
pg_restore -h <host> -U <user> -j 4 -d mydb_restored mydb_2025-09-11.dump
```

### 2.1 逻辑备份详解

**备份格式选择**:

```bash
# 格式1: 自定义格式（推荐，支持并行恢复）
pg_dump -F c -j 4 -d mydb -f mydb.dump
# 优点：支持并行恢复、压缩、选择性恢复
# 缺点：只能使用pg_restore恢复

# 格式2: 目录格式（支持并行备份和恢复）
pg_dump -F d -j 4 -d mydb -f mydb_dir
# 优点：支持并行、可选择性恢复
# 缺点：目录结构复杂

# 格式3: SQL格式（纯文本）
pg_dump -F p -d mydb -f mydb.sql
# 优点：可读、可编辑、跨版本兼容
# 缺点：不支持并行、文件大

# 格式4: Tar格式
pg_dump -F t -d mydb -f mydb.tar
# 优点：压缩、可选择性恢复
# 缺点：不支持并行
```

**完整备份流程**:

```bash
# 1. 单库备份（推荐用于中小型数据库）
pg_dump \
    -h localhost \
    -U postgres \
    -F c \
    -j 4 \
    -d mydb \
    -f mydb_$(date +%Y%m%d_%H%M%S).dump \
    -v

# 2. 全库备份（备份所有数据库）
pg_dumpall \
    -h localhost \
    -U postgres \
    -f all_databases_$(date +%Y%m%d_%H%M%S).sql \
    -v

# 3. 仅备份结构（不包含数据）
pg_dump \
    -h localhost \
    -U postgres \
    -F c \
    -d mydb \
    -s \
    -f mydb_schema.dump

# 4. 仅备份数据（不包含结构）
pg_dump \
    -h localhost \
    -U postgres \
    -F c \
    -d mydb \
    -a \
    -f mydb_data.dump

# 5. 备份特定表
pg_dump \
    -h localhost \
    -U postgres \
    -F c \
    -d mydb \
    -t orders \
    -t customers \
    -f specific_tables.dump

# 6. 排除特定表
pg_dump \
    -h localhost \
    -U postgres \
    -F c \
    -d mydb \
    -T temp_table \
    -T log_table \
    -f exclude_tables.dump
```

**恢复方法**:

```bash
# 方法1: 使用pg_restore恢复（自定义格式）
pg_restore \
    -h localhost \
    -U postgres \
    -d mydb_restored \
    -j 4 \
    -v \
    mydb_20250911.dump

# 方法2: 恢复到新数据库
createdb -h localhost -U postgres mydb_restored
pg_restore \
    -h localhost \
    -U postgres \
    -d mydb_restored \
    -j 4 \
    mydb_20250911.dump

# 方法3: 仅恢复结构
pg_restore \
    -h localhost \
    -U postgres \
    -d mydb_restored \
    -s \
    mydb_20250911.dump

# 方法4: 仅恢复数据
pg_restore \
    -h localhost \
    -U postgres \
    -d mydb_restored \
    -a \
    mydb_20250911.dump

# 方法5: 选择性恢复（交互式）
pg_restore \
    -h localhost \
    -U postgres \
    -d mydb_restored \
    -i \
    mydb_20250911.dump

# 方法6: SQL格式恢复
psql -h localhost -U postgres -d mydb_restored -f mydb.sql
```

**最佳实践**:

```bash
# 1. 备份前检查数据库大小
psql -h localhost -U postgres -c "
SELECT
    pg_size_pretty(pg_database_size('mydb')) as db_size;
"

# 2. 备份时使用压缩（如果网络带宽有限）
pg_dump -F c -Z 9 -d mydb -f mydb_compressed.dump

# 3. 备份到远程存储
pg_dump -F c -d mydb | \
    gzip | \
    aws s3 cp - s3://backup-bucket/mydb_$(date +%Y%m%d).dump.gz

# 4. 验证备份完整性
pg_restore -l mydb_20250911.dump > backup_list.txt
# 检查备份列表，确认所有对象都在

# 5. 自动化备份脚本
#!/bin/bash
# backup_logical.sh

DB_NAME="mydb"
BACKUP_DIR="/backup/logical"
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="${BACKUP_DIR}/${DB_NAME}_${DATE}.dump"

mkdir -p ${BACKUP_DIR}

pg_dump \
    -h localhost \
    -U postgres \
    -F c \
    -j 4 \
    -d ${DB_NAME} \
    -f ${BACKUP_FILE} \
    -v

if [ $? -eq 0 ]; then
    echo "$(date): Backup successful: ${BACKUP_FILE}" >> /var/log/postgresql/backup.log
    # 清理旧备份（保留30天）
    find ${BACKUP_DIR} -name "${DB_NAME}_*.dump" -mtime +30 -delete
else
    echo "$(date): Backup failed!" >> /var/log/postgresql/backup.log
    exit 1
fi
```

## 3. 物理备份与WAL归档

```bash
# 开启归档（postgresql.conf）
archive_mode = on
archive_command = 'test ! -f /arch/%f && cp %p /arch/%f'
wal_level = replica
max_wal_senders = 10

# 基础备份（在线）
pg_basebackup -h <primary> -U repl -D /data/basebackup -X stream -P -R
```

### 3.1 WAL归档配置详解

**归档配置**:

```sql
-- postgresql.conf配置
archive_mode = on
archive_command = 'test ! -f /archive/%f && cp %p /archive/%f'
wal_level = replica  -- 或 logical（逻辑复制场景）
max_wal_senders = 10

-- 归档参数说明：
-- %p: WAL文件完整路径
-- %f: WAL文件名
-- archive_command: 归档命令，返回0表示成功

-- 高级归档配置
archive_command = 'test ! -f /archive/%f && cp %p /archive/%f && gzip /archive/%f'
-- 归档时压缩

archive_command = 'aws s3 cp %p s3://backup-bucket/wal-archive/%f'
-- 归档到S3

archive_command = 'rsync -av %p backup-server:/archive/%f'
-- 归档到远程服务器
```

**归档监控**:

```sql
-- 1. 检查归档状态
SELECT
    archived_count,
    last_archived_wal,
    last_archived_time,
    failed_count,
    last_failed_wal,
    last_failed_time,
    stats_reset
FROM pg_stat_archiver;

-- 2. 检查归档延迟
SELECT
    pg_walfile_name(pg_current_wal_lsn()) as current_wal,
    last_archived_wal,
    CASE
        WHEN pg_walfile_name(pg_current_wal_lsn()) != last_archived_wal
        THEN 'LAG'
        ELSE 'OK'
    END as archive_status
FROM pg_stat_archiver;

-- 3. 检查WAL文件列表
SELECT
    name,
    size,
    modification
FROM pg_ls_waldir()
ORDER BY modification DESC
LIMIT 20;
```

### 3.2 物理备份详解

**基础备份方法**:

```bash
# 方法1: 流式备份（推荐，在线备份）
pg_basebackup \
    -h localhost \
    -U replication \
    -D /backup/base/$(date +%Y%m%d_%H%M%S) \
    -X stream \
    -P \
    -v \
    -F plain

# 方法2: Tar格式备份（压缩）
pg_basebackup \
    -h localhost \
    -U replication \
    -D /backup/base/$(date +%Y%m%d_%H%M%S) \
    -X stream \
    -P \
    -F tar \
    -z \
    -Z 6

# 方法3: 并行备份（PostgreSQL 18+）
pg_basebackup \
    -h localhost \
    -U replication \
    -D /backup/base/$(date +%Y%m%d_%H%M%S) \
    -X stream \
    -P \
    -j 4 \
    -v

# 方法4: 备份到远程（通过SSH）
pg_basebackup \
    -h localhost \
    -U replication \
    -D - \
    -X stream \
    -F tar \
    | ssh backup-server "cat > /backup/base/backup_$(date +%Y%m%d).tar"
```

**备份选项说明**:

```bash
# -D: 备份目标目录
# -X stream: 同时备份WAL文件（推荐）
# -X fetch: 备份后获取WAL文件（需要两次连接）
# -P: 显示进度
# -v: 详细输出
# -F plain: 普通格式（目录结构）
# -F tar: Tar格式（压缩）
# -z: 压缩（Tar格式）
# -Z: 压缩级别（0-9）
# -j: 并行工作进程数（PostgreSQL 18+）
# -R: 自动配置恢复（创建standby.signal和postgresql.auto.conf）
# -c fast: 快速检查点（减少备份时间，但可能影响性能）
# -l: 备份标签
```

**备份验证**:

```bash
# 1. 检查备份完整性
pg_checksums -D /backup/base/20241122_020000 --check

# 2. 检查备份大小
du -sh /backup/base/20241122_020000

# 3. 检查备份内容
ls -lh /backup/base/20241122_020000/

# 4. 验证WAL文件
ls -lh /backup/base/20241122_020000/pg_wal/

# 5. 检查备份清单（如果使用清单格式）
cat /backup/base/20241122_020000/backup_manifest
```

### 3.3 物理备份恢复

```bash
# 步骤1: 停止PostgreSQL
systemctl stop postgresql

# 步骤2: 备份当前数据目录
mv /var/lib/postgresql/data /var/lib/postgresql/data.old

# 步骤3: 恢复备份
cp -r /backup/base/20241122_020000/* /var/lib/postgresql/data/

# 步骤4: 设置权限
chmod 700 /var/lib/postgresql/data
chown -R postgres:postgres /var/lib/postgresql/data

# 步骤5: 配置恢复（如果需要PITR）
cat > /var/lib/postgresql/data/postgresql.auto.conf <<EOF
restore_command = 'cp /archive/%f %p'
EOF

# 步骤6: 创建恢复信号文件
touch /var/lib/postgresql/data/recovery.signal

# 步骤7: 启动PostgreSQL
systemctl start postgresql

# 步骤8: 监控恢复进度
tail -f /var/log/postgresql/postgresql.log
```

## 4. 增量备份（PostgreSQL 18新特性）

⭐⭐⭐ **PostgreSQL 18最重要的生产特性之一**

### 4.1 功能说明

增量备份允许仅备份自上次备份以来更改的数据块，而不是整个数据库。这显著减少：

- ✅ 备份时间：从45分钟降至2-5分钟（90%+提升）
- ✅ 存储空间：节省90-99%的备份存储
- ✅ 网络传输：减少95%+的网络带宽
- ✅ I/O压力：降低对生产系统的影响

### 4.2 基本使用

```bash
# PostgreSQL 17+

# ============================================================
# 步骤1: 创建全量备份
# ============================================================
pg_basebackup -D /backup/base/2025-10-30-full \
  -F tar \
  -z \
  -P \
  --checkpoint=fast

# 备份时间（示例）：1TB数据库约45分钟
# 存储空间：~1TB（压缩后约600GB）

# ============================================================
# 步骤2: 创建第一个增量备份（周一）
# ============================================================
pg_basebackup -D /backup/incremental/2025-10-31-inc1 \
  --incremental=/backup/base/2025-10-30-full/backup_manifest \
  -F tar \
  -z \
  -P

# 备份时间：约2-5分钟 ⭐
# 存储空间：约10-50GB（仅变更部分）⭐

# ============================================================
# 步骤3: 创建第二个增量备份（周二）
# ============================================================
pg_basebackup -D /backup/incremental/2025-11-01-inc2 \
  --incremental=/backup/incremental/2025-10-31-inc1/backup_manifest \
  -F tar \
  -z \
  -P

# 可以基于任何已有备份创建增量

# ============================================================
# 步骤4: 恢复（需要全量+所有增量）
# ============================================================

# 4.1 合并备份
pg_combinebackup \
  /backup/base/2025-10-30-full \
  /backup/incremental/2025-10-31-inc1 \
  /backup/incremental/2025-11-01-inc2 \
  -o /restore/combined

# 4.2 启动恢复
pg_ctl -D /restore/combined start

# 或直接解压到数据目录
cd $PGDATA
tar -xzf /restore/combined/*.tar.gz
pg_ctl start
```

### 4.3 生产环境备份策略

#### 策略A：周全量 + 日增量

```bash
#!/bin/bash
# backup_strategy_weekly.sh

BACKUP_ROOT="/backup/postgresql"
TODAY=$(date +%Y-%m-%d)
DAY_OF_WEEK=$(date +%u)  # 1=Monday, 7=Sunday

if [ "$DAY_OF_WEEK" -eq 7 ]; then
    # Sunday: 全量备份
    echo "Performing full backup..."
    pg_basebackup -D "$BACKUP_ROOT/full/$TODAY" \
      -F tar -z -P --checkpoint=fast

    echo "$BACKUP_ROOT/full/$TODAY" > "$BACKUP_ROOT/latest_full.txt"
else
    # Monday-Saturday: 增量备份
    echo "Performing incremental backup..."
    LATEST_FULL=$(cat "$BACKUP_ROOT/latest_full.txt")

    # 找到最近的备份（全量或增量）
    LATEST_BACKUP=$(ls -td "$BACKUP_ROOT"/*/* | head -1)

    pg_basebackup -D "$BACKUP_ROOT/incremental/$TODAY" \
      --incremental="$LATEST_BACKUP/backup_manifest" \
      -F tar -z -P
fi

# 清理超过30天的备份
find "$BACKUP_ROOT" -type d -mtime +30 -exec rm -rf {} \;
```

**效果**：

- 周日全量：45分钟
- 周一-六增量：每次2-5分钟
- **每周总备份时间**：从315分钟（7×45）降至75分钟 ⭐
- **节省时间**：76% ⭐⭐⭐

#### 策略B：月全量 + 日增量

```text
1号: 全量备份（45分钟）
2-31号: 增量备份（每次2-5分钟）

每月总备份时间: 45 + 30×5 = 195分钟
vs 传统全量: 31×45 = 1395分钟

节省时间: 86% ⭐⭐⭐
存储节省: 90% ⭐⭐⭐
```

### 4.4 性能对比

| 场景 | 数据库大小 | 每日变更 | 全量备份 | 增量备份 | 时间节省 | 空间节省 |
|------|-----------|---------|---------|---------|---------|---------|
| 小型OLTP | 100GB | 1% | 5分钟 | 30秒 | 90% ⭐ | 99% ⭐ |
| 中型应用 | 500GB | 2% | 25分钟 | 2分钟 | 92% ⭐ | 98% ⭐ |
| 大型系统 | 1TB | 1% | 45分钟 | 2分钟 | 95% ⭐⭐⭐ | 99% ⭐⭐⭐ |
| 超大系统 | 5TB | 0.5% | 240分钟 | 5分钟 | 98% ⭐⭐⭐ | 99.5% ⭐⭐⭐ |

### 4.5 恢复流程

```bash
# ============================================================
# 场景：需要恢复到最新状态
# 备份链：Full → Inc1 → Inc2 → Inc3
# ============================================================

# 步骤1: 合并所有备份
pg_combinebackup \
  /backup/full/2025-10-27-full \
  /backup/inc/2025-10-28-inc1 \
  /backup/inc/2025-10-29-inc2 \
  /backup/inc/2025-10-30-inc3 \
  -o /restore/combined \
  --progress

# 步骤2: 停止当前实例（如果运行中）
pg_ctl -D $PGDATA stop -m fast

# 步骤3: 备份当前数据目录（可选但推荐）
mv $PGDATA $PGDATA.old

# 步骤4: 解压合并的备份
mkdir $PGDATA
cd $PGDATA
for tarfile in /restore/combined/*.tar.gz; do
    tar -xzf "$tarfile"
done

# 步骤5: 设置权限
chmod 700 $PGDATA

# 步骤6: 配置recovery（如需PITR）
cat >> postgresql.conf << EOF
restore_command = 'cp /archive/%f %p'
recovery_target_time = '2025-10-30 14:30:00+00'
EOF

# 步骤7: 启动并验证
pg_ctl -D $PGDATA start

# 验证
psql -c "SELECT pg_last_wal_replay_lsn(), now();"
psql -c "SELECT count(*) FROM critical_table;"
```

### 4.6 监控与告警

```sql
-- 创建备份监控视图

CREATE OR REPLACE VIEW backup_status AS
SELECT
    'full' AS backup_type,
    pg_stat_file('/backup/base/latest/backup_manifest').modification AS last_backup,
    EXTRACT(EPOCH FROM (now() - pg_stat_file('/backup/base/latest/backup_manifest').modification)) / 3600 AS hours_since_backup
UNION ALL
SELECT
    'incremental' AS backup_type,
    pg_stat_file('/backup/inc/latest/backup_manifest').modification AS last_backup,
    EXTRACT(EPOCH FROM (now() - pg_stat_file('/backup/inc/latest/backup_manifest').modification)) / 3600 AS hours_since_backup;

-- 告警查询（备份超过24小时）
SELECT * FROM backup_status WHERE hours_since_backup > 24;
```

```bash
# 监控脚本
#!/bin/bash
# monitor_backups.sh

BACKUP_ROOT="/backup/postgresql"

# 检查最近的增量备份
LAST_INC=$(find "$BACKUP_ROOT/incremental" -type f -name "backup_manifest" -mtime 0 | wc -l)

if [ "$LAST_INC" -eq 0 ]; then
    echo "CRITICAL: No incremental backup in last 24 hours"
    # 发送告警
    exit 2
fi

# 检查备份链完整性
FULL=$(cat "$BACKUP_ROOT/latest_full.txt")
if [ ! -f "$FULL/backup_manifest" ]; then
    echo "CRITICAL: Full backup manifest missing"
    exit 2
fi

echo "OK: Backup status normal"
exit 0
```

### 4.7 最佳实践

#### ✅ DO - 推荐做法

1. **定期全量备份**

   ```bash
   # 每周或每月创建新的全量备份
   # 避免增量链过长
   ```

2. **验证备份**

   ```bash
   # 定期测试恢复流程
   pg_combinebackup --check-only <backups>
   ```

3. **监控备份链**

   ```bash
   # 确保所有backup_manifest文件存在且有效
   find /backup -name "backup_manifest" -exec pg_verifybackup {} \;
   ```

4. **异地存储**

   ```bash
   # 将备份同步到另一个位置
   rsync -avz /backup/ remote:/backup-mirror/
   ```

#### ❌ DON'T - 避免做法

1. ❌ 不要删除中间的增量备份（会破坏备份链）
2. ❌ 不要让增量链超过7-10层（恢复时间会增加）
3. ❌ 不要在没有验证的情况下依赖单一备份链
4. ❌ 不要忽略backup_manifest文件（恢复必需）

### 4.8 故障排查

#### 问题1: 增量备份失败

```bash
# 错误: could not open file "backup_manifest": No such file
# 原因: 基础备份的manifest文件不存在

# 解决方法1: 检查文件是否存在
ls -l /backup/base/*/backup_manifest

# 解决方法2: 重新创建全量备份
pg_basebackup -D /backup/base/$(date +%F) -F tar -z
```

#### 问题2: 恢复时缺少中间备份

```bash
# 错误: incremental backup depends on missing backup
# 原因: 备份链不完整

# 解决方法: 使用完整的备份链
# Full → Inc1 → Inc2 → Inc3
# 不能跳过Inc1和Inc2直接恢复Inc3
```

#### 问题3: 存储空间不足

```bash
# 错误: No space left on device
# 原因: 备份目录空间不足

# 解决方法: 清理旧备份
find /backup -type d -mtime +30 -exec rm -rf {} \;

# 或使用更高效的压缩
pg_basebackup -D /backup/inc/$(date +%F) \
  --incremental=... \
  -F tar -z --compress=9  # 最高压缩率
```

### 4.9 生产案例

#### 案例：电商平台（5TB数据库）

**背景**：

- 数据库大小：5TB
- 每日数据变更：约1%（50GB）
- 传统全量备份：4小时
- 备份窗口：凌晨2-6点

**传统方案（PostgreSQL 16）**：

```text
每日全量备份: 4小时
每周总时间: 7 × 4 = 28小时
存储空间: 7 × 5TB = 35TB
```

**增量方案（PostgreSQL 17）**：

```text
周日全量: 4小时
周一-六增量: 每次10分钟

每周总时间: 4 + 6×0.167 = 5小时
存储空间: 5TB + 6×50GB = 5.3TB

时间节省: 82% ⭐⭐⭐
空间节省: 85% ⭐⭐⭐
```

**实际效果**：

- ✅ 每日备份在10分钟内完成，不影响业务
- ✅ 存储成本降低80%
- ✅ 备份成功率从92%提升到99.8%（因为时间窗口充足）
- ✅ 恢复测试时间缩短（备份更频繁更新鲜）

---

## 5. 时间点恢复（PITR）

```bash
# 停库并准备恢复环境
rm -rf $PGDATA/*
cp -a /data/basebackup/* $PGDATA/

# recovery 配置（PostgreSQL 12+）在 postgresql.conf 中：
restore_command = 'cp /arch/%f %p'
recovery_target_time = '2025-09-11 10:15:00+00'
recovery_target_action = 'promote'

# 启动并回放到目标时间后自动提升
pg_ctl -D $PGDATA start
```

- 验证：对照业务校验点（校验总数/关键记录），比对 `pg_last_wal_replay_lsn()` 演进；
- 复位：完成后清理恢复参数，确保后续正常归档。

### 5.1 PITR详细流程

**恢复目标类型**:

```bash
# 1. 时间点恢复（最常用）
recovery_target_time = '2025-11-22 14:30:00+08:00'
recovery_target_action = 'promote'  # 到达目标时间后自动提升

# 2. LSN恢复
recovery_target_lsn = '0/1234567'
recovery_target_action = 'promote'

# 3. 命名恢复点（需要提前创建）
-- 创建恢复点
SELECT pg_create_restore_point('before_major_update');

-- 恢复到恢复点
recovery_target_name = 'before_major_update'
recovery_target_action = 'promote'

# 4. 事务ID恢复（高级用法）
recovery_target_xid = '12345678'
recovery_target_action = 'promote'
```

**完整PITR流程**:

```bash
# 步骤1: 停止PostgreSQL
systemctl stop postgresql

# 步骤2: 备份当前数据目录
mv /var/lib/postgresql/data /var/lib/postgresql/data.old.$(date +%Y%m%d_%H%M%S)

# 步骤3: 恢复基础备份
cp -r /backup/base/20241122_020000/* /var/lib/postgresql/data/

# 步骤4: 配置恢复参数
cat > /var/lib/postgresql/data/postgresql.auto.conf <<EOF
# 恢复命令
restore_command = 'cp /archive/%f %p'

# 恢复目标（选择一种）
recovery_target_time = '2025-11-22 14:30:00+08:00'
# recovery_target_lsn = '0/1234567'
# recovery_target_name = 'backup_point'

# 恢复动作
recovery_target_action = 'promote'  # 到达目标后自动提升
# recovery_target_action = 'pause'   # 到达目标后暂停（需要手动提升）
# recovery_target_action = 'shutdown' # 到达目标后关闭

# 恢复选项
recovery_target_timeline = 'latest'  # 使用最新时间线
EOF

# 步骤5: 创建恢复信号文件
touch /var/lib/postgresql/data/recovery.signal

# 步骤6: 设置权限
chmod 700 /var/lib/postgresql/data
chown -R postgres:postgres /var/lib/postgresql/data

# 步骤7: 启动PostgreSQL
systemctl start postgresql

# 步骤8: 监控恢复进度
tail -f /var/log/postgresql/postgresql.log
# 查看日志中的恢复进度信息
```

**PITR验证**:

```sql
-- 1. 检查恢复状态
SELECT pg_is_in_recovery();
-- 恢复中返回: t (true)
-- 恢复完成返回: f (false)

-- 2. 检查恢复进度
SELECT
    pg_last_wal_replay_lsn(),
    pg_last_wal_replay_timestamp(),
    CASE
        WHEN pg_is_in_recovery() THEN 'Recovering'
        ELSE 'Recovery Complete'
    END as recovery_status;

-- 3. 验证恢复点
SELECT
    recovery_target,
    recovery_target_name,
    recovery_target_time,
    recovery_target_lsn
FROM pg_control_checkpoint();

-- 4. 验证数据一致性
-- 检查关键表的数据量
SELECT
    schemaname,
    tablename,
    n_live_tup
FROM pg_stat_user_tables
WHERE schemaname = 'public'
ORDER BY n_live_tup DESC
LIMIT 10;

-- 5. 验证业务数据
-- 检查关键业务表
SELECT COUNT(*) FROM orders;
SELECT MAX(created_at) FROM orders;
SELECT COUNT(*) FROM users WHERE status = 'active';

-- 6. 验证时间点
SELECT
    NOW() as current_time,
    recovery_target_time,
    NOW() - recovery_target_time as time_diff
FROM pg_control_checkpoint();
```

**PITR完成后的清理**:

```sql
-- 1. 确认恢复完成
SELECT pg_is_in_recovery();
-- 应该返回: f

-- 2. 清理恢复参数（PostgreSQL会自动处理）
-- recovery.signal会被重命名为recovery.done
-- postgresql.auto.conf中的恢复参数会被注释

-- 3. 验证归档正常
SELECT * FROM pg_stat_archiver;

-- 4. 创建新的基础备份（推荐）
-- 恢复完成后，创建新的基础备份作为新的恢复点
```

### 5.2 PITR故障排查

```bash
# 问题1: 恢复时缺少WAL文件
# 错误: could not open file "/archive/000000010000000000000001": No such file or directory

# 解决方法：
# 1. 检查归档目录
ls -lh /archive/

# 2. 检查WAL文件是否在备份中
ls -lh /backup/base/20241122_020000/pg_wal/

# 3. 手动复制缺失的WAL文件
cp /backup/base/20241122_020000/pg_wal/000000010000000000000001 /archive/

# 问题2: 恢复目标时间超出WAL范围
# 错误: recovery target time is not in the WAL archive

# 解决方法：
# 1. 检查可用的WAL文件范围
ls -lh /archive/ | head -1
ls -lh /archive/ | tail -1

# 2. 调整恢复目标时间到可用范围内
# 或使用更早的基础备份

# 问题3: 恢复卡住
# 现象：恢复长时间无进展

# 解决方法：
# 1. 检查PostgreSQL日志
tail -100 /var/log/postgresql/postgresql.log

# 2. 检查WAL归档命令是否正常
# 测试归档命令
test ! -f /archive/test.wal && echo "OK" || echo "FAILED"

# 3. 检查磁盘空间
df -h /archive
df -h /var/lib/postgresql/data
```

## 5. 灾备与演练

- 级联复制/备用库：`primary_conninfo`、`primary_slot_name`；
- 演练SOP：
  1) 选择近一次基线备份 + WAL；
  2) 搭建恢复环境并执行PITR；
  3) 校验一致性与完整性；
  4) 评估RTO/RPO，记录偏差并改进配置。

### 5.1 级联复制配置

```sql
-- 主库配置
-- postgresql.conf
wal_level = replica
max_wal_senders = 10
max_replication_slots = 10

-- 从库1配置（直接连接主库）
-- postgresql.auto.conf
primary_conninfo = 'host=primary port=5432 user=replication'
primary_slot_name = 'standby1_slot'

-- 从库2配置（级联复制，连接从库1）
-- postgresql.auto.conf
primary_conninfo = 'host=standby1 port=5432 user=replication'
primary_slot_name = 'standby2_slot'
wal_level = replica  -- 级联复制需要wal_level = replica
```

### 5.2 灾备演练SOP

**演练准备**:

```bash
# 1. 选择测试环境
TEST_DATA_DIR="/var/lib/postgresql/test_data"
TEST_BACKUP_DIR="/backup/test"

# 2. 选择最近的备份
LATEST_BACKUP=$(ls -td /backup/base/*/ | head -1)
LATEST_WAL=$(ls -t /archive/*.wal | head -1)

# 3. 记录演练开始时间
echo "$(date)" > /tmp/drill_start_time.txt
```

**演练步骤**:

```bash
# 步骤1: 搭建恢复环境
mkdir -p ${TEST_DATA_DIR}
cp -r ${LATEST_BACKUP}/* ${TEST_DATA_DIR}/

# 步骤2: 配置恢复
cat > ${TEST_DATA_DIR}/postgresql.auto.conf <<EOF
restore_command = 'cp /archive/%f %p'
recovery_target_time = '2025-11-22 12:00:00'
recovery_target_action = 'promote'
port = 5433  # 使用不同端口避免冲突
EOF

touch ${TEST_DATA_DIR}/recovery.signal

# 步骤3: 启动测试实例
pg_ctl -D ${TEST_DATA_DIR} -o "-p 5433" start

# 步骤4: 验证恢复
psql -p 5433 -c "SELECT pg_is_in_recovery();"
psql -p 5433 -c "SELECT COUNT(*) FROM orders;"

# 步骤5: 计算RTO/RPO
DRILL_END=$(date +%s)
DRILL_START=$(cat /tmp/drill_start_time.txt | xargs -I {} date -d {} +%s)
RTO=$((DRILL_END - DRILL_START))

# 步骤6: 清理测试环境
pg_ctl -D ${TEST_DATA_DIR} stop
rm -rf ${TEST_DATA_DIR}
```

**RTO/RPO验证**:

```sql
-- 创建演练记录表
CREATE TABLE IF NOT EXISTS backup_drill_log (
    drill_id SERIAL PRIMARY KEY,
    drill_date TIMESTAMP DEFAULT NOW(),
    backup_type VARCHAR(50),  -- 'full', 'incremental', 'pitr'
    backup_path TEXT,
    recovery_target_time TIMESTAMP,
    rto_seconds INTEGER,
    rpo_bytes BIGINT,
    data_verified BOOLEAN,
    drill_result VARCHAR(20),  -- 'success', 'partial', 'failed'
    issues TEXT[],
    improvements TEXT[]
);

-- 记录演练结果
INSERT INTO backup_drill_log (
    backup_type,
    backup_path,
    recovery_target_time,
    rto_seconds,
    rpo_bytes,
    data_verified,
    drill_result
)
VALUES (
    'pitr',
    '/backup/base/20241122_020000',
    '2025-11-22 12:00:00',
    300,  -- RTO: 5分钟
    0,    -- RPO: 0字节（无数据丢失）
    true,
    'success'
);
```

## 6. 合规与安全

- 加密：传输（TLS）与静态（磁盘/对象存储KMS）；
- 留存策略：分层存储与生命周期管理；
- 审计：备份/恢复操作留痕与报表。

### 6.1 备份加密

```bash
# 方法1: 传输加密（TLS）
pg_basebackup \
    -h primary \
    -U replication \
    -D /backup/base \
    --ssl-mode=require \
    -X stream

# 方法2: 静态加密（备份后加密）
pg_basebackup -D /backup/base -X stream
gpg --symmetric --cipher-algo AES256 /backup/base/backup.tar

# 方法3: 使用加密文件系统
# 创建加密的LUKS卷
cryptsetup luksFormat /dev/sdb1
cryptsetup luksOpen /dev/sdb1 backup_encrypted
mkfs.ext4 /dev/mapper/backup_encrypted
mount /dev/mapper/backup_encrypted /backup

# 方法4: 备份到加密对象存储
pg_basebackup -D - -X stream | \
    gzip | \
    aws s3 cp - \
    --server-side-encryption aws:kms \
    --sse-kms-key-id <key-id> \
    s3://backup-bucket/backup_$(date +%Y%m%d).gz
```

### 6.2 备份留存策略

```bash
# 自动化备份清理脚本
#!/bin/bash
# cleanup_backups.sh

BACKUP_BASE="/backup/base"
BACKUP_INC="/backup/incremental"
ARCHIVE_DIR="/archive"

# 全量备份：保留4周
find ${BACKUP_BASE} -type d -mtime +28 -exec rm -rf {} \;

# 增量备份：保留30天
find ${BACKUP_INC} -type d -mtime +30 -exec rm -rf {} \;

# WAL归档：保留7天
find ${ARCHIVE_DIR} -name "*.wal" -mtime +7 -delete

# 逻辑备份：保留90天
find /backup/logical -name "*.dump" -mtime +90 -delete

# 记录清理操作
echo "$(date): Cleaned up old backups" >> /var/log/postgresql/backup.log
```

### 6.3 备份审计

```sql
-- 创建备份审计表
CREATE TABLE IF NOT EXISTS backup_audit (
    audit_id SERIAL PRIMARY KEY,
    backup_time TIMESTAMP DEFAULT NOW(),
    backup_type VARCHAR(50),  -- 'full', 'incremental', 'logical'
    backup_path TEXT,
    backup_size BIGINT,
    backup_duration_seconds INTEGER,
    backup_by VARCHAR(100),
    backup_status VARCHAR(20),  -- 'success', 'failed'
    notes TEXT
);

-- 创建恢复审计表
CREATE TABLE IF NOT EXISTS restore_audit (
    audit_id SERIAL PRIMARY KEY,
    restore_time TIMESTAMP DEFAULT NOW(),
    backup_path TEXT,
    restore_target_time TIMESTAMP,
    restore_duration_seconds INTEGER,
    restore_by VARCHAR(100),
    restore_status VARCHAR(20),  -- 'success', 'failed', 'partial'
    data_verified BOOLEAN,
    notes TEXT
);

-- 查询备份历史
SELECT
    backup_time,
    backup_type,
    pg_size_pretty(backup_size) as backup_size,
    backup_duration_seconds,
    backup_status
FROM backup_audit
ORDER BY backup_time DESC
LIMIT 20;
```

## 7. 常见问题

- 归档堵塞：监控 `archiver` 失败，检查归档目录容量与权限；
- 基线过旧：恢复时间拉长，适当提升全量频次或打开增量基础备份方案；
- 跨版本还原：逻辑备份优先，或使用兼容的升级路径（`pg_upgrade`）。

### 7.1 归档堵塞问题

```sql
-- 问题诊断
SELECT
    archived_count,
    failed_count,
    last_failed_wal,
    last_failed_time
FROM pg_stat_archiver
WHERE failed_count > 0;

-- 常见原因和解决方法：

-- 1. 归档目录空间不足
df -h /archive
# 解决方法：清理旧归档或增加存储

-- 2. 归档目录权限问题
ls -ld /archive
# 解决方法：chown postgres:postgres /archive

-- 3. 归档命令失败
# 测试归档命令
test ! -f /archive/test.wal && cp /var/lib/postgresql/data/pg_wal/test.wal /archive/test.wal

-- 4. 归档目录不存在
mkdir -p /archive
chown postgres:postgres /archive
```

### 7.2 基线过旧问题

```bash
# 问题：恢复时需要应用大量WAL文件，恢复时间过长

# 解决方法1: 增加全量备份频率
# 从每周全量改为每3天全量

# 解决方法2: 使用增量备份（PostgreSQL 18）
# 周全量 + 日增量，减少恢复链长度

# 解决方法3: 定期创建新的基础备份
# 每月创建新的基础备份，清理旧的备份链
```

### 7.3 跨版本还原

```bash
# 问题：PostgreSQL 16的备份无法直接恢复到PostgreSQL 18

# 解决方法1: 使用逻辑备份（推荐）
pg_dump -F c -d old_db -f old_db.dump
pg_restore -d new_db old_db.dump

# 解决方法2: 使用pg_upgrade（原地升级）
pg_upgrade \
    --old-datadir=/var/lib/postgresql/16/data \
    --new-datadir=/var/lib/postgresql/18/data \
    --old-bindir=/usr/lib/postgresql/16/bin \
    --new-bindir=/usr/lib/postgresql/18/bin

# 解决方法3: 使用逻辑复制（跨版本迁移）
# 在主库创建发布
CREATE PUBLICATION my_pub FOR ALL TABLES;

# 在目标库创建订阅
CREATE SUBSCRIPTION my_sub
CONNECTION 'host=source port=5432 dbname=mydb'
PUBLICATION my_pub;
```

## 8. 交叉引用

**相关文档**：

- ⭐⭐⭐ [PostgreSQL 18新特性](../../02-版本特性/02.01-PostgreSQL-18-新特性.md) - 增量备份详解
- ⭐⭐ [存储管理与数据持久化](../../01-核心课程/01.06-存储管理与数据持久化.md) - WAL机制
- ⭐⭐ [单机部署与配置](../../05-部署架构/单机部署/05.01-单机部署与配置.md) - 初始配置
- ⭐⭐ [监控与诊断](../监控与诊断/06.01-监控与诊断.md) - 备份监控
- ⭐ [高可用架构](../../05-部署架构/集群部署/05.04-集群部署与高可用.md) - 复制与备用库

### 8.1 实战案例与示例

- [可运行示例项目](../../examples/README.md) ⭐ - 8个完整的Docker Compose示例
- [Docker部署指南](../../05-部署架构/容器化部署/05.12-Docker部署.md) - 备份配置实践
- [增量备份与恢复](../备份与恢复/06.07-增量备份与恢复.md) - PostgreSQL 18增量备份实践

**官方资源**：

- [PostgreSQL 18 Backup Documentation](https://www.postgresql.org/docs/18/backup.html)
- [pg_basebackup Documentation](https://www.postgresql.org/docs/18/app-pgbasebackup.html)
- [pg_combinebackup Documentation](https://www.postgresql.org/docs/18/app-pgcombinebackup.html)

---

**文档版本**: v2.1
**PostgreSQL版本**: 18.x (推荐) ⭐ | 17.x (推荐) | 16.x (兼容)
**最后更新**: 2025-11-12
**维护者**: Documentation Team

**变更历史**:

- 2025-11-12 v2.1: 更新至PostgreSQL 18，更新所有链接和版本引用
- 2025-10-30 v2.0: 增加PostgreSQL 17增量备份完整指南
- 原版本: 基础备份与恢复文档
