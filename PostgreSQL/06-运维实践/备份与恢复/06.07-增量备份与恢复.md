# Runbook：增量备份与恢复（PostgreSQL 18）

## 目标

利用 PostgreSQL 18 的增量备份功能与 WAL 归档，构建高效、可演练的备份恢复流程，实现 RTO/RPO 目标。

## 前置条件

- PostgreSQL 18+ 版本
- 配置 WAL 归档（archive_mode、archive_command）
- 配置 WAL Summarizer（PostgreSQL 18 默认启用）
- 备份存储空间规划
- 监控告警配置

### 前置配置

```sql
-- 1. 启用WAL归档
-- postgresql.conf
archive_mode = on
archive_command = 'test ! -f /archive/%f && cp %p /archive/%f'
wal_level = replica

-- 2. 验证WAL Summarizer状态（PostgreSQL 18）
SELECT * FROM pg_stat_wal_summarizer;

-- 3. 检查归档状态
SELECT * FROM pg_stat_archiver;
```

## 步骤

### 步骤1: 基础全量备份

```bash
# 创建全量备份（作为增量备份的基准）
pg_basebackup \
    -D /backup/base/$(date +%Y%m%d_%H%M%S) \
    -X stream \
    -P \
    -v \
    -F plain

# 记录备份LSN（用于后续增量备份）
psql -c "SELECT pg_current_wal_lsn();" > /backup/base/backup_lsn.txt

# 验证备份
ls -lh /backup/base/
```

### 步骤2: 增量备份（PostgreSQL 18）

```bash
# PostgreSQL 18增量备份
pg_basebackup \
    -D /backup/incremental/$(date +%Y%m%d_%H%M%S) \
    --incremental \
    --incremental-base=/backup/base/20241122_020000 \
    -X stream \
    -P \
    -v \
    -F plain

# 增量备份选项说明：
# --incremental: 启用增量备份
# --incremental-base: 指定基准备份路径
# -X stream: 同时备份WAL文件
# -P: 显示进度
# -v: 详细输出
```

### 步骤3: 备份验证

```bash
# 1. 检查备份目录结构
ls -lh /backup/incremental/

# 2. 验证备份完整性
pg_checksums -D /backup/incremental/20241122_120000 --check

# 3. 检查备份大小
du -sh /backup/incremental/20241122_120000

# 4. 验证WAL文件
ls -lh /backup/incremental/20241122_120000/pg_wal/
```

### 步骤4: 恢复准备

```bash
# 1. 停止PostgreSQL服务（如果恢复）
systemctl stop postgresql

# 2. 备份当前数据目录（如果存在）
mv /var/lib/postgresql/data /var/lib/postgresql/data.old

# 3. 准备恢复目录
mkdir -p /var/lib/postgresql/data
```

### 步骤5: 执行恢复

```bash
# 方法1: 从全量备份恢复
cp -r /backup/base/20241122_020000/* /var/lib/postgresql/data/

# 方法2: 从增量备份恢复（需要先恢复基准备份）
# 步骤1: 恢复基准备份
cp -r /backup/base/20241122_020000/* /var/lib/postgresql/data/

# 步骤2: 应用增量备份
rsync -av /backup/incremental/20241122_120000/ /var/lib/postgresql/data/

# 3. 配置恢复参数
cat > /var/lib/postgresql/data/postgresql.auto.conf <<EOF
restore_command = 'cp /archive/%f %p'
recovery_target_time = '2024-11-22 12:00:00'  # 可选：时间点恢复
# recovery_target_lsn = '0/1234567'  # 可选：LSN恢复
# recovery_target_name = 'backup_point'  # 可选：命名恢复点
EOF

# 4. 创建恢复信号文件
touch /var/lib/postgresql/data/recovery.signal

# 5. 启动PostgreSQL
systemctl start postgresql

# 6. 监控恢复进度
tail -f /var/log/postgresql/postgresql.log
```

### 步骤6: 恢复验证

```sql
-- 1. 检查恢复状态
SELECT pg_is_in_recovery();

-- 2. 验证数据一致性
SELECT
    schemaname,
    tablename,
    n_live_tup
FROM pg_stat_user_tables
ORDER BY n_live_tup DESC
LIMIT 10;

-- 3. 检查恢复点
SELECT
    pg_last_wal_replay_lsn(),
    pg_last_wal_replay_timestamp();

-- 4. 业务数据验证（示例）
SELECT COUNT(*) FROM orders;
SELECT COUNT(*) FROM users;
SELECT MAX(created_at) FROM orders;

-- 5. 完成恢复（如果使用recovery.signal）
-- 恢复完成后，PostgreSQL会自动重命名recovery.signal为recovery.done
```

## 验证清单

- 备份可读、校验通过（hash/大小/目录结构）
- 恢复后系统一致（系统表与业务表计数/抽样对比）
- 监控事件完整（备份时长、WAL 量、错误日志）
- RTO/RPO 达标并留存记录

### 详细验证步骤

```bash
# 1. 备份完整性验证
pg_checksums -D /backup/incremental/20241122_120000 --check
# 输出：Checksum operation completed
# 输出：Files scanned: XXXX
# 输出：Blocks scanned: XXXX
# 输出：Bad checksums: 0

# 2. 备份大小验证
du -sh /backup/base/20241122_020000
du -sh /backup/incremental/20241122_120000
# 增量备份应该明显小于全量备份（通常节省90%+空间）

# 3. WAL文件验证
ls -lh /backup/incremental/20241122_120000/pg_wal/
# 应该包含必要的WAL文件

# 4. 恢复后数据验证
psql -c "SELECT pg_database_size('postgres');"
psql -c "SELECT COUNT(*) FROM pg_stat_user_tables;"
psql -c "SELECT COUNT(*) FROM orders WHERE created_at >= '2024-11-22';"
```

## 自动化脚本

### 全量备份脚本

```bash
#!/bin/bash
# full_backup.sh

BACKUP_BASE="/backup/base"
BACKUP_DIR="${BACKUP_BASE}/$(date +%Y%m%d_%H%M%S)"
LOG_FILE="/var/log/postgresql/backup.log"

echo "$(date): Starting full backup to ${BACKUP_DIR}" >> ${LOG_FILE}

pg_basebackup \
    -D ${BACKUP_DIR} \
    -X stream \
    -P \
    -v \
    -F plain \
    2>&1 | tee -a ${LOG_FILE}

if [ $? -eq 0 ]; then
    # 记录备份LSN
    psql -t -c "SELECT pg_current_wal_lsn();" > ${BACKUP_DIR}/backup_lsn.txt

    # 记录备份元数据
    echo "$(date): Backup completed: ${BACKUP_DIR}" >> ${LOG_FILE}
    echo "Backup size: $(du -sh ${BACKUP_DIR} | cut -f1)" >> ${LOG_FILE}

    # 清理旧备份（保留最近7天）
    find ${BACKUP_BASE} -type d -mtime +7 -exec rm -rf {} \;
else
    echo "$(date): Backup failed!" >> ${LOG_FILE}
    exit 1
fi
```

### 增量备份脚本

```bash
#!/bin/bash
# incremental_backup.sh

BACKUP_BASE="/backup/base"
BACKUP_INCREMENTAL="/backup/incremental"
LATEST_BASE=$(ls -td ${BACKUP_BASE}/*/ | head -1)
BACKUP_DIR="${BACKUP_INCREMENTAL}/$(date +%Y%m%d_%H%M%S)"
LOG_FILE="/var/log/postgresql/backup.log"

if [ -z "${LATEST_BASE}" ]; then
    echo "$(date): No base backup found, running full backup first" >> ${LOG_FILE}
    /usr/local/bin/full_backup.sh
    LATEST_BASE=$(ls -td ${BACKUP_BASE}/*/ | head -1)
fi

echo "$(date): Starting incremental backup to ${BACKUP_DIR}" >> ${LOG_FILE}
echo "$(date): Base backup: ${LATEST_BASE}" >> ${LOG_FILE}

pg_basebackup \
    -D ${BACKUP_DIR} \
    --incremental \
    --incremental-base=${LATEST_BASE} \
    -X stream \
    -P \
    -v \
    -F plain \
    2>&1 | tee -a ${LOG_FILE}

if [ $? -eq 0 ]; then
    echo "$(date): Incremental backup completed: ${BACKUP_DIR}" >> ${LOG_FILE}
    echo "Backup size: $(du -sh ${BACKUP_DIR} | cut -f1)" >> ${LOG_FILE}

    # 清理旧增量备份（保留最近30天）
    find ${BACKUP_INCREMENTAL} -type d -mtime +30 -exec rm -rf {} \;
else
    echo "$(date): Incremental backup failed!" >> ${LOG_FILE}
    exit 1
fi
```

### 恢复脚本

```bash
#!/bin/bash
# restore.sh

BACKUP_PATH=$1
RECOVERY_TIME=$2  # 可选：时间点恢复
DATA_DIR="/var/lib/postgresql/data"

if [ -z "${BACKUP_PATH}" ]; then
    echo "Usage: $0 <backup_path> [recovery_time]"
    exit 1
fi

echo "Stopping PostgreSQL..."
systemctl stop postgresql

echo "Backing up current data directory..."
mv ${DATA_DIR} ${DATA_DIR}.old.$(date +%Y%m%d_%H%M%S)

echo "Restoring from backup: ${BACKUP_PATH}"
cp -r ${BACKUP_PATH}/* ${DATA_DIR}/

echo "Configuring recovery..."
cat > ${DATA_DIR}/postgresql.auto.conf <<EOF
restore_command = 'cp /archive/%f %p'
EOF

if [ -n "${RECOVERY_TIME}" ]; then
    echo "recovery_target_time = '${RECOVERY_TIME}'" >> ${DATA_DIR}/postgresql.auto.conf
fi

touch ${DATA_DIR}/recovery.signal

echo "Starting PostgreSQL..."
systemctl start postgresql

echo "Monitoring recovery..."
tail -f /var/log/postgresql/postgresql.log
```

## 监控与告警

### 备份监控

```sql
-- 1. 检查WAL Summarizer状态
SELECT * FROM pg_stat_wal_summarizer;

-- 2. 检查归档状态
SELECT
    archived_count,
    last_archived_wal,
    last_archived_time,
    failed_count,
    last_failed_wal,
    last_failed_time
FROM pg_stat_archiver;

-- 3. 检查备份目录
SELECT
    pg_size_pretty(pg_database_size(current_database())) as db_size,
    pg_size_pretty(
        (SELECT sum(pg_tablespace_size(spcname)) FROM pg_tablespace)
    ) as total_size;
```

### Prometheus告警规则

```yaml
groups:
  - name: postgresql_backup
    rules:
      - alert: PostgreSQLBackupFailed
        expr: increase(pg_stat_archiver_failed_count[1h]) > 0
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "PostgreSQL备份失败"
          description: "归档失败次数: {{ $value }}"

      - alert: PostgreSQLBackupLag
        expr: (now() - pg_stat_archiver_last_archived_time) > 1h
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: "PostgreSQL备份延迟"
          description: "最后归档时间: {{ $value }}"
```

## 最佳实践

### 备份策略

```bash
# 推荐策略：周全量 + 日增量
# 周一：全量备份
0 2 * * 1 /usr/local/bin/full_backup.sh

# 周二至周日：增量备份
0 2 * * 2-7 /usr/local/bin/incremental_backup.sh

# 清理策略
# 全量备份：保留4周
# 增量备份：保留30天
# WAL归档：保留7天
```

### 恢复演练

```bash
# 每月执行一次恢复演练
# 1. 在测试环境恢复最新备份
# 2. 验证数据完整性
# 3. 测试时间点恢复
# 4. 记录RTO/RPO指标
```

## 故障排查

### 问题1: 增量备份失败

```bash
# 检查基准备份是否存在
ls -lh /backup/base/

# 检查WAL Summarizer状态
psql -c "SELECT * FROM pg_stat_wal_summarizer;"

# 检查磁盘空间
df -h /backup

# 查看详细错误日志
tail -100 /var/log/postgresql/postgresql.log
```

### 问题2: 恢复时缺少WAL文件

```bash
# 检查WAL归档目录
ls -lh /archive/

# 检查恢复配置
cat /var/lib/postgresql/data/postgresql.auto.conf

# 手动复制缺失的WAL文件
cp /archive/000000010000000000000001 /var/lib/postgresql/data/pg_wal/
```

### 问题3: 恢复后数据不一致

```sql
-- 检查恢复点
SELECT pg_last_wal_replay_lsn(), pg_last_wal_replay_timestamp();

-- 检查数据库大小
SELECT pg_size_pretty(pg_database_size(current_database()));

-- 检查表数据
SELECT schemaname, tablename, n_live_tup
FROM pg_stat_user_tables
ORDER BY n_live_tup DESC;
```
