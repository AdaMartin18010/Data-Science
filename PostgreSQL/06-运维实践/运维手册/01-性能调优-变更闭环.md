# 性能调优-变更闭环（Runbook）

## 1. 目标

- 在生产环境中以最小风险完成参数/SQL/结构优化，形成“监测→诊断→定位→变更→验证→回滚/固化”的闭环。
- 对齐文档：`../05-部署架构/单机部署/05.02-性能调优实践.md`、`../监控与诊断/06.01-监控与诊断.md`。

## 2. 前置检查

- 业务窗口：确认灰度范围与低峰时段；
- 备份/回滚：配置备份点/快照；准备回滚脚本（参数旧值、DDL 回滚方案）。
- 指标面板：P95/P99、TPS/QPS、命中率、WAL 速率、检查点、锁等待、Autovacuum 滞后。

## 3. 诊断入口

1) 慢查询/吞吐下降/延迟升高告警触发；
2) 执行 `sql/diagnostics.sql` 中 TopN + 等待事件；
3) 对疑似语句 `EXPLAIN (ANALYZE, BUFFERS, VERBOSE)`；
4) 评估策略：索引/统计/SQL/参数/架构。

### 3.1 诊断SQL脚本

**完整诊断脚本** (`sql/diagnostics.sql`):

```sql
-- ============================================
-- PostgreSQL 性能诊断脚本
-- ============================================

-- 1. 当前活跃会话和等待事件
SELECT
    pid,
    usename,
    application_name,
    state,
    wait_event_type,
    wait_event,
    query_start,
    state_change,
    LEFT(query, 100) as query_preview
FROM pg_stat_activity
WHERE state != 'idle'
ORDER BY query_start;

-- 2. Top 10 慢查询（需要pg_stat_statements扩展）
SELECT
    LEFT(query, 100) as query_preview,
    calls,
    round(mean_exec_time::numeric, 2) as mean_ms,
    round(max_exec_time::numeric, 2) as max_ms,
    round((100.0 * shared_blks_hit / NULLIF(shared_blks_hit + shared_blks_read, 0))::numeric, 2) as hit_ratio,
    rows
FROM pg_stat_statements
WHERE calls > 10
ORDER BY mean_exec_time DESC
LIMIT 10;

-- 3. 锁等待情况
SELECT
    blocked_locks.pid AS blocked_pid,
    blocked_activity.usename AS blocked_user,
    blocking_locks.pid AS blocking_pid,
    blocking_activity.usename AS blocking_user,
    blocked_activity.query AS blocked_statement,
    blocking_activity.query AS blocking_statement
FROM pg_catalog.pg_locks blocked_locks
JOIN pg_catalog.pg_stat_activity blocked_activity ON blocked_activity.pid = blocked_locks.pid
JOIN pg_catalog.pg_locks blocking_locks
    ON blocking_locks.locktype = blocked_locks.locktype
    AND blocking_locks.database IS NOT DISTINCT FROM blocked_locks.database
    AND blocking_locks.relation IS NOT DISTINCT FROM blocked_locks.relation
    AND blocking_locks.page IS NOT DISTINCT FROM blocked_locks.page
    AND blocking_locks.tuple IS NOT DISTINCT FROM blocked_locks.tuple
    AND blocking_locks.virtualxid IS NOT DISTINCT FROM blocked_locks.virtualxid
    AND blocking_locks.transactionid IS NOT DISTINCT FROM blocked_locks.transactionid
    AND blocking_locks.classid IS NOT DISTINCT FROM blocked_locks.classid
    AND blocking_locks.objid IS NOT DISTINCT FROM blocked_locks.objid
    AND blocking_locks.objsubid IS NOT DISTINCT FROM blocked_locks.objsubid
    AND blocking_locks.pid != blocked_locks.pid
JOIN pg_catalog.pg_stat_activity blocking_activity ON blocking_activity.pid = blocking_locks.pid
WHERE NOT blocked_locks.granted;

-- 4. 缓冲区命中率
SELECT
    datname,
    round(100.0 * sum(blks_hit) / NULLIF(sum(blks_hit) + sum(blks_read), 0), 2) as hit_ratio
FROM pg_stat_database
GROUP BY datname;

-- 5. 表扫描统计
SELECT
    schemaname,
    tablename,
    seq_scan,
    idx_scan,
    round(100.0 * idx_scan / NULLIF(seq_scan + idx_scan, 0), 2) as idx_scan_ratio,
    n_live_tup,
    n_dead_tup,
    round(100.0 * n_dead_tup / NULLIF(n_live_tup + n_dead_tup, 0), 2) as dead_ratio
FROM pg_stat_user_tables
WHERE seq_scan + idx_scan > 0
ORDER BY seq_scan DESC
LIMIT 20;

-- 6. 索引使用情况
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    pg_size_pretty(pg_relation_size(indexname::regclass)) as index_size
FROM pg_stat_user_indexes
WHERE idx_scan = 0
AND pg_relation_size(indexname::regclass) > 1000000
ORDER BY pg_relation_size(indexname::regclass) DESC;

-- 7. WAL和检查点统计
SELECT
    checkpoints_timed,
    checkpoints_req,
    checkpoint_write_time,
    checkpoint_sync_time,
    buffers_checkpoint,
    buffers_clean,
    buffers_backend
FROM pg_stat_bgwriter;

-- 8. Autovacuum状态
SELECT
    schemaname,
    tablename,
    last_vacuum,
    last_autovacuum,
    last_analyze,
    last_autoanalyze,
    n_dead_tup,
    n_live_tup
FROM pg_stat_user_tables
WHERE n_dead_tup > 1000
ORDER BY n_dead_tup DESC;
```

### 3.2 问题定位流程

**性能问题定位决策树**:

```sql
-- 步骤1: 检查等待事件
SELECT wait_event_type, wait_event, COUNT(*) as count
FROM pg_stat_activity
WHERE state != 'idle'
GROUP BY wait_event_type, wait_event
ORDER BY count DESC;

-- 如果等待事件是：
-- - I/O: 检查缓冲区命中率、磁盘I/O性能
-- - Lock: 检查锁等待、死锁
-- - CPU: 检查慢查询、索引使用情况
-- - LWLock: 检查WAL写入、检查点

-- 步骤2: 分析慢查询
SELECT query, calls, mean_exec_time, max_exec_time
FROM pg_stat_statements
WHERE mean_exec_time > 100  -- 平均执行时间>100ms
ORDER BY mean_exec_time DESC
LIMIT 10;

-- 步骤3: 对慢查询执行EXPLAIN
-- EXPLAIN (ANALYZE, BUFFERS, VERBOSE) <慢查询SQL>;

-- 步骤4: 根据EXPLAIN结果选择优化策略
-- - Seq Scan: 考虑创建索引
-- - 高cost: 考虑优化查询、更新统计信息
-- - 高buffers: 考虑增加shared_buffers
```

## 4. 变更票据模板

```text
变更项：<参数/SQL/索引/结构>
对象/范围：<库/表/索引/服务>
旧值→新值：<从> → <到>
预期影响：<延迟/吞吐/资源>
验证窗口：<起止时间/灰度比例>
回滚条件：<P95 恶化>10% / 错误率升 / 锁冲突升>
负责人/审批：<Owner/Reviewer>
```

## 5. 执行步骤

1) 建立审计：记录参数旧值（`SHOW`/`pg_file_settings`）与计划基线；
2) 单变量小步变更；
3) 观察 15–30 分钟稳定窗口；
4) 达标则固化与文档化；不达标则回滚。

### 5.1 变更前审计脚本

```sql
-- 1. 记录当前参数值
CREATE TABLE IF NOT EXISTS pg_tuning_audit (
    change_id SERIAL PRIMARY KEY,
    change_time TIMESTAMP DEFAULT NOW(),
    parameter_name TEXT,
    old_value TEXT,
    new_value TEXT,
    change_type TEXT,  -- 'parameter', 'index', 'sql', 'structure'
    change_reason TEXT,
    change_by TEXT
);

-- 记录参数变更
INSERT INTO pg_tuning_audit (parameter_name, old_value, change_type, change_reason, change_by)
SELECT name, setting, 'parameter', 'Performance tuning', current_user
FROM pg_settings
WHERE name IN (
    'shared_buffers', 'work_mem', 'maintenance_work_mem',
    'effective_cache_size', 'max_connections',
    'checkpoint_timeout', 'max_wal_size', 'wal_buffers',
    'random_page_cost', 'effective_io_concurrency'
);

-- 2. 记录当前性能基线
CREATE TABLE IF NOT EXISTS pg_performance_baseline (
    baseline_id SERIAL PRIMARY KEY,
    baseline_time TIMESTAMP DEFAULT NOW(),
    metric_name TEXT,
    metric_value NUMERIC,
    notes TEXT
);

-- 记录关键指标
INSERT INTO pg_performance_baseline (metric_name, metric_value, notes)
SELECT 'buffer_hit_ratio',
       round(100.0 * sum(blks_hit) / NULLIF(sum(blks_hit) + sum(blks_read), 0), 2),
       'Database: ' || datname
FROM pg_stat_database
WHERE datname = current_database()
GROUP BY datname;

-- 3. 记录当前慢查询基线
CREATE TABLE IF NOT EXISTS pg_query_baseline (
    baseline_id SERIAL PRIMARY KEY,
    baseline_time TIMESTAMP DEFAULT NOW(),
    query_id BIGINT,
    query TEXT,
    calls BIGINT,
    mean_exec_time NUMERIC,
    max_exec_time NUMERIC
);

-- 记录Top 20慢查询
INSERT INTO pg_query_baseline (query_id, query, calls, mean_exec_time, max_exec_time)
SELECT queryid, LEFT(query, 500), calls, mean_exec_time, max_exec_time
FROM pg_stat_statements
ORDER BY mean_exec_time DESC
LIMIT 20;
```

### 5.2 参数变更执行脚本

```sql
-- 示例：调整shared_buffers
-- 步骤1: 记录旧值
DO $$
DECLARE
    old_value TEXT;
BEGIN
    SELECT setting INTO old_value FROM pg_settings WHERE name = 'shared_buffers';
    INSERT INTO pg_tuning_audit (parameter_name, old_value, change_type, change_reason, change_by)
    VALUES ('shared_buffers', old_value, 'parameter', 'Increase buffer for better cache hit ratio', current_user);
END $$;

-- 步骤2: 应用新值（需要重启）
-- 方法1: 使用ALTER SYSTEM（推荐）
ALTER SYSTEM SET shared_buffers = '4GB';
SELECT pg_reload_conf();  -- 注意：某些参数需要重启才能生效

-- 方法2: 直接修改postgresql.conf
-- shared_buffers = 4GB

-- 步骤3: 验证变更
SELECT name, setting, unit, source
FROM pg_settings
WHERE name = 'shared_buffers';

-- 步骤4: 更新审计记录
UPDATE pg_tuning_audit
SET new_value = (SELECT setting FROM pg_settings WHERE name = 'shared_buffers')
WHERE parameter_name = 'shared_buffers'
AND change_id = (SELECT MAX(change_id) FROM pg_tuning_audit WHERE parameter_name = 'shared_buffers');
```

### 5.3 索引变更执行脚本

```sql
-- 示例：创建新索引
-- 步骤1: 记录变更
INSERT INTO pg_tuning_audit (parameter_name, old_value, change_type, change_reason, change_by)
VALUES ('idx_orders_customer_date', 'NOT EXISTS', 'index', 'Optimize customer order history query', current_user);

-- 步骤2: 创建索引（使用CONCURRENTLY避免锁表）
CREATE INDEX CONCURRENTLY idx_orders_customer_date ON orders (customer_id, order_date DESC);

-- 步骤3: 验证索引创建
SELECT
    schemaname,
    tablename,
    indexname,
    indexdef
FROM pg_indexes
WHERE indexname = 'idx_orders_customer_date';

-- 步骤4: 测试查询性能
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM orders
WHERE customer_id = 100
ORDER BY order_date DESC
LIMIT 20;
```

### 5.4 观察期监控脚本

```sql
-- 变更后15-30分钟观察期监控
-- 每5分钟执行一次，记录关键指标

CREATE TABLE IF NOT EXISTS pg_tuning_monitoring (
    monitor_id SERIAL PRIMARY KEY,
    monitor_time TIMESTAMP DEFAULT NOW(),
    change_id INTEGER REFERENCES pg_tuning_audit(change_id),
    buffer_hit_ratio NUMERIC,
    avg_query_time NUMERIC,
    active_connections INTEGER,
    lock_waits INTEGER,
    checkpoint_frequency NUMERIC
);

-- 监控脚本（每5分钟执行）
INSERT INTO pg_tuning_monitoring (
    change_id,
    buffer_hit_ratio,
    avg_query_time,
    active_connections,
    lock_waits,
    checkpoint_frequency
)
SELECT
    (SELECT MAX(change_id) FROM pg_tuning_audit) as change_id,
    (SELECT round(100.0 * sum(blks_hit) / NULLIF(sum(blks_hit) + sum(blks_read), 0), 2)
     FROM pg_stat_database WHERE datname = current_database()) as buffer_hit_ratio,
    (SELECT round(avg(mean_exec_time), 2)
     FROM pg_stat_statements WHERE calls > 10) as avg_query_time,
    (SELECT count(*) FROM pg_stat_activity WHERE state != 'idle') as active_connections,
    (SELECT count(*) FROM pg_locks WHERE NOT granted) as lock_waits,
    (SELECT round(extract(epoch from now() - stats_reset) / NULLIF(checkpoints_timed + checkpoints_req, 0), 2)
     FROM pg_stat_bgwriter) as checkpoint_frequency;

-- 查看监控趋势
SELECT
    monitor_time,
    buffer_hit_ratio,
    avg_query_time,
    active_connections,
    lock_waits
FROM pg_tuning_monitoring
WHERE change_id = (SELECT MAX(change_id) FROM pg_tuning_audit)
ORDER BY monitor_time DESC
LIMIT 10;
```

## 6. 常用参数建议（详细）

### 6.1 连接与并发参数

```sql
-- max_connections: 最大连接数
-- 建议值：根据应用连接池配置，通常100-500
-- 注意：每个连接消耗约10MB内存
ALTER SYSTEM SET max_connections = 200;

-- work_mem: 每个操作的工作内存
-- 建议值：根据并发数和可用内存计算
-- 公式：work_mem = (可用内存 - shared_buffers) / (max_connections * 2)
-- 示例：16GB内存，4GB shared_buffers，200连接
-- work_mem = (16GB - 4GB) / (200 * 2) = 30MB
ALTER SYSTEM SET work_mem = '30MB';

-- maintenance_work_mem: 维护操作内存
-- 建议值：1-2GB（用于VACUUM、CREATE INDEX等）
ALTER SYSTEM SET maintenance_work_mem = '1GB';
```

### 6.2 缓冲参数

```sql
-- shared_buffers: 共享缓冲区
-- 建议值：系统内存的25%（Linux）或40%（Windows）
-- 示例：16GB内存系统，设置4GB
ALTER SYSTEM SET shared_buffers = '4GB';

-- effective_cache_size: 有效缓存大小
-- 建议值：系统内存的50-75%
-- 示例：16GB内存系统，设置12GB
ALTER SYSTEM SET effective_cache_size = '12GB';
```

### 6.3 并行和JIT参数

```sql
-- max_parallel_workers_per_gather: 每个Gather节点的最大工作进程数
-- 建议值：CPU核心数的50%
ALTER SYSTEM SET max_parallel_workers_per_gather = 4;

-- max_parallel_workers: 系统最大并行工作进程数
-- 建议值：CPU核心数
ALTER SYSTEM SET max_parallel_workers = 8;

-- jit: 启用JIT编译（PostgreSQL 11+）
-- 建议：对于复杂查询，启用JIT可以提升性能
ALTER SYSTEM SET jit = on;
ALTER SYSTEM SET jit_above_cost = 100000;  -- 只对高cost查询启用JIT
```

### 6.4 I/O参数

```sql
-- random_page_cost: 随机页面访问成本
-- SSD: 1.1-1.5，NVMe: 1.0-1.1，HDD: 4.0（默认）
ALTER SYSTEM SET random_page_cost = 1.1;  -- SSD环境

-- effective_io_concurrency: 有效I/O并发数（PostgreSQL 18增强）
-- SSD: 200-300，NVMe: 300-500，HDD: 50-100
ALTER SYSTEM SET effective_io_concurrency = 200;  -- SSD环境

-- maintenance_io_concurrency: 维护操作I/O并发数（PostgreSQL 18新增）
ALTER SYSTEM SET maintenance_io_concurrency = 200;
```

### 6.5 检查点和WAL参数

```sql
-- checkpoint_timeout: 检查点超时
-- 建议值：15-30分钟
ALTER SYSTEM SET checkpoint_timeout = '15min';

-- max_wal_size: 最大WAL大小
-- 建议值：根据写入负载，通常2-8GB
ALTER SYSTEM SET max_wal_size = '4GB';

-- checkpoint_completion_target: 检查点完成目标
-- 建议值：0.9（平滑写入）
ALTER SYSTEM SET checkpoint_completion_target = 0.9;

-- wal_compression: WAL压缩
-- 建议：启用可以减少WAL大小
ALTER SYSTEM SET wal_compression = on;

-- wal_buffers: WAL缓冲区
-- 建议值：16-32MB（高写入负载）
ALTER SYSTEM SET wal_buffers = '16MB';
```

### 6.6 维护参数

```sql
-- autovacuum相关参数
ALTER SYSTEM SET autovacuum = on;
ALTER SYSTEM SET autovacuum_max_workers = 3;
ALTER SYSTEM SET autovacuum_naptime = '1min';
ALTER SYSTEM SET autovacuum_vacuum_scale_factor = 0.1;  -- 10%死元组触发
ALTER SYSTEM SET autovacuum_analyze_scale_factor = 0.05;  -- 5%变更触发

-- maintenance_work_mem: 维护工作内存
ALTER SYSTEM SET maintenance_work_mem = '1GB';
```

### 6.7 参数变更检查清单

```sql
-- 检查参数是否生效（某些参数需要重启）
SELECT name, setting, unit, context, source
FROM pg_settings
WHERE name IN (
    'shared_buffers', 'work_mem', 'max_connections',
    'checkpoint_timeout', 'max_wal_size'
)
ORDER BY name;

-- context说明：
-- 'postmaster': 需要重启PostgreSQL服务
-- 'sighup': 需要重新加载配置（SELECT pg_reload_conf();）
-- 'user': 可以在会话级别设置
```

## 7. 验证清单

- 指标对比：调优前/后 P95、TPS/QPS、命中率、WAL、检查点；
- SQL 对比：TopN 是否下降、估算偏差是否缓解；
- 资源：CPU/IO/内存是否在阈值内；
- 业务：错误率/超时是否正常。

### 7.1 验证脚本

```sql
-- 1. 性能指标对比
WITH baseline AS (
    SELECT * FROM pg_performance_baseline
    WHERE baseline_id = (SELECT MAX(baseline_id) FROM pg_performance_baseline)
),
current AS (
    SELECT
        round(100.0 * sum(blks_hit) / NULLIF(sum(blks_hit) + sum(blks_read), 0), 2) as buffer_hit_ratio,
        sum(xact_commit) as commits,
        sum(xact_rollback) as rollbacks
    FROM pg_stat_database
    WHERE datname = current_database()
)
SELECT
    'Buffer Hit Ratio' as metric,
    baseline.metric_value as baseline_value,
    current.buffer_hit_ratio as current_value,
    round((current.buffer_hit_ratio - baseline.metric_value)::numeric, 2) as improvement
FROM baseline, current
WHERE baseline.metric_name = 'buffer_hit_ratio';

-- 2. 慢查询对比
WITH baseline AS (
    SELECT queryid, mean_exec_time as baseline_time
    FROM pg_query_baseline
    WHERE baseline_id = (SELECT MAX(baseline_id) FROM pg_query_baseline)
),
current AS (
    SELECT queryid, mean_exec_time as current_time
    FROM pg_stat_statements
)
SELECT
    LEFT(b.query, 100) as query_preview,
    b.baseline_time,
    c.current_time,
    round((b.baseline_time - c.current_time)::numeric, 2) as improvement_ms,
    round(((b.baseline_time - c.current_time) / b.baseline_time * 100)::numeric, 2) as improvement_pct
FROM baseline b
JOIN current c ON b.queryid = c.queryid
WHERE c.current_time < b.baseline_time * 0.9  -- 性能提升>10%
ORDER BY improvement_ms DESC
LIMIT 10;

-- 3. 资源使用检查
SELECT
    'Active Connections' as metric,
    count(*) as value,
    (SELECT setting::integer FROM pg_settings WHERE name = 'max_connections') as max_value,
    round(100.0 * count(*) / (SELECT setting::integer FROM pg_settings WHERE name = 'max_connections'), 2) as usage_pct
FROM pg_stat_activity
WHERE state != 'idle'
UNION ALL
SELECT
    'Lock Waits' as metric,
    count(*) as value,
    NULL as max_value,
    NULL as usage_pct
FROM pg_locks
WHERE NOT granted;

-- 4. 检查点频率对比
SELECT
    checkpoints_timed + checkpoints_req as total_checkpoints,
    round(extract(epoch from now() - stats_reset) / NULLIF(checkpoints_timed + checkpoints_req, 0) / 60, 2) as avg_interval_minutes,
    checkpoint_write_time + checkpoint_sync_time as total_checkpoint_time_ms
FROM pg_stat_bgwriter;
```

### 7.2 验证标准

**性能提升标准**:

- ✅ **缓冲区命中率**: 提升>2% 或 达到>99%
- ✅ **平均查询时间**: 降低>10%
- ✅ **P95/P99延迟**: 降低>10%
- ✅ **TPS/QPS**: 提升>5%
- ✅ **检查点频率**: 降低>20% 或 间隔>10分钟
- ✅ **锁等待**: 减少>50%

**回滚触发条件**:

- ❌ **缓冲区命中率**: 下降>2%
- ❌ **平均查询时间**: 增加>10%
- ❌ **P95/P99延迟**: 增加>10%
- ❌ **错误率**: 增加>1%
- ❌ **锁等待**: 增加>50%
- ❌ **资源使用**: CPU>90% 或 内存>95%

## 8. 回滚与复盘

- 立即恢复参数旧值/撤销索引或重写；
- 附加证据：日志、慢SQL、EXPLAIN、面板截图；
- 复盘条目：问题根因、无效尝试、有效手段、可复用脚本。

### 8.1 回滚脚本

```sql
-- 1. 参数回滚
-- 从审计表获取旧值并恢复
DO $$
DECLARE
    audit_record RECORD;
BEGIN
    SELECT parameter_name, old_value
    INTO audit_record
    FROM pg_tuning_audit
    WHERE change_id = (SELECT MAX(change_id) FROM pg_tuning_audit)
    AND change_type = 'parameter'
    LIMIT 1;

    IF audit_record.parameter_name IS NOT NULL THEN
        EXECUTE format('ALTER SYSTEM SET %I = %L',
                       audit_record.parameter_name,
                       audit_record.old_value);
        PERFORM pg_reload_conf();
        RAISE NOTICE 'Rolled back parameter % to %',
                     audit_record.parameter_name,
                     audit_record.old_value;
    END IF;
END $$;

-- 2. 索引回滚
-- 删除新创建的索引
DROP INDEX CONCURRENTLY IF EXISTS idx_orders_customer_date;

-- 3. 记录回滚操作
INSERT INTO pg_tuning_audit (
    parameter_name,
    old_value,
    new_value,
    change_type,
    change_reason,
    change_by
)
SELECT
    parameter_name,
    new_value,  -- 当前值作为old_value
    old_value,  -- 原始值作为new_value（回滚）
    'rollback',
    'Performance degradation detected',
    current_user
FROM pg_tuning_audit
WHERE change_id = (SELECT MAX(change_id) FROM pg_tuning_audit);
```

### 8.2 复盘模板

**复盘记录表结构**:

```sql
CREATE TABLE IF NOT EXISTS pg_tuning_review (
    review_id SERIAL PRIMARY KEY,
    change_id INTEGER REFERENCES pg_tuning_audit(change_id),
    review_time TIMESTAMP DEFAULT NOW(),
    root_cause TEXT,
    attempted_solutions TEXT[],
    effective_solution TEXT,
    performance_improvement NUMERIC,
    lessons_learned TEXT,
    reusable_scripts TEXT,
    reviewed_by TEXT
);
```

**复盘记录示例**:

```sql
INSERT INTO pg_tuning_review (
    change_id,
    root_cause,
    attempted_solutions,
    effective_solution,
    performance_improvement,
    lessons_learned,
    reusable_scripts,
    reviewed_by
)
VALUES (
    (SELECT MAX(change_id) FROM pg_tuning_audit),
    'Slow customer order history query due to missing index on (customer_id, order_date)',
    ARRAY[
        'Increased work_mem - no improvement',
        'Updated statistics - no improvement',
        'Created composite index - 80% improvement'
    ],
    'Created composite index idx_orders_customer_date ON orders (customer_id, order_date DESC)',
    80.0,  -- 80%性能提升
    'Composite indexes are effective for multi-column WHERE and ORDER BY clauses',
    'CREATE INDEX CONCURRENTLY idx_orders_customer_date ON orders (customer_id, order_date DESC);',
    current_user
);
```

### 8.3 复盘查询

```sql
-- 查看历史变更和复盘记录
SELECT
    a.change_id,
    a.change_time,
    a.parameter_name,
    a.old_value,
    a.new_value,
    a.change_type,
    r.root_cause,
    r.effective_solution,
    r.performance_improvement,
    r.lessons_learned
FROM pg_tuning_audit a
LEFT JOIN pg_tuning_review r ON a.change_id = r.change_id
ORDER BY a.change_time DESC
LIMIT 20;

-- 统计最有效的优化手段
SELECT
    change_type,
    COUNT(*) as total_changes,
    AVG(r.performance_improvement) as avg_improvement,
    MAX(r.performance_improvement) as max_improvement
FROM pg_tuning_audit a
JOIN pg_tuning_review r ON a.change_id = r.change_id
WHERE r.performance_improvement > 0
GROUP BY change_type
ORDER BY avg_improvement DESC;
```
