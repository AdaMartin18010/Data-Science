# 监控与诊断-落地指南（Runbook）

## 1. 组件

- postgres_exporter、Prometheus、Grafana、日志管道（Filebeat/Vector → Loki/Elastic）。
- 参考：`../监控与诊断/06.01-监控与诊断.md`。

## 2. 步骤

1) 创建监控用户：

    ```sql
    CREATE ROLE metrics WITH LOGIN PASSWORD '***';
    GRANT pg_monitor TO metrics;
    -- 细粒度：GRANT pg_read_all_stats TO metrics;
    ```

2) 启动 exporter：

    ```bash
    DATA_SOURCE_NAME="postgresql://metrics:***@127.0.0.1:5432/postgres?sslmode=disable" ./postgres_exporter
    ```

3) Prometheus 抓取：

    ```yaml
    scrape_configs:
    - job_name: pg
        scrape_interval: 15s
        static_configs:
        - targets: ["db1:9187", "db2:9187", "db3:9187"]
    ```

4) Grafana 导入：连接/事务、命中率/WAL、检查点、Autovacuum、锁等待、Top 查询。

### 2.1 完整部署步骤

**步骤1: 创建监控用户和权限**

```sql
-- 创建监控用户
CREATE ROLE metrics WITH LOGIN PASSWORD 'your_secure_password';

-- 授予监控权限（PostgreSQL 10+）
GRANT pg_monitor TO metrics;

-- 或者细粒度权限（PostgreSQL 9.6-）
GRANT pg_read_all_stats TO metrics;
GRANT pg_read_all_settings TO metrics;

-- 允许连接到数据库
GRANT CONNECT ON DATABASE postgres TO metrics;

-- 验证权限
\du metrics
```

**步骤2: 安装和配置postgres_exporter**

```bash
# 下载postgres_exporter
wget https://github.com/prometheus-community/postgres_exporter/releases/download/v0.15.0/postgres_exporter-0.15.0.linux-amd64.tar.gz
tar -xzf postgres_exporter-0.15.0.linux-amd64.tar.gz
cd postgres_exporter-0.15.0.linux-amd64

# 创建配置文件
cat > .env <<EOF
DATA_SOURCE_NAME="postgresql://metrics:your_secure_password@localhost:5432/postgres?sslmode=disable"
EOF

# 启动exporter
./postgres_exporter

# 或使用systemd服务
cat > /etc/systemd/system/postgres_exporter.service <<EOF
[Unit]
Description=PostgreSQL Exporter
After=network.target

[Service]
Type=simple
User=postgres
EnvironmentFile=/etc/postgres_exporter/.env
ExecStart=/usr/local/bin/postgres_exporter
Restart=always

[Install]
WantedBy=multi-user.target
EOF

systemctl daemon-reload
systemctl enable postgres_exporter
systemctl start postgres_exporter
```

**步骤3: 配置Prometheus**

```yaml
# prometheus.yml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

scrape_configs:
  - job_name: 'postgres'
    scrape_interval: 15s
    static_configs:
      - targets:
          - 'db1:9187'
          - 'db2:9187'
          - 'db3:9187'
    relabel_configs:
      - source_labels: [__address__]
        target_label: instance
        regex: '([^:]+):\d+'
        replacement: '${1}'
```

**步骤4: Grafana仪表板配置**

```json
{
  "dashboard": {
    "title": "PostgreSQL Performance",
    "panels": [
      {
        "title": "Connection Count",
        "targets": [
          {
            "expr": "pg_stat_database_numbackends{datname=\"postgres\"}"
          }
        ]
      },
      {
        "title": "Buffer Hit Ratio",
        "targets": [
          {
            "expr": "100 * (pg_stat_database_blks_hit{datname=\"postgres\"} / (pg_stat_database_blks_hit{datname=\"postgres\"} + pg_stat_database_blks_read{datname=\"postgres\"}))"
          }
        ]
      }
    ]
  }
}
```

### 2.2 关键指标查询

**Prometheus查询示例**:

```promql
# 连接数
pg_stat_database_numbackends{datname="postgres"}

# 缓冲区命中率
100 * (pg_stat_database_blks_hit{datname="postgres"} /
       (pg_stat_database_blks_hit{datname="postgres"} +
        pg_stat_database_blks_read{datname="postgres"}))

# 事务提交率
rate(pg_stat_database_xact_commit{datname="postgres"}[5m])

# WAL写入速率
rate(pg_stat_wal_wal_bytes[5m])

# 检查点频率
rate(pg_stat_bgwriter_checkpoints_timed[5m]) +
rate(pg_stat_bgwriter_checkpoints_req[5m])

# 慢查询数（需要pg_stat_statements）
rate(pg_stat_statements_calls{mean_exec_time > 1000}[5m])

# 锁等待数
pg_locks_granted{locktype="relation"} - pg_locks_granted{locktype="relation",granted="true"}
```

## 3. 日志建议

```text
log_line_prefix = '%m [%p] %u@%d %r %a '
log_min_duration_statement = 500ms
log_checkpoints = on
log_autovacuum_min_duration = 1s
log_lock_waits = on
track_io_timing = on
shared_preload_libraries = 'pg_stat_statements,auto_explain'
auto_explain.log_min_duration = '200ms'
auto_explain.log_analyze = on
auto_explain.log_buffers = on
```

## 4. 诊断SQL

- 见 `sql/diagnostics.sql`；慢SQL面板 TopN 与 EXPLAIN 结合。

### 4.1 完整诊断SQL脚本

**文件**: `sql/diagnostics.sql`

```sql
-- ============================================
-- PostgreSQL 完整诊断脚本
-- ============================================

-- 1. 系统概览
SELECT
    version() as pg_version,
    pg_size_pretty(pg_database_size(current_database())) as db_size,
    (SELECT count(*) FROM pg_stat_activity WHERE state != 'idle') as active_connections,
    (SELECT setting FROM pg_settings WHERE name = 'max_connections')::integer as max_connections;

-- 2. 当前活跃会话
SELECT
    pid,
    usename,
    application_name,
    client_addr,
    state,
    wait_event_type,
    wait_event,
    query_start,
    state_change,
    LEFT(query, 100) as query_preview
FROM pg_stat_activity
WHERE state != 'idle'
ORDER BY query_start;

-- 3. 等待事件统计
SELECT
    wait_event_type,
    wait_event,
    COUNT(*) as count
FROM pg_stat_activity
WHERE wait_event IS NOT NULL
GROUP BY wait_event_type, wait_event
ORDER BY count DESC;

-- 4. 锁等待情况
SELECT
    blocked_locks.pid AS blocked_pid,
    blocked_activity.usename AS blocked_user,
    blocking_locks.pid AS blocking_pid,
    blocking_activity.usename AS blocking_user,
    blocked_activity.query AS blocked_statement,
    blocking_activity.query AS blocking_statement,
    blocked_locks.locktype,
    blocked_locks.mode
FROM pg_catalog.pg_locks blocked_locks
JOIN pg_catalog.pg_stat_activity blocked_activity ON blocked_activity.pid = blocked_locks.pid
JOIN pg_catalog.pg_locks blocking_locks
    ON blocking_locks.locktype = blocked_locks.locktype
    AND blocking_locks.database IS NOT DISTINCT FROM blocked_locks.database
    AND blocking_locks.relation IS NOT DISTINCT FROM blocked_locks.relation
    AND blocking_locks.pid != blocked_locks.pid
JOIN pg_catalog.pg_stat_activity blocking_activity ON blocking_activity.pid = blocking_locks.pid
WHERE NOT blocked_locks.granted;

-- 5. Top 10 慢查询（需要pg_stat_statements扩展）
SELECT
    LEFT(query, 100) as query_preview,
    calls,
    round(mean_exec_time::numeric, 2) as mean_ms,
    round(max_exec_time::numeric, 2) as max_ms,
    round(total_exec_time::numeric, 2) as total_ms,
    round((100.0 * shared_blks_hit / NULLIF(shared_blks_hit + shared_blks_read, 0))::numeric, 2) as hit_ratio,
    rows
FROM pg_stat_statements
WHERE calls > 10
ORDER BY mean_exec_time DESC
LIMIT 10;

-- 6. 缓冲区命中率
SELECT
    datname,
    round(100.0 * sum(blks_hit) / NULLIF(sum(blks_hit) + sum(blks_read), 0), 2) as hit_ratio,
    sum(blks_hit) as blks_hit,
    sum(blks_read) as blks_read
FROM pg_stat_database
GROUP BY datname
ORDER BY hit_ratio;

-- 7. 表扫描统计
SELECT
    schemaname,
    tablename,
    seq_scan,
    idx_scan,
    round(100.0 * idx_scan / NULLIF(seq_scan + idx_scan, 0), 2) as idx_scan_ratio,
    n_live_tup,
    n_dead_tup,
    round(100.0 * n_dead_tup / NULLIF(n_live_tup + n_dead_tup, 0), 2) as dead_ratio,
    last_vacuum,
    last_autovacuum
FROM pg_stat_user_tables
WHERE seq_scan + idx_scan > 0
ORDER BY seq_scan DESC
LIMIT 20;

-- 8. 索引使用情况
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch,
    pg_size_pretty(pg_relation_size(indexname::regclass)) as index_size,
    CASE
        WHEN idx_scan = 0 THEN 'UNUSED'
        WHEN idx_tup_read / NULLIF(idx_scan, 0) > 10000 THEN 'INEFFICIENT'
        ELSE 'EFFICIENT'
    END as status
FROM pg_stat_user_indexes
WHERE pg_relation_size(indexname::regclass) > 1000000  -- 大于1MB
ORDER BY idx_scan DESC;

-- 9. WAL和检查点统计
SELECT
    checkpoints_timed,
    checkpoints_req,
    round((checkpoint_write_time + checkpoint_sync_time) / 1000.0, 2) as total_checkpoint_time_sec,
    round(extract(epoch from now() - stats_reset) / NULLIF(checkpoints_timed + checkpoints_req, 0) / 60, 2) as avg_interval_minutes,
    buffers_checkpoint,
    buffers_clean,
    buffers_backend
FROM pg_stat_bgwriter;

-- 10. Autovacuum状态
SELECT
    schemaname,
    tablename,
    n_live_tup,
    n_dead_tup,
    round(100.0 * n_dead_tup / NULLIF(n_live_tup + n_dead_tup, 0), 2) as dead_ratio,
    last_vacuum,
    last_autovacuum,
    last_analyze,
    last_autoanalyze,
    CASE
        WHEN last_vacuum IS NULL AND last_autovacuum IS NULL THEN 'Never vacuumed'
        WHEN last_vacuum > last_autovacuum THEN last_vacuum::text
        ELSE last_autovacuum::text
    END as last_vacuum_time
FROM pg_stat_user_tables
WHERE n_dead_tup > 1000
ORDER BY n_dead_tup DESC
LIMIT 20;
```

### 4.2 慢查询分析流程

```sql
-- 步骤1: 识别慢查询
SELECT
    queryid,
    LEFT(query, 200) as query_preview,
    calls,
    mean_exec_time,
    max_exec_time,
    stddev_exec_time
FROM pg_stat_statements
WHERE mean_exec_time > 100  -- 平均执行时间>100ms
ORDER BY mean_exec_time DESC
LIMIT 10;

-- 步骤2: 获取完整查询（使用queryid）
SELECT query
FROM pg_stat_statements
WHERE queryid = <queryid_from_step1>;

-- 步骤3: 执行EXPLAIN分析
EXPLAIN (ANALYZE, BUFFERS, VERBOSE, TIMING)
<query_from_step2>;

-- 步骤4: 分析执行计划
-- 检查：
-- - Seq Scan: 考虑创建索引
-- - 高cost: 考虑优化查询
-- - 高buffers: 考虑增加shared_buffers
-- - 高execution time: 考虑查询重写
```

## 5. 告警门槛（示例）

- 连接使用率 > 80%；缓冲命中率 < 95%；WAL 速率骤增；检查点过于频繁；Autovacuum 滞后；死锁事件。

### 5.1 Prometheus告警规则

**文件**: `alerts/postgresql_alerts.yml`

```yaml
groups:
  - name: postgresql
    interval: 30s
    rules:
      # 连接数告警
      - alert: PostgreSQLHighConnections
        expr: (pg_stat_database_numbackends{datname="postgres"} /
               pg_settings_max_connections{name="max_connections"}) > 0.8
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "PostgreSQL连接数过高"
          description: "数据库连接数使用率超过80%: {{ $value | humanizePercentage }}"

      # 缓冲区命中率告警
      - alert: PostgreSQLLowBufferHitRatio
        expr: 100 * (pg_stat_database_blks_hit{datname="postgres"} /
                      (pg_stat_database_blks_hit{datname="postgres"} +
                       pg_stat_database_blks_read{datname="postgres"})) < 95
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "PostgreSQL缓冲区命中率过低"
          description: "缓冲区命中率低于95%: {{ $value }}%"

      # WAL速率告警
      - alert: PostgreSQLHighWALRate
        expr: rate(pg_stat_wal_wal_bytes[5m]) > 100000000  # 100MB/s
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "PostgreSQL WAL写入速率过高"
          description: "WAL写入速率: {{ $value | humanize }}B/s"

      # 检查点频率告警
      - alert: PostgreSQLFrequentCheckpoints
        expr: (rate(pg_stat_bgwriter_checkpoints_timed[5m]) +
               rate(pg_stat_bgwriter_checkpoints_req[5m])) > 0.1  # 每10分钟一次
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: "PostgreSQL检查点过于频繁"
          description: "检查点频率: {{ $value }}次/秒"

      # 锁等待告警
      - alert: PostgreSQLLockWaits
        expr: pg_locks_not_granted > 10
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "PostgreSQL锁等待过多"
          description: "未授予的锁数量: {{ $value }}"

      # 死锁告警
      - alert: PostgreSQLDeadlocks
        expr: increase(pg_stat_database_deadlocks{datname="postgres"}[5m]) > 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "PostgreSQL检测到死锁"
          description: "数据库发生死锁事件"

      # Autovacuum滞后告警
      - alert: PostgreSQLAutovacuumLag
        expr: (pg_stat_user_tables_n_dead_tup /
               NULLIF(pg_stat_user_tables_n_live_tup, 0)) > 0.2
        for: 30m
        labels:
          severity: warning
        annotations:
          summary: "PostgreSQL Autovacuum滞后"
          description: "表 {{ $labels.schemaname }}.{{ $labels.relname }} 死元组比例超过20%"

      # 慢查询告警
      - alert: PostgreSQLSlowQueries
        expr: rate(pg_stat_statements_calls{mean_exec_time > 1000}[5m]) > 10
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "PostgreSQL慢查询过多"
          description: "平均执行时间>1秒的查询调用频率: {{ $value }}次/秒"

      # 复制延迟告警（流复制场景）
      - alert: PostgreSQLReplicationLag
        expr: pg_replication_lag > 10485760  # 10MB
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "PostgreSQL复制延迟过高"
          description: "复制延迟: {{ $value | humanize }}B"
```

### 5.2 告警阈值建议

**告警阈值表**:

| 指标 | 警告阈值 | 严重阈值 | 说明 |
|------|---------|---------|------|
| 连接使用率 | >80% | >95% | 接近最大连接数 |
| 缓冲区命中率 | <95% | <90% | I/O性能下降 |
| WAL写入速率 | >100MB/s | >500MB/s | 写入负载过高 |
| 检查点频率 | >0.1次/秒 | >0.2次/秒 | 检查点过于频繁 |
| 锁等待数 | >10 | >50 | 并发冲突 |
| 死锁事件 | >0 | >0 | 立即告警 |
| 死元组比例 | >20% | >40% | Autovacuum滞后 |
| 慢查询频率 | >10次/秒 | >50次/秒 | 查询性能问题 |

### 5.3 告警通知配置

**Alertmanager配置示例**:

```yaml
# alertmanager.yml
route:
  group_by: ['alertname', 'cluster', 'service']
  group_wait: 10s
  group_interval: 10s
  repeat_interval: 12h
  receiver: 'default'
  routes:
    - match:
        severity: critical
      receiver: 'critical-alerts'
    - match:
        severity: warning
      receiver: 'warning-alerts'

receivers:
  - name: 'default'
    webhook_configs:
      - url: 'http://alert-receiver:9093/webhook'

  - name: 'critical-alerts'
    email_configs:
      - to: 'dba-team@example.com'
        subject: 'PostgreSQL Critical Alert: {{ .GroupLabels.alertname }}'
    webhook_configs:
      - url: 'http://alert-receiver:9093/webhook'
    slack_configs:
      - api_url: 'https://hooks.slack.com/services/YOUR/WEBHOOK/URL'
        channel: '#postgresql-alerts'
        title: 'PostgreSQL Critical Alert'
        text: '{{ .GroupLabels.alertname }}: {{ .CommonAnnotations.description }}'

  - name: 'warning-alerts'
    email_configs:
      - to: 'dba-team@example.com'
        subject: 'PostgreSQL Warning: {{ .GroupLabels.alertname }}'
```
