# æ‰©å±•ç³»ç»Ÿä¸æ’ä»¶å¼€å‘

> **æ–‡æ¡£ç‰ˆæœ¬**: v2.0
> **æœ€åæ›´æ–°**: 2025-11-12
> **ç‰ˆæœ¬è¦†ç›–**: PostgreSQL 18.x (æ¨è) â­ | 17.x (æ¨è) | 16.x (å…¼å®¹)
> **æ–‡æ¡£çŠ¶æ€**: âœ… å·²æ›´æ–°

---

## ğŸ“‹ ç›®å½•

- [æ‰©å±•ç³»ç»Ÿä¸æ’ä»¶å¼€å‘](#æ‰©å±•ç³»ç»Ÿä¸æ’ä»¶å¼€å‘)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. å®šä¹‰ä¸å½¢å¼åŒ–](#1-å®šä¹‰ä¸å½¢å¼åŒ–)
    - [1.1 æ¦‚å¿µå®šä¹‰](#11-æ¦‚å¿µå®šä¹‰)
    - [1.2 å½¢å¼åŒ–å®šä¹‰](#12-å½¢å¼åŒ–å®šä¹‰)
    - [1.3 æ ¸å¿ƒç‰¹æ€§](#13-æ ¸å¿ƒç‰¹æ€§)
  - [2. æ‰©å±•ç³»ç»Ÿæ¶æ„](#2-æ‰©å±•ç³»ç»Ÿæ¶æ„)
    - [2.1 æ‰©å±•ç®¡ç†](#21-æ‰©å±•ç®¡ç†)
    - [2.2 æ‰©å±•é…ç½®](#22-æ‰©å±•é…ç½®)
  - [3. Cè¯­è¨€æ‰©å±•å¼€å‘](#3-cè¯­è¨€æ‰©å±•å¼€å‘)
    - [3.1 æ‰©å±•ç»“æ„](#31-æ‰©å±•ç»“æ„)
    - [3.2 æ•°æ®ç±»å‹æ‰©å±•](#32-æ•°æ®ç±»å‹æ‰©å±•)
    - [3.3 æ“ä½œç¬¦æ‰©å±•](#33-æ“ä½œç¬¦æ‰©å±•)
  - [4. SQLæ‰©å±•å¼€å‘](#4-sqlæ‰©å±•å¼€å‘)
    - [4.1 æ§åˆ¶æ–‡ä»¶](#41-æ§åˆ¶æ–‡ä»¶)
    - [4.2 å®‰è£…è„šæœ¬](#42-å®‰è£…è„šæœ¬)
    - [4.3 å‡çº§è„šæœ¬](#43-å‡çº§è„šæœ¬)
  - [5. ç¬¬ä¸‰æ–¹æ‰©å±•é›†æˆ](#5-ç¬¬ä¸‰æ–¹æ‰©å±•é›†æˆ)
    - [5.1 æµè¡Œæ‰©å±•](#51-æµè¡Œæ‰©å±•)
    - [5.2 åœ°ç†ç©ºé—´æ‰©å±•](#52-åœ°ç†ç©ºé—´æ‰©å±•)
    - [5.3 æ—¶é—´åºåˆ—æ‰©å±•](#53-æ—¶é—´åºåˆ—æ‰©å±•)
  - [6. æ‰©å±•å¼€å‘æœ€ä½³å®è·µ](#6-æ‰©å±•å¼€å‘æœ€ä½³å®è·µ)
    - [6.1 é”™è¯¯å¤„ç†](#61-é”™è¯¯å¤„ç†)
    - [6.2 å†…å­˜ç®¡ç†](#62-å†…å­˜ç®¡ç†)
    - [6.3 æ€§èƒ½ä¼˜åŒ–](#63-æ€§èƒ½ä¼˜åŒ–)
  - [7. å®é™…åº”ç”¨æ¡ˆä¾‹](#7-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [7.1 è‡ªå®šä¹‰èšåˆå‡½æ•°](#71-è‡ªå®šä¹‰èšåˆå‡½æ•°)
    - [7.2 è‡ªå®šä¹‰ç´¢å¼•](#72-è‡ªå®šä¹‰ç´¢å¼•)
  - [8. ç›¸å…³æ¦‚å¿µ](#8-ç›¸å…³æ¦‚å¿µ)
    - [8.1 ä¸Šä½æ¦‚å¿µ](#81-ä¸Šä½æ¦‚å¿µ)
    - [8.2 ä¸‹ä½æ¦‚å¿µ](#82-ä¸‹ä½æ¦‚å¿µ)
    - [8.3 å¹³è¡Œæ¦‚å¿µ](#83-å¹³è¡Œæ¦‚å¿µ)
  - [9. å‚è€ƒæ–‡çŒ®](#9-å‚è€ƒæ–‡çŒ®)
  - [10. Wikidataå¯¹é½](#10-wikidataå¯¹é½)

---

## 1. å®šä¹‰ä¸å½¢å¼åŒ–

### 1.1 æ¦‚å¿µå®šä¹‰

**ä¸­æ–‡å®šä¹‰**: æ‰©å±•ç³»ç»Ÿæ˜¯PostgreSQLæä¾›çš„æ’ä»¶åŒ–æ¶æ„ï¼Œå…è®¸å¼€å‘è€…åˆ›å»ºè‡ªå®šä¹‰æ‰©å±•æ¥å¢å¼ºæ•°æ®åº“åŠŸèƒ½ã€‚æ’ä»¶å¼€å‘åŒ…æ‹¬Cè¯­è¨€æ‰©å±•ã€SQLæ‰©å±•å’Œç¬¬ä¸‰æ–¹é›†æˆï¼Œå®ç°åŠŸèƒ½çš„æ¨¡å—åŒ–å’Œå¯æ‰©å±•æ€§ã€‚

**English Definition**: The extension system is a plugin architecture provided by PostgreSQL that allows developers to create custom extensions to enhance database functionality. Plugin development includes C language extensions, SQL extensions, and third-party integrations, achieving modularity and extensibility of functionality.

### 1.2 å½¢å¼åŒ–å®šä¹‰

```latex
% æ•°å­¦ç¬¦å·å®šä¹‰
\newcommand{\extension}{\mathcal{E}}
\newcommand{\plugin}{\mathcal{P}}
\newcommand{\interface}{\mathcal{I}}

% æ‰©å±•ç³»ç»Ÿçš„å½¢å¼åŒ–å®šä¹‰
\extension = \{p_1, p_2, \ldots, p_n\}

å…¶ä¸­æ¯ä¸ªæ’ä»¶ p_i = (name_i, version_i, interfaces_i, dependencies_i) è¡¨ç¤ºï¼š
- name_i: æ’ä»¶åç§°
- version_i: æ’ä»¶ç‰ˆæœ¬
- interfaces_i: æ¥å£é›†åˆ
- dependencies_i: ä¾èµ–å…³ç³»
```

### 1.3 æ ¸å¿ƒç‰¹æ€§

- **æ¨¡å—åŒ–è®¾è®¡**: åŠŸèƒ½æ¨¡å—åŒ–ï¼Œæ˜“äºç»´æŠ¤å’Œæ‰©å±•
- **ç‰ˆæœ¬ç®¡ç†**: æ”¯æŒæ‰©å±•ç‰ˆæœ¬æ§åˆ¶å’Œå‡çº§
- **ä¾èµ–ç®¡ç†**: è‡ªåŠ¨å¤„ç†æ‰©å±•ä¾èµ–å…³ç³»
- **æ¥å£æ ‡å‡†åŒ–**: ç»Ÿä¸€çš„æ‰©å±•æ¥å£è§„èŒƒ
- **çƒ­æ’æ‹”**: æ”¯æŒè¿è¡Œæ—¶åŠ è½½å’Œå¸è½½æ‰©å±•

## 2. æ‰©å±•ç³»ç»Ÿæ¶æ„

### 2.1 æ‰©å±•ç®¡ç†

```sql
-- æŸ¥çœ‹å·²å®‰è£…æ‰©å±•
SELECT
    extname,
    extversion,
    extrelocatable,
    extconfig,
    extcondition
FROM pg_extension
ORDER BY extname;

-- å®‰è£…æ‰©å±•
CREATE EXTENSION IF NOT EXISTS hstore;
CREATE EXTENSION IF NOT EXISTS pg_stat_statements;
CREATE EXTENSION IF NOT EXISTS pg_trgm;

-- æ›´æ–°æ‰©å±•
ALTER EXTENSION hstore UPDATE TO '1.8';

-- å¸è½½æ‰©å±•
DROP EXTENSION IF EXISTS hstore;
```

### 2.2 æ‰©å±•é…ç½®

```sql
-- æŸ¥çœ‹æ‰©å±•é…ç½®
SELECT
    name,
    setting,
    unit,
    context,
    vartype,
    source,
    min_val,
    max_val,
    enumvals
FROM pg_settings
WHERE name LIKE '%extension%';

-- é…ç½®æ‰©å±•å‚æ•°
ALTER SYSTEM SET shared_preload_libraries = 'pg_stat_statements';
SELECT pg_reload_conf();
```

## 3. Cè¯­è¨€æ‰©å±•å¼€å‘

### 3.1 æ‰©å±•ç»“æ„

```c
// æ‰©å±•å¤´æ–‡ä»¶
#include "postgres.h"
#include "fmgr.h"
#include "utils/builtins.h"

PG_MODULE_MAGIC;

// å‡½æ•°å£°æ˜
PG_FUNCTION_INFO_V1(my_function);

// å‡½æ•°å®ç°
Datum
my_function(PG_FUNCTION_ARGS)
{
    text *arg1 = PG_GETARG_TEXT_PP(0);
    int32 arg2 = PG_GETARG_INT32(1);

    // å‡½æ•°é€»è¾‘
    text *result = cstring_to_text("Hello from extension!");

    PG_RETURN_TEXT_P(result);
}
```

### 3.2 æ•°æ®ç±»å‹æ‰©å±•

```c
// è‡ªå®šä¹‰æ•°æ®ç±»å‹
typedef struct {
    int32 x;
    int32 y;
} Point2D;

// è¾“å…¥å‡½æ•°
PG_FUNCTION_INFO_V1(point2d_in);
Datum
point2d_in(PG_FUNCTION_ARGS)
{
    char *str = PG_GETARG_CSTRING(0);
    Point2D *point = (Point2D *) palloc(sizeof(Point2D));

    if (sscanf(str, "(%d,%d)", &point->x, &point->y) != 2)
        ereport(ERROR,
                (errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),
                 errmsg("invalid input syntax for type point2d: \"%s\"", str)));

    PG_RETURN_POINTER(point);
}

// è¾“å‡ºå‡½æ•°
PG_FUNCTION_INFO_V1(point2d_out);
Datum
point2d_out(PG_FUNCTION_ARGS)
{
    Point2D *point = (Point2D *) PG_GETARG_POINTER(0);
    char *result = psprintf("(%d,%d)", point->x, point->y);

    PG_RETURN_CSTRING(result);
}
```

### 3.3 æ“ä½œç¬¦æ‰©å±•

```c
// æ“ä½œç¬¦å‡½æ•°
PG_FUNCTION_INFO_V1(point2d_add);
Datum
point2d_add(PG_FUNCTION_ARGS)
{
    Point2D *p1 = (Point2D *) PG_GETARG_POINTER(0);
    Point2D *p2 = (Point2D *) PG_GETARG_POINTER(1);
    Point2D *result = (Point2D *) palloc(sizeof(Point2D));

    result->x = p1->x + p2->x;
    result->y = p1->y + p2->y;

    PG_RETURN_POINTER(result);
}

// æ¯”è¾ƒå‡½æ•°
PG_FUNCTION_INFO_V1(point2d_eq);
Datum
point2d_eq(PG_FUNCTION_ARGS)
{
    Point2D *p1 = (Point2D *) PG_GETARG_POINTER(0);
    Point2D *p2 = (Point2D *) PG_GETARG_POINTER(1);

    PG_RETURN_BOOL(p1->x == p2->x && p1->y == p2->y);
}
```

## 4. SQLæ‰©å±•å¼€å‘

### 4.1 æ§åˆ¶æ–‡ä»¶

```sql
-- æ‰©å±•æ§åˆ¶æ–‡ä»¶ (my_extension.control)
comment = 'My custom extension'
default_version = '1.0'
module_pathname = '$libdir/my_extension'
relocatable = true
```

### 4.2 å®‰è£…è„šæœ¬

```sql
-- æ‰©å±•å®‰è£…è„šæœ¬ (my_extension--1.0.sql)
-- åˆ›å»ºè‡ªå®šä¹‰ç±»å‹
CREATE TYPE point2d;

-- åˆ›å»ºè¾“å…¥è¾“å‡ºå‡½æ•°
CREATE FUNCTION point2d_in(cstring)
RETURNS point2d
AS 'MODULE_PATHNAME'
LANGUAGE C IMMUTABLE STRICT;

CREATE FUNCTION point2d_out(point2d)
RETURNS cstring
AS 'MODULE_PATHNAME'
LANGUAGE C IMMUTABLE STRICT;

-- åˆ›å»ºç±»å‹
CREATE TYPE point2d (
    INPUT = point2d_in,
    OUTPUT = point2d_out,
    INTERNALLENGTH = 8,
    ALIGNMENT = int4,
    STORAGE = plain
);

-- åˆ›å»ºæ“ä½œç¬¦
CREATE OPERATOR + (
    LEFTARG = point2d,
    RIGHTARG = point2d,
    PROCEDURE = point2d_add,
    COMMUTATOR = +
);

CREATE OPERATOR = (
    LEFTARG = point2d,
    RIGHTARG = point2d,
    PROCEDURE = point2d_eq,
    COMMUTATOR = =,
    NEGATOR = <>
);
```

### 4.3 å‡çº§è„šæœ¬

```sql
-- æ‰©å±•å‡çº§è„šæœ¬ (my_extension--1.0--1.1.sql)
-- æ·»åŠ æ–°å‡½æ•°
CREATE FUNCTION point2d_distance(point2d, point2d)
RETURNS float8
AS 'MODULE_PATHNAME'
LANGUAGE C IMMUTABLE STRICT;

-- æ·»åŠ æ–°æ“ä½œç¬¦
CREATE OPERATOR <-> (
    LEFTARG = point2d,
    RIGHTARG = point2d,
    PROCEDURE = point2d_distance,
    COMMUTATOR = <->
);
```

## 5. ç¬¬ä¸‰æ–¹æ‰©å±•é›†æˆ

### 5.1 æµè¡Œæ‰©å±•

```sql
-- å…¨æ–‡æœç´¢æ‰©å±•
CREATE EXTENSION IF NOT EXISTS pg_trgm;
CREATE EXTENSION IF NOT EXISTS btree_gin;

-- åˆ›å»ºå…¨æ–‡æœç´¢ç´¢å¼•
CREATE INDEX idx_content_trgm ON documents USING gin (content gin_trgm_ops);

-- ç›¸ä¼¼åº¦æœç´¢
SELECT title, similarity(title, 'postgresql database') as sim
FROM documents
WHERE title % 'postgresql database'
ORDER BY sim DESC;

-- ç»Ÿè®¡ä¿¡æ¯æ‰©å±•
CREATE EXTENSION IF NOT EXISTS pg_stat_statements;

-- æŸ¥çœ‹æŸ¥è¯¢ç»Ÿè®¡
SELECT
    query,
    calls,
    total_time,
    mean_time,
    rows
FROM pg_stat_statements
ORDER BY total_time DESC
LIMIT 10;
```

### 5.2 åœ°ç†ç©ºé—´æ‰©å±•

```sql
-- PostGISæ‰©å±•
CREATE EXTENSION IF NOT EXISTS postgis;

-- åˆ›å»ºåœ°ç†ç©ºé—´è¡¨
CREATE TABLE locations (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    geom GEOMETRY(POINT, 4326)
);

-- æ’å…¥åœ°ç†æ•°æ®
INSERT INTO locations (name, geom) VALUES
('New York', ST_GeomFromText('POINT(-74.0059 40.7128)', 4326)),
('London', ST_GeomFromText('POINT(-0.1276 51.5074)', 4326));

-- åœ°ç†ç©ºé—´æŸ¥è¯¢
SELECT
    name,
    ST_Distance(geom, ST_GeomFromText('POINT(-74.0059 40.7128)', 4326)) as distance
FROM locations
ORDER BY distance;
```

### 5.3 æ—¶é—´åºåˆ—æ‰©å±•

```sql
-- TimescaleDBæ‰©å±•
CREATE EXTENSION IF NOT EXISTS timescaledb;

-- åˆ›å»ºæ—¶é—´åºåˆ—è¡¨
CREATE TABLE sensor_data (
    time TIMESTAMPTZ NOT NULL,
    sensor_id INTEGER NOT NULL,
    temperature DOUBLE PRECISION NULL,
    humidity DOUBLE PRECISION NULL
);

-- è½¬æ¢ä¸ºè¶…è¡¨
SELECT create_hypertable('sensor_data', 'time');

-- æ—¶é—´åºåˆ—æŸ¥è¯¢
SELECT
    time_bucket('1 hour', time) as hour,
    sensor_id,
    AVG(temperature) as avg_temp,
    MAX(temperature) as max_temp
FROM sensor_data
WHERE time >= NOW() - INTERVAL '24 hours'
GROUP BY hour, sensor_id
ORDER BY hour;
```

## 6. æ‰©å±•å¼€å‘æœ€ä½³å®è·µ

### 6.1 é”™è¯¯å¤„ç†

```c
// é”™è¯¯å¤„ç†ç¤ºä¾‹
PG_FUNCTION_INFO_V1(safe_divide);
Datum
safe_divide(PG_FUNCTION_ARGS)
{
    float8 arg1 = PG_GETARG_FLOAT8(0);
    float8 arg2 = PG_GETARG_FLOAT8(1);

    if (arg2 == 0.0)
        ereport(ERROR,
                (errcode(ERRCODE_DIVISION_BY_ZERO),
                 errmsg("division by zero")));

    PG_RETURN_FLOAT8(arg1 / arg2);
}
```

### 6.2 å†…å­˜ç®¡ç†

```c
// å†…å­˜ç®¡ç†ç¤ºä¾‹
PG_FUNCTION_INFO_V1(create_array);
Datum
create_array(PG_FUNCTION_ARGS)
{
    int32 count = PG_GETARG_INT32(0);
    ArrayType *result;
    Datum *values;
    bool *nulls;
    int i;

    // åˆ†é…å†…å­˜
    values = (Datum *) palloc(sizeof(Datum) * count);
    nulls = (bool *) palloc(sizeof(bool) * count);

    // å¡«å……æ•°ç»„
    for (i = 0; i < count; i++) {
        values[i] = Int32GetDatum(i * i);
        nulls[i] = false;
    }

    // åˆ›å»ºæ•°ç»„
    result = construct_array(values, count, INT4OID, 4, true, 'i');

    // æ¸…ç†å†…å­˜
    pfree(values);
    pfree(nulls);

    PG_RETURN_ARRAYTYPE_P(result);
}
```

### 6.3 æ€§èƒ½ä¼˜åŒ–

```c
// æ€§èƒ½ä¼˜åŒ–ç¤ºä¾‹
PG_FUNCTION_INFO_V1(fast_string_compare);
Datum
fast_string_compare(PG_FUNCTION_ARGS)
{
    text *arg1 = PG_GETARG_TEXT_PP(0);
    text *arg2 = PG_GETARG_TEXT_PP(1);
    int result;

    // ä½¿ç”¨å¿«é€Ÿæ¯”è¾ƒ
    result = text_cmp(arg1, arg2);

    if (result < 0)
        PG_RETURN_INT32(-1);
    else if (result > 0)
        PG_RETURN_INT32(1);
    else
        PG_RETURN_INT32(0);
}
```

## 7. å®é™…åº”ç”¨æ¡ˆä¾‹

### 7.1 è‡ªå®šä¹‰èšåˆå‡½æ•°

```c
// è‡ªå®šä¹‰èšåˆå‡½æ•°
typedef struct {
    int64 sum;
    int64 count;
} MyAggState;

PG_FUNCTION_INFO_V1(my_agg_transfn);
Datum
my_agg_transfn(PG_FUNCTION_ARGS)
{
    MyAggState *state;
    int64 value = PG_GETARG_INT64(0);

    if (PG_ARGISNULL(0))
        PG_RETURN_NULL();

    if (PG_ARGISNULL(1)) {
        state = (MyAggState *) palloc(sizeof(MyAggState));
        state->sum = 0;
        state->count = 0;
    } else {
        state = (MyAggState *) PG_GETARG_POINTER(1);
    }

    state->sum += value;
    state->count++;

    PG_RETURN_POINTER(state);
}

PG_FUNCTION_INFO_V1(my_agg_finalfn);
Datum
my_agg_finalfn(PG_FUNCTION_ARGS)
{
    MyAggState *state = (MyAggState *) PG_GETARG_POINTER(0);

    if (state == NULL || state->count == 0)
        PG_RETURN_NULL();

    PG_RETURN_FLOAT8((double) state->sum / state->count);
}
```

### 7.2 è‡ªå®šä¹‰ç´¢å¼•

```c
// è‡ªå®šä¹‰ç´¢å¼•æ“ä½œç¬¦ç±»
PG_FUNCTION_INFO_V1(my_btree_compare);
Datum
my_btree_compare(PG_FUNCTION_ARGS)
{
    MyType *a = (MyType *) PG_GETARG_POINTER(0);
    MyType *b = (MyType *) PG_GETARG_POINTER(1);

    if (a->value < b->value)
        PG_RETURN_INT32(-1);
    else if (a->value > b->value)
        PG_RETURN_INT32(1);
    else
        PG_RETURN_INT32(0);
}
```

## 8. ç›¸å…³æ¦‚å¿µ

### 8.1 ä¸Šä½æ¦‚å¿µ

- **æ•°æ®åº“ç³»ç»Ÿ**: æ›´å¹¿æ³›çš„æ•°æ®åº“ç³»ç»Ÿ
- **è½¯ä»¶æ¶æ„**: è½¯ä»¶æ¶æ„è®¾è®¡
- **æ¨¡å—åŒ–è®¾è®¡**: æ¨¡å—åŒ–ç¼–ç¨‹

### 8.2 ä¸‹ä½æ¦‚å¿µ

- **Cè¯­è¨€æ‰©å±•**: Cè¯­è¨€æ’ä»¶å¼€å‘
- **SQLæ‰©å±•**: SQLè„šæœ¬æ‰©å±•
- **ç¬¬ä¸‰æ–¹é›†æˆ**: ç¬¬ä¸‰æ–¹åº“é›†æˆ

### 8.3 å¹³è¡Œæ¦‚å¿µ

- **æ’ä»¶ç³»ç»Ÿ**: æ’ä»¶æ¶æ„
- **æ¨¡å—ç³»ç»Ÿ**: æ¨¡å—åŒ–ç³»ç»Ÿ
- **APIè®¾è®¡**: åº”ç”¨ç¨‹åºæ¥å£è®¾è®¡

## 9. å‚è€ƒæ–‡çŒ®

1. PostgreSQL Global Development Group. (2025). PostgreSQL 18 Documentation. <https://www.postgresql.org/docs/18/>
2. Obe, R., & Hsu, L. (2015). PostgreSQL: Up and Running (2nd ed.). O'Reilly Media.
3. Krosing, H., & Roybal, K. (2019). PostgreSQL 11 Server Side Programming Quick Start Guide. Packt Publishing.
4. Riggs, S., et al. (2017). PostgreSQL 9.6 High Performance. Packt Publishing.
5. PostgreSQL Global Development Group. (2024). PostgreSQL 17 Documentation. <https://www.postgresql.org/docs/17/>

## 10. Wikidataå¯¹é½

- **Wikidata ID**: Q192490
- **ç›¸å…³å±æ€§**:
  - P31: Q176165 (instance of: database management system)
  - P178: Q9366 (developer: PostgreSQL Global Development Group)
  - P277: Q193321 (programmed in: C)
  - P348: 18.0 (software version)
- **å¤–éƒ¨é“¾æ¥**:
  - <https://www.postgresql.org/docs/current/extend.html>
  - <https://www.postgresql.org/docs/current/contrib.html>
