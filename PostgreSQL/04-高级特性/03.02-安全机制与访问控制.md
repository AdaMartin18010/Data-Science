# å®‰å…¨æœºåˆ¶ä¸è®¿é—®æ§åˆ¶

> **æ–‡æ¡£ç‰ˆæœ¬**: v2.0
> **æœ€åæ›´æ–°**: 2025-11-12
> **ç‰ˆæœ¬è¦†ç›–**: PostgreSQL 18.x (æ¨è) â­ | 17.x (æ¨è) | 16.x (å…¼å®¹)
> **æ–‡æ¡£çŠ¶æ€**: âœ… å·²æ›´æ–°
> ğŸ†• **PostgreSQL 18å®‰å…¨å¢å¼º**
>
> PostgreSQL 18åœ¨å®‰å…¨æ–¹é¢å¸¦æ¥ä»¥ä¸‹æ”¹è¿›ï¼š
>
> - âœ… **OAuth 2.0èº«ä»½éªŒè¯**: ä¼ä¸šçº§èº«ä»½éªŒè¯æ”¯æŒ
> - âœ… **å¢å¼ºçš„è®¿é—®æ§åˆ¶**: æ›´ç»†ç²’åº¦çš„æƒé™ç®¡ç†
> - âœ… **å®¡è®¡æ—¥å¿—å¢å¼º**: æ›´è¯¦ç»†çš„å®¡è®¡ä¿¡æ¯

---

## ğŸ“‹ ç›®å½•

- [å®‰å…¨æœºåˆ¶ä¸è®¿é—®æ§åˆ¶](#å®‰å…¨æœºåˆ¶ä¸è®¿é—®æ§åˆ¶)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. å®šä¹‰ä¸å½¢å¼åŒ–](#1-å®šä¹‰ä¸å½¢å¼åŒ–)
    - [1.1 æ¦‚å¿µå®šä¹‰](#11-æ¦‚å¿µå®šä¹‰)
    - [1.2 å½¢å¼åŒ–å®šä¹‰](#12-å½¢å¼åŒ–å®šä¹‰)
    - [1.3 æ ¸å¿ƒç‰¹æ€§](#13-æ ¸å¿ƒç‰¹æ€§)
  - [2. ç”¨æˆ·è®¤è¯ç³»ç»Ÿ](#2-ç”¨æˆ·è®¤è¯ç³»ç»Ÿ)
    - [2.1 è®¤è¯æ–¹æ³•](#21-è®¤è¯æ–¹æ³•)
    - [2.2 å¯†ç ç­–ç•¥](#22-å¯†ç ç­–ç•¥)
    - [2.3 å¤šå› ç´ è®¤è¯](#23-å¤šå› ç´ è®¤è¯)
    - [2.4 OAuth 2.0èº«ä»½éªŒè¯ï¼ˆPostgreSQL 18 æ–°ç‰¹æ€§ï¼‰](#24-oauth-20èº«ä»½éªŒè¯postgresql-18-æ–°ç‰¹æ€§)
  - [3. æƒé™ç®¡ç†ç³»ç»Ÿ](#3-æƒé™ç®¡ç†ç³»ç»Ÿ)
    - [3.1 è§’è‰²ç®¡ç†](#31-è§’è‰²ç®¡ç†)
    - [3.2 ç»†ç²’åº¦æƒé™æ§åˆ¶](#32-ç»†ç²’åº¦æƒé™æ§åˆ¶)
    - [3.3 åŠ¨æ€æƒé™ç®¡ç†](#33-åŠ¨æ€æƒé™ç®¡ç†)
  - [4. æ•°æ®åŠ å¯†](#4-æ•°æ®åŠ å¯†)
    - [4.1 ä¼ è¾“åŠ å¯†](#41-ä¼ è¾“åŠ å¯†)
    - [4.2 å­˜å‚¨åŠ å¯†](#42-å­˜å‚¨åŠ å¯†)
    - [4.3 å­—æ®µçº§åŠ å¯†](#43-å­—æ®µçº§åŠ å¯†)
  - [5. å®¡è®¡æ—¥å¿—](#5-å®¡è®¡æ—¥å¿—)
    - [5.1 å®¡è®¡é…ç½®](#51-å®¡è®¡é…ç½®)
    - [5.2 å®¡è®¡è§¦å‘å™¨](#52-å®¡è®¡è§¦å‘å™¨)
    - [5.3 å®‰å…¨äº‹ä»¶ç›‘æ§](#53-å®‰å…¨äº‹ä»¶ç›‘æ§)
  - [6. ç½‘ç»œå®‰å…¨](#6-ç½‘ç»œå®‰å…¨)
    - [6.1 è¿æ¥é™åˆ¶](#61-è¿æ¥é™åˆ¶)
    - [6.2 IPç™½åå•](#62-ipç™½åå•)
  - [7. å®é™…åº”ç”¨æ¡ˆä¾‹](#7-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [7.1 å¤šç§Ÿæˆ·å®‰å…¨æ¶æ„](#71-å¤šç§Ÿæˆ·å®‰å…¨æ¶æ„)
    - [7.2 é‡‘èçº§å®‰å…¨](#72-é‡‘èçº§å®‰å…¨)
  - [8. ç›¸å…³æ¦‚å¿µ](#8-ç›¸å…³æ¦‚å¿µ)
    - [8.1 ä¸Šä½æ¦‚å¿µ](#81-ä¸Šä½æ¦‚å¿µ)
    - [8.2 ä¸‹ä½æ¦‚å¿µ](#82-ä¸‹ä½æ¦‚å¿µ)
    - [8.3 å¹³è¡Œæ¦‚å¿µ](#83-å¹³è¡Œæ¦‚å¿µ)
  - [9. å‚è€ƒæ–‡çŒ®](#9-å‚è€ƒæ–‡çŒ®)
  - [10. Wikidataå¯¹é½](#10-wikidataå¯¹é½)

---

## 1. å®šä¹‰ä¸å½¢å¼åŒ–

### 1.1 æ¦‚å¿µå®šä¹‰

**ä¸­æ–‡å®šä¹‰**: å®‰å…¨æœºåˆ¶ä¸è®¿é—®æ§åˆ¶æ˜¯PostgreSQLæ•°æ®åº“ç³»ç»Ÿä¸­ä¿æŠ¤æ•°æ®å®‰å…¨çš„æ ¸å¿ƒç»„ä»¶ï¼ŒåŒ…æ‹¬ç”¨æˆ·è®¤è¯ã€æƒé™ç®¡ç†ã€æ•°æ®åŠ å¯†ã€å®¡è®¡æ—¥å¿—ç­‰å®‰å…¨åŠŸèƒ½ï¼Œç¡®ä¿æ•°æ®çš„æœºå¯†æ€§ã€å®Œæ•´æ€§å’Œå¯ç”¨æ€§ã€‚

**English Definition**: Security mechanisms and access control are core components in PostgreSQL database systems that protect data security, including user authentication, permission management, data encryption, audit logging, and other security features, ensuring data confidentiality, integrity, and availability.

### 1.2 å½¢å¼åŒ–å®šä¹‰

```latex
% æ•°å­¦ç¬¦å·å®šä¹‰
\newcommand{\security}{\mathcal{S}}
\newcommand{\user}{\mathcal{U}}
\newcommand{\role}{\mathcal{R}}
\newcommand{\permission}{\mathcal{P}}
\newcommand{\resource}{\mathcal{Res}}

% å®‰å…¨ç³»ç»Ÿçš„å½¢å¼åŒ–å®šä¹‰
\security = (\user, \role, \permission, \resource, \text{auth}, \text{authorize})

å…¶ä¸­ï¼š
\user = \{u_1, u_2, \ldots, u_n\}: ç”¨æˆ·é›†åˆ
\role = \{r_1, r_2, \ldots, r_m\}: è§’è‰²é›†åˆ
\permission = \{p_1, p_2, \ldots, p_k\}: æƒé™é›†åˆ
\resource = \{res_1, res_2, \ldots, res_l\}: èµ„æºé›†åˆ

% è®¿é—®æ§åˆ¶çš„å½¢å¼åŒ–å®šä¹‰
\text{authorize}(u, res, op) = \exists r \in \role: (u \in r) \land (r \rightarrow p) \land (p \rightarrow op)
```

### 1.3 æ ¸å¿ƒç‰¹æ€§

- **ç”¨æˆ·è®¤è¯**: éªŒè¯ç”¨æˆ·èº«ä»½
- **æƒé™ç®¡ç†**: ç»†ç²’åº¦æƒé™æ§åˆ¶
- **è§’è‰²ç®¡ç†**: åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶
- **æ•°æ®åŠ å¯†**: ä¼ è¾“å’Œå­˜å‚¨åŠ å¯†
- **å®¡è®¡æ—¥å¿—**: å®‰å…¨äº‹ä»¶è®°å½•

## 2. ç”¨æˆ·è®¤è¯ç³»ç»Ÿ

### 2.1 è®¤è¯æ–¹æ³•

```sql
-- æŸ¥çœ‹è®¤è¯é…ç½®
SELECT
    datname,
    usename,
    client_addr,
    application_name,
    state,
    query_start
FROM pg_stat_activity
WHERE state = 'active';

-- é…ç½®è®¤è¯æ–¹æ³•
-- pg_hba.conf é…ç½®ç¤ºä¾‹
-- TYPE  DATABASE        USER            ADDRESS                 METHOD
local   all             all                                     trust
host    all             all             127.0.0.1/32            md5
host    all             all             ::1/128                 md5
host    all             all             0.0.0.0/0               md5
hostssl all             all             0.0.0.0/0               md5

-- åˆ›å»ºç”¨æˆ·
CREATE USER app_user WITH PASSWORD 'secure_password';
CREATE USER readonly_user WITH PASSWORD 'readonly_password';
CREATE USER admin_user WITH PASSWORD 'admin_password' CREATEDB CREATEROLE;
```

### 2.2 å¯†ç ç­–ç•¥

```sql
-- é…ç½®å¯†ç ç­–ç•¥
ALTER SYSTEM SET password_encryption = 'scram-sha-256';
ALTER SYSTEM SET log_statement = 'all';
ALTER SYSTEM SET log_connections = on;
ALTER SYSTEM SET log_disconnections = on;

-- å¯†ç å¤æ‚åº¦æ£€æŸ¥
CREATE OR REPLACE FUNCTION check_password_strength(password TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    -- æ£€æŸ¥å¯†ç é•¿åº¦
    IF length(password) < 8 THEN
        RETURN FALSE;
    END IF;

    -- æ£€æŸ¥æ˜¯å¦åŒ…å«æ•°å­—
    IF password !~ '[0-9]' THEN
        RETURN FALSE;
    END IF;

    -- æ£€æŸ¥æ˜¯å¦åŒ…å«å¤§å†™å­—æ¯
    IF password !~ '[A-Z]' THEN
        RETURN FALSE;
    END IF;

    -- æ£€æŸ¥æ˜¯å¦åŒ…å«å°å†™å­—æ¯
    IF password !~ '[a-z]' THEN
        RETURN FALSE;
    END IF;

    -- æ£€æŸ¥æ˜¯å¦åŒ…å«ç‰¹æ®Šå­—ç¬¦
    IF password !~ '[^a-zA-Z0-9]' THEN
        RETURN FALSE;
    END IF;

    RETURN TRUE;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨å¯†ç ç­–ç•¥
CREATE USER test_user WITH PASSWORD 'Test123!@#';
```

### 2.3 å¤šå› ç´ è®¤è¯

```sql
-- é…ç½®TOTPè®¤è¯
CREATE EXTENSION IF NOT EXISTS pg_totp;

-- ä¸ºç”¨æˆ·å¯ç”¨TOTP
SELECT pg_totp_enable('app_user', 'JBSWY3DPEHPK3PXP');

-- éªŒè¯TOTP
SELECT pg_totp_verify('app_user', '123456');

-- åˆ›å»ºè®¤è¯è¡¨
CREATE TABLE user_authentication (
    user_id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    totp_secret VARCHAR(255),
    totp_enabled BOOLEAN DEFAULT FALSE,
    last_login TIMESTAMPTZ,
    failed_attempts INTEGER DEFAULT 0,
    locked_until TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);
```

### 2.4 OAuth 2.0èº«ä»½éªŒè¯ï¼ˆPostgreSQL 18 æ–°ç‰¹æ€§ï¼‰

**PostgreSQL 18æ–°ç‰¹æ€§**: OAuth 2.0èº«ä»½éªŒè¯æ”¯æŒ

**OAuth 2.0æ¦‚è¿°**ï¼š

OAuth 2.0æ˜¯ä¸€ä¸ªå¼€æ”¾æ ‡å‡†ï¼Œå…è®¸ç”¨æˆ·æˆæƒç¬¬ä¸‰æ–¹åº”ç”¨è®¿é—®å…¶èµ„æºï¼Œè€Œæ— éœ€å…±äº«å¯†ç ã€‚PostgreSQL 18å¼•å…¥äº†OAuth 2.0èº«ä»½éªŒè¯æ”¯æŒï¼Œä½¿ä¼ä¸šçº§åº”ç”¨èƒ½å¤Ÿé›†æˆç°ä»£èº«ä»½éªŒè¯ç³»ç»Ÿã€‚

**OAuth 2.0é…ç½®**ï¼š

```sql
-- PostgreSQL 18: OAuth 2.0é…ç½®
-- åœ¨postgresql.confä¸­é…ç½®
oauth2_provider = 'google'  -- æˆ– 'azure', 'github', 'okta'ç­‰
oauth2_client_id = 'your-client-id'
oauth2_client_secret = 'your-client-secret'
oauth2_redirect_uri = 'https://your-app.com/oauth/callback'
oauth2_scope = 'openid email profile'
oauth2_authorization_endpoint = 'https://accounts.google.com/o/oauth2/auth'
oauth2_token_endpoint = 'https://oauth2.googleapis.com/token'
oauth2_userinfo_endpoint = 'https://www.googleapis.com/oauth2/v2/userinfo'
```

**pg_hba.confé…ç½®**ï¼š

```text
# PostgreSQL 18: OAuth 2.0è®¤è¯
host    all    all    0.0.0.0/0    oauth2
```

**OAuth 2.0æµç¨‹**ï¼š

1. ç”¨æˆ·è®¿é—®åº”ç”¨
2. åº”ç”¨é‡å®šå‘åˆ°OAuthæä¾›è€…
3. ç”¨æˆ·æˆæƒ
4. å›è°ƒè·å–token
5. ä½¿ç”¨tokenè¿æ¥PostgreSQL

**ä¼ä¸šçº§OAuth 2.0æ–¹æ¡ˆ**ï¼š

```sql
-- åˆ›å»ºOAuthç”¨æˆ·æ˜ å°„
CREATE USER MAPPING FOR oauth_user
SERVER oauth_server
OPTIONS (
    oauth_provider = 'azure',
    tenant_id = 'your-tenant-id',
    client_id = 'your-client-id',
    client_secret = 'your-client-secret'
);

-- OAuthè§’è‰²æ˜ å°„
CREATE ROLE oauth_authenticated;
GRANT CONNECT ON DATABASE mydb TO oauth_authenticated;
GRANT USAGE ON SCHEMA public TO oauth_authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO oauth_authenticated;

-- å°†OAuthç”¨æˆ·æ˜ å°„åˆ°è§’è‰²
ALTER ROLE oauth_authenticated SET oauth_mapping = 'email:user_email';
```

**å•ç‚¹ç™»å½•ï¼ˆSSOï¼‰é›†æˆ**ï¼š

```sql
-- PostgreSQL 18: SSOé›†æˆç¤ºä¾‹
-- ä½¿ç”¨OAuth 2.0å®ç°SSO

-- é…ç½®OAuthæä¾›è€…ï¼ˆAzure ADç¤ºä¾‹ï¼‰
ALTER SYSTEM SET oauth2_provider = 'azure';
ALTER SYSTEM SET oauth2_tenant_id = 'your-tenant-id';
ALTER SYSTEM SET oauth2_client_id = 'your-client-id';
ALTER SYSTEM SET oauth2_client_secret = 'your-client-secret';
ALTER SYSTEM SET oauth2_redirect_uri = 'https://your-app.com/oauth/callback';

-- é‡å¯PostgreSQLä½¿é…ç½®ç”Ÿæ•ˆ
SELECT pg_reload_conf();
```

**OAuth 2.0å®‰å…¨æœ€ä½³å®è·µ**ï¼š

1. **ä½¿ç”¨HTTPS**: æ‰€æœ‰OAuthé€šä¿¡å¿…é¡»ä½¿ç”¨HTTPS
2. **å®šæœŸè½®æ¢å¯†é’¥**: å®šæœŸæ›´æ–°client_secret
3. **é™åˆ¶Scope**: åªè¯·æ±‚å¿…è¦çš„æƒé™
4. **ç›‘æ§æ—¥å¿—**: ç›‘æ§OAuthè®¤è¯æ—¥å¿—
5. **ä»¤ç‰ŒéªŒè¯**: éªŒè¯tokençš„æœ‰æ•ˆæ€§å’Œç­¾å

**ç›‘æ§OAuthè®¤è¯**ï¼š

```sql
-- æŸ¥çœ‹OAuthè®¤è¯æ—¥å¿—
SELECT
    log_time,
    user_name,
    client_addr,
    application_name,
    state
FROM pg_stat_activity
WHERE auth_method = 'oauth2';

-- æŸ¥çœ‹OAuthè®¤è¯ç»Ÿè®¡
SELECT
    COUNT(*) as total_oauth_connections,
    COUNT(DISTINCT user_name) as unique_oauth_users
FROM pg_stat_activity
WHERE auth_method = 'oauth2';
```

**æ•…éšœæ’æŸ¥**ï¼š

```sql
-- æ£€æŸ¥OAuthé…ç½®
SHOW oauth2_provider;
SHOW oauth2_client_id;

-- æŸ¥çœ‹OAuthé”™è¯¯æ—¥å¿—
SELECT * FROM pg_stat_statements
WHERE query LIKE '%oauth%'
ORDER BY total_exec_time DESC;
```

## 3. æƒé™ç®¡ç†ç³»ç»Ÿ

### 3.1 è§’è‰²ç®¡ç†

```sql
-- åˆ›å»ºè§’è‰²
CREATE ROLE app_role;
CREATE ROLE readonly_role;
CREATE ROLE admin_role;

-- è§’è‰²æƒé™é…ç½®
GRANT CONNECT ON DATABASE mydb TO app_role;
GRANT USAGE ON SCHEMA public TO app_role;
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO app_role;
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO app_role;

-- åªè¯»è§’è‰²
GRANT CONNECT ON DATABASE mydb TO readonly_role;
GRANT USAGE ON SCHEMA public TO readonly_role;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO readonly_role;

-- ç®¡ç†å‘˜è§’è‰²
GRANT ALL PRIVILEGES ON DATABASE mydb TO admin_role;
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO admin_role;
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO admin_role;

-- å°†ç”¨æˆ·åˆ†é…ç»™è§’è‰²
GRANT app_role TO app_user;
GRANT readonly_role TO readonly_user;
GRANT admin_role TO admin_user;
```

### 3.2 ç»†ç²’åº¦æƒé™æ§åˆ¶

```sql
-- è¡Œçº§å®‰å…¨ç­–ç•¥
CREATE TABLE sensitive_data (
    id SERIAL PRIMARY KEY,
    user_id INTEGER,
    data TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- å¯ç”¨è¡Œçº§å®‰å…¨
ALTER TABLE sensitive_data ENABLE ROW LEVEL SECURITY;

-- åˆ›å»ºè¡Œçº§å®‰å…¨ç­–ç•¥
CREATE POLICY user_data_policy ON sensitive_data
    FOR ALL TO app_role
    USING (user_id = current_setting('app.current_user_id')::INTEGER);

-- åˆ—çº§æƒé™æ§åˆ¶
CREATE TABLE user_profiles (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50),
    email VARCHAR(100),
    phone VARCHAR(20),
    salary DECIMAL(10,2),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- æˆäºˆåˆ—çº§æƒé™
GRANT SELECT (id, username, email) ON user_profiles TO readonly_role;
GRANT SELECT, UPDATE (username, email, phone) ON user_profiles TO app_role;
GRANT ALL PRIVILEGES ON user_profiles TO admin_role;
```

### 3.3 åŠ¨æ€æƒé™ç®¡ç†

```sql
-- åˆ›å»ºæƒé™ç®¡ç†å‡½æ•°
CREATE OR REPLACE FUNCTION grant_table_permissions(
    target_role TEXT,
    table_name TEXT,
    permissions TEXT[]
) RETURNS VOID AS $$
DECLARE
    perm TEXT;
BEGIN
    FOREACH perm IN ARRAY permissions
    LOOP
        EXECUTE format('GRANT %s ON %I TO %I', perm, table_name, target_role);
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨åŠ¨æ€æƒé™ç®¡ç†
SELECT grant_table_permissions('app_role', 'user_profiles',
                              ARRAY['SELECT', 'INSERT', 'UPDATE']);

-- æƒé™å®¡è®¡
CREATE OR REPLACE FUNCTION audit_permissions()
RETURNS TABLE(
    role_name TEXT,
    table_name TEXT,
    privilege_type TEXT,
    is_grantable BOOLEAN
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        r.rolname::TEXT,
        t.tablename::TEXT,
        p.privilege_type::TEXT,
        p.is_grantable
    FROM information_schema.table_privileges p
    JOIN pg_roles r ON r.rolname = p.grantee
    JOIN information_schema.tables t ON t.table_name = p.table_name
    WHERE t.table_schema = 'public'
    ORDER BY r.rolname, t.tablename, p.privilege_type;
END;
$$ LANGUAGE plpgsql;

-- æŸ¥çœ‹æƒé™å®¡è®¡
SELECT * FROM audit_permissions();
```

## 4. æ•°æ®åŠ å¯†

### 4.1 ä¼ è¾“åŠ å¯†

```sql
-- é…ç½®SSL
-- postgresql.conf é…ç½®
ssl = on
ssl_cert_file = 'server.crt'
ssl_key_file = 'server.key'
ssl_ca_file = 'ca.crt'
ssl_ciphers = 'HIGH:MEDIUM:+3DES:!aNULL'
ssl_prefer_server_ciphers = on

-- å¼ºåˆ¶SSLè¿æ¥
-- pg_hba.conf é…ç½®
hostssl all all 0.0.0.0/0 md5

-- æŸ¥çœ‹SSLçŠ¶æ€
SELECT
    datname,
    usename,
    client_addr,
    ssl,
    cipher,
    bits,
    compression
FROM pg_stat_ssl
JOIN pg_stat_activity ON pg_stat_ssl.pid = pg_stat_activity.pid;
```

### 4.2 å­˜å‚¨åŠ å¯†

```sql
-- åˆ›å»ºåŠ å¯†æ‰©å±•
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- åŠ å¯†å‡½æ•°
CREATE OR REPLACE FUNCTION encrypt_data(
    data TEXT,
    key TEXT
) RETURNS BYTEA AS $$
BEGIN
    RETURN pgp_sym_encrypt(data, key);
END;
$$ LANGUAGE plpgsql;

-- è§£å¯†å‡½æ•°
CREATE OR REPLACE FUNCTION decrypt_data(
    encrypted_data BYTEA,
    key TEXT
) RETURNS TEXT AS $$
BEGIN
    RETURN pgp_sym_decrypt(encrypted_data, key);
END;
$$ LANGUAGE plpgsql;

-- åŠ å¯†è¡¨
CREATE TABLE encrypted_data (
    id SERIAL PRIMARY KEY,
    sensitive_info BYTEA,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- æ’å…¥åŠ å¯†æ•°æ®
INSERT INTO encrypted_data (sensitive_info)
VALUES (encrypt_data('sensitive information', 'encryption_key'));

-- æŸ¥è¯¢è§£å¯†æ•°æ®
SELECT
    id,
    decrypt_data(sensitive_info, 'encryption_key') as decrypted_info,
    created_at
FROM encrypted_data;
```

### 4.3 å­—æ®µçº§åŠ å¯†

```sql
-- åˆ›å»ºåŠ å¯†å­—æ®µç±»å‹
CREATE DOMAIN encrypted_text AS BYTEA;

-- åŠ å¯†å­—æ®µè¡¨
CREATE TABLE user_credentials (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50),
    encrypted_password encrypted_text,
    encrypted_email encrypted_text,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- åŠ å¯†å­—æ®µå‡½æ•°
CREATE OR REPLACE FUNCTION encrypt_field(
    field_value TEXT,
    field_key TEXT
) RETURNS encrypted_text AS $$
BEGIN
    RETURN pgp_sym_encrypt(field_value, field_key);
END;
$$ LANGUAGE plpgsql;

-- è§£å¯†å­—æ®µå‡½æ•°
CREATE OR REPLACE FUNCTION decrypt_field(
    encrypted_field encrypted_text,
    field_key TEXT
) RETURNS TEXT AS $$
BEGIN
    RETURN pgp_sym_decrypt(encrypted_field, field_key);
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨åŠ å¯†å­—æ®µ
INSERT INTO user_credentials (username, encrypted_password, encrypted_email)
VALUES (
    'test_user',
    encrypt_field('password123', 'password_key'),
    encrypt_field('user@example.com', 'email_key')
);

-- æŸ¥è¯¢è§£å¯†å­—æ®µ
SELECT
    username,
    decrypt_field(encrypted_password, 'password_key') as password,
    decrypt_field(encrypted_email, 'email_key') as email
FROM user_credentials;
```

## 5. å®¡è®¡æ—¥å¿—

### 5.1 å®¡è®¡é…ç½®

```sql
-- é…ç½®å®¡è®¡æ—¥å¿—
ALTER SYSTEM SET log_statement = 'all';
ALTER SYSTEM SET log_connections = on;
ALTER SYSTEM SET log_disconnections = on;
ALTER SYSTEM SET log_hostname = on;
ALTER SYSTEM SET log_line_prefix = '%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h ';

-- é‡æ–°åŠ è½½é…ç½®
SELECT pg_reload_conf();

-- åˆ›å»ºå®¡è®¡è¡¨
CREATE TABLE audit_log (
    id BIGSERIAL PRIMARY KEY,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    username TEXT,
    database_name TEXT,
    application_name TEXT,
    client_addr INET,
    operation_type TEXT,
    table_name TEXT,
    old_values JSONB,
    new_values JSONB,
    query_text TEXT
);
```

### 5.2 å®¡è®¡è§¦å‘å™¨

```sql
-- åˆ›å»ºå®¡è®¡è§¦å‘å™¨å‡½æ•°
CREATE OR REPLACE FUNCTION audit_trigger_function()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO audit_log (
        username,
        database_name,
        application_name,
        client_addr,
        operation_type,
        table_name,
        old_values,
        new_values,
        query_text
    ) VALUES (
        current_user,
        current_database(),
        current_setting('application_name'),
        inet_client_addr(),
        TG_OP,
        TG_TABLE_NAME,
        CASE WHEN TG_OP = 'DELETE' THEN row_to_json(OLD) ELSE NULL END,
        CASE WHEN TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN row_to_json(NEW) ELSE NULL END,
        current_query()
    );

    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

-- åˆ›å»ºå®¡è®¡è§¦å‘å™¨
CREATE TRIGGER audit_trigger
    AFTER INSERT OR UPDATE OR DELETE
    ON user_profiles
    FOR EACH ROW
    EXECUTE FUNCTION audit_trigger_function();

-- æŸ¥çœ‹å®¡è®¡æ—¥å¿—
SELECT
    timestamp,
    username,
    operation_type,
    table_name,
    old_values,
    new_values
FROM audit_log
WHERE table_name = 'user_profiles'
ORDER BY timestamp DESC
LIMIT 10;
```

### 5.3 å®‰å…¨äº‹ä»¶ç›‘æ§

```sql
-- åˆ›å»ºå®‰å…¨äº‹ä»¶è¡¨
CREATE TABLE security_events (
    id BIGSERIAL PRIMARY KEY,
    event_type TEXT NOT NULL,
    severity TEXT NOT NULL,
    username TEXT,
    client_addr INET,
    event_description TEXT,
    event_data JSONB,
    timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- å®‰å…¨äº‹ä»¶ç›‘æ§å‡½æ•°
CREATE OR REPLACE FUNCTION log_security_event(
    event_type TEXT,
    severity TEXT,
    description TEXT,
    event_data JSONB DEFAULT NULL
) RETURNS VOID AS $$
BEGIN
    INSERT INTO security_events (
        event_type,
        severity,
        username,
        client_addr,
        event_description,
        event_data
    ) VALUES (
        event_type,
        severity,
        current_user,
        inet_client_addr(),
        description,
        event_data
    );
END;
$$ LANGUAGE plpgsql;

-- ç™»å½•å¤±è´¥ç›‘æ§
CREATE OR REPLACE FUNCTION check_failed_logins()
RETURNS VOID AS $$
DECLARE
    failed_count INTEGER;
BEGIN
    SELECT COUNT(*) INTO failed_count
    FROM security_events
    WHERE event_type = 'login_failed'
    AND timestamp > NOW() - INTERVAL '1 hour';

    IF failed_count > 5 THEN
        PERFORM log_security_event(
            'multiple_failed_logins',
            'high',
            'Multiple failed login attempts detected',
            json_build_object('failed_count', failed_count)
        );
    END IF;
END;
$$ LANGUAGE plpgsql;
```

## 6. ç½‘ç»œå®‰å…¨

### 6.1 è¿æ¥é™åˆ¶

```sql
-- é…ç½®è¿æ¥é™åˆ¶
ALTER SYSTEM SET max_connections = 100;
ALTER SYSTEM SET superuser_reserved_connections = 3;

-- ç”¨æˆ·è¿æ¥é™åˆ¶
ALTER USER app_user CONNECTION LIMIT 10;
ALTER USER readonly_user CONNECTION LIMIT 5;

-- æŸ¥çœ‹è¿æ¥çŠ¶æ€
SELECT
    datname,
    usename,
    application_name,
    client_addr,
    state,
    query_start,
    state_change
FROM pg_stat_activity
WHERE state = 'active'
ORDER BY query_start;
```

### 6.2 IPç™½åå•

```sql
-- åˆ›å»ºIPç™½åå•è¡¨
CREATE TABLE ip_whitelist (
    id SERIAL PRIMARY KEY,
    ip_address INET,
    description TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ
);

-- æ·»åŠ IPç™½åå•
INSERT INTO ip_whitelist (ip_address, description, expires_at)
VALUES
    ('192.168.1.0/24', 'Internal network', NULL),
    ('10.0.0.0/8', 'VPN network', NULL),
    ('203.0.113.1', 'Admin workstation', NOW() + INTERVAL '30 days');

-- IPç™½åå•æ£€æŸ¥å‡½æ•°
CREATE OR REPLACE FUNCTION check_ip_whitelist(client_ip INET)
RETURNS BOOLEAN AS $$
DECLARE
    is_allowed BOOLEAN := FALSE;
BEGIN
    SELECT EXISTS(
        SELECT 1 FROM ip_whitelist
        WHERE client_ip <<= ip_address
        AND (expires_at IS NULL OR expires_at > NOW())
    ) INTO is_allowed;

    IF NOT is_allowed THEN
        PERFORM log_security_event(
            'ip_not_whitelisted',
            'medium',
            'Connection attempt from non-whitelisted IP',
            json_build_object('client_ip', client_ip)
        );
    END IF;

    RETURN is_allowed;
END;
$$ LANGUAGE plpgsql;
```

## 7. å®é™…åº”ç”¨æ¡ˆä¾‹

### 7.1 å¤šç§Ÿæˆ·å®‰å…¨æ¶æ„

```sql
-- å¤šç§Ÿæˆ·ç”¨æˆ·è¡¨
CREATE TABLE tenants (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    domain VARCHAR(100) UNIQUE NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE tenant_users (
    id SERIAL PRIMARY KEY,
    tenant_id INTEGER REFERENCES tenants(id),
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,
    role VARCHAR(20) DEFAULT 'user',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(tenant_id, username)
);

-- ç§Ÿæˆ·éš”ç¦»ç­–ç•¥
CREATE POLICY tenant_isolation_policy ON tenant_users
    FOR ALL TO app_role
    USING (tenant_id = current_setting('app.current_tenant_id')::INTEGER);

-- ç§Ÿæˆ·æ•°æ®è¡¨
CREATE TABLE tenant_data (
    id SERIAL PRIMARY KEY,
    tenant_id INTEGER REFERENCES tenants(id),
    data TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ç§Ÿæˆ·æ•°æ®éš”ç¦»
CREATE POLICY tenant_data_isolation_policy ON tenant_data
    FOR ALL TO app_role
    USING (tenant_id = current_setting('app.current_tenant_id')::INTEGER);
```

### 7.2 é‡‘èçº§å®‰å…¨

```sql
-- é‡‘èäº¤æ˜“è¡¨
CREATE TABLE financial_transactions (
    id BIGSERIAL PRIMARY KEY,
    transaction_id UUID DEFAULT gen_random_uuid(),
    from_account VARCHAR(50),
    to_account VARCHAR(50),
    amount DECIMAL(15,2),
    currency VARCHAR(3),
    transaction_type VARCHAR(20),
    status VARCHAR(20) DEFAULT 'pending',
    encrypted_details BYTEA,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- é‡‘èå®¡è®¡è§¦å‘å™¨
CREATE OR REPLACE FUNCTION financial_audit_trigger()
RETURNS TRIGGER AS $$
BEGIN
    -- è®°å½•æ‰€æœ‰é‡‘èäº¤æ˜“å˜æ›´
    INSERT INTO audit_log (
        username,
        operation_type,
        table_name,
        old_values,
        new_values,
        query_text
    ) VALUES (
        current_user,
        TG_OP,
        TG_TABLE_NAME,
        CASE WHEN TG_OP = 'DELETE' THEN row_to_json(OLD) ELSE NULL END,
        CASE WHEN TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN row_to_json(NEW) ELSE NULL END,
        current_query()
    );

    -- æ£€æŸ¥å¤§é¢äº¤æ˜“
    IF NEW.amount > 10000 THEN
        PERFORM log_security_event(
            'large_transaction',
            'high',
            'Large transaction detected',
            json_build_object(
                'transaction_id', NEW.transaction_id,
                'amount', NEW.amount,
                'from_account', NEW.from_account,
                'to_account', NEW.to_account
            )
        );
    END IF;

    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

-- åˆ›å»ºé‡‘èå®¡è®¡è§¦å‘å™¨
CREATE TRIGGER financial_audit_trigger
    AFTER INSERT OR UPDATE OR DELETE
    ON financial_transactions
    FOR EACH ROW
    EXECUTE FUNCTION financial_audit_trigger();
```

## 8. ç›¸å…³æ¦‚å¿µ

### 8.1 ä¸Šä½æ¦‚å¿µ

- **æ•°æ®åº“å®‰å…¨**: æ›´å¹¿æ³›çš„æ•°æ®åº“å®‰å…¨æŠ€æœ¯
- **ä¿¡æ¯å®‰å…¨**: ä¿¡æ¯å®‰å…¨æŠ€æœ¯
- **è®¿é—®æ§åˆ¶**: è®¿é—®æ§åˆ¶æŠ€æœ¯

### 8.2 ä¸‹ä½æ¦‚å¿µ

- **ç”¨æˆ·è®¤è¯**: èº«ä»½éªŒè¯æŠ€æœ¯
- **æƒé™ç®¡ç†**: æƒé™æ§åˆ¶æŠ€æœ¯
- **æ•°æ®åŠ å¯†**: æ•°æ®åŠ å¯†æŠ€æœ¯
- **å®¡è®¡æ—¥å¿—**: å®¡è®¡è®°å½•æŠ€æœ¯

### 8.3 å¹³è¡Œæ¦‚å¿µ

- **ç½‘ç»œå®‰å…¨**: ç½‘ç»œå®‰å…¨æŠ€æœ¯
- **åº”ç”¨å®‰å…¨**: åº”ç”¨å®‰å…¨æŠ€æœ¯
- **æ•°æ®ä¿æŠ¤**: æ•°æ®ä¿æŠ¤æŠ€æœ¯

## 9. å‚è€ƒæ–‡çŒ®

1. PostgreSQL Global Development Group. (2025). PostgreSQL 18 Documentation. <https://www.postgresql.org/docs/18/>
2. Obe, R., & Hsu, L. (2015). PostgreSQL: Up and Running (2nd ed.). O'Reilly Media.
3. Krosing, H., & Roybal, K. (2019). PostgreSQL 11 Server Side Programming Quick Start Guide. Packt Publishing.
4. Riggs, S., et al. (2017). PostgreSQL 9.6 High Performance. Packt Publishing.
5. PostgreSQL Global Development Group. (2024). PostgreSQL 17 Documentation. <https://www.postgresql.org/docs/17/>

## 10. Wikidataå¯¹é½

- **Wikidata ID**: Q192490
- **ç›¸å…³å±æ€§**:
  - P31: Q176165 (instance of: database management system)
  - P178: Q9366 (developer: PostgreSQL Global Development Group)
  - P277: Q193321 (programmed in: C)
  - P348: 18.0 (software version)
- **å¤–éƒ¨é“¾æ¥**:
  - <https://www.postgresql.org/docs/current/auth.html>
  - <https://www.postgresql.org/docs/current/row-level-security.html>
