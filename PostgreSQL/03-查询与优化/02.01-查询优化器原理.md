# 查询优化器原理

> **版本**: v3.1
> **最后更新**: 2025-11-22
> **版本覆盖**: PostgreSQL 18.x (推荐) ⭐ | 17.x (推荐) | 16.x (兼容)
> **难度**: ⭐⭐⭐⭐
> **应用场景**: 查询优化、性能调优、系统设计
> 🆕 **PostgreSQL 18查询优化**: 改进的查询计划器、基数估计准确性提升（误差从25%→15%）、更智能的JOIN方法选择、虚拟生成列优化

---

## 📋 目录

- [查询优化器原理](#查询优化器原理)
  - [📋 目录](#-目录)
  - [1. 定义与形式化](#1-定义与形式化)
    - [1.1 概念定义](#11-概念定义)
    - [1.2 形式化定义](#12-形式化定义)
    - [1.3 核心属性](#13-核心属性)
  - [2. 理论基础](#2-理论基础)
    - [2.1 查询代价模型](#21-查询代价模型)
    - [2.2 查询重写理论](#22-查询重写理论)
    - [2.3 连接顺序优化](#23-连接顺序优化)
  - [3. PostgreSQL优化器架构](#3-postgresql优化器架构)
    - [3.1 优化器组件](#31-优化器组件)
    - [3.2 查询解析](#32-查询解析)
    - [3.3 统计信息](#33-统计信息)
  - [4. 查询重写优化](#4-查询重写优化)
    - [4.1 谓词下推](#41-谓词下推)
    - [4.2 常量折叠](#42-常量折叠)
    - [4.3 视图展开](#43-视图展开)
  - [5. 连接优化](#5-连接优化)
    - [5.1 连接算法选择](#51-连接算法选择)
      - [1. 嵌套循环连接（Nested Loop Join）](#1-嵌套循环连接nested-loop-join)
      - [哈希连接（Hash Join）](#哈希连接hash-join)
      - [合并连接（Merge Join）](#合并连接merge-join)
    - [5.2 连接顺序优化](#52-连接顺序优化)
    - [5.3 连接优化配置](#53-连接优化配置)
  - [6. 索引优化](#6-索引优化)
    - [6.1 索引选择](#61-索引选择)
    - [6.2 索引扫描优化](#62-索引扫描优化)
      - [Index Scan（索引扫描）](#index-scan索引扫描)
      - [Index Only Scan（仅索引扫描）](#index-only-scan仅索引扫描)
      - [Bitmap Index Scan（位图索引扫描）](#bitmap-index-scan位图索引扫描)
  - [7. 聚合优化](#7-聚合优化)
    - [7.1 聚合算法](#71-聚合算法)
    - [7.2 窗口函数优化](#72-窗口函数优化)
  - [8. 性能调优](#8-性能调优)
    - [8.1 优化器配置调优](#81-优化器配置调优)
    - [8.2 查询提示](#82-查询提示)
  - [9. 实际应用案例](#9-实际应用案例)
    - [9.1 复杂查询优化](#91-复杂查询优化)
    - [9.2 大数据量查询优化](#92-大数据量查询优化)
  - [10. 相关概念](#10-相关概念)
    - [10.1 上位概念](#101-上位概念)
    - [10.2 下位概念](#102-下位概念)
    - [10.3 平行概念](#103-平行概念)
  - [11. 相关文档](#11-相关文档)
    - [11.1 实战案例与示例](#111-实战案例与示例)
  - [12. 参考文献](#12-参考文献)
  - [13. 交叉引用](#13-交叉引用)
    - [相关文档](#相关文档)
      - [查询与优化](#查询与优化)
      - [核心课程](#核心课程)
      - [数据模型设计](#数据模型设计)
      - [理论基础](#理论基础)
      - [部署架构](#部署架构)
      - [运维实践](#运维实践)
    - [外部资源](#外部资源)
  - [14. Wikidata对齐](#14-wikidata对齐)
  - [合并来源与映射（整合中）](#合并来源与映射整合中)
    - [待办事项](#待办事项)
      - [1. 接口描述统一](#1-接口描述统一)
      - [2. 内容去重](#2-内容去重)
      - [3. 形式化证明外链](#3-形式化证明外链)

---

## 1. 定义与形式化

### 1.1 概念定义

**中文定义**: 查询优化器是数据库系统中将用户查询转换为高效执行计划的核心组件，通过代价模型选择最优执行策略，确保查询性能的最优化。

**English Definition**: A query optimizer is a core component in database systems that transforms user queries into efficient execution plans by selecting optimal strategies through cost models, ensuring optimal query performance.

### 1.2 形式化定义

```latex
% 数学符号定义
\newcommand{\query}{\mathcal{Q}}
\newcommand{\plan}{\mathcal{P}}
\newcommand{\cost}{\mathcal{C}}
\newcommand{\optimizer}{\mathcal{O}}

% 查询优化的形式化定义
\optimizer: \query \rightarrow \plan

优化目标：\min_{\plan \in \mathcal{P}(\query)} \cost(\plan)

其中：
\mathcal{P}(\query) = \{\plan_1, \plan_2, \ldots, \plan_n\} \text{ 为查询的所有可能执行计划}
\cost(\plan) = \cost_{IO}(\plan) + \cost_{CPU}(\plan) + \cost_{Memory}(\plan)
```

### 1.3 核心属性

- **正确性**: 保证查询结果正确
- **最优性**: 选择最低代价的执行计划
- **适应性**: 根据数据分布动态调整
- **可扩展性**: 支持复杂查询优化

## 2. 理论基础

### 2.1 查询代价模型

查询代价模型是PostgreSQL优化器的核心，用于估算不同执行计划的成本并选择最优计划。

**代价模型定义**:

```latex
\begin{theorem}[查询代价模型]
查询代价由以下因素决定：
1. I/O代价：\cost_{IO} = \sum_{i} \text{page\_reads}_i \times \text{page\_cost}
2. CPU代价：\cost_{CPU} = \sum_{i} \text{tuples\_processed}_i \times \text{cpu\_tuple\_cost}
3. 内存代价：\cost_{Memory} = \text{memory\_usage} \times \text{memory\_cost}

总代价：\cost_{total} = \cost_{IO} + \cost_{CPU} + \cost_{Memory}
\end{theorem}
```

**代价参数详解**:

```sql
-- 查看所有代价参数
SELECT name, setting, unit, short_desc
FROM pg_settings
WHERE name LIKE '%cost%' OR name LIKE '%page%'
ORDER BY name;

-- 主要代价参数
-- I/O代价参数
seq_page_cost = 1.0          -- 顺序页读取代价（基准）
random_page_cost = 4.0       -- 随机页读取代价（SSD建议1.0-1.1）
effective_cache_size = 4GB   -- 有效缓存大小（影响索引选择）

-- CPU代价参数
cpu_tuple_cost = 0.01        -- 处理一个元组的CPU代价
cpu_index_tuple_cost = 0.005 -- 处理一个索引元组的CPU代价
cpu_operator_cost = 0.0025   -- 执行一个操作符的CPU代价

-- 并行查询代价参数
parallel_tuple_cost = 0.1     -- 并行传输一个元组的代价
parallel_setup_cost = 1000.0 -- 并行查询启动代价
```

**代价计算示例**:

```sql
-- 顺序扫描代价计算
-- cost = (pages * seq_page_cost) + (tuples * cpu_tuple_cost)
-- 假设：1000页，100000行
-- cost = (1000 * 1.0) + (100000 * 0.01) = 1000 + 1000 = 2000

-- 索引扫描代价计算
-- cost = (index_pages * random_page_cost) +
--        (index_tuples * cpu_index_tuple_cost) +
--        (heap_pages * random_page_cost) +
--        (tuples * cpu_tuple_cost)
-- 假设：索引50页，10000行，堆100页
-- cost = (50 * 4.0) + (10000 * 0.005) + (100 * 4.0) + (10000 * 0.01)
--      = 200 + 50 + 400 + 100 = 750

-- 查看实际执行计划代价
EXPLAIN (ANALYZE, BUFFERS, COSTS)
SELECT * FROM large_table WHERE id = 12345;
```

**PostgreSQL 18改进**:

- 基数估计准确性提升：误差从25%降至15%
- 更智能的代价估算：考虑数据分布和相关性
- 改进的并行查询代价模型

**代价调优实践**:

```sql
-- 1. 根据存储类型调整random_page_cost
-- SSD/NVMe环境
SET random_page_cost = 1.1;

-- HDD环境
SET random_page_cost = 4.0;

-- 2. 调整effective_cache_size
-- 设置为系统内存的50-75%
SET effective_cache_size = '8GB';

-- 3. 查看代价估算准确性
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM table1 WHERE column1 = 'value';
-- 对比估算行数（rows）和实际行数（actual rows）
```

**代价模型验证**:

```sql
-- 对比不同执行计划的代价
EXPLAIN (COSTS, BUFFERS)
SELECT * FROM table1 WHERE id = 123;

-- 强制使用索引扫描
SET enable_seqscan = off;
EXPLAIN (COSTS, BUFFERS)
SELECT * FROM table1 WHERE id = 123;

-- 恢复默认
SET enable_seqscan = on;
```

### 2.2 查询重写理论

```latex
\begin{theorem}[查询重写等价性]
查询重写保持语义等价性：
\forall \query, \forall \plan_1, \plan_2 \in \mathcal{P}(\query):
\text{result}(\plan_1) = \text{result}(\plan_2) \Rightarrow \plan_1 \equiv \plan_2
\end{theorem}
```

### 2.3 连接顺序优化

```latex
\begin{theorem}[连接顺序最优性]
对于n个表的连接，最优连接顺序满足：
\min_{\sigma \in S_n} \cost(\text{join}_{\sigma(1)} \bowtie \text{join}_{\sigma(2)} \bowtie \ldots \bowtie \text{join}_{\sigma(n)})
\end{theorem}
```

## 3. PostgreSQL优化器架构

### 3.1 优化器组件

```sql
-- 查看优化器配置
SHOW enable_hashjoin;
SHOW enable_mergejoin;
SHOW enable_nestloop;
SHOW enable_seqscan;
SHOW enable_indexscan;
SHOW enable_bitmapscan;

-- 查看代价参数
SHOW seq_page_cost;
SHOW random_page_cost;
SHOW cpu_tuple_cost;
SHOW cpu_index_tuple_cost;
SHOW cpu_operator_cost;
```

### 3.2 查询解析

```sql
-- 查看查询解析树
EXPLAIN (VERBOSE, BUFFERS)
SELECT e.name, d.dept_name, e.salary
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id
WHERE e.salary > 50000
ORDER BY e.salary DESC;

-- 查看查询重写
EXPLAIN (VERBOSE)
SELECT * FROM employees WHERE emp_id IN (
    SELECT emp_id FROM employees WHERE salary > 50000
);
```

### 3.3 统计信息

统计信息是查询优化器选择最优执行计划的关键依据。PostgreSQL通过ANALYZE命令收集统计信息。

**表级统计信息**:

```sql
-- 查看表统计信息
SELECT
    schemaname,
    tablename,
    n_tup_ins,          -- 插入的元组数
    n_tup_upd,          -- 更新的元组数
    n_tup_del,          -- 删除的元组数
    n_live_tup,         -- 活跃元组数
    n_dead_tup,         -- 死元组数
    last_vacuum,         -- 最后VACUUM时间
    last_autovacuum,     -- 最后自动VACUUM时间
    last_analyze,        -- 最后ANALYZE时间
    last_autoanalyze,    -- 最后自动ANALYZE时间
    vacuum_count,        -- VACUUM次数
    autovacuum_count,    -- 自动VACUUM次数
    analyze_count,       -- ANALYZE次数
    autoanalyze_count    -- 自动ANALYZE次数
FROM pg_stat_user_tables
ORDER BY n_live_tup DESC;

-- 手动收集统计信息
ANALYZE table_name;

-- 收集所有表的统计信息
ANALYZE;
```

**列级统计信息**:

```sql
-- 查看列统计信息
SELECT
    schemaname,
    tablename,
    attname,
    n_distinct,
    correlation,
    most_common_vals,
    most_common_freqs,
    histogram_bounds
FROM pg_stats
WHERE schemaname = 'public' AND tablename = 'employees';
```

## 4. 查询重写优化

### 4.1 谓词下推

谓词下推是查询优化器的重要优化技术，将WHERE条件尽可能下推到数据源，减少需要处理的数据量。

**谓词下推原理**:

优化器会将WHERE条件从外层查询下推到子查询、视图或连接操作中，在数据读取阶段就过滤掉不符合条件的行。

**基本谓词下推**:

```sql
-- 示例1：简单谓词下推
EXPLAIN (ANALYZE, BUFFERS)
SELECT e.name, d.dept_name
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id
WHERE e.salary > 50000 AND d.budget > 1000000;

-- 优化器会将条件下推：
-- - e.salary > 50000 下推到 employees 表扫描
-- - d.budget > 1000000 下推到 departments 表扫描
-- 减少连接操作需要处理的行数
```

**子查询谓词下推**:

```sql
-- 示例2：子查询优化（IN子句）
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees
WHERE dept_id IN (
    SELECT dept_id FROM departments WHERE budget > 1000000
);

-- PostgreSQL优化器会将此查询重写为：
-- SELECT e.* FROM employees e
-- JOIN departments d ON e.dept_id = d.dept_id
-- WHERE d.budget > 1000000
-- 使用半连接（Semi-Join）优化

-- 示例3：EXISTS子查询优化
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees e
WHERE EXISTS (
    SELECT 1 FROM departments d
    WHERE d.dept_id = e.dept_id AND d.budget > 1000000
);
-- 优化器会使用半连接或反半连接优化
```

**视图谓词下推**:

```sql
-- 创建视图
CREATE VIEW high_salary_employees AS
SELECT e.*, d.dept_name
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id
WHERE e.salary > 50000;

-- 查询视图时，条件可以下推
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM high_salary_employees
WHERE dept_name = 'Engineering';
-- 优化器会将 dept_name = 'Engineering' 下推到视图定义中
```

**PostgreSQL 18改进**:

- 更智能的谓词下推：识别更多可以下推的条件
- 改进的子查询优化：更好的IN和EXISTS子查询处理
- 视图优化增强：更高效的视图展开和谓词下推

### 4.2 常量折叠

常量折叠是查询优化器在编译时计算常量表达式的优化技术，减少运行时计算开销。

**常量折叠原理**:

优化器会在查询计划生成阶段计算所有常量表达式，将结果直接替换到查询计划中。

**基本常量折叠**:

```sql
-- 示例1：算术表达式折叠
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees
WHERE salary > 50000 + 1000;

-- 优化器会将 50000 + 1000 折叠为 51000
-- 实际执行：WHERE salary > 51000

-- 示例2：函数调用折叠
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees
WHERE created_at > NOW() - INTERVAL '1 year';

-- 如果NOW()在查询编译时已知，会折叠为具体时间戳
```

**表达式简化**:

```sql
-- 示例3：表达式简化
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees
WHERE salary * 1.1 > 55000;

-- 优化器可能简化为：
-- WHERE salary > 55000 / 1.1
-- WHERE salary > 50000

-- 示例4：布尔表达式简化
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees
WHERE salary > 50000 AND TRUE;
-- 简化为：WHERE salary > 50000

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees
WHERE salary > 50000 AND FALSE;
-- 简化为：WHERE FALSE（可能直接返回空结果）
```

**常量折叠限制**:

```sql
-- 以下情况不会折叠：
-- 1. 涉及非确定性函数
SELECT * FROM employees
WHERE created_at > NOW();  -- NOW()每次调用结果不同

-- 2. 涉及用户定义函数（除非标记为IMMUTABLE）
CREATE FUNCTION get_threshold() RETURNS int AS $$
    SELECT 50000;
$$ LANGUAGE SQL STABLE;  -- STABLE函数不会折叠

-- 3. 涉及子查询
SELECT * FROM employees
WHERE salary > (SELECT AVG(salary) FROM employees);
```

**常量折叠优化技巧**:

```sql
-- 使用IMMUTABLE函数支持常量折叠
CREATE FUNCTION calculate_bonus(base_salary int)
RETURNS int AS $$
    SELECT base_salary * 1.1;
$$ LANGUAGE SQL IMMUTABLE;

-- 查询时可以折叠
SELECT * FROM employees
WHERE salary > calculate_bonus(50000);
-- 优化器会折叠为：WHERE salary > 55000
```

### 4.3 视图展开

```sql
-- 创建视图
CREATE VIEW emp_summary AS
SELECT dept_id, COUNT(*) as emp_count, AVG(salary) as avg_salary
FROM employees
GROUP BY dept_id;

-- 视图展开
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM emp_summary WHERE emp_count > 10;
```

## 5. 连接优化

### 5.1 连接算法选择

PostgreSQL支持三种主要的连接算法：嵌套循环连接、哈希连接和合并连接。优化器会根据数据量、索引和排序情况选择最优算法。

#### 1. 嵌套循环连接（Nested Loop Join）

适合小数据集或内表有索引的情况。

```sql
-- 嵌套循环连接示例
EXPLAIN (ANALYZE, BUFFERS)
SELECT e.name, d.dept_name
FROM employees e, departments d
WHERE e.dept_id = d.dept_id;

-- 算法原理：
-- FOR each row in employees:
--     FOR each row in departments WHERE dept_id = e.dept_id:
--         output row
--
-- 如果departments.dept_id有索引，性能很好
-- 时间复杂度：O(n * log(m))，n为外表行数，m为内表行数

-- 强制使用嵌套循环连接
SET enable_hashjoin = off;
SET enable_mergejoin = off;
EXPLAIN (ANALYZE, BUFFERS)
SELECT e.name, d.dept_name
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id;
RESET enable_hashjoin;
RESET enable_mergejoin;
```

#### 哈希连接（Hash Join）

适合中等大小的数据集，内表可以完全放入内存。

```sql
-- 哈希连接示例
EXPLAIN (ANALYZE, BUFFERS)
SELECT e.name, d.dept_name
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id;

-- 算法原理：
-- 1. 对内表（departments）建立哈希表
-- 2. 扫描外表（employees），在哈希表中查找匹配
--
-- 时间复杂度：O(n + m)，n和m分别为两个表的行数
-- 内存需求：需要能容纳内表的哈希表

-- 哈希连接配置
-- work_mem影响哈希表大小
SET work_mem = '256MB';
EXPLAIN (ANALYZE, BUFFERS)
SELECT e.name, d.dept_name
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id;
```

#### 合并连接（Merge Join）

适合两个表都已排序或可以高效排序的情况。

```sql
-- 合并连接示例
EXPLAIN (ANALYZE, BUFFERS)
SELECT e.name, d.dept_name
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id
ORDER BY e.dept_id;

-- 算法原理：
-- 1. 两个表都按连接键排序
-- 2. 同时扫描两个表，合并匹配的行
--
-- 时间复杂度：O(n + m + sort_cost)
-- 如果表已排序，性能最优

-- 合并连接需要排序
-- 如果连接键上有索引，可能使用索引扫描避免排序
CREATE INDEX idx_emp_dept ON employees(dept_id);
CREATE INDEX idx_dept_id ON departments(dept_id);

EXPLAIN (ANALYZE, BUFFERS)
SELECT e.name, d.dept_name
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id;
```

**连接算法选择策略**:

| 场景 | 推荐算法 | 原因 |
|------|---------|------|
| 小表连接 | 嵌套循环 | 开销小，内表有索引时性能好 |
| 中等表，内表可放入内存 | 哈希连接 | 性能稳定，O(n+m)复杂度 |
| 大表，已排序或可排序 | 合并连接 | 避免哈希表内存限制 |
| 内表有索引 | 嵌套循环 | 利用索引快速查找 |
| 需要排序结果 | 合并连接 | 连接和排序一次完成 |

**连接算法配置**:

```sql
-- 启用/禁用特定连接算法
SET enable_nestloop = on;    -- 嵌套循环（默认on）
SET enable_hashjoin = on;    -- 哈希连接（默认on）
SET enable_mergejoin = on;   -- 合并连接（默认on）

-- 查看连接算法使用情况
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT e.name, d.dept_name, p.project_name
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id
JOIN projects p ON e.emp_id = p.manager_id;
```

**PostgreSQL 18连接算法改进**:

- 更智能的算法选择：改进的代价估算
- 并行连接支持：支持并行哈希连接和并行合并连接
- 改进的哈希连接：更好的内存管理和溢出处理

### 5.2 连接顺序优化

连接顺序优化是查询优化器中最复杂的部分之一，对于多表连接查询的性能影响巨大。

**连接顺序问题**:

对于n个表的连接，可能的连接顺序有n!种。PostgreSQL使用动态规划算法和遗传算法来选择最优连接顺序。

**动态规划算法**:

```sql
-- 多表连接示例
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT
    e.name,
    d.dept_name,
    p.project_name,
    c.client_name
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id
JOIN projects p ON e.emp_id = p.manager_id
JOIN clients c ON p.client_id = c.client_id
WHERE e.salary > 50000
  AND d.budget > 1000000
  AND p.status = 'active';

-- 优化器会尝试所有可能的连接顺序：
-- 1. e -> d -> p -> c
-- 2. e -> p -> d -> c
-- 3. d -> e -> p -> c
-- ... (共24种可能)
-- 选择代价最低的顺序
```

**连接顺序优化策略**:

1. **小表优先**: 先连接较小的表，减少中间结果集大小
2. **选择性高的条件优先**: 先应用选择性高的WHERE条件
3. **索引利用**: 优先使用有索引的连接键

**连接顺序配置**:

```sql
-- join_collapse_limit: 控制连接顺序优化的表数量
-- 默认值：8（PostgreSQL 18）
-- 如果表数超过此值，优化器会使用遗传算法

SET join_collapse_limit = 8;  -- 默认值
SET join_collapse_limit = 1;   -- 强制使用查询中的连接顺序

-- from_collapse_limit: 控制FROM子句重写的表数量
SET from_collapse_limit = 8;   -- 默认值

-- 查看当前配置
SHOW join_collapse_limit;
SHOW from_collapse_limit;
```

**连接顺序优化示例**:

```sql
-- 示例1：优化器自动选择最优顺序
EXPLAIN (ANALYZE, BUFFERS)
SELECT e.name, d.dept_name, p.project_name
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id
JOIN projects p ON e.emp_id = p.manager_id
WHERE e.salary > 50000;

-- 示例2：强制连接顺序（调试用）
SET join_collapse_limit = 1;
EXPLAIN (ANALYZE, BUFFERS)
SELECT e.name, d.dept_name, p.project_name
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id
JOIN projects p ON e.emp_id = p.manager_id
WHERE e.salary > 50000;
RESET join_collapse_limit;
```

**连接顺序优化技巧**:

```sql
-- 1. 使用子查询控制连接顺序
SELECT e.name, d.dept_name
FROM (
    SELECT * FROM employees WHERE salary > 50000
) e
JOIN departments d ON e.dept_id = d.dept_id;

-- 2. 使用CTE优化连接顺序
WITH filtered_employees AS (
    SELECT * FROM employees WHERE salary > 50000
)
SELECT e.name, d.dept_name
FROM filtered_employees e
JOIN departments d ON e.dept_id = d.dept_id;

-- 3. 确保连接键上有索引
CREATE INDEX idx_emp_dept ON employees(dept_id);
CREATE INDEX idx_proj_manager ON projects(manager_id);
```

**PostgreSQL 18连接顺序改进**:

- 更智能的连接顺序选择
- 改进的代价估算准确性
- 更好的并行连接支持

**连接顺序问题诊断**:

```sql
-- 查看连接顺序选择
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT ... FROM table1 t1
JOIN table2 t2 ON ...
JOIN table3 t3 ON ...;

-- 如果性能不佳，检查：
-- 1. 连接键是否有索引
-- 2. 统计信息是否准确
-- 3. 连接顺序是否合理

-- 对比不同连接顺序的性能
SET join_collapse_limit = 1;
EXPLAIN ANALYZE SELECT ...;  -- 使用查询中的顺序

SET join_collapse_limit = 8;
EXPLAIN ANALYZE SELECT ...;  -- 使用优化器选择的顺序
```

### 5.3 连接优化配置

```sql
-- 连接优化参数
SHOW join_collapse_limit;
SHOW from_collapse_limit;
SHOW geqo;
SHOW geqo_threshold;

-- 遗传查询优化
SET geqo = on;
SET geqo_threshold = 12;
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13
WHERE t1.id = t2.id AND t2.id = t3.id AND t3.id = t4.id;
```

## 6. 索引优化

### 6.1 索引选择

优化器会根据查询条件、表大小、索引选择性等因素选择使用哪个索引。

**索引选择因素**:

1. **索引选择性**: 索引能过滤掉多少数据
2. **索引大小**: 索引扫描的成本
3. **查询条件**: WHERE子句中的条件
4. **排序需求**: ORDER BY是否可以利用索引

**索引选择示例**:

```sql
-- 创建多个索引
CREATE INDEX idx_emp_dept ON employees(dept_id);
CREATE INDEX idx_emp_salary ON employees(salary);
CREATE INDEX idx_emp_dept_salary ON employees(dept_id, salary);

-- 查询1：优化器选择idx_emp_dept
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE dept_id = 10;
-- 使用索引扫描：Index Scan using idx_emp_dept

-- 查询2：优化器选择idx_emp_salary
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE salary > 50000;
-- 使用索引扫描：Index Scan using idx_emp_salary

-- 查询3：优化器选择idx_emp_dept_salary（组合索引）
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees
WHERE dept_id = 10 AND salary > 50000;
-- 使用索引扫描：Index Scan using idx_emp_dept_salary
```

**索引选择策略**:

```sql
-- 1. 选择性高的索引优先
-- 选择性 = 不同值数量 / 总行数
-- 选择性越高，索引越有用

-- 查看索引选择性
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
ORDER BY idx_scan DESC;

-- 2. 组合索引列顺序很重要
-- 创建组合索引时，选择性高的列放在前面
CREATE INDEX idx_emp_dept_salary ON employees(dept_id, salary);
-- dept_id选择性高，放在前面

-- 3. 部分索引优化
-- 只为常用查询条件创建索引
CREATE INDEX idx_high_salary ON employees(salary)
WHERE salary > 50000;
-- 只索引高薪员工，减少索引大小
```

**索引类型选择**:

```sql
-- B-Tree索引：默认索引，适合等值和范围查询
CREATE INDEX idx_btree ON table1(column1);

-- Hash索引：只支持等值查询，PostgreSQL 10+
CREATE INDEX idx_hash ON table1 USING hash(column1);

-- GIN索引：全文搜索、数组、JSONB
CREATE INDEX idx_gin ON table1 USING gin(column1 gin_trgm_ops);

-- GiST索引：空间数据、全文搜索
CREATE INDEX idx_gist ON table1 USING gist(column1);

-- BRIN索引：大表范围查询，块级索引
CREATE INDEX idx_brin ON table1 USING brin(column1);

-- HNSW索引：向量相似度搜索（pgvector）
CREATE INDEX idx_hnsw ON table1 USING hnsw(embedding vector_l2_ops);
```

**PostgreSQL 18索引选择改进**:

- 更智能的索引选择：改进的代价估算
- 更好的组合索引利用：识别更多可以使用组合索引的场景
- 改进的部分索引支持：更高效的部分索引使用

### 6.2 索引扫描优化

索引扫描有多种方式，优化器会根据数据分布选择最优扫描方式。

**索引扫描类型**:

PostgreSQL支持三种主要的索引扫描方式：

#### Index Scan（索引扫描）

顺序扫描索引，然后回表获取数据，适合需要回表的情况。

```sql
-- Index Scan示例
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE dept_id = 10;
-- Index Scan using idx_emp_dept on employees
--   Index Cond: (dept_id = 10)
```

#### Index Only Scan（仅索引扫描）

只扫描索引，不回表，需要查询的列都在索引中。

```sql
-- Index Only Scan示例
CREATE INDEX idx_emp_dept_name ON employees(dept_id, name);

EXPLAIN (ANALYZE, BUFFERS)
SELECT dept_id, name FROM employees WHERE dept_id = 10;
-- Index Only Scan using idx_emp_dept_name on employees
--   Index Cond: (dept_id = 10)
--   Heap Fetches: 0  -- 不需要回表
```

#### Bitmap Index Scan（位图索引扫描）

先扫描索引构建位图，然后回表，适合多个条件或大量数据。

```sql
-- Bitmap Index Scan示例
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees
WHERE dept_id = 10 AND salary > 50000;
-- Bitmap Heap Scan on employees
--   Recheck Cond: ((dept_id = 10) AND (salary > 50000))
--   -> Bitmap Index Scan on idx_emp_dept
--         Index Cond: (dept_id = 10)
--   -> Bitmap Index Scan on idx_emp_salary
--         Index Cond: (salary > 50000)
```

**索引扫描优化技巧**:

```sql
-- 1. 使用覆盖索引避免回表
CREATE INDEX idx_covering ON employees(dept_id, name, salary);
-- 如果查询只需要这些列，可以使用Index Only Scan

-- 2. 调整索引列顺序
-- 将等值查询的列放在前面
CREATE INDEX idx_optimal ON employees(dept_id, salary, name);
-- dept_id用于等值查询，放在最前面

-- 3. 使用部分索引减少索引大小
CREATE INDEX idx_partial ON employees(salary)
WHERE salary > 50000;
-- 只索引高薪员工

-- 4. 监控索引使用情况
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE idx_scan = 0;  -- 未使用的索引
```

**索引扫描性能调优**:

```sql
-- 1. 调整random_page_cost（SSD环境）
SET random_page_cost = 1.1;  -- SSD默认值4.0太高

-- 2. 调整effective_cache_size
SET effective_cache_size = '8GB';  -- 设置为系统内存的50-75%

-- 3. 强制使用索引（调试用）
SET enable_seqscan = off;
EXPLAIN ANALYZE SELECT * FROM table1 WHERE column1 = 'value';
SET enable_seqscan = on;
```

## 7. 聚合优化

### 7.1 聚合算法

PostgreSQL支持多种聚合算法，优化器会根据数据量和内存情况选择最优算法。

**Hash聚合（Hash Aggregation）**:

适合数据量大、分组键基数高的情况。

```sql
-- Hash聚合示例
EXPLAIN (ANALYZE, BUFFERS)
SELECT dept_id, COUNT(*), AVG(salary), SUM(salary)
FROM employees
GROUP BY dept_id;

-- Hash聚合算法：
-- 1. 在内存中构建哈希表
-- 2. 对每个分组键计算聚合值
-- 3. 内存不足时使用临时文件

-- Hash聚合配置
SET work_mem = '256MB';  -- 影响哈希表大小
```

**Sort聚合（Sort Aggregation）**:

适合数据量小或分组键基数低的情况。

```sql
-- Sort聚合示例
EXPLAIN (ANALYZE, BUFFERS)
SELECT dept_id, COUNT(*), AVG(salary)
FROM employees
GROUP BY dept_id
ORDER BY dept_id;

-- Sort聚合算法：
-- 1. 按分组键排序
-- 2. 顺序扫描计算聚合值
-- 3. 如果已有排序，性能更好
```

**混合聚合（Mixed Aggregation）**:

PostgreSQL 18支持混合聚合，结合Hash和Sort的优势。

```sql
-- 混合聚合示例
EXPLAIN (ANALYZE, BUFFERS)
SELECT dept_id, category, COUNT(*), AVG(salary)
FROM employees
GROUP BY dept_id, category;

-- 优化器可能选择：
-- 1. 先按dept_id分组（Hash）
-- 2. 再按category分组（Sort）
```

**聚合算法选择**:

| 场景 | 推荐算法 | 原因 |
|------|---------|------|
| 分组键基数高 | Hash聚合 | 哈希表查找快 |
| 分组键基数低 | Sort聚合 | 排序开销小 |
| 需要排序结果 | Sort聚合 | 一次排序完成 |
| 内存充足 | Hash聚合 | 性能更好 |
| 内存受限 | Sort聚合 | 使用临时文件 |

**聚合优化配置**:

```sql
-- work_mem影响聚合算法选择
SET work_mem = '256MB';  -- 增加work_mem可能选择Hash聚合

-- 查看聚合统计
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT dept_id, COUNT(*), AVG(salary)
FROM employees
GROUP BY dept_id;
```

**PostgreSQL 18聚合改进**:

- 改进的Hash聚合：更好的内存管理
- 混合聚合支持：结合Hash和Sort优势
- 并行聚合增强：更好的并行聚合支持

### 7.2 窗口函数优化

窗口函数允许在查询结果集上执行计算，而不需要分组。

**窗口函数类型**:

```sql
-- 1. 排名函数
SELECT
    name,
    salary,
    RANK() OVER (ORDER BY salary DESC) as rank,
    DENSE_RANK() OVER (ORDER BY salary DESC) as dense_rank,
    ROW_NUMBER() OVER (ORDER BY salary DESC) as row_num
FROM employees;

-- 2. 聚合窗口函数
SELECT
    dept_id,
    name,
    salary,
    AVG(salary) OVER (PARTITION BY dept_id) as dept_avg,
    SUM(salary) OVER (PARTITION BY dept_id) as dept_total
FROM employees;

-- 3. 窗口帧函数
SELECT
    name,
    salary,
    SUM(salary) OVER (
        ORDER BY salary
        ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING
    ) as moving_sum
FROM employees;
```

**窗口函数优化**:

```sql
-- 1. 使用索引优化窗口函数
CREATE INDEX idx_emp_dept_salary ON employees(dept_id, salary);

-- 窗口函数可以利用索引排序
EXPLAIN (ANALYZE, BUFFERS)
SELECT
    dept_id,
    name,
    salary,
    RANK() OVER (PARTITION BY dept_id ORDER BY salary DESC)
FROM employees;
-- 可以使用索引避免排序

-- 2. 并行窗口函数（PostgreSQL 18）
SET max_parallel_workers_per_gather = 4;
EXPLAIN (ANALYZE, BUFFERS)
SELECT
    dept_id,
    COUNT(*) OVER (PARTITION BY dept_id)
FROM employees;
-- 可能使用并行执行
```

**窗口函数性能优化**:

```sql
-- 1. 减少窗口函数数量
-- 避免多个窗口函数使用不同的PARTITION BY

-- 2. 使用物化视图预计算
CREATE MATERIALIZED VIEW emp_stats AS
SELECT
    dept_id,
    COUNT(*) as emp_count,
    AVG(salary) as avg_salary
FROM employees
GROUP BY dept_id;

-- 3. 使用CTE优化复杂窗口函数
WITH ranked_employees AS (
    SELECT
        dept_id,
        name,
        salary,
        RANK() OVER (PARTITION BY dept_id ORDER BY salary DESC) as rank
    FROM employees
)
SELECT * FROM ranked_employees WHERE rank <= 10;
```

**PostgreSQL 18窗口函数改进**:

- 并行窗口函数支持：支持并行执行窗口函数
- 改进的排序优化：更好的窗口函数排序性能
- 窗口帧优化：更高效的窗口帧计算

## 8. 性能调优

### 8.1 优化器配置调优

```sql
-- 工作内存配置
SET work_mem = '256MB';
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM large_table1 t1
JOIN large_table2 t2 ON t1.id = t2.id;

-- 维护工作内存
SET maintenance_work_mem = '1GB';
VACUUM ANALYZE large_table;

-- 有效缓存大小
SET effective_cache_size = '8GB';
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE salary > 50000;
```

### 8.2 查询提示

```sql
-- 使用提示控制优化器
EXPLAIN (ANALYZE, BUFFERS)
SELECT /*+ HashJoin(e d) */ e.name, d.dept_name
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id;

-- 强制索引使用
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE emp_id = 1001;
-- 通过设置参数强制索引扫描
SET enable_seqscan = off;
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE emp_id = 1001;
```

## 9. 实际应用案例

### 9.1 复杂查询优化

```sql
-- 复杂分析查询
EXPLAIN (ANALYZE, BUFFERS)
WITH dept_stats AS (
    SELECT
        dept_id,
        COUNT(*) as emp_count,
        AVG(salary) as avg_salary,
        MAX(salary) as max_salary
    FROM employees
    GROUP BY dept_id
),
ranked_employees AS (
    SELECT
        e.*,
        ROW_NUMBER() OVER (PARTITION BY e.dept_id ORDER BY e.salary DESC) as salary_rank
    FROM employees e
)
SELECT
    d.dept_name,
    ds.emp_count,
    ds.avg_salary,
    re.name as top_earner,
    re.salary as top_salary
FROM departments d
JOIN dept_stats ds ON d.dept_id = ds.dept_id
JOIN ranked_employees re ON d.dept_id = re.dept_id AND re.salary_rank = 1
WHERE ds.emp_count > 10
ORDER BY ds.avg_salary DESC;
```

### 9.2 大数据量查询优化

```sql
-- 分页查询优化
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM large_table
ORDER BY id
LIMIT 20 OFFSET 1000000;

-- 使用游标优化
BEGIN;
DECLARE cur CURSOR FOR
SELECT * FROM large_table ORDER BY id;
FETCH 20 FROM cur;
FETCH 20 FROM cur;
CLOSE cur;
COMMIT;
```

## 10. 相关概念

### 10.1 上位概念

- **查询处理**: 更广泛的查询处理机制
- **数据库优化**: 数据库性能优化
- **执行引擎**: 查询执行机制

### 10.2 下位概念

- **代价模型**: 查询代价估算
- **查询重写**: 查询转换机制
- **连接优化**: 连接算法选择
- **索引优化**: 索引使用优化

### 10.3 平行概念

- **查询计划器**: 执行计划生成
- **统计信息**: 数据分布统计
- **执行引擎**: 查询执行机制

## 11. 相关文档

- [统计信息与查询调优](./02.03-统计信息与查询调优.md) - 统计信息管理
- [形式化验证方法](../10-理论基础/10.01-形式化验证方法.md) - 查询优化器等价性验证
- [学术研究前沿](../10-理论基础/10.02-学术研究前沿.md) - 查询优化理论研究

### 11.1 实战案例与示例

- [可运行示例项目](../examples/README.md) ⭐ - 8个完整的Docker Compose示例
- [性能问题案例库](../09-应用设计/行业案例/性能问题-案例库.md) - 查询优化实践案例
- [执行计划与性能调优](./02.04-执行计划与性能调优.md) - 性能分析实践

## 12. 参考文献

1. Selinger, P. G., et al. (1979). Access path selection in a relational database management system. ACM SIGMOD Record, 8(2), 23-34.
2. PostgreSQL Global Development Group. (2025). PostgreSQL 18 Documentation. <https://www.postgresql.org/docs/18/>
3. Graefe, G. (1995). The Cascades framework for query optimization. IEEE Data Engineering Bulletin, 18(3), 19-29.
4. Ioannidis, Y. E. (1996). Query optimization. ACM Computing Surveys, 28(1), 121-123.
5. PostgreSQL Global Development Group. (2024). PostgreSQL 17 Documentation. <https://www.postgresql.org/docs/17/>

## 13. 交叉引用

### 相关文档

#### 查询与优化

- ⭐⭐⭐ [执行计划与性能调优](./02.04-执行计划与性能调优.md) - 执行计划分析实践
- ⭐⭐⭐ [统计信息与代价模型](./02.03-统计信息与代价模型.md) - 统计信息对优化器的影响
- ⭐⭐ [索引结构与优化](./02.02-索引结构与优化.md) - 索引选择优化
- ⭐⭐ [并行查询处理](./02.05-并行查询处理.md) - 并行查询优化

#### 核心课程

- ⭐⭐ [SQL语言规范与标准](../../01-核心课程/01.03-SQL语言规范与标准.md) - SQL语言基础
- ⭐ [关系数据模型与理论](../../01-核心课程/01.02-关系数据模型与理论.md) - 关系模型理论基础

#### 数据模型设计

- ⭐⭐ [数据分析完整指南](../../09-应用设计/数据模型设计/09.01-数据分析完整指南.md) - 查询分析实践
- ⭐ [数据建模完整指南](../../09-应用设计/数据模型设计/09.02-数据建模完整指南.md) - 查询建模实践

#### 理论基础

- ⭐⭐ [形式化验证方法](../../10-理论基础/10.01-形式化验证方法.md) - 查询优化器形式化验证
- ⭐ [学术研究前沿](../../10-理论基础/10.02-学术研究前沿.md) - 查询优化研究

#### 部署架构

- ⭐⭐ [性能调优实践](../../05-部署架构/单机部署/05.02-性能调优实践.md) - 性能调优实践指南

#### 运维实践

- ⭐⭐ [监控与诊断](../../06-运维实践/监控与诊断/06.01-监控与诊断.md) - 查询性能监控
- ⭐⭐ [性能问题-案例库](../../09-应用设计/行业案例/性能问题-案例库.md) - 优化器问题案例

### 外部资源

- [PostgreSQL查询规划器文档](https://www.postgresql.org/docs/current/planner-optimizer.html)
- [PostgreSQL查询优化配置](https://www.postgresql.org/docs/current/runtime-config-query.html)
- [PostgreSQL查询优化最佳实践](https://wiki.postgresql.org/wiki/Performance_Optimization)

---

## 14. Wikidata对齐

- **Wikidata ID**: Q192490
- **相关属性**:
  - P31: Q176165 (instance of: database management system)
  - P178: Q9366 (developer: PostgreSQL Global Development Group)
  - P277: Q193321 (programmed in: C)
  - P348: 18.0 (software version)
- **外部链接**:
  - <https://www.postgresql.org/docs/current/planner-optimizer.html>
  - <https://www.postgresql.org/docs/current/runtime-config-query.html>

## 合并来源与映射（整合中）

- 1.1.4-查询优化-增强版.md
- 1.1.4-查询优化-增强版.md
- 1.1.7-查询优化.md
- 1.1.148-PostgreSQL查询优化器国际化标准定义.md
- 1.1.49-选择率估计误差-敏感性与上界.md（误差界与统计部分链接至 02.03）

### 待办事项

以下事项计划在后续版本中完善：

#### 1. 接口描述统一

- [ ] 统一代价模型与统计接口描述
  - 目标：确保代价模型和统计信息接口描述的一致性
  - 优先级：中
  - 计划：创建统一的接口规范文档

#### 2. 内容去重

- [ ] 去重连接顺序与访问路径章节
  - 目标：消除重复内容，提高文档清晰度
  - 优先级：中
  - 计划：合并重复章节，建立清晰的引用关系

#### 3. 形式化证明外链

- [ ] 将部分形式化证明外链至理论基础文档（`10-理论基础/`）
  - 目标：将详细的形式化证明移至理论基础文档，保持本文档的实用性
  - 优先级：低
  - 计划：识别需要外链的形式化证明，建立引用链接
