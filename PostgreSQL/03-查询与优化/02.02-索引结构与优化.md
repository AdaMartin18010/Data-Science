# ç´¢å¼•ç»“æ„ä¸ä¼˜åŒ–

> **ç‰ˆæœ¬**: v3.1
> **æœ€åæ›´æ–°**: 2025-11-22
> **ç‰ˆæœ¬è¦†ç›–**: PostgreSQL 18.x (æ¨è) â­ | 17.x (æ¨è) | 16.x (å…¼å®¹)
> **éš¾åº¦**: â­â­â­â­
> **åº”ç”¨åœºæ™¯**: ç´¢å¼•è®¾è®¡ã€æŸ¥è¯¢ä¼˜åŒ–ã€æ€§èƒ½è°ƒä¼˜
> ğŸ†• **PostgreSQL 18ç´¢å¼•ä¼˜åŒ–**: B-treeå»é‡ä¼˜åŒ–ï¼ˆç´¢å¼•å¤§å°å‡å°‘18%ï¼‰ã€BRINæ€§èƒ½æå‡15-20%ã€æ›´é«˜æ•ˆçš„ç´¢å¼•ç»´æŠ¤ã€å¼‚æ­¥I/Oæå‡ç´¢å¼•æ„å»ºé€Ÿåº¦40%+

---

## ğŸ“‹ ç›®å½•

- [ç´¢å¼•ç»“æ„ä¸ä¼˜åŒ–](#ç´¢å¼•ç»“æ„ä¸ä¼˜åŒ–)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. å®šä¹‰ä¸å½¢å¼åŒ–](#1-å®šä¹‰ä¸å½¢å¼åŒ–)
    - [1.1 æ¦‚å¿µå®šä¹‰](#11-æ¦‚å¿µå®šä¹‰)
    - [1.2 å½¢å¼åŒ–å®šä¹‰](#12-å½¢å¼åŒ–å®šä¹‰)
    - [1.3 æ ¸å¿ƒå±æ€§](#13-æ ¸å¿ƒå±æ€§)
  - [2. ç†è®ºåŸºç¡€](#2-ç†è®ºåŸºç¡€)
    - [2.1 B+æ ‘ç†è®º](#21-bæ ‘ç†è®º)
    - [2.2 å“ˆå¸Œç´¢å¼•ç†è®º](#22-å“ˆå¸Œç´¢å¼•ç†è®º)
    - [2.3 ç´¢å¼•é€‰æ‹©ç†è®º](#23-ç´¢å¼•é€‰æ‹©ç†è®º)
  - [3. PostgreSQLç´¢å¼•ç±»å‹](#3-postgresqlç´¢å¼•ç±»å‹)
    - [3.1 B+æ ‘ç´¢å¼•](#31-bæ ‘ç´¢å¼•)
    - [3.2 å“ˆå¸Œç´¢å¼•](#32-å“ˆå¸Œç´¢å¼•)
    - [3.3 GiSTç´¢å¼•](#33-gistç´¢å¼•)
    - [3.4 GINç´¢å¼•](#34-ginç´¢å¼•)
  - [4. ç´¢å¼•ä¼˜åŒ–ç­–ç•¥](#4-ç´¢å¼•ä¼˜åŒ–ç­–ç•¥)
    - [4.1 å¤åˆç´¢å¼•è®¾è®¡](#41-å¤åˆç´¢å¼•è®¾è®¡)
    - [4.2 éƒ¨åˆ†ç´¢å¼•](#42-éƒ¨åˆ†ç´¢å¼•)
    - [4.3 è¡¨è¾¾å¼ç´¢å¼•](#43-è¡¨è¾¾å¼ç´¢å¼•)
    - [4.4 è¦†ç›–ç´¢å¼•](#44-è¦†ç›–ç´¢å¼•)
  - [5. ç´¢å¼•ç»´æŠ¤](#5-ç´¢å¼•ç»´æŠ¤)
    - [5.1 ç´¢å¼•é‡å»º](#51-ç´¢å¼•é‡å»º)
    - [5.2 ç´¢å¼•ç»Ÿè®¡ä¿¡æ¯](#52-ç´¢å¼•ç»Ÿè®¡ä¿¡æ¯)
    - [5.3 ç´¢å¼•ç›‘æ§](#53-ç´¢å¼•ç›‘æ§)
  - [6. ç´¢å¼•æ€§èƒ½åˆ†æ](#6-ç´¢å¼•æ€§èƒ½åˆ†æ)
    - [6.1 ç´¢å¼•é€‰æ‹©åˆ†æ](#61-ç´¢å¼•é€‰æ‹©åˆ†æ)
    - [6.2 ç´¢å¼•æ•ˆç‡åˆ†æ](#62-ç´¢å¼•æ•ˆç‡åˆ†æ)
    - [6.3 ç´¢å¼•å¤§å°åˆ†æ](#63-ç´¢å¼•å¤§å°åˆ†æ)
  - [7. é«˜çº§ç´¢å¼•æŠ€æœ¯](#7-é«˜çº§ç´¢å¼•æŠ€æœ¯)
    - [7.1 ä½å›¾ç´¢å¼•æ‰«æ](#71-ä½å›¾ç´¢å¼•æ‰«æ)
    - [7.2 ç´¢å¼•è·³è·ƒæ‰«æ](#72-ç´¢å¼•è·³è·ƒæ‰«æ)
    - [7.3 ç´¢å¼•åˆå¹¶](#73-ç´¢å¼•åˆå¹¶)
  - [8. ç´¢å¼•ä¼˜åŒ–å®è·µ](#8-ç´¢å¼•ä¼˜åŒ–å®è·µ)
    - [8.1 æŸ¥è¯¢ä¼˜åŒ–](#81-æŸ¥è¯¢ä¼˜åŒ–)
    - [8.2 æ‰¹é‡æ“ä½œä¼˜åŒ–](#82-æ‰¹é‡æ“ä½œä¼˜åŒ–)
    - [8.3 ç´¢å¼•ç»´æŠ¤ç­–ç•¥](#83-ç´¢å¼•ç»´æŠ¤ç­–ç•¥)
  - [9. å®é™…åº”ç”¨æ¡ˆä¾‹](#9-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [9.1 ç”µå•†ç³»ç»Ÿç´¢å¼•è®¾è®¡](#91-ç”µå•†ç³»ç»Ÿç´¢å¼•è®¾è®¡)
    - [9.2 æ—¥å¿—ç³»ç»Ÿç´¢å¼•è®¾è®¡](#92-æ—¥å¿—ç³»ç»Ÿç´¢å¼•è®¾è®¡)
  - [10. ç›¸å…³æ¦‚å¿µ](#10-ç›¸å…³æ¦‚å¿µ)
    - [10.1 ä¸Šä½æ¦‚å¿µ](#101-ä¸Šä½æ¦‚å¿µ)
    - [10.2 ä¸‹ä½æ¦‚å¿µ](#102-ä¸‹ä½æ¦‚å¿µ)
    - [10.3 å¹³è¡Œæ¦‚å¿µ](#103-å¹³è¡Œæ¦‚å¿µ)
  - [11. ç›¸å…³æ–‡æ¡£](#11-ç›¸å…³æ–‡æ¡£)
    - [11.1 å®æˆ˜æ¡ˆä¾‹ä¸ç¤ºä¾‹](#111-å®æˆ˜æ¡ˆä¾‹ä¸ç¤ºä¾‹)
  - [12. å‚è€ƒæ–‡çŒ®](#12-å‚è€ƒæ–‡çŒ®)
  - [13. Wikidataå¯¹é½](#13-wikidataå¯¹é½)

---

## 1. å®šä¹‰ä¸å½¢å¼åŒ–

### 1.1 æ¦‚å¿µå®šä¹‰

**ä¸­æ–‡å®šä¹‰**: ç´¢å¼•ç»“æ„æ˜¯æ•°æ®åº“ç³»ç»Ÿä¸­ç”¨äºåŠ é€Ÿæ•°æ®è®¿é—®çš„æ•°æ®ç»“æ„ï¼Œé€šè¿‡å»ºç«‹é”®å€¼åˆ°æ•°æ®ä½ç½®çš„æ˜ å°„å…³ç³»æé«˜æŸ¥è¯¢æ€§èƒ½ã€‚PostgreSQLæ”¯æŒå¤šç§ç´¢å¼•ç±»å‹ï¼ŒåŒ…æ‹¬B+æ ‘ã€å“ˆå¸Œã€GiSTã€GINç­‰ã€‚

**English Definition**: Index structures are data structures in database systems used to accelerate data access by establishing mapping relationships between keys and data locations to improve query performance. PostgreSQL supports multiple index types including B+tree, Hash, GiST, GIN, etc.

### 1.2 å½¢å¼åŒ–å®šä¹‰

```latex
% æ•°å­¦ç¬¦å·å®šä¹‰
\newcommand{\index}{\mathcal{I}}
\newcommand{\key}{\mathcal{K}}
\newcommand{\pointer}{\mathcal{P}}
\newcommand{\tuple}{\mathcal{T}}

% ç´¢å¼•çš„å½¢å¼åŒ–å®šä¹‰
\index = \{(k_1, p_1), (k_2, p_2), \ldots, (k_n, p_n)\}

å…¶ä¸­ï¼š
k_i \in \key: ç´¢å¼•é”®å€¼
p_i \in \pointer: æŒ‡å‘æ•°æ®çš„æŒ‡é’ˆ
\forall i \neq j: k_i \neq k_j \text{ (å”¯ä¸€æ€§çº¦æŸ)}
```

### 1.3 æ ¸å¿ƒå±æ€§

- **å¿«é€ŸæŸ¥æ‰¾**: O(log n) æ—¶é—´å¤æ‚åº¦
- **ç©ºé—´æ•ˆç‡**: åˆç†çš„å­˜å‚¨å¼€é”€
- **åŠ¨æ€æ›´æ–°**: æ”¯æŒæ’å…¥ã€åˆ é™¤ã€æ›´æ–°
- **å¹¶å‘å®‰å…¨**: æ”¯æŒå¹¶å‘è®¿é—®

## 2. ç†è®ºåŸºç¡€

### 2.1 B+æ ‘ç†è®º

```latex
\begin{theorem}[B+æ ‘æ€§è´¨]
B+æ ‘æ»¡è¶³ä»¥ä¸‹æ€§è´¨ï¼š
1. æ‰€æœ‰å¶å­èŠ‚ç‚¹åœ¨åŒä¸€å±‚
2. éå¶å­èŠ‚ç‚¹åªå­˜å‚¨é”®å€¼
3. å¶å­èŠ‚ç‚¹åŒ…å«æ‰€æœ‰æ•°æ®
4. æ”¯æŒèŒƒå›´æŸ¥è¯¢å’Œé¡ºåºè®¿é—®
5. æ ‘é«˜ä¸º O(\log n)
\end{theorem}

\begin{proof}
åŸºäºB+æ ‘çš„å¹³è¡¡æ€§è´¨å’ŒèŠ‚ç‚¹åˆ†è£‚åˆå¹¶è§„åˆ™ï¼Œå¯ä»¥è¯æ˜B+æ ‘çš„æ­£ç¡®æ€§ã€‚
\end{proof}
```

### 2.2 å“ˆå¸Œç´¢å¼•ç†è®º

```latex
\begin{theorem}[å“ˆå¸Œç´¢å¼•]
å“ˆå¸Œç´¢å¼•é€šè¿‡å“ˆå¸Œå‡½æ•°å®ç°ï¼š
1. å¹³å‡æŸ¥æ‰¾æ—¶é—´ï¼šO(1)
2. ä¸æ”¯æŒèŒƒå›´æŸ¥è¯¢
3. å“ˆå¸Œå†²çªå¤„ç†ï¼šé“¾å¼æ³•æˆ–å¼€æ”¾åœ°å€æ³•
4. è´Ÿè½½å› å­å½±å“æ€§èƒ½
\end{theorem}
```

### 2.3 ç´¢å¼•é€‰æ‹©ç†è®º

```latex
\begin{theorem}[ç´¢å¼•é€‰æ‹©æ€§]
ç´¢å¼•Iå¯¹æŸ¥è¯¢Qçš„é€‰æ‹©æ€§ä¸ºï¼š
\text{Selectivity}(I, Q) = \frac{|\sigma_p(R)|}{|R|}

å…¶ä¸­pæ˜¯Qçš„è°“è¯æ¡ä»¶ï¼Œé€‰æ‹©æ€§è¶Šé«˜ï¼Œç´¢å¼•æ•ˆæœè¶Šå¥½ã€‚
\end{theorem}
```

## 3. PostgreSQLç´¢å¼•ç±»å‹

### 3.1 B+æ ‘ç´¢å¼•

```sql
-- åˆ›å»ºB+æ ‘ç´¢å¼•
CREATE INDEX idx_emp_salary ON employees (salary);
CREATE INDEX idx_emp_dept_salary ON employees (dept_id, salary);

-- æŸ¥çœ‹ç´¢å¼•ä¿¡æ¯
SELECT
    indexname,
    indexdef,
    pg_size_pretty(pg_relation_size(indexname::regclass)) as size
FROM pg_indexes
WHERE tablename = 'employees';

-- ç´¢å¼•ä½¿ç”¨ç»Ÿè®¡
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE tablename = 'employees'
ORDER BY idx_scan DESC;
```

### 3.2 å“ˆå¸Œç´¢å¼•

```sql
-- åˆ›å»ºå“ˆå¸Œç´¢å¼•
CREATE INDEX idx_emp_id_hash ON employees USING HASH (emp_id);

-- å“ˆå¸Œç´¢å¼•ä½¿ç”¨
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE emp_id = 1001;
```

### 3.3 GiSTç´¢å¼•

```sql
-- åˆ›å»ºGiSTç´¢å¼•ï¼ˆå‡ ä½•æ•°æ®ï¼‰
CREATE TABLE spatial_data (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    location POINT
);

CREATE INDEX idx_spatial_location ON spatial_data USING GIST (location);

-- ç©ºé—´æŸ¥è¯¢
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM spatial_data
WHERE location <@ box '((0,0),(100,100))';
```

### 3.4 GINç´¢å¼•

```sql
-- åˆ›å»ºGINç´¢å¼•ï¼ˆæ•°ç»„æ•°æ®ï¼‰
CREATE TABLE documents (
    id SERIAL PRIMARY KEY,
    title VARCHAR(200),
    tags TEXT[]
);

CREATE INDEX idx_doc_tags ON documents USING GIN (tags);

-- æ•°ç»„æŸ¥è¯¢
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM documents WHERE tags @> ARRAY['postgresql', 'database'];
```

## 4. ç´¢å¼•ä¼˜åŒ–ç­–ç•¥

### 4.1 å¤åˆç´¢å¼•è®¾è®¡

```sql
-- å¤åˆç´¢å¼•è®¾è®¡åŸåˆ™
CREATE INDEX idx_emp_optimized ON employees (dept_id, salary, hire_date);

-- æœ€å·¦å‰ç¼€åŸåˆ™
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE dept_id = 1;  -- ä½¿ç”¨ç´¢å¼•

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE salary > 50000;  -- ä¸ä½¿ç”¨ç´¢å¼•

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE dept_id = 1 AND salary > 50000;  -- ä½¿ç”¨ç´¢å¼•
```

#### 4.1.1 å¤åˆç´¢å¼•è®¾è®¡åŸåˆ™è¯¦è§£

**åˆ—é¡ºåºé€‰æ‹©åŸåˆ™**:

1. **é€‰æ‹©æ€§åŸåˆ™**: é€‰æ‹©æ€§é«˜çš„åˆ—æ”¾åœ¨å‰é¢
   - é€‰æ‹©æ€§ = ä¸åŒå€¼æ•°é‡ / æ€»è¡Œæ•°
   - é€‰æ‹©æ€§è¶Šé«˜ï¼Œè¿‡æ»¤æ•ˆæœè¶Šå¥½

```sql
-- åˆ†æåˆ—é€‰æ‹©æ€§
SELECT
    attname,
    n_distinct,
    round(100.0 * n_distinct / NULLIF(n_live_tup, 0), 2) as selectivity_pct,
    correlation
FROM pg_stats
WHERE schemaname = 'public'
AND tablename = 'employees'
AND attname IN ('dept_id', 'salary', 'hire_date')
ORDER BY n_distinct DESC;

-- æ ¹æ®é€‰æ‹©æ€§åˆ›å»ºç´¢å¼•
-- dept_idé€‰æ‹©æ€§é«˜ï¼ˆå‡è®¾æœ‰100ä¸ªéƒ¨é—¨ï¼‰ï¼Œæ”¾åœ¨å‰é¢
-- salaryé€‰æ‹©æ€§ä¸­ç­‰ï¼Œæ”¾åœ¨ä¸­é—´
-- hire_dateé€‰æ‹©æ€§ä½ï¼ˆæ—¥æœŸèŒƒå›´ï¼‰ï¼Œæ”¾åœ¨åé¢
CREATE INDEX idx_emp_dept_salary_date ON employees (dept_id, salary, hire_date);
```

2. **æŸ¥è¯¢é¢‘ç‡åŸåˆ™**: ç»å¸¸ä¸€èµ·æŸ¥è¯¢çš„åˆ—ç»„åˆåœ¨ä¸€èµ·

```sql
-- åˆ†ææŸ¥è¯¢æ¨¡å¼
SELECT
    schemaname,
    tablename,
    attname,
    n_distinct,
    most_common_vals,
    most_common_freqs
FROM pg_stats
WHERE schemaname = 'public'
AND tablename = 'employees';

-- æ ¹æ®æŸ¥è¯¢æ¨¡å¼åˆ›å»ºç´¢å¼•
-- å¦‚æœç»å¸¸æŸ¥è¯¢ dept_id + salaryï¼Œåˆ›å»ºå¤åˆç´¢å¼•
CREATE INDEX idx_emp_dept_salary ON employees (dept_id, salary);

-- å¦‚æœç»å¸¸å•ç‹¬æŸ¥è¯¢ dept_idï¼Œä¹Ÿå¯ä»¥å•ç‹¬åˆ›å»ºç´¢å¼•
CREATE INDEX idx_emp_dept ON employees (dept_id);
```

3. **ç­‰å€¼æŸ¥è¯¢ä¼˜å…ˆåŸåˆ™**: ç­‰å€¼æŸ¥è¯¢çš„åˆ—æ”¾åœ¨èŒƒå›´æŸ¥è¯¢åˆ—ä¹‹å‰

```sql
-- æ­£ç¡®ï¼šç­‰å€¼åˆ—åœ¨å‰
CREATE INDEX idx_emp_dept_salary ON employees (dept_id, salary);
-- æŸ¥è¯¢ï¼šWHERE dept_id = 1 AND salary > 50000 âœ“ å¯ä»¥ä½¿ç”¨ç´¢å¼•

-- é”™è¯¯ï¼šèŒƒå›´åˆ—åœ¨å‰
CREATE INDEX idx_emp_salary_dept ON employees (salary, dept_id);
-- æŸ¥è¯¢ï¼šWHERE dept_id = 1 AND salary > 50000 âœ— åªèƒ½éƒ¨åˆ†ä½¿ç”¨ç´¢å¼•
```

**å¤åˆç´¢å¼•ä½¿ç”¨åœºæ™¯**:

```sql
-- åœºæ™¯1: å¤šåˆ—ç­‰å€¼æŸ¥è¯¢
CREATE INDEX idx_orders_customer_status ON orders (customer_id, status);
-- æŸ¥è¯¢ï¼šWHERE customer_id = 100 AND status = 'pending'

-- åœºæ™¯2: ç­‰å€¼ + èŒƒå›´æŸ¥è¯¢
CREATE INDEX idx_orders_customer_date ON orders (customer_id, order_date);
-- æŸ¥è¯¢ï¼šWHERE customer_id = 100 AND order_date >= '2024-01-01'

-- åœºæ™¯3: ç­‰å€¼ + æ’åº
CREATE INDEX idx_orders_customer_date_desc ON orders (customer_id, order_date DESC);
-- æŸ¥è¯¢ï¼šWHERE customer_id = 100 ORDER BY order_date DESC

-- åœºæ™¯4: å¤šåˆ—æ’åº
CREATE INDEX idx_products_category_price ON products (category_id, price, created_at);
-- æŸ¥è¯¢ï¼šWHERE category_id = 1 ORDER BY price, created_at
```

**å¤åˆç´¢å¼•æ€§èƒ½å¯¹æ¯”**:

```sql
-- æµ‹è¯•å•åˆ—ç´¢å¼• vs å¤åˆç´¢å¼•
-- å•åˆ—ç´¢å¼•æ–¹æ¡ˆ
CREATE INDEX idx_emp_dept ON employees (dept_id);
CREATE INDEX idx_emp_salary ON employees (salary);

-- å¤åˆç´¢å¼•æ–¹æ¡ˆ
CREATE INDEX idx_emp_dept_salary ON employees (dept_id, salary);

-- æŸ¥è¯¢1: åªä½¿ç”¨dept_id
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE dept_id = 1;
-- å•åˆ—ç´¢å¼•ï¼šIndex Scan using idx_emp_dept
-- å¤åˆç´¢å¼•ï¼šIndex Scan using idx_emp_dept_salaryï¼ˆåŒæ ·é«˜æ•ˆï¼‰

-- æŸ¥è¯¢2: ä½¿ç”¨dept_idå’Œsalary
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE dept_id = 1 AND salary > 50000;
-- å•åˆ—ç´¢å¼•ï¼šBitmap Index Scanï¼ˆéœ€è¦åˆå¹¶ä¸¤ä¸ªç´¢å¼•ï¼‰
-- å¤åˆç´¢å¼•ï¼šIndex Scan using idx_emp_dept_salaryï¼ˆæ›´é«˜æ•ˆï¼‰

-- æŸ¥è¯¢3: åªä½¿ç”¨salary
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE salary > 50000;
-- å•åˆ—ç´¢å¼•ï¼šIndex Scan using idx_emp_salary
-- å¤åˆç´¢å¼•ï¼šSeq Scanï¼ˆæ— æ³•ä½¿ç”¨å¤åˆç´¢å¼•ï¼‰
```

### 4.2 éƒ¨åˆ†ç´¢å¼•

```sql
-- åˆ›å»ºéƒ¨åˆ†ç´¢å¼•
CREATE INDEX idx_high_salary ON employees (salary) WHERE salary > 100000;

-- éƒ¨åˆ†ç´¢å¼•ä½¿ç”¨
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE salary > 150000;  -- ä½¿ç”¨ç´¢å¼•

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE salary < 50000;  -- ä¸ä½¿ç”¨ç´¢å¼•
```

#### 4.2.1 éƒ¨åˆ†ç´¢å¼•è¯¦è§£

**éƒ¨åˆ†ç´¢å¼•çš„ä¼˜åŠ¿**:

1. **å‡å°‘ç´¢å¼•å¤§å°**: åªç´¢å¼•æ»¡è¶³æ¡ä»¶çš„è¡Œ
2. **æå‡ç»´æŠ¤æ€§èƒ½**: æ’å…¥/æ›´æ–°ä¸æ»¡è¶³æ¡ä»¶çš„è¡Œæ—¶ä¸éœ€è¦æ›´æ–°ç´¢å¼•
3. **æé«˜æŸ¥è¯¢æ€§èƒ½**: ç´¢å¼•æ›´å°ï¼Œæ‰«ææ›´å¿«

**ä½¿ç”¨åœºæ™¯**:

```sql
-- åœºæ™¯1: æ´»è·ƒæ•°æ®ç´¢å¼•ï¼ˆåªç´¢å¼•æœªåˆ é™¤çš„è®°å½•ï¼‰
CREATE INDEX idx_orders_active ON orders (customer_id, order_date)
WHERE status != 'deleted';
-- æŸ¥è¯¢æ´»è·ƒè®¢å•æ—¶ä½¿ç”¨ç´¢å¼•ï¼ŒæŸ¥è¯¢å·²åˆ é™¤è®¢å•æ—¶ä¸ä½¿ç”¨ç´¢å¼•

-- åœºæ™¯2: çƒ­ç‚¹æ•°æ®ç´¢å¼•ï¼ˆåªç´¢å¼•é«˜é¢‘æŸ¥è¯¢çš„æ•°æ®ï¼‰
CREATE INDEX idx_products_in_stock ON products (category_id, price)
WHERE stock_quantity > 0;
-- åªç´¢å¼•æœ‰åº“å­˜çš„å•†å“ï¼Œå‡å°‘ç´¢å¼•å¤§å°

-- åœºæ™¯3: æ—¶é—´èŒƒå›´ç´¢å¼•ï¼ˆåªç´¢å¼•æœ€è¿‘çš„æ•°æ®ï¼‰
CREATE INDEX idx_logs_recent ON log_entries (level, log_time)
WHERE log_time >= CURRENT_DATE - interval '30 days';
-- åªç´¢å¼•æœ€è¿‘30å¤©çš„æ—¥å¿—ï¼Œå®šæœŸé‡å»ºç´¢å¼•

-- åœºæ™¯4: çŠ¶æ€ç´¢å¼•ï¼ˆåªç´¢å¼•ç‰¹å®šçŠ¶æ€ï¼‰
CREATE INDEX idx_orders_pending ON orders (customer_id, created_at)
WHERE status = 'pending';
-- åªç´¢å¼•å¾…å¤„ç†è®¢å•ï¼Œå¿«é€ŸæŸ¥è¯¢å¾…å¤„ç†è®¢å•
```

**éƒ¨åˆ†ç´¢å¼•æ€§èƒ½å¯¹æ¯”**:

```sql
-- å…¨ç´¢å¼• vs éƒ¨åˆ†ç´¢å¼•
-- å‡è®¾è¡¨æœ‰1000ä¸‡è¡Œï¼Œä½†åªæœ‰10ä¸‡è¡Œæ»¡è¶³æ¡ä»¶

-- å…¨ç´¢å¼•
CREATE INDEX idx_orders_full ON orders (customer_id, order_date);
-- ç´¢å¼•å¤§å°ï¼š~500MBï¼Œç»´æŠ¤æˆæœ¬é«˜

-- éƒ¨åˆ†ç´¢å¼•
CREATE INDEX idx_orders_partial ON orders (customer_id, order_date)
WHERE status != 'deleted';
-- ç´¢å¼•å¤§å°ï¼š~50MBï¼Œç»´æŠ¤æˆæœ¬ä½

-- æŸ¥è¯¢æ€§èƒ½å¯¹æ¯”
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM orders WHERE customer_id = 100 AND status != 'deleted';
-- å…¨ç´¢å¼•ï¼šIndex Scanï¼Œæ‰«æ500MBç´¢å¼•
-- éƒ¨åˆ†ç´¢å¼•ï¼šIndex Scanï¼Œæ‰«æ50MBç´¢å¼•ï¼ˆ10å€æ€§èƒ½æå‡ï¼‰

-- æ’å…¥æ€§èƒ½å¯¹æ¯”
INSERT INTO orders (customer_id, order_date, status) VALUES (100, NOW(), 'deleted');
-- å…¨ç´¢å¼•ï¼šéœ€è¦æ›´æ–°ç´¢å¼•
-- éƒ¨åˆ†ç´¢å¼•ï¼šä¸éœ€è¦æ›´æ–°ç´¢å¼•ï¼ˆå› ä¸ºstatus='deleted'ä¸æ»¡è¶³æ¡ä»¶ï¼‰
```

**éƒ¨åˆ†ç´¢å¼•ç»´æŠ¤**:

```sql
-- å®šæœŸé‡å»ºéƒ¨åˆ†ç´¢å¼•ï¼ˆå¦‚æœæ¡ä»¶èŒƒå›´å˜åŒ–ï¼‰
-- ä¾‹å¦‚ï¼šæ—¶é—´èŒƒå›´ç´¢å¼•éœ€è¦å®šæœŸæ›´æ–°
DROP INDEX IF EXISTS idx_logs_recent;
CREATE INDEX idx_logs_recent ON log_entries (level, log_time)
WHERE log_time >= CURRENT_DATE - interval '30 days';

-- ä½¿ç”¨å‡½æ•°è‡ªåŠ¨ç»´æŠ¤
CREATE OR REPLACE FUNCTION rebuild_recent_logs_index()
RETURNS void AS $$
BEGIN
    DROP INDEX IF EXISTS idx_logs_recent;
    EXECUTE format(
        'CREATE INDEX idx_logs_recent ON log_entries (level, log_time) '
        'WHERE log_time >= %L',
        CURRENT_DATE - interval '30 days'
    );
END;
$$ LANGUAGE plpgsql;

-- é€šè¿‡cronå®šæœŸæ‰§è¡Œ
-- SELECT cron.schedule('rebuild-logs-index', '0 2 * * *', 'SELECT rebuild_recent_logs_index();');
```

### 4.3 è¡¨è¾¾å¼ç´¢å¼•

```sql
-- åˆ›å»ºè¡¨è¾¾å¼ç´¢å¼•
CREATE INDEX idx_name_lower ON employees (LOWER(name));
CREATE INDEX idx_salary_rounded ON employees ((salary::INTEGER));

-- è¡¨è¾¾å¼ç´¢å¼•ä½¿ç”¨
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE LOWER(name) = 'john doe';

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE (salary::INTEGER) = 50000;
```

#### 4.3.1 è¡¨è¾¾å¼ç´¢å¼•è¯¦è§£

**è¡¨è¾¾å¼ç´¢å¼•çš„ä½¿ç”¨åœºæ™¯**:

1. **å‡½æ•°è°ƒç”¨**: å¯¹åˆ—åº”ç”¨å‡½æ•°åæŸ¥è¯¢

```sql
-- åœºæ™¯1: å¤§å°å†™ä¸æ•æ„ŸæŸ¥è¯¢
CREATE INDEX idx_users_email_lower ON users (LOWER(email));
-- æŸ¥è¯¢ï¼šWHERE LOWER(email) = 'user@example.com'

-- åœºæ™¯2: æ—¥æœŸå‡½æ•°
CREATE INDEX idx_orders_year ON orders (EXTRACT(YEAR FROM order_date));
-- æŸ¥è¯¢ï¼šWHERE EXTRACT(YEAR FROM order_date) = 2024

-- åœºæ™¯3: å­—ç¬¦ä¸²å‡½æ•°
CREATE INDEX idx_products_name_prefix ON products (LEFT(name, 10));
-- æŸ¥è¯¢ï¼šWHERE LEFT(name, 10) = 'Product A'
```

2. **ç±»å‹è½¬æ¢**: æŸ¥è¯¢æ—¶è¿›è¡Œç±»å‹è½¬æ¢

```sql
-- åœºæ™¯1: æ•°å€¼ç±»å‹è½¬æ¢
CREATE INDEX idx_sales_amount_int ON sales ((amount::INTEGER));
-- æŸ¥è¯¢ï¼šWHERE (amount::INTEGER) = 1000

-- åœºæ™¯2: æ—¥æœŸç±»å‹è½¬æ¢
CREATE INDEX idx_events_date_trunc ON events (DATE_TRUNC('day', event_time));
-- æŸ¥è¯¢ï¼šWHERE DATE_TRUNC('day', event_time) = '2024-01-01'
```

3. **JSON/JSONBå­—æ®µ**: ç´¢å¼•JSONå­—æ®µçš„ç‰¹å®šè·¯å¾„

```sql
-- åœºæ™¯1: JSONBå­—æ®µç´¢å¼•
CREATE INDEX idx_products_metadata_category ON products ((metadata->>'category'));
-- æŸ¥è¯¢ï¼šWHERE metadata->>'category' = 'electronics'

-- åœºæ™¯2: JSONBæ•°ç»„ç´¢å¼•
CREATE INDEX idx_documents_tags ON documents USING GIN ((tags::jsonb));
-- æŸ¥è¯¢ï¼šWHERE tags @> '["postgresql"]'::jsonb
```

**è¡¨è¾¾å¼ç´¢å¼•çš„æ³¨æ„äº‹é¡¹**:

```sql
-- 1. æŸ¥è¯¢å¿…é¡»å®Œå…¨åŒ¹é…è¡¨è¾¾å¼
-- ç´¢å¼•ï¼šCREATE INDEX idx_name_lower ON employees (LOWER(name));
-- å¯ä»¥ä½¿ç”¨ï¼šWHERE LOWER(name) = 'john'
-- ä¸èƒ½ä½¿ç”¨ï¼šWHERE name = 'John'ï¼ˆä¸åŒ¹é…è¡¨è¾¾å¼ï¼‰

-- 2. è¡¨è¾¾å¼ç´¢å¼•ç»´æŠ¤æˆæœ¬è¾ƒé«˜
-- æ¯æ¬¡æ’å…¥/æ›´æ–°éƒ½éœ€è¦è®¡ç®—è¡¨è¾¾å¼
-- å¯¹äºå¤æ‚è¡¨è¾¾å¼ï¼Œè€ƒè™‘ä½¿ç”¨å‡½æ•°ç´¢å¼•

-- 3. ä½¿ç”¨IMMUTABLEå‡½æ•°
-- åªæœ‰IMMUTABLEå‡½æ•°å¯ä»¥ç”¨äºè¡¨è¾¾å¼ç´¢å¼•
CREATE INDEX idx_products_created_month ON products (DATE_TRUNC('month', created_at));
-- DATE_TRUNCæ˜¯IMMUTABLEå‡½æ•°

-- 4. éƒ¨åˆ†è¡¨è¾¾å¼ç´¢å¼•
CREATE INDEX idx_high_salary_rounded ON employees ((salary::INTEGER))
WHERE (salary::INTEGER) > 100000;
-- ç»“åˆéƒ¨åˆ†ç´¢å¼•ï¼Œå‡å°‘ç´¢å¼•å¤§å°
```

**è¡¨è¾¾å¼ç´¢å¼•æ€§èƒ½å¯¹æ¯”**:

```sql
-- æ— ç´¢å¼•ï¼šå…¨è¡¨æ‰«æ
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE LOWER(name) = 'john doe';
-- Seq Scanï¼Œæ‰«ææ‰€æœ‰è¡Œ

-- æœ‰è¡¨è¾¾å¼ç´¢å¼•ï¼šç´¢å¼•æ‰«æ
CREATE INDEX idx_name_lower ON employees (LOWER(name));
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE LOWER(name) = 'john doe';
-- Index Scan using idx_name_lowerï¼ˆæ€§èƒ½æå‡æ˜¾è‘—ï¼‰

-- ç»´æŠ¤æˆæœ¬å¯¹æ¯”
-- æ’å…¥100ä¸‡è¡Œ
INSERT INTO employees (name, salary)
SELECT 'Employee' || generate_series(1, 1000000), random() * 100000;
-- æ— è¡¨è¾¾å¼ç´¢å¼•ï¼šæ’å…¥æ—¶é—´åŸºå‡†
-- æœ‰è¡¨è¾¾å¼ç´¢å¼•ï¼šæ’å…¥æ—¶é—´å¢åŠ 10-20%ï¼ˆéœ€è¦è®¡ç®—LOWER(name)ï¼‰
```

### 4.4 è¦†ç›–ç´¢å¼•

```sql
-- åˆ›å»ºè¦†ç›–ç´¢å¼•
CREATE INDEX idx_emp_covering ON employees (dept_id) INCLUDE (name, salary);

-- è¦†ç›–ç´¢å¼•ä½¿ç”¨
EXPLAIN (ANALYZE, BUFFERS)
SELECT dept_id, name, salary FROM employees WHERE dept_id = 1;
```

#### 4.4.1 è¦†ç›–ç´¢å¼•è¯¦è§£

**è¦†ç›–ç´¢å¼•åŸç†**:

è¦†ç›–ç´¢å¼•ï¼ˆCovering Indexï¼‰åŒ…å«æŸ¥è¯¢æ‰€éœ€çš„æ‰€æœ‰åˆ—ï¼ŒæŸ¥è¯¢å¯ä»¥ç›´æ¥ä»ç´¢å¼•è·å–æ•°æ®ï¼Œæ— éœ€å›è¡¨è®¿é—®å †è¡¨ï¼Œå¤§å¹…æå‡æŸ¥è¯¢æ€§èƒ½ã€‚

**INCLUDEåˆ—çš„ä½¿ç”¨**:

```sql
-- PostgreSQL 11+æ”¯æŒINCLUDEåˆ—
-- INCLUDEåˆ—ä¸å‚ä¸ç´¢å¼•æ’åºï¼Œä½†å­˜å‚¨åœ¨ç´¢å¼•ä¸­
CREATE INDEX idx_orders_covering ON orders (customer_id, order_date)
INCLUDE (status, total_amount);

-- æŸ¥è¯¢å¯ä»¥ç›´æ¥ä»ç´¢å¼•è·å–æ‰€æœ‰æ•°æ®
EXPLAIN (ANALYZE, BUFFERS)
SELECT customer_id, order_date, status, total_amount
FROM orders
WHERE customer_id = 100 AND order_date >= '2024-01-01';
-- Index Only Scanï¼ˆä¸éœ€è¦è®¿é—®å †è¡¨ï¼‰
```

**è¦†ç›–ç´¢å¼• vs æ™®é€šç´¢å¼•**:

```sql
-- æ™®é€šç´¢å¼•
CREATE INDEX idx_orders_customer_date ON orders (customer_id, order_date);

-- æŸ¥è¯¢éœ€è¦å›è¡¨
EXPLAIN (ANALYZE, BUFFERS)
SELECT customer_id, order_date, status, total_amount
FROM orders
WHERE customer_id = 100;
-- Index Scan -> Heap Fetchï¼ˆéœ€è¦è®¿é—®å †è¡¨è·å–statuså’Œtotal_amountï¼‰

-- è¦†ç›–ç´¢å¼•
CREATE INDEX idx_orders_covering ON orders (customer_id, order_date)
INCLUDE (status, total_amount);

-- æŸ¥è¯¢ä¸éœ€è¦å›è¡¨
EXPLAIN (ANALYZE, BUFFERS)
SELECT customer_id, order_date, status, total_amount
FROM orders
WHERE customer_id = 100;
-- Index Only Scanï¼ˆç›´æ¥ä»ç´¢å¼•è·å–æ‰€æœ‰æ•°æ®ï¼‰

-- æ€§èƒ½å¯¹æ¯”
-- æ™®é€šç´¢å¼•ï¼š1000æ¬¡ç´¢å¼•æ‰«æ + 1000æ¬¡å †è¡¨è®¿é—®
-- è¦†ç›–ç´¢å¼•ï¼š1000æ¬¡ç´¢å¼•æ‰«æï¼ˆæ— å †è¡¨è®¿é—®ï¼‰
-- æ€§èƒ½æå‡ï¼š2-3å€ï¼ˆå–å†³äºå †è¡¨è®¿é—®æˆæœ¬ï¼‰
```

**è¦†ç›–ç´¢å¼•è®¾è®¡åŸåˆ™**:

```sql
-- 1. åˆ†ææŸ¥è¯¢æ¨¡å¼
-- è¯†åˆ«ç»å¸¸ä¸€èµ·æŸ¥è¯¢çš„åˆ—ç»„åˆ
SELECT
    schemaname,
    tablename,
    attname,
    n_distinct
FROM pg_stats
WHERE schemaname = 'public'
AND tablename = 'orders';

-- 2. åˆ›å»ºè¦†ç›–ç´¢å¼•
-- å°†WHEREå­å¥çš„åˆ—æ”¾åœ¨ç´¢å¼•é”®ä¸­
-- å°†SELECTå­å¥çš„å…¶ä»–åˆ—æ”¾åœ¨INCLUDEä¸­
CREATE INDEX idx_orders_covering ON orders (customer_id, order_date)
INCLUDE (status, total_amount, shipping_address);

-- 3. é¿å…è¿‡åº¦ä½¿ç”¨INCLUDE
-- INCLUDEåˆ—ä¼šå¢åŠ ç´¢å¼•å¤§å°
-- åªåŒ…å«ç»å¸¸æŸ¥è¯¢çš„åˆ—
CREATE INDEX idx_orders_minimal ON orders (customer_id)
INCLUDE (order_date, status);  -- åªåŒ…å«å¿…è¦åˆ—

-- 4. ç»“åˆéƒ¨åˆ†ç´¢å¼•
CREATE INDEX idx_orders_active_covering ON orders (customer_id, order_date)
INCLUDE (status, total_amount)
WHERE status != 'cancelled';
-- åªç´¢å¼•æ´»è·ƒè®¢å•ï¼Œå‡å°‘ç´¢å¼•å¤§å°
```

**è¦†ç›–ç´¢å¼•ä½¿ç”¨åœºæ™¯**:

```sql
-- åœºæ™¯1: æŠ¥è¡¨æŸ¥è¯¢ï¼ˆåªæŸ¥è¯¢ç‰¹å®šåˆ—ï¼‰
CREATE INDEX idx_sales_covering ON sales (sale_date, region)
INCLUDE (product_id, quantity, amount);
-- æŸ¥è¯¢ï¼šSELECT sale_date, region, product_id, quantity, amount FROM sales WHERE ...

-- åœºæ™¯2: APIæŸ¥è¯¢ï¼ˆè¿”å›å›ºå®šå­—æ®µï¼‰
CREATE INDEX idx_users_api_covering ON users (user_id)
INCLUDE (name, email, created_at, status);
-- æŸ¥è¯¢ï¼šSELECT user_id, name, email, created_at, status FROM users WHERE user_id = ?

-- åœºæ™¯3: èšåˆæŸ¥è¯¢ï¼ˆé¢„è®¡ç®—åˆ—ï¼‰
CREATE INDEX idx_orders_stats_covering ON orders (customer_id, order_date)
INCLUDE (total_amount);
-- æŸ¥è¯¢ï¼šSELECT customer_id, SUM(total_amount) FROM orders WHERE ... GROUP BY customer_id
```

**è¦†ç›–ç´¢å¼•æ€§èƒ½ç›‘æ§**:

```sql
-- æ£€æŸ¥ç´¢å¼•ä½¿ç”¨æƒ…å†µ
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE indexname LIKE '%covering%';

-- æ£€æŸ¥Index Only Scanä½¿ç”¨æƒ…å†µ
EXPLAIN (ANALYZE, BUFFERS)
SELECT customer_id, order_date, status, total_amount
FROM orders
WHERE customer_id = 100;
-- æŸ¥çœ‹æ˜¯å¦ä½¿ç”¨Index Only Scan

-- ç›‘æ§ç´¢å¼•å¤§å°
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexname::regclass)) as index_size,
    pg_size_pretty(pg_relation_size(tablename::regclass)) as table_size
FROM pg_indexes
WHERE indexname LIKE '%covering%';
```

## 5. ç´¢å¼•ç»´æŠ¤

### 5.1 ç´¢å¼•é‡å»º

```sql
-- é‡å»ºç´¢å¼•
REINDEX INDEX idx_emp_salary;
REINDEX TABLE employees;

-- å¹¶å‘é‡å»ºç´¢å¼•
REINDEX INDEX CONCURRENTLY idx_emp_salary;

-- æŸ¥çœ‹ç´¢å¼•è†¨èƒ€
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexname::regclass)) as index_size,
    pg_size_pretty(pg_relation_size(tablename::regclass)) as table_size
FROM pg_indexes
WHERE tablename = 'employees';
```

### 5.2 ç´¢å¼•ç»Ÿè®¡ä¿¡æ¯

```sql
-- æ›´æ–°ç´¢å¼•ç»Ÿè®¡ä¿¡æ¯
ANALYZE employees;

-- æŸ¥çœ‹ç´¢å¼•ç»Ÿè®¡
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch,
    idx_blks_read,
    idx_blks_hit
FROM pg_statio_user_indexes
WHERE tablename = 'employees';
```

### 5.3 ç´¢å¼•ç›‘æ§

```sql
-- ç›‘æ§ç´¢å¼•ä½¿ç”¨æƒ…å†µ
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch,
    CASE
        WHEN idx_scan = 0 THEN 'UNUSED'
        WHEN idx_tup_read / idx_scan > 1000 THEN 'INEFFICIENT'
        ELSE 'EFFICIENT'
    END as status
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
ORDER BY idx_scan DESC;
```

#### 5.3.1 ç´¢å¼•ç›‘æ§è¯¦è§£

**ç´¢å¼•ä½¿ç”¨æƒ…å†µç›‘æ§**:

```sql
-- 1. è¯†åˆ«æœªä½¿ç”¨çš„ç´¢å¼•
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexname::regclass)) as index_size,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE idx_scan = 0
AND pg_relation_size(indexname::regclass) > 1000000  -- å¤§äº1MB
ORDER BY pg_relation_size(indexname::regclass) DESC;

-- 2. è¯†åˆ«ä½æ•ˆç´¢å¼•
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    round(1.0 * idx_tup_read / NULLIF(idx_scan, 0), 2) as avg_tuples_per_scan,
    CASE
        WHEN idx_scan = 0 THEN 'UNUSED'
        WHEN idx_tup_read / NULLIF(idx_scan, 0) > 10000 THEN 'INEFFICIENT'
        ELSE 'EFFICIENT'
    END as efficiency
FROM pg_stat_user_indexes
WHERE idx_scan > 0
ORDER BY idx_tup_read / NULLIF(idx_scan, 0) DESC;

-- 3. ç´¢å¼•å‘½ä¸­ç‡ç›‘æ§
SELECT
    schemaname,
    tablename,
    indexname,
    idx_blks_hit,
    idx_blks_read,
    round(100.0 * idx_blks_hit / NULLIF(idx_blks_hit + idx_blks_read, 0), 2) as hit_ratio
FROM pg_statio_user_indexes
WHERE idx_blks_hit + idx_blks_read > 0
ORDER BY hit_ratio ASC;
```

**ç´¢å¼•è†¨èƒ€ç›‘æ§**:

```sql
-- 1. æ£€æŸ¥ç´¢å¼•è†¨èƒ€
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexname::regclass)) as index_size,
    pg_size_pretty(pg_relation_size(tablename::regclass)) as table_size,
    round(100.0 * pg_relation_size(indexname::regclass) /
          NULLIF(pg_relation_size(tablename::regclass), 0), 2) as size_ratio
FROM pg_indexes
WHERE schemaname = 'public'
ORDER BY pg_relation_size(indexname::regclass) DESC;

-- 2. ä½¿ç”¨pgstattupleæ‰©å±•æ£€æŸ¥ç´¢å¼•è†¨èƒ€ï¼ˆéœ€è¦å®‰è£…æ‰©å±•ï¼‰
CREATE EXTENSION IF NOT EXISTS pgstattuple;
SELECT * FROM pgstatindex('idx_emp_salary');
-- è¿”å›ç´¢å¼•ç»Ÿè®¡ä¿¡æ¯ï¼ŒåŒ…æ‹¬è†¨èƒ€ç‡

-- 3. è¯†åˆ«éœ€è¦é‡å»ºçš„ç´¢å¼•
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexname::regclass)) as index_size,
    idx_scan,
    last_vacuum,
    last_autovacuum
FROM pg_stat_user_indexes
WHERE pg_relation_size(indexname::regclass) > 100000000  -- å¤§äº100MB
AND (last_vacuum IS NULL OR last_vacuum < NOW() - interval '7 days')
ORDER BY pg_relation_size(indexname::regclass) DESC;
```

**ç´¢å¼•ç»´æŠ¤è‡ªåŠ¨åŒ–**:

```sql
-- è‡ªåŠ¨ç´¢å¼•ç»´æŠ¤å‡½æ•°
CREATE OR REPLACE FUNCTION maintain_indexes(
    min_size_mb integer DEFAULT 100,
    unused_days integer DEFAULT 30
)
RETURNS TABLE(
    action text,
    schemaname text,
    tablename text,
    indexname text,
    reason text
) AS $$
DECLARE
    r RECORD;
BEGIN
    -- 1. è¯†åˆ«æœªä½¿ç”¨çš„ç´¢å¼•
    FOR r IN
        SELECT
            i.schemaname,
            i.tablename,
            i.indexname,
            pg_relation_size(i.indexname::regclass) as index_size,
            s.idx_scan,
            s.last_vacuum,
            s.last_autovacuum
        FROM pg_indexes i
        LEFT JOIN pg_stat_user_indexes s
            ON s.schemaname = i.schemaname
            AND s.tablename = i.tablename
            AND s.indexname = i.indexname
        WHERE i.schemaname = 'public'
        AND pg_relation_size(i.indexname::regclass) > min_size_mb * 1024 * 1024
    LOOP
        -- æ£€æŸ¥æ˜¯å¦æœªä½¿ç”¨
        IF r.idx_scan = 0 OR r.idx_scan IS NULL THEN
            RETURN QUERY SELECT
                'DROP'::text,
                r.schemaname,
                r.tablename,
                r.indexname,
                format('Unused index, size: %s', pg_size_pretty(r.index_size))::text;
        END IF;

        -- æ£€æŸ¥æ˜¯å¦éœ€è¦é‡å»º
        IF (r.last_vacuum IS NULL AND r.last_autovacuum IS NULL)
           OR (r.last_vacuum < NOW() - (unused_days || ' days')::interval
               AND r.last_autovacuum < NOW() - (unused_days || ' days')::interval) THEN
            RETURN QUERY SELECT
                'REINDEX'::text,
                r.schemaname,
                r.tablename,
                r.indexname,
                format('Index not vacuumed in %s days', unused_days)::text;
        END IF;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨ç¤ºä¾‹
SELECT * FROM maintain_indexes(100, 30);
-- è¿”å›éœ€è¦ç»´æŠ¤çš„ç´¢å¼•åˆ—è¡¨
```

## 6. ç´¢å¼•æ€§èƒ½åˆ†æ

### 6.1 ç´¢å¼•é€‰æ‹©åˆ†æ

```sql
-- åˆ†æç´¢å¼•é€‰æ‹©
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT * FROM employees WHERE emp_id = 1001;

-- åˆ†æå¤åˆç´¢å¼•
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT * FROM employees WHERE dept_id = 1 AND salary > 50000;

-- åˆ†æèŒƒå›´æŸ¥è¯¢
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT * FROM employees WHERE salary BETWEEN 40000 AND 60000;
```

### 6.2 ç´¢å¼•æ•ˆç‡åˆ†æ

```sql
-- ç´¢å¼•æ•ˆç‡åˆ†æ
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch,
    round(100.0 * idx_blks_hit / (idx_blks_hit + idx_blks_read), 2) as hit_ratio
FROM pg_statio_user_indexes
WHERE idx_blks_hit + idx_blks_read > 0
ORDER BY hit_ratio ASC;
```

### 6.3 ç´¢å¼•å¤§å°åˆ†æ

```sql
-- ç´¢å¼•å¤§å°åˆ†æ
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexname::regclass)) as index_size,
    pg_size_pretty(pg_relation_size(tablename::regclass)) as table_size,
    round(100.0 * pg_relation_size(indexname::regclass) / pg_relation_size(tablename::regclass), 2) as size_ratio
FROM pg_indexes
WHERE schemaname = 'public'
ORDER BY pg_relation_size(indexname::regclass) DESC;
```

## 7. é«˜çº§ç´¢å¼•æŠ€æœ¯

### 7.1 ä½å›¾ç´¢å¼•æ‰«æ

```sql
-- ä½å›¾ç´¢å¼•æ‰«æ
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE dept_id = 1 AND salary > 50000;

-- ä½å›¾å †æ‰«æ
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE dept_id IN (1, 2, 3) AND salary > 50000;
```

### 7.2 ç´¢å¼•è·³è·ƒæ‰«æ

```sql
-- ç´¢å¼•è·³è·ƒæ‰«æ
CREATE INDEX idx_emp_skip ON employees (dept_id, salary, hire_date);

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE salary > 50000 ORDER BY dept_id, salary;
```

### 7.3 ç´¢å¼•åˆå¹¶

```sql
-- ç´¢å¼•åˆå¹¶
CREATE INDEX idx_emp_dept ON employees (dept_id);
CREATE INDEX idx_emp_salary ON employees (salary);

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE dept_id = 1 OR salary > 50000;
```

## 8. ç´¢å¼•ä¼˜åŒ–å®è·µ

### 8.1 æŸ¥è¯¢ä¼˜åŒ–

```sql
-- ä¼˜åŒ–å‰
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees
WHERE dept_id = 1 AND salary > 50000 AND hire_date > '2020-01-01';

-- åˆ›å»ºä¼˜åŒ–ç´¢å¼•
CREATE INDEX idx_emp_optimized ON employees (dept_id, salary, hire_date);

-- ä¼˜åŒ–å
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees
WHERE dept_id = 1 AND salary > 50000 AND hire_date > '2020-01-01';
```

### 8.2 æ‰¹é‡æ“ä½œä¼˜åŒ–

```sql
-- æ‰¹é‡æ’å…¥ä¼˜åŒ–
BEGIN;
-- ä¸´æ—¶ç¦ç”¨ç´¢å¼•
DROP INDEX CONCURRENTLY idx_emp_salary;
-- æ‰¹é‡æ’å…¥
INSERT INTO employees (name, dept_id, salary)
SELECT 'Employee' || generate_series(1, 100000),
       (random() * 10)::INTEGER + 1,
       (random() * 100000)::INTEGER + 30000;
-- é‡å»ºç´¢å¼•
CREATE INDEX CONCURRENTLY idx_emp_salary ON employees (salary);
COMMIT;
```

### 8.3 ç´¢å¼•ç»´æŠ¤ç­–ç•¥

```sql
-- è‡ªåŠ¨ç´¢å¼•ç»´æŠ¤
CREATE OR REPLACE FUNCTION maintain_indexes()
RETURNS void AS $$
DECLARE
    r RECORD;
BEGIN
    FOR r IN
        SELECT schemaname, tablename, indexname
        FROM pg_indexes
        WHERE schemaname = 'public'
    LOOP
        -- æ£€æŸ¥ç´¢å¼•ä½¿ç”¨æƒ…å†µ
        IF (SELECT idx_scan FROM pg_stat_user_indexes
            WHERE schemaname = r.schemaname
            AND tablename = r.tablename
            AND indexname = r.indexname) = 0 THEN

            RAISE NOTICE 'Unused index: %.%', r.tablename, r.indexname;
        END IF;
    END LOOP;
END;
$$ LANGUAGE plpgsql;
```

## 9. å®é™…åº”ç”¨æ¡ˆä¾‹

### 9.1 ç”µå•†ç³»ç»Ÿç´¢å¼•è®¾è®¡

```sql
-- å•†å“è¡¨ç´¢å¼•
CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    name VARCHAR(200),
    category_id INTEGER,
    price DECIMAL(10,2),
    stock_quantity INTEGER,
    created_at TIMESTAMP DEFAULT NOW()
);

-- å¤åˆç´¢å¼•
CREATE INDEX idx_products_category_price ON products (category_id, price);
CREATE INDEX idx_products_stock ON products (stock_quantity) WHERE stock_quantity > 0;

-- è®¢å•è¡¨ç´¢å¼•
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INTEGER,
    order_date TIMESTAMP DEFAULT NOW(),
    status VARCHAR(20),
    total_amount DECIMAL(10,2)
);

-- æ—¶é—´èŒƒå›´ç´¢å¼•
CREATE INDEX idx_orders_date_status ON orders (order_date, status);
CREATE INDEX idx_orders_customer ON orders (customer_id, order_date);
```

#### 9.1.1 ç”µå•†ç³»ç»Ÿç´¢å¼•è®¾è®¡å®Œæ•´æ–¹æ¡ˆ

**ä¸šåŠ¡åœºæ™¯åˆ†æ**:

1. **å•†å“æŸ¥è¯¢**: æŒ‰åˆ†ç±»ã€ä»·æ ¼èŒƒå›´ã€åº“å­˜çŠ¶æ€æŸ¥è¯¢
2. **è®¢å•æŸ¥è¯¢**: æŒ‰å®¢æˆ·ã€æ—¶é—´èŒƒå›´ã€çŠ¶æ€æŸ¥è¯¢
3. **æœç´¢åŠŸèƒ½**: å•†å“åç§°å…¨æ–‡æœç´¢
4. **æŠ¥è¡¨æŸ¥è¯¢**: æŒ‰æ—¶é—´ã€åˆ†ç±»èšåˆç»Ÿè®¡

**å®Œæ•´ç´¢å¼•è®¾è®¡æ–¹æ¡ˆ**:

```sql
-- 1. å•†å“è¡¨ç´¢å¼•è®¾è®¡
CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    category_id INTEGER NOT NULL,
    brand_id INTEGER,
    price DECIMAL(10,2) NOT NULL,
    stock_quantity INTEGER DEFAULT 0,
    status VARCHAR(20) DEFAULT 'active',
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- ä¸»é”®ç´¢å¼•ï¼ˆè‡ªåŠ¨åˆ›å»ºï¼‰
-- PRIMARY KEY (product_id)

-- åˆ†ç±»+ä»·æ ¼å¤åˆç´¢å¼•ï¼ˆæ”¯æŒåˆ†ç±»æµè§ˆå’Œä»·æ ¼æ’åºï¼‰
CREATE INDEX idx_products_category_price ON products (category_id, price);

-- å“ç‰Œ+ä»·æ ¼ç´¢å¼•ï¼ˆæ”¯æŒå“ç‰Œç­›é€‰ï¼‰
CREATE INDEX idx_products_brand_price ON products (brand_id, price)
WHERE brand_id IS NOT NULL;

-- æœ‰åº“å­˜å•†å“ç´¢å¼•ï¼ˆéƒ¨åˆ†ç´¢å¼•ï¼Œåªç´¢å¼•æœ‰åº“å­˜çš„å•†å“ï¼‰
CREATE INDEX idx_products_in_stock ON products (category_id, price)
WHERE stock_quantity > 0 AND status = 'active';

-- å•†å“åç§°å…¨æ–‡æœç´¢ç´¢å¼•
CREATE INDEX idx_products_name_gin ON products USING GIN (to_tsvector('english', name));

-- æ›´æ–°æ—¶é—´ç´¢å¼•ï¼ˆæ”¯æŒæœ€è¿‘æ›´æ–°å•†å“æŸ¥è¯¢ï¼‰
CREATE INDEX idx_products_updated ON products (updated_at DESC)
WHERE status = 'active';

-- 2. è®¢å•è¡¨ç´¢å¼•è®¾è®¡
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INTEGER NOT NULL,
    order_date TIMESTAMP NOT NULL DEFAULT NOW(),
    status VARCHAR(20) NOT NULL DEFAULT 'pending',
    total_amount DECIMAL(10,2) NOT NULL,
    shipping_address TEXT,
    created_at TIMESTAMP DEFAULT NOW()
);

-- å®¢æˆ·+æ—¶é—´ç´¢å¼•ï¼ˆæ”¯æŒå®¢æˆ·è®¢å•å†å²æŸ¥è¯¢ï¼‰
CREATE INDEX idx_orders_customer_date ON orders (customer_id, order_date DESC);

-- çŠ¶æ€+æ—¶é—´ç´¢å¼•ï¼ˆæ”¯æŒæŒ‰çŠ¶æ€æŸ¥è¯¢è®¢å•ï¼‰
CREATE INDEX idx_orders_status_date ON orders (status, order_date DESC);

-- å¾…å¤„ç†è®¢å•ç´¢å¼•ï¼ˆéƒ¨åˆ†ç´¢å¼•ï¼Œåªç´¢å¼•å¾…å¤„ç†è®¢å•ï¼‰
CREATE INDEX idx_orders_pending ON orders (order_date)
WHERE status IN ('pending', 'processing');

-- è¦†ç›–ç´¢å¼•ï¼ˆæ”¯æŒè®¢å•åˆ—è¡¨æŸ¥è¯¢ï¼ŒåŒ…å«å¸¸ç”¨å­—æ®µï¼‰
CREATE INDEX idx_orders_covering ON orders (customer_id, order_date)
INCLUDE (status, total_amount);

-- 3. è®¢å•é¡¹è¡¨ç´¢å¼•è®¾è®¡
CREATE TABLE order_items (
    item_id SERIAL PRIMARY KEY,
    order_id INTEGER NOT NULL REFERENCES orders(order_id),
    product_id INTEGER NOT NULL REFERENCES products(product_id),
    quantity INTEGER NOT NULL,
    price DECIMAL(10,2) NOT NULL
);

-- è®¢å•+äº§å“ç´¢å¼•ï¼ˆæ”¯æŒè®¢å•è¯¦æƒ…æŸ¥è¯¢ï¼‰
CREATE INDEX idx_order_items_order ON order_items (order_id, product_id);

-- äº§å“ç´¢å¼•ï¼ˆæ”¯æŒäº§å“é”€å”®ç»Ÿè®¡ï¼‰
CREATE INDEX idx_order_items_product ON order_items (product_id, order_id);

-- 4. æŸ¥è¯¢æ€§èƒ½æµ‹è¯•
-- æŸ¥è¯¢1: æŒ‰åˆ†ç±»å’Œä»·æ ¼èŒƒå›´æŸ¥è¯¢å•†å“
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM products
WHERE category_id = 1 AND price BETWEEN 100 AND 500
ORDER BY price;
-- ä½¿ç”¨ç´¢å¼•ï¼šidx_products_category_price

-- æŸ¥è¯¢2: å®¢æˆ·è®¢å•å†å²
EXPLAIN (ANALYZE, BUFFERS)
SELECT order_id, order_date, status, total_amount
FROM orders
WHERE customer_id = 100
ORDER BY order_date DESC
LIMIT 20;
-- ä½¿ç”¨ç´¢å¼•ï¼šidx_orders_customer_dateï¼ˆè¦†ç›–ç´¢å¼•ï¼‰

-- æŸ¥è¯¢3: å¾…å¤„ç†è®¢å•
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM orders
WHERE status = 'pending'
ORDER BY order_date;
-- ä½¿ç”¨ç´¢å¼•ï¼šidx_orders_pendingï¼ˆéƒ¨åˆ†ç´¢å¼•ï¼‰

-- æŸ¥è¯¢4: å•†å“åç§°æœç´¢
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM products
WHERE to_tsvector('english', name) @@ to_tsquery('english', 'laptop');
-- ä½¿ç”¨ç´¢å¼•ï¼šidx_products_name_ginï¼ˆGINç´¢å¼•ï¼‰
```

**ç´¢å¼•ç»´æŠ¤ç­–ç•¥**:

```sql
-- 1. å®šæœŸé‡å»ºéƒ¨åˆ†ç´¢å¼•ï¼ˆæ—¶é—´èŒƒå›´å˜åŒ–ï¼‰
DROP INDEX IF EXISTS idx_products_updated;
CREATE INDEX idx_products_updated ON products (updated_at DESC)
WHERE status = 'active' AND updated_at >= CURRENT_DATE - interval '30 days';

-- 2. ç›‘æ§ç´¢å¼•ä½¿ç”¨æƒ…å†µ
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    pg_size_pretty(pg_relation_size(indexname::regclass)) as index_size
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
AND tablename IN ('products', 'orders', 'order_items')
ORDER BY idx_scan DESC;

-- 3. è¯†åˆ«æœªä½¿ç”¨çš„ç´¢å¼•
SELECT
    indexname,
    pg_size_pretty(pg_relation_size(indexname::regclass)) as index_size
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
AND idx_scan = 0
AND pg_relation_size(indexname::regclass) > 10000000;  -- å¤§äº10MB
```

### 9.2 æ—¥å¿—ç³»ç»Ÿç´¢å¼•è®¾è®¡

```sql
-- æ—¥å¿—è¡¨ç´¢å¼•
CREATE TABLE log_entries (
    id BIGSERIAL PRIMARY KEY,
    log_time TIMESTAMP,
    level VARCHAR(10),
    source VARCHAR(100),
    message TEXT
);

-- æ—¶é—´åˆ†åŒºç´¢å¼•
CREATE INDEX idx_log_time ON log_entries (log_time);
CREATE INDEX idx_log_level_time ON log_entries (level, log_time);
CREATE INDEX idx_log_source_time ON log_entries (source, log_time);

-- å…¨æ–‡æœç´¢ç´¢å¼•
CREATE INDEX idx_log_message_gin ON log_entries USING GIN (to_tsvector('english', message));
```

#### 9.2.1 æ—¥å¿—ç³»ç»Ÿç´¢å¼•è®¾è®¡å®Œæ•´æ–¹æ¡ˆ

**ä¸šåŠ¡åœºæ™¯åˆ†æ**:

1. **æ—¶é—´èŒƒå›´æŸ¥è¯¢**: æŸ¥è¯¢ç‰¹å®šæ—¶é—´æ®µçš„æ—¥å¿—
2. **çº§åˆ«ç­›é€‰**: æŒ‰æ—¥å¿—çº§åˆ«ï¼ˆERRORã€WARNç­‰ï¼‰æŸ¥è¯¢
3. **æ¥æºç­›é€‰**: æŒ‰æ¥æºï¼ˆåº”ç”¨ã€æ¨¡å—ï¼‰æŸ¥è¯¢
4. **å…¨æ–‡æœç´¢**: åœ¨æ—¥å¿—æ¶ˆæ¯ä¸­æœç´¢å…³é”®è¯
5. **æ•°æ®é‡å¤§**: æ¯å¤©æ•°ç™¾ä¸‡æ¡æ—¥å¿—ï¼Œéœ€è¦åˆ†åŒº

**å®Œæ•´ç´¢å¼•è®¾è®¡æ–¹æ¡ˆ**:

```sql
-- 1. æ—¥å¿—è¡¨ç»“æ„ï¼ˆåˆ†åŒºè¡¨ï¼‰
CREATE TABLE log_entries (
    id BIGSERIAL,
    log_time TIMESTAMP NOT NULL,
    level VARCHAR(10) NOT NULL,
    source VARCHAR(100),
    module VARCHAR(50),
    message TEXT,
    metadata JSONB,
    created_at TIMESTAMP DEFAULT NOW()
) PARTITION BY RANGE (log_time);

-- æŒ‰æœˆåˆ›å»ºåˆ†åŒº
CREATE TABLE log_entries_2024_01 PARTITION OF log_entries
FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

-- 2. æ—¶é—´ç´¢å¼•ï¼ˆæ”¯æŒæ—¶é—´èŒƒå›´æŸ¥è¯¢ï¼‰
CREATE INDEX idx_log_time ON log_entries (log_time);
-- è‡ªåŠ¨åœ¨æ‰€æœ‰åˆ†åŒºä¸Šåˆ›å»º

-- 3. çº§åˆ«+æ—¶é—´å¤åˆç´¢å¼•ï¼ˆæ”¯æŒæŒ‰çº§åˆ«æŸ¥è¯¢ï¼‰
CREATE INDEX idx_log_level_time ON log_entries (level, log_time DESC);

-- 4. æ¥æº+æ—¶é—´ç´¢å¼•ï¼ˆæ”¯æŒæŒ‰æ¥æºæŸ¥è¯¢ï¼‰
CREATE INDEX idx_log_source_time ON log_entries (source, log_time DESC)
WHERE source IS NOT NULL;

-- 5. é”™è¯¯æ—¥å¿—ç´¢å¼•ï¼ˆéƒ¨åˆ†ç´¢å¼•ï¼Œåªç´¢å¼•ERRORçº§åˆ«ï¼‰
CREATE INDEX idx_log_errors ON log_entries (log_time DESC, source)
WHERE level = 'ERROR';

-- 6. å…¨æ–‡æœç´¢ç´¢å¼•ï¼ˆæ”¯æŒæ¶ˆæ¯æœç´¢ï¼‰
CREATE INDEX idx_log_message_gin ON log_entries USING GIN (to_tsvector('english', message));

-- 7. JSONBå…ƒæ•°æ®ç´¢å¼•ï¼ˆæ”¯æŒå…ƒæ•°æ®æŸ¥è¯¢ï¼‰
CREATE INDEX idx_log_metadata_gin ON log_entries USING GIN (metadata);

-- 8. æœ€è¿‘æ—¥å¿—ç´¢å¼•ï¼ˆéƒ¨åˆ†ç´¢å¼•ï¼Œåªç´¢å¼•æœ€è¿‘30å¤©ï¼‰
CREATE INDEX idx_log_recent ON log_entries (level, log_time DESC)
WHERE log_time >= CURRENT_DATE - interval '30 days';

-- 9. æŸ¥è¯¢æ€§èƒ½æµ‹è¯•
-- æŸ¥è¯¢1: æ—¶é—´èŒƒå›´æŸ¥è¯¢
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM log_entries
WHERE log_time >= '2024-01-15' AND log_time < '2024-01-16'
ORDER BY log_time DESC;
-- ä½¿ç”¨ç´¢å¼•ï¼šidx_log_timeï¼Œåˆ†åŒºè£å‰ª

-- æŸ¥è¯¢2: é”™è¯¯æ—¥å¿—æŸ¥è¯¢
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM log_entries
WHERE level = 'ERROR'
AND log_time >= CURRENT_DATE - interval '7 days'
ORDER BY log_time DESC;
-- ä½¿ç”¨ç´¢å¼•ï¼šidx_log_errorsï¼ˆéƒ¨åˆ†ç´¢å¼•ï¼‰

-- æŸ¥è¯¢3: æ¥æº+æ—¶é—´æŸ¥è¯¢
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM log_entries
WHERE source = 'payment-service'
AND log_time >= CURRENT_DATE - interval '1 day'
ORDER BY log_time DESC;
-- ä½¿ç”¨ç´¢å¼•ï¼šidx_log_source_time

-- æŸ¥è¯¢4: å…¨æ–‡æœç´¢
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM log_entries
WHERE to_tsvector('english', message) @@ to_tsquery('english', 'error & database')
AND log_time >= CURRENT_DATE - interval '7 days';
-- ä½¿ç”¨ç´¢å¼•ï¼šidx_log_message_gin

-- æŸ¥è¯¢5: JSONBå…ƒæ•°æ®æŸ¥è¯¢
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM log_entries
WHERE metadata @> '{"user_id": 12345}'::jsonb
AND log_time >= CURRENT_DATE - interval '1 day';
-- ä½¿ç”¨ç´¢å¼•ï¼šidx_log_metadata_gin
```

**ç´¢å¼•ç»´æŠ¤ç­–ç•¥**:

```sql
-- 1. å®šæœŸé‡å»ºæœ€è¿‘æ—¥å¿—ç´¢å¼•
DROP INDEX IF EXISTS idx_log_recent;
CREATE INDEX idx_log_recent ON log_entries (level, log_time DESC)
WHERE log_time >= CURRENT_DATE - interval '30 days';

-- 2. è‡ªåŠ¨æ¸…ç†æ—§åˆ†åŒºç´¢å¼•ï¼ˆå¦‚æœåˆ†åŒºè¢«åˆ é™¤ï¼‰
-- åˆ†åŒºåˆ é™¤æ—¶ï¼Œç´¢å¼•è‡ªåŠ¨åˆ é™¤

-- 3. ç›‘æ§ç´¢å¼•å¤§å°
SELECT
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexname::regclass)) as index_size
FROM pg_indexes
WHERE tablename LIKE 'log_entries_%'
ORDER BY pg_relation_size(indexname::regclass) DESC;

-- 4. åˆ†æç´¢å¼•ä½¿ç”¨æƒ…å†µ
SELECT
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    round(1.0 * idx_tup_read / NULLIF(idx_scan, 0), 2) as avg_tuples
FROM pg_stat_user_indexes
WHERE tablename LIKE 'log_entries_%'
ORDER BY idx_scan DESC;
```

## 10. ç›¸å…³æ¦‚å¿µ

### 10.1 ä¸Šä½æ¦‚å¿µ

- **æ•°æ®ç»“æ„**: æ›´å¹¿æ³›çš„æ•°æ®ç»„ç»‡æ–¹å¼
- **æŸ¥è¯¢ä¼˜åŒ–**: æŸ¥è¯¢æ€§èƒ½ä¼˜åŒ–
- **å­˜å‚¨ç®¡ç†**: æ•°æ®å­˜å‚¨æœºåˆ¶

### 10.2 ä¸‹ä½æ¦‚å¿µ

- **B+æ ‘**: å¹³è¡¡æ ‘ç»“æ„
- **å“ˆå¸Œè¡¨**: å“ˆå¸Œæ•°æ®ç»“æ„
- **ä½å›¾**: ä½å‘é‡ç»“æ„
- **å€’æ’ç´¢å¼•**: åå‘ç´¢å¼•ç»“æ„

### 10.3 å¹³è¡Œæ¦‚å¿µ

- **ç¼“å­˜**: å†…å­˜ç¼“å­˜æœºåˆ¶
- **åˆ†åŒº**: æ•°æ®åˆ†åŒºç­–ç•¥
- **å‹ç¼©**: æ•°æ®å‹ç¼©æŠ€æœ¯

## 11. ç›¸å…³æ–‡æ¡£

### 11.1 å®æˆ˜æ¡ˆä¾‹ä¸ç¤ºä¾‹

- [å¯è¿è¡Œç¤ºä¾‹é¡¹ç›®](../examples/README.md) â­ - 8ä¸ªå®Œæ•´çš„Docker Composeç¤ºä¾‹
- [å‘é‡æ•°æ®åº“æ”¯æŒ](../04-é«˜çº§ç‰¹æ€§/03.05-å‘é‡æ•°æ®åº“æ”¯æŒ.md) - å‘é‡ç´¢å¼•å®è·µ
- [ç´¢å¼•ç»“æ„ä¸ä¼˜åŒ–å®è·µ](../05-éƒ¨ç½²æ¶æ„/å•æœºéƒ¨ç½²/05.02-æ€§èƒ½è°ƒä¼˜å®è·µ.md) - ç´¢å¼•ä¼˜åŒ–æ¡ˆä¾‹

## 12. å‚è€ƒæ–‡çŒ®

1. Comer, D. (1979). The ubiquitous B-tree. ACM Computing Surveys, 11(2), 121-137.
2. PostgreSQL Global Development Group. (2025). PostgreSQL 18 Documentation. <https://www.postgresql.org/docs/18/>
3. Zobel, J., & Moffat, A. (2006). Inverted files for text search engines. ACM Computing Surveys, 38(2), 6.
4. Graefe, G. (2011). Modern B-tree techniques. Foundations and Trends in Databases, 3(4), 203-402.
5. PostgreSQL Global Development Group. (2024). PostgreSQL 17 Documentation. <https://www.postgresql.org/docs/17/>

## 13. Wikidataå¯¹é½

- **Wikidata ID**: Q192490
- **ç›¸å…³å±æ€§**:
  - P31: Q176165 (instance of: database management system)
  - P178: Q9366 (developer: PostgreSQL Global Development Group)
  - P277: Q193321 (programmed in: C)
  - P348: 18.0 (software version)
- **å¤–éƒ¨é“¾æ¥**:
  - <https://www.postgresql.org/docs/current/indexes.html>
  - <https://www.postgresql.org/docs/current/indexes-types.html>
