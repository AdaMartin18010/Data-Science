# ç´¢å¼•ç»“æ„ä¸ä¼˜åŒ–

> **æ–‡æ¡£ç‰ˆæœ¬**: v2.0
> **æœ€åæ›´æ–°**: 2025-11-12
> **ç‰ˆæœ¬è¦†ç›–**: PostgreSQL 18.x (æ¨è) â­ | 17.x (æ¨è) | 16.x (å…¼å®¹)
> **æ–‡æ¡£çŠ¶æ€**: âœ… å·²æ›´æ–°
> ğŸ†• **PostgreSQL 18ç´¢å¼•ä¼˜åŒ–**: B-treeå»é‡ä¼˜åŒ–ï¼ˆç´¢å¼•å¤§å°å‡å°‘18%ï¼‰ã€BRINæ€§èƒ½æå‡15-20%ã€æ›´é«˜æ•ˆçš„ç´¢å¼•ç»´æŠ¤ã€å¼‚æ­¥I/Oæå‡ç´¢å¼•æ„å»ºé€Ÿåº¦40%+

---

## ğŸ“‹ ç›®å½•

- [ç´¢å¼•ç»“æ„ä¸ä¼˜åŒ–](#ç´¢å¼•ç»“æ„ä¸ä¼˜åŒ–)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. å®šä¹‰ä¸å½¢å¼åŒ–](#1-å®šä¹‰ä¸å½¢å¼åŒ–)
    - [1.1 æ¦‚å¿µå®šä¹‰](#11-æ¦‚å¿µå®šä¹‰)
    - [1.2 å½¢å¼åŒ–å®šä¹‰](#12-å½¢å¼åŒ–å®šä¹‰)
    - [1.3 æ ¸å¿ƒå±æ€§](#13-æ ¸å¿ƒå±æ€§)
  - [2. ç†è®ºåŸºç¡€](#2-ç†è®ºåŸºç¡€)
    - [2.1 B+æ ‘ç†è®º](#21-bæ ‘ç†è®º)
    - [2.2 å“ˆå¸Œç´¢å¼•ç†è®º](#22-å“ˆå¸Œç´¢å¼•ç†è®º)
    - [2.3 ç´¢å¼•é€‰æ‹©ç†è®º](#23-ç´¢å¼•é€‰æ‹©ç†è®º)
  - [3. PostgreSQLç´¢å¼•ç±»å‹](#3-postgresqlç´¢å¼•ç±»å‹)
    - [3.1 B+æ ‘ç´¢å¼•](#31-bæ ‘ç´¢å¼•)
    - [3.2 å“ˆå¸Œç´¢å¼•](#32-å“ˆå¸Œç´¢å¼•)
    - [3.3 GiSTç´¢å¼•](#33-gistç´¢å¼•)
    - [3.4 GINç´¢å¼•](#34-ginç´¢å¼•)
  - [4. ç´¢å¼•ä¼˜åŒ–ç­–ç•¥](#4-ç´¢å¼•ä¼˜åŒ–ç­–ç•¥)
    - [4.1 å¤åˆç´¢å¼•è®¾è®¡](#41-å¤åˆç´¢å¼•è®¾è®¡)
    - [4.2 éƒ¨åˆ†ç´¢å¼•](#42-éƒ¨åˆ†ç´¢å¼•)
    - [4.3 è¡¨è¾¾å¼ç´¢å¼•](#43-è¡¨è¾¾å¼ç´¢å¼•)
    - [4.4 è¦†ç›–ç´¢å¼•](#44-è¦†ç›–ç´¢å¼•)
  - [5. ç´¢å¼•ç»´æŠ¤](#5-ç´¢å¼•ç»´æŠ¤)
    - [5.1 ç´¢å¼•é‡å»º](#51-ç´¢å¼•é‡å»º)
    - [5.2 ç´¢å¼•ç»Ÿè®¡ä¿¡æ¯](#52-ç´¢å¼•ç»Ÿè®¡ä¿¡æ¯)
    - [5.3 ç´¢å¼•ç›‘æ§](#53-ç´¢å¼•ç›‘æ§)
  - [6. ç´¢å¼•æ€§èƒ½åˆ†æ](#6-ç´¢å¼•æ€§èƒ½åˆ†æ)
    - [6.1 ç´¢å¼•é€‰æ‹©åˆ†æ](#61-ç´¢å¼•é€‰æ‹©åˆ†æ)
    - [6.2 ç´¢å¼•æ•ˆç‡åˆ†æ](#62-ç´¢å¼•æ•ˆç‡åˆ†æ)
    - [6.3 ç´¢å¼•å¤§å°åˆ†æ](#63-ç´¢å¼•å¤§å°åˆ†æ)
  - [7. é«˜çº§ç´¢å¼•æŠ€æœ¯](#7-é«˜çº§ç´¢å¼•æŠ€æœ¯)
    - [7.1 ä½å›¾ç´¢å¼•æ‰«æ](#71-ä½å›¾ç´¢å¼•æ‰«æ)
    - [7.2 ç´¢å¼•è·³è·ƒæ‰«æ](#72-ç´¢å¼•è·³è·ƒæ‰«æ)
    - [7.3 ç´¢å¼•åˆå¹¶](#73-ç´¢å¼•åˆå¹¶)
  - [8. ç´¢å¼•ä¼˜åŒ–å®è·µ](#8-ç´¢å¼•ä¼˜åŒ–å®è·µ)
    - [8.1 æŸ¥è¯¢ä¼˜åŒ–](#81-æŸ¥è¯¢ä¼˜åŒ–)
    - [8.2 æ‰¹é‡æ“ä½œä¼˜åŒ–](#82-æ‰¹é‡æ“ä½œä¼˜åŒ–)
    - [8.3 ç´¢å¼•ç»´æŠ¤ç­–ç•¥](#83-ç´¢å¼•ç»´æŠ¤ç­–ç•¥)
  - [9. å®é™…åº”ç”¨æ¡ˆä¾‹](#9-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [9.1 ç”µå•†ç³»ç»Ÿç´¢å¼•è®¾è®¡](#91-ç”µå•†ç³»ç»Ÿç´¢å¼•è®¾è®¡)
    - [9.2 æ—¥å¿—ç³»ç»Ÿç´¢å¼•è®¾è®¡](#92-æ—¥å¿—ç³»ç»Ÿç´¢å¼•è®¾è®¡)
  - [10. ç›¸å…³æ¦‚å¿µ](#10-ç›¸å…³æ¦‚å¿µ)
    - [10.1 ä¸Šä½æ¦‚å¿µ](#101-ä¸Šä½æ¦‚å¿µ)
    - [10.2 ä¸‹ä½æ¦‚å¿µ](#102-ä¸‹ä½æ¦‚å¿µ)
    - [10.3 å¹³è¡Œæ¦‚å¿µ](#103-å¹³è¡Œæ¦‚å¿µ)
  - [11. å‚è€ƒæ–‡çŒ®](#11-å‚è€ƒæ–‡çŒ®)
  - [12. Wikidataå¯¹é½](#12-wikidataå¯¹é½)

---

## 1. å®šä¹‰ä¸å½¢å¼åŒ–

### 1.1 æ¦‚å¿µå®šä¹‰

**ä¸­æ–‡å®šä¹‰**: ç´¢å¼•ç»“æ„æ˜¯æ•°æ®åº“ç³»ç»Ÿä¸­ç”¨äºåŠ é€Ÿæ•°æ®è®¿é—®çš„æ•°æ®ç»“æ„ï¼Œé€šè¿‡å»ºç«‹é”®å€¼åˆ°æ•°æ®ä½ç½®çš„æ˜ å°„å…³ç³»æé«˜æŸ¥è¯¢æ€§èƒ½ã€‚PostgreSQLæ”¯æŒå¤šç§ç´¢å¼•ç±»å‹ï¼ŒåŒ…æ‹¬B+æ ‘ã€å“ˆå¸Œã€GiSTã€GINç­‰ã€‚

**English Definition**: Index structures are data structures in database systems used to accelerate data access by establishing mapping relationships between keys and data locations to improve query performance. PostgreSQL supports multiple index types including B+tree, Hash, GiST, GIN, etc.

### 1.2 å½¢å¼åŒ–å®šä¹‰

```latex
% æ•°å­¦ç¬¦å·å®šä¹‰
\newcommand{\index}{\mathcal{I}}
\newcommand{\key}{\mathcal{K}}
\newcommand{\pointer}{\mathcal{P}}
\newcommand{\tuple}{\mathcal{T}}

% ç´¢å¼•çš„å½¢å¼åŒ–å®šä¹‰
\index = \{(k_1, p_1), (k_2, p_2), \ldots, (k_n, p_n)\}

å…¶ä¸­ï¼š
k_i \in \key: ç´¢å¼•é”®å€¼
p_i \in \pointer: æŒ‡å‘æ•°æ®çš„æŒ‡é’ˆ
\forall i \neq j: k_i \neq k_j \text{ (å”¯ä¸€æ€§çº¦æŸ)}
```

### 1.3 æ ¸å¿ƒå±æ€§

- **å¿«é€ŸæŸ¥æ‰¾**: O(log n) æ—¶é—´å¤æ‚åº¦
- **ç©ºé—´æ•ˆç‡**: åˆç†çš„å­˜å‚¨å¼€é”€
- **åŠ¨æ€æ›´æ–°**: æ”¯æŒæ’å…¥ã€åˆ é™¤ã€æ›´æ–°
- **å¹¶å‘å®‰å…¨**: æ”¯æŒå¹¶å‘è®¿é—®

## 2. ç†è®ºåŸºç¡€

### 2.1 B+æ ‘ç†è®º

```latex
\begin{theorem}[B+æ ‘æ€§è´¨]
B+æ ‘æ»¡è¶³ä»¥ä¸‹æ€§è´¨ï¼š
1. æ‰€æœ‰å¶å­èŠ‚ç‚¹åœ¨åŒä¸€å±‚
2. éå¶å­èŠ‚ç‚¹åªå­˜å‚¨é”®å€¼
3. å¶å­èŠ‚ç‚¹åŒ…å«æ‰€æœ‰æ•°æ®
4. æ”¯æŒèŒƒå›´æŸ¥è¯¢å’Œé¡ºåºè®¿é—®
5. æ ‘é«˜ä¸º O(\log n)
\end{theorem}

\begin{proof}
åŸºäºB+æ ‘çš„å¹³è¡¡æ€§è´¨å’ŒèŠ‚ç‚¹åˆ†è£‚åˆå¹¶è§„åˆ™ï¼Œå¯ä»¥è¯æ˜B+æ ‘çš„æ­£ç¡®æ€§ã€‚
\end{proof}
```

### 2.2 å“ˆå¸Œç´¢å¼•ç†è®º

```latex
\begin{theorem}[å“ˆå¸Œç´¢å¼•]
å“ˆå¸Œç´¢å¼•é€šè¿‡å“ˆå¸Œå‡½æ•°å®ç°ï¼š
1. å¹³å‡æŸ¥æ‰¾æ—¶é—´ï¼šO(1)
2. ä¸æ”¯æŒèŒƒå›´æŸ¥è¯¢
3. å“ˆå¸Œå†²çªå¤„ç†ï¼šé“¾å¼æ³•æˆ–å¼€æ”¾åœ°å€æ³•
4. è´Ÿè½½å› å­å½±å“æ€§èƒ½
\end{theorem}
```

### 2.3 ç´¢å¼•é€‰æ‹©ç†è®º

```latex
\begin{theorem}[ç´¢å¼•é€‰æ‹©æ€§]
ç´¢å¼•Iå¯¹æŸ¥è¯¢Qçš„é€‰æ‹©æ€§ä¸ºï¼š
\text{Selectivity}(I, Q) = \frac{|\sigma_p(R)|}{|R|}

å…¶ä¸­pæ˜¯Qçš„è°“è¯æ¡ä»¶ï¼Œé€‰æ‹©æ€§è¶Šé«˜ï¼Œç´¢å¼•æ•ˆæœè¶Šå¥½ã€‚
\end{theorem}
```

## 3. PostgreSQLç´¢å¼•ç±»å‹

### 3.1 B+æ ‘ç´¢å¼•

```sql
-- åˆ›å»ºB+æ ‘ç´¢å¼•
CREATE INDEX idx_emp_salary ON employees (salary);
CREATE INDEX idx_emp_dept_salary ON employees (dept_id, salary);

-- æŸ¥çœ‹ç´¢å¼•ä¿¡æ¯
SELECT
    indexname,
    indexdef,
    pg_size_pretty(pg_relation_size(indexname::regclass)) as size
FROM pg_indexes
WHERE tablename = 'employees';

-- ç´¢å¼•ä½¿ç”¨ç»Ÿè®¡
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE tablename = 'employees'
ORDER BY idx_scan DESC;
```

### 3.2 å“ˆå¸Œç´¢å¼•

```sql
-- åˆ›å»ºå“ˆå¸Œç´¢å¼•
CREATE INDEX idx_emp_id_hash ON employees USING HASH (emp_id);

-- å“ˆå¸Œç´¢å¼•ä½¿ç”¨
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE emp_id = 1001;
```

### 3.3 GiSTç´¢å¼•

```sql
-- åˆ›å»ºGiSTç´¢å¼•ï¼ˆå‡ ä½•æ•°æ®ï¼‰
CREATE TABLE spatial_data (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    location POINT
);

CREATE INDEX idx_spatial_location ON spatial_data USING GIST (location);

-- ç©ºé—´æŸ¥è¯¢
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM spatial_data
WHERE location <@ box '((0,0),(100,100))';
```

### 3.4 GINç´¢å¼•

```sql
-- åˆ›å»ºGINç´¢å¼•ï¼ˆæ•°ç»„æ•°æ®ï¼‰
CREATE TABLE documents (
    id SERIAL PRIMARY KEY,
    title VARCHAR(200),
    tags TEXT[]
);

CREATE INDEX idx_doc_tags ON documents USING GIN (tags);

-- æ•°ç»„æŸ¥è¯¢
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM documents WHERE tags @> ARRAY['postgresql', 'database'];
```

## 4. ç´¢å¼•ä¼˜åŒ–ç­–ç•¥

### 4.1 å¤åˆç´¢å¼•è®¾è®¡

```sql
-- å¤åˆç´¢å¼•è®¾è®¡åŸåˆ™
CREATE INDEX idx_emp_optimized ON employees (dept_id, salary, hire_date);

-- æœ€å·¦å‰ç¼€åŸåˆ™
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE dept_id = 1;  -- ä½¿ç”¨ç´¢å¼•

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE salary > 50000;  -- ä¸ä½¿ç”¨ç´¢å¼•

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE dept_id = 1 AND salary > 50000;  -- ä½¿ç”¨ç´¢å¼•
```

### 4.2 éƒ¨åˆ†ç´¢å¼•

```sql
-- åˆ›å»ºéƒ¨åˆ†ç´¢å¼•
CREATE INDEX idx_high_salary ON employees (salary) WHERE salary > 100000;

-- éƒ¨åˆ†ç´¢å¼•ä½¿ç”¨
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE salary > 150000;  -- ä½¿ç”¨ç´¢å¼•

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE salary < 50000;  -- ä¸ä½¿ç”¨ç´¢å¼•
```

### 4.3 è¡¨è¾¾å¼ç´¢å¼•

```sql
-- åˆ›å»ºè¡¨è¾¾å¼ç´¢å¼•
CREATE INDEX idx_name_lower ON employees (LOWER(name));
CREATE INDEX idx_salary_rounded ON employees ((salary::INTEGER));

-- è¡¨è¾¾å¼ç´¢å¼•ä½¿ç”¨
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE LOWER(name) = 'john doe';

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE (salary::INTEGER) = 50000;
```

### 4.4 è¦†ç›–ç´¢å¼•

```sql
-- åˆ›å»ºè¦†ç›–ç´¢å¼•
CREATE INDEX idx_emp_covering ON employees (dept_id) INCLUDE (name, salary);

-- è¦†ç›–ç´¢å¼•ä½¿ç”¨
EXPLAIN (ANALYZE, BUFFERS)
SELECT dept_id, name, salary FROM employees WHERE dept_id = 1;
```

## 5. ç´¢å¼•ç»´æŠ¤

### 5.1 ç´¢å¼•é‡å»º

```sql
-- é‡å»ºç´¢å¼•
REINDEX INDEX idx_emp_salary;
REINDEX TABLE employees;

-- å¹¶å‘é‡å»ºç´¢å¼•
REINDEX INDEX CONCURRENTLY idx_emp_salary;

-- æŸ¥çœ‹ç´¢å¼•è†¨èƒ€
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexname::regclass)) as index_size,
    pg_size_pretty(pg_relation_size(tablename::regclass)) as table_size
FROM pg_indexes
WHERE tablename = 'employees';
```

### 5.2 ç´¢å¼•ç»Ÿè®¡ä¿¡æ¯

```sql
-- æ›´æ–°ç´¢å¼•ç»Ÿè®¡ä¿¡æ¯
ANALYZE employees;

-- æŸ¥çœ‹ç´¢å¼•ç»Ÿè®¡
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch,
    idx_blks_read,
    idx_blks_hit
FROM pg_statio_user_indexes
WHERE tablename = 'employees';
```

### 5.3 ç´¢å¼•ç›‘æ§

```sql
-- ç›‘æ§ç´¢å¼•ä½¿ç”¨æƒ…å†µ
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch,
    CASE
        WHEN idx_scan = 0 THEN 'UNUSED'
        WHEN idx_tup_read / idx_scan > 1000 THEN 'INEFFICIENT'
        ELSE 'EFFICIENT'
    END as status
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
ORDER BY idx_scan DESC;
```

## 6. ç´¢å¼•æ€§èƒ½åˆ†æ

### 6.1 ç´¢å¼•é€‰æ‹©åˆ†æ

```sql
-- åˆ†æç´¢å¼•é€‰æ‹©
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT * FROM employees WHERE emp_id = 1001;

-- åˆ†æå¤åˆç´¢å¼•
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT * FROM employees WHERE dept_id = 1 AND salary > 50000;

-- åˆ†æèŒƒå›´æŸ¥è¯¢
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT * FROM employees WHERE salary BETWEEN 40000 AND 60000;
```

### 6.2 ç´¢å¼•æ•ˆç‡åˆ†æ

```sql
-- ç´¢å¼•æ•ˆç‡åˆ†æ
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch,
    round(100.0 * idx_blks_hit / (idx_blks_hit + idx_blks_read), 2) as hit_ratio
FROM pg_statio_user_indexes
WHERE idx_blks_hit + idx_blks_read > 0
ORDER BY hit_ratio ASC;
```

### 6.3 ç´¢å¼•å¤§å°åˆ†æ

```sql
-- ç´¢å¼•å¤§å°åˆ†æ
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexname::regclass)) as index_size,
    pg_size_pretty(pg_relation_size(tablename::regclass)) as table_size,
    round(100.0 * pg_relation_size(indexname::regclass) / pg_relation_size(tablename::regclass), 2) as size_ratio
FROM pg_indexes
WHERE schemaname = 'public'
ORDER BY pg_relation_size(indexname::regclass) DESC;
```

## 7. é«˜çº§ç´¢å¼•æŠ€æœ¯

### 7.1 ä½å›¾ç´¢å¼•æ‰«æ

```sql
-- ä½å›¾ç´¢å¼•æ‰«æ
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE dept_id = 1 AND salary > 50000;

-- ä½å›¾å †æ‰«æ
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE dept_id IN (1, 2, 3) AND salary > 50000;
```

### 7.2 ç´¢å¼•è·³è·ƒæ‰«æ

```sql
-- ç´¢å¼•è·³è·ƒæ‰«æ
CREATE INDEX idx_emp_skip ON employees (dept_id, salary, hire_date);

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE salary > 50000 ORDER BY dept_id, salary;
```

### 7.3 ç´¢å¼•åˆå¹¶

```sql
-- ç´¢å¼•åˆå¹¶
CREATE INDEX idx_emp_dept ON employees (dept_id);
CREATE INDEX idx_emp_salary ON employees (salary);

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE dept_id = 1 OR salary > 50000;
```

## 8. ç´¢å¼•ä¼˜åŒ–å®è·µ

### 8.1 æŸ¥è¯¢ä¼˜åŒ–

```sql
-- ä¼˜åŒ–å‰
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees
WHERE dept_id = 1 AND salary > 50000 AND hire_date > '2020-01-01';

-- åˆ›å»ºä¼˜åŒ–ç´¢å¼•
CREATE INDEX idx_emp_optimized ON employees (dept_id, salary, hire_date);

-- ä¼˜åŒ–å
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees
WHERE dept_id = 1 AND salary > 50000 AND hire_date > '2020-01-01';
```

### 8.2 æ‰¹é‡æ“ä½œä¼˜åŒ–

```sql
-- æ‰¹é‡æ’å…¥ä¼˜åŒ–
BEGIN;
-- ä¸´æ—¶ç¦ç”¨ç´¢å¼•
DROP INDEX CONCURRENTLY idx_emp_salary;
-- æ‰¹é‡æ’å…¥
INSERT INTO employees (name, dept_id, salary)
SELECT 'Employee' || generate_series(1, 100000),
       (random() * 10)::INTEGER + 1,
       (random() * 100000)::INTEGER + 30000;
-- é‡å»ºç´¢å¼•
CREATE INDEX CONCURRENTLY idx_emp_salary ON employees (salary);
COMMIT;
```

### 8.3 ç´¢å¼•ç»´æŠ¤ç­–ç•¥

```sql
-- è‡ªåŠ¨ç´¢å¼•ç»´æŠ¤
CREATE OR REPLACE FUNCTION maintain_indexes()
RETURNS void AS $$
DECLARE
    r RECORD;
BEGIN
    FOR r IN
        SELECT schemaname, tablename, indexname
        FROM pg_indexes
        WHERE schemaname = 'public'
    LOOP
        -- æ£€æŸ¥ç´¢å¼•ä½¿ç”¨æƒ…å†µ
        IF (SELECT idx_scan FROM pg_stat_user_indexes
            WHERE schemaname = r.schemaname
            AND tablename = r.tablename
            AND indexname = r.indexname) = 0 THEN

            RAISE NOTICE 'Unused index: %.%', r.tablename, r.indexname;
        END IF;
    END LOOP;
END;
$$ LANGUAGE plpgsql;
```

## 9. å®é™…åº”ç”¨æ¡ˆä¾‹

### 9.1 ç”µå•†ç³»ç»Ÿç´¢å¼•è®¾è®¡

```sql
-- å•†å“è¡¨ç´¢å¼•
CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    name VARCHAR(200),
    category_id INTEGER,
    price DECIMAL(10,2),
    stock_quantity INTEGER,
    created_at TIMESTAMP DEFAULT NOW()
);

-- å¤åˆç´¢å¼•
CREATE INDEX idx_products_category_price ON products (category_id, price);
CREATE INDEX idx_products_stock ON products (stock_quantity) WHERE stock_quantity > 0;

-- è®¢å•è¡¨ç´¢å¼•
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INTEGER,
    order_date TIMESTAMP DEFAULT NOW(),
    status VARCHAR(20),
    total_amount DECIMAL(10,2)
);

-- æ—¶é—´èŒƒå›´ç´¢å¼•
CREATE INDEX idx_orders_date_status ON orders (order_date, status);
CREATE INDEX idx_orders_customer ON orders (customer_id, order_date);
```

### 9.2 æ—¥å¿—ç³»ç»Ÿç´¢å¼•è®¾è®¡

```sql
-- æ—¥å¿—è¡¨ç´¢å¼•
CREATE TABLE log_entries (
    id BIGSERIAL PRIMARY KEY,
    log_time TIMESTAMP,
    level VARCHAR(10),
    source VARCHAR(100),
    message TEXT
);

-- æ—¶é—´åˆ†åŒºç´¢å¼•
CREATE INDEX idx_log_time ON log_entries (log_time);
CREATE INDEX idx_log_level_time ON log_entries (level, log_time);
CREATE INDEX idx_log_source_time ON log_entries (source, log_time);

-- å…¨æ–‡æœç´¢ç´¢å¼•
CREATE INDEX idx_log_message_gin ON log_entries USING GIN (to_tsvector('english', message));
```

## 10. ç›¸å…³æ¦‚å¿µ

### 10.1 ä¸Šä½æ¦‚å¿µ

- **æ•°æ®ç»“æ„**: æ›´å¹¿æ³›çš„æ•°æ®ç»„ç»‡æ–¹å¼
- **æŸ¥è¯¢ä¼˜åŒ–**: æŸ¥è¯¢æ€§èƒ½ä¼˜åŒ–
- **å­˜å‚¨ç®¡ç†**: æ•°æ®å­˜å‚¨æœºåˆ¶

### 10.2 ä¸‹ä½æ¦‚å¿µ

- **B+æ ‘**: å¹³è¡¡æ ‘ç»“æ„
- **å“ˆå¸Œè¡¨**: å“ˆå¸Œæ•°æ®ç»“æ„
- **ä½å›¾**: ä½å‘é‡ç»“æ„
- **å€’æ’ç´¢å¼•**: åå‘ç´¢å¼•ç»“æ„

### 10.3 å¹³è¡Œæ¦‚å¿µ

- **ç¼“å­˜**: å†…å­˜ç¼“å­˜æœºåˆ¶
- **åˆ†åŒº**: æ•°æ®åˆ†åŒºç­–ç•¥
- **å‹ç¼©**: æ•°æ®å‹ç¼©æŠ€æœ¯

## 11. ç›¸å…³æ–‡æ¡£

### 11.1 å®æˆ˜æ¡ˆä¾‹ä¸ç¤ºä¾‹

- [å¯è¿è¡Œç¤ºä¾‹é¡¹ç›®](../examples/README.md) â­ - 8ä¸ªå®Œæ•´çš„Docker Composeç¤ºä¾‹
- [å‘é‡æ•°æ®åº“æ”¯æŒ](../04-é«˜çº§ç‰¹æ€§/03.05-å‘é‡æ•°æ®åº“æ”¯æŒ.md) - å‘é‡ç´¢å¼•å®è·µ
- [ç´¢å¼•ç»“æ„ä¸ä¼˜åŒ–å®è·µ](../05-éƒ¨ç½²æ¶æ„/å•æœºéƒ¨ç½²/05.02-æ€§èƒ½è°ƒä¼˜å®è·µ.md) - ç´¢å¼•ä¼˜åŒ–æ¡ˆä¾‹

## 12. å‚è€ƒæ–‡çŒ®

1. Comer, D. (1979). The ubiquitous B-tree. ACM Computing Surveys, 11(2), 121-137.
2. PostgreSQL Global Development Group. (2025). PostgreSQL 18 Documentation. <https://www.postgresql.org/docs/18/>
3. Zobel, J., & Moffat, A. (2006). Inverted files for text search engines. ACM Computing Surveys, 38(2), 6.
4. Graefe, G. (2011). Modern B-tree techniques. Foundations and Trends in Databases, 3(4), 203-402.
5. PostgreSQL Global Development Group. (2024). PostgreSQL 17 Documentation. <https://www.postgresql.org/docs/17/>

## 13. Wikidataå¯¹é½

- **Wikidata ID**: Q192490
- **ç›¸å…³å±æ€§**:
  - P31: Q176165 (instance of: database management system)
  - P178: Q9366 (developer: PostgreSQL Global Development Group)
  - P277: Q193321 (programmed in: C)
  - P348: 18.0 (software version)
- **å¤–éƒ¨é“¾æ¥**:
  - <https://www.postgresql.org/docs/current/indexes.html>
  - <https://www.postgresql.org/docs/current/indexes-types.html>
