# 索引结构与优化

> **版本**: v3.1
> **最后更新**: 2025-11-22
> **版本覆盖**: PostgreSQL 18.x (推荐) ⭐ | 17.x (推荐) | 16.x (兼容)
> **难度**: ⭐⭐⭐⭐
> **应用场景**: 索引设计、查询优化、性能调优
> 🆕 **PostgreSQL 18索引优化**: B-tree去重优化（索引大小减少18%）、BRIN性能提升15-20%、更高效的索引维护、异步I/O提升索引构建速度40%+

---

## 📋 目录

- [索引结构与优化](#索引结构与优化)
  - [📋 目录](#-目录)
  - [1. 定义与形式化](#1-定义与形式化)
    - [1.1 概念定义](#11-概念定义)
    - [1.2 形式化定义](#12-形式化定义)
    - [1.3 核心属性](#13-核心属性)
  - [2. 理论基础](#2-理论基础)
    - [2.1 B+树理论](#21-b树理论)
    - [2.2 哈希索引理论](#22-哈希索引理论)
    - [2.3 索引选择理论](#23-索引选择理论)
  - [3. PostgreSQL索引类型](#3-postgresql索引类型)
    - [3.1 B+树索引](#31-b树索引)
    - [3.2 哈希索引](#32-哈希索引)
    - [3.3 GiST索引](#33-gist索引)
    - [3.4 GIN索引](#34-gin索引)
  - [4. 索引优化策略](#4-索引优化策略)
    - [4.1 复合索引设计](#41-复合索引设计)
      - [4.1.1 复合索引设计原则详解](#411-复合索引设计原则详解)
    - [4.2 部分索引](#42-部分索引)
      - [4.2.1 部分索引详解](#421-部分索引详解)
    - [4.3 表达式索引](#43-表达式索引)
      - [4.3.1 表达式索引详解](#431-表达式索引详解)
    - [4.4 覆盖索引](#44-覆盖索引)
      - [4.4.1 覆盖索引详解](#441-覆盖索引详解)
  - [5. 索引维护](#5-索引维护)
    - [5.1 索引重建](#51-索引重建)
    - [5.2 索引统计信息](#52-索引统计信息)
    - [5.3 索引监控](#53-索引监控)
      - [5.3.1 索引监控详解](#531-索引监控详解)
  - [6. 索引性能分析](#6-索引性能分析)
    - [6.1 索引选择分析](#61-索引选择分析)
    - [6.2 索引效率分析](#62-索引效率分析)
    - [6.3 索引大小分析](#63-索引大小分析)
  - [7. 高级索引技术](#7-高级索引技术)
    - [7.1 位图索引扫描](#71-位图索引扫描)
    - [7.2 索引跳跃扫描](#72-索引跳跃扫描)
    - [7.3 索引合并](#73-索引合并)
  - [8. 索引优化实践](#8-索引优化实践)
    - [8.1 查询优化](#81-查询优化)
    - [8.2 批量操作优化](#82-批量操作优化)
    - [8.3 索引维护策略](#83-索引维护策略)
  - [9. 实际应用案例](#9-实际应用案例)
    - [9.1 电商系统索引设计](#91-电商系统索引设计)
      - [9.1.1 电商系统索引设计完整方案](#911-电商系统索引设计完整方案)
    - [9.2 日志系统索引设计](#92-日志系统索引设计)
      - [9.2.1 日志系统索引设计完整方案](#921-日志系统索引设计完整方案)
  - [10. 相关概念](#10-相关概念)
    - [10.1 上位概念](#101-上位概念)
    - [10.2 下位概念](#102-下位概念)
    - [10.3 平行概念](#103-平行概念)
  - [11. 相关文档](#11-相关文档)
    - [11.1 实战案例与示例](#111-实战案例与示例)
  - [12. 参考文献](#12-参考文献)
  - [13. 交叉引用](#13-交叉引用)
    - [相关文档](#相关文档)
    - [外部资源](#外部资源)
  - [14. Wikidata对齐](#14-wikidata对齐)

---

## 1. 定义与形式化

### 1.1 概念定义

**中文定义**: 索引结构是数据库系统中用于加速数据访问的数据结构，通过建立键值到数据位置的映射关系提高查询性能。PostgreSQL支持多种索引类型，包括B+树、哈希、GiST、GIN等。

**English Definition**: Index structures are data structures in database systems used to accelerate data access by establishing mapping relationships between keys and data locations to improve query performance. PostgreSQL supports multiple index types including B+tree, Hash, GiST, GIN, etc.

### 1.2 形式化定义

```latex
% 数学符号定义
\newcommand{\index}{\mathcal{I}}
\newcommand{\key}{\mathcal{K}}
\newcommand{\pointer}{\mathcal{P}}
\newcommand{\tuple}{\mathcal{T}}

% 索引的形式化定义
\index = \{(k_1, p_1), (k_2, p_2), \ldots, (k_n, p_n)\}

其中：
k_i \in \key: 索引键值
p_i \in \pointer: 指向数据的指针
\forall i \neq j: k_i \neq k_j \text{ (唯一性约束)}
```

### 1.3 核心属性

- **快速查找**: O(log n) 时间复杂度
- **空间效率**: 合理的存储开销
- **动态更新**: 支持插入、删除、更新
- **并发安全**: 支持并发访问

## 2. 理论基础

### 2.1 B+树理论

```latex
\begin{theorem}[B+树性质]
B+树满足以下性质：
1. 所有叶子节点在同一层
2. 非叶子节点只存储键值
3. 叶子节点包含所有数据
4. 支持范围查询和顺序访问
5. 树高为 O(\log n)
\end{theorem}

\begin{proof}
基于B+树的平衡性质和节点分裂合并规则，可以证明B+树的正确性。
\end{proof}
```

### 2.2 哈希索引理论

```latex
\begin{theorem}[哈希索引]
哈希索引通过哈希函数实现：
1. 平均查找时间：O(1)
2. 不支持范围查询
3. 哈希冲突处理：链式法或开放地址法
4. 负载因子影响性能
\end{theorem}
```

### 2.3 索引选择理论

```latex
\begin{theorem}[索引选择性]
索引I对查询Q的选择性为：
\text{Selectivity}(I, Q) = \frac{|\sigma_p(R)|}{|R|}

其中p是Q的谓词条件，选择性越高，索引效果越好。
\end{theorem}
```

## 3. PostgreSQL索引类型

### 3.1 B+树索引

```sql
-- 创建B+树索引
CREATE INDEX idx_emp_salary ON employees (salary);
CREATE INDEX idx_emp_dept_salary ON employees (dept_id, salary);

-- 查看索引信息
SELECT
    indexname,
    indexdef,
    pg_size_pretty(pg_relation_size(indexname::regclass)) as size
FROM pg_indexes
WHERE tablename = 'employees';

-- 索引使用统计
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE tablename = 'employees'
ORDER BY idx_scan DESC;
```

### 3.2 哈希索引

```sql
-- 创建哈希索引
CREATE INDEX idx_emp_id_hash ON employees USING HASH (emp_id);

-- 哈希索引使用
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE emp_id = 1001;
```

### 3.3 GiST索引

```sql
-- 创建GiST索引（几何数据）
CREATE TABLE spatial_data (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    location POINT
);

CREATE INDEX idx_spatial_location ON spatial_data USING GIST (location);

-- 空间查询
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM spatial_data
WHERE location <@ box '((0,0),(100,100))';
```

### 3.4 GIN索引

```sql
-- 创建GIN索引（数组数据）
CREATE TABLE documents (
    id SERIAL PRIMARY KEY,
    title VARCHAR(200),
    tags TEXT[]
);

CREATE INDEX idx_doc_tags ON documents USING GIN (tags);

-- 数组查询
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM documents WHERE tags @> ARRAY['postgresql', 'database'];
```

## 4. 索引优化策略

### 4.1 复合索引设计

```sql
-- 复合索引设计原则
CREATE INDEX idx_emp_optimized ON employees (dept_id, salary, hire_date);

-- 最左前缀原则
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE dept_id = 1;  -- 使用索引

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE salary > 50000;  -- 不使用索引

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE dept_id = 1 AND salary > 50000;  -- 使用索引
```

#### 4.1.1 复合索引设计原则详解

**列顺序选择原则**:

1. **选择性原则**: 选择性高的列放在前面
   - 选择性 = 不同值数量 / 总行数
   - 选择性越高，过滤效果越好

```sql
-- 分析列选择性
SELECT
    attname,
    n_distinct,
    round(100.0 * n_distinct / NULLIF(n_live_tup, 0), 2) as selectivity_pct,
    correlation
FROM pg_stats
WHERE schemaname = 'public'
AND tablename = 'employees'
AND attname IN ('dept_id', 'salary', 'hire_date')
ORDER BY n_distinct DESC;

-- 根据选择性创建索引
-- dept_id选择性高（假设有100个部门），放在前面
-- salary选择性中等，放在中间
-- hire_date选择性低（日期范围），放在后面
CREATE INDEX idx_emp_dept_salary_date ON employees (dept_id, salary, hire_date);
```

2. **查询频率原则**: 经常一起查询的列组合在一起

```sql
-- 分析查询模式
SELECT
    schemaname,
    tablename,
    attname,
    n_distinct,
    most_common_vals,
    most_common_freqs
FROM pg_stats
WHERE schemaname = 'public'
AND tablename = 'employees';

-- 根据查询模式创建索引
-- 如果经常查询 dept_id + salary，创建复合索引
CREATE INDEX idx_emp_dept_salary ON employees (dept_id, salary);

-- 如果经常单独查询 dept_id，也可以单独创建索引
CREATE INDEX idx_emp_dept ON employees (dept_id);
```

3. **等值查询优先原则**: 等值查询的列放在范围查询列之前

```sql
-- 正确：等值列在前
CREATE INDEX idx_emp_dept_salary ON employees (dept_id, salary);
-- 查询：WHERE dept_id = 1 AND salary > 50000 ✓ 可以使用索引

-- 错误：范围列在前
CREATE INDEX idx_emp_salary_dept ON employees (salary, dept_id);
-- 查询：WHERE dept_id = 1 AND salary > 50000 ✗ 只能部分使用索引
```

**复合索引使用场景**:

```sql
-- 场景1: 多列等值查询
CREATE INDEX idx_orders_customer_status ON orders (customer_id, status);
-- 查询：WHERE customer_id = 100 AND status = 'pending'

-- 场景2: 等值 + 范围查询
CREATE INDEX idx_orders_customer_date ON orders (customer_id, order_date);
-- 查询：WHERE customer_id = 100 AND order_date >= '2024-01-01'

-- 场景3: 等值 + 排序
CREATE INDEX idx_orders_customer_date_desc ON orders (customer_id, order_date DESC);
-- 查询：WHERE customer_id = 100 ORDER BY order_date DESC

-- 场景4: 多列排序
CREATE INDEX idx_products_category_price ON products (category_id, price, created_at);
-- 查询：WHERE category_id = 1 ORDER BY price, created_at
```

**复合索引性能对比**:

```sql
-- 测试单列索引 vs 复合索引
-- 单列索引方案
CREATE INDEX idx_emp_dept ON employees (dept_id);
CREATE INDEX idx_emp_salary ON employees (salary);

-- 复合索引方案
CREATE INDEX idx_emp_dept_salary ON employees (dept_id, salary);

-- 查询1: 只使用dept_id
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE dept_id = 1;
-- 单列索引：Index Scan using idx_emp_dept
-- 复合索引：Index Scan using idx_emp_dept_salary（同样高效）

-- 查询2: 使用dept_id和salary
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE dept_id = 1 AND salary > 50000;
-- 单列索引：Bitmap Index Scan（需要合并两个索引）
-- 复合索引：Index Scan using idx_emp_dept_salary（更高效）

-- 查询3: 只使用salary
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE salary > 50000;
-- 单列索引：Index Scan using idx_emp_salary
-- 复合索引：Seq Scan（无法使用复合索引）
```

### 4.2 部分索引

```sql
-- 创建部分索引
CREATE INDEX idx_high_salary ON employees (salary) WHERE salary > 100000;

-- 部分索引使用
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE salary > 150000;  -- 使用索引

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE salary < 50000;  -- 不使用索引
```

#### 4.2.1 部分索引详解

**部分索引的优势**:

1. **减少索引大小**: 只索引满足条件的行
2. **提升维护性能**: 插入/更新不满足条件的行时不需要更新索引
3. **提高查询性能**: 索引更小，扫描更快

**使用场景**:

```sql
-- 场景1: 活跃数据索引（只索引未删除的记录）
CREATE INDEX idx_orders_active ON orders (customer_id, order_date)
WHERE status != 'deleted';
-- 查询活跃订单时使用索引，查询已删除订单时不使用索引

-- 场景2: 热点数据索引（只索引高频查询的数据）
CREATE INDEX idx_products_in_stock ON products (category_id, price)
WHERE stock_quantity > 0;
-- 只索引有库存的商品，减少索引大小

-- 场景3: 时间范围索引（只索引最近的数据）
CREATE INDEX idx_logs_recent ON log_entries (level, log_time)
WHERE log_time >= CURRENT_DATE - interval '30 days';
-- 只索引最近30天的日志，定期重建索引

-- 场景4: 状态索引（只索引特定状态）
CREATE INDEX idx_orders_pending ON orders (customer_id, created_at)
WHERE status = 'pending';
-- 只索引待处理订单，快速查询待处理订单
```

**部分索引性能对比**:

```sql
-- 全索引 vs 部分索引
-- 假设表有1000万行，但只有10万行满足条件

-- 全索引
CREATE INDEX idx_orders_full ON orders (customer_id, order_date);
-- 索引大小：~500MB，维护成本高

-- 部分索引
CREATE INDEX idx_orders_partial ON orders (customer_id, order_date)
WHERE status != 'deleted';
-- 索引大小：~50MB，维护成本低

-- 查询性能对比
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM orders WHERE customer_id = 100 AND status != 'deleted';
-- 全索引：Index Scan，扫描500MB索引
-- 部分索引：Index Scan，扫描50MB索引（10倍性能提升）

-- 插入性能对比
INSERT INTO orders (customer_id, order_date, status) VALUES (100, NOW(), 'deleted');
-- 全索引：需要更新索引
-- 部分索引：不需要更新索引（因为status='deleted'不满足条件）
```

**部分索引维护**:

```sql
-- 定期重建部分索引（如果条件范围变化）
-- 例如：时间范围索引需要定期更新
DROP INDEX IF EXISTS idx_logs_recent;
CREATE INDEX idx_logs_recent ON log_entries (level, log_time)
WHERE log_time >= CURRENT_DATE - interval '30 days';

-- 使用函数自动维护
CREATE OR REPLACE FUNCTION rebuild_recent_logs_index()
RETURNS void AS $$
BEGIN
    DROP INDEX IF EXISTS idx_logs_recent;
    EXECUTE format(
        'CREATE INDEX idx_logs_recent ON log_entries (level, log_time) '
        'WHERE log_time >= %L',
        CURRENT_DATE - interval '30 days'
    );
END;
$$ LANGUAGE plpgsql;

-- 通过cron定期执行
-- SELECT cron.schedule('rebuild-logs-index', '0 2 * * *', 'SELECT rebuild_recent_logs_index();');
```

### 4.3 表达式索引

```sql
-- 创建表达式索引
CREATE INDEX idx_name_lower ON employees (LOWER(name));
CREATE INDEX idx_salary_rounded ON employees ((salary::INTEGER));

-- 表达式索引使用
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE LOWER(name) = 'john doe';

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE (salary::INTEGER) = 50000;
```

#### 4.3.1 表达式索引详解

**表达式索引的使用场景**:

1. **函数调用**: 对列应用函数后查询

```sql
-- 场景1: 大小写不敏感查询
CREATE INDEX idx_users_email_lower ON users (LOWER(email));
-- 查询：WHERE LOWER(email) = 'user@example.com'

-- 场景2: 日期函数
CREATE INDEX idx_orders_year ON orders (EXTRACT(YEAR FROM order_date));
-- 查询：WHERE EXTRACT(YEAR FROM order_date) = 2024

-- 场景3: 字符串函数
CREATE INDEX idx_products_name_prefix ON products (LEFT(name, 10));
-- 查询：WHERE LEFT(name, 10) = 'Product A'
```

2. **类型转换**: 查询时进行类型转换

```sql
-- 场景1: 数值类型转换
CREATE INDEX idx_sales_amount_int ON sales ((amount::INTEGER));
-- 查询：WHERE (amount::INTEGER) = 1000

-- 场景2: 日期类型转换
CREATE INDEX idx_events_date_trunc ON events (DATE_TRUNC('day', event_time));
-- 查询：WHERE DATE_TRUNC('day', event_time) = '2024-01-01'
```

3. **JSON/JSONB字段**: 索引JSON字段的特定路径

```sql
-- 场景1: JSONB字段索引
CREATE INDEX idx_products_metadata_category ON products ((metadata->>'category'));
-- 查询：WHERE metadata->>'category' = 'electronics'

-- 场景2: JSONB数组索引
CREATE INDEX idx_documents_tags ON documents USING GIN ((tags::jsonb));
-- 查询：WHERE tags @> '["postgresql"]'::jsonb
```

**表达式索引的注意事项**:

```sql
-- 1. 查询必须完全匹配表达式
-- 索引：CREATE INDEX idx_name_lower ON employees (LOWER(name));
-- 可以使用：WHERE LOWER(name) = 'john'
-- 不能使用：WHERE name = 'John'（不匹配表达式）

-- 2. 表达式索引维护成本较高
-- 每次插入/更新都需要计算表达式
-- 对于复杂表达式，考虑使用函数索引

-- 3. 使用IMMUTABLE函数
-- 只有IMMUTABLE函数可以用于表达式索引
CREATE INDEX idx_products_created_month ON products (DATE_TRUNC('month', created_at));
-- DATE_TRUNC是IMMUTABLE函数

-- 4. 部分表达式索引
CREATE INDEX idx_high_salary_rounded ON employees ((salary::INTEGER))
WHERE (salary::INTEGER) > 100000;
-- 结合部分索引，减少索引大小
```

**表达式索引性能对比**:

```sql
-- 无索引：全表扫描
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE LOWER(name) = 'john doe';
-- Seq Scan，扫描所有行

-- 有表达式索引：索引扫描
CREATE INDEX idx_name_lower ON employees (LOWER(name));
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE LOWER(name) = 'john doe';
-- Index Scan using idx_name_lower（性能提升显著）

-- 维护成本对比
-- 插入100万行
INSERT INTO employees (name, salary)
SELECT 'Employee' || generate_series(1, 1000000), random() * 100000;
-- 无表达式索引：插入时间基准
-- 有表达式索引：插入时间增加10-20%（需要计算LOWER(name)）
```

### 4.4 覆盖索引

```sql
-- 创建覆盖索引
CREATE INDEX idx_emp_covering ON employees (dept_id) INCLUDE (name, salary);

-- 覆盖索引使用
EXPLAIN (ANALYZE, BUFFERS)
SELECT dept_id, name, salary FROM employees WHERE dept_id = 1;
```

#### 4.4.1 覆盖索引详解

**覆盖索引原理**:

覆盖索引（Covering Index）包含查询所需的所有列，查询可以直接从索引获取数据，无需回表访问堆表，大幅提升查询性能。

**INCLUDE列的使用**:

```sql
-- PostgreSQL 11+支持INCLUDE列
-- INCLUDE列不参与索引排序，但存储在索引中
CREATE INDEX idx_orders_covering ON orders (customer_id, order_date)
INCLUDE (status, total_amount);

-- 查询可以直接从索引获取所有数据
EXPLAIN (ANALYZE, BUFFERS)
SELECT customer_id, order_date, status, total_amount
FROM orders
WHERE customer_id = 100 AND order_date >= '2024-01-01';
-- Index Only Scan（不需要访问堆表）
```

**覆盖索引 vs 普通索引**:

```sql
-- 普通索引
CREATE INDEX idx_orders_customer_date ON orders (customer_id, order_date);

-- 查询需要回表
EXPLAIN (ANALYZE, BUFFERS)
SELECT customer_id, order_date, status, total_amount
FROM orders
WHERE customer_id = 100;
-- Index Scan -> Heap Fetch（需要访问堆表获取status和total_amount）

-- 覆盖索引
CREATE INDEX idx_orders_covering ON orders (customer_id, order_date)
INCLUDE (status, total_amount);

-- 查询不需要回表
EXPLAIN (ANALYZE, BUFFERS)
SELECT customer_id, order_date, status, total_amount
FROM orders
WHERE customer_id = 100;
-- Index Only Scan（直接从索引获取所有数据）

-- 性能对比
-- 普通索引：1000次索引扫描 + 1000次堆表访问
-- 覆盖索引：1000次索引扫描（无堆表访问）
-- 性能提升：2-3倍（取决于堆表访问成本）
```

**覆盖索引设计原则**:

```sql
-- 1. 分析查询模式
-- 识别经常一起查询的列组合
SELECT
    schemaname,
    tablename,
    attname,
    n_distinct
FROM pg_stats
WHERE schemaname = 'public'
AND tablename = 'orders';

-- 2. 创建覆盖索引
-- 将WHERE子句的列放在索引键中
-- 将SELECT子句的其他列放在INCLUDE中
CREATE INDEX idx_orders_covering ON orders (customer_id, order_date)
INCLUDE (status, total_amount, shipping_address);

-- 3. 避免过度使用INCLUDE
-- INCLUDE列会增加索引大小
-- 只包含经常查询的列
CREATE INDEX idx_orders_minimal ON orders (customer_id)
INCLUDE (order_date, status);  -- 只包含必要列

-- 4. 结合部分索引
CREATE INDEX idx_orders_active_covering ON orders (customer_id, order_date)
INCLUDE (status, total_amount)
WHERE status != 'cancelled';
-- 只索引活跃订单，减少索引大小
```

**覆盖索引使用场景**:

```sql
-- 场景1: 报表查询（只查询特定列）
CREATE INDEX idx_sales_covering ON sales (sale_date, region)
INCLUDE (product_id, quantity, amount);
-- 查询：SELECT sale_date, region, product_id, quantity, amount FROM sales WHERE ...

-- 场景2: API查询（返回固定字段）
CREATE INDEX idx_users_api_covering ON users (user_id)
INCLUDE (name, email, created_at, status);
-- 查询：SELECT user_id, name, email, created_at, status FROM users WHERE user_id = ?

-- 场景3: 聚合查询（预计算列）
CREATE INDEX idx_orders_stats_covering ON orders (customer_id, order_date)
INCLUDE (total_amount);
-- 查询：SELECT customer_id, SUM(total_amount) FROM orders WHERE ... GROUP BY customer_id
```

**覆盖索引性能监控**:

```sql
-- 检查索引使用情况
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE indexname LIKE '%covering%';

-- 检查Index Only Scan使用情况
EXPLAIN (ANALYZE, BUFFERS)
SELECT customer_id, order_date, status, total_amount
FROM orders
WHERE customer_id = 100;
-- 查看是否使用Index Only Scan

-- 监控索引大小
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexname::regclass)) as index_size,
    pg_size_pretty(pg_relation_size(tablename::regclass)) as table_size
FROM pg_indexes
WHERE indexname LIKE '%covering%';
```

## 5. 索引维护

### 5.1 索引重建

```sql
-- 重建索引
REINDEX INDEX idx_emp_salary;
REINDEX TABLE employees;

-- 并发重建索引
REINDEX INDEX CONCURRENTLY idx_emp_salary;

-- 查看索引膨胀
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexname::regclass)) as index_size,
    pg_size_pretty(pg_relation_size(tablename::regclass)) as table_size
FROM pg_indexes
WHERE tablename = 'employees';
```

### 5.2 索引统计信息

```sql
-- 更新索引统计信息
ANALYZE employees;

-- 查看索引统计
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch,
    idx_blks_read,
    idx_blks_hit
FROM pg_statio_user_indexes
WHERE tablename = 'employees';
```

### 5.3 索引监控

```sql
-- 监控索引使用情况
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch,
    CASE
        WHEN idx_scan = 0 THEN 'UNUSED'
        WHEN idx_tup_read / idx_scan > 1000 THEN 'INEFFICIENT'
        ELSE 'EFFICIENT'
    END as status
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
ORDER BY idx_scan DESC;
```

#### 5.3.1 索引监控详解

**索引使用情况监控**:

```sql
-- 1. 识别未使用的索引
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexname::regclass)) as index_size,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE idx_scan = 0
AND pg_relation_size(indexname::regclass) > 1000000  -- 大于1MB
ORDER BY pg_relation_size(indexname::regclass) DESC;

-- 2. 识别低效索引
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    round(1.0 * idx_tup_read / NULLIF(idx_scan, 0), 2) as avg_tuples_per_scan,
    CASE
        WHEN idx_scan = 0 THEN 'UNUSED'
        WHEN idx_tup_read / NULLIF(idx_scan, 0) > 10000 THEN 'INEFFICIENT'
        ELSE 'EFFICIENT'
    END as efficiency
FROM pg_stat_user_indexes
WHERE idx_scan > 0
ORDER BY idx_tup_read / NULLIF(idx_scan, 0) DESC;

-- 3. 索引命中率监控
SELECT
    schemaname,
    tablename,
    indexname,
    idx_blks_hit,
    idx_blks_read,
    round(100.0 * idx_blks_hit / NULLIF(idx_blks_hit + idx_blks_read, 0), 2) as hit_ratio
FROM pg_statio_user_indexes
WHERE idx_blks_hit + idx_blks_read > 0
ORDER BY hit_ratio ASC;
```

**索引膨胀监控**:

```sql
-- 1. 检查索引膨胀
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexname::regclass)) as index_size,
    pg_size_pretty(pg_relation_size(tablename::regclass)) as table_size,
    round(100.0 * pg_relation_size(indexname::regclass) /
          NULLIF(pg_relation_size(tablename::regclass), 0), 2) as size_ratio
FROM pg_indexes
WHERE schemaname = 'public'
ORDER BY pg_relation_size(indexname::regclass) DESC;

-- 2. 使用pgstattuple扩展检查索引膨胀（需要安装扩展）
CREATE EXTENSION IF NOT EXISTS pgstattuple;
SELECT * FROM pgstatindex('idx_emp_salary');
-- 返回索引统计信息，包括膨胀率

-- 3. 识别需要重建的索引
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexname::regclass)) as index_size,
    idx_scan,
    last_vacuum,
    last_autovacuum
FROM pg_stat_user_indexes
WHERE pg_relation_size(indexname::regclass) > 100000000  -- 大于100MB
AND (last_vacuum IS NULL OR last_vacuum < NOW() - interval '7 days')
ORDER BY pg_relation_size(indexname::regclass) DESC;
```

**索引维护自动化**:

```sql
-- 自动索引维护函数
CREATE OR REPLACE FUNCTION maintain_indexes(
    min_size_mb integer DEFAULT 100,
    unused_days integer DEFAULT 30
)
RETURNS TABLE(
    action text,
    schemaname text,
    tablename text,
    indexname text,
    reason text
) AS $$
DECLARE
    r RECORD;
BEGIN
    -- 1. 识别未使用的索引
    FOR r IN
        SELECT
            i.schemaname,
            i.tablename,
            i.indexname,
            pg_relation_size(i.indexname::regclass) as index_size,
            s.idx_scan,
            s.last_vacuum,
            s.last_autovacuum
        FROM pg_indexes i
        LEFT JOIN pg_stat_user_indexes s
            ON s.schemaname = i.schemaname
            AND s.tablename = i.tablename
            AND s.indexname = i.indexname
        WHERE i.schemaname = 'public'
        AND pg_relation_size(i.indexname::regclass) > min_size_mb * 1024 * 1024
    LOOP
        -- 检查是否未使用
        IF r.idx_scan = 0 OR r.idx_scan IS NULL THEN
            RETURN QUERY SELECT
                'DROP'::text,
                r.schemaname,
                r.tablename,
                r.indexname,
                format('Unused index, size: %s', pg_size_pretty(r.index_size))::text;
        END IF;

        -- 检查是否需要重建
        IF (r.last_vacuum IS NULL AND r.last_autovacuum IS NULL)
           OR (r.last_vacuum < NOW() - (unused_days || ' days')::interval
               AND r.last_autovacuum < NOW() - (unused_days || ' days')::interval) THEN
            RETURN QUERY SELECT
                'REINDEX'::text,
                r.schemaname,
                r.tablename,
                r.indexname,
                format('Index not vacuumed in %s days', unused_days)::text;
        END IF;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- 使用示例
SELECT * FROM maintain_indexes(100, 30);
-- 返回需要维护的索引列表
```

## 6. 索引性能分析

### 6.1 索引选择分析

```sql
-- 分析索引选择
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT * FROM employees WHERE emp_id = 1001;

-- 分析复合索引
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT * FROM employees WHERE dept_id = 1 AND salary > 50000;

-- 分析范围查询
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT * FROM employees WHERE salary BETWEEN 40000 AND 60000;
```

### 6.2 索引效率分析

```sql
-- 索引效率分析
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch,
    round(100.0 * idx_blks_hit / (idx_blks_hit + idx_blks_read), 2) as hit_ratio
FROM pg_statio_user_indexes
WHERE idx_blks_hit + idx_blks_read > 0
ORDER BY hit_ratio ASC;
```

### 6.3 索引大小分析

```sql
-- 索引大小分析
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexname::regclass)) as index_size,
    pg_size_pretty(pg_relation_size(tablename::regclass)) as table_size,
    round(100.0 * pg_relation_size(indexname::regclass) / pg_relation_size(tablename::regclass), 2) as size_ratio
FROM pg_indexes
WHERE schemaname = 'public'
ORDER BY pg_relation_size(indexname::regclass) DESC;
```

## 7. 高级索引技术

### 7.1 位图索引扫描

```sql
-- 位图索引扫描
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE dept_id = 1 AND salary > 50000;

-- 位图堆扫描
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE dept_id IN (1, 2, 3) AND salary > 50000;
```

### 7.2 索引跳跃扫描

```sql
-- 索引跳跃扫描
CREATE INDEX idx_emp_skip ON employees (dept_id, salary, hire_date);

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE salary > 50000 ORDER BY dept_id, salary;
```

### 7.3 索引合并

```sql
-- 索引合并
CREATE INDEX idx_emp_dept ON employees (dept_id);
CREATE INDEX idx_emp_salary ON employees (salary);

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE dept_id = 1 OR salary > 50000;
```

## 8. 索引优化实践

### 8.1 查询优化

```sql
-- 优化前
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees
WHERE dept_id = 1 AND salary > 50000 AND hire_date > '2020-01-01';

-- 创建优化索引
CREATE INDEX idx_emp_optimized ON employees (dept_id, salary, hire_date);

-- 优化后
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees
WHERE dept_id = 1 AND salary > 50000 AND hire_date > '2020-01-01';
```

### 8.2 批量操作优化

```sql
-- 批量插入优化
BEGIN;
-- 临时禁用索引
DROP INDEX CONCURRENTLY idx_emp_salary;
-- 批量插入
INSERT INTO employees (name, dept_id, salary)
SELECT 'Employee' || generate_series(1, 100000),
       (random() * 10)::INTEGER + 1,
       (random() * 100000)::INTEGER + 30000;
-- 重建索引
CREATE INDEX CONCURRENTLY idx_emp_salary ON employees (salary);
COMMIT;
```

### 8.3 索引维护策略

```sql
-- 自动索引维护
CREATE OR REPLACE FUNCTION maintain_indexes()
RETURNS void AS $$
DECLARE
    r RECORD;
BEGIN
    FOR r IN
        SELECT schemaname, tablename, indexname
        FROM pg_indexes
        WHERE schemaname = 'public'
    LOOP
        -- 检查索引使用情况
        IF (SELECT idx_scan FROM pg_stat_user_indexes
            WHERE schemaname = r.schemaname
            AND tablename = r.tablename
            AND indexname = r.indexname) = 0 THEN

            RAISE NOTICE 'Unused index: %.%', r.tablename, r.indexname;
        END IF;
    END LOOP;
END;
$$ LANGUAGE plpgsql;
```

## 9. 实际应用案例

### 9.1 电商系统索引设计

```sql
-- 商品表索引
CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    name VARCHAR(200),
    category_id INTEGER,
    price DECIMAL(10,2),
    stock_quantity INTEGER,
    created_at TIMESTAMP DEFAULT NOW()
);

-- 复合索引
CREATE INDEX idx_products_category_price ON products (category_id, price);
CREATE INDEX idx_products_stock ON products (stock_quantity) WHERE stock_quantity > 0;

-- 订单表索引
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INTEGER,
    order_date TIMESTAMP DEFAULT NOW(),
    status VARCHAR(20),
    total_amount DECIMAL(10,2)
);

-- 时间范围索引
CREATE INDEX idx_orders_date_status ON orders (order_date, status);
CREATE INDEX idx_orders_customer ON orders (customer_id, order_date);
```

#### 9.1.1 电商系统索引设计完整方案

**业务场景分析**:

1. **商品查询**: 按分类、价格范围、库存状态查询
2. **订单查询**: 按客户、时间范围、状态查询
3. **搜索功能**: 商品名称全文搜索
4. **报表查询**: 按时间、分类聚合统计

**完整索引设计方案**:

```sql
-- 1. 商品表索引设计
CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    category_id INTEGER NOT NULL,
    brand_id INTEGER,
    price DECIMAL(10,2) NOT NULL,
    stock_quantity INTEGER DEFAULT 0,
    status VARCHAR(20) DEFAULT 'active',
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 主键索引（自动创建）
-- PRIMARY KEY (product_id)

-- 分类+价格复合索引（支持分类浏览和价格排序）
CREATE INDEX idx_products_category_price ON products (category_id, price);

-- 品牌+价格索引（支持品牌筛选）
CREATE INDEX idx_products_brand_price ON products (brand_id, price)
WHERE brand_id IS NOT NULL;

-- 有库存商品索引（部分索引，只索引有库存的商品）
CREATE INDEX idx_products_in_stock ON products (category_id, price)
WHERE stock_quantity > 0 AND status = 'active';

-- 商品名称全文搜索索引
CREATE INDEX idx_products_name_gin ON products USING GIN (to_tsvector('english', name));

-- 更新时间索引（支持最近更新商品查询）
CREATE INDEX idx_products_updated ON products (updated_at DESC)
WHERE status = 'active';

-- 2. 订单表索引设计
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INTEGER NOT NULL,
    order_date TIMESTAMP NOT NULL DEFAULT NOW(),
    status VARCHAR(20) NOT NULL DEFAULT 'pending',
    total_amount DECIMAL(10,2) NOT NULL,
    shipping_address TEXT,
    created_at TIMESTAMP DEFAULT NOW()
);

-- 客户+时间索引（支持客户订单历史查询）
CREATE INDEX idx_orders_customer_date ON orders (customer_id, order_date DESC);

-- 状态+时间索引（支持按状态查询订单）
CREATE INDEX idx_orders_status_date ON orders (status, order_date DESC);

-- 待处理订单索引（部分索引，只索引待处理订单）
CREATE INDEX idx_orders_pending ON orders (order_date)
WHERE status IN ('pending', 'processing');

-- 覆盖索引（支持订单列表查询，包含常用字段）
CREATE INDEX idx_orders_covering ON orders (customer_id, order_date)
INCLUDE (status, total_amount);

-- 3. 订单项表索引设计
CREATE TABLE order_items (
    item_id SERIAL PRIMARY KEY,
    order_id INTEGER NOT NULL REFERENCES orders(order_id),
    product_id INTEGER NOT NULL REFERENCES products(product_id),
    quantity INTEGER NOT NULL,
    price DECIMAL(10,2) NOT NULL
);

-- 订单+产品索引（支持订单详情查询）
CREATE INDEX idx_order_items_order ON order_items (order_id, product_id);

-- 产品索引（支持产品销售统计）
CREATE INDEX idx_order_items_product ON order_items (product_id, order_id);

-- 4. 查询性能测试
-- 查询1: 按分类和价格范围查询商品
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM products
WHERE category_id = 1 AND price BETWEEN 100 AND 500
ORDER BY price;
-- 使用索引：idx_products_category_price

-- 查询2: 客户订单历史
EXPLAIN (ANALYZE, BUFFERS)
SELECT order_id, order_date, status, total_amount
FROM orders
WHERE customer_id = 100
ORDER BY order_date DESC
LIMIT 20;
-- 使用索引：idx_orders_customer_date（覆盖索引）

-- 查询3: 待处理订单
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM orders
WHERE status = 'pending'
ORDER BY order_date;
-- 使用索引：idx_orders_pending（部分索引）

-- 查询4: 商品名称搜索
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM products
WHERE to_tsvector('english', name) @@ to_tsquery('english', 'laptop');
-- 使用索引：idx_products_name_gin（GIN索引）
```

**索引维护策略**:

```sql
-- 1. 定期重建部分索引（时间范围变化）
DROP INDEX IF EXISTS idx_products_updated;
CREATE INDEX idx_products_updated ON products (updated_at DESC)
WHERE status = 'active' AND updated_at >= CURRENT_DATE - interval '30 days';

-- 2. 监控索引使用情况
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    pg_size_pretty(pg_relation_size(indexname::regclass)) as index_size
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
AND tablename IN ('products', 'orders', 'order_items')
ORDER BY idx_scan DESC;

-- 3. 识别未使用的索引
SELECT
    indexname,
    pg_size_pretty(pg_relation_size(indexname::regclass)) as index_size
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
AND idx_scan = 0
AND pg_relation_size(indexname::regclass) > 10000000;  -- 大于10MB
```

### 9.2 日志系统索引设计

```sql
-- 日志表索引
CREATE TABLE log_entries (
    id BIGSERIAL PRIMARY KEY,
    log_time TIMESTAMP,
    level VARCHAR(10),
    source VARCHAR(100),
    message TEXT
);

-- 时间分区索引
CREATE INDEX idx_log_time ON log_entries (log_time);
CREATE INDEX idx_log_level_time ON log_entries (level, log_time);
CREATE INDEX idx_log_source_time ON log_entries (source, log_time);

-- 全文搜索索引
CREATE INDEX idx_log_message_gin ON log_entries USING GIN (to_tsvector('english', message));
```

#### 9.2.1 日志系统索引设计完整方案

**业务场景分析**:

1. **时间范围查询**: 查询特定时间段的日志
2. **级别筛选**: 按日志级别（ERROR、WARN等）查询
3. **来源筛选**: 按来源（应用、模块）查询
4. **全文搜索**: 在日志消息中搜索关键词
5. **数据量大**: 每天数百万条日志，需要分区

**完整索引设计方案**:

```sql
-- 1. 日志表结构（分区表）
CREATE TABLE log_entries (
    id BIGSERIAL,
    log_time TIMESTAMP NOT NULL,
    level VARCHAR(10) NOT NULL,
    source VARCHAR(100),
    module VARCHAR(50),
    message TEXT,
    metadata JSONB,
    created_at TIMESTAMP DEFAULT NOW()
) PARTITION BY RANGE (log_time);

-- 按月创建分区
CREATE TABLE log_entries_2024_01 PARTITION OF log_entries
FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

-- 2. 时间索引（支持时间范围查询）
CREATE INDEX idx_log_time ON log_entries (log_time);
-- 自动在所有分区上创建

-- 3. 级别+时间复合索引（支持按级别查询）
CREATE INDEX idx_log_level_time ON log_entries (level, log_time DESC);

-- 4. 来源+时间索引（支持按来源查询）
CREATE INDEX idx_log_source_time ON log_entries (source, log_time DESC)
WHERE source IS NOT NULL;

-- 5. 错误日志索引（部分索引，只索引ERROR级别）
CREATE INDEX idx_log_errors ON log_entries (log_time DESC, source)
WHERE level = 'ERROR';

-- 6. 全文搜索索引（支持消息搜索）
CREATE INDEX idx_log_message_gin ON log_entries USING GIN (to_tsvector('english', message));

-- 7. JSONB元数据索引（支持元数据查询）
CREATE INDEX idx_log_metadata_gin ON log_entries USING GIN (metadata);

-- 8. 最近日志索引（部分索引，只索引最近30天）
CREATE INDEX idx_log_recent ON log_entries (level, log_time DESC)
WHERE log_time >= CURRENT_DATE - interval '30 days';

-- 9. 查询性能测试
-- 查询1: 时间范围查询
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM log_entries
WHERE log_time >= '2024-01-15' AND log_time < '2024-01-16'
ORDER BY log_time DESC;
-- 使用索引：idx_log_time，分区裁剪

-- 查询2: 错误日志查询
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM log_entries
WHERE level = 'ERROR'
AND log_time >= CURRENT_DATE - interval '7 days'
ORDER BY log_time DESC;
-- 使用索引：idx_log_errors（部分索引）

-- 查询3: 来源+时间查询
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM log_entries
WHERE source = 'payment-service'
AND log_time >= CURRENT_DATE - interval '1 day'
ORDER BY log_time DESC;
-- 使用索引：idx_log_source_time

-- 查询4: 全文搜索
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM log_entries
WHERE to_tsvector('english', message) @@ to_tsquery('english', 'error & database')
AND log_time >= CURRENT_DATE - interval '7 days';
-- 使用索引：idx_log_message_gin

-- 查询5: JSONB元数据查询
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM log_entries
WHERE metadata @> '{"user_id": 12345}'::jsonb
AND log_time >= CURRENT_DATE - interval '1 day';
-- 使用索引：idx_log_metadata_gin
```

**索引维护策略**:

```sql
-- 1. 定期重建最近日志索引
DROP INDEX IF EXISTS idx_log_recent;
CREATE INDEX idx_log_recent ON log_entries (level, log_time DESC)
WHERE log_time >= CURRENT_DATE - interval '30 days';

-- 2. 自动清理旧分区索引（如果分区被删除）
-- 分区删除时，索引自动删除

-- 3. 监控索引大小
SELECT
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexname::regclass)) as index_size
FROM pg_indexes
WHERE tablename LIKE 'log_entries_%'
ORDER BY pg_relation_size(indexname::regclass) DESC;

-- 4. 分析索引使用情况
SELECT
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    round(1.0 * idx_tup_read / NULLIF(idx_scan, 0), 2) as avg_tuples
FROM pg_stat_user_indexes
WHERE tablename LIKE 'log_entries_%'
ORDER BY idx_scan DESC;
```

## 10. 相关概念

### 10.1 上位概念

- **数据结构**: 更广泛的数据组织方式
- **查询优化**: 查询性能优化
- **存储管理**: 数据存储机制

### 10.2 下位概念

- **B+树**: 平衡树结构
- **哈希表**: 哈希数据结构
- **位图**: 位向量结构
- **倒排索引**: 反向索引结构

### 10.3 平行概念

- **缓存**: 内存缓存机制
- **分区**: 数据分区策略
- **压缩**: 数据压缩技术

## 11. 相关文档

### 11.1 实战案例与示例

- [可运行示例项目](../examples/README.md) ⭐ - 8个完整的Docker Compose示例
- [向量数据库支持](../04-高级特性/03.05-向量数据库支持.md) - 向量索引实践
- [索引结构与优化实践](../05-部署架构/单机部署/05.02-性能调优实践.md) - 索引优化案例

## 12. 参考文献

1. Comer, D. (1979). The ubiquitous B-tree. ACM Computing Surveys, 11(2), 121-137.
2. PostgreSQL Global Development Group. (2025). PostgreSQL 18 Documentation. <https://www.postgresql.org/docs/18/>
3. Zobel, J., & Moffat, A. (2006). Inverted files for text search engines. ACM Computing Surveys, 38(2), 6.
4. Graefe, G. (2011). Modern B-tree techniques. Foundations and Trends in Databases, 3(4), 203-402.
5. PostgreSQL Global Development Group. (2024). PostgreSQL 17 Documentation. <https://www.postgresql.org/docs/17/>

## 13. 交叉引用

### 相关文档

- ⭐⭐⭐ [查询优化器原理](./02.01-查询优化器原理.md) - 查询优化理论基础
- ⭐⭐⭐ [执行计划与性能调优](./02.04-执行计划与性能调优.md) - 执行计划分析实践
- ⭐⭐ [统计信息与代价模型](./02.03-统计信息与代价模型.md) - 统计信息对索引选择的影响
- ⭐⭐ [数据建模完整指南](../../09-应用设计/数据模型设计/09.02-数据建模完整指南.md) - 索引设计实践
- ⭐⭐ [性能调优实践](../../05-部署架构/单机部署/05.02-性能调优实践.md) - 性能调优详细指南
- ⭐ [存储管理与数据持久化](../../01-核心课程/01.06-存储管理与数据持久化.md) - 存储管理
- ⭐ [监控与诊断](../../06-运维实践/监控与诊断/06.01-监控与诊断.md) - 索引监控

### 外部资源

- [PostgreSQL索引文档](https://www.postgresql.org/docs/current/indexes.html)
- [PostgreSQL索引类型文档](https://www.postgresql.org/docs/current/indexes-types.html)
- [PostgreSQL索引优化最佳实践](https://wiki.postgresql.org/wiki/Index_Maintenance)

---

## 14. Wikidata对齐

- **Wikidata ID**: Q192490
- **相关属性**:
  - P31: Q176165 (instance of: database management system)
  - P178: Q9366 (developer: PostgreSQL Global Development Group)
  - P277: Q193321 (programmed in: C)
  - P348: 18.0 (software version)
- **外部链接**:
  - <https://www.postgresql.org/docs/current/indexes.html>
  - <https://www.postgresql.org/docs/current/indexes-types.html>

---

**文档版本**: v3.1
**最后更新**: 2025-11-22
**PostgreSQL版本**: 18.x (推荐) ⭐ | 17.x (推荐) | 16.x (兼容)
**维护者**: Documentation Team
