# å¹¶è¡ŒæŸ¥è¯¢å¤„ç†

> **ç‰ˆæœ¬**: v3.1
> **æœ€åæ›´æ–°**: 2025-11-22
> **ç‰ˆæœ¬è¦†ç›–**: PostgreSQL 18.x (æ¨è) â­ | 17.x (æ¨è) | 16.x (å…¼å®¹)
> **éš¾åº¦**: â­â­â­â­
> **åº”ç”¨åœºæ™¯**: å¹¶è¡ŒæŸ¥è¯¢ã€å¤§æ•°æ®åˆ†æã€æ€§èƒ½ä¼˜åŒ–
> ğŸ†• **PostgreSQL 18å¹¶è¡ŒæŸ¥è¯¢å¢å¼º**: å¹¶è¡ŒæŸ¥è¯¢æ€§èƒ½æå‡30-40%ã€æ›´æ™ºèƒ½çš„å¹¶è¡Œåº¦å†³ç­–ã€parallel_leader_participationæ–°å‚æ•°ã€æ›´å¥½çš„è´Ÿè½½å‡è¡¡ã€å¼‚æ­¥I/Oæå‡å¹¶è¡ŒI/Oæ€§èƒ½

---

## ğŸ“‹ ç›®å½•

- [å¹¶è¡ŒæŸ¥è¯¢å¤„ç†](#å¹¶è¡ŒæŸ¥è¯¢å¤„ç†)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. å®šä¹‰ä¸å½¢å¼åŒ–](#1-å®šä¹‰ä¸å½¢å¼åŒ–)
    - [1.1 æ¦‚å¿µå®šä¹‰](#11-æ¦‚å¿µå®šä¹‰)
    - [1.2 å½¢å¼åŒ–å®šä¹‰](#12-å½¢å¼åŒ–å®šä¹‰)
    - [1.3 æ ¸å¿ƒå±æ€§](#13-æ ¸å¿ƒå±æ€§)
  - [2. ç†è®ºåŸºç¡€](#2-ç†è®ºåŸºç¡€)
    - [2.1 å¹¶è¡Œè®¡ç®—ç†è®º](#21-å¹¶è¡Œè®¡ç®—ç†è®º)
    - [2.2 è´Ÿè½½å‡è¡¡ç†è®º](#22-è´Ÿè½½å‡è¡¡ç†è®º)
  - [3. PostgreSQLå¹¶è¡ŒæŸ¥è¯¢æ¶æ„](#3-postgresqlå¹¶è¡ŒæŸ¥è¯¢æ¶æ„)
    - [3.1 å¹¶è¡ŒæŸ¥è¯¢é…ç½®](#31-å¹¶è¡ŒæŸ¥è¯¢é…ç½®)
    - [3.2 å¹¶è¡ŒæŸ¥è¯¢å¯ç”¨](#32-å¹¶è¡ŒæŸ¥è¯¢å¯ç”¨)
    - [3.3 å¹¶è¡Œåº¦è®¾ç½®](#33-å¹¶è¡Œåº¦è®¾ç½®)
  - [4. å¹¶è¡Œæ‰«æ](#4-å¹¶è¡Œæ‰«æ)
    - [4.1 å¹¶è¡Œé¡ºåºæ‰«æ](#41-å¹¶è¡Œé¡ºåºæ‰«æ)
    - [4.2 å¹¶è¡Œç´¢å¼•æ‰«æ](#42-å¹¶è¡Œç´¢å¼•æ‰«æ)
    - [4.3 å¹¶è¡Œåˆ†åŒºæ‰«æ](#43-å¹¶è¡Œåˆ†åŒºæ‰«æ)
  - [5. å¹¶è¡Œè¿æ¥](#5-å¹¶è¡Œè¿æ¥)
    - [5.1 å¹¶è¡Œå“ˆå¸Œè¿æ¥](#51-å¹¶è¡Œå“ˆå¸Œè¿æ¥)
    - [5.2 å¹¶è¡ŒåµŒå¥—å¾ªç¯è¿æ¥](#52-å¹¶è¡ŒåµŒå¥—å¾ªç¯è¿æ¥)
    - [5.3 å¹¶è¡Œåˆå¹¶è¿æ¥](#53-å¹¶è¡Œåˆå¹¶è¿æ¥)
  - [6. å¹¶è¡Œèšåˆ](#6-å¹¶è¡Œèšåˆ)
    - [6.1 å¹¶è¡Œå“ˆå¸Œèšåˆ](#61-å¹¶è¡Œå“ˆå¸Œèšåˆ)
    - [6.2 å¹¶è¡Œæ’åºèšåˆ](#62-å¹¶è¡Œæ’åºèšåˆ)
    - [6.3 å¹¶è¡Œçª—å£å‡½æ•°](#63-å¹¶è¡Œçª—å£å‡½æ•°)
  - [7. å¹¶è¡Œç»´æŠ¤æ“ä½œ](#7-å¹¶è¡Œç»´æŠ¤æ“ä½œ)
    - [7.1 å¹¶è¡ŒVACUUM](#71-å¹¶è¡Œvacuum)
    - [7.2 å¹¶è¡Œç´¢å¼•æ„å»º](#72-å¹¶è¡Œç´¢å¼•æ„å»º)
    - [7.3 å¹¶è¡Œæ•°æ®åŠ è½½](#73-å¹¶è¡Œæ•°æ®åŠ è½½)
  - [8. å¹¶è¡ŒæŸ¥è¯¢ä¼˜åŒ–](#8-å¹¶è¡ŒæŸ¥è¯¢ä¼˜åŒ–)
    - [8.1 å¹¶è¡Œåº¦ä¼˜åŒ–](#81-å¹¶è¡Œåº¦ä¼˜åŒ–)
    - [8.2 è´Ÿè½½å‡è¡¡ä¼˜åŒ–](#82-è´Ÿè½½å‡è¡¡ä¼˜åŒ–)
    - [8.3 å†…å­˜ä¼˜åŒ–](#83-å†…å­˜ä¼˜åŒ–)
  - [9. å®é™…åº”ç”¨æ¡ˆä¾‹](#9-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [9.1 å¤§æ•°æ®åˆ†ææŸ¥è¯¢](#91-å¤§æ•°æ®åˆ†ææŸ¥è¯¢)
    - [9.2 å¹¶è¡Œæ•°æ®è¿ç§»](#92-å¹¶è¡Œæ•°æ®è¿ç§»)
    - [9.3 å¹¶è¡ŒæŠ¥è¡¨ç”Ÿæˆ](#93-å¹¶è¡ŒæŠ¥è¡¨ç”Ÿæˆ)
  - [10. æ€§èƒ½ç›‘æ§](#10-æ€§èƒ½ç›‘æ§)
    - [10.1 å¹¶è¡ŒæŸ¥è¯¢ç›‘æ§](#101-å¹¶è¡ŒæŸ¥è¯¢ç›‘æ§)
    - [10.2 å·¥ä½œè¿›ç¨‹ç›‘æ§](#102-å·¥ä½œè¿›ç¨‹ç›‘æ§)
  - [11. ç›¸å…³æ¦‚å¿µ](#11-ç›¸å…³æ¦‚å¿µ)
    - [11.1 ä¸Šä½æ¦‚å¿µ](#111-ä¸Šä½æ¦‚å¿µ)
    - [11.2 ä¸‹ä½æ¦‚å¿µ](#112-ä¸‹ä½æ¦‚å¿µ)
    - [11.3 å¹³è¡Œæ¦‚å¿µ](#113-å¹³è¡Œæ¦‚å¿µ)
  - [12. å‚è€ƒæ–‡çŒ®](#12-å‚è€ƒæ–‡çŒ®)
  - [13. Wikidataå¯¹é½](#13-wikidataå¯¹é½)

---

## 1. å®šä¹‰ä¸å½¢å¼åŒ–

### 1.1 æ¦‚å¿µå®šä¹‰

**ä¸­æ–‡å®šä¹‰**: å¹¶è¡ŒæŸ¥è¯¢å¤„ç†æ˜¯æ•°æ®åº“ç³»ç»Ÿåˆ©ç”¨å¤šæ ¸CPUå’Œå¤šä¸ªå·¥ä½œè¿›ç¨‹åŒæ—¶æ‰§è¡ŒæŸ¥è¯¢æ“ä½œçš„æŠ€æœ¯ï¼Œé€šè¿‡å¹¶è¡ŒåŒ–æé«˜æŸ¥è¯¢æ€§èƒ½å’Œç³»ç»Ÿååé‡ã€‚

**English Definition**: Parallel query processing is a technique in database systems that utilizes multi-core CPUs and multiple worker processes to execute query operations simultaneously, improving query performance and system throughput through parallelization.

### 1.2 å½¢å¼åŒ–å®šä¹‰

```latex
% æ•°å­¦ç¬¦å·å®šä¹‰
\newcommand{\parallel}{\mathcal{P}}
\newcommand{\worker}{\mathcal{W}}
\newcommand{\query}{\mathcal{Q}}
\newcommand{\time}{\mathcal{T}}

% å¹¶è¡ŒæŸ¥è¯¢çš„å½¢å¼åŒ–å®šä¹‰
\parallel(\query) = \{\worker_1(\query_1), \worker_2(\query_2), \ldots, \worker_n(\query_n)\}

å…¶ä¸­ï¼š
\query = \query_1 \cup \query_2 \cup \ldots \cup \query_n
\time(\parallel(\query)) = \max_{i=1}^{n} \time(\worker_i(\query_i))
```

### 1.3 æ ¸å¿ƒå±æ€§

- **å¹¶è¡Œæ€§**: å¤šä¸ªå·¥ä½œè¿›ç¨‹åŒæ—¶æ‰§è¡Œ
- **å¯æ‰©å±•æ€§**: æ”¯æŒåŠ¨æ€è°ƒæ•´å¹¶è¡Œåº¦
- **è´Ÿè½½å‡è¡¡**: åˆç†åˆ†é…å·¥ä½œè´Ÿè½½
- **å®¹é”™æ€§**: æ”¯æŒæ•…éšœæ¢å¤

## 2. ç†è®ºåŸºç¡€

### 2.1 å¹¶è¡Œè®¡ç®—ç†è®º

```latex
\begin{theorem}[å¹¶è¡ŒåŠ é€Ÿæ¯”]
å¹¶è¡ŒåŠ é€Ÿæ¯”å®šä¹‰ä¸ºï¼š
S(n) = \frac{\time(1)}{\time(n)}

å…¶ä¸­næ˜¯å¹¶è¡Œåº¦ï¼Œç†æƒ³æƒ…å†µä¸‹S(n) = nã€‚
\end{theorem}

\begin{proof}
åŸºäºAmdahlå®šå¾‹ï¼Œå¹¶è¡ŒåŠ é€Ÿæ¯”å—åˆ°ä¸²è¡Œéƒ¨åˆ†çš„é™åˆ¶ã€‚
\end{proof}
```

### 2.2 è´Ÿè½½å‡è¡¡ç†è®º

```latex
\begin{theorem}[è´Ÿè½½å‡è¡¡æœ€ä¼˜æ€§]
è´Ÿè½½å‡è¡¡æœ€ä¼˜æ€§è¦æ±‚ï¼š
\min \max_{i=1}^{n} \text{load}(\worker_i)

å…¶ä¸­load(worker_i)æ˜¯å·¥ä½œè¿›ç¨‹içš„è´Ÿè½½ã€‚
\end{theorem}
```

## 3. PostgreSQLå¹¶è¡ŒæŸ¥è¯¢æ¶æ„

### 3.1 å¹¶è¡ŒæŸ¥è¯¢é…ç½®

```sql
-- æŸ¥çœ‹å¹¶è¡ŒæŸ¥è¯¢é…ç½®
SHOW max_parallel_workers_per_gather;
SHOW max_parallel_workers;
SHOW max_parallel_maintenance_workers;
SHOW parallel_tuple_cost;
SHOW parallel_setup_cost;

-- è®¾ç½®å¹¶è¡ŒæŸ¥è¯¢å‚æ•°
SET max_parallel_workers_per_gather = 4;
SET max_parallel_workers = 8;
SET max_parallel_maintenance_workers = 4;
SET parallel_tuple_cost = 0.1;
SET parallel_setup_cost = 1000;
```

### 3.2 å¹¶è¡ŒæŸ¥è¯¢å¯ç”¨

```sql
-- å¯ç”¨å¹¶è¡ŒæŸ¥è¯¢
SET enable_parallel_hash = on;
SET enable_parallel_append = on;
SET enable_parallel_union = on;

-- æŸ¥çœ‹å¹¶è¡ŒæŸ¥è¯¢çŠ¶æ€
SHOW enable_parallel_hash;
SHOW enable_parallel_append;
SHOW enable_parallel_union;
```

### 3.3 å¹¶è¡Œåº¦è®¾ç½®

```sql
-- è¡¨çº§å¹¶è¡Œåº¦è®¾ç½®
ALTER TABLE large_table SET (parallel_workers = 4);

-- æŸ¥çœ‹è¡¨å¹¶è¡Œåº¦è®¾ç½®
SELECT
    schemaname,
    tablename,
    reloptions
FROM pg_class c
JOIN pg_namespace n ON c.relnamespace = n.oid
WHERE c.relname = 'large_table'
AND n.nspname = 'public';
```

## 4. å¹¶è¡Œæ‰«æ

### 4.1 å¹¶è¡Œé¡ºåºæ‰«æ

```sql
-- å¹¶è¡Œé¡ºåºæ‰«æ
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT COUNT(*) FROM large_table;

-- æŸ¥çœ‹å¹¶è¡Œæ‰«æç»Ÿè®¡
SELECT
    schemaname,
    tablename,
    seq_scan,
    seq_tup_read,
    seq_tup_read / seq_scan as avg_tuples_per_scan
FROM pg_stat_user_tables
WHERE tablename = 'large_table';
```

### 4.2 å¹¶è¡Œç´¢å¼•æ‰«æ

```sql
-- å¹¶è¡Œç´¢å¼•æ‰«æ
CREATE INDEX idx_large_table_id ON large_table (id);

EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT COUNT(*) FROM large_table WHERE id > 1000000;

-- å¹¶è¡Œä½å›¾æ‰«æ
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT COUNT(*) FROM large_table WHERE id BETWEEN 1000000 AND 2000000;
```

### 4.3 å¹¶è¡Œåˆ†åŒºæ‰«æ

```sql
-- åˆ›å»ºåˆ†åŒºè¡¨
CREATE TABLE sales (
    id BIGSERIAL,
    sale_date DATE,
    amount DECIMAL(10,2)
) PARTITION BY RANGE (sale_date);

-- åˆ›å»ºåˆ†åŒº
CREATE TABLE sales_2023 PARTITION OF sales
FOR VALUES FROM ('2023-01-01') TO ('2024-01-01');

CREATE TABLE sales_2024 PARTITION OF sales
FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');

-- å¹¶è¡Œåˆ†åŒºæ‰«æ
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT COUNT(*) FROM sales WHERE sale_date >= '2023-01-01';
```

## 5. å¹¶è¡Œè¿æ¥

### 5.1 å¹¶è¡Œå“ˆå¸Œè¿æ¥

```sql
-- å¹¶è¡Œå“ˆå¸Œè¿æ¥
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT COUNT(*)
FROM large_table1 t1
JOIN large_table2 t2 ON t1.id = t2.id;

-- å¼ºåˆ¶å¹¶è¡Œå“ˆå¸Œè¿æ¥
SET enable_parallel_hash = on;
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT COUNT(*)
FROM large_table1 t1
JOIN large_table2 t2 ON t1.id = t2.id;
```

### 5.2 å¹¶è¡ŒåµŒå¥—å¾ªç¯è¿æ¥

```sql
-- å¹¶è¡ŒåµŒå¥—å¾ªç¯è¿æ¥
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT COUNT(*)
FROM large_table1 t1
JOIN large_table2 t2 ON t1.id = t2.id
WHERE t1.value > 1000;
```

### 5.3 å¹¶è¡Œåˆå¹¶è¿æ¥

```sql
-- å¹¶è¡Œåˆå¹¶è¿æ¥
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT COUNT(*)
FROM large_table1 t1
JOIN large_table2 t2 ON t1.id = t2.id
ORDER BY t1.id;
```

## 6. å¹¶è¡Œèšåˆ

### 6.1 å¹¶è¡Œå“ˆå¸Œèšåˆ

```sql
-- å¹¶è¡Œå“ˆå¸Œèšåˆ
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT category_id, COUNT(*), AVG(value)
FROM large_table
GROUP BY category_id;

-- å¹¶è¡Œåˆ†ç»„èšåˆ
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT category_id, subcategory_id, COUNT(*), AVG(value)
FROM large_table
GROUP BY category_id, subcategory_id;
```

### 6.2 å¹¶è¡Œæ’åºèšåˆ

```sql
-- å¹¶è¡Œæ’åºèšåˆ
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT category_id, COUNT(*), AVG(value)
FROM large_table
GROUP BY category_id
ORDER BY category_id;
```

### 6.3 å¹¶è¡Œçª—å£å‡½æ•°

```sql
-- å¹¶è¡Œçª—å£å‡½æ•°
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT
    category_id,
    value,
    ROW_NUMBER() OVER (PARTITION BY category_id ORDER BY value DESC) as rank
FROM large_table;
```

## 7. å¹¶è¡Œç»´æŠ¤æ“ä½œ

### 7.1 å¹¶è¡ŒVACUUM

```sql
-- å¹¶è¡ŒVACUUM
VACUUM (PARALLEL 4) large_table;

-- å¹¶è¡ŒVACUUM ANALYZE
VACUUM (ANALYZE, PARALLEL 4) large_table;

-- æŸ¥çœ‹VACUUMè¿›åº¦
SELECT
    pid,
    datname,
    usename,
    application_name,
    state,
    query
FROM pg_stat_activity
WHERE query LIKE '%VACUUM%';
```

### 7.2 å¹¶è¡Œç´¢å¼•æ„å»º

```sql
-- å¹¶è¡Œç´¢å¼•æ„å»º
CREATE INDEX CONCURRENTLY idx_large_table_parallel
ON large_table (category_id, value)
WITH (parallel_workers = 4);

-- æŸ¥çœ‹ç´¢å¼•æ„å»ºè¿›åº¦
SELECT
    pid,
    datname,
    usename,
    application_name,
    state,
    query
FROM pg_stat_activity
WHERE query LIKE '%CREATE INDEX%';
```

### 7.3 å¹¶è¡Œæ•°æ®åŠ è½½

```sql
-- å¹¶è¡Œæ•°æ®åŠ è½½
COPY large_table FROM '/path/to/data.csv' WITH (FORMAT csv, HEADER);

-- ä½¿ç”¨å¹¶è¡ŒINSERT
INSERT INTO large_table (category_id, value, description)
SELECT
    (random() * 100)::INTEGER,
    (random() * 1000)::DECIMAL(10,2),
    'Description ' || generate_series(1, 1000000);
```

## 8. å¹¶è¡ŒæŸ¥è¯¢ä¼˜åŒ–

### 8.1 å¹¶è¡Œåº¦ä¼˜åŒ–

```sql
-- åŠ¨æ€è°ƒæ•´å¹¶è¡Œåº¦
CREATE OR REPLACE FUNCTION optimize_parallel_degree(table_name text, query_text text)
RETURNS integer AS $$
DECLARE
    optimal_degree integer;
    current_degree integer;
    execution_time numeric;
    best_time numeric := 999999;
    best_degree integer := 1;
BEGIN
    FOR current_degree IN 1..8 LOOP
        EXECUTE format('SET max_parallel_workers_per_gather = %s', current_degree);

        -- æ‰§è¡ŒæŸ¥è¯¢å¹¶æµ‹é‡æ—¶é—´
        EXECUTE format('EXPLAIN (ANALYZE, BUFFERS) %s', query_text);

        -- è¿™é‡Œéœ€è¦ä»EXPLAINè¾“å‡ºä¸­æå–æ‰§è¡Œæ—¶é—´
        -- ç®€åŒ–ç¤ºä¾‹ï¼Œå®é™…å®ç°éœ€è¦è§£æEXPLAINè¾“å‡º

        IF execution_time < best_time THEN
            best_time := execution_time;
            best_degree := current_degree;
        END IF;
    END LOOP;

    RETURN best_degree;
END;
$$ LANGUAGE plpgsql;
```

### 8.2 è´Ÿè½½å‡è¡¡ä¼˜åŒ–

```sql
-- ç›‘æ§å¹¶è¡ŒæŸ¥è¯¢è´Ÿè½½
SELECT
    pid,
    usename,
    application_name,
    state,
    query_start,
    query
FROM pg_stat_activity
WHERE query LIKE '%Gather%' OR query LIKE '%Parallel%';

-- æŸ¥çœ‹å·¥ä½œè¿›ç¨‹ç»Ÿè®¡
SELECT
    datname,
    numbackends,
    xact_commit,
    xact_rollback,
    blks_read,
    blks_hit
FROM pg_stat_database
WHERE datname = current_database();
```

### 8.3 å†…å­˜ä¼˜åŒ–

```sql
-- å¹¶è¡ŒæŸ¥è¯¢å†…å­˜é…ç½®
SET work_mem = '256MB';
SET maintenance_work_mem = '1GB';

-- ç›‘æ§å†…å­˜ä½¿ç”¨
SELECT
    pid,
    usename,
    application_name,
    state,
    query
FROM pg_stat_activity
WHERE state = 'active'
AND query LIKE '%Gather%';
```

## 9. å®é™…åº”ç”¨æ¡ˆä¾‹

### 9.1 å¤§æ•°æ®åˆ†ææŸ¥è¯¢

```sql
-- å¤§æ•°æ®åˆ†ææŸ¥è¯¢
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
WITH monthly_stats AS (
    SELECT
        DATE_TRUNC('month', sale_date) as month,
        category_id,
        COUNT(*) as transaction_count,
        SUM(amount) as total_amount,
        AVG(amount) as avg_amount
    FROM sales
    WHERE sale_date >= '2023-01-01'
    GROUP BY DATE_TRUNC('month', sale_date), category_id
)
SELECT
    month,
    category_id,
    transaction_count,
    total_amount,
    avg_amount,
    ROW_NUMBER() OVER (PARTITION BY month ORDER BY total_amount DESC) as rank
FROM monthly_stats
ORDER BY month, rank;
```

### 9.2 å¹¶è¡Œæ•°æ®è¿ç§»

```sql
-- å¹¶è¡Œæ•°æ®è¿ç§»
CREATE TABLE target_table (
    id BIGSERIAL PRIMARY KEY,
    source_id INTEGER,
    data_value DECIMAL(10,2),
    created_at TIMESTAMP DEFAULT NOW()
);

-- å¹¶è¡Œæ•°æ®è¿ç§»
INSERT INTO target_table (source_id, data_value)
SELECT
    source_id,
    data_value
FROM source_table
WHERE id BETWEEN 1 AND 1000000;

-- ä½¿ç”¨å¹¶è¡ŒCOPY
COPY target_table (source_id, data_value)
FROM '/path/to/data.csv'
WITH (FORMAT csv, HEADER);
```

### 9.3 å¹¶è¡ŒæŠ¥è¡¨ç”Ÿæˆ

```sql
-- å¹¶è¡ŒæŠ¥è¡¨ç”Ÿæˆ
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT
    d.dept_name,
    COUNT(e.emp_id) as employee_count,
    AVG(e.salary) as avg_salary,
    MAX(e.salary) as max_salary,
    MIN(e.salary) as min_salary,
    SUM(e.salary) as total_salary
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id
WHERE e.hire_date >= '2020-01-01'
GROUP BY d.dept_name
ORDER BY total_salary DESC;
```

## 10. æ€§èƒ½ç›‘æ§

### 10.1 å¹¶è¡ŒæŸ¥è¯¢ç›‘æ§

```sql
-- å¹¶è¡ŒæŸ¥è¯¢ç›‘æ§
SELECT
    pid,
    usename,
    application_name,
    state,
    query_start,
    query
FROM pg_stat_activity
WHERE query LIKE '%Gather%' OR query LIKE '%Parallel%'
ORDER BY query_start;

-- å¹¶è¡ŒæŸ¥è¯¢ç»Ÿè®¡
SELECT
    query,
    calls,
    total_time,
    mean_time,
    stddev_time,
    rows
FROM pg_stat_statements
WHERE query LIKE '%Gather%' OR query LIKE '%Parallel%'
ORDER BY total_time DESC;
```

### 10.2 å·¥ä½œè¿›ç¨‹ç›‘æ§

```sql
-- å·¥ä½œè¿›ç¨‹ç›‘æ§
SELECT
    pid,
    usename,
    application_name,
    state,
    query_start,
    query
FROM pg_stat_activity
WHERE application_name LIKE '%worker%'
ORDER BY query_start;

-- å·¥ä½œè¿›ç¨‹ç»Ÿè®¡
SELECT
    datname,
    numbackends,
    xact_commit,
    xact_rollback,
    blks_read,
    blks_hit
FROM pg_stat_database
WHERE datname = current_database();
```

## 11. ç›¸å…³æ¦‚å¿µ

### 11.1 ä¸Šä½æ¦‚å¿µ

- **å¹¶è¡Œè®¡ç®—**: æ›´å¹¿æ³›çš„å¹¶è¡Œè®¡ç®—æŠ€æœ¯
- **æŸ¥è¯¢ä¼˜åŒ–**: æŸ¥è¯¢æ€§èƒ½ä¼˜åŒ–
- **ç³»ç»Ÿæ¶æ„**: æ•°æ®åº“ç³»ç»Ÿæ¶æ„

### 11.2 ä¸‹ä½æ¦‚å¿µ

- **å¹¶è¡Œæ‰«æ**: å¹¶è¡Œæ•°æ®æ‰«æ
- **å¹¶è¡Œè¿æ¥**: å¹¶è¡Œè¿æ¥æ“ä½œ
- **å¹¶è¡Œèšåˆ**: å¹¶è¡Œèšåˆæ“ä½œ
- **è´Ÿè½½å‡è¡¡**: è´Ÿè½½åˆ†é…æœºåˆ¶

### 11.3 å¹³è¡Œæ¦‚å¿µ

- **åˆ†å¸ƒå¼æŸ¥è¯¢**: è·¨èŠ‚ç‚¹æŸ¥è¯¢å¤„ç†
- **å¤šçº¿ç¨‹**: å¤šçº¿ç¨‹ç¼–ç¨‹æŠ€æœ¯
- **é›†ç¾¤è®¡ç®—**: é›†ç¾¤å¹¶è¡Œè®¡ç®—

## 12. å‚è€ƒæ–‡çŒ®

1. PostgreSQL Global Development Group. (2025). PostgreSQL 18 Documentation. <https://www.postgresql.org/docs/18/>
2. Graefe, G. (1995). The Cascades framework for query optimization. IEEE Data Engineering Bulletin, 18(3), 19-29.
3. DeWitt, D. J., & Gray, J. (1992). Parallel database systems: the future of high performance database processing. Communications of the ACM, 35(6), 85-98.
4. Amdahl, G. M. (1967). Validity of the single processor approach to achieving large scale computing capabilities. AFIPS Conference Proceedings, 30, 483-485.
5. PostgreSQL Global Development Group. (2024). PostgreSQL 17 Documentation. <https://www.postgresql.org/docs/17/>

## 13. Wikidataå¯¹é½

- **Wikidata ID**: Q192490
- **ç›¸å…³å±æ€§**:
  - P31: Q176165 (instance of: database management system)
  - P178: Q9366 (developer: PostgreSQL Global Development Group)
  - P277: Q193321 (programmed in: C)
  - P348: 18.0 (software version)
- **å¤–éƒ¨é“¾æ¥**:
  - <https://www.postgresql.org/docs/current/parallel-query.html>
  - <https://www.postgresql.org/docs/current/runtime-config-query.html>

---

## 14. äº¤å‰å¼•ç”¨

### ç›¸å…³æ–‡æ¡£

- â­â­â­ [æŸ¥è¯¢ä¼˜åŒ–å™¨åŸç†](./02.01-æŸ¥è¯¢ä¼˜åŒ–å™¨åŸç†.md) - æŸ¥è¯¢ä¼˜åŒ–ç†è®ºåŸºç¡€
- â­â­â­ [æ‰§è¡Œè®¡åˆ’ä¸æ€§èƒ½è°ƒä¼˜](./02.04-æ‰§è¡Œè®¡åˆ’ä¸æ€§èƒ½è°ƒä¼˜.md) - æ‰§è¡Œè®¡åˆ’åˆ†æ
- â­â­ [ç»Ÿè®¡ä¿¡æ¯ä¸ä»£ä»·æ¨¡å‹](./02.03-ç»Ÿè®¡ä¿¡æ¯ä¸ä»£ä»·æ¨¡å‹.md) - ç»Ÿè®¡ä¿¡æ¯å¯¹å¹¶è¡ŒæŸ¥è¯¢çš„å½±å“
- â­â­ [ç´¢å¼•ç»“æ„ä¸ä¼˜åŒ–](./02.02-ç´¢å¼•ç»“æ„ä¸ä¼˜åŒ–.md) - å¹¶è¡Œç´¢å¼•æ‰«æä¼˜åŒ–
- â­â­ [ç³»ç»Ÿæ¶æ„ä¸è®¾è®¡åŸç†](../../01-æ ¸å¿ƒè¯¾ç¨‹/01.01-ç³»ç»Ÿæ¶æ„ä¸è®¾è®¡åŸç†.md) - è¿›ç¨‹æ¨¡å‹å’Œå†…å­˜ç®¡ç†
- â­ [æ€§èƒ½è°ƒä¼˜å®è·µ](../../05-éƒ¨ç½²æ¶æ„/å•æœºéƒ¨ç½²/05.02-æ€§èƒ½è°ƒä¼˜å®è·µ.md) - æ€§èƒ½è°ƒä¼˜å®è·µæŒ‡å—
- â­ [ç›‘æ§ä¸è¯Šæ–­](../../06-è¿ç»´å®è·µ/ç›‘æ§ä¸è¯Šæ–­/06.01-ç›‘æ§ä¸è¯Šæ–­.md) - å¹¶è¡ŒæŸ¥è¯¢ç›‘æ§æ–¹æ³•

### å¤–éƒ¨èµ„æº

- [PostgreSQLå¹¶è¡ŒæŸ¥è¯¢æ–‡æ¡£](https://www.postgresql.org/docs/current/parallel-query.html)
- [PostgreSQLå¹¶è¡ŒæŸ¥è¯¢é…ç½®](https://www.postgresql.org/docs/current/runtime-config-query.html#RUNTIME-CONFIG-QUERY-ENABLE)
- [PostgreSQLå¹¶è¡ŒæŸ¥è¯¢æ€§èƒ½è°ƒä¼˜](https://www.postgresql.org/docs/current/parallel-query.html#PARALLEL-QUERY-PERFORMANCE)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v3.1
**æœ€åæ›´æ–°**: 2025-11-22
**PostgreSQLç‰ˆæœ¬**: 18.x (æ¨è) â­ | 17.x (æ¨è) | 16.x (å…¼å®¹)
**ç»´æŠ¤è€…**: Documentation Team
