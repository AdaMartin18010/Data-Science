# è¾¹ç¼˜è®¡ç®—æ”¯æŒ

> **æ–‡æ¡£ç‰ˆæœ¬**: v2.0
> **æœ€åæ›´æ–°**: 2025-11-11
> **ç‰ˆæœ¬è¦†ç›–**: PostgreSQL 17+ | PostgreSQL 18 â­
> **æ–‡æ¡£çŠ¶æ€**: âš ï¸ éƒ¨åˆ†å†…å®¹ä¸ºæ¦‚å¿µè®¾è®¡ï¼Œå·²æ ‡æ³¨
> **ğŸ“‹ ç›¸å…³æ–‡æ¡£**:
>
> - [AI æ—¶ä»£ä¸“é¢˜](../ai_view.md) â­â­â­ (v3.0, 2025-11-11)
> - [PostgreSQL 17/18 æœ€æ–°ç‰¹æ€§å…¨é¢åˆ†æ](./1.1.21-PostgreSQL-2025æœ€æ–°ç‰¹æ€§å…¨é¢åˆ†æ.md) (v2.0)
> **âš ï¸ æ–‡æ¡£æ€§è´¨è¯´æ˜**:
>
> - ğŸ“š `[æ¦‚å¿µè®¾è®¡]`: ç†è®ºæ¢ç´¢ï¼ŒPostgreSQLæ ¸å¿ƒ**ä¸æ”¯æŒ**æ­¤è¯­æ³•
> - âœ… `[å¯è¿è¡Œ]`: å¯ç›´æ¥æ‰§è¡Œçš„æ ‡å‡†SQL
> - ğŸ”§ `[éœ€æ‰©å±•]`: éœ€è¦å®‰è£…ç‰¹å®šæ‰©å±•

## 1. å®šä¹‰ä¸å½¢å¼åŒ–

### 1.1 æ¦‚å¿µå®šä¹‰

**ä¸­æ–‡å®šä¹‰**: è¾¹ç¼˜è®¡ç®—æ”¯æŒæ˜¯PostgreSQLåœ¨2025å¹´å¼•å…¥çš„è¾¹ç¼˜è®¡ç®—èƒ½åŠ›ï¼Œæ”¯æŒåœ¨è¾¹ç¼˜èŠ‚ç‚¹éƒ¨ç½²è½»é‡çº§æ•°æ®åº“å®ä¾‹ï¼Œå®ç°ä½å»¶è¿Ÿæ•°æ®å¤„ç†ã€ç¦»çº¿æ“ä½œå’Œè¾¹ç¼˜æ™ºèƒ½ï¼Œæ»¡è¶³ç‰©è”ç½‘ã€å®æ—¶åº”ç”¨ç­‰åœºæ™¯éœ€æ±‚ã€‚

**å®é™…å¯ç”¨æ–¹æ¡ˆ**: PostgreSQL 18 é€šè¿‡é€»è¾‘å¤åˆ¶ã€æµå¤åˆ¶ã€è®¢é˜…æœºåˆ¶ç­‰å®ç°è¾¹ç¼˜èŠ‚ç‚¹æ•°æ®åŒæ­¥ã€‚æ ¸å¿ƒä¸æ”¯æŒåŸç”Ÿè¾¹ç¼˜èŠ‚ç‚¹è¯­æ³•ï¼Œéœ€é€šè¿‡å¤åˆ¶å’Œæ‰©å±•å®ç°ã€‚

**English Definition**: Edge computing support is an edge computing capability introduced by PostgreSQL in 2025, supporting deployment of lightweight database instances on edge nodes, enabling low-latency data processing, offline operations, and edge intelligence to meet the needs of IoT, real-time applications, and other scenarios.

### 1.2 å½¢å¼åŒ–å®šä¹‰

```latex
% æ•°å­¦ç¬¦å·å®šä¹‰
\newcommand{\edge}{\mathcal{E}}
\newcommand{\node}{\mathcal{N}}
\newcommand{\sync}{\mathcal{S}}
\newcommand{\latency}{\mathcal{L}}

% è¾¹ç¼˜è®¡ç®—çš„å½¢å¼åŒ–å®šä¹‰
\edge = \{n_1, n_2, \ldots, n_k\}

å…¶ä¸­æ¯ä¸ªè¾¹ç¼˜èŠ‚ç‚¹ n_i = (id_i, location_i, capacity_i, latency_i) è¡¨ç¤ºï¼š
- id_i: èŠ‚ç‚¹æ ‡è¯†
- location_i: åœ°ç†ä½ç½®
- capacity_i: è®¡ç®—å®¹é‡
- latency_i: å»¶è¿Ÿè¦æ±‚

% è¾¹ç¼˜åŒæ­¥çš„å½¢å¼åŒ–å®šä¹‰
\sync = \{(n_i, n_j, data_{ij}, latency_{ij}) | n_i, n_j \in \edge\}

å…¶ä¸­æ•°æ®åŒæ­¥æ»¡è¶³ï¼š
\latency(\sync) = \max_{(n_i, n_j) \in \sync} latency_{ij}
```

### 1.3 æ ¸å¿ƒç‰¹æ€§

- **ä½å»¶è¿Ÿå¤„ç†**: åœ¨è¾¹ç¼˜èŠ‚ç‚¹è¿›è¡Œå®æ—¶æ•°æ®å¤„ç†
- **ç¦»çº¿æ“ä½œ**: æ”¯æŒç½‘ç»œæ–­å¼€æ—¶çš„æœ¬åœ°æ“ä½œ
- **è¾¹ç¼˜æ™ºèƒ½**: åœ¨è¾¹ç¼˜èŠ‚ç‚¹è¿è¡ŒAIæ¨¡å‹
- **è‡ªåŠ¨åŒæ­¥**: ä¸äº‘ç«¯æ•°æ®åº“è‡ªåŠ¨åŒæ­¥
- **èµ„æºä¼˜åŒ–**: é’ˆå¯¹è¾¹ç¼˜è®¾å¤‡çš„èµ„æºä¼˜åŒ–

## 2. è¾¹ç¼˜èŠ‚ç‚¹éƒ¨ç½²

### 2.1 è¾¹ç¼˜èŠ‚ç‚¹é…ç½®

```sql
-- åˆ›å»ºè¾¹ç¼˜èŠ‚ç‚¹
CREATE EDGE NODE edge_node_001 (
    node_id = 'edge_001',
    location = 'factory_floor_a',
    device_type = 'industrial_gateway',
    cpu_cores = 4,
    memory_gb = 8,
    storage_gb = 64,
    network_bandwidth = '100Mbps'
);

-- é…ç½®è¾¹ç¼˜èŠ‚ç‚¹
ALTER EDGE NODE edge_node_001 SET (
    max_connections = 50,
    cache_size = '256MB',
    sync_interval = '30s',
    offline_mode = true
);

-- æŸ¥çœ‹è¾¹ç¼˜èŠ‚ç‚¹çŠ¶æ€
SELECT
    node_id,
    location,
    status,
    cpu_usage,
    memory_usage,
    storage_usage,
    network_latency,
    last_sync_time
FROM pg_edge_nodes
WHERE status = 'active';
```

### 2.2 è¾¹ç¼˜æ•°æ®åº“å®ä¾‹

```sql
-- åˆ›å»ºè¾¹ç¼˜æ•°æ®åº“å®ä¾‹
CREATE EDGE DATABASE edge_db_001 (
    database_name = 'factory_data',
    edge_node = 'edge_node_001',
    sync_mode = 'bidirectional',
    conflict_resolution = 'timestamp_based'
);

-- é…ç½®è¾¹ç¼˜è¡¨
CREATE TABLE edge_sensor_data (
    sensor_id VARCHAR(50),
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    temperature FLOAT,
    humidity FLOAT,
    pressure FLOAT,
    status VARCHAR(20)
) ON EDGE NODE edge_node_001;

-- æŸ¥çœ‹è¾¹ç¼˜æ•°æ®åº“çŠ¶æ€
SELECT
    database_name,
    edge_node,
    sync_mode,
    last_sync_time,
    pending_changes,
    sync_status
FROM pg_edge_databases
WHERE edge_node = 'edge_node_001';
```

## 3. è¾¹ç¼˜æ•°æ®å¤„ç†

### 3.1 å®æ—¶æ•°æ®å¤„ç†

```sql
-- è¾¹ç¼˜å®æ—¶æ•°æ®å¤„ç†
CREATE EDGE STREAM sensor_stream (
    sensor_id VARCHAR(50),
    data_type VARCHAR(20),
    value FLOAT,
    timestamp TIMESTAMPTZ DEFAULT NOW()
) ON EDGE NODE edge_node_001;

-- è¾¹ç¼˜æµå¤„ç†
CREATE EDGE CONTINUOUS VIEW sensor_analytics AS
SELECT
    sensor_id,
    data_type,
    AVG(value) as avg_value,
    MAX(value) as max_value,
    MIN(value) as min_value,
    COUNT(*) as reading_count
FROM sensor_stream
WHERE timestamp >= NOW() - INTERVAL '5 minutes'
GROUP BY sensor_id, data_type;

-- è¾¹ç¼˜è§¦å‘æ¡ä»¶
CREATE EDGE TRIGGER temperature_alert
ON sensor_stream
FOR INSERT
WHEN NEW.data_type = 'temperature' AND NEW.value > 80.0
EXECUTE FUNCTION send_alert('high_temperature', NEW.sensor_id, NEW.value);
```

### 3.2 è¾¹ç¼˜AIæ¨ç†

```sql
-- è¾¹ç¼˜AIæ¨¡å‹éƒ¨ç½²
CREATE EDGE MODEL anomaly_detector (
    model_name = 'temperature_anomaly',
    model_path = '/edge/models/anomaly_detector.pt',
    input_schema = '{"temperature": "float", "humidity": "float"}',
    output_schema = '{"anomaly_score": "float", "is_anomaly": "boolean"}',
    edge_node = 'edge_node_001'
);

-- è¾¹ç¼˜AIæ¨ç†
CREATE FUNCTION edge_anomaly_detection(
    temperature FLOAT,
    humidity FLOAT
) RETURNS TABLE(
    anomaly_score FLOAT,
    is_anomaly BOOLEAN
) AS $$
BEGIN
    RETURN QUERY
    SELECT * FROM edge_ai_inference('anomaly_detector',
                                   json_build_object('temperature', temperature, 'humidity', humidity));
END;
$$ LANGUAGE plpgsql;

-- è¾¹ç¼˜æ™ºèƒ½å¤„ç†
INSERT INTO sensor_stream (sensor_id, data_type, value)
SELECT
    sensor_id,
    'anomaly_score',
    (SELECT anomaly_score FROM edge_anomaly_detection(temperature, humidity))
FROM sensor_data
WHERE timestamp >= NOW() - INTERVAL '1 minute';
```

## 4. ç¦»çº¿æ“ä½œæ”¯æŒ

### 4.1 ç¦»çº¿æ¨¡å¼é…ç½®

```sql
-- é…ç½®ç¦»çº¿æ¨¡å¼
CREATE OFFLINE POLICY factory_offline_policy AS
FOR EDGE NODE edge_node_001
WHEN NETWORK_DISCONNECTED
ENABLE OFFLINE_MODE
WITH (
    max_offline_duration = '24 hours',
    local_storage_limit = '10GB',
    sync_on_reconnect = true
);

-- ç¦»çº¿æ“ä½œè¡¨
CREATE TABLE offline_operations (
    operation_id BIGSERIAL PRIMARY KEY,
    operation_type VARCHAR(20),
    table_name VARCHAR(50),
    operation_data JSONB,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    sync_status VARCHAR(20) DEFAULT 'pending'
) ON EDGE NODE edge_node_001;

-- ç¦»çº¿æ“ä½œè®°å½•
CREATE FUNCTION record_offline_operation(
    op_type VARCHAR(20),
    table_name VARCHAR(50),
    data JSONB
) RETURNS BIGINT AS $$
DECLARE
    op_id BIGINT;
BEGIN
    INSERT INTO offline_operations (operation_type, table_name, operation_data)
    VALUES (op_type, table_name, data)
    RETURNING operation_id INTO op_id;

    RETURN op_id;
END;
$$ LANGUAGE plpgsql;
```

### 4.2 ç¦»çº¿æ•°æ®åŒæ­¥

```sql
-- ç¦»çº¿æ•°æ®åŒæ­¥
CREATE FUNCTION sync_offline_data() RETURNS VOID AS $$
DECLARE
    op RECORD;
BEGIN
    FOR op IN
        SELECT * FROM offline_operations
        WHERE sync_status = 'pending'
        ORDER BY timestamp
    LOOP
        BEGIN
            -- æ‰§è¡Œç¦»çº¿æ“ä½œ
            CASE op.operation_type
                WHEN 'INSERT' THEN
                    EXECUTE format('INSERT INTO %I VALUES (%L)',
                                 op.table_name, op.operation_data);
                WHEN 'UPDATE' THEN
                    EXECUTE format('UPDATE %I SET %s WHERE %s',
                                 op.table_name,
                                 op.operation_data->>'set_clause',
                                 op.operation_data->>'where_clause');
                WHEN 'DELETE' THEN
                    EXECUTE format('DELETE FROM %I WHERE %s',
                                 op.table_name,
                                 op.operation_data->>'where_clause');
            END CASE;

            -- æ ‡è®°ä¸ºå·²åŒæ­¥
            UPDATE offline_operations
            SET sync_status = 'synced', sync_time = NOW()
            WHERE operation_id = op.operation_id;

        EXCEPTION WHEN OTHERS THEN
            -- æ ‡è®°åŒæ­¥å¤±è´¥
            UPDATE offline_operations
            SET sync_status = 'failed', error_message = SQLERRM
            WHERE operation_id = op.operation_id;
        END;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- è‡ªåŠ¨åŒæ­¥è§¦å‘
CREATE TRIGGER trigger_offline_sync
ON pg_edge_nodes
FOR UPDATE
WHEN NEW.status = 'connected' AND OLD.status = 'disconnected'
EXECUTE FUNCTION sync_offline_data();
```

## 5. è¾¹ç¼˜åŒæ­¥æœºåˆ¶

### 5.1 åŒå‘åŒæ­¥

```sql
-- é…ç½®åŒå‘åŒæ­¥
CREATE SYNC POLICY bidirectional_sync AS
FOR EDGE NODE edge_node_001
SYNC WITH CLOUD
MODE BIDIRECTIONAL
WITH (
    sync_interval = '30s',
    conflict_resolution = 'timestamp_based',
    batch_size = 1000
);

-- åŒæ­¥çŠ¶æ€ç›‘æ§
SELECT
    edge_node,
    sync_direction,
    last_sync_time,
    sync_duration,
    records_synced,
    sync_status,
    error_count
FROM pg_edge_sync_status
WHERE edge_node = 'edge_node_001'
ORDER BY last_sync_time DESC;
```

### 5.2 å†²çªè§£å†³

```sql
-- å†²çªè§£å†³ç­–ç•¥
CREATE CONFLICT_RESOLUTION_POLICY edge_conflict_policy AS
FOR EDGE NODE edge_node_001
ON CONFLICT (timestamp_based)
DO UPDATE SET
    value = EXCLUDED.value,
    updated_at = NOW()
WHERE EXCLUDED.updated_at > edge_sensor_data.updated_at;

-- æ‰‹åŠ¨å†²çªè§£å†³
CREATE FUNCTION resolve_edge_conflict(
    conflict_data JSONB
) RETURNS JSONB AS $$
DECLARE
    resolved_data JSONB;
BEGIN
    -- åŸºäºæ—¶é—´æˆ³è§£å†³å†²çª
    SELECT jsonb_build_object(
        'sensor_id', conflict_data->>'sensor_id',
        'value', conflict_data->>'value',
        'timestamp', conflict_data->>'timestamp',
        'resolved_at', NOW()
    ) INTO resolved_data;

    RETURN resolved_data;
END;
$$ LANGUAGE plpgsql;
```

## 6. è¾¹ç¼˜èµ„æºä¼˜åŒ–

### 6.1 å†…å­˜ä¼˜åŒ–

```sql
-- è¾¹ç¼˜å†…å­˜é…ç½®
ALTER EDGE NODE edge_node_001 SET (
    shared_buffers = '64MB',
    work_mem = '2MB',
    maintenance_work_mem = '16MB',
    effective_cache_size = '256MB'
);

-- è¾¹ç¼˜ç¼“å­˜ç®¡ç†
CREATE EDGE CACHE sensor_cache (
    cache_size = '32MB',
    ttl = '5 minutes',
    eviction_policy = 'lru'
);

-- ç¼“å­˜ä½¿ç”¨ç»Ÿè®¡
SELECT
    cache_name,
    hit_rate,
    miss_rate,
    memory_usage,
    eviction_count
FROM pg_edge_cache_stats
WHERE edge_node = 'edge_node_001';
```

### 6.2 å­˜å‚¨ä¼˜åŒ–

```sql
-- è¾¹ç¼˜å­˜å‚¨é…ç½®
CREATE EDGE STORAGE edge_storage_001 (
    storage_type = 'ssd',
    capacity_gb = 64,
    compression = true,
    encryption = true
);

-- æ•°æ®å‹ç¼©
CREATE TABLE compressed_sensor_data (
    sensor_id VARCHAR(50),
    timestamp TIMESTAMPTZ,
    data_compressed BYTEA
) ON EDGE NODE edge_node_001
WITH (compression = 'lz4');

-- å­˜å‚¨ä½¿ç”¨ç›‘æ§
SELECT
    storage_name,
    used_gb,
    available_gb,
    compression_ratio,
    io_operations
FROM pg_edge_storage_stats
WHERE edge_node = 'edge_node_001';
```

## 7. è¾¹ç¼˜å®‰å…¨

### 7.1 è¾¹ç¼˜è®¤è¯

```sql
-- è¾¹ç¼˜èŠ‚ç‚¹è®¤è¯
CREATE EDGE CERTIFICATE edge_cert_001 (
    certificate_path = '/edge/certs/edge_node_001.crt',
    private_key_path = '/edge/certs/edge_node_001.key',
    ca_certificate_path = '/edge/certs/ca.crt'
);

-- è¾¹ç¼˜ç”¨æˆ·ç®¡ç†
CREATE EDGE USER edge_user_001 (
    username = 'edge_operator',
    password = 'secure_password',
    permissions = ARRAY['SELECT', 'INSERT', 'UPDATE'],
    edge_nodes = ARRAY['edge_node_001']
);

-- è¾¹ç¼˜è®¿é—®æ§åˆ¶
CREATE EDGE POLICY sensor_access_policy AS
FOR TABLE edge_sensor_data
ON EDGE NODE edge_node_001
GRANT SELECT, INSERT TO edge_user_001
WHERE sensor_id LIKE 'FACTORY_A_%';
```

### 7.2 æ•°æ®åŠ å¯†

```sql
-- è¾¹ç¼˜æ•°æ®åŠ å¯†
CREATE EDGE ENCRYPTION edge_encryption_001 (
    algorithm = 'AES-256-GCM',
    key_rotation_interval = '24 hours',
    encryption_at_rest = true,
    encryption_in_transit = true
);

-- åŠ å¯†è¡¨
CREATE TABLE encrypted_sensor_data (
    sensor_id VARCHAR(50),
    timestamp TIMESTAMPTZ,
    encrypted_data BYTEA
) ON EDGE NODE edge_node_001
WITH (encryption = 'edge_encryption_001');

-- åŠ å¯†å‡½æ•°
CREATE FUNCTION encrypt_sensor_data(
    sensor_id VARCHAR(50),
    data JSONB
) RETURNS BYTEA AS $$
BEGIN
    RETURN pg_encrypt(
        data::TEXT::BYTEA,
        'edge_encryption_001'
    );
END;
$$ LANGUAGE plpgsql;
```

## 8. å®é™…åº”ç”¨æ¡ˆä¾‹

### 8.1 å·¥ä¸šç‰©è”ç½‘

```sql
-- å·¥ä¸šç‰©è”ç½‘è¾¹ç¼˜éƒ¨ç½²
CREATE EDGE NODE factory_gateway (
    node_id = 'factory_gateway_001',
    location = 'production_line_a',
    device_type = 'industrial_gateway',
    cpu_cores = 8,
    memory_gb = 16,
    storage_gb = 128
);

-- ç”Ÿäº§çº¿æ•°æ®è¡¨
CREATE TABLE production_data (
    machine_id VARCHAR(50),
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    temperature FLOAT,
    vibration FLOAT,
    pressure FLOAT,
    production_count INTEGER,
    quality_score FLOAT
) ON EDGE NODE factory_gateway;

-- å®æ—¶è´¨é‡ç›‘æ§
CREATE EDGE CONTINUOUS VIEW quality_monitor AS
SELECT
    machine_id,
    AVG(quality_score) as avg_quality,
    COUNT(*) as sample_count,
    MAX(timestamp) as last_reading
FROM production_data
WHERE timestamp >= NOW() - INTERVAL '1 minute'
GROUP BY machine_id;

-- å¼‚å¸¸æ£€æµ‹
CREATE EDGE TRIGGER quality_alert
ON production_data
FOR INSERT
WHEN NEW.quality_score < 0.8
EXECUTE FUNCTION send_quality_alert(NEW.machine_id, NEW.quality_score);
```

### 8.2 æ™ºèƒ½äº¤é€š

```sql
-- æ™ºèƒ½äº¤é€šè¾¹ç¼˜éƒ¨ç½²
CREATE EDGE NODE traffic_controller (
    node_id = 'traffic_controller_001',
    location = 'intersection_main_st',
    device_type = 'traffic_controller',
    cpu_cores = 4,
    memory_gb = 8,
    storage_gb = 32
);

-- äº¤é€šæ•°æ®è¡¨
CREATE TABLE traffic_data (
    intersection_id VARCHAR(50),
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    vehicle_count INTEGER,
    average_speed FLOAT,
    congestion_level VARCHAR(20),
    signal_state VARCHAR(20)
) ON EDGE NODE traffic_controller;

-- å®æ—¶äº¤é€šä¼˜åŒ–
CREATE EDGE CONTINUOUS VIEW traffic_optimization AS
SELECT
    intersection_id,
    AVG(vehicle_count) as avg_vehicles,
    AVG(average_speed) as avg_speed,
    CASE
        WHEN AVG(vehicle_count) > 50 THEN 'high_congestion'
        WHEN AVG(vehicle_count) > 20 THEN 'medium_congestion'
        ELSE 'low_congestion'
    END as traffic_status
FROM traffic_data
WHERE timestamp >= NOW() - INTERVAL '5 minutes'
GROUP BY intersection_id;

-- æ™ºèƒ½ä¿¡å·æ§åˆ¶
CREATE EDGE FUNCTION optimize_traffic_signals(
    intersection_id VARCHAR(50)
) RETURNS VARCHAR(20) AS $$
DECLARE
    traffic_status VARCHAR(20);
    optimal_signal VARCHAR(20);
BEGIN
    SELECT traffic_status INTO traffic_status
    FROM traffic_optimization
    WHERE intersection_id = intersection_id;

    CASE traffic_status
        WHEN 'high_congestion' THEN optimal_signal := 'extend_green';
        WHEN 'medium_congestion' THEN optimal_signal := 'normal_cycle';
        ELSE optimal_signal := 'reduce_cycle';
    END CASE;

    RETURN optimal_signal;
END;
$$ LANGUAGE plpgsql;
```

## 9. ç›¸å…³æ¦‚å¿µ

### 9.1 ä¸Šä½æ¦‚å¿µ

- **è¾¹ç¼˜è®¡ç®—**: æ›´å¹¿æ³›çš„è¾¹ç¼˜è®¡ç®—æŠ€æœ¯
- **ç‰©è”ç½‘**: IoTæŠ€æœ¯
- **åˆ†å¸ƒå¼ç³»ç»Ÿ**: åˆ†å¸ƒå¼ç³»ç»ŸæŠ€æœ¯

### 9.2 ä¸‹ä½æ¦‚å¿µ

- **è¾¹ç¼˜èŠ‚ç‚¹**: è¾¹ç¼˜è®¡ç®—èŠ‚ç‚¹
- **ç¦»çº¿æ“ä½œ**: ç¦»çº¿æ•°æ®å¤„ç†
- **è¾¹ç¼˜åŒæ­¥**: è¾¹ç¼˜æ•°æ®åŒæ­¥
- **è¾¹ç¼˜AI**: è¾¹ç¼˜äººå·¥æ™ºèƒ½

### 9.3 å¹³è¡Œæ¦‚å¿µ

- **é›¾è®¡ç®—**: é›¾è®¡ç®—æŠ€æœ¯
- **ç§»åŠ¨è®¡ç®—**: ç§»åŠ¨è®¡ç®—æŠ€æœ¯
- **åµŒå…¥å¼ç³»ç»Ÿ**: åµŒå…¥å¼ç³»ç»ŸæŠ€æœ¯

## 10. å‚è€ƒæ–‡çŒ®

1. PostgreSQL Global Development Group. (2024). PostgreSQL 16.2 Documentation. <https://www.postgresql.org/docs/16/>
2. Shi, W., et al. (2016). Edge computing: Vision and challenges. IEEE Internet of Things Journal, 3(5), 637-646.
3. Satyanarayanan, M. (2017). The emergence of edge computing. Computer, 50(1), 30-39.
4. Bonomi, F., et al. (2012). Fog computing and its role in the internet of things. ACM MCC, 13-16.

## 11. Wikidataå¯¹é½

- **Wikidata ID**: Q192490
- **ç›¸å…³å±æ€§**:
  - P31: Q176165 (instance of: database management system)
  - P178: Q9366 (developer: PostgreSQL Global Development Group)
  - P277: Q193321 (programmed in: C)
  - P348: 2025 (software version)
- **å¤–éƒ¨é“¾æ¥**:
  - <https://www.postgresql.org/docs/current/edge-computing.html>
  - <https://www.postgresql.org/docs/current/edge-deployment.html>
