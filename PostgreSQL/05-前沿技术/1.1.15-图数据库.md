# å›¾æ•°æ®åº“

> **æ–‡æ¡£ç‰ˆæœ¬**: v2.0
> **æœ€åæ›´æ–°**: 2025-11-11
> **ç‰ˆæœ¬è¦†ç›–**: PostgreSQL 17+ | PostgreSQL 18 â­
> **æ–‡æ¡£çŠ¶æ€**: âœ… å·²æ›´æ–°è‡³ PostgreSQL 18
> **ğŸ“‹ ç›¸å…³æ–‡æ¡£**:
>
> - [AI æ—¶ä»£ä¸“é¢˜ - å¤šæ¨¡ä¸€ä½“åŒ–](../ai_view.md) â­â­â­ (v3.0, 2025-11-11)
> - [å›¾æ•°æ®åº“åŠŸèƒ½](../03-é«˜çº§ç‰¹æ€§/03.06-å›¾æ•°æ®åº“åŠŸèƒ½.md) (PG 18+ â­)

## 1. å®šä¹‰

**ä¸­æ–‡**: å›¾æ•°æ®åº“æ˜¯ä¸“é—¨ç”¨äºå­˜å‚¨å’ŒæŸ¥è¯¢å›¾ç»“æ„æ•°æ®çš„æ•°æ®åº“ç³»ç»Ÿï¼Œæ”¯æŒèŠ‚ç‚¹ã€è¾¹å’Œå¤æ‚å…³ç³»çš„é«˜æ•ˆå¤„ç†ã€‚

**English**: Graph databases are specialized database systems for storing and querying graph-structured data, supporting efficient processing of nodes, edges, and complex relationships.

## 2. å½¢å¼åŒ–å®šä¹‰

```latex
\newcommand{\graph}{\mathcal{G}}
\newcommand{\vertex}{\mathcal{V}}
\newcommand{\edge}{\mathcal{E}}

\graph = (\vertex, \edge)

å…¶ä¸­ï¼š
\vertex = \{v_1, v_2, \ldots, v_n\}: é¡¶ç‚¹é›†åˆ
\edge = \{(v_i, v_j) | v_i, v_j \in \vertex\}: è¾¹é›†åˆ
```

## 3. æ ¸å¿ƒå±æ€§

- **å…³ç³»å»ºæ¨¡**: è‡ªç„¶è¡¨è¾¾å¤æ‚å…³ç³»
- **éå†æ€§èƒ½**: é«˜æ•ˆçš„å›¾éå†ç®—æ³•
- **æ¨¡å¼çµæ´»æ€§**: åŠ¨æ€å›¾ç»“æ„æ”¯æŒ
- **æŸ¥è¯¢è¡¨è¾¾èƒ½åŠ›**: å¤æ‚è·¯å¾„æŸ¥è¯¢

## 4. ç†è®ºåŸºç¡€

```latex
\begin{theorem}[å›¾éå†ç®—æ³•]
å›¾æ•°æ®åº“æ”¯æŒä»¥ä¸‹æ ¸å¿ƒç®—æ³•ï¼š
1. æ·±åº¦ä¼˜å…ˆæœç´¢(DFS)ï¼šO(V + E) æ—¶é—´å¤æ‚åº¦
2. å¹¿åº¦ä¼˜å…ˆæœç´¢(BFS)ï¼šO(V + E) æ—¶é—´å¤æ‚åº¦
3. æœ€çŸ­è·¯å¾„ç®—æ³•ï¼šDijkstra O(VÂ² + E)
4. è¿é€šåˆ†é‡ç®—æ³•ï¼šUnion-Find O(V + E)
\end{theorem}
```

## 5. ç®—æ³•å®ç°

### 5.1 å›¾æ•°æ®å­˜å‚¨

```sql
-- åˆ›å»ºé¡¶ç‚¹è¡¨
CREATE TABLE users (
    user_id INTEGER PRIMARY KEY,
    name VARCHAR(100),
    age INTEGER,
    location VARCHAR(100)
);

-- åˆ›å»ºè¾¹è¡¨
CREATE TABLE friendships (
    friendship_id SERIAL PRIMARY KEY,
    user1_id INTEGER REFERENCES users(user_id),
    user2_id INTEGER REFERENCES users(user_id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 5.2 å›¾æŸ¥è¯¢

```sql
-- ä½¿ç”¨é€’å½’CTEè¿›è¡Œå›¾éå†
WITH RECURSIVE friend_paths AS (
    -- åŸºç¡€æƒ…å†µï¼šç›´æ¥æœ‹å‹
    SELECT
        user1_id as start_user,
        user2_id as end_user,
        ARRAY[user1_id, user2_id] as path,
        1 as depth
    FROM friendships
    WHERE user1_id = 1001

    UNION ALL

    -- é€’å½’æƒ…å†µï¼šæœ‹å‹çš„æœ‹å‹
    SELECT
        fp.start_user,
        f.user2_id,
        fp.path || f.user2_id,
        fp.depth + 1
    FROM friend_paths fp
    JOIN friendships f ON fp.end_user = f.user1_id
    WHERE fp.depth < 3
    AND f.user2_id != ALL(fp.path)
)
SELECT DISTINCT end_user, depth
FROM friend_paths
ORDER BY depth, end_user;
```

### 5.3 å›¾åˆ†æ

```sql
-- è®¡ç®—ç”¨æˆ·ä¸­å¿ƒæ€§
WITH user_degrees AS (
    SELECT
        user_id,
        COUNT(*) as degree
    FROM (
        SELECT user1_id as user_id FROM friendships
        UNION ALL
        SELECT user2_id as user_id FROM friendships
    ) all_connections
    GROUP BY user_id
)
SELECT
    u.name,
    ud.degree,
    CASE
        WHEN ud.degree > 50 THEN 'é«˜å½±å“åŠ›'
        WHEN ud.degree > 20 THEN 'ä¸­ç­‰å½±å“åŠ›'
        ELSE 'æ™®é€šç”¨æˆ·'
    END as influence_level
FROM users u
JOIN user_degrees ud ON u.user_id = ud.user_id
ORDER BY ud.degree DESC;
```

## 6. åº”ç”¨å®ä¾‹

### 6.1 ç¤¾äº¤ç½‘ç»œåˆ†æ

```sql
-- å½±å“åŠ›ä¼ æ’­åˆ†æ
WITH RECURSIVE influence_spread AS (
    SELECT
        from_node as influencer,
        to_node as influenced,
        1 as level
    FROM relationships
    WHERE rel_type = 'follows' AND from_node = 1001

    UNION ALL

    SELECT
        is.influencer,
        r.to_node,
        is.level + 1
    FROM influence_spread is
    JOIN relationships r ON is.influenced = r.from_node
    WHERE r.rel_type = 'follows' AND is.level < 3
)
SELECT level, COUNT(DISTINCT influenced) as reach_count
FROM influence_spread
GROUP BY level
ORDER BY level;
```

### 6.2 æ¨èç³»ç»Ÿ

```sql
-- åŸºäºå›¾çš„æ¨èç®—æ³•
WITH user_similarity AS (
    SELECT
        u1.user_id as user1,
        u2.user_id as user2,
        COUNT(DISTINCT f1.user2_id) as common_friends
    FROM users u1
    JOIN friendships f1 ON u1.user_id = f1.user1_id
    JOIN friendships f2 ON f1.user2_id = f2.user1_id
    JOIN users u2 ON f2.user2_id = u2.user_id
    WHERE u1.user_id != u2.user_id
    GROUP BY u1.user_id, u2.user_id
    HAVING COUNT(DISTINCT f1.user2_id) > 2
)
SELECT
    us.user2 as recommended_user,
    u.name as recommended_name,
    us.common_friends as similarity_score
FROM user_similarity us
JOIN users u ON us.user2 = u.user_id
WHERE us.user1 = 1001
ORDER BY us.common_friends DESC
LIMIT 10;
```

## 7. æ€§èƒ½åˆ†æ

- **éå†æ€§èƒ½**: O(V + E) åŸºç¡€å¤æ‚åº¦
- **å­˜å‚¨å¼€é”€**: èŠ‚ç‚¹ + è¾¹ + å±æ€§æ•°æ®
- **æŸ¥è¯¢å»¶è¿Ÿ**: å–å†³äºå›¾å¤§å°å’ŒæŸ¥è¯¢å¤æ‚åº¦
- **æ‰©å±•æ€§**: æ”¯æŒåˆ†å¸ƒå¼å›¾å¤„ç†

## 8. ç›¸å…³æ¦‚å¿µ

- **ä¸Šä½æ¦‚å¿µ**: æ•°æ®åº“ç³»ç»Ÿã€å›¾è®º
- **ä¸‹ä½æ¦‚å¿µ**: å›¾éå†ã€è·¯å¾„æŸ¥è¯¢ã€å›¾ç®—æ³•
- **å¹³è¡Œæ¦‚å¿µ**: å…³ç³»æ•°æ®åº“ã€æ–‡æ¡£æ•°æ®åº“

## 9. å‚è€ƒæ–‡çŒ®

1. Angles, R., & Gutierrez, C. (2008). Survey of graph database models.
2. PostgreSQL Global Development Group. (2024). PostgreSQL 16.2 Documentation.

## 10. Wikidataå¯¹é½

- **ID**: Q186929 (graph database)
- **å±æ€§**: database concept, graph theory
- **é“¾æ¥**: <https://en.wikipedia.org/wiki/Graph_database>
