# æ‰§è¡Œè®¡åˆ’ä¸æ€§èƒ½è°ƒä¼˜

> ğŸ“– **é€‚ç”¨ç‰ˆæœ¬**: PostgreSQL 17.xï¼ˆæ¨èï¼‰ | 16.xï¼ˆå…¼å®¹ï¼‰ | 15.xï¼ˆå…¼å®¹ï¼‰
> ğŸ“… **æœ€åæ›´æ–°**: 2025-10-30
> ğŸ¯ **æ–‡æ¡£ç›®æ ‡**: æ·±å…¥ç†è§£æ‰§è¡Œè®¡åˆ’è§£è¯»ã€æ€§èƒ½åˆ†æå’ŒæŸ¥è¯¢è°ƒä¼˜å®è·µ
> ğŸ†• **PostgreSQL 17æ€§èƒ½æ”¹è¿›**: å¤æ‚æŸ¥è¯¢æ€§èƒ½æå‡30-40%ã€æ›´å‡†ç¡®çš„æ‰§è¡Œè®¡åˆ’ä¼°ç®—ã€æ”¹è¿›çš„EXPLAINåˆ†æ

---

## ç›®å½•

- [æ‰§è¡Œè®¡åˆ’ä¸æ€§èƒ½è°ƒä¼˜](#æ‰§è¡Œè®¡åˆ’ä¸æ€§èƒ½è°ƒä¼˜)
  - [ç›®å½•](#ç›®å½•)
  - [1. å®šä¹‰ä¸å½¢å¼åŒ–](#1-å®šä¹‰ä¸å½¢å¼åŒ–)
    - [1.1 æ¦‚å¿µå®šä¹‰](#11-æ¦‚å¿µå®šä¹‰)
    - [1.2 å½¢å¼åŒ–å®šä¹‰](#12-å½¢å¼åŒ–å®šä¹‰)
    - [1.3 æ ¸å¿ƒå±æ€§](#13-æ ¸å¿ƒå±æ€§)
  - [2. ç†è®ºåŸºç¡€](#2-ç†è®ºåŸºç¡€)
    - [2.1 æ‰§è¡Œè®¡åˆ’ç†è®º](#21-æ‰§è¡Œè®¡åˆ’ç†è®º)
    - [2.2 æ€§èƒ½è°ƒä¼˜ç†è®º](#22-æ€§èƒ½è°ƒä¼˜ç†è®º)
  - [3. æ‰§è¡Œè®¡åˆ’åˆ†æ](#3-æ‰§è¡Œè®¡åˆ’åˆ†æ)
    - [3.1 åŸºæœ¬æ‰§è¡Œè®¡åˆ’](#31-åŸºæœ¬æ‰§è¡Œè®¡åˆ’)
    - [3.2 æ‰§è¡Œè®¡åˆ’èŠ‚ç‚¹ç±»å‹](#32-æ‰§è¡Œè®¡åˆ’èŠ‚ç‚¹ç±»å‹)
    - [3.3 æ‰§è¡Œè®¡åˆ’ç»Ÿè®¡ä¿¡æ¯](#33-æ‰§è¡Œè®¡åˆ’ç»Ÿè®¡ä¿¡æ¯)
  - [4. æ€§èƒ½ç›‘æ§](#4-æ€§èƒ½ç›‘æ§)
    - [4.1 æŸ¥è¯¢æ€§èƒ½ç›‘æ§](#41-æŸ¥è¯¢æ€§èƒ½ç›‘æ§)
    - [4.2 ç³»ç»Ÿæ€§èƒ½ç›‘æ§](#42-ç³»ç»Ÿæ€§èƒ½ç›‘æ§)
    - [4.3 I/Oæ€§èƒ½ç›‘æ§](#43-ioæ€§èƒ½ç›‘æ§)
  - [5. æ€§èƒ½è°ƒä¼˜ç­–ç•¥](#5-æ€§èƒ½è°ƒä¼˜ç­–ç•¥)
    - [5.1 æŸ¥è¯¢ä¼˜åŒ–](#51-æŸ¥è¯¢ä¼˜åŒ–)
    - [5.2 ç³»ç»Ÿå‚æ•°è°ƒä¼˜](#52-ç³»ç»Ÿå‚æ•°è°ƒä¼˜)
    - [5.3 å¹¶å‘å‚æ•°è°ƒä¼˜](#53-å¹¶å‘å‚æ•°è°ƒä¼˜)
  - [6. æ€§èƒ½åˆ†æå·¥å…·](#6-æ€§èƒ½åˆ†æå·¥å…·)
    - [6.1 æ‰§è¡Œè®¡åˆ’åˆ†æ](#61-æ‰§è¡Œè®¡åˆ’åˆ†æ)
    - [6.2 æ€§èƒ½åŸºå‡†æµ‹è¯•](#62-æ€§èƒ½åŸºå‡†æµ‹è¯•)
    - [6.3 æ€§èƒ½ç›‘æ§ä»ªè¡¨æ¿](#63-æ€§èƒ½ç›‘æ§ä»ªè¡¨æ¿)
  - [7. å®é™…åº”ç”¨æ¡ˆä¾‹](#7-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [7.1 æ…¢æŸ¥è¯¢ä¼˜åŒ–](#71-æ…¢æŸ¥è¯¢ä¼˜åŒ–)
    - [7.2 æ‰¹é‡æ“ä½œä¼˜åŒ–](#72-æ‰¹é‡æ“ä½œä¼˜åŒ–)
    - [7.3 åˆ†åŒºè¡¨æ€§èƒ½ä¼˜åŒ–](#73-åˆ†åŒºè¡¨æ€§èƒ½ä¼˜åŒ–)
  - [8. æ€§èƒ½è°ƒä¼˜æœ€ä½³å®è·µ](#8-æ€§èƒ½è°ƒä¼˜æœ€ä½³å®è·µ)
    - [8.1 ç´¢å¼•ä¼˜åŒ–ç­–ç•¥](#81-ç´¢å¼•ä¼˜åŒ–ç­–ç•¥)
    - [8.2 æŸ¥è¯¢ä¼˜åŒ–ç­–ç•¥](#82-æŸ¥è¯¢ä¼˜åŒ–ç­–ç•¥)
    - [8.3 ç³»ç»Ÿé…ç½®ä¼˜åŒ–](#83-ç³»ç»Ÿé…ç½®ä¼˜åŒ–)
  - [9. ç›¸å…³æ¦‚å¿µ](#9-ç›¸å…³æ¦‚å¿µ)
    - [9.1 ä¸Šä½æ¦‚å¿µ](#91-ä¸Šä½æ¦‚å¿µ)
    - [9.2 ä¸‹ä½æ¦‚å¿µ](#92-ä¸‹ä½æ¦‚å¿µ)
    - [9.3 å¹³è¡Œæ¦‚å¿µ](#93-å¹³è¡Œæ¦‚å¿µ)
  - [10. å‚è€ƒæ–‡çŒ®](#10-å‚è€ƒæ–‡çŒ®)
  - [11. Wikidataå¯¹é½](#11-wikidataå¯¹é½)

---

## 1. å®šä¹‰ä¸å½¢å¼åŒ–

### 1.1 æ¦‚å¿µå®šä¹‰

**ä¸­æ–‡å®šä¹‰**: æ‰§è¡Œè®¡åˆ’æ˜¯æ•°æ®åº“ç³»ç»Ÿå°†æŸ¥è¯¢è½¬æ¢ä¸ºå…·ä½“æ‰§è¡Œæ­¥éª¤çš„è¯¦ç»†æ–¹æ¡ˆï¼Œæ€§èƒ½è°ƒä¼˜æ˜¯é€šè¿‡åˆ†ææ‰§è¡Œè®¡åˆ’å’Œç³»ç»Ÿæ€§èƒ½æŒ‡æ ‡æ¥ä¼˜åŒ–æŸ¥è¯¢æ€§èƒ½çš„è¿‡ç¨‹ã€‚

**English Definition**: An execution plan is a detailed scheme that transforms queries into specific execution steps in database systems. Performance tuning is the process of optimizing query performance by analyzing execution plans and system performance metrics.

### 1.2 å½¢å¼åŒ–å®šä¹‰

```latex
% æ•°å­¦ç¬¦å·å®šä¹‰
\newcommand{\plan}{\mathcal{P}}
\newcommand{\node}{\mathcal{N}}
\newcommand{\cost}{\mathcal{C}}
\newcommand{\time}{\mathcal{T}}

% æ‰§è¡Œè®¡åˆ’çš„å½¢å¼åŒ–å®šä¹‰
\plan = \{n_1, n_2, \ldots, n_k\}

å…¶ä¸­æ¯ä¸ªèŠ‚ç‚¹ n_i = (type_i, cost_i, time_i, rows_i, width_i) è¡¨ç¤ºï¼š
- type_i: æ“ä½œç±»å‹
- cost_i: æ‰§è¡Œä»£ä»·
- time_i: æ‰§è¡Œæ—¶é—´
- rows_i: è¾“å‡ºè¡Œæ•°
- width_i: è¡Œå®½åº¦
```

### 1.3 æ ¸å¿ƒå±æ€§

- **å‡†ç¡®æ€§**: æ‰§è¡Œè®¡åˆ’åæ˜ çœŸå®æ‰§è¡Œè¿‡ç¨‹
- **å¯è¯»æ€§**: æ‰§è¡Œè®¡åˆ’æ˜“äºç†è§£å’Œåˆ†æ
- **å¯ä¼˜åŒ–æ€§**: æ”¯æŒæ€§èƒ½è°ƒä¼˜å’Œä¼˜åŒ–
- **å¯é¢„æµ‹æ€§**: èƒ½å¤Ÿé¢„æµ‹æ‰§è¡Œæ€§èƒ½

## 2. ç†è®ºåŸºç¡€

### 2.1 æ‰§è¡Œè®¡åˆ’ç†è®º

```latex
\begin{theorem}[æ‰§è¡Œè®¡åˆ’æ­£ç¡®æ€§]
æ‰§è¡Œè®¡åˆ’Pæ­£ç¡®æ‰§è¡ŒæŸ¥è¯¢Qï¼Œå½“ä¸”ä»…å½“ï¼š
1. è¯­ä¹‰ç­‰ä»·æ€§ï¼š\text{result}(P) = \text{result}(Q)
2. ä»£ä»·æœ€ä¼˜æ€§ï¼š\cost(P) = \min_{P' \in \mathcal{P}(Q)} \cost(P')
3. æ—¶é—´å¯è¡Œæ€§ï¼š\time(P) \leq \text{timeout}
\end{theorem}
```

### 2.2 æ€§èƒ½è°ƒä¼˜ç†è®º

```latex
\begin{theorem}[æ€§èƒ½è°ƒä¼˜æœ€ä¼˜åŒ–]
æ€§èƒ½è°ƒä¼˜çš„ç›®æ ‡æ˜¯ï¼š
\min_{\text{config}} \sum_{i=1}^{n} \time(\query_i, \text{config})

å…¶ä¸­configæ˜¯ç³»ç»Ÿé…ç½®å‚æ•°ï¼Œquery_iæ˜¯æŸ¥è¯¢é›†åˆã€‚
\end{theorem}
```

## 3. æ‰§è¡Œè®¡åˆ’åˆ†æ

### 3.1 åŸºæœ¬æ‰§è¡Œè®¡åˆ’

```sql
-- åŸºæœ¬æ‰§è¡Œè®¡åˆ’
EXPLAIN SELECT * FROM employees WHERE emp_id = 1001;

-- è¯¦ç»†æ‰§è¡Œè®¡åˆ’
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT e.name, d.dept_name, e.salary
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id
WHERE e.salary > 50000;

-- æ‰§è¡Œè®¡åˆ’æ ¼å¼
EXPLAIN (FORMAT JSON)
SELECT * FROM employees WHERE dept_id = 1;
```

### 3.2 æ‰§è¡Œè®¡åˆ’èŠ‚ç‚¹ç±»å‹

```sql
-- æ‰«æèŠ‚ç‚¹
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees;  -- Seq Scan

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE emp_id = 1001;  -- Index Scan

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE dept_id = 1 AND salary > 50000;  -- Bitmap Scan

-- è¿æ¥èŠ‚ç‚¹
EXPLAIN (ANALYZE, BUFFERS)
SELECT e.name, d.dept_name
FROM employees e, departments d
WHERE e.dept_id = d.dept_id;  -- Nested Loop

EXPLAIN (ANALYZE, BUFFERS)
SELECT e.name, d.dept_name
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id;  -- Hash Join

-- èšåˆèŠ‚ç‚¹
EXPLAIN (ANALYZE, BUFFERS)
SELECT dept_id, COUNT(*), AVG(salary)
FROM employees
GROUP BY dept_id;  -- Hash Aggregate
```

### 3.3 æ‰§è¡Œè®¡åˆ’ç»Ÿè®¡ä¿¡æ¯

```sql
-- æŸ¥çœ‹æ‰§è¡Œè®¡åˆ’ç»Ÿè®¡
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT e.name, d.dept_name, e.salary
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id
WHERE e.salary > 50000
ORDER BY e.salary DESC;

-- æ‰§è¡Œè®¡åˆ’æˆæœ¬åˆ†æ
EXPLAIN (COSTS, BUFFERS)
SELECT * FROM employees WHERE dept_id = 1;
```

## 4. æ€§èƒ½ç›‘æ§

### 4.1 æŸ¥è¯¢æ€§èƒ½ç›‘æ§

```sql
-- æŸ¥çœ‹å½“å‰æ´»åŠ¨æŸ¥è¯¢
SELECT
    pid,
    usename,
    application_name,
    client_addr,
    backend_start,
    state,
    query_start,
    state_change,
    query
FROM pg_stat_activity
WHERE state = 'active'
ORDER BY query_start;

-- æŸ¥çœ‹æŸ¥è¯¢ç»Ÿè®¡
SELECT
    query,
    calls,
    total_time,
    mean_time,
    stddev_time,
    rows,
    100.0 * shared_blks_hit / nullif(shared_blks_hit + shared_blks_read, 0) AS hit_percent
FROM pg_stat_statements
ORDER BY total_time DESC
LIMIT 10;
```

### 4.2 ç³»ç»Ÿæ€§èƒ½ç›‘æ§

```sql
-- æ•°æ®åº“æ€§èƒ½ç»Ÿè®¡
SELECT
    datname,
    numbackends,
    xact_commit,
    xact_rollback,
    blks_read,
    blks_hit,
    tup_returned,
    tup_fetched,
    tup_inserted,
    tup_updated,
    tup_deleted
FROM pg_stat_database
WHERE datname = current_database();

-- è¡¨æ€§èƒ½ç»Ÿè®¡
SELECT
    schemaname,
    tablename,
    seq_scan,
    seq_tup_read,
    idx_scan,
    idx_tup_fetch,
    n_tup_ins,
    n_tup_upd,
    n_tup_del,
    n_live_tup,
    n_dead_tup
FROM pg_stat_user_tables
ORDER BY seq_scan DESC;
```

### 4.3 I/Oæ€§èƒ½ç›‘æ§

```sql
-- I/Oç»Ÿè®¡ä¿¡æ¯
SELECT
    schemaname,
    tablename,
    heap_blks_read,
    heap_blks_hit,
    idx_blks_read,
    idx_blks_hit,
    toast_blks_read,
    toast_blks_hit,
    tidx_blks_read,
    tidx_blks_hit
FROM pg_statio_user_tables
ORDER BY heap_blks_read + heap_blks_hit DESC;

-- ç¼“å†²åŒºå‘½ä¸­ç‡
SELECT
    round(100.0 * sum(blks_hit) / (sum(blks_hit) + sum(blks_read)), 2) as hit_ratio
FROM pg_stat_database;
```

## 5. æ€§èƒ½è°ƒä¼˜ç­–ç•¥

### 5.1 æŸ¥è¯¢ä¼˜åŒ–

```sql
-- æŸ¥è¯¢é‡å†™ä¼˜åŒ–
-- ä¼˜åŒ–å‰
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees
WHERE emp_id IN (
    SELECT emp_id FROM employees WHERE salary > 50000
);

-- ä¼˜åŒ–å
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees
WHERE salary > 50000;

-- ç´¢å¼•ä¼˜åŒ–
CREATE INDEX idx_emp_salary ON employees (salary);
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE salary > 50000;

-- å¤åˆç´¢å¼•ä¼˜åŒ–
CREATE INDEX idx_emp_dept_salary ON employees (dept_id, salary);
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE dept_id = 1 AND salary > 50000;
```

### 5.2 ç³»ç»Ÿå‚æ•°è°ƒä¼˜

```sql
-- å†…å­˜å‚æ•°è°ƒä¼˜
SHOW shared_buffers;
SHOW work_mem;
SHOW maintenance_work_mem;
SHOW effective_cache_size;

-- è®¾ç½®å†…å­˜å‚æ•°
SET shared_buffers = '256MB';
SET work_mem = '4MB';
SET maintenance_work_mem = '64MB';
SET effective_cache_size = '1GB';

-- æ£€æŸ¥ç‚¹å‚æ•°è°ƒä¼˜
SHOW checkpoint_timeout;
SHOW max_wal_size;
SHOW min_wal_size;
SHOW checkpoint_completion_target;

-- è®¾ç½®æ£€æŸ¥ç‚¹å‚æ•°
SET checkpoint_timeout = '15min';
SET max_wal_size = '1GB';
SET min_wal_size = '80MB';
SET checkpoint_completion_target = 0.9;
```

### 5.3 å¹¶å‘å‚æ•°è°ƒä¼˜

```sql
-- å¹¶å‘å‚æ•°
SHOW max_connections;
SHOW max_prepared_transactions;
SHOW max_locks_per_transaction;
SHOW max_pred_locks_per_transaction;

-- è®¾ç½®å¹¶å‘å‚æ•°
SET max_connections = 100;
SET max_prepared_transactions = 0;
SET max_locks_per_transaction = 64;
SET max_pred_locks_per_transaction = 64;
```

## 6. æ€§èƒ½åˆ†æå·¥å…·

### 6.1 æ‰§è¡Œè®¡åˆ’åˆ†æ

```sql
-- åˆ›å»ºæ‰§è¡Œè®¡åˆ’åˆ†æå‡½æ•°
CREATE OR REPLACE FUNCTION analyze_execution_plan(query_text text)
RETURNS TABLE(
    node_type text,
    cost_start numeric,
    cost_total numeric,
    actual_time numeric,
    rows_estimated bigint,
    rows_actual bigint,
    width_estimated integer
) AS $$
BEGIN
    RETURN QUERY
    EXECUTE format('EXPLAIN (ANALYZE, BUFFERS, FORMAT JSON) %s', query_text);
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨æ‰§è¡Œè®¡åˆ’åˆ†æ
SELECT * FROM analyze_execution_plan('SELECT * FROM employees WHERE salary > 50000');
```

### 6.2 æ€§èƒ½åŸºå‡†æµ‹è¯•

```sql
-- åˆ›å»ºæ€§èƒ½æµ‹è¯•å‡½æ•°
CREATE OR REPLACE FUNCTION benchmark_query(query_text text, iterations integer DEFAULT 10)
RETURNS TABLE(
    iteration integer,
    execution_time numeric,
    rows_returned bigint
) AS $$
DECLARE
    i integer;
    start_time timestamp;
    end_time timestamp;
    result_rows bigint;
BEGIN
    FOR i IN 1..iterations LOOP
        start_time := clock_timestamp();
        EXECUTE format('SELECT COUNT(*) FROM (%s) t', query_text) INTO result_rows;
        end_time := clock_timestamp();

        RETURN QUERY SELECT
            i,
            EXTRACT(EPOCH FROM (end_time - start_time)) * 1000,
            result_rows;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨æ€§èƒ½æµ‹è¯•
SELECT * FROM benchmark_query('SELECT * FROM employees WHERE salary > 50000', 5);
```

### 6.3 æ€§èƒ½ç›‘æ§ä»ªè¡¨æ¿

```sql
-- åˆ›å»ºæ€§èƒ½ç›‘æ§è§†å›¾
CREATE OR REPLACE VIEW performance_dashboard AS
SELECT
    'Database' as metric_type,
    datname as metric_name,
    round(100.0 * blks_hit / (blks_hit + blks_read), 2) as hit_ratio,
    tup_returned + tup_fetched + tup_inserted + tup_updated + tup_deleted as total_operations
FROM pg_stat_database
WHERE datname = current_database()

UNION ALL

SELECT
    'Table' as metric_type,
    tablename as metric_name,
    round(100.0 * heap_blks_hit / (heap_blks_hit + heap_blks_read), 2) as hit_ratio,
    n_live_tup as total_operations
FROM pg_stat_user_tables
ORDER BY metric_type, hit_ratio DESC;

-- æŸ¥çœ‹æ€§èƒ½ä»ªè¡¨æ¿
SELECT * FROM performance_dashboard;
```

## 7. å®é™…åº”ç”¨æ¡ˆä¾‹

### 7.1 æ…¢æŸ¥è¯¢ä¼˜åŒ–

```sql
-- è¯†åˆ«æ…¢æŸ¥è¯¢
SELECT
    query,
    calls,
    total_time,
    mean_time,
    stddev_time,
    rows,
    100.0 * shared_blks_hit / nullif(shared_blks_hit + shared_blks_read, 0) AS hit_percent
FROM pg_stat_statements
WHERE mean_time > 1000  -- å¹³å‡æ‰§è¡Œæ—¶é—´è¶…è¿‡1ç§’
ORDER BY mean_time DESC
LIMIT 10;

-- ä¼˜åŒ–æ…¢æŸ¥è¯¢
-- åŸå§‹æŸ¥è¯¢
EXPLAIN (ANALYZE, BUFFERS)
SELECT e.name, d.dept_name, p.project_name
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id
JOIN projects p ON e.emp_id = p.manager_id
WHERE e.salary > 50000 AND d.budget > 1000000;

-- åˆ›å»ºä¼˜åŒ–ç´¢å¼•
CREATE INDEX idx_emp_salary ON employees (salary);
CREATE INDEX idx_dept_budget ON departments (budget);
CREATE INDEX idx_proj_manager ON projects (manager_id);

-- ä¼˜åŒ–åæŸ¥è¯¢
EXPLAIN (ANALYZE, BUFFERS)
SELECT e.name, d.dept_name, p.project_name
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id
JOIN projects p ON e.emp_id = p.manager_id
WHERE e.salary > 50000 AND d.budget > 1000000;
```

### 7.2 æ‰¹é‡æ“ä½œä¼˜åŒ–

```sql
-- æ‰¹é‡æ’å…¥ä¼˜åŒ–
-- ä¼˜åŒ–å‰
DO $$
DECLARE
    i integer;
BEGIN
    FOR i IN 1..10000 LOOP
        INSERT INTO employees (name, dept_id, salary)
        VALUES ('Employee' || i, (i % 10) + 1, 30000 + (i % 50000));
    END LOOP;
END $$;

-- ä¼˜åŒ–å
INSERT INTO employees (name, dept_id, salary)
SELECT
    'Employee' || generate_series(1, 10000),
    (generate_series(1, 10000) % 10) + 1,
    30000 + (generate_series(1, 10000) % 50000);

-- æ‰¹é‡æ›´æ–°ä¼˜åŒ–
-- ä¼˜åŒ–å‰
UPDATE employees SET salary = salary * 1.1 WHERE dept_id = 1;
UPDATE employees SET salary = salary * 1.1 WHERE dept_id = 2;
UPDATE employees SET salary = salary * 1.1 WHERE dept_id = 3;

-- ä¼˜åŒ–å
UPDATE employees SET salary = salary * 1.1 WHERE dept_id IN (1, 2, 3);
```

### 7.3 åˆ†åŒºè¡¨æ€§èƒ½ä¼˜åŒ–

```sql
-- åˆ†åŒºè¡¨æ€§èƒ½ä¼˜åŒ–
CREATE TABLE sales (
    id BIGSERIAL,
    sale_date DATE,
    amount DECIMAL(10,2),
    customer_id INTEGER
) PARTITION BY RANGE (sale_date);

-- åˆ›å»ºåˆ†åŒº
CREATE TABLE sales_2023 PARTITION OF sales
FOR VALUES FROM ('2023-01-01') TO ('2024-01-01');

CREATE TABLE sales_2024 PARTITION OF sales
FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');

-- åˆ†åŒºæŸ¥è¯¢ä¼˜åŒ–
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM sales WHERE sale_date >= '2024-01-01' AND sale_date < '2024-02-01';

-- åˆ†åŒºè£å‰ª
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM sales WHERE sale_date BETWEEN '2024-01-01' AND '2024-12-31';
```

## 8. æ€§èƒ½è°ƒä¼˜æœ€ä½³å®è·µ

### 8.1 ç´¢å¼•ä¼˜åŒ–ç­–ç•¥

```sql
-- ç´¢å¼•ä¼˜åŒ–ç­–ç•¥
-- 1. åˆ†ææŸ¥è¯¢æ¨¡å¼
SELECT
    schemaname,
    tablename,
    attname,
    n_distinct,
    correlation
FROM pg_stats
WHERE schemaname = 'public'
ORDER BY tablename, attname;

-- 2. åˆ›å»ºå¤åˆç´¢å¼•
CREATE INDEX idx_emp_optimized ON employees (dept_id, salary, hire_date);

-- 3. ç›‘æ§ç´¢å¼•ä½¿ç”¨
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE idx_scan = 0;  -- æœªä½¿ç”¨çš„ç´¢å¼•
```

### 8.2 æŸ¥è¯¢ä¼˜åŒ–ç­–ç•¥

```sql
-- æŸ¥è¯¢ä¼˜åŒ–ç­–ç•¥
-- 1. ä½¿ç”¨é€‚å½“çš„JOINç±»å‹
EXPLAIN (ANALYZE, BUFFERS)
SELECT e.name, d.dept_name
FROM employees e
INNER JOIN departments d ON e.dept_id = d.dept_id;

-- 2. é¿å…SELECT *
EXPLAIN (ANALYZE, BUFFERS)
SELECT emp_id, name, salary FROM employees WHERE dept_id = 1;

-- 3. ä½¿ç”¨LIMITé™åˆ¶ç»“æœé›†
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees ORDER BY salary DESC LIMIT 10;
```

### 8.3 ç³»ç»Ÿé…ç½®ä¼˜åŒ–

```sql
-- ç³»ç»Ÿé…ç½®ä¼˜åŒ–
-- 1. å†…å­˜é…ç½®
ALTER SYSTEM SET shared_buffers = '256MB';
ALTER SYSTEM SET work_mem = '4MB';
ALTER SYSTEM SET maintenance_work_mem = '64MB';

-- 2. æ£€æŸ¥ç‚¹é…ç½®
ALTER SYSTEM SET checkpoint_timeout = '15min';
ALTER SYSTEM SET max_wal_size = '1GB';
ALTER SYSTEM SET checkpoint_completion_target = 0.9;

-- 3. å¹¶å‘é…ç½®
ALTER SYSTEM SET max_connections = 100;
ALTER SYSTEM SET max_prepared_transactions = 0;

-- é‡æ–°åŠ è½½é…ç½®
SELECT pg_reload_conf();
```

## 9. ç›¸å…³æ¦‚å¿µ

### 9.1 ä¸Šä½æ¦‚å¿µ

- **æŸ¥è¯¢ä¼˜åŒ–**: æ›´å¹¿æ³›çš„æŸ¥è¯¢ä¼˜åŒ–æœºåˆ¶
- **æ€§èƒ½ç®¡ç†**: ç³»ç»Ÿæ€§èƒ½ç®¡ç†
- **æ•°æ®åº“è°ƒä¼˜**: æ•°æ®åº“æ€§èƒ½è°ƒä¼˜

### 9.2 ä¸‹ä½æ¦‚å¿µ

- **æ‰§è¡Œè®¡åˆ’**: æŸ¥è¯¢æ‰§è¡Œè®¡åˆ’
- **æ€§èƒ½ç›‘æ§**: æ€§èƒ½ç›‘æ§æœºåˆ¶
- **ç´¢å¼•ä¼˜åŒ–**: ç´¢å¼•æ€§èƒ½ä¼˜åŒ–
- **æŸ¥è¯¢é‡å†™**: æŸ¥è¯¢ä¼˜åŒ–æŠ€æœ¯

### 9.3 å¹³è¡Œæ¦‚å¿µ

- **åŸºå‡†æµ‹è¯•**: æ€§èƒ½åŸºå‡†æµ‹è¯•
- **è´Ÿè½½æµ‹è¯•**: ç³»ç»Ÿè´Ÿè½½æµ‹è¯•
- **å®¹é‡è§„åˆ’**: ç³»ç»Ÿå®¹é‡è§„åˆ’

## 10. å‚è€ƒæ–‡çŒ®

1. PostgreSQL Global Development Group. (2024). PostgreSQL 16.2 Documentation. <https://www.postgresql.org/docs/16/>
2. Selinger, P. G., et al. (1979). Access path selection in a relational database management system. ACM SIGMOD Record, 8(2), 23-34.
3. Graefe, G. (1995). The Cascades framework for query optimization. IEEE Data Engineering Bulletin, 18(3), 19-29.
4. Ioannidis, Y. E. (1996). Query optimization. ACM Computing Surveys, 28(1), 121-123.

## 11. Wikidataå¯¹é½

- **Wikidata ID**: Q192490
- **ç›¸å…³å±æ€§**:
  - P31: Q176165 (instance of: database management system)
  - P178: Q9366 (developer: PostgreSQL Global Development Group)
  - P277: Q193321 (programmed in: C)
  - P348: 16.2 (software version)
- **å¤–éƒ¨é“¾æ¥**:
  - <https://www.postgresql.org/docs/current/using-explain.html>
  - <https://www.postgresql.org/docs/current/monitoring-stats.html>
