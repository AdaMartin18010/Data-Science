# ç»Ÿè®¡ä¿¡æ¯ä¸ä»£ä»·æ¨¡å‹

> ğŸ“– **é€‚ç”¨ç‰ˆæœ¬**: PostgreSQL 17.xï¼ˆæ¨èï¼‰ | 16.xï¼ˆå…¼å®¹ï¼‰ | 15.xï¼ˆå…¼å®¹ï¼‰
> ğŸ“… **æœ€åæ›´æ–°**: 2025-10-30
> ğŸ¯ **æ–‡æ¡£ç›®æ ‡**: æ·±å…¥ç†è§£ç»Ÿè®¡ä¿¡æ¯æ”¶é›†ã€ä»£ä»·æ¨¡å‹è®¡ç®—å’ŒæŸ¥è¯¢ä¼˜åŒ–å†³ç­–

> ğŸ†• **PostgreSQL 17ç»Ÿè®¡æ”¹è¿›**: æ”¹è¿›çš„å¤šå˜é‡ç»Ÿè®¡å‡†ç¡®æ€§ã€æ›´ç²¾ç»†çš„ç›´æ–¹å›¾ã€è‡ªé€‚åº”ç»Ÿè®¡ä¿¡æ¯æ›´æ–°

---

## ç›®å½•

- [ç»Ÿè®¡ä¿¡æ¯ä¸ä»£ä»·æ¨¡å‹](#ç»Ÿè®¡ä¿¡æ¯ä¸ä»£ä»·æ¨¡å‹)
  - [ç›®å½•](#ç›®å½•)
  - [1. å®šä¹‰ä¸å½¢å¼åŒ–](#1-å®šä¹‰ä¸å½¢å¼åŒ–)
    - [1.1 æ¦‚å¿µå®šä¹‰](#11-æ¦‚å¿µå®šä¹‰)
    - [1.2 å½¢å¼åŒ–å®šä¹‰](#12-å½¢å¼åŒ–å®šä¹‰)
    - [1.3 æ ¸å¿ƒå±æ€§](#13-æ ¸å¿ƒå±æ€§)
  - [2. ç†è®ºåŸºç¡€](#2-ç†è®ºåŸºç¡€)
    - [2.1 ç»Ÿè®¡ä¿¡æ¯ç†è®º](#21-ç»Ÿè®¡ä¿¡æ¯ç†è®º)
    - [2.2 ä»£ä»·æ¨¡å‹ç†è®º](#22-ä»£ä»·æ¨¡å‹ç†è®º)
    - [2.3 é€‰æ‹©æ€§ä¼°è®¡ç†è®º](#23-é€‰æ‹©æ€§ä¼°è®¡ç†è®º)
  - [3. PostgreSQLç»Ÿè®¡ä¿¡æ¯](#3-postgresqlç»Ÿè®¡ä¿¡æ¯)
    - [3.1 è¡¨çº§ç»Ÿè®¡ä¿¡æ¯](#31-è¡¨çº§ç»Ÿè®¡ä¿¡æ¯)
    - [3.2 åˆ—çº§ç»Ÿè®¡ä¿¡æ¯](#32-åˆ—çº§ç»Ÿè®¡ä¿¡æ¯)
    - [3.3 ç´¢å¼•ç»Ÿè®¡ä¿¡æ¯](#33-ç´¢å¼•ç»Ÿè®¡ä¿¡æ¯)
  - [4. ç»Ÿè®¡ä¿¡æ¯æ”¶é›†](#4-ç»Ÿè®¡ä¿¡æ¯æ”¶é›†)
    - [4.1 è‡ªåŠ¨ç»Ÿè®¡ä¿¡æ¯æ”¶é›†](#41-è‡ªåŠ¨ç»Ÿè®¡ä¿¡æ¯æ”¶é›†)
    - [4.2 æ‰‹åŠ¨ç»Ÿè®¡ä¿¡æ¯æ”¶é›†](#42-æ‰‹åŠ¨ç»Ÿè®¡ä¿¡æ¯æ”¶é›†)
    - [4.3 ç»Ÿè®¡ä¿¡æ¯é…ç½®](#43-ç»Ÿè®¡ä¿¡æ¯é…ç½®)
  - [5. ä»£ä»·æ¨¡å‹å‚æ•°](#5-ä»£ä»·æ¨¡å‹å‚æ•°)
    - [5.1 åŸºæœ¬ä»£ä»·å‚æ•°](#51-åŸºæœ¬ä»£ä»·å‚æ•°)
    - [5.2 è¿æ¥ä»£ä»·å‚æ•°](#52-è¿æ¥ä»£ä»·å‚æ•°)
    - [5.3 å†…å­˜ä»£ä»·å‚æ•°](#53-å†…å­˜ä»£ä»·å‚æ•°)
  - [6. é€‰æ‹©æ€§ä¼°è®¡](#6-é€‰æ‹©æ€§ä¼°è®¡)
    - [6.1 ç­‰å€¼æŸ¥è¯¢é€‰æ‹©æ€§](#61-ç­‰å€¼æŸ¥è¯¢é€‰æ‹©æ€§)
    - [6.2 èŒƒå›´æŸ¥è¯¢é€‰æ‹©æ€§](#62-èŒƒå›´æŸ¥è¯¢é€‰æ‹©æ€§)
    - [6.3 å¤åˆæ¡ä»¶é€‰æ‹©æ€§](#63-å¤åˆæ¡ä»¶é€‰æ‹©æ€§)
  - [7. ä»£ä»·ä¼°ç®—åˆ†æ](#7-ä»£ä»·ä¼°ç®—åˆ†æ)
    - [7.1 æ‰«æä»£ä»·ä¼°ç®—](#71-æ‰«æä»£ä»·ä¼°ç®—)
    - [7.2 è¿æ¥ä»£ä»·ä¼°ç®—](#72-è¿æ¥ä»£ä»·ä¼°ç®—)
    - [7.3 èšåˆä»£ä»·ä¼°ç®—](#73-èšåˆä»£ä»·ä¼°ç®—)
  - [8. ç»Ÿè®¡ä¿¡æ¯ä¼˜åŒ–](#8-ç»Ÿè®¡ä¿¡æ¯ä¼˜åŒ–)
    - [8.1 ç»Ÿè®¡ä¿¡æ¯è´¨é‡è¯„ä¼°](#81-ç»Ÿè®¡ä¿¡æ¯è´¨é‡è¯„ä¼°)
    - [8.2 ç»Ÿè®¡ä¿¡æ¯æ›´æ–°ç­–ç•¥](#82-ç»Ÿè®¡ä¿¡æ¯æ›´æ–°ç­–ç•¥)
    - [8.3 ç»Ÿè®¡ä¿¡æ¯ç›‘æ§](#83-ç»Ÿè®¡ä¿¡æ¯ç›‘æ§)
  - [9. å®é™…åº”ç”¨æ¡ˆä¾‹](#9-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [9.1 å¤§æ•°æ®è¡¨ç»Ÿè®¡ä¿¡æ¯ç®¡ç†](#91-å¤§æ•°æ®è¡¨ç»Ÿè®¡ä¿¡æ¯ç®¡ç†)
    - [9.2 åŠ¨æ€ç»Ÿè®¡ä¿¡æ¯è°ƒæ•´](#92-åŠ¨æ€ç»Ÿè®¡ä¿¡æ¯è°ƒæ•´)
  - [10. ç›¸å…³æ¦‚å¿µ](#10-ç›¸å…³æ¦‚å¿µ)
    - [10.1 ä¸Šä½æ¦‚å¿µ](#101-ä¸Šä½æ¦‚å¿µ)
    - [10.2 ä¸‹ä½æ¦‚å¿µ](#102-ä¸‹ä½æ¦‚å¿µ)
    - [10.3 å¹³è¡Œæ¦‚å¿µ](#103-å¹³è¡Œæ¦‚å¿µ)
  - [11. å‚è€ƒæ–‡çŒ®](#11-å‚è€ƒæ–‡çŒ®)
  - [12. Wikidataå¯¹é½](#12-wikidataå¯¹é½)

---

## 1. å®šä¹‰ä¸å½¢å¼åŒ–

### 1.1 æ¦‚å¿µå®šä¹‰

**ä¸­æ–‡å®šä¹‰**: ç»Ÿè®¡ä¿¡æ¯æ˜¯æ•°æ®åº“ç³»ç»Ÿä¸­ç”¨äºæè¿°æ•°æ®åˆ†å¸ƒç‰¹å¾çš„ä¿¡æ¯ï¼Œä»£ä»·æ¨¡å‹åŸºäºç»Ÿè®¡ä¿¡æ¯ä¼°ç®—æŸ¥è¯¢æ‰§è¡Œæˆæœ¬ï¼Œä¸ºæŸ¥è¯¢ä¼˜åŒ–å™¨æä¾›å†³ç­–ä¾æ®ã€‚

**English Definition**: Statistics are information in database systems used to describe data distribution characteristics. Cost models estimate query execution costs based on statistics, providing decision-making basis for query optimizers.

### 1.2 å½¢å¼åŒ–å®šä¹‰

```latex
% æ•°å­¦ç¬¦å·å®šä¹‰
\newcommand{\stats}{\mathcal{S}}
\newcommand{\cost}{\mathcal{C}}
\newcommand{\query}{\mathcal{Q}}
\newcommand{\plan}{\mathcal{P}}

% ç»Ÿè®¡ä¿¡æ¯çš„å½¢å¼åŒ–å®šä¹‰
\stats = \{n, \text{ndistinct}, \text{correlation}, \text{histogram}, \text{mcv}\}

å…¶ä¸­ï¼š
n: å…ƒç»„æ•°é‡
\text{ndistinct}: ä¸åŒå€¼æ•°é‡
\text{correlation}: åˆ—ç›¸å…³æ€§
\text{histogram}: ç›´æ–¹å›¾åˆ†å¸ƒ
\text{mcv}: æœ€å¸¸å€¼

% ä»£ä»·æ¨¡å‹çš„å½¢å¼åŒ–å®šä¹‰
\cost(\plan) = \cost_{IO}(\plan) + \cost_{CPU}(\plan) + \cost_{Memory}(\plan)
```

### 1.3 æ ¸å¿ƒå±æ€§

- **å‡†ç¡®æ€§**: ç»Ÿè®¡ä¿¡æ¯åæ˜ çœŸå®æ•°æ®åˆ†å¸ƒ
- **æ—¶æ•ˆæ€§**: ç»Ÿè®¡ä¿¡æ¯åŠæ—¶æ›´æ–°
- **å®Œæ•´æ€§**: è¦†ç›–æ‰€æœ‰ç›¸å…³æ•°æ®ç‰¹å¾
- **å¯æ‰©å±•æ€§**: æ”¯æŒå¤æ‚æŸ¥è¯¢ä»£ä»·ä¼°ç®—

## 2. ç†è®ºåŸºç¡€

### 2.1 ç»Ÿè®¡ä¿¡æ¯ç†è®º

```latex
\begin{theorem}[ç»Ÿè®¡ä¿¡æ¯å®Œå¤‡æ€§]
ç»Ÿè®¡ä¿¡æ¯å®Œå¤‡æ€§è¦æ±‚ï¼š
1. åŸºæ•°ä¼°è®¡ï¼š|R| çš„å‡†ç¡®ä¼°è®¡
2. é€‰æ‹©æ€§ä¼°è®¡ï¼š\frac{|\sigma_p(R)|}{|R|} çš„å‡†ç¡®ä¼°è®¡
3. ç›¸å…³æ€§ä¼°è®¡ï¼šåˆ—é—´ç›¸å…³æ€§çš„å‡†ç¡®ä¼°è®¡
4. åˆ†å¸ƒä¼°è®¡ï¼šæ•°æ®åˆ†å¸ƒçš„å‡†ç¡®ä¼°è®¡
\end{theorem}
```

### 2.2 ä»£ä»·æ¨¡å‹ç†è®º

```latex
\begin{theorem}[ä»£ä»·æ¨¡å‹æ­£ç¡®æ€§]
ä»£ä»·æ¨¡å‹æ»¡è¶³ä»¥ä¸‹æ€§è´¨ï¼š
1. å•è°ƒæ€§ï¼š\cost(\plan_1) \leq \cost(\plan_2) \Rightarrow \text{æ€§èƒ½}(\plan_1) \geq \text{æ€§èƒ½}(\plan_2)
2. å¯åŠ æ€§ï¼š\cost(\plan_1 \bowtie \plan_2) = \cost(\plan_1) + \cost(\plan_2) + \cost_{join}
3. ä¸€è‡´æ€§ï¼šç›¸åŒæ“ä½œçš„ä»£ä»·ä¼°ç®—ä¸€è‡´
\end{theorem}
```

### 2.3 é€‰æ‹©æ€§ä¼°è®¡ç†è®º

```latex
\begin{theorem}[é€‰æ‹©æ€§ä¼°è®¡]
å¯¹äºè°“è¯ pï¼Œé€‰æ‹©æ€§ä¼°è®¡ä¸ºï¼š
\text{sel}(p) = \frac{|\sigma_p(R)|}{|R|}

å…¶ä¸­é€‰æ‹©æ€§ä¼°è®¡çš„å‡†ç¡®æ€§ç›´æ¥å½±å“æŸ¥è¯¢ä¼˜åŒ–æ•ˆæœã€‚
\end{theorem}
```

## 3. PostgreSQLç»Ÿè®¡ä¿¡æ¯

### 3.1 è¡¨çº§ç»Ÿè®¡ä¿¡æ¯

```sql
-- æŸ¥çœ‹è¡¨ç»Ÿè®¡ä¿¡æ¯
SELECT
    schemaname,
    tablename,
    n_tup_ins,
    n_tup_upd,
    n_tup_del,
    n_live_tup,
    n_dead_tup,
    last_vacuum,
    last_autovacuum,
    last_analyze,
    last_autoanalyze
FROM pg_stat_user_tables
WHERE tablename = 'employees';

-- æŸ¥çœ‹è¡¨å¤§å°ç»Ÿè®¡
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as total_size,
    pg_size_pretty(pg_relation_size(schemaname||'.'||tablename)) as table_size,
    pg_size_pretty(pg_indexes_size(schemaname||'.'||tablename)) as indexes_size
FROM pg_tables
WHERE tablename = 'employees';
```

### 3.2 åˆ—çº§ç»Ÿè®¡ä¿¡æ¯

```sql
-- æŸ¥çœ‹åˆ—ç»Ÿè®¡ä¿¡æ¯
SELECT
    schemaname,
    tablename,
    attname,
    n_distinct,
    correlation,
    most_common_vals,
    most_common_freqs,
    histogram_bounds
FROM pg_stats
WHERE schemaname = 'public' AND tablename = 'employees';

-- æŸ¥çœ‹ç‰¹å®šåˆ—ç»Ÿè®¡
SELECT
    attname,
    n_distinct,
    correlation,
    array_length(most_common_vals, 1) as mcv_count,
    array_length(histogram_bounds, 1) as histogram_buckets
FROM pg_stats
WHERE schemaname = 'public'
AND tablename = 'employees'
AND attname = 'salary';
```

### 3.3 ç´¢å¼•ç»Ÿè®¡ä¿¡æ¯

```sql
-- æŸ¥çœ‹ç´¢å¼•ç»Ÿè®¡ä¿¡æ¯
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch,
    idx_blks_read,
    idx_blks_hit
FROM pg_statio_user_indexes
WHERE tablename = 'employees';

-- ç´¢å¼•ä½¿ç”¨æ•ˆç‡
SELECT
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch,
    round(100.0 * idx_blks_hit / (idx_blks_hit + idx_blks_read), 2) as hit_ratio
FROM pg_statio_user_indexes
WHERE tablename = 'employees'
ORDER BY idx_scan DESC;
```

## 4. ç»Ÿè®¡ä¿¡æ¯æ”¶é›†

### 4.1 è‡ªåŠ¨ç»Ÿè®¡ä¿¡æ¯æ”¶é›†

```sql
-- æŸ¥çœ‹è‡ªåŠ¨ç»Ÿè®¡ä¿¡æ¯é…ç½®
SHOW autovacuum;
SHOW autovacuum_analyze_threshold;
SHOW autovacuum_analyze_scale_factor;

-- é…ç½®è‡ªåŠ¨ç»Ÿè®¡ä¿¡æ¯
ALTER TABLE employees SET (autovacuum_analyze_threshold = 50);
ALTER TABLE employees SET (autovacuum_analyze_scale_factor = 0.1);

-- æŸ¥çœ‹ç»Ÿè®¡ä¿¡æ¯æ”¶é›†çŠ¶æ€
SELECT
    schemaname,
    tablename,
    last_analyze,
    last_autoanalyze,
    analyze_count,
    autoanalyze_count
FROM pg_stat_user_tables
WHERE tablename = 'employees';
```

### 4.2 æ‰‹åŠ¨ç»Ÿè®¡ä¿¡æ¯æ”¶é›†

```sql
-- æ‰‹åŠ¨æ”¶é›†ç»Ÿè®¡ä¿¡æ¯
ANALYZE employees;
ANALYZE employees (salary, dept_id);
ANALYZE VERBOSE employees;

-- æ”¶é›†æ‰€æœ‰è¡¨ç»Ÿè®¡ä¿¡æ¯
ANALYZE;

-- æŸ¥çœ‹ç»Ÿè®¡ä¿¡æ¯æ”¶é›†è¿›åº¦
SELECT
    pid,
    datname,
    usename,
    application_name,
    state,
    query
FROM pg_stat_activity
WHERE query LIKE '%ANALYZE%';
```

### 4.3 ç»Ÿè®¡ä¿¡æ¯é…ç½®

```sql
-- ç»Ÿè®¡ä¿¡æ¯é…ç½®å‚æ•°
SHOW default_statistics_target;
SHOW n_distinct;
SHOW correlation;

-- è®¾ç½®ç»Ÿè®¡ä¿¡æ¯ç›®æ ‡
ALTER TABLE employees ALTER COLUMN salary SET STATISTICS 1000;
ALTER TABLE employees ALTER COLUMN dept_id SET STATISTICS 100;

-- æŸ¥çœ‹åˆ—ç»Ÿè®¡ä¿¡æ¯ç›®æ ‡
SELECT
    attname,
    attstattarget
FROM pg_attribute
WHERE attrelid = 'employees'::regclass
AND attnum > 0
AND NOT attisdropped;
```

## 5. ä»£ä»·æ¨¡å‹å‚æ•°

### 5.1 åŸºæœ¬ä»£ä»·å‚æ•°

```sql
-- æŸ¥çœ‹åŸºæœ¬ä»£ä»·å‚æ•°
SHOW seq_page_cost;
SHOW random_page_cost;
SHOW cpu_tuple_cost;
SHOW cpu_index_tuple_cost;
SHOW cpu_operator_cost;

-- è®¾ç½®ä»£ä»·å‚æ•°
SET seq_page_cost = 1.0;
SET random_page_cost = 4.0;
SET cpu_tuple_cost = 0.01;
SET cpu_index_tuple_cost = 0.005;
SET cpu_operator_cost = 0.0025;
```

### 5.2 è¿æ¥ä»£ä»·å‚æ•°

```sql
-- æŸ¥çœ‹è¿æ¥ä»£ä»·å‚æ•°
SHOW join_collapse_limit;
SHOW from_collapse_limit;
SHOW geqo;
SHOW geqo_threshold;

-- è®¾ç½®è¿æ¥ä»£ä»·
SET join_collapse_limit = 8;
SET from_collapse_limit = 8;
SET geqo = on;
SET geqo_threshold = 12;
```

### 5.3 å†…å­˜ä»£ä»·å‚æ•°

```sql
-- æŸ¥çœ‹å†…å­˜ä»£ä»·å‚æ•°
SHOW work_mem;
SHOW maintenance_work_mem;
SHOW effective_cache_size;

-- è®¾ç½®å†…å­˜å‚æ•°
SET work_mem = '256MB';
SET maintenance_work_mem = '1GB';
SET effective_cache_size = '8GB';
```

## 6. é€‰æ‹©æ€§ä¼°è®¡

### 6.1 ç­‰å€¼æŸ¥è¯¢é€‰æ‹©æ€§

```sql
-- ç­‰å€¼æŸ¥è¯¢é€‰æ‹©æ€§ä¼°è®¡
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT * FROM employees WHERE emp_id = 1001;

-- æŸ¥çœ‹é€‰æ‹©æ€§ä¼°è®¡
SELECT
    attname,
    n_distinct,
    most_common_vals,
    most_common_freqs
FROM pg_stats
WHERE schemaname = 'public'
AND tablename = 'employees'
AND attname = 'emp_id';
```

### 6.2 èŒƒå›´æŸ¥è¯¢é€‰æ‹©æ€§

```sql
-- èŒƒå›´æŸ¥è¯¢é€‰æ‹©æ€§ä¼°è®¡
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT * FROM employees WHERE salary BETWEEN 40000 AND 60000;

-- æŸ¥çœ‹ç›´æ–¹å›¾ä¿¡æ¯
SELECT
    attname,
    histogram_bounds
FROM pg_stats
WHERE schemaname = 'public'
AND tablename = 'employees'
AND attname = 'salary';
```

### 6.3 å¤åˆæ¡ä»¶é€‰æ‹©æ€§

```sql
-- å¤åˆæ¡ä»¶é€‰æ‹©æ€§ä¼°è®¡
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT * FROM employees
WHERE dept_id = 1 AND salary > 50000;

-- æŸ¥çœ‹åˆ—ç›¸å…³æ€§
SELECT
    attname,
    correlation
FROM pg_stats
WHERE schemaname = 'public'
AND tablename = 'employees'
AND attname IN ('dept_id', 'salary');
```

## 7. ä»£ä»·ä¼°ç®—åˆ†æ

### 7.1 æ‰«æä»£ä»·ä¼°ç®—

```sql
-- é¡ºåºæ‰«æä»£ä»·
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT * FROM employees;

-- ç´¢å¼•æ‰«æä»£ä»·
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT * FROM employees WHERE emp_id = 1001;

-- ä½å›¾æ‰«æä»£ä»·
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT * FROM employees WHERE dept_id = 1 AND salary > 50000;
```

### 7.2 è¿æ¥ä»£ä»·ä¼°ç®—

```sql
-- åµŒå¥—å¾ªç¯è¿æ¥ä»£ä»·
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT e.name, d.dept_name
FROM employees e, departments d
WHERE e.dept_id = d.dept_id;

-- å“ˆå¸Œè¿æ¥ä»£ä»·
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT e.name, d.dept_name
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id;

-- åˆå¹¶è¿æ¥ä»£ä»·
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT e.name, d.dept_name
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id
ORDER BY e.dept_id;
```

### 7.3 èšåˆä»£ä»·ä¼°ç®—

```sql
-- å“ˆå¸Œèšåˆä»£ä»·
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT dept_id, COUNT(*), AVG(salary)
FROM employees
GROUP BY dept_id;

-- æ’åºèšåˆä»£ä»·
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT dept_id, COUNT(*), AVG(salary)
FROM employees
GROUP BY dept_id
ORDER BY dept_id;
```

## 8. ç»Ÿè®¡ä¿¡æ¯ä¼˜åŒ–

### 8.1 ç»Ÿè®¡ä¿¡æ¯è´¨é‡è¯„ä¼°

```sql
-- ç»Ÿè®¡ä¿¡æ¯è´¨é‡è¯„ä¼°
SELECT
    schemaname,
    tablename,
    attname,
    n_distinct,
    correlation,
    CASE
        WHEN n_distinct = -1 THEN 'ALL_DISTINCT'
        WHEN n_distinct = 0 THEN 'NO_DISTINCT'
        ELSE 'PARTIAL_DISTINCT'
    END as distinct_status,
    CASE
        WHEN correlation IS NULL THEN 'NO_CORRELATION'
        WHEN abs(correlation) > 0.8 THEN 'HIGH_CORRELATION'
        WHEN abs(correlation) > 0.5 THEN 'MEDIUM_CORRELATION'
        ELSE 'LOW_CORRELATION'
    END as correlation_status
FROM pg_stats
WHERE schemaname = 'public'
ORDER BY tablename, attname;
```

### 8.2 ç»Ÿè®¡ä¿¡æ¯æ›´æ–°ç­–ç•¥

```sql
-- åˆ›å»ºç»Ÿè®¡ä¿¡æ¯æ›´æ–°å‡½æ•°
CREATE OR REPLACE FUNCTION update_table_stats(table_name text)
RETURNS void AS $$
BEGIN
    EXECUTE format('ANALYZE %I', table_name);
    RAISE NOTICE 'Updated statistics for table: %', table_name;
END;
$$ LANGUAGE plpgsql;

-- æ‰¹é‡æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
DO $$
DECLARE
    r RECORD;
BEGIN
    FOR r IN
        SELECT tablename
        FROM pg_tables
        WHERE schemaname = 'public'
    LOOP
        PERFORM update_table_stats(r.tablename);
    END LOOP;
END $$;
```

### 8.3 ç»Ÿè®¡ä¿¡æ¯ç›‘æ§

```sql
-- ç»Ÿè®¡ä¿¡æ¯ç›‘æ§
CREATE OR REPLACE FUNCTION monitor_stats()
RETURNS TABLE(
    table_name text,
    last_analyze timestamp,
    analyze_count bigint,
    autoanalyze_count bigint,
    days_since_analyze numeric
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        t.tablename::text,
        s.last_analyze,
        s.analyze_count,
        s.autoanalyze_count,
        EXTRACT(EPOCH FROM (NOW() - s.last_analyze)) / 86400 as days_since_analyze
    FROM pg_tables t
    LEFT JOIN pg_stat_user_tables s ON t.tablename = s.tablename
    WHERE t.schemaname = 'public'
    ORDER BY days_since_analyze DESC NULLS LAST;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨ç›‘æ§å‡½æ•°
SELECT * FROM monitor_stats();
```

## 9. å®é™…åº”ç”¨æ¡ˆä¾‹

### 9.1 å¤§æ•°æ®è¡¨ç»Ÿè®¡ä¿¡æ¯ç®¡ç†

```sql
-- å¤§è¡¨ç»Ÿè®¡ä¿¡æ¯ç®¡ç†
CREATE TABLE large_table (
    id BIGSERIAL PRIMARY KEY,
    category_id INTEGER,
    value DECIMAL(10,2),
    created_at TIMESTAMP DEFAULT NOW()
);

-- åˆ†åŒºè¡¨ç»Ÿè®¡ä¿¡æ¯
CREATE TABLE log_entries (
    id BIGSERIAL,
    log_time TIMESTAMP,
    level VARCHAR(10),
    message TEXT
) PARTITION BY RANGE (log_time);

-- ä¸ºåˆ†åŒºè¡¨æ”¶é›†ç»Ÿè®¡ä¿¡æ¯
DO $$
DECLARE
    r RECORD;
BEGIN
    FOR r IN
        SELECT schemaname, tablename
        FROM pg_tables
        WHERE tablename LIKE 'log_entries_%'
    LOOP
        EXECUTE format('ANALYZE %I.%I', r.schemaname, r.tablename);
    END LOOP;
END $$;
```

### 9.2 åŠ¨æ€ç»Ÿè®¡ä¿¡æ¯è°ƒæ•´

```sql
-- åŠ¨æ€è°ƒæ•´ç»Ÿè®¡ä¿¡æ¯ç›®æ ‡
CREATE OR REPLACE FUNCTION adjust_stats_target(table_name text, column_name text, target integer)
RETURNS void AS $$
BEGIN
    EXECUTE format('ALTER TABLE %I ALTER COLUMN %I SET STATISTICS %s',
                   table_name, column_name, target);
    EXECUTE format('ANALYZE %I', table_name);
    RAISE NOTICE 'Adjusted statistics target for %.% to %', table_name, column_name, target;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨åŠ¨æ€è°ƒæ•´
SELECT adjust_stats_target('employees', 'salary', 1000);
SELECT adjust_stats_target('employees', 'dept_id', 100);
```

## 10. ç›¸å…³æ¦‚å¿µ

### 10.1 ä¸Šä½æ¦‚å¿µ

- **æŸ¥è¯¢ä¼˜åŒ–**: æ›´å¹¿æ³›çš„æŸ¥è¯¢ä¼˜åŒ–æœºåˆ¶
- **æ•°æ®åº“ç»Ÿè®¡**: æ•°æ®åº“ç»Ÿè®¡ä¿¡æ¯ç®¡ç†
- **æ€§èƒ½åˆ†æ**: æ€§èƒ½åˆ†æå’Œä¼˜åŒ–

### 10.2 ä¸‹ä½æ¦‚å¿µ

- **ç›´æ–¹å›¾**: æ•°æ®åˆ†å¸ƒè¡¨ç¤º
- **ç›¸å…³æ€§**: åˆ—é—´å…³ç³»åº¦é‡
- **é€‰æ‹©æ€§**: æŸ¥è¯¢æ¡ä»¶é€‰æ‹©æ€§
- **åŸºæ•°ä¼°è®¡**: ç»“æœé›†å¤§å°ä¼°è®¡

### 10.3 å¹³è¡Œæ¦‚å¿µ

- **é‡‡æ ·**: æ•°æ®é‡‡æ ·æŠ€æœ¯
- **è¿‘ä¼¼ç®—æ³•**: è¿‘ä¼¼ç»Ÿè®¡ç®—æ³•
- **æœºå™¨å­¦ä¹ **: åŸºäºMLçš„ç»Ÿè®¡ä¼°è®¡

## 11. å‚è€ƒæ–‡çŒ®

1. Ioannidis, Y. E. (1996). Query optimization. ACM Computing Surveys, 28(1), 121-123.
2. PostgreSQL Global Development Group. (2024). PostgreSQL 16.2 Documentation. <https://www.postgresql.org/docs/16/>
3. Selinger, P. G., et al. (1979). Access path selection in a relational database management system. ACM SIGMOD Record, 8(2), 23-34.
4. Chaudhuri, S. (1998). An overview of query optimization in relational systems. ACM PODS, 34-43.

## 12. Wikidataå¯¹é½

- **Wikidata ID**: Q192490
- **ç›¸å…³å±æ€§**:
  - P31: Q176165 (instance of: database management system)
  - P178: Q9366 (developer: PostgreSQL Global Development Group)
  - P277: Q193321 (programmed in: C)
  - P348: 16.2 (software version)
- **å¤–éƒ¨é“¾æ¥**:
  - <https://www.postgresql.org/docs/current/planner-stats.html>
  - <https://www.postgresql.org/docs/current/runtime-config-query.html>
