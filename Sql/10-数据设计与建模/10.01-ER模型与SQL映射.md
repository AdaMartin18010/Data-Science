# ER模型与SQL映射

> **创建日期**：2025-12-01
> **难度**：⭐⭐⭐
> **前置知识**：关系模型理论、DDL语法
> **关联文档**：Design/06-数据模型理论体系

---

## 📋 目录

- [ER模型与SQL映射](#er模型与sql映射)
  - [📋 目录](#-目录)
  - [一、概述](#一概述)
  - [二、ER模型基础](#二er模型基础)
    - [2.1 核心概念](#21-核心概念)
    - [2.2 关系基数类型](#22-关系基数类型)
  - [三、实体到表的映射](#三实体到表的映射)
    - [3.1 强实体映射](#31-强实体映射)
    - [3.2 弱实体映射](#32-弱实体映射)
    - [3.3 复合属性映射](#33-复合属性映射)
  - [四、关系到外键的映射](#四关系到外键的映射)
    - [4.1 一对一关系(1:1)](#41-一对一关系11)
    - [4.2 一对多关系(1:N)](#42-一对多关系1n)
    - [4.3 多对多关系(M:N)](#43-多对多关系mn)
    - [4.4 自引用关系](#44-自引用关系)
  - [五、PostgreSQL 18实现](#五postgresql-18实现)
    - [5.1 完整电商ER模型实现](#51-完整电商er模型实现)
  - [六、SQLite 3.45+实现](#六sqlite-345实现)
  - [七、形式化映射规则](#七形式化映射规则)
    - [7.1 映射函数定义](#71-映射函数定义)
    - [7.2 映射决策树](#72-映射决策树)
  - [相关资源](#相关资源)
    - [相关文档](#相关文档)
    - [外部资源](#外部资源)

---

## 一、概述

**ER模型(Entity-Relationship Model)** 是概念数据建模的标准方法，由Peter Chen于1976年提出。
本文档详细阐述ER模型到SQL DDL的完整映射规则。

```text
ER模型 → SQL映射的核心价值
══════════════════════════════════════════════════════════════════════════════

业务需求 ──→ [概念模型(ER图)] ──→ [逻辑模型(关系模式)] ──→ [物理模型(SQL DDL)]
    │              │                    │                      │
    ↓              ↓                    ↓                      ↓
 "客户下订单"   客户─订单关系        Customer表+Order表     CREATE TABLE语句
                                    外键约束               FOREIGN KEY
```

---

## 二、ER模型基础

### 2.1 核心概念

| 概念 | 定义 | SQL对应 |
|------|------|---------|
| **实体(Entity)** | 可区分的业务对象 | TABLE |
| **属性(Attribute)** | 实体的特征 | COLUMN |
| **关系(Relationship)** | 实体间的关联 | FOREIGN KEY / 关联表 |
| **主键(Primary Key)** | 唯一标识实体 | PRIMARY KEY |
| **基数(Cardinality)** | 关系的数量约束 | 外键位置/关联表设计 |

### 2.2 关系基数类型

```text
关系基数映射规则
══════════════════════════════════════════════════════════════════════════════

1:1 (一对一)
┌─────────┐         ┌─────────┐
│ Employee│─────────│ Passport│
└─────────┘         └─────────┘
→ 外键放在任意一方，或合并为一表

1:N (一对多)
┌──────────┐        ┌─────────┐
│Department│────<───│Employee │
└──────────┘        └─────────┘
→ 外键放在"多"的一方(Employee.dept_id)

M:N (多对多)
┌─────────┐        ┌─────────┐
│ Student │────────│  Course │
└─────────┘        └─────────┘
→ 创建关联表(Enrollment)，包含两个外键
```

---

## 三、实体到表的映射

### 3.1 强实体映射

```sql
-- ER模型：强实体 Customer
-- 属性：customer_id(PK), name, email, phone

-- PostgreSQL 18 / SQLite 3.45+
CREATE TABLE customers (
    customer_id     INTEGER PRIMARY KEY,       -- 主键
    name            VARCHAR(100) NOT NULL,     -- 必填属性
    email           VARCHAR(100) UNIQUE,       -- 唯一属性
    phone           VARCHAR(20),               -- 可选属性
    created_at      TIMESTAMP DEFAULT NOW()    -- 派生/默认属性
);
```

### 3.2 弱实体映射

```sql
-- ER模型：弱实体 OrderItem 依赖于 Order
-- OrderItem 的主键 = Order主键 + 自身部分键

CREATE TABLE orders (
    order_id        SERIAL PRIMARY KEY,
    customer_id     INTEGER NOT NULL REFERENCES customers(customer_id),
    order_date      DATE DEFAULT CURRENT_DATE
);

-- 弱实体：主键包含父实体主键
CREATE TABLE order_items (
    order_id        INTEGER NOT NULL,
    item_number     INTEGER NOT NULL,          -- 弱实体的部分键
    product_id      INTEGER NOT NULL,
    quantity        INTEGER NOT NULL CHECK (quantity > 0),
    unit_price      DECIMAL(10,2) NOT NULL,
    -- 复合主键 = 父实体主键 + 部分键
    PRIMARY KEY (order_id, item_number),
    FOREIGN KEY (order_id) REFERENCES orders(order_id) ON DELETE CASCADE
);
```

### 3.3 复合属性映射

```sql
-- ER模型：复合属性 Address = (street, city, state, zip)

-- 方案1：展平为多个列（推荐）
CREATE TABLE customers (
    customer_id     INTEGER PRIMARY KEY,
    name            VARCHAR(100) NOT NULL,
    -- 复合属性展平
    address_street  VARCHAR(200),
    address_city    VARCHAR(100),
    address_state   VARCHAR(50),
    address_zip     VARCHAR(20)
);

-- 方案2：使用JSON（PostgreSQL 18）
CREATE TABLE customers (
    customer_id     INTEGER PRIMARY KEY,
    name            VARCHAR(100) NOT NULL,
    address         JSONB  -- {"street": "...", "city": "...", ...}
);

-- 方案3：单独的地址表（多值属性）
CREATE TABLE customer_addresses (
    address_id      SERIAL PRIMARY KEY,
    customer_id     INTEGER NOT NULL REFERENCES customers(customer_id),
    address_type    VARCHAR(20),  -- 'home', 'work', 'shipping'
    street          VARCHAR(200),
    city            VARCHAR(100),
    state           VARCHAR(50),
    zip             VARCHAR(20)
);
```

---

## 四、关系到外键的映射

### 4.1 一对一关系(1:1)

```sql
-- ER模型：Employee ──── Passport (1:1)

-- 方案1：外键放在任意一方
CREATE TABLE employees (
    emp_id          INTEGER PRIMARY KEY,
    name            VARCHAR(100) NOT NULL
);

CREATE TABLE passports (
    passport_id     VARCHAR(20) PRIMARY KEY,
    emp_id          INTEGER UNIQUE NOT NULL,  -- UNIQUE保证1:1
    issue_date      DATE,
    expiry_date     DATE,
    FOREIGN KEY (emp_id) REFERENCES employees(emp_id)
);

-- 方案2：合并为一表（如果关系很强）
CREATE TABLE employees_with_passport (
    emp_id          INTEGER PRIMARY KEY,
    name            VARCHAR(100) NOT NULL,
    passport_id     VARCHAR(20) UNIQUE,
    passport_issue  DATE,
    passport_expiry DATE
);
```

### 4.2 一对多关系(1:N)

```sql
-- ER模型：Department ────< Employee (1:N)

CREATE TABLE departments (
    dept_id         INTEGER PRIMARY KEY,
    dept_name       VARCHAR(100) NOT NULL
);

CREATE TABLE employees (
    emp_id          INTEGER PRIMARY KEY,
    name            VARCHAR(100) NOT NULL,
    -- 外键放在"多"的一方
    dept_id         INTEGER NOT NULL,
    FOREIGN KEY (dept_id) REFERENCES departments(dept_id)
);
```

### 4.3 多对多关系(M:N)

```sql
-- ER模型：Student ────── Course (M:N) with Enrollment关系

CREATE TABLE students (
    student_id      INTEGER PRIMARY KEY,
    name            VARCHAR(100) NOT NULL
);

CREATE TABLE courses (
    course_id       INTEGER PRIMARY KEY,
    title           VARCHAR(200) NOT NULL,
    credits         INTEGER
);

-- 关联表：解决M:N关系
CREATE TABLE enrollments (
    student_id      INTEGER NOT NULL,
    course_id       INTEGER NOT NULL,
    enrollment_date DATE DEFAULT CURRENT_DATE,
    grade           CHAR(2),
    -- 复合主键
    PRIMARY KEY (student_id, course_id),
    FOREIGN KEY (student_id) REFERENCES students(student_id),
    FOREIGN KEY (course_id) REFERENCES courses(course_id)
);
```

### 4.4 自引用关系

```sql
-- ER模型：Employee ────< Employee (经理-下属关系)

CREATE TABLE employees (
    emp_id          INTEGER PRIMARY KEY,
    name            VARCHAR(100) NOT NULL,
    -- 自引用外键
    manager_id      INTEGER,
    FOREIGN KEY (manager_id) REFERENCES employees(emp_id)
);

-- 查询：员工及其经理
SELECT
    e.name AS employee,
    m.name AS manager
FROM employees e
LEFT JOIN employees m ON e.manager_id = m.emp_id;
```

---

## 五、PostgreSQL 18实现

### 5.1 完整电商ER模型实现

```sql
-- PostgreSQL 18: 电商系统ER模型完整实现

-- 实体：用户
CREATE TABLE users (
    user_id         BIGSERIAL PRIMARY KEY,
    username        VARCHAR(50) UNIQUE NOT NULL,
    email           VARCHAR(100) UNIQUE NOT NULL,
    password_hash   VARCHAR(255) NOT NULL,
    created_at      TIMESTAMPTZ DEFAULT NOW(),
    -- 派生属性（虚拟生成列）
    account_age_days INTEGER GENERATED ALWAYS AS (
        EXTRACT(DAY FROM NOW() - created_at)::INTEGER
    ) STORED
);

-- 实体：商品分类（自引用层次结构）
CREATE TABLE categories (
    category_id     SERIAL PRIMARY KEY,
    name            VARCHAR(100) NOT NULL,
    parent_id       INTEGER REFERENCES categories(category_id),
    level           INTEGER GENERATED ALWAYS AS (
        CASE WHEN parent_id IS NULL THEN 0 ELSE 1 END
    ) STORED
);

-- 实体：商品
CREATE TABLE products (
    product_id      BIGSERIAL PRIMARY KEY,
    name            VARCHAR(200) NOT NULL,
    description     TEXT,
    price           DECIMAL(12,2) NOT NULL CHECK (price >= 0),
    stock           INTEGER NOT NULL DEFAULT 0 CHECK (stock >= 0),
    category_id     INTEGER NOT NULL REFERENCES categories(category_id),
    attributes      JSONB DEFAULT '{}',  -- 复合属性用JSON
    -- 全文搜索向量
    search_vector   TSVECTOR GENERATED ALWAYS AS (
        setweight(to_tsvector('english', name), 'A') ||
        setweight(to_tsvector('english', COALESCE(description, '')), 'B')
    ) STORED
);

-- 关系：用户-商品（M:N 购物车）
CREATE TABLE cart_items (
    user_id         BIGINT NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    product_id      BIGINT NOT NULL REFERENCES products(product_id),
    quantity        INTEGER NOT NULL CHECK (quantity > 0),
    added_at        TIMESTAMPTZ DEFAULT NOW(),
    PRIMARY KEY (user_id, product_id)
);

-- 实体：订单
CREATE TABLE orders (
    order_id        BIGSERIAL PRIMARY KEY,
    user_id         BIGINT NOT NULL REFERENCES users(user_id),
    status          VARCHAR(20) NOT NULL DEFAULT 'pending'
                    CHECK (status IN ('pending', 'paid', 'shipped', 'completed', 'cancelled')),
    total_amount    DECIMAL(14,2) NOT NULL,
    created_at      TIMESTAMPTZ DEFAULT NOW(),
    updated_at      TIMESTAMPTZ DEFAULT NOW()
);

-- 弱实体：订单明细
CREATE TABLE order_items (
    order_id        BIGINT NOT NULL,
    line_number     INTEGER NOT NULL,
    product_id      BIGINT NOT NULL REFERENCES products(product_id),
    quantity        INTEGER NOT NULL CHECK (quantity > 0),
    unit_price      DECIMAL(12,2) NOT NULL,
    subtotal        DECIMAL(14,2) GENERATED ALWAYS AS (quantity * unit_price) STORED,
    PRIMARY KEY (order_id, line_number),
    FOREIGN KEY (order_id) REFERENCES orders(order_id) ON DELETE CASCADE
);

-- 索引
CREATE INDEX idx_products_category ON products(category_id);
CREATE INDEX idx_products_search ON products USING GIN(search_vector);
CREATE INDEX idx_orders_user_status ON orders(user_id, status);
```

---

## 六、SQLite 3.45+实现

```sql
-- SQLite 3.45+: 同一电商模型的简化实现

CREATE TABLE users (
    user_id         INTEGER PRIMARY KEY AUTOINCREMENT,
    username        TEXT UNIQUE NOT NULL,
    email           TEXT UNIQUE NOT NULL,
    password_hash   TEXT NOT NULL,
    created_at      TEXT DEFAULT (datetime('now'))
) STRICT;

CREATE TABLE categories (
    category_id     INTEGER PRIMARY KEY AUTOINCREMENT,
    name            TEXT NOT NULL,
    parent_id       INTEGER REFERENCES categories(category_id)
);

CREATE TABLE products (
    product_id      INTEGER PRIMARY KEY AUTOINCREMENT,
    name            TEXT NOT NULL,
    description     TEXT,
    price           REAL NOT NULL CHECK (price >= 0),
    stock           INTEGER NOT NULL DEFAULT 0 CHECK (stock >= 0),
    category_id     INTEGER NOT NULL REFERENCES categories(category_id),
    attributes      TEXT DEFAULT '{}'  -- JSON as TEXT
) STRICT;

CREATE TABLE orders (
    order_id        INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id         INTEGER NOT NULL REFERENCES users(user_id),
    status          TEXT NOT NULL DEFAULT 'pending',
    total_amount    REAL NOT NULL,
    created_at      TEXT DEFAULT (datetime('now'))
);

CREATE TABLE order_items (
    order_id        INTEGER NOT NULL,
    line_number     INTEGER NOT NULL,
    product_id      INTEGER NOT NULL REFERENCES products(product_id),
    quantity        INTEGER NOT NULL CHECK (quantity > 0),
    unit_price      REAL NOT NULL,
    PRIMARY KEY (order_id, line_number),
    FOREIGN KEY (order_id) REFERENCES orders(order_id) ON DELETE CASCADE
);

-- 启用外键约束
PRAGMA foreign_keys = ON;
```

---

## 七、形式化映射规则

### 7.1 映射函数定义

```text
定义：ER到SQL的映射函数
══════════════════════════════════════════════════════════════════════════════

设 ER模型 M = (E, R, A)，SQL Schema S = (T, C, K)

映射函数 φ: M → S 定义为：

1. 实体映射 φ_E: E → T
   φ_E(e) = CREATE TABLE t_e (...)
   其中表名 t_e 对应实体名 e

2. 属性映射 φ_A: A → C
   φ_A(a) = column_a datatype [constraints]
   - 主键属性 → PRIMARY KEY
   - 必填属性 → NOT NULL
   - 唯一属性 → UNIQUE
   - 派生属性 → GENERATED ALWAYS AS

3. 关系映射 φ_R: R → K ∪ T
   - 1:1 关系 → FOREIGN KEY + UNIQUE
   - 1:N 关系 → FOREIGN KEY
   - M:N 关系 → 新表 + 两个FOREIGN KEY

定理：映射的正确性
──────────────────────────────────────────────────────────────────────────────
φ 保持以下性质：
1. 实体完整性：每个实体有唯一主键 → 每个表有PRIMARY KEY
2. 参照完整性：关系约束 → FOREIGN KEY约束
3. 语义等价：ER模型语义 ≡ SQL Schema语义
```

### 7.2 映射决策树

```text
ER关系到SQL的决策树
══════════════════════════════════════════════════════════════════════════════

[关系类型?]
    │
    ├─→ 1:1
    │     │
    │     ├─→ 关系是否必须? ─→ 是 ─→ 合并为一表
    │     │
    │     └─→ 否 ─→ 外键+UNIQUE放在可选一方
    │
    ├─→ 1:N
    │     │
    │     └─→ 外键放在"多"的一方
    │
    └─→ M:N
          │
          └─→ 创建关联表，包含两个外键作为复合主键
```

---

## 相关资源

### 相关文档

- [01.07-范式理论完整因果链](../01-理论基础/01.07-范式理论完整因果链.md)
- [04.01-数据定义语言(DDL)](../04-语法规范/04.01-数据定义语言(DDL).md)
- [Design/07.03-数据建模指导](../../Design/07-数据库设计实践/07.03-数据建模指导.md)

### 外部资源

- [Peter Chen's Original ER Paper (1976)](https://dl.acm.org/doi/10.1145/320434.320440)
- [PostgreSQL CREATE TABLE](https://www.postgresql.org/docs/current/sql-createtable.html)

---

**维护者**: SQL Standards Team
**最后更新**: 2025-12-01
