# æ•°æ®åˆ†æSQLæ¨¡å¼

> **åˆ›å»ºæ—¥æœŸ**ï¼š2025-12-01
> **éš¾åº¦**ï¼šâ­â­â­â­
> **å‰ç½®çŸ¥è¯†**ï¼šçª—å£å‡½æ•°ã€èšåˆå‡½æ•°ã€CTE
> **åº”ç”¨åœºæ™¯**ï¼šæ•°æ®ç§‘å­¦ã€BIæŠ¥è¡¨ã€ç”¨æˆ·åˆ†æ

---

## ğŸ“‹ ç›®å½•

- [æ•°æ®åˆ†æSQLæ¨¡å¼](#æ•°æ®åˆ†æsqlæ¨¡å¼)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ä¸€ã€æ¦‚è¿°](#ä¸€æ¦‚è¿°)
  - [äºŒã€èšåˆåˆ†ææ¨¡å¼](#äºŒèšåˆåˆ†ææ¨¡å¼)
    - [2.1 å¤šç»´èšåˆ (ROLLUP/CUBE)](#21-å¤šç»´èšåˆ-rollupcube)
    - [2.2 é€è§†è¡¨ (PIVOT)](#22-é€è§†è¡¨-pivot)
  - [ä¸‰ã€æ—¶é—´åºåˆ—åˆ†æ](#ä¸‰æ—¶é—´åºåˆ—åˆ†æ)
    - [3.1 æ—¥/å‘¨/æœˆæ±‡æ€»](#31-æ—¥å‘¨æœˆæ±‡æ€»)
    - [3.2 åŒæ¯”ç¯æ¯”åˆ†æ](#32-åŒæ¯”ç¯æ¯”åˆ†æ)
    - [3.3 ç´¯è®¡ç»Ÿè®¡](#33-ç´¯è®¡ç»Ÿè®¡)
  - [å››ã€ç”¨æˆ·è¡Œä¸ºåˆ†æ](#å››ç”¨æˆ·è¡Œä¸ºåˆ†æ)
    - [4.1 æ¼æ–—åˆ†æ](#41-æ¼æ–—åˆ†æ)
    - [4.2 ç•™å­˜åˆ†æ](#42-ç•™å­˜åˆ†æ)
    - [4.3 RFMæ¨¡å‹](#43-rfmæ¨¡å‹)
  - [äº”ã€ç»Ÿè®¡åˆ†ææ¨¡å¼](#äº”ç»Ÿè®¡åˆ†ææ¨¡å¼)
    - [5.1 ç™¾åˆ†ä½æ•°åˆ†æ](#51-ç™¾åˆ†ä½æ•°åˆ†æ)
    - [5.2 æ ‡å‡†å·®å’Œæ–¹å·®](#52-æ ‡å‡†å·®å’Œæ–¹å·®)
  - [å…­ã€PostgreSQL 18æ•°æ®åˆ†æ](#å…­postgresql-18æ•°æ®åˆ†æ)
    - [6.1 å‘é‡ç›¸ä¼¼åº¦åˆ†æ](#61-å‘é‡ç›¸ä¼¼åº¦åˆ†æ)
    - [6.2 JSONèšåˆæŠ¥è¡¨](#62-jsonèšåˆæŠ¥è¡¨)
  - [ä¸ƒã€SQLite 3.45+æ•°æ®åˆ†æ](#ä¸ƒsqlite-345æ•°æ®åˆ†æ)
  - [ç›¸å…³èµ„æº](#ç›¸å…³èµ„æº)
    - [ç›¸å…³æ–‡æ¡£](#ç›¸å…³æ–‡æ¡£)

---

## ä¸€ã€æ¦‚è¿°

**æ•°æ®åˆ†æSQLæ¨¡å¼**æ˜¯æ•°æ®ç§‘å­¦å®¶å’Œåˆ†æå¸ˆæ—¥å¸¸ä½¿ç”¨çš„SQLæŸ¥è¯¢æ¨¡æ¿ã€‚
æœ¬æ–‡æ¡£æ•´ç†æœ€å¸¸ç”¨çš„åˆ†ææ¨¡å¼ï¼Œæä¾›PostgreSQL 18å’ŒSQLite 3.45+çš„å®Œæ•´å®ç°ã€‚

```text
æ•°æ®åˆ†æSQLæ¨¡å¼åˆ†ç±»
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          æ•°æ®åˆ†æSQLæ¨¡å¼                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   èšåˆåˆ†æ     â”‚   æ—¶é—´åºåˆ—     â”‚   ç”¨æˆ·åˆ†æ    â”‚   ç»Ÿè®¡åˆ†æ     â”‚   é«˜çº§åˆ†æ   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ GROUP BY      â”‚ æ—¥/å‘¨/æœˆæ±‡æ€»   â”‚ æ¼æ–—åˆ†æ       â”‚ ç™¾åˆ†ä½æ•°      â”‚ åŒæ¯”ç¯æ¯”     â”‚
â”‚ HAVING        â”‚ ç§»åŠ¨å¹³å‡       â”‚ ç•™å­˜åˆ†æ      â”‚ æ ‡å‡†å·®         â”‚ ç´¯è®¡å æ¯”     â”‚
â”‚ ROLLUP/CUBE   â”‚ è¶‹åŠ¿åˆ†æ       â”‚ ç”Ÿå‘½å‘¨æœŸ      â”‚ ç›¸å…³æ€§         â”‚ æ’ååˆ†å¸ƒ     â”‚
â”‚ é€è§†è¡¨         â”‚ å‘¨æœŸå¯¹æ¯”      â”‚ RFMæ¨¡å‹       â”‚ åˆ†å¸ƒåˆ†æ       â”‚ é˜Ÿåˆ—åˆ†æ     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## äºŒã€èšåˆåˆ†ææ¨¡å¼

### 2.1 å¤šç»´èšåˆ (ROLLUP/CUBE)

```sql
-- PostgreSQL 18: ROLLUPç”Ÿæˆå°è®¡å’Œæ€»è®¡
SELECT
    COALESCE(region, 'ã€æ€»è®¡ã€‘') AS region,
    COALESCE(category, 'ã€å°è®¡ã€‘') AS category,
    SUM(sales) AS total_sales,
    COUNT(*) AS order_count
FROM orders o
JOIN products p ON o.product_id = p.product_id
GROUP BY ROLLUP (region, category)
ORDER BY
    region NULLS LAST,
    category NULLS LAST;

/*
ç»“æœç¤ºä¾‹:
region    | category   | total_sales | order_count
----------+------------+-------------+-------------
åä¸œ      | ç”µå­äº§å“    | 150000      | 120
åä¸œ      | æœè£…        | 80000       | 200
åä¸œ      | ã€å°è®¡ã€‘    | 230000      | 320
ååŒ—      | ç”µå­äº§å“    | 120000      | 100
ååŒ—      | æœè£…        | 60000       | 150
ååŒ—      | ã€å°è®¡ã€‘    | 180000      | 250
ã€æ€»è®¡ã€‘  | ã€å°è®¡ã€‘    | 410000      | 570
*/

-- CUBEï¼šæ‰€æœ‰ç»´åº¦ç»„åˆ
SELECT
    region,
    category,
    SUM(sales) AS total_sales
FROM sales_data
GROUP BY CUBE (region, category);
```

### 2.2 é€è§†è¡¨ (PIVOT)

```sql
-- PostgreSQL 18: ä½¿ç”¨æ¡ä»¶èšåˆå®ç°é€è§†è¡¨
SELECT
    category,
    SUM(CASE WHEN quarter = 'Q1' THEN sales ELSE 0 END) AS Q1,
    SUM(CASE WHEN quarter = 'Q2' THEN sales ELSE 0 END) AS Q2,
    SUM(CASE WHEN quarter = 'Q3' THEN sales ELSE 0 END) AS Q3,
    SUM(CASE WHEN quarter = 'Q4' THEN sales ELSE 0 END) AS Q4,
    SUM(sales) AS total
FROM (
    SELECT
        category,
        'Q' || EXTRACT(QUARTER FROM order_date) AS quarter,
        total_amount AS sales
    FROM orders
    WHERE EXTRACT(YEAR FROM order_date) = 2025
) AS quarterly_sales
GROUP BY category
ORDER BY total DESC;

-- ä½¿ç”¨crosstabæ‰©å±•ï¼ˆæ›´çµæ´»ï¼‰
-- CREATE EXTENSION IF NOT EXISTS tablefunc;
SELECT * FROM crosstab(
    'SELECT category, quarter, SUM(sales)
     FROM sales GROUP BY 1, 2 ORDER BY 1, 2',
    'SELECT DISTINCT quarter FROM sales ORDER BY 1'
) AS ct(category TEXT, Q1 NUMERIC, Q2 NUMERIC, Q3 NUMERIC, Q4 NUMERIC);
```

---

## ä¸‰ã€æ—¶é—´åºåˆ—åˆ†æ

### 3.1 æ—¥/å‘¨/æœˆæ±‡æ€»

```sql
-- PostgreSQL 18: å¤šç²’åº¦æ—¶é—´æ±‡æ€»
WITH daily_sales AS (
    SELECT
        DATE(order_date) AS sale_date,
        SUM(total_amount) AS daily_total
    FROM orders
    WHERE order_date >= '2025-01-01'
    GROUP BY DATE(order_date)
)
SELECT
    sale_date,
    daily_total,
    -- å‘¨æ±‡æ€»
    SUM(daily_total) OVER (
        PARTITION BY DATE_TRUNC('week', sale_date)
    ) AS weekly_total,
    -- æœˆæ±‡æ€»
    SUM(daily_total) OVER (
        PARTITION BY DATE_TRUNC('month', sale_date)
    ) AS monthly_total,
    -- 7æ—¥ç§»åŠ¨å¹³å‡
    ROUND(AVG(daily_total) OVER (
        ORDER BY sale_date
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ), 2) AS ma7,
    -- 30æ—¥ç§»åŠ¨å¹³å‡
    ROUND(AVG(daily_total) OVER (
        ORDER BY sale_date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ), 2) AS ma30
FROM daily_sales
ORDER BY sale_date;
```

### 3.2 åŒæ¯”ç¯æ¯”åˆ†æ

```sql
-- PostgreSQL 18: å®Œæ•´çš„åŒæ¯”ç¯æ¯”åˆ†æ
WITH monthly_metrics AS (
    SELECT
        DATE_TRUNC('month', order_date) AS month,
        SUM(total_amount) AS revenue,
        COUNT(DISTINCT customer_id) AS customers,
        COUNT(*) AS orders
    FROM orders
    GROUP BY DATE_TRUNC('month', order_date)
)
SELECT
    month,
    revenue,
    customers,
    orders,
    -- ç¯æ¯”ï¼ˆMoMï¼‰
    LAG(revenue) OVER (ORDER BY month) AS prev_month_revenue,
    ROUND(
        (revenue - LAG(revenue) OVER (ORDER BY month)) * 100.0 /
        NULLIF(LAG(revenue) OVER (ORDER BY month), 0), 2
    ) AS mom_growth_pct,
    -- åŒæ¯”ï¼ˆYoYï¼‰
    LAG(revenue, 12) OVER (ORDER BY month) AS prev_year_revenue,
    ROUND(
        (revenue - LAG(revenue, 12) OVER (ORDER BY month)) * 100.0 /
        NULLIF(LAG(revenue, 12) OVER (ORDER BY month), 0), 2
    ) AS yoy_growth_pct,
    -- è¶‹åŠ¿æŒ‡ç¤º
    CASE
        WHEN revenue > LAG(revenue) OVER (ORDER BY month) * 1.1 THEN 'â†‘â†‘'
        WHEN revenue > LAG(revenue) OVER (ORDER BY month) THEN 'â†‘'
        WHEN revenue < LAG(revenue) OVER (ORDER BY month) * 0.9 THEN 'â†“â†“'
        WHEN revenue < LAG(revenue) OVER (ORDER BY month) THEN 'â†“'
        ELSE 'â†’'
    END AS trend
FROM monthly_metrics
ORDER BY month DESC
LIMIT 24;
```

### 3.3 ç´¯è®¡ç»Ÿè®¡

```sql
-- ç´¯è®¡é”€å”®å’Œç´¯è®¡å æ¯”
SELECT
    order_date,
    daily_sales,
    -- ç´¯è®¡é”€å”®
    SUM(daily_sales) OVER (ORDER BY order_date) AS cumulative_sales,
    -- ç´¯è®¡å æ¯”
    ROUND(
        SUM(daily_sales) OVER (ORDER BY order_date) * 100.0 /
        SUM(daily_sales) OVER (), 2
    ) AS cumulative_pct,
    -- å½“æ—¥å æ¯”
    ROUND(daily_sales * 100.0 / SUM(daily_sales) OVER (), 2) AS daily_pct
FROM (
    SELECT DATE(order_date) AS order_date, SUM(total_amount) AS daily_sales
    FROM orders
    WHERE order_date >= '2025-01-01'
    GROUP BY DATE(order_date)
) AS daily
ORDER BY order_date;
```

---

## å››ã€ç”¨æˆ·è¡Œä¸ºåˆ†æ

### 4.1 æ¼æ–—åˆ†æ

```sql
-- PostgreSQL 18: ç”µå•†æ¼æ–—åˆ†æ
WITH funnel AS (
    SELECT
        COUNT(DISTINCT CASE WHEN event = 'page_view' THEN user_id END) AS step1_view,
        COUNT(DISTINCT CASE WHEN event = 'add_to_cart' THEN user_id END) AS step2_cart,
        COUNT(DISTINCT CASE WHEN event = 'checkout' THEN user_id END) AS step3_checkout,
        COUNT(DISTINCT CASE WHEN event = 'purchase' THEN user_id END) AS step4_purchase
    FROM user_events
    WHERE event_date >= CURRENT_DATE - INTERVAL '30 days'
)
SELECT
    'Step 1: æµè§ˆ' AS step,
    step1_view AS users,
    100.0 AS conversion_rate,
    100.0 AS drop_off_rate
FROM funnel
UNION ALL
SELECT
    'Step 2: åŠ è´­',
    step2_cart,
    ROUND(step2_cart * 100.0 / step1_view, 2),
    ROUND((step1_view - step2_cart) * 100.0 / step1_view, 2)
FROM funnel
UNION ALL
SELECT
    'Step 3: ç»“ç®—',
    step3_checkout,
    ROUND(step3_checkout * 100.0 / step1_view, 2),
    ROUND((step2_cart - step3_checkout) * 100.0 / step2_cart, 2)
FROM funnel
UNION ALL
SELECT
    'Step 4: è´­ä¹°',
    step4_purchase,
    ROUND(step4_purchase * 100.0 / step1_view, 2),
    ROUND((step3_checkout - step4_purchase) * 100.0 / step3_checkout, 2)
FROM funnel;
```

### 4.2 ç•™å­˜åˆ†æ

```sql
-- PostgreSQL 18: ç”¨æˆ·ç•™å­˜åˆ†æï¼ˆCohort Analysisï¼‰
WITH user_cohorts AS (
    -- ç”¨æˆ·é¦–æ¬¡æ´»è·ƒæ—¥æœŸï¼ˆé˜Ÿåˆ—ï¼‰
    SELECT
        user_id,
        DATE_TRUNC('month', MIN(event_date)) AS cohort_month
    FROM user_events
    GROUP BY user_id
),
user_activities AS (
    -- ç”¨æˆ·æ¯æœˆæ´»è·ƒæƒ…å†µ
    SELECT
        e.user_id,
        c.cohort_month,
        DATE_TRUNC('month', e.event_date) AS activity_month,
        -- è·ç¦»é¦–æ¬¡æ´»è·ƒçš„æœˆæ•°
        EXTRACT(MONTH FROM AGE(DATE_TRUNC('month', e.event_date), c.cohort_month)) AS months_since_first
    FROM user_events e
    JOIN user_cohorts c ON e.user_id = c.user_id
)
SELECT
    cohort_month,
    COUNT(DISTINCT CASE WHEN months_since_first = 0 THEN user_id END) AS month_0,
    COUNT(DISTINCT CASE WHEN months_since_first = 1 THEN user_id END) AS month_1,
    COUNT(DISTINCT CASE WHEN months_since_first = 2 THEN user_id END) AS month_2,
    COUNT(DISTINCT CASE WHEN months_since_first = 3 THEN user_id END) AS month_3,
    -- ç•™å­˜ç‡
    ROUND(COUNT(DISTINCT CASE WHEN months_since_first = 1 THEN user_id END) * 100.0 /
          NULLIF(COUNT(DISTINCT CASE WHEN months_since_first = 0 THEN user_id END), 0), 1) AS retention_m1,
    ROUND(COUNT(DISTINCT CASE WHEN months_since_first = 3 THEN user_id END) * 100.0 /
          NULLIF(COUNT(DISTINCT CASE WHEN months_since_first = 0 THEN user_id END), 0), 1) AS retention_m3
FROM user_activities
GROUP BY cohort_month
ORDER BY cohort_month;
```

### 4.3 RFMæ¨¡å‹

```sql
-- PostgreSQL 18: RFMç”¨æˆ·ä»·å€¼åˆ†æ
-- è§ 07.01-å¤æ‚æŸ¥è¯¢æ¡ˆä¾‹.md å®Œæ•´å®ç°
WITH rfm_base AS (
    SELECT
        customer_id,
        CURRENT_DATE - MAX(order_date)::DATE AS recency,
        COUNT(*) AS frequency,
        SUM(total_amount) AS monetary
    FROM orders
    WHERE order_date >= CURRENT_DATE - INTERVAL '1 year'
    GROUP BY customer_id
),
rfm_scores AS (
    SELECT *,
        NTILE(5) OVER (ORDER BY recency DESC) AS r_score,
        NTILE(5) OVER (ORDER BY frequency) AS f_score,
        NTILE(5) OVER (ORDER BY monetary) AS m_score
    FROM rfm_base
)
SELECT
    customer_id,
    r_score, f_score, m_score,
    r_score + f_score + m_score AS rfm_total,
    CASE
        WHEN r_score >= 4 AND f_score >= 4 AND m_score >= 4 THEN 'é‡è¦ä»·å€¼å®¢æˆ·'
        WHEN r_score >= 4 AND f_score >= 4 THEN 'é‡è¦å‘å±•å®¢æˆ·'
        WHEN f_score >= 4 AND m_score >= 4 THEN 'é‡è¦æŒ½ç•™å®¢æˆ·'
        ELSE 'ä¸€èˆ¬å®¢æˆ·'
    END AS customer_segment
FROM rfm_scores
ORDER BY rfm_total DESC;
```

---

## äº”ã€ç»Ÿè®¡åˆ†ææ¨¡å¼

### 5.1 ç™¾åˆ†ä½æ•°åˆ†æ

```sql
-- PostgreSQL 18: ç™¾åˆ†ä½æ•°
SELECT
    category,
    ROUND(PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY price), 2) AS p25,
    ROUND(PERCENTILE_CONT(0.50) WITHIN GROUP (ORDER BY price), 2) AS median,
    ROUND(PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY price), 2) AS p75,
    ROUND(PERCENTILE_CONT(0.90) WITHIN GROUP (ORDER BY price), 2) AS p90,
    ROUND(PERCENTILE_CONT(0.99) WITHIN GROUP (ORDER BY price), 2) AS p99
FROM products
GROUP BY category;

-- åˆ†å¸ƒåˆ†æ
SELECT
    width_bucket(price, 0, 1000, 10) AS price_bucket,
    COUNT(*) AS count,
    MIN(price) AS min_price,
    MAX(price) AS max_price
FROM products
GROUP BY 1
ORDER BY 1;
```

### 5.2 æ ‡å‡†å·®å’Œæ–¹å·®

```sql
-- ç»Ÿè®¡æŒ‡æ ‡
SELECT
    category,
    COUNT(*) AS n,
    ROUND(AVG(price), 2) AS mean,
    ROUND(STDDEV_SAMP(price), 2) AS std_dev,
    ROUND(VAR_SAMP(price), 2) AS variance,
    ROUND(STDDEV_SAMP(price) / NULLIF(AVG(price), 0), 4) AS cv  -- å˜å¼‚ç³»æ•°
FROM products
GROUP BY category;
```

---

## å…­ã€PostgreSQL 18æ•°æ®åˆ†æ

### 6.1 å‘é‡ç›¸ä¼¼åº¦åˆ†æ

```sql
-- PostgreSQL 18 + pgvector: ç”¨æˆ·ç›¸ä¼¼åº¦åˆ†æ
SELECT
    u1.user_id AS user_a,
    u2.user_id AS user_b,
    1 - (u1.preference_vector <=> u2.preference_vector) AS similarity
FROM user_profiles u1
CROSS JOIN user_profiles u2
WHERE u1.user_id < u2.user_id
  AND 1 - (u1.preference_vector <=> u2.preference_vector) > 0.8
ORDER BY similarity DESC
LIMIT 100;
```

### 6.2 JSONèšåˆæŠ¥è¡¨

```sql
-- ç”ŸæˆJSONæ ¼å¼æŠ¥è¡¨
SELECT jsonb_build_object(
    'report_date', CURRENT_DATE,
    'summary', jsonb_build_object(
        'total_revenue', SUM(total_amount),
        'order_count', COUNT(*),
        'avg_order_value', ROUND(AVG(total_amount), 2)
    ),
    'by_category', jsonb_agg(DISTINCT jsonb_build_object(
        'category', category,
        'revenue', category_revenue
    ))
) AS report
FROM orders o
JOIN (
    SELECT category, SUM(total_amount) AS category_revenue
    FROM orders JOIN products USING (product_id)
    GROUP BY category
) cat ON true;
```

---

## ä¸ƒã€SQLite 3.45+æ•°æ®åˆ†æ

```sql
-- SQLite 3.45+: æ•°æ®åˆ†æç¤ºä¾‹

-- æ—¶é—´åºåˆ—åˆ†æ
SELECT
    date(order_date) AS sale_date,
    SUM(total_amount) AS daily_sales,
    SUM(SUM(total_amount)) OVER (ORDER BY date(order_date)) AS cumulative_sales,
    AVG(SUM(total_amount)) OVER (
        ORDER BY date(order_date)
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS ma7
FROM orders
GROUP BY date(order_date);

-- RFMåˆ†æ
WITH rfm AS (
    SELECT
        customer_id,
        julianday('now') - julianday(MAX(order_date)) AS recency,
        COUNT(*) AS frequency,
        SUM(total_amount) AS monetary
    FROM orders
    GROUP BY customer_id
)
SELECT *,
    NTILE(5) OVER (ORDER BY recency DESC) AS r,
    NTILE(5) OVER (ORDER BY frequency) AS f,
    NTILE(5) OVER (ORDER BY monetary) AS m
FROM rfm;

-- JSONèšåˆ
SELECT
    category,
    json_group_array(json_object('id', product_id, 'name', name, 'price', price)) AS products
FROM products
GROUP BY category;
```

---

## ç›¸å…³èµ„æº

### ç›¸å…³æ–‡æ¡£

- [05.01-çª—å£å‡½æ•°è¯¦è§£](../05-é«˜çº§ç‰¹æ€§/05.01-çª—å£å‡½æ•°è¯¦è§£.md)
- [07.01-å¤æ‚æŸ¥è¯¢æ¡ˆä¾‹](../07-å®è·µæ¡ˆä¾‹/07.01-å¤æ‚æŸ¥è¯¢æ¡ˆä¾‹.md)
- [07.02-æ•°æ®åˆ†ææ¡ˆä¾‹](../07-å®è·µæ¡ˆä¾‹/07.02-æ•°æ®åˆ†ææ¡ˆä¾‹.md)

---

**ç»´æŠ¤è€…**: SQL Standards Team
**æœ€åæ›´æ–°**: 2025-12-01
