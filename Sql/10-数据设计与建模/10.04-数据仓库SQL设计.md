# æ•°æ®ä»“åº“SQLè®¾è®¡

> **åˆ›å»ºæ—¥æœŸ**ï¼š2025-12-01
> **éš¾åº¦**ï¼šâ­â­â­â­â­
> **å‰ç½®çŸ¥è¯†**ï¼šæ•°æ®å»ºæ¨¡ã€SQLé«˜çº§ç‰¹æ€§
> **åº”ç”¨åœºæ™¯**ï¼šBIç³»ç»Ÿã€æ•°æ®åˆ†æå¹³å°ã€æŠ¥è¡¨ç³»ç»Ÿ

---

## ğŸ“‹ ç›®å½•

- [æ•°æ®ä»“åº“SQLè®¾è®¡](#æ•°æ®ä»“åº“sqlè®¾è®¡)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ä¸€ã€æ¦‚è¿°](#ä¸€æ¦‚è¿°)
  - [äºŒã€ç»´åº¦å»ºæ¨¡åŸºç¡€](#äºŒç»´åº¦å»ºæ¨¡åŸºç¡€)
    - [2.1 æ ¸å¿ƒæ¦‚å¿µ](#21-æ ¸å¿ƒæ¦‚å¿µ)
    - [2.2 æ˜Ÿå‹ vs é›ªèŠ±](#22-æ˜Ÿå‹-vs-é›ªèŠ±)
  - [ä¸‰ã€æ˜Ÿå‹æ¨¡å‹SQLå®ç°](#ä¸‰æ˜Ÿå‹æ¨¡å‹sqlå®ç°)
    - [3.1 ç»´åº¦è¡¨DDL](#31-ç»´åº¦è¡¨ddl)
    - [3.2 äº‹å®è¡¨DDL](#32-äº‹å®è¡¨ddl)
    - [3.3 æ˜Ÿå‹æ¨¡å‹æŸ¥è¯¢](#33-æ˜Ÿå‹æ¨¡å‹æŸ¥è¯¢)
  - [å››ã€é›ªèŠ±æ¨¡å‹SQLå®ç°](#å››é›ªèŠ±æ¨¡å‹sqlå®ç°)
  - [äº”ã€PostgreSQL 18æ•°æ®ä»“åº“](#äº”postgresql-18æ•°æ®ä»“åº“)
    - [5.1 åˆ—å¼å­˜å‚¨æ‰©å±•](#51-åˆ—å¼å­˜å‚¨æ‰©å±•)
    - [5.2 åˆ†æå‡½æ•°åº”ç”¨](#52-åˆ†æå‡½æ•°åº”ç”¨)
  - [å…­ã€ETL SQLæ¨¡å¼](#å…­etl-sqlæ¨¡å¼)
    - [6.1 å¢é‡åŠ è½½](#61-å¢é‡åŠ è½½)
    - [6.2 SCD Type 2 å®ç°](#62-scd-type-2-å®ç°)
  - [ç›¸å…³èµ„æº](#ç›¸å…³èµ„æº)
    - [ç›¸å…³æ–‡æ¡£](#ç›¸å…³æ–‡æ¡£)

---

## ä¸€ã€æ¦‚è¿°

**æ•°æ®ä»“åº“(Data Warehouse)** æ˜¯é¢å‘åˆ†æçš„æ•°æ®å­˜å‚¨ç³»ç»Ÿï¼Œé‡‡ç”¨ç»´åº¦å»ºæ¨¡æ–¹æ³•ã€‚

```text
æ•°æ®ä»“åº“æ¶æ„
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   æ•°æ®æº     â”‚â”€â”€â”€â†’â”‚  ETLå¤„ç†    â”‚â”€â”€â”€â†’â”‚  æ•°æ®ä»“åº“   â”‚â”€â”€â”€â†’â”‚  BI/æŠ¥è¡¨    â”‚
â”‚  (OLTP)     â”‚    â”‚  (æŠ½å–è½¬æ¢)  â”‚    â”‚  (OLAP)    â”‚    â”‚  (åˆ†æ)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚                  â”‚
                         â†“                  â†“
                   SQL: MERGE         SQL: çª—å£å‡½æ•°
                   SQL: CTE           SQL: ROLLUP/CUBE
```

---

## äºŒã€ç»´åº¦å»ºæ¨¡åŸºç¡€

### 2.1 æ ¸å¿ƒæ¦‚å¿µ

| æ¦‚å¿µ | å®šä¹‰ | SQLå¯¹åº” |
|------|------|---------|
| **äº‹å®è¡¨(Fact)** | ä¸šåŠ¡åº¦é‡æ•°æ® | åŒ…å«å¤–é”®å’Œåº¦é‡çš„è¡¨ |
| **ç»´åº¦è¡¨(Dimension)** | æè¿°æ€§å±æ€§ | åŒ…å«ä¸»é”®å’Œå±æ€§çš„è¡¨ |
| **åº¦é‡(Measure)** | å¯èšåˆçš„æ•°å€¼ | SUM/AVG/COUNTçš„åˆ— |
| **ç²’åº¦(Grain)** | äº‹å®è¡¨ä¸€è¡Œä»£è¡¨ä»€ä¹ˆ | ä¸»é”®å®šä¹‰ |

### 2.2 æ˜Ÿå‹ vs é›ªèŠ±

```text
æ˜Ÿå‹æ¨¡å‹ (Star Schema)          é›ªèŠ±æ¨¡å‹ (Snowflake Schema)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚ dim_timeâ”‚                    â”‚ dim_timeâ”‚
     â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
          â”‚                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ dim_    â”‚    dim_ â”‚          â”‚ dim_    â”‚    dim_ â”‚
â”‚ product â”‚ customerâ”‚          â”‚ product â”‚ customerâ”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”´â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”´â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
     â”‚         â”‚                    â”‚         â”‚
     â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
          â”‚                              â”‚
     â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
     â”‚  fact_  â”‚                    â”‚  fact_  â”‚
     â”‚  sales  â”‚                    â”‚  sales  â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                         â”‚
                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                              â”‚          â”‚          â”‚
                         â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”
                         â”‚categoryâ”‚ â”‚brand   â”‚ â”‚region  â”‚
                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ä¼˜ç‚¹ï¼šæŸ¥è¯¢ç®€å•ï¼Œæ€§èƒ½å¥½         ä¼˜ç‚¹ï¼šå‡å°‘å†—ä½™ï¼ŒèŠ‚çœç©ºé—´
ç¼ºç‚¹ï¼šæ•°æ®å†—ä½™               ç¼ºç‚¹ï¼šJOINå¤šï¼ŒæŸ¥è¯¢å¤æ‚
```

---

## ä¸‰ã€æ˜Ÿå‹æ¨¡å‹SQLå®ç°

### 3.1 ç»´åº¦è¡¨DDL

```sql
-- PostgreSQL 18: æ—¶é—´ç»´åº¦
CREATE TABLE dim_date (
    date_key        INTEGER PRIMARY KEY,  -- YYYYMMDDæ ¼å¼
    full_date       DATE NOT NULL UNIQUE,
    year            INTEGER NOT NULL,
    quarter         INTEGER NOT NULL,
    month           INTEGER NOT NULL,
    month_name      VARCHAR(20) NOT NULL,
    week            INTEGER NOT NULL,
    day_of_week     INTEGER NOT NULL,
    day_name        VARCHAR(20) NOT NULL,
    is_weekend      BOOLEAN NOT NULL,
    is_holiday      BOOLEAN DEFAULT FALSE,
    fiscal_year     INTEGER,
    fiscal_quarter  INTEGER
);

-- ç”Ÿæˆæ—¶é—´ç»´åº¦æ•°æ®
INSERT INTO dim_date
SELECT
    TO_CHAR(d, 'YYYYMMDD')::INTEGER AS date_key,
    d AS full_date,
    EXTRACT(YEAR FROM d)::INTEGER,
    EXTRACT(QUARTER FROM d)::INTEGER,
    EXTRACT(MONTH FROM d)::INTEGER,
    TO_CHAR(d, 'Month'),
    EXTRACT(WEEK FROM d)::INTEGER,
    EXTRACT(DOW FROM d)::INTEGER,
    TO_CHAR(d, 'Day'),
    EXTRACT(DOW FROM d) IN (0, 6),
    FALSE,
    EXTRACT(YEAR FROM d)::INTEGER,
    EXTRACT(QUARTER FROM d)::INTEGER
FROM generate_series('2020-01-01'::DATE, '2030-12-31'::DATE, '1 day') AS d;

-- äº§å“ç»´åº¦
CREATE TABLE dim_product (
    product_key     SERIAL PRIMARY KEY,
    product_id      INTEGER NOT NULL,  -- ä¸šåŠ¡é”®
    product_name    VARCHAR(200) NOT NULL,
    category        VARCHAR(100),
    subcategory     VARCHAR(100),
    brand           VARCHAR(100),
    unit_price      DECIMAL(10,2),
    -- SCD Type 2 æ”¯æŒ
    effective_date  DATE NOT NULL DEFAULT CURRENT_DATE,
    expiry_date     DATE DEFAULT '9999-12-31',
    is_current      BOOLEAN DEFAULT TRUE
);

-- å®¢æˆ·ç»´åº¦
CREATE TABLE dim_customer (
    customer_key    SERIAL PRIMARY KEY,
    customer_id     INTEGER NOT NULL,
    customer_name   VARCHAR(100) NOT NULL,
    email           VARCHAR(100),
    city            VARCHAR(100),
    region          VARCHAR(100),
    country         VARCHAR(100),
    customer_segment VARCHAR(50),
    effective_date  DATE NOT NULL DEFAULT CURRENT_DATE,
    expiry_date     DATE DEFAULT '9999-12-31',
    is_current      BOOLEAN DEFAULT TRUE
);
```

### 3.2 äº‹å®è¡¨DDL

```sql
-- é”€å”®äº‹å®è¡¨
CREATE TABLE fact_sales (
    sale_id         BIGSERIAL PRIMARY KEY,
    -- ç»´åº¦å¤–é”®
    date_key        INTEGER NOT NULL REFERENCES dim_date(date_key),
    product_key     INTEGER NOT NULL REFERENCES dim_product(product_key),
    customer_key    INTEGER NOT NULL REFERENCES dim_customer(customer_key),
    -- åº¦é‡
    quantity        INTEGER NOT NULL,
    unit_price      DECIMAL(10,2) NOT NULL,
    discount_amount DECIMAL(10,2) DEFAULT 0,
    sales_amount    DECIMAL(12,2) GENERATED ALWAYS AS (
        quantity * unit_price - discount_amount
    ) STORED,
    cost_amount     DECIMAL(12,2),
    profit_amount   DECIMAL(12,2) GENERATED ALWAYS AS (
        quantity * unit_price - discount_amount - COALESCE(cost_amount, 0)
    ) STORED
);

-- åˆ†åŒºï¼ˆæŒ‰å¹´ï¼‰
CREATE TABLE fact_sales_2024 PARTITION OF fact_sales
    FOR VALUES FROM (20240101) TO (20250101);
CREATE TABLE fact_sales_2025 PARTITION OF fact_sales
    FOR VALUES FROM (20250101) TO (20260101);

-- ç´¢å¼•
CREATE INDEX idx_fact_sales_date ON fact_sales(date_key);
CREATE INDEX idx_fact_sales_product ON fact_sales(product_key);
CREATE INDEX idx_fact_sales_customer ON fact_sales(customer_key);
```

### 3.3 æ˜Ÿå‹æ¨¡å‹æŸ¥è¯¢

```sql
-- å…¸å‹OLAPæŸ¥è¯¢ï¼šæŒ‰æœˆã€ç±»åˆ«çš„é”€å”®åˆ†æ
SELECT
    d.year,
    d.month_name,
    p.category,
    SUM(f.quantity) AS total_quantity,
    SUM(f.sales_amount) AS total_sales,
    SUM(f.profit_amount) AS total_profit,
    ROUND(SUM(f.profit_amount) / NULLIF(SUM(f.sales_amount), 0) * 100, 2) AS profit_margin
FROM fact_sales f
JOIN dim_date d ON f.date_key = d.date_key
JOIN dim_product p ON f.product_key = p.product_key
WHERE d.year = 2025
GROUP BY d.year, d.month, d.month_name, p.category
ORDER BY d.month, total_sales DESC;

-- å¤šç»´åˆ†æï¼šROLLUPç”Ÿæˆå°è®¡
SELECT
    COALESCE(d.year::TEXT, 'æ€»è®¡') AS year,
    COALESCE(d.quarter::TEXT, 'å°è®¡') AS quarter,
    COALESCE(p.category, 'å°è®¡') AS category,
    SUM(f.sales_amount) AS sales
FROM fact_sales f
JOIN dim_date d ON f.date_key = d.date_key
JOIN dim_product p ON f.product_key = p.product_key
GROUP BY ROLLUP (d.year, d.quarter, p.category)
ORDER BY d.year NULLS LAST, d.quarter NULLS LAST;
```

---

## å››ã€é›ªèŠ±æ¨¡å‹SQLå®ç°

```sql
-- é›ªèŠ±æ¨¡å‹ï¼šç»´åº¦è¡¨è¿›ä¸€æ­¥è§„èŒƒåŒ–
CREATE TABLE dim_category (
    category_key    SERIAL PRIMARY KEY,
    category_name   VARCHAR(100) NOT NULL,
    department      VARCHAR(100)
);

CREATE TABLE dim_brand (
    brand_key       SERIAL PRIMARY KEY,
    brand_name      VARCHAR(100) NOT NULL,
    manufacturer    VARCHAR(100)
);

CREATE TABLE dim_product_snowflake (
    product_key     SERIAL PRIMARY KEY,
    product_id      INTEGER NOT NULL,
    product_name    VARCHAR(200) NOT NULL,
    category_key    INTEGER REFERENCES dim_category(category_key),
    brand_key       INTEGER REFERENCES dim_brand(brand_key),
    unit_price      DECIMAL(10,2)
);

-- é›ªèŠ±æŸ¥è¯¢ï¼ˆæ›´å¤šJOINï¼‰
SELECT
    c.category_name,
    b.brand_name,
    SUM(f.sales_amount) AS sales
FROM fact_sales f
JOIN dim_product_snowflake p ON f.product_key = p.product_key
JOIN dim_category c ON p.category_key = c.category_key
JOIN dim_brand b ON p.brand_key = b.brand_key
GROUP BY c.category_name, b.brand_name;
```

---

## äº”ã€PostgreSQL 18æ•°æ®ä»“åº“

### 5.1 åˆ—å¼å­˜å‚¨æ‰©å±•

```sql
-- ä½¿ç”¨cstore_fdwæˆ–Citusåˆ—å¼å­˜å‚¨
-- é€‚åˆOLAPåœºæ™¯

-- åˆ›å»ºåˆ—å¼è¡¨ï¼ˆéœ€è¦å®‰è£…æ‰©å±•ï¼‰
-- CREATE EXTENSION cstore_fdw;
-- CREATE SERVER cstore_server FOREIGN DATA WRAPPER cstore_fdw;

-- æˆ–ä½¿ç”¨Citusåˆ†å¸ƒå¼
-- CREATE EXTENSION citus;
-- SELECT create_distributed_table('fact_sales', 'date_key');
```

### 5.2 åˆ†æå‡½æ•°åº”ç”¨

```sql
-- PostgreSQL 18: æ•°æ®ä»“åº“åˆ†ææŸ¥è¯¢
-- åŒæ¯”å¢é•¿åˆ†æ
WITH monthly_sales AS (
    SELECT
        d.year,
        d.month,
        SUM(f.sales_amount) AS sales
    FROM fact_sales f
    JOIN dim_date d ON f.date_key = d.date_key
    GROUP BY d.year, d.month
)
SELECT
    year, month, sales,
    LAG(sales, 12) OVER (ORDER BY year, month) AS prev_year_sales,
    ROUND((sales - LAG(sales, 12) OVER (ORDER BY year, month)) * 100.0 /
          NULLIF(LAG(sales, 12) OVER (ORDER BY year, month), 0), 2) AS yoy_growth
FROM monthly_sales
ORDER BY year DESC, month DESC;

-- å®¢æˆ·RFMåˆ†æï¼ˆæ•°æ®ä»“åº“ç‰ˆï¼‰
SELECT
    c.customer_segment,
    COUNT(DISTINCT f.customer_key) AS customer_count,
    SUM(f.sales_amount) AS total_sales,
    ROUND(AVG(f.sales_amount), 2) AS avg_order_value
FROM fact_sales f
JOIN dim_customer c ON f.customer_key = c.customer_key
WHERE c.is_current = TRUE
GROUP BY c.customer_segment
ORDER BY total_sales DESC;
```

---

## å…­ã€ETL SQLæ¨¡å¼

### 6.1 å¢é‡åŠ è½½

```sql
-- å¢é‡åŠ è½½äº‹å®è¡¨
INSERT INTO fact_sales (date_key, product_key, customer_key, quantity, unit_price, cost_amount)
SELECT
    TO_CHAR(o.order_date, 'YYYYMMDD')::INTEGER,
    p.product_key,
    c.customer_key,
    oi.quantity,
    oi.unit_price,
    oi.cost
FROM staging_orders o
JOIN staging_order_items oi ON o.order_id = oi.order_id
JOIN dim_product p ON oi.product_id = p.product_id AND p.is_current = TRUE
JOIN dim_customer c ON o.customer_id = c.customer_id AND c.is_current = TRUE
WHERE o.order_date > (SELECT COALESCE(MAX(full_date), '1900-01-01') FROM dim_date d
                      JOIN fact_sales f ON d.date_key = f.date_key);
```

### 6.2 SCD Type 2 å®ç°

```sql
-- ç¼“æ…¢å˜åŒ–ç»´åº¦ Type 2
-- å½“å®¢æˆ·ä¿¡æ¯å˜åŒ–æ—¶ï¼Œåˆ›å»ºæ–°ç‰ˆæœ¬
CREATE OR REPLACE PROCEDURE update_customer_scd2(
    p_customer_id INTEGER,
    p_name VARCHAR(100),
    p_city VARCHAR(100),
    p_segment VARCHAR(50)
)
LANGUAGE plpgsql AS $$
BEGIN
    -- å…³é—­æ—§è®°å½•
    UPDATE dim_customer
    SET expiry_date = CURRENT_DATE - 1, is_current = FALSE
    WHERE customer_id = p_customer_id AND is_current = TRUE;

    -- æ’å…¥æ–°è®°å½•
    INSERT INTO dim_customer (customer_id, customer_name, city, customer_segment, effective_date)
    VALUES (p_customer_id, p_name, p_city, p_segment, CURRENT_DATE);
END;
$$;
```

---

## ç›¸å…³èµ„æº

### ç›¸å…³æ–‡æ¡£

- [10.03-æ•°æ®åˆ†æSQLæ¨¡å¼](./10.03-æ•°æ®åˆ†æSQLæ¨¡å¼.md)
- [07.03-ETLæµç¨‹æ¡ˆä¾‹](../07-å®è·µæ¡ˆä¾‹/07.03-ETLæµç¨‹æ¡ˆä¾‹.md)
- [Design/07.41-æ•°æ®åˆ†æåº”ç”¨](../../Design/07-æ•°æ®åº“è®¾è®¡å®è·µ/07.41-æ•°æ®åˆ†æåº”ç”¨æ•°æ®åº“è®¾è®¡.md)

---

**ç»´æŠ¤è€…**: SQL Standards Team
**æœ€åæ›´æ–°**: 2025-12-01
