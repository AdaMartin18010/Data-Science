# 反范式与性能优化

> **创建日期**：2025-12-01
> **难度**：⭐⭐⭐⭐
> **前置知识**：范式理论、索引原理
> **应用场景**：高并发系统、OLAP分析、读多写少场景

---

## 📋 目录

- [反范式与性能优化](#反范式与性能优化)
  - [📋 目录](#-目录)
  - [一、概述](#一概述)
  - [二、反范式设计原则](#二反范式设计原则)
    - [2.1 何时使用反范式](#21-何时使用反范式)
    - [2.2 反范式代价](#22-反范式代价)
  - [三、常见反范式模式](#三常见反范式模式)
    - [3.1 预计算聚合列](#31-预计算聚合列)
    - [3.2 冗余外键属性](#32-冗余外键属性)
    - [3.3 物化路径（层次结构）](#33-物化路径层次结构)
    - [3.4 JSON嵌套文档](#34-json嵌套文档)
  - [四、PostgreSQL 18实现](#四postgresql-18实现)
    - [4.1 生成列实现反范式](#41-生成列实现反范式)
    - [4.2 物化视图](#42-物化视图)
    - [4.3 表继承实现冗余](#43-表继承实现冗余)
  - [五、SQLite 3.45+实现](#五sqlite-345实现)
    - [5.1 触发器维护冗余](#51-触发器维护冗余)
    - [5.2 JSON反范式](#52-json反范式)
  - [六、决策框架](#六决策框架)
    - [6.1 反范式决策树](#61-反范式决策树)
    - [6.2 反范式模式选择](#62-反范式模式选择)
  - [相关资源](#相关资源)
    - [相关文档](#相关文档)

---

## 一、概述

**反范式(Denormalization)** 是有意违反范式规则，通过数据冗余换取查询性能的设计策略。

```text
范式 vs 反范式权衡
══════════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────────────┐
│                        设计权衡天平                                          │
├────────────────────────────┬────────────────────────────────────────────────┤
│        范式化设计           │           反范式化设计                          │
├────────────────────────────┼────────────────────────────────────────────────┤
│ ✅ 数据一致性高             │ ✅ 查询性能高                                  │
│ ✅ 存储空间小               │ ✅ 减少JOIN操作                                │
│ ✅ 更新异常少               │ ✅ 简化复杂查询                                │
│ ❌ 查询需要多表JOIN         │ ❌ 数据冗余                                    │
│ ❌ 聚合查询性能低           │ ❌ 更新需同步多处                              │
├────────────────────────────┴────────────────────────────────────────────────┤
│                 适用场景决策：读写比例 + 一致性要求 + 性能目标                  │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 二、反范式设计原则

### 2.1 何时使用反范式

| 场景 | 读写比 | 推荐策略 |
|------|--------|---------|
| **OLTP系统** | 1:1 | 保持范式化 |
| **OLAP/报表** | 100:1 | 反范式化 |
| **缓存层** | 1000:1 | 完全反范式 |
| **实时分析** | 10:1 | 部分反范式 |

### 2.2 反范式代价

```text
反范式的代价分析
══════════════════════════════════════════════════════════════════════════════

1. 存储代价：冗余数据占用额外空间
   - 估算：冗余字段数 × 平均字段大小 × 记录数

2. 写入代价：更新需同步多处
   - 估算：每次更新影响的表数 × 更新频率

3. 一致性风险：数据不一致的可能性
   - 缓解：触发器、应用层同步、定期校验

决策公式（简化）：
反范式收益 = 查询性能提升 × 查询频率
反范式代价 = 存储成本 + 更新复杂度 + 一致性风险

当 收益 >> 代价 时，选择反范式
```

---

## 三、常见反范式模式

### 3.1 预计算聚合列

```sql
-- 问题：频繁计算订单总金额
-- 范式化设计
SELECT o.order_id, SUM(oi.quantity * oi.unit_price) AS total
FROM orders o
JOIN order_items oi ON o.order_id = oi.order_id
GROUP BY o.order_id;

-- 反范式：添加预计算列
ALTER TABLE orders ADD COLUMN total_amount DECIMAL(12,2);
ALTER TABLE orders ADD COLUMN item_count INTEGER;

-- 触发器维护一致性
CREATE OR REPLACE FUNCTION update_order_totals()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE orders SET
        total_amount = (SELECT SUM(quantity * unit_price) FROM order_items WHERE order_id = NEW.order_id),
        item_count = (SELECT COUNT(*) FROM order_items WHERE order_id = NEW.order_id)
    WHERE order_id = NEW.order_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_order_items_change
AFTER INSERT OR UPDATE OR DELETE ON order_items
FOR EACH ROW EXECUTE FUNCTION update_order_totals();
```

### 3.2 冗余外键属性

```sql
-- 问题：订单查询总需要JOIN用户表获取用户名
-- 范式化
SELECT o.*, u.username FROM orders o JOIN users u ON o.user_id = u.user_id;

-- 反范式：冗余用户名到订单表
ALTER TABLE orders ADD COLUMN customer_name VARCHAR(100);

-- 插入时冗余
INSERT INTO orders (user_id, customer_name, total_amount)
SELECT 123, username, 99.99 FROM users WHERE user_id = 123;

-- 用户改名时同步（触发器或应用层）
UPDATE orders SET customer_name = '新名字' WHERE user_id = 123;
```

### 3.3 物化路径（层次结构）

```sql
-- 问题：递归查询组织架构性能差
-- 范式化：自引用
CREATE TABLE departments (
    dept_id INTEGER PRIMARY KEY,
    name VARCHAR(100),
    parent_id INTEGER REFERENCES departments(dept_id)
);

-- 反范式：物化路径
ALTER TABLE departments ADD COLUMN path TEXT;  -- 如 '/1/3/7/'
ALTER TABLE departments ADD COLUMN level INTEGER;

-- 查询某部门的所有下属（无需递归）
SELECT * FROM departments WHERE path LIKE '/1/3/%';

-- 查询某部门的所有上级
SELECT * FROM departments
WHERE '/1/3/7/' LIKE path || '%'
ORDER BY level;
```

### 3.4 JSON嵌套文档

```sql
-- 问题：频繁查询商品及其所有属性
-- 范式化：多表
SELECT p.*, json_agg(a.*) AS attributes
FROM products p
LEFT JOIN product_attributes a ON p.product_id = a.product_id
GROUP BY p.product_id;

-- 反范式：JSONB嵌套
ALTER TABLE products ADD COLUMN attributes JSONB DEFAULT '{}';

-- 直接查询，无需JOIN
SELECT product_id, name, attributes->>'color' AS color
FROM products
WHERE attributes->>'category' = 'electronics';
```

---

## 四、PostgreSQL 18实现

### 4.1 生成列实现反范式

```sql
-- PostgreSQL 18: 使用生成列自动维护冗余数据
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    items JSONB NOT NULL,  -- 订单项JSON数组
    -- 自动计算的反范式列
    total_amount DECIMAL(12,2) GENERATED ALWAYS AS (
        (SELECT SUM((item->>'quantity')::INT * (item->>'price')::DECIMAL)
         FROM jsonb_array_elements(items) AS item)
    ) STORED,
    item_count INTEGER GENERATED ALWAYS AS (
        jsonb_array_length(items)
    ) STORED
);

-- 插入数据
INSERT INTO orders (items) VALUES
('[{"product_id": 1, "quantity": 2, "price": 29.99},
  {"product_id": 2, "quantity": 1, "price": 49.99}]');

-- 自动计算total_amount和item_count
SELECT order_id, total_amount, item_count FROM orders;
```

### 4.2 物化视图

```sql
-- PostgreSQL 18: 物化视图作为反范式策略
CREATE MATERIALIZED VIEW mv_product_stats AS
SELECT
    p.product_id,
    p.name,
    p.category_id,
    c.category_name,
    COUNT(oi.order_id) AS order_count,
    SUM(oi.quantity) AS total_sold,
    SUM(oi.quantity * oi.unit_price) AS total_revenue,
    AVG(r.rating) AS avg_rating
FROM products p
JOIN categories c ON p.category_id = c.category_id
LEFT JOIN order_items oi ON p.product_id = oi.product_id
LEFT JOIN reviews r ON p.product_id = r.product_id
GROUP BY p.product_id, p.name, p.category_id, c.category_name;

-- 创建索引加速查询
CREATE INDEX idx_mv_product_stats_category ON mv_product_stats(category_id);

-- 定期刷新
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_product_stats;

-- 查询（无需JOIN）
SELECT * FROM mv_product_stats WHERE category_id = 1 ORDER BY total_revenue DESC;
```

### 4.3 表继承实现冗余

```sql
-- PostgreSQL: 使用表继承
CREATE TABLE base_orders (
    order_id SERIAL PRIMARY KEY,
    user_id INTEGER,
    order_date DATE,
    status VARCHAR(20)
);

CREATE TABLE orders_with_user (
    customer_name VARCHAR(100),
    customer_email VARCHAR(100)
) INHERITS (base_orders);

-- 查询时自动包含冗余字段
SELECT * FROM orders_with_user WHERE user_id = 123;
```

---

## 五、SQLite 3.45+实现

### 5.1 触发器维护冗余

```sql
-- SQLite 3.45+: 反范式实现
CREATE TABLE orders (
    order_id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER NOT NULL,
    customer_name TEXT,  -- 冗余字段
    total_amount REAL DEFAULT 0,
    item_count INTEGER DEFAULT 0
);

CREATE TABLE order_items (
    item_id INTEGER PRIMARY KEY AUTOINCREMENT,
    order_id INTEGER NOT NULL,
    product_id INTEGER NOT NULL,
    quantity INTEGER NOT NULL,
    unit_price REAL NOT NULL,
    FOREIGN KEY (order_id) REFERENCES orders(order_id)
);

-- 触发器维护冗余数据
CREATE TRIGGER trg_update_order_total
AFTER INSERT ON order_items
BEGIN
    UPDATE orders SET
        total_amount = (
            SELECT COALESCE(SUM(quantity * unit_price), 0)
            FROM order_items WHERE order_id = NEW.order_id
        ),
        item_count = (
            SELECT COUNT(*) FROM order_items WHERE order_id = NEW.order_id
        )
    WHERE order_id = NEW.order_id;
END;
```

### 5.2 JSON反范式

```sql
-- SQLite 3.45+: JSON存储相关数据
CREATE TABLE products (
    product_id INTEGER PRIMARY KEY,
    name TEXT NOT NULL,
    -- 反范式：嵌套属性和统计
    details TEXT DEFAULT '{}'  -- JSON
) STRICT;

-- 存储冗余统计
UPDATE products SET details = json_set(
    details,
    '$.order_count', (SELECT COUNT(*) FROM order_items WHERE product_id = 1),
    '$.avg_rating', (SELECT AVG(rating) FROM reviews WHERE product_id = 1)
)
WHERE product_id = 1;

-- 查询
SELECT
    product_id,
    name,
    json_extract(details, '$.order_count') AS orders,
    json_extract(details, '$.avg_rating') AS rating
FROM products;
```

---

## 六、决策框架

### 6.1 反范式决策树

```text
反范式决策树
══════════════════════════════════════════════════════════════════════════════

[查询性能是否满足要求?]
    │
    ├─→ 是 ─→ 保持范式化设计 ✓
    │
    └─→ 否 ─→ [是否可以通过索引优化?]
                │
                ├─→ 是 ─→ 添加索引 ✓
                │
                └─→ 否 ─→ [读写比例?]
                          │
                          ├─→ 读多写少(>10:1) ─→ 考虑反范式
                          │                      │
                          │                      ├─→ [数据一致性要求?]
                          │                      │     │
                          │                      │     ├─→ 高 ─→ 物化视图/触发器
                          │                      │     │
                          │                      │     └─→ 中/低 ─→ 应用层冗余
                          │
                          └─→ 读写均衡 ─→ 保持范式化，考虑缓存
```

### 6.2 反范式模式选择

| 场景 | 推荐模式 | PostgreSQL | SQLite |
|------|---------|------------|--------|
| 预计算聚合 | 生成列/触发器 | GENERATED ALWAYS | 触发器 |
| 减少JOIN | 冗余外键属性 | 触发器同步 | 触发器同步 |
| 层次查询 | 物化路径 | ltree扩展 | path字符串 |
| 复杂报表 | 物化视图 | MATERIALIZED VIEW | 手动维护表 |
| 灵活属性 | JSON嵌套 | JSONB | JSON1扩展 |

---

## 相关资源

### 相关文档

- [01.07-范式理论完整因果链](../01-理论基础/01.07-范式理论完整因果链.md)
- [10.01-ER模型与SQL映射](./10.01-ER模型与SQL映射.md)
- [Design/07.08-性能调优](../../Design/07-数据库设计实践/07.08-数据库性能调优实战.md)

---

**维护者**: SQL Standards Team
**最后更新**: 2025-12-01
