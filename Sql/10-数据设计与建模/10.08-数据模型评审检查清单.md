# 数据模型评审检查清单

> **创建日期**: 2025-12-04
> **适用**: ER模型 → SQL DDL
> **难度**: ⭐⭐⭐⭐

---

## 评审维度总览

```text
数据模型评审六维度
══════════════════════════════════════════════════════════════════════════════

┌──────────────┬──────────────┬──────────────┐
│ 1. 范式检查  │ 2. 完整性    │ 3. 性能      │
│ • 1NF-BCNF   │ • 实体完整性 │ • 索引设计   │
│ • 函数依赖   │ • 参照完整性 │ • 查询模式   │
│ • 冗余分析   │ • 域完整性   │ • 分区策略   │
├──────────────┼──────────────┼──────────────┤
│ 4. 扩展性    │ 5. 安全性    │ 6. 标准化    │
│ • 水平扩展   │ • 访问控制   │ • 命名规范   │
│ • 垂直扩展   │ • 数据脱敏   │ • 注释文档   │
│ • 历史数据   │ • 审计日志   │ • 版本管理   │
└──────────────┴──────────────┴──────────────┘
```

---

## 维度1：范式检查

### 1NF检查（原子性）

```sql
-- ❌ 违反1NF：phone包含多个值
CREATE TABLE users_bad (
    id INTEGER PRIMARY KEY,
    name TEXT,
    phones TEXT  -- "13800138000,13900139000"
);

-- ✅ 符合1NF
CREATE TABLE users (
    id INTEGER PRIMARY KEY,
    name TEXT
);

CREATE TABLE user_phones (
    id INTEGER PRIMARY KEY,
    user_id INTEGER,
    phone TEXT,
    phone_type TEXT CHECK(phone_type IN ('mobile', 'home', 'work')),
    FOREIGN KEY (user_id) REFERENCES users(id)
);
```

### 2NF检查（消除部分依赖）

```sql
-- ❌ 违反2NF：product_name依赖于product_id（部分依赖）
CREATE TABLE order_items_bad (
    order_id INTEGER,
    product_id INTEGER,
    product_name TEXT,  -- 依赖于product_id，不依赖于(order_id, product_id)
    quantity INTEGER,
    PRIMARY KEY (order_id, product_id)
);

-- ✅ 符合2NF：product_name移到products表
CREATE TABLE order_items (
    order_id INTEGER,
    product_id INTEGER,
    quantity INTEGER,
    PRIMARY KEY (order_id, product_id),
    FOREIGN KEY (product_id) REFERENCES products(id)
);

CREATE TABLE products (
    id INTEGER PRIMARY KEY,
    name TEXT,
    price DECIMAL(10, 2)
);
```

### 3NF检查（消除传递依赖）

```sql
-- ❌ 违反3NF：city_name依赖于city_id（传递依赖）
CREATE TABLE users_bad (
    id INTEGER PRIMARY KEY,
    name TEXT,
    city_id INTEGER,
    city_name TEXT  -- 传递依赖: id → city_id → city_name
);

-- ✅ 符合3NF
CREATE TABLE users (
    id INTEGER PRIMARY KEY,
    name TEXT,
    city_id INTEGER,
    FOREIGN KEY (city_id) REFERENCES cities(id)
);

CREATE TABLE cities (
    id INTEGER PRIMARY KEY,
    name TEXT
);
```

### BCNF检查（强3NF）

```sql
-- 场景：教师-课程-教室
-- 函数依赖：
-- • (teacher, course) → classroom
-- • classroom → teacher（每个教室只有一个教师）

-- ❌ 违反BCNF
CREATE TABLE teaching_bad (
    teacher TEXT,
    course TEXT,
    classroom TEXT,
    PRIMARY KEY (teacher, course)
);
-- 问题: classroom不是超键，但决定teacher

-- ✅ 符合BCNF：拆分
CREATE TABLE classroom_teacher (
    classroom TEXT PRIMARY KEY,
    teacher TEXT NOT NULL
);

CREATE TABLE course_classroom (
    course TEXT PRIMARY KEY,
    classroom TEXT NOT NULL,
    FOREIGN KEY (classroom) REFERENCES classroom_teacher(classroom)
);
```

---

## 维度2：完整性检查

### 实体完整性

```sql
-- ✅ 主键约束
CREATE TABLE orders (
    id INTEGER PRIMARY KEY,  -- NOT NULL隐含
    order_no TEXT NOT NULL UNIQUE,  -- 候选键
    user_id INTEGER NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- ✅ 检查点：
-- • 每个表都有主键？
-- • 主键是否稳定（不可变）？
-- • 主键是否简短（性能）？
-- • 候选键是否标记为UNIQUE？
```

### 参照完整性

```sql
-- ✅ 外键约束
CREATE TABLE order_items (
    id INTEGER PRIMARY KEY,
    order_id INTEGER NOT NULL,
    product_id INTEGER NOT NULL,
    FOREIGN KEY (order_id) REFERENCES orders(id) ON DELETE CASCADE,
    FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE RESTRICT
);

-- ✅ 检查点：
-- • 所有外键都定义了约束？
-- • ON DELETE/UPDATE动作合理？
--   - CASCADE: 订单删除时，订单项也删除
--   - RESTRICT: 产品有订单项时，不能删除
--   - SET NULL: 用户删除时，订单user_id设为NULL（罕见）
-- • 外键列有索引？（PostgreSQL需要手动创建）
CREATE INDEX idx_order_items_order_id ON order_items(order_id);
CREATE INDEX idx_order_items_product_id ON order_items(product_id);
```

### 域完整性

```sql
-- ✅ CHECK约束
CREATE TABLE products (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL CHECK(length(name) >= 3),
    price DECIMAL(10, 2) NOT NULL CHECK(price > 0),
    stock INTEGER NOT NULL CHECK(stock >= 0),
    status TEXT NOT NULL CHECK(status IN ('active', 'inactive', 'deleted')),
    discount_rate DECIMAL(3, 2) CHECK(discount_rate BETWEEN 0 AND 1)
);

-- ✅ NOT NULL约束
-- 检查点：哪些列必须有值？

-- ✅ DEFAULT值
CREATE TABLE users (
    id INTEGER PRIMARY KEY,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    login_count INTEGER NOT NULL DEFAULT 0
);
```

---

## 维度3：性能检查

### 索引设计

```sql
-- 检查清单

-- ✅ 1. 主键自动有索引
-- ✅ 2. 外键列有索引
CREATE INDEX idx_orders_user_id ON orders(user_id);

-- ✅ 3. 常用WHERE条件有索引
-- 查询: SELECT * FROM orders WHERE status = 'pending'
CREATE INDEX idx_orders_status ON orders(status);

-- ✅ 4. 常用ORDER BY/GROUP BY有索引
-- 查询: SELECT * FROM orders ORDER BY created_at DESC
CREATE INDEX idx_orders_created ON orders(created_at DESC);

-- ✅ 5. 复合索引列顺序正确
-- 查询: WHERE user_id = ? AND status = ? ORDER BY created_at
CREATE INDEX idx_orders_user_status_created
ON orders(user_id, status, created_at DESC);
-- 列顺序: 等值过滤 → 范围过滤/排序

-- ✅ 6. 覆盖索引（Index-Only Scan）
-- 查询: SELECT id, status, created_at FROM orders WHERE user_id = ?
CREATE INDEX idx_orders_user_covering
ON orders(user_id) INCLUDE (status, created_at);  -- PostgreSQL 11+

-- ❌ 7. 避免冗余索引
-- BAD: 同时有 (a) 和 (a, b) 索引（前者冗余）
-- GOOD: 只保留 (a, b)

-- ❌ 8. 避免过多索引（写入性能）
-- 规则: 单表索引数 < 5-7个
```

### 查询模式优化

```sql
-- 检查清单

-- ✅ 1. 避免SELECT *
-- BAD:  SELECT * FROM orders
-- GOOD: SELECT id, order_no, status FROM orders

-- ✅ 2. 避免N+1查询
-- BAD:  SELECT * FROM orders (N次)
--       for each order: SELECT * FROM order_items WHERE order_id = ?
-- GOOD: SELECT * FROM orders JOIN order_items ON ...

-- ✅ 3. 使用批量操作
-- BAD:  INSERT INTO ... VALUES (...) (1000次)
-- GOOD: INSERT INTO ... VALUES (...), (...), ... (1次)

-- ✅ 4. 大表添加分页
SELECT * FROM orders
ORDER BY created_at DESC
LIMIT 100 OFFSET 0;
```

---

## 维度4：扩展性检查

### 水平扩展设计

```sql
-- ✅ 1. 避免跨库JOIN
-- 设计：用户表和订单表在同一数据库

-- ✅ 2. 分片键选择
-- 按user_id分片 → 用户相关数据在同一分片
CREATE TABLE orders (
    id BIGINT PRIMARY KEY,
    user_id BIGINT NOT NULL,  -- 分片键
    order_no TEXT NOT NULL,
    created_at TIMESTAMP NOT NULL
);

-- ✅ 3. 避免全局唯一约束（分片场景）
-- BAD:  order_no UNIQUE（跨分片）
-- GOOD: (user_id, order_no) UNIQUE（分片内唯一）

-- ✅ 4. 分布式ID生成
-- 使用Snowflake ID（64位）
CREATE TABLE orders (
    id BIGINT PRIMARY KEY,  -- Snowflake ID: 时间戳+机器ID+序列号
    ...
);
```

### 历史数据管理

```sql
-- ✅ 1. 分区表（按时间）
CREATE TABLE orders (
    id BIGINT PRIMARY KEY,
    created_at TIMESTAMP NOT NULL,
    ...
) PARTITION BY RANGE (created_at);

CREATE TABLE orders_2025_01 PARTITION OF orders
FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');

CREATE TABLE orders_2025_02 PARTITION OF orders
FOR VALUES FROM ('2025-02-01') TO ('2025-03-01');

-- ✅ 2. 归档策略
-- 定期将旧数据移到归档表
INSERT INTO orders_archive SELECT * FROM orders WHERE created_at < '2024-01-01';
DELETE FROM orders WHERE created_at < '2024-01-01';
```

---

## 维度5：安全性检查

### 访问控制

```sql
-- ✅ 1. 行级安全（RLS）PostgreSQL
CREATE TABLE orders (
    id BIGINT PRIMARY KEY,
    user_id BIGINT NOT NULL,
    ...
);

ALTER TABLE orders ENABLE ROW LEVEL SECURITY;

-- 用户只能看到自己的订单
CREATE POLICY user_orders_policy ON orders
FOR SELECT
USING (user_id = current_setting('app.current_user_id')::BIGINT);

-- ✅ 2. 列级权限
-- 敏感列（password_hash）只有特定角色可见
GRANT SELECT (id, username, email) ON users TO app_role;
-- 不授予password_hash的SELECT权限
```

### 数据脱敏

```sql
-- ✅ 1. 敏感数据加密存储
CREATE TABLE users (
    id BIGINT PRIMARY KEY,
    email TEXT NOT NULL,
    phone_encrypted BYTEA,  -- 加密存储
    id_card_hash TEXT  -- 单向哈希
);

-- ✅ 2. 视图脱敏
CREATE VIEW users_masked AS
SELECT
    id,
    username,
    substring(email, 1, 3) || '***' || substring(email, position('@' in email)) as email_masked,
    '***' || right(phone, 4) as phone_masked
FROM users;

-- 应用查询脱敏视图
GRANT SELECT ON users_masked TO app_role;
```

### 审计日志

```sql
-- ✅ 审计表设计
CREATE TABLE audit_log (
    id BIGINT PRIMARY KEY,
    table_name TEXT NOT NULL,
    operation TEXT NOT NULL CHECK(operation IN ('INSERT', 'UPDATE', 'DELETE')),
    record_id BIGINT NOT NULL,
    old_data JSONB,
    new_data JSONB,
    user_id BIGINT,
    ip_address INET,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- 触发器自动记录
CREATE TRIGGER audit_orders AFTER UPDATE OR DELETE ON orders
FOR EACH ROW EXECUTE FUNCTION log_audit();
```

---

## 维度6：标准化检查

### 命名规范

```text
✅ 表名
• 复数名词: users, orders, products
• 小写+下划线: order_items（不是OrderItems）
• 避免缩写: 使用products而不是prods

✅ 列名
• 小写+下划线: created_at, user_id
• 布尔列: is_*, has_*, can_*
• 时间戳: created_at, updated_at, deleted_at
• 外键: <关联表>_id (user_id, product_id)

✅ 索引名
• idx_<表名>_<列名>: idx_orders_user_id
• 复合索引: idx_orders_user_status
• 唯一索引: uniq_users_email

✅ 约束名
• pk_<表名>: pk_orders
• fk_<表名>_<列名>: fk_orders_user_id
• chk_<表名>_<列名>: chk_products_price
```

### 注释文档

```sql
-- ✅ 表注释
COMMENT ON TABLE orders IS '订单表：存储所有用户订单';

-- ✅ 列注释
COMMENT ON COLUMN orders.status IS '订单状态：pending(待支付), paid(已支付), shipped(已发货), completed(已完成), cancelled(已取消)';

-- ✅ 枚举值文档化
CREATE TABLE orders (
    status TEXT NOT NULL CHECK(status IN (
        'pending',    -- 待支付
        'paid',       -- 已支付
        'shipped',    -- 已发货
        'completed',  -- 已完成
        'cancelled'   -- 已取消
    ))
);
```

---

## 评审检查表（Checklist）

```text
数据模型评审检查表
══════════════════════════════════════════════════════════════════════════════

□ 范式检查
  □ 所有表符合1NF（原子性）
  □ 所有表符合2NF（无部分依赖）
  □ 所有表符合3NF（无传递依赖）
  □ 冗余设计有明确理由（性能优化）

□ 完整性检查
  □ 每个表有主键
  □ 所有外键定义了约束
  □ 敏感列有NOT NULL约束
  □ 数值/枚举列有CHECK约束
  □ 时间戳列有DEFAULT值

□ 性能检查
  □ 主键和外键有索引
  □ 常用WHERE/ORDER BY列有索引
  □ 复合索引列顺序合理
  □ 无冗余索引
  □ 考虑了覆盖索引

□ 扩展性检查
  □ 设计支持水平扩展（分片）
  □ 大表有分区策略
  □ 历史数据有归档计划
  □ ID生成方案可扩展

□ 安全性检查
  □ 敏感数据加密存储
  □ 行级安全策略（如需要）
  □ 审计日志机制
  □ 最小权限原则

□ 标准化检查
  □ 命名符合团队规范
  □ 所有表/列有注释
  □ ER图与DDL一致
  □ 版本管理（迁移脚本）
```

---

**文档版本**: v1.0.0
**最后更新**: 2025-12-04
