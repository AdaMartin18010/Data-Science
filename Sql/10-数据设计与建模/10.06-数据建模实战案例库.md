# æ•°æ®å»ºæ¨¡å®æˆ˜æ¡ˆä¾‹åº“

> **åˆ›å»ºæ—¥æœŸ**ï¼š2025-12-04
> **ç‰ˆæœ¬**ï¼šPostgreSQL 18 / SQLite 3.47.x
> **éš¾åº¦**ï¼šâ­â­â­â­

---

## ğŸ“‹ æ¡ˆä¾‹1ï¼šç¤¾äº¤ç½‘ç»œæ•°æ®æ¨¡å‹

### ERæ¨¡å‹

```text
ç¤¾äº¤ç½‘ç»œæ ¸å¿ƒå®ä½“
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[Users] 1 â”€â”€â”€â”€ N [Posts] N â”€â”€â”€â”€ N [Users]
   â”‚                              (Likes)
   â”‚ 1
   â”‚
   â”‚ N
[Friendships] (å¤šå¯¹å¤šè‡ªå…³è”)
   user_id â†â†’ friend_id
```

### PostgreSQL 18å®ç°

```sql
-- ç”¨æˆ·è¡¨
CREATE TABLE users (
    user_id BIGSERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL UNIQUE,
    bio TEXT,
    avatar_url TEXT,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- å¥½å‹å…³ç³»è¡¨ï¼ˆå¯¹ç§°å…³ç³»ï¼‰
CREATE TABLE friendships (
    friendship_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(user_id),
    friend_id BIGINT NOT NULL REFERENCES users(user_id),
    status VARCHAR(20) NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'accepted', 'blocked')),
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,

    -- ç¡®ä¿ä¸é‡å¤ï¼ˆæ— è®ºé¡ºåºï¼‰
    CONSTRAINT unique_friendship UNIQUE (
        LEAST(user_id, friend_id),
        GREATEST(user_id, friend_id)
    ),
    -- ä¸èƒ½è‡ªå·±åŠ è‡ªå·±
    CONSTRAINT no_self_friendship CHECK (user_id != friend_id)
);

CREATE INDEX idx_friendships_user ON friendships(user_id) WHERE status = 'accepted';
CREATE INDEX idx_friendships_friend ON friendships(friend_id) WHERE status = 'accepted';

-- å¸–å­è¡¨
CREATE TABLE posts (
    post_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(user_id),
    content TEXT NOT NULL,
    media_urls TEXT[],  -- PostgreSQLæ•°ç»„
    visibility VARCHAR(20) DEFAULT 'public' CHECK (visibility IN ('public', 'friends', 'private')),
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,

    -- å…¨æ–‡æœç´¢
    search_vector tsvector GENERATED ALWAYS AS (
        to_tsvector('english', content)
    ) STORED
);

CREATE INDEX idx_posts_user_created ON posts(user_id, created_at DESC);
CREATE INDEX idx_posts_search ON posts USING GIN(search_vector);

-- ç‚¹èµè¡¨ï¼ˆå¤šå¯¹å¤šï¼‰
CREATE TABLE post_likes (
    like_id BIGSERIAL PRIMARY KEY,
    post_id BIGINT NOT NULL REFERENCES posts(post_id) ON DELETE CASCADE,
    user_id BIGINT NOT NULL REFERENCES users(user_id),
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,

    UNIQUE(post_id, user_id)  -- æ¯äººåªèƒ½ç‚¹èµä¸€æ¬¡
);

CREATE INDEX idx_likes_post ON post_likes(post_id);
CREATE INDEX idx_likes_user ON post_likes(user_id, created_at DESC);

-- è¯„è®ºè¡¨ï¼ˆè‡ªå…³è”å±‚æ¬¡ç»“æ„ï¼‰
CREATE TABLE comments (
    comment_id BIGSERIAL PRIMARY KEY,
    post_id BIGINT NOT NULL REFERENCES posts(post_id) ON DELETE CASCADE,
    user_id BIGINT NOT NULL REFERENCES users(user_id),
    parent_comment_id BIGINT REFERENCES comments(comment_id) ON DELETE CASCADE,
    content TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_comments_post ON comments(post_id, created_at);
CREATE INDEX idx_comments_parent ON comments(parent_comment_id);
```

### æŸ¥è¯¢ç¤ºä¾‹

```sql
-- æŸ¥è¯¢1ï¼šè·å–ç”¨æˆ·åŠ¨æ€ï¼ˆå«å¥½å‹å¸–å­ï¼‰
WITH user_friends AS (
    SELECT DISTINCT
        CASE
            WHEN user_id = 1001 THEN friend_id
            ELSE user_id
        END AS friend_id
    FROM friendships
    WHERE (user_id = 1001 OR friend_id = 1001)
        AND status = 'accepted'
)
SELECT
    p.post_id,
    u.username,
    p.content,
    p.created_at,
    COUNT(DISTINCT pl.user_id) AS like_count,
    COUNT(DISTINCT c.comment_id) AS comment_count
FROM posts p
JOIN users u ON p.user_id = u.user_id
LEFT JOIN post_likes pl ON p.post_id = pl.post_id
LEFT JOIN comments c ON p.post_id = c.post_id
WHERE p.user_id IN (SELECT friend_id FROM user_friends UNION SELECT 1001)
    AND p.created_at >= CURRENT_TIMESTAMP - INTERVAL '7 days'
    AND p.visibility IN ('public', 'friends')
GROUP BY p.post_id, u.username, p.content, p.created_at
ORDER BY p.created_at DESC
LIMIT 50;

-- æŸ¥è¯¢2ï¼šNåº¦å¥½å‹æŸ¥è¯¢ï¼ˆé€’å½’CTEï¼‰
WITH RECURSIVE friend_network(user_id, friend_id, degree) AS (
    SELECT 1001, 1001, 0

    UNION

    SELECT
        fn.user_id,
        CASE
            WHEN f.user_id = fn.friend_id THEN f.friend_id
            ELSE f.user_id
        END,
        fn.degree + 1
    FROM friend_network fn
    JOIN friendships f ON (fn.friend_id = f.user_id OR fn.friend_id = f.friend_id)
    WHERE fn.degree < 3
        AND f.status = 'accepted'
)
SELECT DISTINCT friend_id, MIN(degree) AS closest_degree
FROM friend_network
WHERE user_id = 1001 AND friend_id != 1001
GROUP BY friend_id
ORDER BY closest_degree, friend_id;

-- æŸ¥è¯¢3ï¼šè¯„è®ºæ ‘ï¼ˆé€’å½’è·å–å›å¤ï¼‰
WITH RECURSIVE comment_tree AS (
    -- æ ¹è¯„è®º
    SELECT
        comment_id,
        post_id,
        user_id,
        parent_comment_id,
        content,
        created_at,
        0 AS level,
        ARRAY[comment_id] AS path
    FROM comments
    WHERE post_id = 5001 AND parent_comment_id IS NULL

    UNION ALL

    -- å­è¯„è®º
    SELECT
        c.comment_id,
        c.post_id,
        c.user_id,
        c.parent_comment_id,
        c.content,
        c.created_at,
        ct.level + 1,
        ct.path || c.comment_id
    FROM comments c
    JOIN comment_tree ct ON c.parent_comment_id = ct.comment_id
    WHERE ct.level < 5  -- é™åˆ¶å±‚çº§
)
SELECT
    comment_id,
    user_id,
    content,
    level,
    array_to_string(path, ' > ') AS comment_path
FROM comment_tree
ORDER BY path;
```

---

## ğŸ“‹ æ¡ˆä¾‹2ï¼šç”µå•†æ•°æ®ä»“åº“æ¨¡å‹ï¼ˆæ˜Ÿå‹Schemaï¼‰

### ç»´åº¦è¡¨è®¾è®¡

```sql
-- æ—¶é—´ç»´åº¦è¡¨
CREATE TABLE dim_date (
    date_key INTEGER PRIMARY KEY,  -- 20251204
    full_date DATE NOT NULL UNIQUE,
    year INTEGER NOT NULL,
    quarter INTEGER NOT NULL CHECK (quarter BETWEEN 1 AND 4),
    month INTEGER NOT NULL CHECK (month BETWEEN 1 AND 12),
    day INTEGER NOT NULL CHECK (day BETWEEN 1 AND 31),
    day_of_week INTEGER NOT NULL CHECK (day_of_week BETWEEN 0 AND 6),
    day_name VARCHAR(10) NOT NULL,
    week_of_year INTEGER NOT NULL,
    is_weekend BOOLEAN NOT NULL,
    is_holiday BOOLEAN DEFAULT FALSE,
    holiday_name VARCHAR(50)
);

-- ç”Ÿæˆæ—¶é—´ç»´åº¦æ•°æ®
INSERT INTO dim_date
SELECT
    TO_CHAR(d, 'YYYYMMDD')::INTEGER AS date_key,
    d AS full_date,
    EXTRACT(YEAR FROM d) AS year,
    EXTRACT(QUARTER FROM d) AS quarter,
    EXTRACT(MONTH FROM d) AS month,
    EXTRACT(DAY FROM d) AS day,
    EXTRACT(DOW FROM d) AS day_of_week,
    TO_CHAR(d, 'Day') AS day_name,
    EXTRACT(WEEK FROM d) AS week_of_year,
    EXTRACT(DOW FROM d) IN (0, 6) AS is_weekend,
    FALSE AS is_holiday,
    NULL AS holiday_name
FROM generate_series(
    '2020-01-01'::date,
    '2030-12-31'::date,
    '1 day'::interval
) AS d;

-- äº§å“ç»´åº¦è¡¨ï¼ˆSCD Type 2ï¼šä¿ç•™å†å²ï¼‰
CREATE TABLE dim_product (
    product_key BIGSERIAL PRIMARY KEY,
    product_id BIGINT NOT NULL,  -- ä¸šåŠ¡é”®
    product_name VARCHAR(200) NOT NULL,
    category VARCHAR(50) NOT NULL,
    brand VARCHAR(50),
    price DECIMAL(10, 2) NOT NULL,

    -- SCD Type 2å­—æ®µ
    effective_date DATE NOT NULL DEFAULT CURRENT_DATE,
    expiry_date DATE DEFAULT '9999-12-31',
    is_current BOOLEAN DEFAULT TRUE,

    CONSTRAINT check_dates CHECK (effective_date <= expiry_date)
);

CREATE INDEX idx_dim_product_id_current ON dim_product(product_id) WHERE is_current = TRUE;

-- å®¢æˆ·ç»´åº¦è¡¨
CREATE TABLE dim_customer (
    customer_key BIGSERIAL PRIMARY KEY,
    customer_id BIGINT NOT NULL UNIQUE,
    customer_name VARCHAR(100) NOT NULL,
    email VARCHAR(100),
    city VARCHAR(50),
    country VARCHAR(50),
    customer_segment VARCHAR(20),  -- 'VIP', 'Regular', 'New'
    registration_date DATE NOT NULL
);
```

### äº‹å®è¡¨è®¾è®¡

```sql
-- é”€å”®äº‹å®è¡¨
CREATE TABLE fact_sales (
    sale_id BIGSERIAL PRIMARY KEY,

    -- ç»´åº¦å¤–é”®
    date_key INTEGER NOT NULL REFERENCES dim_date(date_key),
    product_key BIGINT NOT NULL REFERENCES dim_product(product_key),
    customer_key BIGINT NOT NULL REFERENCES dim_customer(customer_key),

    -- åº¦é‡å€¼
    quantity INTEGER NOT NULL CHECK (quantity > 0),
    unit_price DECIMAL(10, 2) NOT NULL,
    total_amount DECIMAL(10, 2) NOT NULL,
    discount_amount DECIMAL(10, 2) DEFAULT 0,
    tax_amount DECIMAL(10, 2) DEFAULT 0,
    profit_amount DECIMAL(10, 2),

    -- é€€åŒ–ç»´åº¦ï¼ˆDegenerate Dimensionï¼‰
    order_id BIGINT NOT NULL,
    transaction_id VARCHAR(50) NOT NULL,

    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- åˆ†åŒºï¼ˆæŒ‰æœˆï¼‰
CREATE TABLE fact_sales_partitioned (
    LIKE fact_sales INCLUDING ALL
) PARTITION BY RANGE (date_key);

CREATE TABLE fact_sales_2025_01 PARTITION OF fact_sales_partitioned
    FOR VALUES FROM (20250101) TO (20250201);
CREATE TABLE fact_sales_2025_02 PARTITION OF fact_sales_partitioned
    FOR VALUES FROM (20250201) TO (20250301);
-- ...ç»§ç»­åˆ›å»ºå…¶ä»–æœˆä»½åˆ†åŒº

-- ç´¢å¼•
CREATE INDEX idx_fact_sales_date ON fact_sales(date_key);
CREATE INDEX idx_fact_sales_product ON fact_sales(product_key);
CREATE INDEX idx_fact_sales_customer ON fact_sales(customer_key);
CREATE INDEX idx_fact_sales_order ON fact_sales(order_id);
```

### OLAPæŸ¥è¯¢ç¤ºä¾‹

```sql
-- å¤šç»´åˆ†ææŸ¥è¯¢

-- æŒ‰æ—¶é—´ã€äº§å“ã€åœ°åŒºçš„é”€å”®åˆ†æ
SELECT
    dd.year,
    dd.quarter,
    dd.month,
    dp.category,
    dp.brand,
    dc.country,
    dc.city,
    SUM(fs.quantity) AS total_quantity,
    SUM(fs.total_amount) AS total_revenue,
    SUM(fs.profit_amount) AS total_profit,
    COUNT(DISTINCT fs.customer_key) AS unique_customers,
    COUNT(DISTINCT fs.order_id) AS order_count
FROM fact_sales fs
JOIN dim_date dd ON fs.date_key = dd.date_key
JOIN dim_product dp ON fs.product_key = dp.product_key
JOIN dim_customer dc ON fs.customer_key = dc.customer_key
WHERE dd.year = 2025
    AND dd.quarter = 1
GROUP BY ROLLUP(
    (dd.year, dd.quarter, dd.month),
    (dp.category, dp.brand),
    (dc.country, dc.city)
)
ORDER BY
    dd.year NULLS LAST,
    dd.quarter NULLS LAST,
    dp.category NULLS LAST,
    dc.country NULLS LAST;

-- åŒæ¯”ç¯æ¯”åˆ†æ
WITH monthly_sales AS (
    SELECT
        dd.year,
        dd.month,
        SUM(fs.total_amount) AS revenue
    FROM fact_sales fs
    JOIN dim_date dd ON fs.date_key = dd.date_key
    GROUP BY dd.year, dd.month
)
SELECT
    year,
    month,
    revenue,
    -- ç¯æ¯”å¢é•¿
    (revenue - LAG(revenue) OVER (ORDER BY year, month)) /
        NULLIF(LAG(revenue) OVER (ORDER BY year, month), 0) * 100 AS mom_growth_pct,
    -- åŒæ¯”å¢é•¿
    (revenue - LAG(revenue, 12) OVER (ORDER BY year, month)) /
        NULLIF(LAG(revenue, 12) OVER (ORDER BY year, month), 0) * 100 AS yoy_growth_pct
FROM monthly_sales
ORDER BY year, month;
```

---

## ğŸ“‹ æ¡ˆä¾‹3ï¼šå¤šç§Ÿæˆ·SaaSæ•°æ®æ¨¡å‹

### è®¾è®¡æ–¹æ¡ˆå¯¹æ¯”

```text
å¤šç§Ÿæˆ·æ•°æ®éš”ç¦»ç­–ç•¥
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

æ–¹æ¡ˆ1ï¼šç‹¬ç«‹æ•°æ®åº“ï¼ˆDatabase per Tenantï¼‰
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ä¼˜ç‚¹ï¼š                                                                 â”‚
â”‚ â€¢ å®Œå…¨éš”ç¦»ï¼Œå®‰å…¨æ€§æœ€é«˜                                                 â”‚
â”‚ â€¢ å¯ç‹¬ç«‹å¤‡ä»½æ¢å¤                                                       â”‚
â”‚ â€¢ æ€§èƒ½äº’ä¸å½±å“                                                         â”‚
â”‚                                                                        â”‚
â”‚ ç¼ºç‚¹ï¼š                                                                 â”‚
â”‚ â€¢ ç®¡ç†å¤æ‚ï¼ˆ1000ä¸ªç§Ÿæˆ·=1000ä¸ªæ•°æ®åº“ï¼‰                                  â”‚
â”‚ â€¢ èµ„æºå¼€é”€å¤§                                                           â”‚
â”‚ â€¢ Schemaå˜æ›´å›°éš¾                                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æ–¹æ¡ˆ2ï¼šå…±äº«æ•°æ®åº“+ç‹¬ç«‹Schemaï¼ˆSchema per Tenantï¼‰
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ä¼˜ç‚¹ï¼š                                                                 â”‚
â”‚ â€¢ è¾ƒå¥½çš„éš”ç¦»æ€§                                                         â”‚
â”‚ â€¢ ç®¡ç†ç›¸å¯¹ç®€å•                                                         â”‚
â”‚                                                                        â”‚
â”‚ ç¼ºç‚¹ï¼š                                                                 â”‚
â”‚ â€¢ PostgreSQLè¿æ¥éœ€è¦SET search_path                                    â”‚
â”‚ â€¢ ä»éœ€ç®¡ç†å¤šä¸ªschema                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æ–¹æ¡ˆ3ï¼šå…±äº«è¡¨+tenant_idåˆ—ï¼ˆShared Tablesï¼Œæ¨èï¼‰
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ä¼˜ç‚¹ï¼š                                                                 â”‚
â”‚ â€¢ ç®¡ç†æœ€ç®€å•                                                           â”‚
â”‚ â€¢ Schemaå˜æ›´ç»Ÿä¸€                                                       â”‚
â”‚ â€¢ è·¨ç§Ÿæˆ·æŸ¥è¯¢æ–¹ä¾¿                                                       â”‚
â”‚                                                                        â”‚
â”‚ ç¼ºç‚¹ï¼š                                                                 â”‚
â”‚ â€¢ éœ€è¦ä¸¥æ ¼çš„Row-Level Security                                         â”‚
â”‚ â€¢ æŸ¥è¯¢å¿…é¡»åŒ…å«tenant_idè¿‡æ»¤                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ–¹æ¡ˆ3å®ç°ï¼ˆæ¨èï¼‰

```sql
-- å…±äº«è¡¨+RLSï¼ˆRow-Level Securityï¼‰

-- ç§Ÿæˆ·è¡¨
CREATE TABLE tenants (
    tenant_id BIGSERIAL PRIMARY KEY,
    tenant_name VARCHAR(100) NOT NULL UNIQUE,
    plan VARCHAR(20) NOT NULL CHECK (plan IN ('free', 'pro', 'enterprise')),
    max_users INTEGER NOT NULL,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    is_active BOOLEAN DEFAULT TRUE
);

-- ç”¨æˆ·è¡¨ï¼ˆå¤šç§Ÿæˆ·ï¼‰
CREATE TABLE users (
    user_id BIGSERIAL PRIMARY KEY,
    tenant_id BIGINT NOT NULL REFERENCES tenants(tenant_id),
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,

    UNIQUE(tenant_id, username),
    UNIQUE(tenant_id, email)
);

-- å¯ç”¨RLS
ALTER TABLE users ENABLE ROW LEVEL SECURITY;

-- RLSç­–ç•¥ï¼šåªèƒ½çœ‹åˆ°è‡ªå·±ç§Ÿæˆ·çš„æ•°æ®
CREATE POLICY tenant_isolation_policy ON users
    USING (tenant_id = current_setting('app.current_tenant_id')::BIGINT);

-- å…è®¸ç§Ÿæˆ·ç®¡ç†å‘˜æŸ¥çœ‹
CREATE POLICY tenant_admin_policy ON users
    USING (
        tenant_id = current_setting('app.current_tenant_id')::BIGINT
        AND current_setting('app.user_role') = 'admin'
    );

-- æ–‡æ¡£è¡¨
CREATE TABLE documents (
    document_id BIGSERIAL PRIMARY KEY,
    tenant_id BIGINT NOT NULL REFERENCES tenants(tenant_id),
    user_id BIGINT NOT NULL REFERENCES users(user_id),
    title VARCHAR(200) NOT NULL,
    content TEXT,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,

    -- åˆ†åŒºé”®åŒ…å«tenant_id
    CONSTRAINT fk_check_tenant CHECK (
        (SELECT tenant_id FROM users WHERE user_id = documents.user_id) = documents.tenant_id
    )
);

ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

CREATE POLICY tenant_documents_policy ON documents
    USING (tenant_id = current_setting('app.current_tenant_id')::BIGINT);

-- åˆ†åŒºç­–ç•¥ï¼šæŒ‰tenant_idåˆ†åŒºï¼ˆå¤§ç§Ÿæˆ·ç‹¬ç«‹åˆ†åŒºï¼‰
CREATE TABLE documents_partitioned (
    LIKE documents INCLUDING ALL
) PARTITION BY LIST (tenant_id);

CREATE TABLE documents_tenant_1 PARTITION OF documents_partitioned
    FOR VALUES IN (1);
CREATE TABLE documents_tenant_2 PARTITION OF documents_partitioned
    FOR VALUES IN (2);
CREATE TABLE documents_other PARTITION OF documents_partitioned
    DEFAULT;  -- å°ç§Ÿæˆ·å…±äº«åˆ†åŒº
```

### åº”ç”¨å±‚ä½¿ç”¨

```python
import psycopg2

class MultiTenantDB:
    def __init__(self):
        self.pool = create_connection_pool()

    def execute_for_tenant(self, tenant_id, sql, params=None):
        """åœ¨ç§Ÿæˆ·ä¸Šä¸‹æ–‡ä¸­æ‰§è¡ŒSQL"""
        conn = self.pool.getconn()
        try:
            # è®¾ç½®ç§Ÿæˆ·ä¸Šä¸‹æ–‡
            conn.execute(f"SET app.current_tenant_id = {tenant_id}")
            conn.execute("SET app.user_role = 'user'")

            # æ‰§è¡ŒæŸ¥è¯¢ï¼ˆRLSè‡ªåŠ¨è¿‡æ»¤ï¼‰
            cursor = conn.execute(sql, params)
            return cursor.fetchall()
        finally:
            # é‡ç½®ä¸Šä¸‹æ–‡
            conn.execute("RESET app.current_tenant_id")
            conn.execute("RESET app.user_role")
            self.pool.putconn(conn)

# ä½¿ç”¨
db = MultiTenantDB()

# æŸ¥è¯¢ç§Ÿæˆ·1çš„ç”¨æˆ·ï¼ˆåªèƒ½çœ‹åˆ°ç§Ÿæˆ·1çš„æ•°æ®ï¼‰
users = db.execute_for_tenant(1, "SELECT * FROM users")

# æŸ¥è¯¢ç§Ÿæˆ·2çš„ç”¨æˆ·ï¼ˆåªèƒ½çœ‹åˆ°ç§Ÿæˆ·2çš„æ•°æ®ï¼‰
users = db.execute_for_tenant(2, "SELECT * FROM users")
```

---

## ğŸ“‹ æ¡ˆä¾‹4ï¼šå®¡è®¡æ—¥å¿—æ¨¡å‹

```sql
-- å®¡è®¡æ—¥å¿—è¡¨è®¾è®¡

CREATE TABLE audit_logs (
    log_id BIGSERIAL PRIMARY KEY,
    table_name VARCHAR(50) NOT NULL,
    record_id BIGINT NOT NULL,
    operation VARCHAR(10) NOT NULL CHECK (operation IN ('INSERT', 'UPDATE', 'DELETE')),
    old_values JSONB,  -- æ—§å€¼
    new_values JSONB,  -- æ–°å€¼
    changed_fields TEXT[],  -- å˜æ›´å­—æ®µåˆ—è¡¨
    user_id BIGINT,
    user_ip INET,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,

    -- åˆ†åŒºé”®
    CONSTRAINT audit_logs_partition_key PRIMARY KEY (log_id, created_at)
) PARTITION BY RANGE (created_at);

-- æŒ‰æœˆåˆ†åŒº
CREATE TABLE audit_logs_2025_01 PARTITION OF audit_logs
    FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');

-- é€šç”¨å®¡è®¡è§¦å‘å™¨
CREATE OR REPLACE FUNCTION audit_trigger_func()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        INSERT INTO audit_logs (table_name, record_id, operation, new_values, user_id)
        VALUES (TG_TABLE_NAME, NEW.id, 'INSERT', row_to_json(NEW), current_setting('app.user_id')::BIGINT);
    ELSIF TG_OP = 'UPDATE' THEN
        INSERT INTO audit_logs (table_name, record_id, operation, old_values, new_values, changed_fields, user_id)
        VALUES (
            TG_TABLE_NAME,
            NEW.id,
            'UPDATE',
            row_to_json(OLD),
            row_to_json(NEW),
            (SELECT array_agg(key) FROM jsonb_each(row_to_json(NEW)::jsonb) WHERE row_to_json(NEW)::jsonb->>key != row_to_json(OLD)::jsonb->>key),
            current_setting('app.user_id')::BIGINT
        );
    ELSIF TG_OP = 'DELETE' THEN
        INSERT INTO audit_logs (table_name, record_id, operation, old_values, user_id)
        VALUES (TG_TABLE_NAME, OLD.id, 'DELETE', row_to_json(OLD), current_setting('app.user_id')::BIGINT);
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- åº”ç”¨åˆ°è¡¨
CREATE TRIGGER users_audit_trigger
AFTER INSERT OR UPDATE OR DELETE ON users
FOR EACH ROW EXECUTE FUNCTION audit_trigger_func();

CREATE TRIGGER orders_audit_trigger
AFTER INSERT OR UPDATE OR DELETE ON orders
FOR EACH ROW EXECUTE FUNCTION audit_trigger_func();

-- å®¡è®¡æŸ¥è¯¢
SELECT
    log_id,
    table_name,
    record_id,
    operation,
    changed_fields,
    created_at
FROM audit_logs
WHERE table_name = 'users'
    AND record_id = 1001
    AND created_at >= CURRENT_DATE - INTERVAL '30 days'
ORDER BY created_at DESC;
```

---

## ğŸ“‹ æ¡ˆä¾‹5ï¼šæ—¶é—´åºåˆ—æ•°æ®æ¨¡å‹

```sql
-- IoTä¼ æ„Ÿå™¨æ—¶åºæ•°æ®ï¼ˆTimescaleDBæ‰©å±•ï¼‰

-- åˆ›å»ºhypertable
CREATE TABLE sensor_readings (
    time TIMESTAMPTZ NOT NULL,
    sensor_id INTEGER NOT NULL,
    temperature DOUBLE PRECISION,
    humidity DOUBLE PRECISION,
    pressure DOUBLE PRECISION,
    location POINT,  -- åœ°ç†åæ ‡
    PRIMARY KEY (sensor_id, time)
);

-- è½¬æ¢ä¸ºæ—¶åºè¡¨ï¼ˆTimescaleDBï¼‰
SELECT create_hypertable('sensor_readings', 'time',
    chunk_time_interval => INTERVAL '1 day',
    partitioning_column => 'sensor_id',
    number_partitions => 4
);

-- è‡ªåŠ¨èšåˆï¼ˆContinuous Aggregateï¼‰
CREATE MATERIALIZED VIEW sensor_readings_hourly
WITH (timescaledb.continuous) AS
SELECT
    time_bucket('1 hour', time) AS bucket,
    sensor_id,
    AVG(temperature) AS avg_temp,
    MIN(temperature) AS min_temp,
    MAX(temperature) AS max_temp,
    AVG(humidity) AS avg_humidity,
    COUNT(*) AS reading_count
FROM sensor_readings
GROUP BY bucket, sensor_id;

-- è‡ªåŠ¨åˆ·æ–°ç­–ç•¥
SELECT add_continuous_aggregate_policy('sensor_readings_hourly',
    start_offset => INTERVAL '3 hours',
    end_offset => INTERVAL '1 hour',
    schedule_interval => INTERVAL '1 hour');

-- å‹ç¼©ç­–ç•¥ï¼ˆèŠ‚çœç©ºé—´ï¼‰
SELECT add_compression_policy('sensor_readings', INTERVAL '7 days');

-- æŸ¥è¯¢ä¼˜åŒ–ï¼šæ—¶é—´èŒƒå›´+ä¼ æ„Ÿå™¨
SELECT
    time,
    temperature,
    humidity
FROM sensor_readings
WHERE sensor_id = 1001
    AND time >= NOW() - INTERVAL '24 hours'
ORDER BY time DESC;

-- èšåˆæŸ¥è¯¢ï¼ˆä½¿ç”¨ç‰©åŒ–è§†å›¾ï¼‰
SELECT
    bucket,
    sensor_id,
    avg_temp,
    max_temp - min_temp AS temp_range
FROM sensor_readings_hourly
WHERE bucket >= NOW() - INTERVAL '7 days'
    AND sensor_id IN (1001, 1002, 1003)
ORDER BY bucket DESC;
```

---

**æ•°æ®å»ºæ¨¡æ¡ˆä¾‹åº“å®Œæˆï¼**

æœ¬æ–‡æ¡£æä¾›5ä¸ªå®Œæ•´æ•°æ®æ¨¡å‹ï¼š

- âœ… ç¤¾äº¤ç½‘ç»œï¼ˆå¥½å‹å…³ç³»/åŠ¨æ€/è¯„è®ºæ ‘ï¼‰
- âœ… ç”µå•†æ•°æ®ä»“åº“ï¼ˆæ˜Ÿå‹Schema/SCD Type 2/åˆ†åŒºï¼‰
- âœ… å¤šç§Ÿæˆ·SaaSï¼ˆRLSå®‰å…¨ç­–ç•¥/3ç§æ–¹æ¡ˆå¯¹æ¯”ï¼‰
- âœ… å®¡è®¡æ—¥å¿—ï¼ˆé€šç”¨è§¦å‘å™¨/JSONBå­˜å‚¨ï¼‰
- âœ… æ—¶é—´åºåˆ—ï¼ˆTimescaleDB/è‡ªåŠ¨èšåˆ/å‹ç¼©ï¼‰

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0
**æœ€åæ›´æ–°**: 2025-12-04
