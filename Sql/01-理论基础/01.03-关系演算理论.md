# 关系演算理论

> **创建日期**：2025-01-15
> **最后更新**：2025-01-15
> **版本**：v1.0.0
> **难度**：⭐⭐⭐⭐⭐
> **应用场景**：数据库理论基础、查询语义理解、形式化验证

---

## 📋 目录

- [关系演算理论](#关系演算理论)
  - [📋 目录](#-目录)
  - [一、概述](#一概述)
    - [1.1 关系演算定义](#11-关系演算定义)
    - [1.2 关系演算类型](#12-关系演算类型)
    - [1.3 关系演算与关系代数](#13-关系演算与关系代数)
    - [1.4 关系演算知识体系思维导图](#14-关系演算知识体系思维导图)
    - [1.5 关系演算与关系代数对比矩阵](#15-关系演算与关系代数对比矩阵)
  - [二、元组关系演算](#二元组关系演算)
    - [2.1 元组关系演算定义](#21-元组关系演算定义)
    - [2.2 元组关系演算语法](#22-元组关系演算语法)
    - [2.3 元组关系演算示例](#23-元组关系演算示例)
    - [2.4 元组关系演算形式化语义](#24-元组关系演算形式化语义)
  - [三、域关系演算](#三域关系演算)
    - [3.1 域关系演算定义](#31-域关系演算定义)
    - [3.2 域关系演算语法](#32-域关系演算语法)
    - [3.3 域关系演算示例](#33-域关系演算示例)
    - [3.4 域关系演算形式化语义](#34-域关系演算形式化语义)
  - [四、安全表达式](#四安全表达式)
    - [4.1 安全表达式定义](#41-安全表达式定义)
    - [4.2 安全表达式判定](#42-安全表达式判定)
    - [4.3 安全表达式转换](#43-安全表达式转换)
  - [五、关系演算与关系代数等价性](#五关系演算与关系代数等价性)
    - [5.1 等价性定义](#51-等价性定义)
    - [5.2 等价性证明](#52-等价性证明)
      - [5.2.1 等价性定理](#521-等价性定理)
      - [5.2.2 关系代数到关系演算的转换证明](#522-关系代数到关系演算的转换证明)
      - [5.2.3 关系演算到关系代数的转换证明](#523-关系演算到关系代数的转换证明)
      - [5.2.4 等价性证明的历史背景](#524-等价性证明的历史背景)
    - [5.3 转换算法](#53-转换算法)
  - [六、关系演算与SQL对应](#六关系演算与sql对应)
    - [6.1 元组关系演算到SQL](#61-元组关系演算到sql)
    - [6.2 域关系演算到SQL](#62-域关系演算到sql)
  - [七、相关资源](#七相关资源)
    - [相关文档](#相关文档)
    - [外部资源](#外部资源)

---

## 一、概述

### 1.1 关系演算定义

**关系演算（Relational Calculus）**是基于谓词逻辑的查询语言，用于描述查询条件。

**形式化定义**：

```latex
关系演算 = (元组关系演算, 域关系演算, 安全表达式)

元组关系演算 = {查询 | 查询使用元组变量}
域关系演算 = {查询 | 查询使用域变量}
安全表达式 = {表达式 | 表达式的结果是有限的}
```

### 1.2 关系演算类型

**两种类型的关系演算**：

1. **元组关系演算（Tuple Relational Calculus, TRC）**
   - 使用元组变量
   - 基于一阶谓词逻辑
   - 更接近SQL的语义

2. **域关系演算（Domain Relational Calculus, DRC）**
   - 使用域变量
   - 基于一阶谓词逻辑
   - QBE（Query By Example）的基础

### 1.3 关系演算与关系代数

**关系演算与关系代数的关系**：

```latex
\begin{theorem}[关系演算与关系代数等价性]
关系演算和关系代数在表达能力上等价，即：
\forall 关系代数查询 q₁, \exists 关系演算查询 q₂: Result(q₁) = Result(q₂)
\forall 关系演算查询 q₂, \exists 关系代数查询 q₁: Result(q₂) = Result(q₁)
\end{theorem}
```

### 1.4 关系演算知识体系思维导图

```mermaid
mindmap
  root((关系演算))
    元组关系演算
      元组变量
        变量定义
        变量范围
      谓词逻辑
        原子公式
        复合公式
        量词
      查询表达式
        {t | P(t)}
        存在量词
        全称量词
    域关系演算
      域变量
        变量定义
        变量范围
      谓词逻辑
        原子公式
        复合公式
      查询表达式
        {<x1,x2,...> | P(x1,x2,...)}
    安全表达式
      安全定义
        有限结果
        可计算性
      安全判定
        范围限制
        存在性检查
      安全转换
        转换为安全表达式
    等价性
      与关系代数等价
        表达能力等价
        转换算法
      与SQL对应
        元组演算到SQL
        域演算到SQL
    应用场景
      查询语义
        SQL语义定义
        查询理解
      形式化验证
        正确性验证
        等价性证明
```

### 1.5 关系演算与关系代数对比矩阵

| 特性 | 关系代数 | 元组关系演算 | 域关系演算 | SQL |
|------|---------|-------------|-----------|-----|
| **表达方式** | 过程式 | 声明式 | 声明式 | 声明式 |
| **变量类型** | 关系 | 元组 | 域值 | 表/行 |
| **操作符** | 集合运算 | 逻辑运算 | 逻辑运算 | 混合 |
| **表达能力** | 完备 | 完备 | 完备 | 完备 |
| **可读性** | 中 | 高 | 高 | 高 |
| **实现难度** | 中 | 高 | 高 | 中 |

---

## 二、元组关系演算

### 2.1 元组关系演算定义

**元组关系演算（Tuple Relational Calculus, TRC）**使用元组变量来描述查询。

**形式化定义**：

```latex
元组关系演算查询形式：

{t | P(t)}

其中：
- t 是元组变量
- P(t) 是谓词（布尔表达式）
- 结果：所有满足 P(t) 的元组 t
```

**语法元素**：

```latex
元组关系演算语法：

1. 原子公式：
   - R(t)：元组 t 属于关系 R
   - t[A] θ s[B]：元组 t 的属性 A 与元组 s 的属性 B 满足关系 θ
   - t[A] θ c：元组 t 的属性 A 与常量 c 满足关系 θ

2. 逻辑连接符：
   - ∧（AND）：合取
   - ∨（OR）：析取
   - ¬（NOT）：否定
   - ⟹（IMPLIES）：蕴含

3. 量词：
   - ∃（存在量词）：存在
   - ∀（全称量词）：对所有
```

### 2.2 元组关系演算语法

**完整语法定义**：

```latex
元组关系演算BNF语法：

<query> ::= { <tuple_var> | <predicate> }

<tuple_var> ::= <identifier>

<predicate> ::= <atomic_formula>
              | <predicate> ∧ <predicate>
              | <predicate> ∨ <predicate>
              | ¬ <predicate>
              | ∃ <tuple_var> <predicate>
              | ∀ <tuple_var> <predicate>

<atomic_formula> ::= <relation>(<tuple_var>)
                   | <tuple_var>.<attribute> θ <tuple_var>.<attribute>
                   | <tuple_var>.<attribute> θ <constant>
```

### 2.3 元组关系演算示例

**示例1：简单选择查询**：

```text
关系：Student(学号, 姓名, 年龄, 专业)

查询：找出年龄大于20的学生

元组关系演算：
{t | Student(t) ∧ t.年龄 > 20}

SQL对应：
SELECT * FROM Student WHERE 年龄 > 20;
```

**示例2：投影查询**：

```text
查询：找出所有学生的学号和姓名

元组关系演算：
{t | ∃s (Student(s) ∧ t.学号 = s.学号 ∧ t.姓名 = s.姓名)}

SQL对应：
SELECT 学号, 姓名 FROM Student;
```

**示例3：连接查询**：

```text
关系：Student(学号, 姓名, 专业)
关系：Course(课程号, 课程名, 学分)
关系：Enrollment(学号, 课程号, 成绩)

查询：找出选修了"数据库"课程的学生姓名

元组关系演算：
{t | ∃s ∃e ∃c (
    Student(s) ∧ Enrollment(e) ∧ Course(c)
    ∧ s.学号 = e.学号
    ∧ e.课程号 = c.课程号
    ∧ c.课程名 = '数据库'
    ∧ t.姓名 = s.姓名
)}

SQL对应：
SELECT DISTINCT s.姓名
FROM Student s
JOIN Enrollment e ON s.学号 = e.学号
JOIN Course c ON e.课程号 = c.课程号
WHERE c.课程名 = '数据库';
```

**示例4：存在量词查询**：

```text
查询：找出至少选修了一门课程的学生

元组关系演算：
{t | Student(t) ∧ ∃e (Enrollment(e) ∧ e.学号 = t.学号)}

SQL对应：
SELECT DISTINCT s.*
FROM Student s
WHERE EXISTS (
    SELECT 1 FROM Enrollment e
    WHERE e.学号 = s.学号
);
```

**示例5：全称量词查询**：

```text
查询：找出选修了所有课程的学生

元组关系演算：
{t | Student(t) ∧ ∀c (
    Course(c) ⟹ ∃e (
        Enrollment(e) ∧ e.学号 = t.学号 ∧ e.课程号 = c.课程号
    )
)}

SQL对应：
SELECT s.*
FROM Student s
WHERE NOT EXISTS (
    SELECT c.课程号
    FROM Course c
    WHERE NOT EXISTS (
        SELECT 1 FROM Enrollment e
        WHERE e.学号 = s.学号 AND e.课程号 = c.课程号
    )
);
```

### 2.4 元组关系演算形式化语义

**形式化语义定义**：

```latex
元组关系演算语义：

语义函数：⟦·⟧: Query → Relation

⟦{t | P(t)}⟧ = {t | ⟦P(t)⟧ = True}

其中：
⟦R(t)⟧ = True  ⟺  t ∈ R
⟦t[A] θ s[B]⟧ = True  ⟺  t[A] θ s[B]
⟦t[A] θ c⟧ = True  ⟺  t[A] θ c
⟦P₁ ∧ P₂⟧ = True  ⟺  ⟦P₁⟧ = True ∧ ⟦P₂⟧ = True
⟦P₁ ∨ P₂⟧ = True  ⟺  ⟦P₁⟧ = True ∨ ⟦P₂⟧ = True
⟦¬P⟧ = True  ⟺  ⟦P⟧ = False
⟦∃x P(x)⟧ = True  ⟺  ∃t: ⟦P(t)⟧ = True
⟦∀x P(x)⟧ = True  ⟺  ∀t: ⟦P(t)⟧ = True
```

---

## 三、域关系演算

### 3.1 域关系演算定义

**域关系演算（Domain Relational Calculus, DRC）**使用域变量来描述查询。

**形式化定义**：

```latex
域关系演算查询形式：

{<x₁, x₂, ..., xₙ> | P(x₁, x₂, ..., xₙ)}

其中：
- x₁, x₂, ..., xₙ 是域变量
- P(x₁, x₂, ..., xₙ) 是谓词
- 结果：所有满足 P 的 n 元组
```

### 3.2 域关系演算语法

**语法定义**：

```latex
域关系演算BNF语法：

<query> ::= { <domain_var_list> | <predicate> }

<domain_var_list> ::= <domain_var> {, <domain_var>}

<domain_var> ::= <identifier>

<predicate> ::= <atomic_formula>
              | <predicate> ∧ <predicate>
              | <predicate> ∨ <predicate>
              | ¬ <predicate>
              | ∃ <domain_var> <predicate>
              | ∀ <domain_var> <predicate>

<atomic_formula> ::= <relation>(<domain_var_list>)
                   | <domain_var> θ <domain_var>
                   | <domain_var> θ <constant>
```

### 3.3 域关系演算示例

**示例1：简单选择查询**：

```text
关系：Student(学号, 姓名, 年龄, 专业)

查询：找出年龄大于20的学生

域关系演算：
{<sno, name, age, major> | Student(sno, name, age, major) ∧ age > 20}

SQL对应：
SELECT * FROM Student WHERE 年龄 > 20;
```

**示例2：投影查询**：

```text
查询：找出所有学生的学号和姓名

域关系演算：
{<sno, name> | ∃age ∃major Student(sno, name, age, major)}

SQL对应：
SELECT 学号, 姓名 FROM Student;
```

**示例3：连接查询**：

```text
关系：Student(学号, 姓名, 专业)
关系：Course(课程号, 课程名, 学分)
关系：Enrollment(学号, 课程号, 成绩)

查询：找出选修了"数据库"课程的学生姓名

域关系演算：
{<name> | ∃sno ∃cno ∃grade ∃cname ∃credit (
    Student(sno, name, _)
    ∧ Enrollment(sno, cno, grade)
    ∧ Course(cno, cname, credit)
    ∧ cname = '数据库'
)}

SQL对应：
SELECT DISTINCT s.姓名
FROM Student s
JOIN Enrollment e ON s.学号 = e.学号
JOIN Course c ON e.课程号 = c.课程号
WHERE c.课程名 = '数据库';
```

### 3.4 域关系演算形式化语义

**形式化语义定义**：

```latex
域关系演算语义：

语义函数：⟦·⟧: Query → Relation

⟦{<x₁, ..., xₙ> | P(x₁, ..., xₙ)}⟧ = {
    <v₁, ..., vₙ> | ⟦P(v₁, ..., vₙ)⟧ = True
}

其中：
⟦R(v₁, ..., vₙ)⟧ = True  ⟺  <v₁, ..., vₙ> ∈ R
⟦v₁ θ v₂⟧ = True  ⟺  v₁ θ v₂
⟦v θ c⟧ = True  ⟺  v θ c
```

---

## 四、安全表达式

### 4.1 安全表达式定义

**安全表达式（Safe Expression）**是结果有限的关系演算表达式。

**形式化定义**：

```latex
安全表达式定义：

表达式 {t | P(t)} 是安全的，当且仅当：
1. 如果 t 满足 P(t)，则 t 的每个属性值都出现在某个关系的某个元组中
2. 对于 P 中的每个形如 ∃u (Q(u)) 的子表达式，如果 u 满足 Q(u)，则 u 的每个属性值都出现在某个关系的某个元组中
3. 对于 P 中的每个形如 ∀u (Q(u)) 的子表达式，Q(u) 的限制是安全的
```

### 4.2 安全表达式判定

**安全表达式判定规则**：

```latex
\begin{theorem}[安全表达式判定]
表达式 {t | P(t)} 是安全的，当且仅当：
1. P 中的所有自由变量都出现在某个原子公式 R(t) 中
2. 对于 P 中的每个存在量词 ∃u (Q(u))，Q(u) 中的自由变量都出现在某个原子公式中
3. 对于 P 中的每个全称量词 ∀u (Q(u))，Q(u) 的限制是安全的
\end{theorem}
```

### 4.3 安全表达式转换

**不安全表达式转换为安全表达式**：

```latex
转换规则：

1. 限制范围：为量词变量添加范围限制
2. 添加约束：确保结果有限

示例：
不安全：{t | t.年龄 > 20}
安全：{t | Student(t) ∧ t.年龄 > 20}
```

---

## 五、关系演算与关系代数等价性

### 5.1 等价性定义

**等价性定义**：

```latex
关系演算查询 q₁ 和关系代数查询 q₂ 等价，当且仅当：
\forall 数据库实例 DB: Result(q₁, DB) = Result(q₂, DB)
```

### 5.2 等价性证明

#### 5.2.1 等价性定理

**关系演算与关系代数等价性定理**：

```latex
\begin{theorem}[关系演算与关系代数等价性]
关系演算和关系代数在表达能力上等价，即：
\forall 关系演算查询 q₁, \exists 关系代数表达式 e: Result(q₁) = Result(e)
\forall 关系代数表达式 e, \exists 关系演算查询 q₁: Result(e) = Result(q₁)
\end{theorem}
```

#### 5.2.2 关系代数到关系演算的转换证明

**关系代数到关系演算的转换**：

```latex
\begin{proof}[关系代数到关系演算]
证明每个关系代数操作都可以用关系演算表达：

步骤1：选择操作
关系代数：σ_{条件}(R)
关系演算：{t | R(t) ∧ 条件(t)}
等价性：σ_{条件}(R) = {t | R(t) ∧ 条件(t)}

步骤2：投影操作
关系代数：π_{A}(R)
关系演算：{t | ∃s (R(s) ∧ t.A = s.A)}
等价性：π_{A}(R) = {t | ∃s (R(s) ∧ t.A = s.A)}

步骤3：并操作
关系代数：R₁ ∪ R₂
关系演算：{t | R₁(t) ∨ R₂(t)}
等价性：R₁ ∪ R₂ = {t | R₁(t) ∨ R₂(t)}

步骤4：差操作
关系代数：R₁ - R₂
关系演算：{t | R₁(t) ∧ ¬R₂(t)}
等价性：R₁ - R₂ = {t | R₁(t) ∧ ¬R₂(t)}

步骤5：笛卡尔积操作
关系代数：R₁ × R₂
关系演算：{t | ∃s₁ ∃s₂ (R₁(s₁) ∧ R₂(s₂) ∧ t = (s₁, s₂))}
等价性：R₁ × R₂ = {t | ∃s₁ ∃s₂ (R₁(s₁) ∧ R₂(s₂) ∧ t = (s₁, s₂))}

因此，每个关系代数操作都可以用关系演算表达。
\end{proof}
```

#### 5.2.3 关系演算到关系代数的转换证明

**关系演算到关系代数的转换**：

```latex
\begin{proof}[关系演算到关系代数]
证明每个关系演算查询都可以用关系代数表达：

步骤1：原子公式
关系演算：R(t)
关系代数：R
等价性：R(t) 对应关系 R

步骤2：合取
关系演算：P₁(t) ∧ P₂(t)
关系代数：σ_{P₁}(σ_{P₂}(R)) 或 σ_{P₁ ∧ P₂}(R)
等价性：P₁(t) ∧ P₂(t) 对应选择操作

步骤3：析取
关系演算：P₁(t) ∨ P₂(t)
关系代数：(σ_{P₁}(R)) ∪ (σ_{P₂}(R))
等价性：P₁(t) ∨ P₂(t) 对应并操作

步骤4：否定
关系演算：¬P(t)
关系代数：R - σ_{P}(R)
等价性：¬P(t) 对应差操作

步骤5：存在量词
关系演算：∃s (R(s) ∧ P(s, t))
关系代数：π_{t的属性}(σ_{P}(R))
等价性：存在量词对应投影和选择操作

因此，每个关系演算查询都可以用关系代数表达。
\end{proof}
```

#### 5.2.4 等价性证明的历史背景

**历史背景**：

- **1970年**：Codd在原始论文中提出了关系演算和关系代数的等价性
- **1972年**：Codd证明了关系演算和关系代数的等价性
- **1980年代**：等价性证明被系统化和完善
- **至今**：等价性证明是数据库理论基础的重要组成部分

**等价性的重要性**：

1. **理论基础**：为数据库查询语言提供了理论基础
2. **查询优化**：为查询优化提供了理论基础
3. **语言设计**：为查询语言设计提供了指导原则

### 5.3 转换算法

**关系演算到关系代数转换算法**：

```latex
转换算法：

1. 原子公式 R(t) → R
2. 条件 t[A] θ c → σ_{A θ c}
3. 合取 P₁ ∧ P₂ → 先应用 P₁，再应用 P₂
4. 析取 P₁ ∨ P₂ → (P₁) ∪ (P₂)
5. 否定 ¬P → 全集 - (P)
6. 存在量词 ∃x P(x) → π_{自由变量}(P(x))
```

---

## 六、关系演算与SQL对应

### 6.1 元组关系演算到SQL

**转换规则**：

| 元组关系演算 | SQL对应 | 示例 |
|------------|---------|------|
| {t \| R(t)} | SELECT * FROM R | - |
| {t \| R(t) ∧ P(t)} | SELECT * FROM R WHERE P | - |
| {t \| ∃s (R(s) ∧ t.A = s.A)} | SELECT A FROM R | - |
| {t \| R₁(t) ∨ R₂(t)} | SELECT *FROM R1 UNION SELECT* FROM R2 | - |
| {t \| R₁(t) ∧ ¬R₂(t)} | SELECT *FROM R1 EXCEPT SELECT* FROM R2 | - |
| {t \| R₁(t) ∧ ∃s (R₂(s) ∧ ...)} | SELECT ... FROM R1 WHERE EXISTS (SELECT ... FROM R2 ...) | - |

### 6.2 域关系演算到SQL

**转换规则**：

| 域关系演算 | SQL对应 | 示例 |
|----------|---------|------|
| {<x₁, x₂> \| R(x₁, x₂, ...)} | SELECT x₁, x₂ FROM R | - |
| {<x> \| R(x, ...) ∧ x > 20} | SELECT x FROM R WHERE x > 20 | - |

---

## 七、相关资源

### 相关文档

- [关系模型理论](./01.01-关系模型理论.md) - 关系模型基础
- [关系代数理论](./01.02-关系代数理论.md) - 关系代数
- [SQL完备性理论](./01.04-SQL完备性理论.md) - SQL完备性

### 外部资源

- Codd, E. F. (1972). "Relational Completeness of Data Base Sublanguages"
- Date, C. J. (2003). "An Introduction to Database Systems"

---

**维护者**: SQL Standards Team
**最后更新**: 2025-01-15
