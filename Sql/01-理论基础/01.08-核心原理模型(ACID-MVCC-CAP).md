# 核心原理模型：ACID / MVCC / CAP

> **创建日期**：2025-12-01
> **难度**：⭐⭐⭐⭐⭐
> **前置知识**：事务理论、并发控制
> **关联标准**：SQL:1992 事务定义, SQL:2011 隔离级别

---

## 📋 目录

- [核心原理模型：ACID / MVCC / CAP](#核心原理模型acid--mvcc--cap)
  - [📋 目录](#-目录)
  - [一、概述](#一概述)
    - [1.1 与SQL标准的关系](#11-与sql标准的关系)
  - [二、ACID原理](#二acid原理)
    - [2.1 形式化定义](#21-形式化定义)
    - [2.2 ACID因果链](#22-acid因果链)
  - [三、MVCC原理](#三mvcc原理)
    - [3.1 形式化定义](#31-形式化定义)
    - [3.2 MVCC与隔离级别的关系](#32-mvcc与隔离级别的关系)
    - [3.3 MVCC版本管理](#33-mvcc版本管理)
  - [四、CAP定理](#四cap定理)
    - [4.1 形式化定义](#41-形式化定义)
    - [4.2 CAP权衡选择](#42-cap权衡选择)
  - [五、PACELC扩展](#五pacelc扩展)
    - [5.1 PACELC定理](#51-pacelc定理)
  - [六、原理间的关系](#六原理间的关系)
    - [6.1 ACID-MVCC-CAP关系图](#61-acid-mvcc-cap关系图)
    - [6.2 决策矩阵](#62-决策矩阵)
  - [七、PostgreSQL 18实现](#七postgresql-18实现)
    - [7.1 ACID实现](#71-acid实现)
    - [7.2 MVCC实现](#72-mvcc实现)
  - [八、SQLite 3.45+实现](#八sqlite-345实现)
  - [相关资源](#相关资源)
    - [相关文档](#相关文档)
    - [外部资源](#外部资源)

---

## 一、概述

**ACID、MVCC、CAP** 是数据库系统的三大核心原理模型，它们分别从不同角度定义了数据库的正确性保证。

```text
数据库核心原理模型关系图
══════════════════════════════════════════════════════════════════════════════

                              数据库系统目标
                           ┌────────┴────────┐
                           │                 │
                    正确性保证            性能/可用性
                           │                 │
            ┌──────────────┼──────────────┐  │
            │              │              │  │
            ▼              ▼              ▼  ▼
         ┌──────┐     ┌──────┐      ┌──────────┐
         │ ACID │     │ MVCC │      │ CAP/     │
         │事务正确│     │并发控制│     │ PACELC  │
         └───┬──┘     └───┬──┘      └────┬─────┘
             │            │              │
     ┌───────┴───────┐    │      ┌───────┴───────┐
     │   │   │   │   │    │      │       │       │
     ▼   ▼   ▼   ▼   ▼    ▼      ▼       ▼       ▼
    原  一  隔  持  快  SI     一致性  可用性  分区
    子  致  离  久  照  SSI           容错
    性  性  性  性  隔离

──────────────────────────────────────────────────────────────────────────────
标准关联：
- ACID → SQL:1992 事务语义, SQL:2011 隔离级别
- MVCC → 非SQL标准，但被主流数据库采用实现隔离级别
- CAP  → 分布式SQL数据库设计约束
══════════════════════════════════════════════════════════════════════════════
```

### 1.1 与SQL标准的关系

| 原理 | SQL标准关联 | 标准版本 |
|------|------------|---------|
| **ACID** | 事务定义、COMMIT/ROLLBACK语义 | SQL:1992 |
| **隔离级别** | READ UNCOMMITTED/COMMITTED/REPEATABLE READ/SERIALIZABLE | SQL:1992, SQL:2011 |
| **MVCC** | 非标准，实现机制 | - |
| **CAP** | 分布式SQL扩展 | - |

---

## 二、ACID原理

### 2.1 形式化定义

```text
ACID特性的形式化定义
══════════════════════════════════════════════════════════════════════════════

设 D 为数据库状态，T = {T₁, T₂, ..., Tₙ} 为事务集合

【原子性 Atomicity】
─────────────────────────────────────────────────────────────────────────────
定义：事务T的所有操作要么全部执行，要么全部不执行

形式化：∀T ∈ T: Execute(T) ∈ {AllOps(T), ∅}

其中：
- AllOps(T) = {op₁, op₂, ..., opₙ} 事务T的所有操作
- Execute(T) 实际执行的操作集合

证明（必要性）：
假设存在事务T部分执行（Execute(T) ⊂ AllOps(T) 且 Execute(T) ≠ ∅）
设 Execute(T) = {op₁, op₂, ..., opₖ}, k < n
则数据库状态 D' 不是T预期的最终状态也不是初始状态
→ 数据不一致
∴ 原子性是保证事务正确性的必要条件 □

【一致性 Consistency】
─────────────────────────────────────────────────────────────────────────────
定义：事务将数据库从一个一致状态转换到另一个一致状态

形式化：∀T ∈ T: Valid(D) ∧ Execute(T) → Valid(D')

其中：Valid(D) 表示数据库状态D满足所有完整性约束

约束类型：
- 实体完整性：主键非空且唯一
- 参照完整性：外键引用有效
- 域完整性：值在有效范围内
- 业务规则：应用层约束

【隔离性 Isolation】
─────────────────────────────────────────────────────────────────────────────
定义：并发执行的事务互不干扰，如同串行执行

形式化：∀T₁, T₂ ∈ T: Concurrent(T₁, T₂) →
        Effect(T₁ || T₂) = Effect(Serial(T₁, T₂))

其中：
- T₁ || T₂ 表示并发执行
- Serial(T₁, T₂) 表示某种串行顺序执行

隔离级别（SQL:2011）：
┌────────────────────┬──────────┬──────────┬──────────┬──────────┐
│ 隔离级别           │ 脏读     │ 不可重复读│ 幻读     │ 序列化   │
├────────────────────┼──────────┼──────────┼──────────┼──────────┤
│ READ UNCOMMITTED   │ 可能     │ 可能     │ 可能     │ ✗        │
│ READ COMMITTED     │ ✗        │ 可能     │ 可能     │ ✗        │
│ REPEATABLE READ    │ ✗        │ ✗        │ 可能     │ ✗        │
│ SERIALIZABLE       │ ✗        │ ✗        │ ✗        │ ✓        │
└────────────────────┴──────────┴──────────┴──────────┴──────────┘

【持久性 Durability】
─────────────────────────────────────────────────────────────────────────────
定义：已提交事务的修改永久保存，即使系统故障也不丢失

形式化：∀T ∈ T: Commit(T) → ∀t > tcommit: D(t) 包含 Effect(T)

实现机制：
- WAL（Write-Ahead Logging）：先写日志，再写数据
- Checkpoint：定期将内存数据刷新到磁盘
- 复制：数据副本
```

### 2.2 ACID因果链

```text
ACID特性因果关系
══════════════════════════════════════════════════════════════════════════════

业务需求            技术实现              保证目标
────────           ────────              ────────
银行转账         → 原子性(Atomicity)   → 资金不会凭空消失或产生
  A→B转账                                 要么成功要么回滚
     │
     └─────────→ 一致性(Consistency) → 总金额守恒
                   CHECK(balance >= 0)    约束始终满足
     │
     └─────────→ 隔离性(Isolation)   → 并发转账不互相干扰
                   可串行化               读取一致性视图
     │
     └─────────→ 持久性(Durability)  → 转账成功后永不丢失
                   WAL + Checkpoint       系统崩溃可恢复

因果推导：
1. 业务正确性要求 → 需要原子性保证操作完整
2. 数据完整性要求 → 需要一致性保证约束满足
3. 并发处理要求   → 需要隔离性防止干扰
4. 可靠性要求     → 需要持久性防止丢失

∴ ACID是关系数据库事务正确性的充分条件
```

---

## 三、MVCC原理

### 3.1 形式化定义

```text
MVCC (Multi-Version Concurrency Control) 形式化定义
══════════════════════════════════════════════════════════════════════════════

【基本概念】
─────────────────────────────────────────────────────────────────────────────
设 x 为数据项

多版本存储：每个数据项x维护版本链
V(x) = {v₁, v₂, ..., vₙ} 其中vᵢ = (value, txn_id, begin_ts, end_ts)

- value: 数据值
- txn_id: 创建该版本的事务ID
- begin_ts: 版本开始时间戳
- end_ts: 版本结束时间戳（∞表示当前有效）

【版本可见性规则】
─────────────────────────────────────────────────────────────────────────────
事务T在时间戳ts读取x时，可见版本v满足：
Visible(v, T, ts) ⟺
    (v.begin_ts ≤ ts) ∧
    (v.end_ts > ts) ∧
    (v.txn_id ∈ Committed ∨ v.txn_id = T.id)

【快照隔离 Snapshot Isolation】
─────────────────────────────────────────────────────────────────────────────
定义：每个事务看到数据库在其开始时刻的一致快照

形式化：
∀T: Snapshot(T) = {(x, v) | v ∈ V(x) ∧ Visible(v, T, T.start_ts)}

读操作：Read(T, x) = v where (x, v) ∈ Snapshot(T)
写操作：Write(T, x, val) creates new version v' = (val, T.id, T.commit_ts, ∞)

【定理：MVCC保证快照隔离】
─────────────────────────────────────────────────────────────────────────────
证明：
1. 每个事务T看到开始时刻的快照Snapshot(T)
2. 快照包含所有在T.start_ts之前已提交的版本
3. T的写操作创建新版本，不影响其他事务的快照
4. 只有T提交后，新版本才对后续事务可见

∴ 事务间读取互不干扰，满足快照隔离 □
```

### 3.2 MVCC与隔离级别的关系

```text
MVCC实现SQL隔离级别
══════════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────────────┐
│                        MVCC与隔离级别映射                                    │
├──────────────────┬────────────────────────────────────────────────────────┤
│ SQL隔离级别      │ MVCC实现策略                                           │
├──────────────────┼────────────────────────────────────────────────────────┤
│ READ UNCOMMITTED │ 读取最新版本（包括未提交）                              │
│                  │ Read(T,x) = Latest(V(x))                               │
├──────────────────┼────────────────────────────────────────────────────────┤
│ READ COMMITTED   │ 每次读取时获取新快照                                    │
│                  │ Read(T,x) = Visible(V(x), T, CurrentTime())            │
├──────────────────┼────────────────────────────────────────────────────────┤
│ REPEATABLE READ  │ 事务开始时获取快照，整个事务使用同一快照                │
│ (Snapshot)       │ Read(T,x) = Visible(V(x), T, T.start_ts)               │
├──────────────────┼────────────────────────────────────────────────────────┤
│ SERIALIZABLE     │ 快照隔离 + 写写冲突检测 + 读写冲突检测(SSI)             │
│ (SSI)            │ 检测dangerous structure: rw-dependency cycle           │
└──────────────────┴────────────────────────────────────────────────────────┘

【可串行化快照隔离 SSI (Serializable Snapshot Isolation)】
─────────────────────────────────────────────────────────────────────────────
问题：纯快照隔离无法防止所有异常（如Write Skew）

Write Skew示例：
  T1: 读取x=10, y=10; if(x+y>0) then write(x=-15)
  T2: 读取x=10, y=10; if(x+y>0) then write(y=-15)

  快照隔离下两个事务都成功，但x+y=-30违反约束

SSI解决方案：
1. 维护rw-dependency（读写依赖）
2. 检测dangerous structure（T1 --rw--> T2 --rw--> T1循环）
3. 发现循环时中止其中一个事务
```

### 3.3 MVCC版本管理

```text
MVCC版本链示例
══════════════════════════════════════════════════════════════════════════════

数据项x的版本链（PostgreSQL风格）：

时间线:  ts=100    ts=150    ts=200    ts=250
           │         │         │         │
           ▼         ▼         ▼         ▼
┌─────────────────────────────────────────────────────┐
│ x版本链                                              │
│                                                      │
│ v1(val=10, txn=T1, begin=100, end=150)              │
│      │                                               │
│      └──→ v2(val=20, txn=T2, begin=150, end=200)    │
│                │                                     │
│                └──→ v3(val=30, txn=T3, begin=200, ∞)│
└─────────────────────────────────────────────────────┘

查询可见性：
- 事务在ts=120读x → 返回v1(10)
- 事务在ts=180读x → 返回v2(20)
- 事务在ts=250读x → 返回v3(30)
```

---

## 四、CAP定理

### 4.1 形式化定义

```text
CAP定理形式化
══════════════════════════════════════════════════════════════════════════════

【定理 (Brewer 2000, Gilbert & Lynch 2002证明)】
─────────────────────────────────────────────────────────────────────────────
在分布式系统中，以下三个属性最多只能同时满足两个：

C - Consistency（一致性）
A - Availability（可用性）
P - Partition Tolerance（分区容错性）

【形式化定义】
─────────────────────────────────────────────────────────────────────────────
设 S = (N, E) 为分布式系统，N为节点集合，E为网络连接

一致性 C:
∀n₁, n₂ ∈ N, ∀t, ∀x:
  read(n₁, x, t) = read(n₂, x, t)
（所有节点在同一时刻看到相同数据）

可用性 A:
∀n ∈ N, ∀req:
  ∃resp, ∃Δt < timeout: respond(n, req, resp, Δt)
（每个非故障节点在有限时间内响应请求）

分区容错性 P:
∀partition(N₁, N₂):
  S continues to operate
（网络分区发生时系统继续运行）

【证明（不可能定理）】
─────────────────────────────────────────────────────────────────────────────
假设系统同时满足C、A、P

场景：网络分区将节点分为N₁和N₂

1. 由P，系统继续运行
2. 客户端向n₁∈N₁发送write(x, v)
3. 由A，n₁必须在有限时间内响应，假设成功写入
4. 客户端向n₂∈N₂发送read(x)
5. 由A，n₂必须在有限时间内响应
6. 由于分区，n₂无法与n₁通信获取新值v
7. n₂只能返回旧值v'（v' ≠ v），违反C

矛盾！故CAP三者不可兼得 □
```

### 4.2 CAP权衡选择

```text
CAP系统分类
══════════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────────────┐
│                           CAP选择三角                                        │
│                                                                              │
│                              C (一致性)                                      │
│                              /\                                              │
│                             /  \                                             │
│                            /    \                                            │
│                           / CP系统\                                          │
│                          /  HBase  \                                         │
│                         /  MongoDB  \                                        │
│                        /    Zookeeper\                                       │
│                       /________________\                                     │
│              (可用性) A ────────────── P (分区容错)                           │
│                        \   AP系统    /                                       │
│                         \ Cassandra /                                        │
│                          \ DynamoDB/                                         │
│                           \  Redis /                                         │
│                            \      /                                          │
│                             \    /                                           │
│                              \  /                                            │
│                               \/                                             │
│                                                                              │
│  注：CA系统在分布式环境中不存在（必须容忍分区）                               │
│      单机数据库可视为CA（无分区问题）                                         │
└─────────────────────────────────────────────────────────────────────────────┘

系统选择决策：
┌───────────────┬────────────────────────────────────────────────────────────┐
│ 选择          │ 适用场景                                                   │
├───────────────┼────────────────────────────────────────────────────────────┤
│ CP (牺牲A)    │ 金融交易、库存管理等强一致性场景                           │
│               │ 分区时拒绝服务，保证数据正确                               │
├───────────────┼────────────────────────────────────────────────────────────┤
│ AP (牺牲C)    │ 社交媒体、内容分发等最终一致性场景                         │
│               │ 分区时继续服务，允许短暂不一致                             │
└───────────────┴────────────────────────────────────────────────────────────┘
```

---

## 五、PACELC扩展

### 5.1 PACELC定理

```text
PACELC定理（Abadi 2012）
══════════════════════════════════════════════════════════════════════════════

【扩展CAP】
CAP只讨论分区发生时的权衡，PACELC扩展考虑正常情况：

PACELC = if Partition then (A vs C) else (Latency vs Consistency)

形式化：
─────────
P - 分区发生时
  A - 选择可用性
  C - 选择一致性
E - 正常情况下（Else）
  L - 选择低延迟
  C - 选择一致性

【系统分类】
─────────────────────────────────────────────────────────────────────────────
┌─────────────────┬─────────────────┬─────────────────────────────────────────┐
│ 类型            │ 系统            │ 说明                                    │
├─────────────────┼─────────────────┼─────────────────────────────────────────┤
│ PA/EL           │ Cassandra       │ 分区时选可用，正常时选延迟              │
│                 │ DynamoDB        │ 最终一致性，高可用                      │
├─────────────────┼─────────────────┼─────────────────────────────────────────┤
│ PC/EC           │ HBase           │ 始终选一致性                            │
│                 │ VoltDB          │ 强一致，牺牲可用性和延迟                │
├─────────────────┼─────────────────┼─────────────────────────────────────────┤
│ PA/EC           │ MongoDB         │ 分区时可用，正常时一致                  │
│                 │ (configurable)  │ 可配置的一致性级别                      │
├─────────────────┼─────────────────┼─────────────────────────────────────────┤
│ PC/EL           │ PNUTS           │ 分区时一致，正常时低延迟                │
│                 │                 │ 较少见                                  │
└─────────────────┴─────────────────┴─────────────────────────────────────────┘

【形式化定义】
─────────────────────────────────────────────────────────────────────────────
设系统S在时刻t的状态为state(t)

正常运行：NoPartition(t) = ∀n₁, n₂ ∈ N: Connected(n₁, n₂, t)

延迟定义：Latency(op) = t_response - t_request

一致性定义：Consistent(t) = ∀n₁, n₂: read(n₁, x, t) = read(n₂, x, t)

PACELC权衡：
if ¬NoPartition(t):
    Choose(Availability) XOR Choose(Consistency)
else:
    Choose(LowLatency) XOR Choose(Consistency)
```

---

## 六、原理间的关系

### 6.1 ACID-MVCC-CAP关系图

```text
三大原理的关系
══════════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────────────┐
│                         原理层次关系                                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│    [理论层]                                                                  │
│         │                                                                    │
│         ├───→ ACID ←────────────────── 定义事务正确性                       │
│         │       │                                                            │
│         │       ├─ 原子性 ───→ 全或无执行                                   │
│         │       ├─ 一致性 ───→ 约束保持                                     │
│         │       ├─ 隔离性 ───→ 并发透明 ←─────┐                             │
│         │       └─ 持久性 ───→ 永久保存       │                             │
│         │                                      │                             │
│    [实现层]                                    │                             │
│         │                                      │                             │
│         └───→ MVCC ─────────────────────────→ 实现隔离性                    │
│                 │                                                            │
│                 ├─ 版本链 ───→ 非阻塞读                                     │
│                 ├─ 快照 ─────→ 一致性视图                                   │
│                 └─ SSI ─────→ 可串行化                                      │
│                                                                              │
│    [分布式层]                                                                │
│         │                                                                    │
│         └───→ CAP/PACELC ───→ 分布式约束                                   │
│                 │                                                            │
│                 ├─ 分布式ACID ───→ 2PC, 3PC, Saga                           │
│                 └─ 分布式MVCC ───→ 向量时钟, 因果一致性                     │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘

因果链：
─────────────────────────────────────────────────────────────────────────────
ACID定义正确性 → MVCC实现隔离性 → CAP约束分布式扩展
     │                │                │
     ↓                ↓                ↓
SQL标准事务     PostgreSQL/MySQL    分布式SQL数据库
                 隔离级别实现       (CockroachDB, TiDB)
```

### 6.2 决策矩阵

```text
场景与原理选择决策矩阵
══════════════════════════════════════════════════════════════════════════════

┌───────────────────┬────────────┬────────────┬────────────┬─────────────────┐
│ 场景              │ ACID要求   │ MVCC适用   │ CAP选择    │ 推荐方案        │
├───────────────────┼────────────┼────────────┼────────────┼─────────────────┤
│ 单机OLTP          │ 完整ACID   │ 高度适用   │ N/A        │ PostgreSQL/MySQL│
│ 金融转账          │            │ SI/SSI     │            │ SERIALIZABLE    │
├───────────────────┼────────────┼────────────┼────────────┼─────────────────┤
│ 单机OLAP          │ 弱ACID     │ 快照读     │ N/A        │ PostgreSQL      │
│ 报表分析          │ 只读事务   │ RC/RR      │            │ READ COMMITTED  │
├───────────────────┼────────────┼────────────┼────────────┼─────────────────┤
│ 分布式强一致      │ 分布式ACID │ 分布式MVCC │ CP         │ CockroachDB     │
│ 跨区域转账        │ 2PC/3PC    │ HLC时钟    │            │ Spanner         │
├───────────────────┼────────────┼────────────┼────────────┼─────────────────┤
│ 分布式高可用      │ 弱一致性   │ 最终一致   │ AP         │ Cassandra       │
│ 社交动态          │ 无事务     │            │            │ DynamoDB        │
├───────────────────┼────────────┼────────────┼────────────┼─────────────────┤
│ 混合负载          │ 可配置     │ 可配置     │ PA/EC      │ TiDB            │
│ 电商平台          │            │            │            │ YugabyteDB      │
└───────────────────┴────────────┴────────────┴────────────┴─────────────────┘
```

---

## 七、PostgreSQL 18实现

### 7.1 ACID实现

```sql
-- PostgreSQL 18: ACID实现示例

-- 原子性：事务块保证
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
-- 两条语句要么都成功，要么都回滚
COMMIT;

-- 一致性：约束检查
CREATE TABLE accounts (
    id SERIAL PRIMARY KEY,
    balance DECIMAL(12,2) NOT NULL CHECK (balance >= 0),
    customer_id INTEGER NOT NULL REFERENCES customers(id)
);

-- 隔离性：设置隔离级别
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
-- SSI实现可串行化
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
COMMIT;

-- 持久性：WAL配置
-- postgresql.conf:
-- wal_level = replica
-- synchronous_commit = on
-- fsync = on
```

### 7.2 MVCC实现

```sql
-- PostgreSQL 18: MVCC内部查看

-- 查看元组版本信息
SELECT ctid, xmin, xmax, * FROM accounts;
-- ctid: 物理位置
-- xmin: 创建该版本的事务ID
-- xmax: 删除该版本的事务ID（0表示未删除）

-- 快照隔离示例
-- 会话1
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SELECT * FROM accounts WHERE id = 1;  -- 看到快照

-- 会话2（并发）
UPDATE accounts SET balance = balance + 100 WHERE id = 1;
COMMIT;

-- 会话1继续
SELECT * FROM accounts WHERE id = 1;  -- 仍看到开始时的快照
COMMIT;

-- SSI写偏斜检测
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
SELECT SUM(balance) FROM accounts;  -- 读取
UPDATE accounts SET balance = balance - 50 WHERE id = 1;
COMMIT;
-- 如果并发事务形成rw-dependency循环，会报错：
-- ERROR: could not serialize access due to read/write dependencies
```

---

## 八、SQLite 3.45+实现

```sql
-- SQLite 3.45+: ACID/MVCC实现

-- 启用WAL模式（支持并发读）
PRAGMA journal_mode = WAL;

-- SQLite隔离级别
-- 默认：SERIALIZABLE（通过数据库级锁实现）
-- WAL模式下：读不阻塞写，写不阻塞读（类似MVCC效果）

-- 事务控制
BEGIN IMMEDIATE;  -- 获取写锁
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;

-- 约束实现一致性
CREATE TABLE accounts (
    id INTEGER PRIMARY KEY,
    balance REAL NOT NULL CHECK (balance >= 0),
    customer_id INTEGER NOT NULL REFERENCES customers(id)
);

-- 注意：SQLite外键约束需要显式启用
PRAGMA foreign_keys = ON;

-- SQLite是单机数据库，不涉及CAP问题
-- 但可以通过Litestream等工具实现复制
```

---

## 相关资源

### 相关文档

- [01.05-事务理论](./01.05-事务理论.md) - ACID详细形式化定义
- [03.09-并发控制形式化理论](../03-形式化模型/03.09-并发控制形式化理论.md) - MVCC形式化
- [03.10-分布式数据库形式化理论](../03-形式化模型/03.10-分布式数据库形式化理论.md) - CAP/PACELC

### 外部资源

- [A Critique of ANSI SQL Isolation Levels](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf) - 隔离级别经典论文
- [Brewer's CAP Theorem](https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed/) - CAP 12年后回顾
- [PACELC: Beyond CAP](http://cs-www.cs.yale.edu/homes/dna/papers/abadi-pacelc.pdf) - PACELC原始论文

---

**维护者**: SQL Standards Team
**最后更新**: 2025-12-01
