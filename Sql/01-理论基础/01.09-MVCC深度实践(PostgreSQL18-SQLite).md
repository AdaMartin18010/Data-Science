# MVCC深度实践：PostgreSQL 18 & SQLite 3.45+

> **创建日期**：2025-12-01
> **难度**：⭐⭐⭐⭐⭐
> **前置知识**：事务理论、ACID、并发控制
> **目标数据库**：PostgreSQL 18, SQLite 3.45+

---

## 📋 目录

- [MVCC深度实践：PostgreSQL 18 \& SQLite 3.45+](#mvcc深度实践postgresql-18--sqlite-345)
  - [📋 目录](#-目录)
  - [一、概述与知识图谱](#一概述与知识图谱)
    - [1.1 MVCC知识体系思维导图](#11-mvcc知识体系思维导图)
    - [1.2 使用场景决策矩阵](#12-使用场景决策矩阵)
  - [二、PostgreSQL 18 MVCC机制](#二postgresql-18-mvcc机制)
    - [2.1 元组版本结构](#21-元组版本结构)
    - [2.2 事务快照与可见性](#22-事务快照与可见性)
    - [2.3 可见性判断算法](#23-可见性判断算法)
    - [2.4 隔离级别实现](#24-隔离级别实现)
  - [三、SQLite 3.45+ 并发控制](#三sqlite-345-并发控制)
    - [3.1 WAL模式架构](#31-wal模式架构)
    - [3.2 SQLite事务模式](#32-sqlite事务模式)
    - [3.3 SQLite锁状态机](#33-sqlite锁状态机)
  - [四、事务控制流机制](#四事务控制流机制)
    - [4.1 PostgreSQL事务控制流](#41-postgresql事务控制流)
    - [4.2 SQLite事务控制流](#42-sqlite事务控制流)
  - [五、数据版本流可视化](#五数据版本流可视化)
    - [5.1 PostgreSQL版本演进图](#51-postgresql版本演进图)
    - [5.2 SQLite WAL版本流](#52-sqlite-wal版本流)
  - [六、场景决策框架](#六场景决策框架)
    - [6.1 隔离级别选择决策树](#61-隔离级别选择决策树)
    - [6.2 PostgreSQL vs SQLite选择矩阵](#62-postgresql-vs-sqlite选择矩阵)
  - [七、形式化证明](#七形式化证明)
    - [7.1 快照隔离正确性证明](#71-快照隔离正确性证明)
    - [7.2 SSI正确性证明](#72-ssi正确性证明)
  - [八、完整实践案例](#八完整实践案例)
    - [8.1 PostgreSQL 18银行转账](#81-postgresql-18银行转账)
    - [8.2 SQLite 3.45+库存管理](#82-sqlite-345库存管理)
    - [8.3 综合对比示例](#83-综合对比示例)
  - [相关资源](#相关资源)
    - [相关文档](#相关文档)
    - [外部资源](#外部资源)

---

## 一、概述与知识图谱

### 1.1 MVCC知识体系思维导图

```text
MVCC深度实践知识图谱
══════════════════════════════════════════════════════════════════════════════

                              MVCC并发控制
                                   │
        ┌──────────────┬───────────┼───────────┬──────────────┐
        │              │           │           │              │
        ▼              ▼           ▼           ▼              ▼
   版本存储模型    可见性规则    隔离级别    垃圾回收      冲突检测
        │              │           │           │              │
   ┌────┴────┐    ┌────┴────┐ ┌───┴───┐  ┌────┴────┐    ┌────┴────┐
   │         │    │         │ │       │  │         │    │         │
   ▼         ▼    ▼         ▼ ▼       ▼  ▼         ▼    ▼         ▼
 追加式   原地式  快照    事务  RC    RR   Vacuum   Auto   写写    读写
  存储     更新   时间戳  可见  SI    SSI  手动清理 清理   冲突    冲突

════════════════════════════════════════════════════════════════════════════
PostgreSQL 18                              SQLite 3.45+
────────────────                           ──────────────
• 追加式存储(Heap)                         • WAL模式
• xmin/xmax元组头                          • 写时复制
• 事务快照                                  • 单写者模型
• Vacuum垃圾回收                           • Checkpoint清理
• SSI可串行化                              • 数据库级锁
════════════════════════════════════════════════════════════════════════════
```

### 1.2 使用场景决策矩阵

```text
场景-数据库-隔离级别决策矩阵
══════════════════════════════════════════════════════════════════════════════

┌─────────────────┬─────────────┬─────────────┬─────────────┬────────────────┐
│ 使用场景         │ 并发特征     │ 一致性要求  │ PostgreSQL  │ SQLite         │
├─────────────────┼─────────────┼─────────────┼─────────────┼────────────────┤
│ 金融转账         │ 高并发读写   │ 强一致      │ SERIALIZABLE│ IMMEDIATE      │
│                 │             │             │ + SSI       │ + EXCLUSIVE    │
├─────────────────┼─────────────┼─────────────┼─────────────┼────────────────┤
│ 电商库存         │ 高并发读    │ 最终一致     │ REPEATABLE  │ WAL +          │
│                 │ 中等写      │              │ READ        │ DEFERRED       │
├─────────────────┼─────────────┼─────────────┼─────────────┼────────────────┤
│ 报表分析         │ 只读长事务   │ 快照一致    │ REPEATABLE  │ WAL +          │
│                 │             │             │ READ        │ 只读连接        │
├─────────────────┼─────────────┼─────────────┼─────────────┼────────────────┤
│ 日志写入         │ 高并发写    │ 弱一致       │ READ        │ WAL +          │
│                 │ 低读        │             │ COMMITTED    │ 异步Checkpoint │
├─────────────────┼─────────────┼─────────────┼─────────────┼────────────────┤
│ 嵌入式单用户     │ 单线程       │ 强一致      │ N/A         │ DELETE模式     │
│                 │             │             │             │ EXCLUSIVE      │
└─────────────────┴─────────────┴─────────────┴─────────────┴────────────────┘
```

---

## 二、PostgreSQL 18 MVCC机制

### 2.1 元组版本结构

```text
PostgreSQL 18 元组头结构
══════════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────────────┐
│                          HeapTupleHeaderData                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────┬─────────────┬─────────────┬─────────────┬───────────────┐  │
│  │ t_xmin (4B) │ t_xmax (4B) │ t_cid (4B)  │ t_ctid (6B) │ t_infomask    │  │
│  │ 创建事务ID   │ 删除事务ID   │ 命令ID      │ 物理位置     │ 状态标志      │  │
│  └─────────────┴─────────────┴─────────────┴─────────────┴───────────────┘  │
│                                                                             │
│  t_xmin: 插入该元组的事务ID                                                  │
│  t_xmax: 删除/更新该元组的事务ID（0表示未删除）                                │
│  t_cid:  事务内的命令序号                                                     │
│  t_ctid: 元组物理位置(页号, 偏移)                                             │
│  t_infomask: 状态位（已提交、已中止、冻结等）                                  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

版本链示例（UPDATE操作）：
─────────────────────────────────────────────────────────────────────────────
UPDATE accounts SET balance = 200 WHERE id = 1;  -- 事务T2执行

Before:                           After:
┌────────────────────────┐       ┌────────────────────────┐
│ id=1, balance=100      │       │ id=1, balance=100      │ (旧版本)
│ xmin=100, xmax=0       │  ──→  │ xmin=100, xmax=200     │
│ ctid=(0,1)             │       │ ctid=(0,2)  ─────┐     │
└────────────────────────┘       └───────────────────┼────┘
                                                     │
                                 ┌───────────────────▼────┐
                                 │ id=1, balance=200      │ (新版本)
                                 │ xmin=200, xmax=0       │
                                 │ ctid=(0,2)             │
                                 └────────────────────────┘
```

### 2.2 事务快照与可见性

```sql
-- PostgreSQL 18: 查看当前事务快照
SELECT txid_current();           -- 当前事务ID
SELECT txid_current_snapshot();  -- 当前快照

-- 快照格式: xmin:xmax:xip_list
-- 例如: 100:105:102,103
-- xmin=100: 所有<100的事务已提交，对当前可见
-- xmax=105: 所有>=105的事务对当前不可见
-- xip_list=102,103: 事务102,103正在进行，不可见

-- 查看元组版本信息
SELECT ctid, xmin, xmax, * FROM accounts;

-- 详细版本信息（需要pageinspect扩展）
CREATE EXTENSION IF NOT EXISTS pageinspect;
SELECT lp, t_xmin, t_xmax, t_ctid, t_infomask, t_data
FROM heap_page_items(get_raw_page('accounts', 0));
```

### 2.3 可见性判断算法

```text
PostgreSQL MVCC可见性判断算法
══════════════════════════════════════════════════════════════════════════════

输入: 元组t, 当前事务快照S = (xmin, xmax, xip_list)
输出: 元组是否可见

算法 HeapTupleSatisfiesMVCC(t, S):
─────────────────────────────────────────────────────────────────────────────
1. 检查xmin（创建事务）:
   IF t.xmin == CurrentTransactionId THEN
       -- 当前事务创建的元组
       IF t.xmax == 0 THEN RETURN VISIBLE
       ELSE RETURN NOT_VISIBLE  -- 已被当前事务删除
   END IF

   IF t.xmin NOT IN CommittedTransactions THEN
       RETURN NOT_VISIBLE  -- 创建事务未提交
   END IF

   IF t.xmin >= S.xmax OR t.xmin IN S.xip_list THEN
       RETURN NOT_VISIBLE  -- 创建事务在快照之后开始或正在进行
   END IF

2. 检查xmax（删除事务）:
   IF t.xmax == 0 THEN
       RETURN VISIBLE  -- 未被删除
   END IF

   IF t.xmax == CurrentTransactionId THEN
       RETURN NOT_VISIBLE  -- 被当前事务删除
   END IF

   IF t.xmax NOT IN CommittedTransactions THEN
       RETURN VISIBLE  -- 删除事务未提交
   END IF

   IF t.xmax >= S.xmax OR t.xmax IN S.xip_list THEN
       RETURN VISIBLE  -- 删除事务在快照之后，元组仍可见
   END IF

3. RETURN NOT_VISIBLE  -- 已被删除且删除事务已提交


可见性决策树:
─────────────────────────────────────────────────────────────────────────────
                    [元组t]
                       │
            ┌──────────┴──────────┐
            ▼                     ▼
    [xmin是当前事务?]      [xmin已提交?]
      │YES    │NO          │YES    │NO
      ▼       ▼            ▼       ▼
  [xmax=0?] 继续        [xmin<xmax│ 不可见
    │YES│NO            且不在xip?]
    ▼   ▼               │YES  │NO
 可见 不可见             ▼      ▼
                    [xmax=0?] 不可见
                      │YES│NO
                      ▼   ▼
                   可见 [xmax已提交
                        且xmax<xmax
                        且不在xip?]
                          │YES│NO
                          ▼   ▼
                       不可见 可见
```

### 2.4 隔离级别实现

```sql
-- PostgreSQL 18: 各隔离级别的MVCC实现

-- READ COMMITTED: 每条语句获取新快照
BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;
SELECT * FROM accounts WHERE id = 1;  -- 快照S1
-- 其他事务提交
SELECT * FROM accounts WHERE id = 1;  -- 快照S2（可能看到新数据）
COMMIT;

-- REPEATABLE READ: 事务开始时获取快照，整个事务使用
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SELECT * FROM accounts WHERE id = 1;  -- 快照S
-- 其他事务提交
SELECT * FROM accounts WHERE id = 1;  -- 仍使用快照S（看到相同数据）
COMMIT;

-- SERIALIZABLE (SSI): 快照隔离 + 读写依赖检测
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
SELECT SUM(balance) FROM accounts;    -- 记录读集合
UPDATE accounts SET balance = balance - 100 WHERE id = 1;  -- 记录写集合
COMMIT;  -- 检查是否存在危险结构（rw-dependency循环）

-- SSI写偏斜检测示例
-- 约束: 至少有一个医生值班
-- T1和T2同时执行，都读取到2个医生值班，然后各自下班
-- 快照隔离下两个都成功，但结果是0个医生值班（违反约束）
-- SSI会检测到并中止其中一个事务
```

---

## 三、SQLite 3.45+ 并发控制

### 3.1 WAL模式架构

```text
SQLite 3.45+ WAL模式架构
══════════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────────────┐
│                         SQLite WAL模式数据流                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   读操作                          写操作                                     │
│   ───────                         ───────                                   │
│   ┌─────────┐                    ┌─────────┐                                │
│   │ Reader1 │                    │ Writer  │                                │
│   └────┬────┘                    └────┬────┘                                │
│        │                              │                                     │
│        │ 读取快照                     │ 追加写                               │
│        ▼                              ▼                                     │
│   ┌─────────────────────────────────────────────────────────────────┐       │
│   │                        数据库文件 (.db)                          │       │
│   │  ┌─────────┬─────────┬─────────┬─────────┐                      │       │
│   │  │ Page 1  │ Page 2  │ Page 3  │ ...     │                      │       │
│   │  └─────────┴─────────┴─────────┴─────────┘                      │       │
│   └─────────────────────────────────────────────────────────────────┘       │
│                              ↑                                              │
│                              │ Checkpoint                                   │
│                              │ (将WAL合并回主文件)                          │
│   ┌─────────────────────────────────────────────────────────────────┐      │
│   │                        WAL文件 (.db-wal)                         │      │
│   │  ┌─────────┬─────────┬─────────┬─────────┬─────────┐            │      │
│   │  │ Frame1  │ Frame2  │ Frame3  │ Frame4  │ ...     │            │      │
│   │  │ Page2'  │ Page5'  │ Page2'' │ Page7'  │         │            │      │
│   │  └─────────┴─────────┴─────────┴─────────┴─────────┘            │      │
│   └─────────────────────────────────────────────────────────────────┘      │
│                                                                             │
│   ┌─────────────────────────────────────────────────────────────────┐      │
│   │                       WAL索引 (.db-shm)                          │      │
│   │  记录每个页面在WAL中的最新版本位置                                 │      │
│   └─────────────────────────────────────────────────────────────────┘      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

WAL读取逻辑:
1. 查询WAL索引，检查页面是否在WAL中有更新版本
2. 如果有，从WAL读取；否则从主文件读取
3. 读操作不阻塞写操作
```

### 3.2 SQLite事务模式

```sql
-- SQLite 3.45+: 启用WAL模式
PRAGMA journal_mode = WAL;

-- 事务模式对比
-- DEFERRED: 延迟获取锁（默认）
BEGIN DEFERRED;           -- 不立即获取锁
SELECT * FROM accounts;   -- 获取SHARED锁
UPDATE accounts SET balance = 100 WHERE id = 1;  -- 尝试获取RESERVED锁
COMMIT;                   -- 获取EXCLUSIVE锁并提交

-- IMMEDIATE: 立即获取RESERVED锁
BEGIN IMMEDIATE;          -- 立即获取RESERVED锁（阻止其他写者）
SELECT * FROM accounts;
UPDATE accounts SET balance = 100 WHERE id = 1;
COMMIT;

-- EXCLUSIVE: 立即获取EXCLUSIVE锁
BEGIN EXCLUSIVE;          -- 立即获取EXCLUSIVE锁（阻止其他读写）
SELECT * FROM accounts;
UPDATE accounts SET balance = 100 WHERE id = 1;
COMMIT;

-- WAL模式下的读写并发
-- 连接1（写者）
BEGIN IMMEDIATE;
UPDATE accounts SET balance = balance + 100 WHERE id = 1;
-- 此时连接2可以读取旧版本
COMMIT;

-- 连接2（读者）
SELECT * FROM accounts WHERE id = 1;  -- 读取快照，不被写者阻塞
```

### 3.3 SQLite锁状态机

```text
SQLite锁状态转换图
══════════════════════════════════════════════════════════════════════════════

                        ┌─────────────────────────────────────┐
                        │          锁状态转换                  │
                        └─────────────────────────────────────┘

    ┌────────┐     BEGIN      ┌────────┐     SELECT     ┌────────┐
    │UNLOCKED│───────────────→│UNLOCKED│───────────────→│ SHARED │
    └────────┘                └────────┘                └────┬───┘
         ↑                                                   │
         │                                                   │ UPDATE/INSERT
         │ COMMIT/ROLLBACK                                   ↓
         │                    ┌────────┐    BEGIN      ┌────────┐
         └────────────────────│UNLOCKED│←──IMMEDIATE──→│RESERVED│
                              └────────┘               └────┬───┘
                                   ↑                        │
                                   │                        │ COMMIT准备
                                   │ COMMIT/ROLLBACK        ↓
                                   │                   ┌────────┐
                                   └───────────────────│EXCLUSIVE│
                                                       └────────┘

锁兼容矩阵:
┌──────────┬─────────┬─────────┬──────────┬───────────┐
│ 请求\持有 │ UNLOCKED│ SHARED  │ RESERVED │ EXCLUSIVE │
├──────────┼─────────┼─────────┼──────────┼───────────┤
│ SHARED   │   ✓    │   ✓     │    ✓     │    ✗     │
│ RESERVED │   ✓    │   ✓     │    ✗     │    ✗     │
│ EXCLUSIVE│   ✓    │   ✗     │    ✗     │    ✗     │
└──────────┴─────────┴─────────┴──────────┴───────────┘

WAL模式增强:
- 多个读者可以并发（SHARED锁兼容）
- 一个写者可以与多个读者并发（读者看旧版本）
- 写者之间串行（只有一个RESERVED/EXCLUSIVE）
```

---

## 四、事务控制流机制

### 4.1 PostgreSQL事务控制流

```text
PostgreSQL 18 事务执行控制流
══════════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────────────┐
│                        事务生命周期控制流                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  [客户端]                    [PostgreSQL后端]                                │
│      │                            │                                         │
│      │ BEGIN                      │                                         │
│      │──────────────────────────→ │                                         │
│      │                            ├─→ 分配事务ID (xid)                       │
│      │                            ├─→ 创建事务快照 (SI/SSI)                  │
│      │                            ├─→ 初始化事务状态为IN_PROGRESS             │
│      │                            │                                         │
│      │ SELECT                     │                                         │
│      │──────────────────────────→ │                                         │
│      │                            ├─→ 获取快照（RC每次/RR复用）               │
│      │                            ├─→ 按可见性规则过滤元组                    │
│      │◀────────────────────────────│ 返回结果                               │
│      │                            │                                         │
│      │ UPDATE                     │                                         │
│      │──────────────────────────→ │                                         │
│      │                            ├─→ 定位目标元组                           │
│      │                            ├─→ 检查并获取行锁                         │
│      │                            ├─→ 设置旧元组xmax = 当前xid               │
│      │                            ├─→ 插入新元组(xmin=当前xid, xmax=0)       │
│      │                            ├─→ 写WAL日志                             │
│      │                            ├─→ SSI: 记录读写集合                      │
│      │◀────────────────────────────│ 返回影响行数                           │
│      │                            │                                         │
│      │ COMMIT                     │                                         │
│      │──────────────────────────→ │                                         │
│      │                            ├─→ SSI: 检查序列化冲突                    │
│      │                            │   IF 检测到危险结构 THEN                 │
│      │                            │       ABORT事务                         │
│      │                            │   END IF                                │
│      │                            ├─→ 写COMMIT WAL记录                      │
│      │                            ├─→ 刷新WAL到磁盘                          │
│      │                            ├─→ 更新事务状态为COMMITTED                │
│      │                            ├─→ 释放锁                                 │
│      │◀────────────────────────────│ 返回成功                               │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 4.2 SQLite事务控制流

```text
SQLite 3.45+ WAL模式事务控制流
══════════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────────────┐
│                     SQLite WAL模式事务执行流程                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  [应用程序]                  [SQLite引擎]                                    │
│      │                            │                                         │
│      │ BEGIN IMMEDIATE            │                                         │
│      │──────────────────────────→ │                                         │
│      │                            ├─→ 获取RESERVED锁                        │
│      │                            ├─→ 记录当前WAL位置（读取点）               │
│      │                            │                                         │
│      │ SELECT                     │                                         │
│      │──────────────────────────→ │                                         │
│      │                            ├─→ 查询WAL索引                            │
│      │                            ├─→ 从WAL或主文件读取页面                  │
│      │                            │   (读取点之前的版本)                     │
│      │◀────────────────────────────│ 返回结果                               │
│      │                            │                                         │
│      │ UPDATE                     │                                         │
│      │──────────────────────────→ │                                         │
│      │                            ├─→ 读取目标页面                          │
│      │                            ├─→ 在内存中修改                          │
│      │                            ├─→ 将修改后的页面追加到WAL                │
│      │                            ├─→ 更新WAL索引                           │
│      │◀────────────────────────────│ 返回影响行数                           │
│      │                            │                                         │
│      │ COMMIT                     │                                         │
│      │──────────────────────────→ │                                         │
│      │                            ├─→ 获取EXCLUSIVE锁（瞬间）                │
│      │                            ├─→ 将WAL帧标记为已提交                    │
│      │                            ├─→ 调用fsync()刷新WAL                     │
│      │                            ├─→ 释放锁                                 │
│      │                            ├─→ [可选] 触发Checkpoint                  │
│      │◀────────────────────────────│ 返回成功                               │
│                                                                             │
│  Checkpoint流程:                                                            │
│  ──────────────                                                             │
│      │ PRAGMA wal_checkpoint      │                                         │
│      │──────────────────────────→ │                                         │
│      │                            ├─→ 等待所有读者完成                        │
│      │                            ├─→ 将WAL内容合并到主文件                   │
│      │                            ├─→ 重置WAL文件                            │
│      │◀────────────────────────────│                                        │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 五、数据版本流可视化

### 5.1 PostgreSQL版本演进图

```text
PostgreSQL MVCC版本演进示例
══════════════════════════════════════════════════════════════════════════════

场景: 账户表 accounts(id, balance)
初始: (id=1, balance=100)

时间线: ─────────────────────────────────────────────────────────────────────→
        T1=100      T2=150      T3=200      T4=250      Vacuum
        INSERT      UPDATE      UPDATE      SELECT      清理

T1 (xid=100): INSERT INTO accounts VALUES (1, 100)
─────────────────────────────────────────────────────────────────────────────
        │
        ▼
┌───────────────────────┐
│ (1, 100)              │
│ xmin=100, xmax=0      │  ← 当前活跃版本
│ ctid=(0,1)            │
└───────────────────────┘

T2 (xid=150): UPDATE accounts SET balance=200 WHERE id=1
─────────────────────────────────────────────────────────────────────────────
        │
        ▼
┌───────────────────────┐      ┌───────────────────────┐
│ (1, 100)              │      │ (1, 200)              │
│ xmin=100, xmax=150    │─────→│ xmin=150, xmax=0      │ ← 当前活跃
│ ctid=(0,2)            │      │ ctid=(0,2)            │
└───────────────────────┘      └───────────────────────┘
     (对T1可见)                      (对T2+可见)

T3 (xid=200): UPDATE accounts SET balance=300 WHERE id=1
─────────────────────────────────────────────────────────────────────────────
┌───────────────┐      ┌───────────────┐      ┌───────────────┐
│ (1, 100)      │      │ (1, 200)      │      │ (1, 300)      │
│ xmin=100      │─────→│ xmin=150      │─────→│ xmin=200      │ ← 当前活跃
│ xmax=150      │      │ xmax=200      │      │ xmax=0        │
└───────────────┘      └───────────────┘      └───────────────┘

T4 (xid=250): SELECT * FROM accounts WHERE id=1
─────────────────────────────────────────────────────────────────────────────
快照: 250:250:
版本可见性检查:
- (1,100): xmin=100<250 ✓, xmax=150<250 已删除 ✗
- (1,200): xmin=150<250 ✓, xmax=200<250 已删除 ✗
- (1,300): xmin=200<250 ✓, xmax=0 未删除 ✓  → 返回此版本

Vacuum清理（假设最老活跃事务xid=240）:
─────────────────────────────────────────────────────────────────────────────
- (1,100): xmax=150 < 240, 可清理 ✓
- (1,200): xmax=200 < 240, 可清理 ✓
- (1,300): xmax=0, 保留

清理后:
┌───────────────┐
│ (1, 300)      │ ← 唯一版本
│ xmin=200      │
│ xmax=0        │
└───────────────┘
```

### 5.2 SQLite WAL版本流

```text
SQLite WAL模式版本流示例
══════════════════════════════════════════════════════════════════════════════

场景: 同上 accounts(id, balance)

时间线: ─────────────────────────────────────────────────────────────────────→
        W1写入     R1开始读    W2更新    R1继续读    W2提交    Checkpoint

初始状态:
┌─────────────────────────────┐
│     主数据库文件 (.db)       │
│  ┌─────────────────────┐    │
│  │ Page1: (1, 100)     │    │
│  └─────────────────────┘    │
└─────────────────────────────┘
┌─────────────────────────────┐
│     WAL文件 (.db-wal)       │
│  (空)                        │
└─────────────────────────────┘

W2开始: BEGIN IMMEDIATE; UPDATE accounts SET balance=200 WHERE id=1;
─────────────────────────────────────────────────────────────────────────────
┌─────────────────────────────┐
│     主数据库文件 (.db)       │
│  ┌─────────────────────┐    │
│  │ Page1: (1, 100)     │    │  ← 原始版本
│  └─────────────────────┘    │
└─────────────────────────────┘
┌─────────────────────────────┐
│     WAL文件 (.db-wal)       │
│  ┌─────────────────────┐    │
│  │ Frame1: Page1'      │    │  ← 新版本 (1, 200)
│  │ (1, 200)            │    │     未提交
│  └─────────────────────┘    │
└─────────────────────────────┘

R1读取（在W2提交前开始）:
─────────────────────────────────────────────────────────────────────────────
R1的读取点在Frame1之前 → 从主文件读取 Page1 → 返回 (1, 100)

W2提交: COMMIT;
─────────────────────────────────────────────────────────────────────────────
┌─────────────────────────────┐
│     WAL文件 (.db-wal)       │
│  ┌─────────────────────┐    │
│  │ Frame1: Page1'      │    │  ← 已提交
│  │ (1, 200)            │    │
│  │ committed=true      │    │
│  └─────────────────────┘    │
└─────────────────────────────┘

R1继续读取（同一事务内）:
─────────────────────────────────────────────────────────────────────────────
R1的读取点仍在Frame1之前 → 仍返回 (1, 100)  ← 快照一致性!

R2新读取（W2提交后开始）:
─────────────────────────────────────────────────────────────────────────────
R2的读取点包含Frame1 → 从WAL读取 → 返回 (1, 200)

Checkpoint:
─────────────────────────────────────────────────────────────────────────────
等待R1完成 → 将Frame1内容写入主文件 → 重置WAL

┌─────────────────────────────┐
│     主数据库文件 (.db)       │
│  ┌─────────────────────┐    │
│  │ Page1: (1, 200)     │    │  ← 合并后
│  └─────────────────────┘    │
└─────────────────────────────┘
```

---

## 六、场景决策框架

### 6.1 隔离级别选择决策树

```text
隔离级别选择决策树
══════════════════════════════════════════════════════════════════════════════

                    [开始选择隔离级别]
                            │
                            ▼
                    [是否需要可串行化?]
                      /          \
                    YES           NO
                    /              \
                   ▼                ▼
        ┌─────────────────┐   [是否需要防止幻读?]
        │ PostgreSQL:     │        /          \
        │ SERIALIZABLE    │      YES           NO
        │ (SSI)           │      /              \
        │                 │     ▼                ▼
        │ SQLite:         │ [是否需要       [是否需要防止
        │ BEGIN EXCLUSIVE │ 重复读一致?]     不可重复读?]
        └─────────────────┘   /    \           /    \
                            YES     NO       YES     NO
                            /        \       /        \
                           ▼          ▼     ▼          ▼
               ┌────────────────┐ ┌──────────────┐ ┌──────────────┐
               │ PostgreSQL:    │ │ PostgreSQL:  │ │ PostgreSQL:  │
               │ REPEATABLE READ│ │ REPEATABLE   │ │ READ         │
               │                │ │ READ         │ │ COMMITTED    │
               │ SQLite WAL:    │ │              │ │              │
               │ 事务内快照一致  │ │ SQLite WAL:  │ │ SQLite WAL:  │
               └────────────────┘ │ BEGIN        │ │ autocommit   │
                                  │ DEFERRED     │ │ 或短事务      │
                                  └──────────────┘ └──────────────┘

性能 vs 一致性权衡:
─────────────────────────────────────────────────────────────────────────────
┌─────────────────┬───────────────────┬───────────────────┐
│ 隔离级别         │ 一致性保证         │ 并发性能          │
├─────────────────┼───────────────────┼───────────────────┤
│ READ UNCOMMITTED│ 最低               │ 最高（很少使用）   │
│ READ COMMITTED  │ 防止脏读           │ 高                │
│ REPEATABLE READ │ 防止脏读+不可重复   │ 中                │
│ SERIALIZABLE    │ 完全可串行化       │ 低                │
└─────────────────┴───────────────────┴───────────────────┘
```

### 6.2 PostgreSQL vs SQLite选择矩阵

```text
数据库选择决策矩阵
══════════════════════════════════════════════════════════════════════════════

┌────────────────────┬─────────────────────┬─────────────────────┬───────────┐
│ 决策维度            │ 选PostgreSQL 18     │ 选SQLite 3.45+      │ 权重      │
├────────────────────┼─────────────────────┼─────────────────────┼───────────┤
│ 并发用户数          │ >10                 │ 1-10                │⭐⭐⭐⭐⭐ │
├────────────────────┼─────────────────────┼─────────────────────┼───────────┤
│ 数据量              │ >1GB                │ <1GB                │⭐⭐⭐⭐   │
├────────────────────┼─────────────────────┼─────────────────────┼───────────┤
│ 写并发              │ 高并发写            │ 低并发写             │⭐⭐⭐⭐⭐ │
├────────────────────┼─────────────────────┼─────────────────────┼───────────┤
│ 部署复杂度          │ 可接受C/S架构        │ 需要嵌入式/零配置    │ ⭐⭐⭐   │
├────────────────────┼─────────────────────┼─────────────────────┼───────────┤
│ 高级SQL特性         │ 需要(JSON,CTE递归)   │ 基本够用            │ ⭐⭐⭐   │
├────────────────────┼─────────────────────┼─────────────────────┼───────────┤
│ 隔离级别需求        │ 需要SSI              │ WAL快照足够         │ ⭐⭐⭐⭐│
├────────────────────┼─────────────────────┼─────────────────────┼───────────┤
│ 扩展性              │ 需要扩展/插件        │ 不需要              │ ⭐⭐     │
└────────────────────┴─────────────────────┴─────────────────────┴───────────┘

典型场景推荐:
─────────────────────────────────────────────────────────────────────────────
• Web应用后端     → PostgreSQL 18
• 移动应用本地存储 → SQLite 3.45+ WAL
• 桌面应用        → SQLite 3.45+
• 微服务          → PostgreSQL 18
• IoT边缘设备     → SQLite 3.45+
• 金融交易系统    → PostgreSQL 18 SERIALIZABLE
• 测试/原型       → SQLite 3.45+
```

---

## 七、形式化证明

### 7.1 快照隔离正确性证明

```text
定理: PostgreSQL MVCC实现满足快照隔离
══════════════════════════════════════════════════════════════════════════════

定义:
─────
设 T 为事务集合
设 S(T) = (xmin, xmax, xip_list) 为事务T的快照
设 Visible(t, T) 为元组t对事务T的可见性

快照隔离性质:
1. 事务读取开始时刻的一致快照
2. 写冲突时先提交者胜出

证明:
─────

【性质1证明: 快照一致性】

引理1: 对于REPEATABLE READ事务T，整个事务使用相同快照S(T)

证明:
- T开始时，获取快照S(T) = (xmin_T, xmax_T, xip_T)
- 对于任意读操作Read(T, x)，使用Visible(v, T, S(T))判断可见性
- S(T)在事务T生命周期内不变
∴ T看到的是开始时刻的一致快照 □

引理2: 快照S(T)包含所有在T开始前已提交事务的效果

证明:
- xmin_T = 开始时最小活跃事务ID
- 所有 xid < xmin_T 的事务已完成（提交或回滚）
- 若事务T'(xid < xmin_T)已提交，则T'.xmin对T可见
- 若事务T'已回滚，则T'的元组(xmax=T'.xid)对T不可见
∴ 快照正确反映T开始时刻的数据库状态 □

【性质2证明: 写冲突处理】

引理3: 两个并发事务写同一行时，只有一个能成功

证明:
- T1和T2同时更新元组t
- T1先获取t的行锁，设置t.xmax = T1.xid
- T2尝试更新时，发现t.xmax ≠ 0
- T2等待T1完成:
  - 若T1提交: T2发现冲突，可选择:
    * 重试（读取新版本并更新）
    * 回滚
  - 若T1回滚: T2可以继续更新
∴ 先提交者胜出 □

综合以上引理，PostgreSQL MVCC满足快照隔离的定义 □
```

### 7.2 SSI正确性证明

```text
定理: PostgreSQL SSI实现保证可串行化
══════════════════════════════════════════════════════════════════════════════

背景:
─────
SSI (Serializable Snapshot Isolation) 在快照隔离基础上检测读写依赖循环

定义:
─────
读写依赖 rw(T1, T2): T1读取了T2后来修改的数据
写写依赖 ww(T1, T2): T2覆盖了T1写入的数据
写读依赖 wr(T1, T2): T2读取了T1写入的数据

危险结构: T1 --rw--> T2 --rw--> T1 形成的循环

证明:
─────

【充分性: 无危险结构 → 可串行化】

引理4: 若执行历史H不包含危险结构，则H可串行化

证明（反证法）:
- 假设H不可串行化
- 则存在依赖循环: T1 → T2 → ... → Tk → T1
- 由快照隔离性质，wr依赖和ww依赖不形成循环（先提交者胜出）
- 因此循环中必须包含rw依赖
- 由Fekete等人的理论，最小循环是 T1 --rw--> T2 --rw--> T1
- 这就是危险结构
- 与假设矛盾
∴ 无危险结构 → 可串行化 □

【SSI检测算法正确性】

引理5: SSI检测算法发现所有危险结构

证明:
- SSI维护每个事务的读集合R(T)和写集合W(T)
- 对于任意两个并发事务T1, T2:
  - 若 R(T1) ∩ W(T2) ≠ ∅，记录 rw(T1, T2)
  - 若 R(T2) ∩ W(T1) ≠ ∅，记录 rw(T2, T1)
- 若同时存在 rw(T1, T2) 和 rw(T2, T1)，形成危险结构
- 中止T1或T2

检测发生时机:
- T1读取时: 检查是否存在并发T2已修改该数据
- T1提交时: 检查T1的写是否与其他事务的读冲突

∴ SSI正确检测并阻止所有危险结构 □

综合引理4和引理5:
PostgreSQL SSI实现保证可串行化 □
```

---

## 八、完整实践案例

### 8.1 PostgreSQL 18银行转账

```sql
-- PostgreSQL 18: 完整的银行转账案例（展示MVCC和SSI）

-- 创建账户表
CREATE TABLE bank_accounts (
    account_id      SERIAL PRIMARY KEY,
    customer_name   VARCHAR(100) NOT NULL,
    balance         DECIMAL(15,2) NOT NULL DEFAULT 0.00,
    updated_at      TIMESTAMPTZ DEFAULT NOW(),
    CONSTRAINT positive_balance CHECK (balance >= 0)
);

-- 插入测试数据
INSERT INTO bank_accounts (customer_name, balance) VALUES
    ('Alice', 1000.00),
    ('Bob', 500.00);

-- 转账存储过程（使用SERIALIZABLE保证一致性）
CREATE OR REPLACE FUNCTION transfer_money(
    p_from_account INTEGER,
    p_to_account INTEGER,
    p_amount DECIMAL(15,2)
) RETURNS BOOLEAN AS $$
DECLARE
    v_from_balance DECIMAL(15,2);
BEGIN
    -- 锁定并检查源账户余额
    SELECT balance INTO v_from_balance
    FROM bank_accounts
    WHERE account_id = p_from_account
    FOR UPDATE;

    IF v_from_balance < p_amount THEN
        RAISE EXCEPTION '余额不足: 可用 %, 需要 %', v_from_balance, p_amount;
    END IF;

    -- 执行转账
    UPDATE bank_accounts
    SET balance = balance - p_amount,
        updated_at = NOW()
    WHERE account_id = p_from_account;

    UPDATE bank_accounts
    SET balance = balance + p_amount,
        updated_at = NOW()
    WHERE account_id = p_to_account;

    -- 记录转账日志
    INSERT INTO transfer_log (from_account, to_account, amount, transfer_time)
    VALUES (p_from_account, p_to_account, p_amount, NOW());

    RETURN TRUE;
END;
$$ LANGUAGE plpgsql;

-- 使用SERIALIZABLE隔离级别执行转账
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
SELECT transfer_money(1, 2, 100.00);
COMMIT;

-- 验证MVCC: 并发读取不阻塞
-- 会话1（写事务）
BEGIN;
UPDATE bank_accounts SET balance = balance - 50 WHERE account_id = 1;
-- 此时会话2可以读取旧值

-- 会话2（读事务）
SELECT * FROM bank_accounts WHERE account_id = 1;
-- 返回修改前的余额（MVCC快照）

-- 会话1提交
COMMIT;

-- 查看元组版本（调试用）
SELECT ctid, xmin, xmax, * FROM bank_accounts;

-- 查看事务快照
SELECT txid_current(), txid_current_snapshot();
```

### 8.2 SQLite 3.45+库存管理

```sql
-- SQLite 3.45+: 库存管理案例（展示WAL并发控制）

-- 启用WAL模式和外键约束
PRAGMA journal_mode = WAL;
PRAGMA foreign_keys = ON;
PRAGMA busy_timeout = 5000;  -- 等待锁5秒

-- 创建库存表
CREATE TABLE inventory (
    product_id      INTEGER PRIMARY KEY,
    product_name    TEXT NOT NULL,
    quantity        INTEGER NOT NULL DEFAULT 0 CHECK (quantity >= 0),
    reserved        INTEGER NOT NULL DEFAULT 0 CHECK (reserved >= 0),
    updated_at      TEXT DEFAULT (datetime('now'))
) STRICT;

-- 创建订单表
CREATE TABLE orders (
    order_id        INTEGER PRIMARY KEY AUTOINCREMENT,
    product_id      INTEGER NOT NULL REFERENCES inventory(product_id),
    quantity        INTEGER NOT NULL CHECK (quantity > 0),
    status          TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'confirmed', 'shipped', 'cancelled')),
    created_at      TEXT DEFAULT (datetime('now'))
) STRICT;

-- 插入测试数据
INSERT INTO inventory (product_id, product_name, quantity) VALUES
    (1, 'Widget A', 100),
    (2, 'Widget B', 50);

-- 下单（使用IMMEDIATE事务保证写一致性）
-- 连接可以使用Python/Node.js等调用

-- 示例: 并发安全的下单操作
-- 步骤1: 开始IMMEDIATE事务（获取写锁）
BEGIN IMMEDIATE;

-- 步骤2: 检查并预留库存
UPDATE inventory
SET reserved = reserved + 10,
    updated_at = datetime('now')
WHERE product_id = 1
  AND quantity - reserved >= 10;

-- 检查是否成功预留
SELECT changes();  -- 返回1表示成功

-- 步骤3: 创建订单
INSERT INTO orders (product_id, quantity, status)
VALUES (1, 10, 'pending');

-- 步骤4: 提交
COMMIT;

-- 确认订单（扣减库存）
BEGIN IMMEDIATE;

UPDATE inventory
SET quantity = quantity - 10,
    reserved = reserved - 10,
    updated_at = datetime('now')
WHERE product_id = 1;

UPDATE orders
SET status = 'confirmed'
WHERE order_id = 1;

COMMIT;

-- WAL并发读写示例
-- 写操作不阻塞读操作

-- 触发Checkpoint（将WAL合并到主文件）
PRAGMA wal_checkpoint(TRUNCATE);

-- 查看WAL状态
PRAGMA wal_checkpoint;
-- 返回: busy, log, checkpointed
```

### 8.3 综合对比示例

```sql
-- 同一业务逻辑在两个数据库的实现对比

/*
══════════════════════════════════════════════════════════════════════════════
场景: 用户注册时检查用户名唯一性并插入
══════════════════════════════════════════════════════════════════════════════
*/

-- PostgreSQL 18 实现
-- 方案1: 使用SERIALIZABLE
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
SELECT 1 FROM users WHERE username = 'newuser';
-- 如果不存在
INSERT INTO users (username, email) VALUES ('newuser', 'new@example.com');
COMMIT;
-- SSI会检测并发插入相同用户名的情况

-- 方案2: 使用UNIQUE约束（更简单）
INSERT INTO users (username, email) VALUES ('newuser', 'new@example.com')
ON CONFLICT (username) DO NOTHING
RETURNING *;
-- 返回NULL表示用户名已存在

-- SQLite 3.45+ 实现
-- 方案1: 使用IMMEDIATE事务
BEGIN IMMEDIATE;
SELECT 1 FROM users WHERE username = 'newuser';
-- 如果不存在
INSERT INTO users (username, email) VALUES ('newuser', 'new@example.com');
COMMIT;

-- 方案2: 使用INSERT OR IGNORE
INSERT OR IGNORE INTO users (username, email) VALUES ('newuser', 'new@example.com');
SELECT changes();  -- 返回0表示用户名已存在

/*
══════════════════════════════════════════════════════════════════════════════
性能对比思维导图
══════════════════════════════════════════════════════════════════════════════

                    用户注册并发处理
                          │
           ┌──────────────┴──────────────┐
           │                             │
    PostgreSQL 18                   SQLite 3.45+
           │                             │
    ┌──────┴──────┐               ┌──────┴──────┐
    │             │               │             │
 SERIALIZABLE   UPSERT         IMMEDIATE    INSERT OR
 (悲观)        (乐观)          (串行写)     IGNORE
    │             │               │             │
 开销高        开销低          单写者      单写者
 高并发安全    处理冲突        队列写入    处理冲突

推荐:                         推荐:
高并发→UPSERT               任何场景→INSERT OR IGNORE
关键操作→SERIALIZABLE       需要返回值→RETURNING
*/
```

---

## 相关资源

### 相关文档

- [01.05-事务理论](./01.05-事务理论.md) - ACID详细定义
- [01.08-核心原理模型(ACID-MVCC-CAP)](./01.08-核心原理模型(ACID-MVCC-CAP).md) - 原理整合
- [03.09-并发控制形式化理论](../03-形式化模型/03.09-并发控制形式化理论.md) - 形式化证明

### 外部资源

- [PostgreSQL MVCC官方文档](https://www.postgresql.org/docs/current/mvcc.html)
- [SQLite WAL模式文档](https://www.sqlite.org/wal.html)
- [Serializable Snapshot Isolation论文](https://dl.acm.org/doi/10.1145/1376616.1376690)

---

**维护者**: SQL Standards Team
**最后更新**: 2025-12-01
