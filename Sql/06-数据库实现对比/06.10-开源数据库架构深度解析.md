# 开源数据库架构深度解析

> **创建日期**: 2025-12-05
> **对象**: PostgreSQL 18/MySQL 8.4/SQLite 3.47
> **难度**: ⭐⭐⭐⭐⭐

---

## PostgreSQL架构精华

### 进程模型

```text
PostgreSQL进程架构
══════════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────┐
│                    Postmaster (主进程)                       │
│  • 监听连接                                                  │
│  • fork子进程                                                │
│  • 管理后台进程                                              │
└──────┬──────────────────────────────────────────────────────┘
       │
       ├─ Backend Processes（每个客户端连接一个）
       │  ├─ Backend 1 (Client 1)
       │  ├─ Backend 2 (Client 2)
       │  └─ Backend N (Client N)
       │
       ├─ Background Processes
       │  ├─ Checkpointer（刷脏页到磁盘）
       │  ├─ WAL Writer（写WAL到磁盘）
       │  ├─ Autovacuum Launcher（清理死元组）
       │  ├─ Autovacuum Workers（实际清理）
       │  ├─ Archiver（归档WAL）
       │  ├─ Stats Collector（统计信息收集）
       │  └─ Logical Replication Workers（逻辑复制）
       │
       └─ Shared Memory
          ├─ Shared Buffers（共享缓冲池，默认128MB）
          ├─ WAL Buffers（WAL缓冲）
          └─ Lock Tables（锁表）

进程 vs 线程对比:
优势:
• 隔离性强（进程崩溃不影响其他）
• 调试简单（gdb attach）
• 稳定性高

劣势:
• 内存占用大（每个进程10-50MB）
• 上下文切换开销
• 连接数限制（典型200-500）

连接池必要性（pgBouncer）:
┌──────────┐          ┌──────────┐
│ 1000个   │          │ 20个     │
│ 应用连接 │──────────│ PG连接   │
└──────────┘  pgBouncer└──────────┘

模式:
• Session模式：1连接对应1后端（可用事务）
• Transaction模式：1事务占用1后端（高并发）
• Statement模式：1语句占用1后端（最高并发）
```

### MVCC实现（xmin/xmax）

```text
PostgreSQL MVCC元组结构
══════════════════════════════════════════════════════════════════════════════

元组头部（HeapTupleHeader）:
┌──────────────────────────────────────────────────────────┐
│ t_xmin (4字节)  | 创建该版本的事务ID                      │
│ t_xmax (4字节)  | 删除该版本的事务ID（0=未删除）          │
│ t_cid (4字节)   | 命令ID（事务内语句序号）                │
│ t_ctid (6字节)  | 下一版本位置（更新链）                  │
│ t_infomask (2字节) | 标志位                              │
│ t_hoff (1字节)  | 用户数据偏移                           │
│ ...其他字段...                                           │
├──────────────────────────────────────────────────────────┤
│ User Data (用户数据)                                     │
└──────────────────────────────────────────────────────────┘

可见性判断算法:
bool tuple_visible(HeapTuple tuple, Snapshot snap) {
    // 1. 检查创建事务
    if (tuple->t_xmin > snap->xmax) {
        return false;  // 在快照之后创建
    }
    if (tuple->t_xmin >= snap->xmin &&
        XidInMVCCSnapshot(tuple->t_xmin, snap)) {
        return false;  // 创建事务未提交
    }

    // 2. 检查删除事务
    if (tuple->t_xmax == 0) {
        return true;  // 未删除
    }
    if (tuple->t_xmax > snap->xmax) {
        return true;  // 删除在快照之后
    }
    if (tuple->t_xmax >= snap->xmin &&
        XidInMVCCSnapshot(tuple->t_xmax, snap)) {
        return true;  // 删除事务未提交
    }

    return false;  // 已删除
}

示例：更新操作
初始状态:
┌─────────────────────────────┐
│ xmin=100 | xmax=0 | data=v1 │ (可见)
└─────────────────────────────┘

UPDATE (txn_id=200):
┌─────────────────────────────┐
│ xmin=100 | xmax=200 | data=v1 │ (标记删除)
└─────────────────────────────┘
┌─────────────────────────────┐
│ xmin=200 | xmax=0 | data=v2 │ (新版本)
└─────────────────────────────┘

事务150查询（snap->xmax=199）:
• 版本1：xmin=100 < 199, xmax=200 > 199 → 可见
• 版本2：xmin=200 > 199 → 不可见
• 返回：v1

事务250查询（snap->xmax=249）:
• 版本1：xmin=100 < 249, xmax=200 < 249 → 不可见
• 版本2：xmin=200 < 249, xmax=0 → 可见
• 返回：v2
```

### 查询优化器（遗传算法）

```text
PostgreSQL优化器架构
══════════════════════════════════════════════════════════════════════════════

阶段1：预处理（Rewriter）
• 视图展开
• 规则应用（RULEs）
• 子查询提升

阶段2：规划器（Planner）
步骤2.1：生成路径（Path Generation）
  • 顺序扫描路径
  • 索引扫描路径
  • 位图扫描路径
  • TID扫描路径

步骤2.2：JOIN路径生成
  方法1：动态规划（<12个表）
    • 枚举所有JOIN顺序
    • 复杂度：O(3^n)

  方法2：遗传算法（≥12个表）
    • 初始种群：随机JOIN顺序
    • 适应度：代价估算
    • 交叉：组合两个计划
    • 变异：随机调整
    • 迭代：收敛到最优

    伪代码:
    population = random_join_orders(size=50)
    for generation in range(100):
        scores = [cost(plan) for plan in population]
        parents = select_best(population, scores, n=20)

        offspring = []
        for _ in range(30):
            p1, p2 = random.sample(parents, 2)
            child = crossover(p1, p2)
            if random.random() < 0.1:
                child = mutate(child)
            offspring.append(child)

        population = parents + offspring

    return best(population)

步骤2.3：代价估算
  Cost = Startup_Cost + Run_Cost

  Run_Cost = CPU_Cost + IO_Cost
  CPU_Cost = rows * cpu_tuple_cost
  IO_Cost = pages * (seq_page_cost or random_page_cost)

阶段3：执行器（Executor）
• Volcano迭代器模型
• JIT编译（PostgreSQL 11+）
• 并行执行（PostgreSQL 9.6+）

配置调优:
-- 启用JIT（大查询）
SET jit = on;
SET jit_above_cost = 100000;

-- 遗传算法参数
SET geqo_threshold = 12;  # ≥12表启用
SET geqo_generations = 100;
SET geqo_pool_size = 50;

-- 代价参数（SSD）
SET random_page_cost = 1.1;  # 默认4.0（HDD）
SET effective_cache_size = '16GB';
```

---

## MySQL架构精华

### 插件式存储引擎

```text
MySQL分层架构
══════════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────┐
│            MySQL Server Layer                           │
│  ┌──────────────────────────────────────────────────┐  │
│  │  Connection Pool（连接池）                        │  │
│  └──────────────────────────────────────────────────┘  │
│  ┌──────────────────────────────────────────────────┐  │
│  │  SQL Parser（SQL解析器）                          │  │
│  └──────────────────────────────────────────────────┘  │
│  ┌──────────────────────────────────────────────────┐  │
│  │  Optimizer（优化器）                              │  │
│  └──────────────────────────────────────────────────┘  │
│  ┌──────────────────────────────────────────────────┐  │
│  │  Cache（查询缓存，已废弃）                         │  │
│  └──────────────────────────────────────────────────┘  │
└───────────────────┬─────────────────────────────────────┘
                    │ Storage Engine API
        ┌───────────┼───────────┬───────────┐
        │           │           │           │
┌───────▼───┐  ┌────▼────┐  ┌──▼──────┐  ┌─▼────┐
│  InnoDB   │  │ MyISAM  │  │ Memory  │  │ CSV  │
│ (默认)    │  │ (已弃用) │  │ (临时)  │  │      │
└───────────┘  └─────────┘  └─────────┘  └──────┘

InnoDB架构:
┌─────────────────────────────────────────┐
│ Buffer Pool（缓冲池）                    │
│  • 数据页缓存                            │
│  • 索引页缓存                            │
│  • LRU淘汰算法                           │
│  • 默认128MB → 推荐：RAM的70-80%        │
├─────────────────────────────────────────┤
│ Change Buffer（变更缓冲）                │
│  • 二级索引更新缓冲                      │
│  • 延迟写入（异步）                      │
├─────────────────────────────────────────┤
│ Redo Log（重做日志）                     │
│  • ib_logfile0, ib_logfile1             │
│  • 循环写入                              │
│  • 默认48MB → 推荐：1-2GB               │
├─────────────────────────────────────────┤
│ Undo Log（回滚日志）                     │
│  • MVCC版本链                            │
│  • 存储在ibdata或独立表空间              │
└─────────────────────────────────────────┘

配置优化:
[mysqld]
# Buffer Pool（内存的75%）
innodb_buffer_pool_size = 12G
innodb_buffer_pool_instances = 8  # 多实例（并发）

# Redo Log
innodb_log_file_size = 1G
innodb_log_files_in_group = 2
innodb_flush_log_at_trx_commit = 1  # 1=强一致，2=高性能

# IO优化
innodb_io_capacity = 2000  # SSD
innodb_io_capacity_max = 4000
innodb_flush_method = O_DIRECT  # 绕过OS缓存

# Change Buffer
innodb_change_buffering = all
innodb_change_buffer_max_size = 25  # Buffer Pool的25%
```

### Group Replication（MGR）

```text
MGR架构（多主复制）
══════════════════════════════════════════════════════════════════════════════

┌────────────┐  ┌────────────┐  ┌────────────┐
│  Node 1    │  │  Node 2    │  │  Node 3    │
│  (Primary) │  │ (Secondary)│  │ (Secondary)│
└──────┬─────┘  └─────┬──────┘  └─────┬──────┘
       │              │              │
       └──────────────┼──────────────┘
                      │
              Group Communication
                 (Paxos协议)

工作流程:
1. 客户端写入 → Node 1
2. Node 1广播事务 → Group
3. Group达成共识（多数派）
4. 所有节点提交
5. Node 1返回客户端

一致性保证:
• 写入延迟：+10-50ms（共识开销）
• 数据一致性：强一致（所有节点相同）
• 故障切换：自动（< 10秒）

冲突检测:
-- 基于行的冲突检测
Transaction T1: UPDATE users SET name='Alice' WHERE id=1;
Transaction T2: UPDATE users SET name='Bob' WHERE id=1;
-- T2会被拒绝（冲突），需要重试

-- 乐观并发
-- 提交时检测冲突，而非加锁

流控（Flow Control）:
-- 防止慢节点拖累整个集群
-- 如果某节点延迟 > 阈值，暂停向其发送事务

单主 vs 多主:
单主模式（推荐）:
• 只有Primary接受写入
• Secondary只读
• 无写冲突

多主模式（高级）:
• 所有节点可写
• 需要处理冲突
• 复杂度高
```

---

## SQLite架构精华

### VDBE虚拟机（字节码）

```text
SQLite编译执行流程
══════════════════════════════════════════════════════════════════════════════

SQL查询：
SELECT name FROM users WHERE id = 1;

编译为VDBE字节码：
Addr  Opcode         P1    P2    P3    P4
----  -------------  ----  ----  ----  ---------------
0     Init           0     12    0
1     OpenRead       0     2     0     users(name,id)
2     Integer        1     1     0
3     SeekGE         0     11    1     1
4       IdxGT        0     11    1     1
5       Column       0     0     2
6       ResultRow    2     1     0
7       Next         0     4     0
8     Goto           0     11    0
9     Noop           0     0     0
10    Close          0     0     0
11    Halt           0     0     0

指令详解:
• Init: 初始化，跳到结束（如果错误）
• OpenRead: 打开表游标（P1=游标号，P2=根页号）
• Integer: 加载整数1到寄存器R[1]
• SeekGE: 游标定位到 ≥ R[1] 的行
• IdxGT: 如果当前行 > R[1]，跳出循环
• Column: 读取列到寄存器R[2]
• ResultRow: 输出结果行
• Next: 移动游标到下一行
• Halt: 停止执行

VDBE vs 直接执行:
优势:
• 平台无关（字节码）
• 易于调试（EXPLAIN）
• 优化机会（字节码级）

劣势:
• 解释开销（vs 编译）
• 分支预测差
```

### B-Tree精简实现

```text
SQLite B-Tree页面结构
══════════════════════════════════════════════════════════════════════════════

页面类型:
1. 内部页（Interior Page）
   ┌────────────────────────────────────┐
   │ Page Header (12字节)               │
   ├────────────────────────────────────┤
   │ Cell Pointer Array                 │
   │  [offset₁, offset₂, ..., offsetₙ] │
   ├────────────────────────────────────┤
   │ Unallocated Space                  │
   ├────────────────────────────────────┤
   │ Cell Content Area                  │
   │  Cell₁: [key₁, left_child_page]   │
   │  Cell₂: [key₂, right_child_page]  │
   │  ...                               │
   └────────────────────────────────────┘

2. 叶子页（Leaf Page）
   ┌────────────────────────────────────┐
   │ Page Header (8字节)                │
   ├────────────────────────────────────┤
   │ Cell Pointer Array                 │
   ├────────────────────────────────────┤
   │ Unallocated Space                  │
   ├────────────────────────────────────┤
   │ Cell Content Area                  │
   │  Cell₁: [key₁, data₁]             │
   │  Cell₂: [key₂, data₂]             │
   │  ...                               │
   └────────────────────────────────────┘

Cell格式（叶子页）:
┌──────────────────────────────────────┐
│ Varint: Payload Size                 │
│ Varint: RowID                        │
│ Payload Data (可能溢出到其他页)      │
└──────────────────────────────────────┘

Varint编码（可变长度整数）:
• 1字节：0-127
• 2字节：128-16,383
• 3字节：16,384-2,097,151
• ...
• 节省空间（小数字用更少字节）

页面分裂算法（插入导致）:
void btree_split_page(Page *page) {
    // 1. 分配新页面
    Page *new_page = allocate_page();

    // 2. 计算分裂点（尽量平均）
    int mid = page->cell_count / 2;

    // 3. 移动后半部分cells到新页
    for (int i = mid; i < page->cell_count; i++) {
        move_cell(page, new_page, i);
    }

    // 4. 更新父页面（添加新页指针）
    insert_into_parent(page->parent, new_page,
                       get_cell_key(new_page, 0));
}

优化技巧:
• 右侧分裂（Rightmost split）: 顺序插入优化
• 平衡分裂（Balanced split）: 随机插入
• 合并（Merge）: 删除后页面利用率<50%
```

---

## 架构对比矩阵

```text
三大开源数据库架构对比
══════════════════════════════════════════════════════════════════════════════

维度 | PostgreSQL | MySQL | SQLite
-----|-----------|-------|-------
并发模型 | 进程 | 线程 | 库（单线程）
MVCC | xmin/xmax | Undo Log | WAL版本链
锁粒度 | 行锁 | 行锁 | 数据库锁
事务隔离 | 4级全支持 | 4级全支持 | 2级
WAL | Write-Ahead Log | Redo Log | WAL (3.7+)
索引类型 | B-Tree/Hash/GIN/GiST | B-Tree/Hash | B-Tree
优化器 | 遗传算法 | Cost-based | Rule-based
连接池 | 需要pgBouncer | 内置 | N/A
扩展性 | 强（插件机制） | 中（存储引擎） | 弱
适用规模 | 10GB-10TB | 10GB-10TB | <2GB
最大优势 | 功能完整 | 易用性能 | 零配置
最大劣势 | 连接开销 | 复制延迟 | 并发限制

进程 vs 线程（深度对比）:
PostgreSQL进程模型:
• 内存隔离（每进程独立内存）
• 崩溃隔离（一个进程崩溃不影响其他）
• fork开销（创建进程10ms）
• 连接限制（200-500典型）

MySQL线程模型:
• 内存共享（所有线程共享Buffer Pool）
• 轻量级（创建线程1ms）
• 更高并发（支持1000+连接）
• 崩溃风险（一个线程错误可能影响全局）

SQLite库模型:
• 无进程/线程（直接函数调用）
• 零开销（无IPC）
• 无网络（文件访问）
• 简单部署（单文件）
```

---

**文档版本**: v1.0
**最后更新**: 2025-12-05
