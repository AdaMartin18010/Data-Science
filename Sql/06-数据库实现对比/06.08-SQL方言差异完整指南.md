# SQL方言差异完整指南

> **创建日期**: 2025-12-04
> **覆盖数据库**: PostgreSQL 18, MySQL 8.4, SQLite 3.47, SQL Server 2022
> **难度**: ⭐⭐⭐⭐

---

## 语法差异总览

### 分页（LIMIT vs FETCH）

```sql
-- PostgreSQL / MySQL / SQLite
SELECT * FROM users ORDER BY id LIMIT 10 OFFSET 20;

-- SQL Server / Oracle (标准SQL:2008)
SELECT * FROM users ORDER BY id
OFFSET 20 ROWS
FETCH NEXT 10 ROWS ONLY;

-- SQL Server 2000+（TOP）
SELECT TOP 10 * FROM users WHERE id > 20 ORDER BY id;
```

### 字符串连接

```sql
-- PostgreSQL / SQLite
SELECT 'Hello' || ' ' || 'World';  -- Hello World

-- MySQL
SELECT CONCAT('Hello', ' ', 'World');  -- Hello World

-- SQL Server
SELECT 'Hello' + ' ' + 'World';  -- Hello World
SELECT CONCAT('Hello', ' ', 'World');  -- SQL Server 2012+
```

### UPSERT（插入或更新）

```sql
-- PostgreSQL
INSERT INTO users (id, name) VALUES (1, 'Alice')
ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;

-- MySQL
INSERT INTO users (id, name) VALUES (1, 'Alice')
ON DUPLICATE KEY UPDATE name = VALUES(name);

-- SQLite
INSERT INTO users (id, name) VALUES (1, 'Alice')
ON CONFLICT (id) DO UPDATE SET name = excluded.name;

-- SQL Server (MERGE)
MERGE INTO users AS target
USING (SELECT 1 AS id, 'Alice' AS name) AS source
ON target.id = source.id
WHEN MATCHED THEN
    UPDATE SET name = source.name
WHEN NOT MATCHED THEN
    INSERT (id, name) VALUES (source.id, source.name);
```

---

## 数据类型差异

### 自增列

```sql
-- PostgreSQL
CREATE TABLE users (
    id SERIAL PRIMARY KEY,  -- 等价于 INTEGER + SEQUENCE
    name TEXT
);

-- 或者使用 IDENTITY（SQL标准）
CREATE TABLE users (
    id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    name TEXT
);

-- MySQL
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100)
);

-- SQLite
CREATE TABLE users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,  -- 或直接 INTEGER PRIMARY KEY
    name TEXT
);

-- SQL Server
CREATE TABLE users (
    id INT IDENTITY(1,1) PRIMARY KEY,  -- 起始值1，步长1
    name NVARCHAR(100)
);
```

### 布尔类型

```sql
-- PostgreSQL
CREATE TABLE settings (
    enabled BOOLEAN DEFAULT TRUE
);
INSERT INTO settings VALUES (TRUE), (FALSE), (NULL);

-- MySQL
CREATE TABLE settings (
    enabled BOOLEAN DEFAULT TRUE  -- 实际存储为 TINYINT(1)
);
INSERT INTO settings VALUES (1), (0), (NULL);  -- TRUE=1, FALSE=0

-- SQLite
CREATE TABLE settings (
    enabled INTEGER CHECK(enabled IN (0, 1))  -- 手动实现
);
INSERT INTO settings VALUES (1), (0), (NULL);

-- SQL Server
CREATE TABLE settings (
    enabled BIT DEFAULT 1  -- BIT类型，0=FALSE, 1=TRUE
);
INSERT INTO settings VALUES (1), (0), (NULL);
```

### 日期时间

```sql
-- PostgreSQL
SELECT CURRENT_TIMESTAMP;  -- 2025-12-04 10:30:45.123456+00
SELECT NOW();              -- 同上
SELECT CURRENT_DATE;       -- 2025-12-04
SELECT CURRENT_TIME;       -- 10:30:45.123456+00

-- MySQL
SELECT CURRENT_TIMESTAMP();  -- 2025-12-04 10:30:45
SELECT NOW();                -- 同上
SELECT CURDATE();            -- 2025-12-04
SELECT CURTIME();            -- 10:30:45

-- SQLite
SELECT CURRENT_TIMESTAMP;  -- 2025-12-04 10:30:45
SELECT datetime('now');    -- 同上
SELECT date('now');        -- 2025-12-04
SELECT time('now');        -- 10:30:45

-- SQL Server
SELECT CURRENT_TIMESTAMP;  -- 2025-12-04 10:30:45.123
SELECT GETDATE();          -- 同上
SELECT SYSDATETIME();      -- 2025-12-04 10:30:45.1234567 (更高精度)
```

---

## 函数差异

### 字符串函数

```sql
-- 字符串长度
-- PostgreSQL / SQLite: LENGTH('Hello')  → 5
-- MySQL / SQL Server: LEN('Hello')  → 5 (SQL Server会trim trailing spaces)
-- MySQL也支持: LENGTH('Hello')  → 5

-- 子字符串
-- PostgreSQL / MySQL / SQLite: SUBSTRING('Hello', 2, 3)  → 'ell'
-- SQL Server: SUBSTRING('Hello', 2, 3)  → 'ell'

-- 大小写转换
-- 通用: UPPER('hello'), LOWER('HELLO')

-- 去除空格
-- PostgreSQL / SQLite: TRIM('  Hello  ')  → 'Hello'
-- MySQL: TRIM('  Hello  ')  → 'Hello'
-- SQL Server: LTRIM(RTRIM('  Hello  '))  → 'Hello'

-- 正则表达式
-- PostgreSQL: 'Hello' ~ 'H.*o'  → TRUE
-- MySQL: 'Hello' REGEXP 'H.*o'  → 1
-- SQLite: REGEXP未内置，需扩展
-- SQL Server: 需使用CLR函数
```

### 日期函数

```sql
-- 日期加减

-- PostgreSQL
SELECT CURRENT_DATE + INTERVAL '1 day';  -- 明天
SELECT CURRENT_TIMESTAMP - INTERVAL '1 hour';  -- 1小时前

-- MySQL
SELECT DATE_ADD(CURRENT_DATE, INTERVAL 1 DAY);  -- 明天
SELECT DATE_SUB(CURRENT_TIMESTAMP, INTERVAL 1 HOUR);  -- 1小时前

-- SQLite
SELECT date('now', '+1 day');  -- 明天
SELECT datetime('now', '-1 hour');  -- 1小时前

-- SQL Server
SELECT DATEADD(day, 1, CURRENT_TIMESTAMP);  -- 明天
SELECT DATEADD(hour, -1, CURRENT_TIMESTAMP);  -- 1小时前

-- 日期差

-- PostgreSQL
SELECT AGE('2025-12-04', '2025-01-01');  -- 11 mons 3 days
SELECT EXTRACT(DAY FROM '2025-12-04'::TIMESTAMP - '2025-01-01'::TIMESTAMP);  -- 天数差

-- MySQL
SELECT DATEDIFF('2025-12-04', '2025-01-01');  -- 337 (天数差)
SELECT TIMESTAMPDIFF(HOUR, '2025-01-01 00:00:00', '2025-12-04 10:00:00');  -- 小时差

-- SQLite
SELECT JULIANDAY('2025-12-04') - JULIANDAY('2025-01-01');  -- 337.0 (天数差)

-- SQL Server
SELECT DATEDIFF(DAY, '2025-01-01', '2025-12-04');  -- 337
```

---

## 事务行为差异

### 默认隔离级别

```text
数据库           | 默认隔离级别
----------------|------------------
PostgreSQL      | READ COMMITTED
MySQL (InnoDB)  | REPEATABLE READ
SQLite          | SERIALIZABLE (WAL模式实际为Snapshot Isolation)
SQL Server      | READ COMMITTED
```

### 自动提交

```sql
-- PostgreSQL: 默认每条语句自动提交（除非在BEGIN...COMMIT块中）
BEGIN;
INSERT INTO users VALUES (1, 'Alice');
COMMIT;

-- MySQL: 默认自动提交
SET autocommit = 0;  -- 禁用自动提交
INSERT INTO users VALUES (1, 'Alice');
COMMIT;

-- SQLite: 默认每条语句自动提交
BEGIN;
INSERT INTO users VALUES (1, 'Alice');
COMMIT;

-- SQL Server: 默认自动提交
BEGIN TRANSACTION;
INSERT INTO users VALUES (1, 'Alice');
COMMIT TRANSACTION;
```

---

## DDL差异

### 修改列

```sql
-- PostgreSQL
ALTER TABLE users ALTER COLUMN name TYPE VARCHAR(200);
ALTER TABLE users ALTER COLUMN name SET DEFAULT 'Unknown';
ALTER TABLE users ALTER COLUMN name DROP DEFAULT;

-- MySQL
ALTER TABLE users MODIFY COLUMN name VARCHAR(200) DEFAULT 'Unknown';
ALTER TABLE users ALTER COLUMN name DROP DEFAULT;

-- SQLite
-- 不支持ALTER COLUMN！需要重建表：
-- 1. 创建新表
-- 2. 复制数据
-- 3. 删除旧表
-- 4. 重命名新表

-- SQL Server
ALTER TABLE users ALTER COLUMN name NVARCHAR(200);
ALTER TABLE users ADD DEFAULT 'Unknown' FOR name;
ALTER TABLE users DROP CONSTRAINT DF_users_name;  -- 删除默认值约束
```

### 修改主键

```sql
-- PostgreSQL
ALTER TABLE users DROP CONSTRAINT users_pkey;
ALTER TABLE users ADD PRIMARY KEY (id);

-- MySQL
ALTER TABLE users DROP PRIMARY KEY;
ALTER TABLE users ADD PRIMARY KEY (id);

-- SQLite
-- 不支持ALTER PRIMARY KEY！需要重建表

-- SQL Server
ALTER TABLE users DROP CONSTRAINT PK_users;
ALTER TABLE users ADD CONSTRAINT PK_users PRIMARY KEY (id);
```

---

## JSON支持差异

### JSON查询

```sql
-- 数据
-- PostgreSQL: JSONB类型
-- MySQL: JSON类型
-- SQLite: TEXT存储
-- SQL Server: NVARCHAR(MAX)

INSERT INTO products (data) VALUES
('{"name": "iPhone", "price": 999, "tags": ["electronics", "phone"]}');

-- 提取JSON字段

-- PostgreSQL
SELECT data->>'name' AS name FROM products;  -- 'iPhone' (文本)
SELECT data->'price' AS price FROM products;  -- 999 (JSONB)
SELECT data->'tags'->>0 AS first_tag FROM products;  -- 'electronics'

-- MySQL
SELECT JSON_EXTRACT(data, '$.name') AS name FROM products;  -- "iPhone" (带引号)
SELECT JSON_UNQUOTE(JSON_EXTRACT(data, '$.name')) AS name FROM products;  -- iPhone
SELECT data->>'$.name' AS name FROM products;  -- MySQL 5.7+ 简写

-- SQLite
SELECT JSON_EXTRACT(data, '$.name') AS name FROM products;  -- 'iPhone'
SELECT data->>'$.name' AS name FROM products;  -- SQLite 3.38+ 简写

-- SQL Server
SELECT JSON_VALUE(data, '$.name') AS name FROM products;  -- iPhone
SELECT JSON_QUERY(data, '$.tags') AS tags FROM products;  -- ["electronics", "phone"]
```

---

## 窗口函数差异

### NULLS FIRST/LAST

```sql
-- PostgreSQL / SQLite (3.30+)
SELECT
    name,
    score,
    RANK() OVER (ORDER BY score DESC NULLS LAST) as rank
FROM users;

-- MySQL (不支持NULLS FIRST/LAST)
-- 变通方法：
SELECT
    name,
    score,
    RANK() OVER (ORDER BY score IS NULL, score DESC) as rank
FROM users;
-- NULL会排在最前（IS NULL = 1）

-- SQL Server (不支持NULLS FIRST/LAST)
-- 同MySQL变通方法
```

### FILTER子句

```sql
-- PostgreSQL
SELECT
    COUNT(*) FILTER (WHERE status = 'active') as active_count,
    COUNT(*) FILTER (WHERE status = 'inactive') as inactive_count
FROM users;

-- MySQL / SQLite / SQL Server (不支持FILTER)
-- 变通方法：
SELECT
    COUNT(CASE WHEN status = 'active' THEN 1 END) as active_count,
    COUNT(CASE WHEN status = 'inactive' THEN 1 END) as inactive_count
FROM users;
```

---

## 迁移兼容性指南

### PostgreSQL → MySQL

```sql
-- 问题1：RETURNING子句
-- PostgreSQL:
INSERT INTO users (name) VALUES ('Alice') RETURNING id;

-- MySQL变通：
INSERT INTO users (name) VALUES ('Alice');
SELECT LAST_INSERT_ID();

-- 问题2：数组类型
-- PostgreSQL:
CREATE TABLE posts (tags TEXT[]);

-- MySQL变通：
CREATE TABLE posts (tags JSON);  -- 或 VARCHAR + 分隔符

-- 问题3：BOOL类型
-- PostgreSQL: BOOLEAN
-- MySQL: TINYINT(1)
```

### MySQL → PostgreSQL

```sql
-- 问题1：AUTO_INCREMENT
-- MySQL:
CREATE TABLE users (id INT AUTO_INCREMENT PRIMARY KEY);

-- PostgreSQL:
CREATE TABLE users (id SERIAL PRIMARY KEY);
-- 或
CREATE TABLE users (id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY);

-- 问题2：反引号标识符
-- MySQL: `table_name`
-- PostgreSQL: "table_name" (双引号)

-- 问题3：LIMIT没有OFFSET
-- MySQL: LIMIT 10, 20  (跳过10，取20)
-- PostgreSQL: LIMIT 20 OFFSET 10
```

---

**文档版本**: v1.0.0
**最后更新**: 2025-12-04
