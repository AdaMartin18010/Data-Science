# SQL事务控制完整指南

> **创建日期**：2025-12-04
> **适用数据库**：PostgreSQL 18 / MySQL 8.4 / SQLite 3.47.x
> **难度**：⭐⭐⭐⭐

---

## 📋 基础语法

### BEGIN/COMMIT/ROLLBACK

```sql
-- 标准事务语法

BEGIN;  -- 或 BEGIN TRANSACTION / START TRANSACTION
    INSERT INTO accounts (id, balance) VALUES (1, 1000);
    UPDATE accounts SET balance = balance - 100 WHERE id = 1;
    UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;  -- 提交

-- 回滚示例
BEGIN;
    UPDATE accounts SET balance = balance - 100 WHERE id = 1;
    -- 发现错误
ROLLBACK;  -- 撤销所有修改
```

### SAVEPOINT（保存点）

```sql
-- PostgreSQL/MySQL支持SAVEPOINT

BEGIN;
    INSERT INTO orders (id, total) VALUES (1, 100);

    SAVEPOINT sp1;  -- 保存点1
    UPDATE orders SET total = 200 WHERE id = 1;

    SAVEPOINT sp2;  -- 保存点2
    DELETE FROM orders WHERE id = 1;

    ROLLBACK TO SAVEPOINT sp2;  -- 回滚到sp2，保留sp1的UPDATE
    -- 现在：order.total = 200

    ROLLBACK TO SAVEPOINT sp1;  -- 回滚到sp1，撤销UPDATE
    -- 现在：order.total = 100

COMMIT;  -- 提交INSERT
```

### 隔离级别

```sql
-- 设置事务隔离级别

-- PostgreSQL
BEGIN ISOLATION LEVEL READ COMMITTED;
BEGIN ISOLATION LEVEL REPEATABLE READ;
BEGIN ISOLATION LEVEL SERIALIZABLE;

-- MySQL
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

-- SQLite（配置式）
PRAGMA read_uncommitted=1;  -- READ UNCOMMITTED
-- 默认：SERIALIZABLE（或WAL模式的Snapshot Isolation）
```

---

## 高级特性

### 两阶段提交（2PC）

```sql
-- PostgreSQL两阶段提交

-- 阶段1：准备
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
PREPARE TRANSACTION 'txn_001';

-- 阶段2a：提交
COMMIT PREPARED 'txn_001';

-- 或阶段2b：回滚
ROLLBACK PREPARED 'txn_001';

-- 查看准备的事务
SELECT * FROM pg_prepared_xacts;

-- 应用场景：分布式事务协调
```

### 事务快照

```sql
-- PostgreSQL事务快照

-- 导出快照
BEGIN ISOLATION LEVEL REPEATABLE READ;
SELECT pg_export_snapshot();
-- 返回: '00000003-00000001-1'

-- 在另一个会话中使用相同快照
BEGIN ISOLATION LEVEL REPEATABLE READ;
SET TRANSACTION SNAPSHOT '00000003-00000001-1';
-- 两个事务看到完全相同的数据视图

-- 应用场景：
-- • 并行数据导出（多进程使用相同快照）
-- • 一致性备份
```

### Advisory Lock（咨询锁）

```sql
-- PostgreSQL咨询锁（应用层分布式锁）

-- 获取锁（阻塞）
SELECT pg_advisory_lock(12345);

-- 获取锁（非阻塞）
SELECT pg_try_advisory_lock(12345);
-- 返回: true（成功）或false（失败）

-- 释放锁
SELECT pg_advisory_unlock(12345);

-- 事务级锁（事务结束自动释放）
SELECT pg_advisory_xact_lock(12345);

-- 应用场景：分布式任务调度
CREATE TABLE scheduled_jobs (
    job_id BIGINT PRIMARY KEY,
    job_name VARCHAR(100),
    status VARCHAR(20),
    next_run_at TIMESTAMPTZ
);

-- 工作进程竞争任务
BEGIN;
    -- 尝试锁定job_id
    SELECT pg_try_advisory_xact_lock(job_id)
    FROM scheduled_jobs
    WHERE status = 'pending'
        AND next_run_at <= NOW()
    ORDER BY next_run_at
    LIMIT 1;

    -- 如果获取到锁，更新状态
    UPDATE scheduled_jobs
    SET status = 'running'
    WHERE job_id = ?;

COMMIT;

-- 只有一个进程能获取到锁并执行任务
```

---

## 事务模式对比

```text
事务模式性能对比
══════════════════════════════════════════════════════════════════════════════

PostgreSQL事务模式：
┌──────────────────┬──────────┬──────────┬────────────────────────┐
│ 隔离级别         │ 并发度   │ 冲突率   │ 适用场景               │
├──────────────────┼──────────┼──────────┼────────────────────────┤
│ READ COMMITTED   │ 最高     │ 低       │ 一般Web应用            │
│ REPEATABLE READ  │ 高       │ 中       │ 报表查询               │
│ SERIALIZABLE(SSI)│ 中       │ 高       │ 金融交易               │
└──────────────────┴──────────┴──────────┴────────────────────────┘

SQLite事务模式：
┌──────────────────┬──────────────────────────────────────────────┐
│ 模式             │ 说明                                         │
├──────────────────┼──────────────────────────────────────────────┤
│ BEGIN DEFERRED   │ 延迟获取锁（默认），遇到写操作时获取锁       │
│ BEGIN IMMEDIATE  │ 立即获取RESERVED锁，推荐写事务使用           │
│ BEGIN EXCLUSIVE  │ 立即获取EXCLUSIVE锁，完全独占                │
└──────────────────┴──────────────────────────────────────────────┘

-- 推荐实践
-- 读事务：BEGIN DEFERRED (默认)
-- 写事务：BEGIN IMMEDIATE（避免锁升级失败）
```

---

## 实战案例

### 银行转账（ACID保证）

```python
def transfer_with_acid(conn, from_account, to_account, amount):
    """银行转账（完整ACID保证）"""
    try:
        conn.execute("BEGIN IMMEDIATE")  # 立即获取写锁

        # 1. 检查源账户余额（加锁）
        cursor = conn.execute("""
            SELECT balance FROM accounts WHERE account_id = ?
        """, (from_account,))

        balance = cursor.fetchone()
        if not balance or balance[0] < amount:
            raise ValueError("余额不足")

        # 2. 扣款
        conn.execute("""
            UPDATE accounts
            SET balance = balance - ?,
                updated_at = CURRENT_TIMESTAMP
            WHERE account_id = ?
        """, (amount, from_account))

        # 3. 入账
        conn.execute("""
            UPDATE accounts
            SET balance = balance + ?,
                updated_at = CURRENT_TIMESTAMP
            WHERE account_id = ?
        """, (amount, to_account))

        # 4. 记录交易日志
        conn.execute("""
            INSERT INTO transactions (from_account, to_account, amount, created_at)
            VALUES (?, ?, ?, CURRENT_TIMESTAMP)
        """, (from_account, to_account, amount))

        # 5. 提交
        conn.commit()
        return True

    except Exception as e:
        conn.rollback()
        print(f"转账失败: {e}")
        return False
```

### 库存扣减（并发控制）

```sql
-- 场景：高并发秒杀

-- 方案1：悲观锁（PostgreSQL）
BEGIN;
SELECT stock FROM products WHERE product_id = 1001 FOR UPDATE;  -- 锁行
-- 检查库存
UPDATE products SET stock = stock - 1 WHERE product_id = 1001;
COMMIT;

-- 方案2：乐观锁
UPDATE products
SET stock = stock - 1, version = version + 1
WHERE product_id = 1001
    AND version = ?  -- 传入的版本号
    AND stock > 0;
-- 检查affected_rows，如果为0则冲突，需重试

-- 方案3：SQL原子操作
UPDATE products
SET stock = stock - 1
WHERE product_id = 1001
    AND stock > 0;
-- 返回affected_rows，0表示库存不足

-- 方案4：Redis + Lua原子脚本（最高性能）
-- EVAL "if redis.call('get', KEYS[1]) > 0 then return redis.call('decr', KEYS[1]) else return nil end" 1 product:1001:stock
```

---

**文档版本**: v1.0.0
**最后更新**: 2025-12-04
