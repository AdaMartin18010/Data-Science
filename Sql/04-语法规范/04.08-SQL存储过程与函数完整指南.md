# SQL存储过程与函数完整指南

> **创建日期**: 2025-12-04
> **适用**: PostgreSQL 18, MySQL 8.4, SQL Server
> **难度**: ⭐⭐⭐⭐

---

## 存储过程 vs 函数

```text
存储过程与函数对比
══════════════════════════════════════════════════════════════════════════════

┌─────────────────┬─────────────────┬─────────────────┐
│ 特性            │ 存储过程        │ 函数            │
├─────────────────┼─────────────────┼─────────────────┤
│ 返回值          │ 可选            │ 必须            │
│ 调用方式        │ CALL/EXECUTE    │ SELECT中使用    │
│ 事务控制        │ 支持COMMIT      │ 不支持          │
│ OUT参数         │ 支持            │ 不支持          │
│ DML操作         │ 支持            │ 限制（部分DB）  │
│ 性能            │ 相同            │ 相同            │
│ 用途            │ 复杂业务逻辑    │ 计算和转换      │
└─────────────────┴─────────────────┴─────────────────┘
```

---

## PostgreSQL存储过程

### 基础语法

```sql
-- 创建存储过程
CREATE OR REPLACE PROCEDURE procedure_name(
    param1 type1,
    param2 type2,
    OUT result_param type3
)
LANGUAGE plpgsql
AS $$
DECLARE
    -- 变量声明
    local_var INTEGER;
BEGIN
    -- 逻辑
    result_param := some_value;

    -- 事务控制
    COMMIT;
END;
$$;

-- 调用
CALL procedure_name(arg1, arg2, NULL);
```

### 实战案例1：订单创建（带库存扣减）

```sql
CREATE OR REPLACE PROCEDURE create_order_with_inventory(
    p_user_id BIGINT,
    p_product_id BIGINT,
    p_quantity INTEGER,
    OUT p_order_id BIGINT,
    OUT p_success BOOLEAN,
    OUT p_message TEXT
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_stock INTEGER;
    v_price DECIMAL(10, 2);
    v_order_no TEXT;
BEGIN
    -- 初始化
    p_success := FALSE;
    p_order_id := NULL;

    -- 1. 检查库存（FOR UPDATE锁）
    SELECT stock, price INTO v_stock, v_price
    FROM products
    WHERE id = p_product_id
    FOR UPDATE;

    IF v_stock IS NULL THEN
        p_message := '产品不存在';
        RETURN;
    END IF;

    IF v_stock < p_quantity THEN
        p_message := '库存不足';
        RETURN;
    END IF;

    -- 2. 扣减库存
    UPDATE products
    SET stock = stock - p_quantity,
        updated_at = CURRENT_TIMESTAMP
    WHERE id = p_product_id;

    -- 3. 生成订单号
    v_order_no := 'ORD' || TO_CHAR(CURRENT_TIMESTAMP, 'YYYYMMDDHH24MISS') ||
                  LPAD(nextval('order_no_seq')::TEXT, 6, '0');

    -- 4. 创建订单
    INSERT INTO orders (user_id, order_no, total_amount, status, created_at)
    VALUES (p_user_id, v_order_no, v_price * p_quantity, 'pending', CURRENT_TIMESTAMP)
    RETURNING id INTO p_order_id;

    -- 5. 创建订单项
    INSERT INTO order_items (order_id, product_id, quantity, price)
    VALUES (p_order_id, p_product_id, p_quantity, v_price);

    -- 6. 提交
    COMMIT;

    p_success := TRUE;
    p_message := '订单创建成功';

EXCEPTION
    WHEN OTHERS THEN
        -- 回滚由PostgreSQL自动处理
        p_message := SQLERRM;
        RAISE NOTICE '订单创建失败: %', SQLERRM;
END;
$$;

-- 调用
DO $$
DECLARE
    v_order_id BIGINT;
    v_success BOOLEAN;
    v_message TEXT;
BEGIN
    CALL create_order_with_inventory(
        p_user_id := 123,
        p_product_id := 456,
        p_quantity := 2,
        p_order_id := v_order_id,
        p_success := v_success,
        p_message := v_message
    );

    RAISE NOTICE '结果: success=%, order_id=%, message=%', v_success, v_order_id, v_message;
END;
$$;
```

### 实战案例2：数据归档（批量处理）

```sql
CREATE OR REPLACE PROCEDURE archive_old_orders(
    p_days_ago INTEGER DEFAULT 365,
    OUT p_archived_count INTEGER
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_cutoff_date TIMESTAMP;
    v_batch_size INTEGER := 1000;
    v_affected INTEGER;
BEGIN
    p_archived_count := 0;
    v_cutoff_date := CURRENT_TIMESTAMP - (p_days_ago || ' days')::INTERVAL;

    RAISE NOTICE '归档日期早于: %', v_cutoff_date;

    -- 批量处理（避免长事务）
    LOOP
        -- 1. 复制到归档表
        INSERT INTO orders_archive
        SELECT * FROM orders
        WHERE created_at < v_cutoff_date
            AND status = 'completed'
        LIMIT v_batch_size;

        GET DIAGNOSTICS v_affected = ROW_COUNT;

        IF v_affected = 0 THEN
            EXIT;  -- 没有更多数据
        END IF;

        -- 2. 删除原表数据
        DELETE FROM orders
        WHERE id IN (
            SELECT id FROM orders
            WHERE created_at < v_cutoff_date
                AND status = 'completed'
            LIMIT v_batch_size
        );

        p_archived_count := p_archived_count + v_affected;

        -- 3. 提交（分批提交）
        COMMIT;

        RAISE NOTICE '已归档: % 条记录', p_archived_count;

        -- 4. 短暂休眠（降低负载）
        PERFORM pg_sleep(0.1);
    END LOOP;

    RAISE NOTICE '归档完成，总计: % 条记录', p_archived_count;
END;
$$;

-- 调用
CALL archive_old_orders(365);
```

---

## PostgreSQL函数

### 标量函数

```sql
-- 计算距离（Haversine公式）
CREATE OR REPLACE FUNCTION calculate_distance(
    lat1 DOUBLE PRECISION,
    lon1 DOUBLE PRECISION,
    lat2 DOUBLE PRECISION,
    lon2 DOUBLE PRECISION
)
RETURNS DOUBLE PRECISION
LANGUAGE plpgsql
IMMUTABLE  -- 相同输入总是相同输出（优化器可缓存）
AS $$
DECLARE
    r DOUBLE PRECISION := 6371;  -- 地球半径(km)
    dlat DOUBLE PRECISION;
    dlon DOUBLE PRECISION;
    a DOUBLE PRECISION;
    c DOUBLE PRECISION;
BEGIN
    dlat := radians(lat2 - lat1);
    dlon := radians(lon2 - lon1);

    a := sin(dlat/2)^2 + cos(radians(lat1)) * cos(radians(lat2)) * sin(dlon/2)^2;
    c := 2 * asin(sqrt(a));

    RETURN r * c;
END;
$$;

-- 使用
SELECT
    id,
    name,
    calculate_distance(40.7128, -74.0060, latitude, longitude) as distance_km
FROM stores
WHERE calculate_distance(40.7128, -74.0060, latitude, longitude) < 10
ORDER BY distance_km;
```

### 表函数（返回表）

```sql
-- 获取用户最近N个订单
CREATE OR REPLACE FUNCTION get_user_recent_orders(
    p_user_id BIGINT,
    p_limit INTEGER DEFAULT 10
)
RETURNS TABLE (
    order_id BIGINT,
    order_no TEXT,
    total_amount DECIMAL(10, 2),
    status TEXT,
    created_at TIMESTAMP
)
LANGUAGE plpgsql
STABLE  -- 同一事务内相同输入相同输出
AS $$
BEGIN
    RETURN QUERY
    SELECT
        o.id,
        o.order_no,
        o.total_amount,
        o.status,
        o.created_at
    FROM orders o
    WHERE o.user_id = p_user_id
    ORDER BY o.created_at DESC
    LIMIT p_limit;
END;
$$;

-- 使用
SELECT * FROM get_user_recent_orders(123, 5);

-- 或作为子查询
SELECT
    u.username,
    r.order_no,
    r.total_amount
FROM users u
CROSS JOIN LATERAL get_user_recent_orders(u.id, 3) r;
```

### 聚合函数（自定义）

```sql
-- 中位数聚合函数（PostgreSQL 9.4+内置了percentile_cont）
-- 这里展示自定义聚合的原理

-- 1. 状态转换函数
CREATE OR REPLACE FUNCTION median_transfn(
    state DOUBLE PRECISION[],
    value DOUBLE PRECISION
)
RETURNS DOUBLE PRECISION[]
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN array_append(state, value);
END;
$$;

-- 2. 最终计算函数
CREATE OR REPLACE FUNCTION median_finalfn(
    state DOUBLE PRECISION[]
)
RETURNS DOUBLE PRECISION
LANGUAGE plpgsql
AS $$
DECLARE
    sorted DOUBLE PRECISION[];
    len INTEGER;
BEGIN
    IF array_length(state, 1) IS NULL THEN
        RETURN NULL;
    END IF;

    sorted := ARRAY(SELECT unnest(state) ORDER BY 1);
    len := array_length(sorted, 1);

    IF len % 2 = 1 THEN
        RETURN sorted[(len + 1) / 2];
    ELSE
        RETURN (sorted[len / 2] + sorted[len / 2 + 1]) / 2;
    END IF;
END;
$$;

-- 3. 创建聚合
CREATE AGGREGATE median(DOUBLE PRECISION) (
    SFUNC = median_transfn,
    STYPE = DOUBLE PRECISION[],
    FINALFUNC = median_finalfn,
    INITCOND = '{}'
);

-- 使用
SELECT
    category,
    AVG(price) as avg_price,
    median(price) as median_price
FROM products
GROUP BY category;
```

---

## MySQL存储过程

### 基础语法

```sql
DELIMITER $$

CREATE PROCEDURE procedure_name(
    IN param1 INT,
    OUT param2 VARCHAR(100),
    INOUT param3 DECIMAL(10, 2)
)
BEGIN
    DECLARE local_var INT DEFAULT 0;

    -- 逻辑
    SET param2 = 'Result';
    SET param3 = param3 * 1.1;

    -- 事务控制
    START TRANSACTION;
    -- ... DML操作
    COMMIT;
END$$

DELIMITER ;

-- 调用
CALL procedure_name(123, @result, @value);
SELECT @result, @value;
```

### 实战案例：分页存储过程

```sql
DELIMITER $$

CREATE PROCEDURE get_orders_paginated(
    IN p_user_id BIGINT,
    IN p_page INT,
    IN p_page_size INT,
    OUT p_total INT
)
BEGIN
    DECLARE v_offset INT;

    -- 计算偏移
    SET v_offset = (p_page - 1) * p_page_size;

    -- 获取总数
    SELECT COUNT(*) INTO p_total
    FROM orders
    WHERE user_id = p_user_id;

    -- 查询分页数据
    SELECT
        id,
        order_no,
        total_amount,
        status,
        created_at
    FROM orders
    WHERE user_id = p_user_id
    ORDER BY created_at DESC
    LIMIT v_offset, p_page_size;
END$$

DELIMITER ;

-- 调用
CALL get_orders_paginated(123, 1, 10, @total);
SELECT @total AS total_count;
```

### 控制流语句

```sql
DELIMITER $$

CREATE PROCEDURE order_status_handler(
    IN p_order_id BIGINT
)
BEGIN
    DECLARE v_status VARCHAR(20);
    DECLARE v_days_ago INT;

    -- 获取订单状态
    SELECT status, DATEDIFF(CURRENT_DATE, created_at) INTO v_status, v_days_ago
    FROM orders
    WHERE id = p_order_id;

    -- IF-ELSEIF-ELSE
    IF v_status = 'pending' THEN
        IF v_days_ago > 7 THEN
            UPDATE orders SET status = 'cancelled' WHERE id = p_order_id;
            SELECT 'Order cancelled (timeout)' AS result;
        ELSE
            SELECT 'Order pending' AS result;
        END IF;
    ELSEIF v_status = 'paid' THEN
        SELECT 'Order paid' AS result;
    ELSE
        SELECT 'Unknown status' AS result;
    END IF;

    -- CASE语句
    CASE v_status
        WHEN 'pending' THEN
            INSERT INTO notifications (order_id, message) VALUES (p_order_id, 'Payment reminder');
        WHEN 'shipped' THEN
            INSERT INTO notifications (order_id, message) VALUES (p_order_id, 'Shipped notification');
        ELSE
            BEGIN END;  -- 空操作
    END CASE;
END$$

DELIMITER ;
```

### 游标（Cursor）

```sql
DELIMITER $$

CREATE PROCEDURE process_pending_orders()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE v_order_id BIGINT;
    DECLARE v_total_amount DECIMAL(10, 2);

    -- 声明游标
    DECLARE order_cursor CURSOR FOR
        SELECT id, total_amount
        FROM orders
        WHERE status = 'pending'
            AND created_at < DATE_SUB(NOW(), INTERVAL 7 DAY);

    -- 声明结束处理
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;

    -- 打开游标
    OPEN order_cursor;

    read_loop: LOOP
        -- 读取数据
        FETCH order_cursor INTO v_order_id, v_total_amount;

        IF done THEN
            LEAVE read_loop;
        END IF;

        -- 处理逻辑
        UPDATE orders
        SET status = 'cancelled',
            updated_at = NOW()
        WHERE id = v_order_id;

        -- 记录日志
        INSERT INTO order_logs (order_id, action, message)
        VALUES (v_order_id, 'auto_cancel', 'Cancelled due to timeout');
    END LOOP;

    -- 关闭游标
    CLOSE order_cursor;

    SELECT ROW_COUNT() AS cancelled_count;
END$$

DELIMITER ;
```

---

## 性能优化建议

### 1. 避免游标（使用集合操作）

```sql
-- ❌ 慢：使用游标
DELIMITER $$
CREATE PROCEDURE update_with_cursor()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE v_id INT;
    DECLARE cur CURSOR FOR SELECT id FROM users;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;

    OPEN cur;
    LOOP
        FETCH cur INTO v_id;
        IF done THEN LEAVE; END IF;
        UPDATE users SET processed = 1 WHERE id = v_id;
    END LOOP;
    CLOSE cur;
END$$
DELIMITER ;

-- ✅ 快：直接UPDATE
UPDATE users SET processed = 1;
```

### 2. 批量处理

```sql
-- ✅ 分批处理大量数据
CREATE PROCEDURE batch_delete_old_data()
BEGIN
    DECLARE v_affected INT DEFAULT 1;

    WHILE v_affected > 0 DO
        DELETE FROM logs
        WHERE created_at < DATE_SUB(NOW(), INTERVAL 1 YEAR)
        LIMIT 10000;

        SET v_affected = ROW_COUNT();

        -- 短暂休眠
        DO SLEEP(0.1);
    END WHILE;
END;
```

### 3. 使用预编译语句

```sql
-- ✅ 预编译（适合循环中多次执行）
PREPARE stmt FROM 'INSERT INTO logs (user_id, action) VALUES (?, ?)';
SET @user_id = 123;
SET @action = 'login';
EXECUTE stmt USING @user_id, @action;
DEALLOCATE PREPARE stmt;
```

---

**文档版本**: v1.0.0
**最后更新**: 2025-12-04
