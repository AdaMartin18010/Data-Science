# SQL技术决策树完整集

> **创建日期**: 2025-12-05
> **版本**: v1.0
> **用途**: 提供系统化的技术决策指导

---

## 决策树1：数据库选型

```text
数据库选型决策树
══════════════════════════════════════════════════════════════════════════════

问题: 选择哪个数据库？
    │
    ├─ 应用类型？
    │   ├─ 嵌入式/移动应用 → SQLite
    │   │   └─ 验证：数据量<2GB? ✓→SQLite ✗→评估其他
    │   │
    │   ├─ Web应用 → 继续评估
    │   │
    │   ├─ 企业应用 → PostgreSQL/Oracle
    │   │
    │   └─ 实时分析 → ClickHouse/Druid
    │
    ├─ 数据量级？
    │   ├─ <10GB → SQLite/PostgreSQL/MySQL
    │   ├─ 10GB-1TB → PostgreSQL/MySQL
    │   ├─ 1TB-10TB → 分片PostgreSQL/TiDB
    │   └─ >10TB → CockroachDB/Spanner/Cassandra
    │
    ├─ 并发需求？
    │   ├─ <100 并发 → SQLite/PostgreSQL
    │   ├─ 100-10K 并发 → PostgreSQL/MySQL
    │   ├─ 10K-100K 并发 → 集群方案
    │   └─ >100K 并发 → 分布式数据库
    │
    ├─ 事务复杂度？
    │   ├─ 简单CRUD → MySQL/SQLite
    │   ├─ 复杂事务 → PostgreSQL
    │   ├─ 分布式事务 → CockroachDB/TiDB
    │   └─ 无事务需求 → NoSQL
    │
    ├─ 数据模型？
    │   ├─ 纯关系型 → PostgreSQL/MySQL
    │   ├─ 关系+文档 → PostgreSQL (JSONB)
    │   ├─ 文档模型 → MongoDB
    │   ├─ 图模型 → Neo4j
    │   ├─ 键值 → Redis
    │   └─ 列式 → ClickHouse
    │
    ├─ 查询模式？
    │   ├─ OLTP (事务) → PostgreSQL/MySQL
    │   ├─ OLAP (分析) → ClickHouse/Greenplum
    │   ├─ HTAP (混合) → TiDB/CockroachDB
    │   └─ 时序数据 → TimescaleDB/InfluxDB
    │
    ├─ 部署环境？
    │   ├─ 本地服务器 → PostgreSQL/MySQL
    │   ├─ 云环境 → RDS/Aurora
    │   ├─ 边缘设备 → SQLite
    │   └─ Serverless → DynamoDB/FaunaDB
    │
    ├─ 一致性要求？
    │   ├─ 强一致 → PostgreSQL/MySQL
    │   ├─ 最终一致 → Cassandra/DynamoDB
    │   └─ 因果一致 → MongoDB
    │
    ├─ 可用性要求？
    │   ├─ 99.9% (3个9) → 单主复制
    │   ├─ 99.99% (4个9) → 多AZ部署
    │   └─ 99.999% (5个9) → 多区域复制
    │
    ├─ 预算限制？
    │   ├─ 开源优先 → PostgreSQL/MySQL/SQLite
    │   ├─ 商业支持 → Oracle/SQL Server
    │   └─ 云托管 → RDS/Cloud SQL
    │
    └─ 团队技能？
        ├─ PostgreSQL经验 → PostgreSQL
        ├─ MySQL经验 → MySQL
        ├─ NoSQL经验 → MongoDB/Cassandra
        └─ 通用SQL → PostgreSQL (功能最全)

推荐矩阵:
场景 | 首选 | 次选 | 避免
-----|-----|-----|-----
移动App | SQLite | Realm | PostgreSQL
小型Web | PostgreSQL | MySQL | Oracle
大型Web | PostgreSQL集群 | MySQL分片 | SQLite
电商 | PostgreSQL | MySQL | MongoDB
社交网络 | Cassandra | MongoDB | SQLite
实时分析 | ClickHouse | Druid | MySQL
IoT | TimescaleDB | InfluxDB | Oracle
金融交易 | PostgreSQL | Oracle | NoSQL
```

---

## 决策树2：索引策略选择

```text
索引设计决策树
══════════════════════════════════════════════════════════════════════════════

问题: 是否需要索引？
    │
    ├─ 表大小？
    │   ├─ <1000行 → 不需要（全表扫描更快）
    │   ├─ 1000-10万行 → 可选
    │   └─ >10万行 → 强烈推荐
    │
    └─ 查询频率？
        ├─ 很少查询 → 不需要
        ├─ 频繁查询 → 继续评估
        └─ 热点查询 → 必须

问题: 创建什么类型的索引？
    │
    ├─ 查询模式？
    │   ├─ 等值查询 (WHERE col = ?)
    │   │   ├─ 高选择性 → B-Tree索引
    │   │   ├─ 低选择性 → Hash索引 (PostgreSQL)
    │   │   └─ 极低选择性 (<5% unique) → 部分索引
    │   │
    │   ├─ 范围查询 (WHERE col BETWEEN ? AND ?)
    │   │   └─ B-Tree索引
    │   │
    │   ├─ 前缀查询 (WHERE col LIKE 'abc%')
    │   │   └─ B-Tree索引
    │   │
    │   ├─ 全文搜索 (WHERE col LIKE '%keyword%')
    │   │   ├─ PostgreSQL → GIN索引 + tsvector
    │   │   ├─ MySQL → FULLTEXT索引
    │   │   └─ SQLite → FTS5扩展
    │   │
    │   ├─ JSON查询 (WHERE json_col->>'key' = ?)
    │   │   ├─ PostgreSQL → GIN索引 (jsonb_ops)
    │   │   └─ MySQL → 虚拟列 + B-Tree
    │   │
    │   ├─ 数组查询 (WHERE ? = ANY(array_col))
    │   │   └─ PostgreSQL → GIN索引
    │   │
    │   └─ 地理查询 (WHERE ST_DWithin(geom, ?, ?))
    │       ├─ PostgreSQL → GiST索引
    │       └─ MySQL → Spatial索引
    │
    ├─ 多列查询？
    │   ├─ AND条件 (WHERE a=? AND b=? AND c=?)
    │   │   ├─ 创建复合索引 (a, b, c)
    │   │   ├─ 列顺序：等值→范围→排序
    │   │   └─ 示例：WHERE a=1 AND b>10 ORDER BY c
    │   │       → INDEX(a, b, c)
    │   │
    │   ├─ OR条件 (WHERE a=? OR b=?)
    │   │   ├─ 方案1：两个单列索引 + Bitmap Scan
    │   │   └─ 方案2：改写为UNION
    │   │
    │   └─ 混合条件
    │       └─ 分析最常用的列组合
    │
    ├─ ORDER BY需求？
    │   ├─ 单列排序 → 索引该列
    │   ├─ 多列排序 → 复合索引（保持顺序）
    │   ├─ DESC排序 → PostgreSQL支持DESC索引
    │   └─ NULLS FIRST/LAST → 部分DB支持
    │
    ├─ 覆盖索引优化？
    │   ├─ 查询只访问索引列？
    │   │   ├─ ✓ → INCLUDE额外列（PostgreSQL 11+）
    │   │   │     CREATE INDEX idx ON t(a) INCLUDE (b, c);
    │   │   └─ ✗ → 普通索引
    │   │
    │   └─ 权衡：索引大小 vs 回表开销
    │
    ├─ 部分索引？
    │   ├─ 热数据查询？
    │   │   └─ 示例：WHERE status='active'（只占10%）
    │   │       CREATE INDEX idx ON t(id) WHERE status='active';
    │   │
    │   └─ 优势：索引小90%，查询同样快
    │
    ├─ 表达式索引？
    │   ├─ 函数包裹列？
    │   │   └─ 示例：WHERE LOWER(email) = ?
    │   │       CREATE INDEX idx ON t(LOWER(email));
    │   │
    │   └─ 计算列？
    │       └─ 示例：WHERE a + b > 100
    │           CREATE INDEX idx ON t((a + b));
    │
    └─ 唯一索引？
        ├─ 业务唯一性？
        │   └─ CREATE UNIQUE INDEX idx ON t(email);
        │
        └─ 复合唯一？
            └─ CREATE UNIQUE INDEX idx ON t(user_id, date);

索引数量权衡:
    ├─ 读多写少 → 可以多个索引（3-5个）
    ├─ 读写均衡 → 精选索引（2-3个）
    └─ 写多读少 → 最小化索引（1-2个）

维护成本:
    每个索引:
    ├─ INSERT性能 -10%
    ├─ UPDATE性能 -5%（如果更新索引列）
    ├─ DELETE性能 -5%
    └─ 存储空间 +10-30%
```

---

## 决策树3：查询优化策略

```text
查询优化决策树
══════════════════════════════════════════════════════════════════════════════

问题: 查询慢（>1秒）？
    │
    ├─ Step 1: 获取EXPLAIN ANALYZE
    │   └─ 识别瓶颈节点
    │
    ├─ 瓶颈类型？
    │   │
    │   ├─ Sequential Scan（全表扫描）
    │   │   ├─ 原因1：缺少索引
    │   │   │   └─ 解决：CREATE INDEX
    │   │   │
    │   │   ├─ 原因2：索引失效
    │   │   │   ├─ 函数包裹 → 表达式索引
    │   │   │   ├─ 类型不匹配 → 修正类型
    │   │   │   ├─ OR条件 → 改写或Bitmap Scan
    │   │   │   └─ LIKE '%...' → 全文索引
    │   │   │
    │   │   ├─ 原因3：选择性太低
    │   │   │   └─ 解决：部分索引 或 接受Seq Scan
    │   │   │
    │   │   └─ 原因4：表太小(<1000行)
    │   │       └─ 正常，Seq Scan更快
    │   │
    │   ├─ Nested Loop Join慢
    │   │   ├─ 原因1：内表无索引
    │   │   │   └─ 解决：在JOIN列创建索引
    │   │   │
    │   │   ├─ 原因2：JOIN顺序不对
    │   │   │   └─ 解决：小表在外，大表在内
    │   │   │
    │   │   └─ 原因3：JOIN类型不对
    │   │       └─ 考虑：Hash Join 或 Sort-Merge Join
    │   │
    │   ├─ Sort操作慢
    │   │   ├─ 原因：ORDER BY列无索引
    │   │   │   └─ 解决：创建索引
    │   │   │
    │   │   └─ 原因：work_mem不足
    │   │       └─ 解决：增加work_mem
    │   │
    │   ├─ Aggregate慢
    │   │   ├─ 优化1：GROUP BY列添加索引
    │   │   ├─ 优化2：使用物化视图
    │   │   └─ 优化3：增量聚合（流式）
    │   │
    │   └─ 子查询慢
    │       ├─ 相关子查询 → 改写为JOIN
    │       ├─ IN子查询 → 自动优化为Semi Join
    │       └─ EXISTS子查询 → 通常高效
    │
    ├─ 返回行数过多（>10万行）
    │   ├─ 需要全部数据？
    │   │   ├─ ✓ → 分批查询（游标/Keyset分页）
    │   │   └─ ✗ → 添加LIMIT
    │   │
    │   └─ JOIN导致行数爆炸？
    │       ├─ 检查JOIN条件（防止笛卡尔积）
    │       └─ 考虑EXISTS代替JOIN
    │
    ├─ 统计信息过时？
    │   └─ 执行：ANALYZE table_name;
    │
    ├─ 锁等待？
    │   ├─ 检查：pg_stat_activity (PostgreSQL)
    │   ├─ 解决：缩小事务范围
    │   └─ 解决：调整隔离级别
    │
    └─ 缓存未命中？
        ├─ 增加：shared_buffers (PostgreSQL)
        ├─ 增加：innodb_buffer_pool_size (MySQL)
        └─ 使用：应用层缓存（Redis）

优化优先级（由高到低）:
1. 添加缺失索引（10-100倍提升）
2. 修复索引失效（2-10倍提升）
3. 改写查询（2-5倍提升）
4. 调整JOIN顺序（1.5-3倍提升）
5. 增加缓存（1.2-2倍提升）
6. 调整配置参数（1.1-1.5倍提升）
```

---

## 决策树4：事务隔离级别选择

```text
事务隔离级别决策树
══════════════════════════════════════════════════════════════════════════════

问题: 选择哪个隔离级别？
    │
    ├─ 并发异常容忍度？
    │   │
    │   ├─ 不能容忍任何异常 → SERIALIZABLE
    │   │   ├─ 优点：完全隔离
    │   │   ├─ 缺点：性能最差，可能失败
    │   │   └─ 适用：金融交易、库存管理
    │   │
    │   ├─ 可容忍写偏序 → REPEATABLE READ
    │   │   ├─ 优点：防止脏读、不可重复读、幻读
    │   │   ├─ 缺点：仍有写偏序风险
    │   │   ├─ 数据库：MySQL默认
    │   │   └─ 适用：报表查询、数据分析
    │   │
    │   ├─ 可容忍幻读 → READ COMMITTED
    │   │   ├─ 优点：性能好，并发高
    │   │   ├─ 缺点：同一事务内读取可能不一致
    │   │   ├─ 数据库：PostgreSQL/Oracle默认
    │   │   └─ 适用：大多数Web应用
    │   │
    │   └─ 可容忍脏读 → READ UNCOMMITTED
    │       ├─ 优点：性能最好
    │       ├─ 缺点：读到未提交数据
    │       └─ 适用：非关键数据统计
    │
    ├─ 性能要求？
    │   ├─ 极致性能 → READ UNCOMMITTED
    │   ├─ 高性能 → READ COMMITTED
    │   ├─ 平衡 → REPEATABLE READ
    │   └─ 一致性优先 → SERIALIZABLE
    │
    ├─ 并发写冲突？
    │   ├─ 高并发写入同一行
    │   │   ├─ SERIALIZABLE → 大量失败
    │   │   ├─ REPEATABLE READ → 较多失败
    │   │   └─ READ COMMITTED → 较少失败
    │   │
    │   └─ 写入不同行
    │       └─ 任何级别都OK
    │
    ├─ 长事务？
    │   ├─ 秒级事务 → 任何级别
    │   ├─ 分钟级事务 → 避免SERIALIZABLE
    │   └─ 小时级事务 → READ COMMITTED only
    │
    └─ 特殊需求？
        ├─ 需要可重复读单行
        │   └─ SELECT ... FOR UPDATE
        │
        ├─ 需要防止其他事务插入
        │   └─ SELECT ... FOR UPDATE
        │       + 范围锁（PostgreSQL）
        │
        └─ 需要跨行约束（如总和>0）
            └─ SERIALIZABLE
                或 应用层检测
                或 触发器检查

数据库默认值:
├─ PostgreSQL → READ COMMITTED
├─ MySQL (InnoDB) → REPEATABLE READ
├─ Oracle → READ COMMITTED
├─ SQL Server → READ COMMITTED
└─ SQLite → SERIALIZABLE (实际SI)

推荐矩阵:
场景 | 推荐隔离级别 | 理由
-----|------------|-----
Web CRUD | READ COMMITTED | 性能与一致性平衡
报表查询 | REPEATABLE READ | 防止读取不一致
金融转账 | SERIALIZABLE | 绝对一致性
库存扣减 | SERIALIZABLE | 防止超卖
社交点赞 | READ UNCOMMITTED | 性能优先
数据统计 | READ COMMITTED | 近似值可接受
批处理 | READ COMMITTED | 处理速度优先
```

---

## 决策树5：分区策略选择

```text
表分区决策树
══════════════════════════════════════════════════════════════════════════════

问题: 是否需要分区？
    │
    ├─ 表大小？
    │   ├─ <10GB → 不需要
    │   ├─ 10-100GB → 可选
    │   └─ >100GB → 强烈推荐
    │
    ├─ 查询模式？
    │   ├─ 总是扫描全表 → 不需要
    │   ├─ 查询特定时间范围 → 需要（时间分区）
    │   ├─ 查询特定地区 → 需要（地区分区）
    │   └─ 查询特定类别 → 需要（列表分区）
    │
    └─ 数据管理？
        ├─ 需要定期删除旧数据 → 需要
        ├─ 需要归档历史数据 → 需要
        └─ 数据生命周期管理 → 需要

问题: 选择哪种分区方式？
    │
    ├─ 时间范围分区（RANGE）
    │   ├─ 适用：时序数据、日志、订单
    │   ├─ 分区键：created_at, date
    │   ├─ 示例：按月分区
    │   │   CREATE TABLE orders_2025_01
    │   │   PARTITION OF orders
    │   │   FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');
    │   │
    │   └─ 优势：
    │       ├─ 快速删除旧分区（DROP PARTITION）
    │       ├─ 查询自动剪枝（Partition Pruning）
    │       └─ 维护独立（VACUUM per partition）
    │
    ├─ 列表分区（LIST）
    │   ├─ 适用：地区、类别、状态
    │   ├─ 分区键：region, category
    │   ├─ 示例：按地区分区
    │   │   CREATE TABLE users_asia
    │   │   PARTITION OF users
    │   │   FOR VALUES IN ('CN', 'JP', 'KR');
    │   │
    │   └─ 优势：
    │       ├─ 地理数据隔离
    │       └─ 合规要求（GDPR）
    │
    ├─ 哈希分区（HASH）
    │   ├─ 适用：均匀分布数据
    │   ├─ 分区键：id, hash_key
    │   ├─ 示例：按ID哈希分区
    │   │   CREATE TABLE orders_h0
    │   │   PARTITION OF orders
    │   │   FOR VALUES WITH (MODULUS 4, REMAINDER 0);
    │   │
    │   └─ 优势：
    │       ├─ 自动负载均衡
    │       └─ 并行查询
    │
    └─ 复合分区（多级）
        ├─ 示例：先按月，再按地区
        ├─ 第1级：RANGE (date)
        └─ 第2级：LIST (region)

分区数量建议:
├─ 总数据<100GB → 12个分区（按月）
├─ 100GB-1TB → 36个分区（按月×3年）
├─ 1TB-10TB → 120个分区（按月×10年）
└─ >10TB → 考虑分片（Sharding）

维护策略:
├─ 自动创建新分区（定时任务）
├─ 定期归档旧分区（ALTER TABLE DETACH）
├─ 监控分区大小（避免倾斜）
└─ 定期重建索引（per partition）
```

---

**文档版本**: v1.0
**最后更新**: 2025-12-05
**决策树数量**: 5个核心决策树
**覆盖场景**: 选型/索引/优化/隔离/分区
