# 决策推理规则库

> **创建日期**：2025-12-01
> **最后更新**：2025-12-01
> **版本**：v1.0.0
> **目的**：为SQL技术决策建立形式化推理框架

---

## 📋 目录

- [决策推理规则库](#决策推理规则库)
  - [📋 目录](#-目录)
  - [一、规则库概述](#一规则库概述)
    - [1.1 规则格式](#11-规则格式)
  - [二、数据库选型决策](#二数据库选型决策)
    - [2.1 OLTP vs OLAP](#21-oltp-vs-olap)
    - [2.2 关系型 vs NoSQL](#22-关系型-vs-nosql)
    - [2.3 向量数据库选型](#23-向量数据库选型)
  - [三、索引策略决策](#三索引策略决策)
    - [3.1 索引类型选择](#31-索引类型选择)
    - [3.2 复合索引设计](#32-复合索引设计)
  - [四、范式选择决策](#四范式选择决策)
  - [五、查询优化决策](#五查询优化决策)
    - [5.1 等价变换决策](#51-等价变换决策)
    - [5.2 访问路径决策](#52-访问路径决策)
  - [六、事务隔离级别决策](#六事务隔离级别决策)
  - [七、连接算法决策](#七连接算法决策)
  - [相关资源](#相关资源)

---

## 一、规则库概述

### 1.1 规则格式

```text
Rule: [规则名称]
───────────────────────────────────────────
Premises (前提条件):
  P1: 条件1
  P2: 条件2
  ...

Conclusion (结论):
  C: 推荐决策

Proof (证明/推理):
  1. 由P1得...
  2. 由P2和步骤1得...
  3. 因此C成立

Confidence: 必然/高/中/低
Trade-off: 权衡说明
Counter-example: 反例条件
```

---

## 二、数据库选型决策

### 2.1 OLTP vs OLAP

```text
Rule: OLTP数据库选型
───────────────────────────────────────────
Premises:
  P1: 事务处理为主（读写均衡）
  P2: 需要强ACID保证
  P3: 单行/小批量操作为主
  P4: 低延迟要求(<100ms)

Conclusion:
  C: 选择OLTP数据库（PostgreSQL/MySQL/SQL Server）

Proof:
  1. P1+P3 → 需要行级锁和高并发支持
  2. P2 → 需要完整事务支持
  3. P4 → 需要优化的索引和缓存
  4. OLTP数据库设计满足1-3

Confidence: 高
Trade-off: 分析查询性能较差

───────────────────────────────────────────

Rule: OLAP数据库选型
───────────────────────────────────────────
Premises:
  P1: 分析查询为主（读远多于写）
  P2: 大范围聚合扫描
  P3: 批量数据加载
  P4: 可接受最终一致性

Conclusion:
  C: 选择OLAP数据库（ClickHouse/DuckDB/BigQuery）

Proof:
  1. P1+P2 → 需要列式存储和向量化执行
  2. P3 → 需要批量加载优化
  3. P4 → 可放松事务要求
  4. OLAP数据库设计满足1-3

Confidence: 高
Trade-off: OLTP操作性能差
```

### 2.2 关系型 vs NoSQL

```text
Rule: 关系型数据库选型
───────────────────────────────────────────
Premises:
  P1: 数据结构固定且关系明确
  P2: 需要复杂JOIN查询
  P3: 需要强一致性
  P4: 需要ACID事务

Conclusion:
  C: 选择关系型数据库

Proof:
  1. P1 → 关系模型可精确建模
  2. P2 → 关系代数支持高效JOIN
  3. P3+P4 → 关系数据库原生支持
  4. 综合满足需求

Confidence: 高

───────────────────────────────────────────

Rule: 文档数据库选型
───────────────────────────────────────────
Premises:
  P1: 数据结构灵活多变
  P2: 数据自包含（少JOIN）
  P3: 需要水平扩展
  P4: 可接受最终一致性

Conclusion:
  C: 选择文档数据库（MongoDB/CouchDB）

Proof:
  1. P1 → Schema-less设计更适合
  2. P2 → 嵌入式文档减少JOIN
  3. P3 → 分布式架构原生支持
  4. 综合满足需求

Confidence: 高
```

### 2.3 向量数据库选型

```text
Rule: 向量检索需求选型
───────────────────────────────────────────
Premises:
  P1: 需要语义相似性搜索
  P2: 高维向量数据（128-4096维）
  P3: 需要与关系数据结合

Conclusion:
  C1: 若P3为真 → PostgreSQL + pgvector
  C2: 若P3为假且规模大 → Milvus/Pinecone
  C3: 若轻量级需求 → SQLite + sqlite-vec

Proof:
  1. P1+P2 → 需要向量索引（HNSW/IVF）
  2. P3真 → 需要SQL+向量融合，pgvector支持
  3. P3假 → 专用向量数据库性能更优

Confidence: 高
Trade-off:
  - pgvector: 融合好但大规模性能有限
  - 专用向量库: 性能好但需额外维护
```

---

## 三、索引策略决策

### 3.1 索引类型选择

```text
Rule: B-tree索引选择
───────────────────────────────────────────
Premises:
  P1: 等值查询（=）或范围查询（<, >, BETWEEN）
  P2: ORDER BY需要排序
  P3: 数据基数高（选择性好）

Conclusion:
  C: 使用B-tree索引（默认）

Proof:
  1. P1 → B-tree支持O(log n)查找
  2. P2 → B-tree天然有序
  3. P3 → 高选择性使索引扫描高效

Confidence: 必然
Counter-example: 极低基数列应考虑Bitmap

───────────────────────────────────────────

Rule: Hash索引选择
───────────────────────────────────────────
Premises:
  P1: 仅等值查询（=）
  P2: 不需要范围查询
  P3: 不需要排序

Conclusion:
  C: 考虑Hash索引

Proof:
  1. P1+P2+P3 → 仅需O(1)查找
  2. Hash索引等值查询更快
  3. 但不支持范围和排序

Confidence: 中
Trade-off: 功能受限但特定场景更快

───────────────────────────────────────────

Rule: GiST/GIN索引选择
───────────────────────────────────────────
Premises:
  P1: 全文搜索需求 → GIN
  P2: 空间数据查询 → GiST
  P3: JSONB字段查询 → GIN
  P4: 数组包含查询 → GIN

Conclusion:
  C: 根据数据类型选择GiST或GIN

Proof:
  1. GIN: 倒排索引，适合多值/文本
  2. GiST: 通用搜索树，适合空间

Confidence: 高
```

### 3.2 复合索引设计

```text
Rule: 复合索引列顺序
───────────────────────────────────────────
Premises:
  P1: 多列查询条件
  P2: 等值条件列为{E1, E2, ...}
  P3: 范围条件列为{R1, R2, ...}
  P4: 排序列为{S1, S2, ...}

Conclusion:
  C: 索引列顺序 = [等值列] + [范围列(一个)] + [排序列]

Proof:
  1. 等值列放前面可精确定位
  2. 范围列只能有效使用第一个
  3. 排序列放后可避免filesort
  4. 遵循最左前缀原则

Confidence: 必然
Example: WHERE a=1 AND b>10 ORDER BY c
         索引: (a, b, c)

───────────────────────────────────────────

Rule: 覆盖索引设计
───────────────────────────────────────────
Premises:
  P1: 查询频繁
  P2: SELECT列固定且较少
  P3: 表数据量大

Conclusion:
  C: 创建包含所有SELECT列的覆盖索引

Proof:
  1. 覆盖索引避免回表
  2. P3 → 回表代价高
  3. Index-Only Scan更高效

Confidence: 高
Trade-off: 索引空间增加，写入变慢
```

---

## 四、范式选择决策

```text
Rule: 3NF vs BCNF决策
───────────────────────────────────────────
Premises:
  P1: 存在BCNF违规（非超键决定属性）
  P2: BCNF分解会丢失依赖

Conclusion:
  C: 若P2为真 → 保持3NF
     若P2为假 → 分解到BCNF

Proof:
  1. BCNF消除更多冗余
  2. 但依赖保持更重要（约束检查）
  3. 3NF保证依赖保持+无损

Confidence: 高

───────────────────────────────────────────

Rule: 反规范化决策
───────────────────────────────────────────
Premises:
  P1: 读远多于写（读写比 > 10:1）
  P2: 频繁需要JOIN多表
  P3: 更新异常风险可接受
  P4: 有触发器/应用层保证一致性

Conclusion:
  C: 考虑反规范化（冗余存储）

Proof:
  1. P1 → 读优化优先
  2. P2 → JOIN代价高
  3. P3+P4 → 一致性有保障

Confidence: 中
Trade-off: 冗余存储、更新复杂
Counter-example: 频繁更新场景不适用
```

---

## 五、查询优化决策

### 5.1 等价变换决策

```text
Rule: 选择下推
───────────────────────────────────────────
Premises:
  P1: σ_p(R ⋈ S) 需要计算
  P2: p仅涉及R的属性

Conclusion:
  C: 变换为 σ_p(R) ⋈ S

Proof:
  1. σ_p(R ⋈ S) ≡ σ_p(R) ⋈ S（当P2成立）
  2. 先过滤减少连接输入
  3. 降低整体计算量

Confidence: 必然
Application: 查询优化器自动执行

───────────────────────────────────────────

Rule: 投影下推
───────────────────────────────────────────
Premises:
  P1: 只需要部分列
  P2: 表有大宽列（TEXT/BLOB）

Conclusion:
  C: 尽早投影减少I/O

Proof:
  1. 减少数据传输量
  2. 特别是P2时效果显著

Confidence: 高
```

### 5.2 访问路径决策

```text
Rule: 索引扫描 vs 全表扫描
───────────────────────────────────────────
Premises:
  P1: 选择率(selectivity) = 返回行数/总行数
  P2: 存在可用索引
  P3: 阈值T ≈ 5-15%（取决于数据库）

Conclusion:
  C: 若 P1 < T → 索引扫描
     若 P1 >= T → 全表扫描

Proof:
  1. 索引扫描 = 索引查找 + 回表
  2. 选择率高时，回表代价超过全表扫描
  3. 统计信息决定阈值

Confidence: 高
Note: 覆盖索引可提高阈值
```

---

## 六、事务隔离级别决策

```text
Rule: 隔离级别选择
───────────────────────────────────────────

场景1: 读未提交需求
Premises:
  P1: 可接受脏读
  P2: 最大化并发
  P3: 非关键数据
Conclusion: READ UNCOMMITTED
Confidence: 中 (很少使用)

场景2: 读已提交需求（默认推荐）
Premises:
  P1: 不接受脏读
  P2: 可接受不可重复读
  P3: 一般OLTP场景
Conclusion: READ COMMITTED
Confidence: 高

场景3: 可重复读需求
Premises:
  P1: 事务内多次读取需一致
  P2: 可接受幻读
  P3: 报表/对账场景
Conclusion: REPEATABLE READ
Confidence: 高

场景4: 串行化需求
Premises:
  P1: 需要完全隔离
  P2: 不可接受任何异常
  P3: 金融/关键业务
Conclusion: SERIALIZABLE
Confidence: 高
Trade-off: 性能最差但最安全

───────────────────────────────────────────
隔离级别与异常关系：

| 隔离级别         | 脏读 | 不可重复读 | 幻读 |
|-----------------|------|----------|------|
| READ UNCOMMITTED | ✓   | ✓        | ✓   |
| READ COMMITTED   | ✗   | ✓        | ✓   |
| REPEATABLE READ  | ✗   | ✗        | ✓   |
| SERIALIZABLE     | ✗   | ✗        | ✗   |
```

---

## 七、连接算法决策

```text
Rule: 连接算法选择
───────────────────────────────────────────

Rule J1: 嵌套循环连接 (Nested Loop)
Premises:
  P1: 外表小（< 1000行）
  P2: 内表有索引
  P3: 选择性高
Conclusion: Nested Loop Join
Proof: O(n * log m)，索引查找高效
Confidence: 高

Rule J2: 哈希连接 (Hash Join)
Premises:
  P1: 无有效索引
  P2: 内存足够构建哈希表
  P3: 等值连接
Conclusion: Hash Join
Proof: O(n + m)，线性复杂度
Confidence: 高

Rule J3: 排序合并连接 (Merge Join)
Premises:
  P1: 两表已排序（或有序索引）
  P2: 等值连接
  P3: 大表连接
Conclusion: Merge Join
Proof: O(n + m)，无需额外内存
Confidence: 高

───────────────────────────────────────────
决策树：

                 开始
                  │
          ┌───有索引？───┐
          │ 是           │ 否
          ▼              ▼
    ┌───小外表？    ┌───内存足够？
    │ 是    │ 否    │ 是      │ 否
    ▼       ▼       ▼         ▼
  NL Join  检查    Hash    ┌───已排序？
           排序    Join    │ 是      │ 否
            │              ▼         ▼
            ▼           Merge     Sort+
         Merge或        Join      Merge
         Hash
```

---

## 相关资源

- [SQL概念本体](./09.06-SQL概念本体.md)
- [统一概念定义框架](./09.05-统一概念定义框架.md)
- [查询等价性理论](../03-形式化模型/03.02-查询等价性理论.md)
- [代价模型理论](../03-形式化模型/03.06-代价模型理论.md)

---

**维护者**: SQL Standards Team
**创建日期**: 2025-12-01
**规则数量**: 30+
