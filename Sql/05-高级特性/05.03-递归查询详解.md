# é€’å½’æŸ¥è¯¢è¯¦è§£

> **åˆ›å»ºæ—¥æœŸ**ï¼š2025-01-15
> **æœ€åæ›´æ–°**ï¼š2025-01-16
> **ç‰ˆæœ¬**ï¼šv1.0.0
> **éš¾åº¦**ï¼šâ­â­â­â­
> **åº”ç”¨åœºæ™¯**ï¼šå±‚æ¬¡ç»“æ„æŸ¥è¯¢ã€å›¾éå†ã€æ ‘å½¢æ•°æ®å¤„ç†

---

## ğŸ“‹ ç›®å½•

- [é€’å½’æŸ¥è¯¢è¯¦è§£](#é€’å½’æŸ¥è¯¢è¯¦è§£)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ä¸€ã€æ¦‚è¿°](#ä¸€æ¦‚è¿°)
    - [1.0 é€’å½’æŸ¥è¯¢å†å²èƒŒæ™¯](#10-é€’å½’æŸ¥è¯¢å†å²èƒŒæ™¯)
    - [1.1 é€’å½’æŸ¥è¯¢åº”ç”¨åœºæ™¯æ€ç»´å¯¼å›¾](#11-é€’å½’æŸ¥è¯¢åº”ç”¨åœºæ™¯æ€ç»´å¯¼å›¾)
    - [1.2 é€’å½’æŸ¥è¯¢å†³ç­–æ ‘](#12-é€’å½’æŸ¥è¯¢å†³ç­–æ ‘)
    - [1.3 é€’å½’æŸ¥è¯¢ vs å…¶ä»–æ–¹æ¡ˆå¯¹æ¯”çŸ©é˜µ](#13-é€’å½’æŸ¥è¯¢-vs-å…¶ä»–æ–¹æ¡ˆå¯¹æ¯”çŸ©é˜µ)
  - [äºŒã€é€’å½’CTEè¯­æ³•](#äºŒé€’å½’cteè¯­æ³•)
    - [2.1 é€’å½’æŸ¥è¯¢çš„å½¢å¼åŒ–å®šä¹‰](#21-é€’å½’æŸ¥è¯¢çš„å½¢å¼åŒ–å®šä¹‰)
    - [2.2 è¯­æ³•ç»“æ„](#22-è¯­æ³•ç»“æ„)
  - [ä¸‰ã€é€’å½’æŸ¥è¯¢åº”ç”¨](#ä¸‰é€’å½’æŸ¥è¯¢åº”ç”¨)
    - [3.1 å±‚æ¬¡ç»“æ„æŸ¥è¯¢](#31-å±‚æ¬¡ç»“æ„æŸ¥è¯¢)
  - [å››ã€ç»ˆæ­¢æ¡ä»¶](#å››ç»ˆæ­¢æ¡ä»¶)
    - [4.1 ç»ˆæ­¢æ¡ä»¶é‡è¦æ€§](#41-ç»ˆæ­¢æ¡ä»¶é‡è¦æ€§)
  - [äº”ã€æ€§èƒ½ä¼˜åŒ–](#äº”æ€§èƒ½ä¼˜åŒ–)
    - [5.1 ä¼˜åŒ–å»ºè®®](#51-ä¼˜åŒ–å»ºè®®)
  - [å…­ã€å›¾éå†å®Œæ•´æ¡ˆä¾‹ï¼šç¤¾äº¤ç½‘ç»œå¥½å‹æ¨è ğŸ†•](#å…­å›¾éå†å®Œæ•´æ¡ˆä¾‹ç¤¾äº¤ç½‘ç»œå¥½å‹æ¨è-)
    - [6.1 ä¸šåŠ¡åœºæ™¯æè¿°](#61-ä¸šåŠ¡åœºæ™¯æè¿°)
    - [6.2 æ¡ˆä¾‹1ï¼šæŸ¥æ‰¾Nåº¦å¥½å‹](#62-æ¡ˆä¾‹1æŸ¥æ‰¾nåº¦å¥½å‹)
    - [6.3 æ¡ˆä¾‹2ï¼šè®¡ç®—æœ€çŸ­è·¯å¾„](#63-æ¡ˆä¾‹2è®¡ç®—æœ€çŸ­è·¯å¾„)
    - [6.4 æ¡ˆä¾‹3ï¼šå‘ç°å…±åŒå¥½å‹](#64-æ¡ˆä¾‹3å‘ç°å…±åŒå¥½å‹)
    - [6.5 SQLite 3.45+ å›¾éå†å®ç°](#65-sqlite-345-å›¾éå†å®ç°)
  - [ä¸ƒã€PostgreSQL 18 é€’å½’æŸ¥è¯¢æ–°ç‰¹æ€§ ğŸ†•](#ä¸ƒpostgresql-18-é€’å½’æŸ¥è¯¢æ–°ç‰¹æ€§-)
    - [7.1 SEARCHå­å¥ï¼ˆæ·±åº¦/å¹¿åº¦ä¼˜å…ˆï¼‰](#71-searchå­å¥æ·±åº¦å¹¿åº¦ä¼˜å…ˆ)
    - [7.2 CYCLEå­å¥ï¼ˆå¾ªç¯æ£€æµ‹ï¼‰](#72-cycleå­å¥å¾ªç¯æ£€æµ‹)
    - [7.3 å¹¶è¡Œé€’å½’æŸ¥è¯¢ä¼˜åŒ–](#73-å¹¶è¡Œé€’å½’æŸ¥è¯¢ä¼˜åŒ–)
  - [å…«ã€SQLite 3.45+ é€’å½’æŸ¥è¯¢ç‰¹æ€§ ğŸ†•](#å…«sqlite-345-é€’å½’æŸ¥è¯¢ç‰¹æ€§-)
    - [8.1 é€’å½’æ·±åº¦é™åˆ¶](#81-é€’å½’æ·±åº¦é™åˆ¶)
    - [8.2 é€’å½’æŸ¥è¯¢æ€§èƒ½ä¼˜åŒ–](#82-é€’å½’æŸ¥è¯¢æ€§èƒ½ä¼˜åŒ–)
  - [ä¹ã€é€’å½’æŸ¥è¯¢å½¢å¼åŒ–ç†è®ºè¡¥å…… ğŸ†•](#ä¹é€’å½’æŸ¥è¯¢å½¢å¼åŒ–ç†è®ºè¡¥å……-)
    - [9.1 æœ€å°å›ºå®šç‚¹è¯­ä¹‰å®Œæ•´è¯æ˜](#91-æœ€å°å›ºå®šç‚¹è¯­ä¹‰å®Œæ•´è¯æ˜)
    - [9.2 UNION vs UNION ALLè¯­ä¹‰å·®å¼‚](#92-union-vs-union-allè¯­ä¹‰å·®å¼‚)
  - [åã€ç›¸å…³èµ„æº](#åç›¸å…³èµ„æº)
    - [ç›¸å…³æ–‡æ¡£](#ç›¸å…³æ–‡æ¡£)
    - [å¤–éƒ¨èµ„æº](#å¤–éƒ¨èµ„æº)

---

## ä¸€ã€æ¦‚è¿°

**é€’å½’æŸ¥è¯¢ï¼ˆRecursive Queryï¼‰**ä½¿ç”¨WITH RECURSIVEå®ç°ï¼Œç”¨äºå¤„ç†å±‚æ¬¡ç»“æ„å’Œå›¾æ•°æ®ã€‚

**é€’å½’æŸ¥è¯¢ç‰¹ç‚¹**ï¼š

- æ”¯æŒè‡ªå¼•ç”¨
- éœ€è¦æ˜ç¡®çš„ç»ˆæ­¢æ¡ä»¶
- å¯ä»¥å¤„ç†æ— é™å±‚æ¬¡ç»“æ„

### 1.0 é€’å½’æŸ¥è¯¢å†å²èƒŒæ™¯

**é€’å½’æŸ¥è¯¢çš„å‘å±•å†ç¨‹**ï¼š

- **SQL:1999**ï¼šæ­£å¼å¼•å…¥é€’å½’æŸ¥è¯¢ï¼ˆWITH RECURSIVEï¼‰ï¼ŒåŸºäºå›ºå®šç‚¹è¯­ä¹‰
- **SQL:2003**ï¼šå¢å¼ºäº†é€’å½’æŸ¥è¯¢çš„åŠŸèƒ½ï¼Œæ”¹è¿›äº†å›ºå®šç‚¹è¯­ä¹‰çš„å®šä¹‰
- **SQL:2008**ï¼šè¿›ä¸€æ­¥å®Œå–„äº†é€’å½’æŸ¥è¯¢çš„è¯­æ³•å’Œæ€§èƒ½ä¼˜åŒ–
- **SQL:2011**ï¼šå¢å¼ºäº†é€’å½’æŸ¥è¯¢åœ¨å¤æ‚åœºæ™¯ä¸­çš„åº”ç”¨
- **SQL:2016**ï¼šæ”¹è¿›äº†é€’å½’æŸ¥è¯¢çš„æ€§èƒ½ä¼˜åŒ–æ”¯æŒ
- **SQL:2023**ï¼šè¿›ä¸€æ­¥å®Œå–„äº†é€’å½’æŸ¥è¯¢çš„è¯­æ³•å’ŒåŠŸèƒ½

**é€’å½’æŸ¥è¯¢çš„è®¾è®¡åŠ¨æœº**ï¼š

é€’å½’æŸ¥è¯¢çš„è®¾è®¡æ˜¯ä¸ºäº†è§£å†³ä¼ ç»ŸSQLåœ¨å¤„ç†å±‚æ¬¡ç»“æ„å’Œå›¾æ•°æ®æ—¶çš„å±€é™æ€§ï¼š

1. **å±‚æ¬¡ç»“æ„æŸ¥è¯¢**ï¼šéœ€è¦å¤„ç†ç»„ç»‡æ¶æ„ã€åˆ†ç±»ä½“ç³»ç­‰å±‚æ¬¡ç»“æ„æ•°æ®
2. **å›¾éå†éœ€æ±‚**ï¼šéœ€è¦å¤„ç†ç¤¾äº¤ç½‘ç»œã€è·¯å¾„æŸ¥æ‰¾ç­‰å›¾æ•°æ®
3. **é€’å½’è®¡ç®—éœ€æ±‚**ï¼šéœ€è¦è®¡ç®—ç´¯è®¡å€¼ã€ç”Ÿæˆåºåˆ—ç­‰é€’å½’è®¡ç®—
4. **è‡ªå¼•ç”¨å…³ç³»**ï¼šéœ€è¦å¤„ç†è‡ªå¼•ç”¨çš„å…³ç³»ï¼Œå¦‚å‘˜å·¥-ç»ç†å…³ç³»

**é€’å½’æŸ¥è¯¢ä¸å…³ç³»æ¨¡å‹çš„å…³ç³»**ï¼š

é€’å½’æŸ¥è¯¢æ‰©å±•äº†å…³ç³»ä»£æ•°çš„è¡¨è¾¾èƒ½åŠ›ï¼Œå¼•å…¥äº†"é€’å½’å…³ç³»"å’Œ"å›ºå®šç‚¹"çš„æ¦‚å¿µã€‚åœ¨å…³ç³»ä»£æ•°ä¸­ï¼Œé€’å½’å…³ç³»å¯ä»¥é€šè¿‡æœ€å°å›ºå®šç‚¹æ“ä½œç¬¦$\mu$å®šä¹‰ï¼Œé€’å½’æŸ¥è¯¢æä¾›äº†SQLä¸­çš„å®ç°æ–¹å¼ã€‚

### 1.1 é€’å½’æŸ¥è¯¢åº”ç”¨åœºæ™¯æ€ç»´å¯¼å›¾

```mermaid
mindmap
  root((é€’å½’æŸ¥è¯¢))
    å±‚æ¬¡ç»“æ„
      ç»„ç»‡æ¶æ„
        éƒ¨é—¨å±‚çº§
        å‘˜å·¥å±‚çº§
      åˆ†ç±»ä½“ç³»
        å•†å“åˆ†ç±»
        ç›®å½•ç»“æ„
      æ ‘å½¢ç»“æ„
        è¯„è®ºæ ‘
        èœå•æ ‘
    å›¾éå†
      ç¤¾äº¤ç½‘ç»œ
        å¥½å‹å…³ç³»
        å…³æ³¨å…³ç³»
      è·¯å¾„æŸ¥æ‰¾
        æœ€çŸ­è·¯å¾„
        æ‰€æœ‰è·¯å¾„
      è¿é€šæ€§
        è¿é€šåˆ†é‡
        å¯è¾¾æ€§
    æ•°æ®ç”Ÿæˆ
      åºåˆ—ç”Ÿæˆ
        æ•°å­—åºåˆ—
        æ—¥æœŸåºåˆ—
      ç»„åˆç”Ÿæˆ
        æ’åˆ—ç»„åˆ
        å­é›†ç”Ÿæˆ
    ç´¯è®¡è®¡ç®—
      ç´¯è®¡æ±‚å’Œ
        ç´¯è®¡é”€å”®é¢
        ç´¯è®¡ç”¨æˆ·æ•°
      ç´¯è®¡ç»Ÿè®¡
        ç´¯è®¡æ’å
        ç´¯è®¡å æ¯”
```

### 1.2 é€’å½’æŸ¥è¯¢å†³ç­–æ ‘

```mermaid
flowchart TD
    A[éœ€è¦é€’å½’æŸ¥è¯¢?] --> B{æ•°æ®ç»“æ„ç±»å‹}
    B -->|å±‚æ¬¡ç»“æ„| C{æœ‰æ˜ç¡®å±‚çº§?}
    B -->|å›¾ç»“æ„| D{éœ€è¦éå†?}
    B -->|åºåˆ—ç”Ÿæˆ| E[ä½¿ç”¨é€’å½’CTE]

    C -->|æ˜¯| F{æœ‰ç»ˆæ­¢æ¡ä»¶?}
    F -->|æ˜¯| G[ä½¿ç”¨WITH RECURSIVE]
    F -->|å¦| H[è®¾è®¡ç»ˆæ­¢æ¡ä»¶]
    H --> G

    D -->|æ˜¯| I{éœ€è¦è·¯å¾„?}
    I -->|æ˜¯| J[é€’å½’è·¯å¾„æŸ¥æ‰¾]
    I -->|å¦| K[é€’å½’éå†]
    J --> G
    K --> G

    E --> G
    G --> L[æ‰§è¡Œé€’å½’æŸ¥è¯¢]
```

### 1.3 é€’å½’æŸ¥è¯¢ vs å…¶ä»–æ–¹æ¡ˆå¯¹æ¯”çŸ©é˜µ

| æ–¹æ¡ˆ | å®ç°æ–¹å¼ | æ€§èƒ½ | å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ |
|------|---------|------|--------|---------|
| **é€’å½’CTE** | WITH RECURSIVE | â­â­â­ | â­â­â­ | å±‚æ¬¡ç»“æ„ã€å›¾éå† |
| **è‡ªè¿æ¥** | å¤šæ¬¡JOIN | â­â­ | â­â­â­â­ | å›ºå®šå±‚çº§ï¼ˆ2-3å±‚ï¼‰ |
| **å­˜å‚¨è¿‡ç¨‹** | å¾ªç¯å¤„ç† | â­â­ | â­â­â­â­ | å¤æ‚é€»è¾‘ |
| **åº”ç”¨å±‚é€’å½’** | ç¨‹åºä»£ç  | â­ | â­â­â­â­â­ | ç®€å•åœºæ™¯ |

---

## äºŒã€é€’å½’CTEè¯­æ³•

### 2.1 é€’å½’æŸ¥è¯¢çš„å½¢å¼åŒ–å®šä¹‰

**é€’å½’æŸ¥è¯¢çš„BNFè¯­æ³•å®šä¹‰**ï¼ˆåŸºäºSQL:1999æ ‡å‡†ï¼‰ï¼š

```bnf
<with clause> ::=
    WITH RECURSIVE <with list>

<with list> ::=
    <with list element> [ { <comma> <with list element> }... ]

<with list element> ::=
    <query name> [ <left paren> <with column list> <right paren> ]
    AS <left paren> <query expression body> <right paren>

<query expression body> ::=
    <query term>
    | <query expression body> UNION [ ALL | DISTINCT ] <query term>
    | <query expression body> EXCEPT [ ALL | DISTINCT ] <query term>

<query term> ::=
    <query primary>
    | <query term> INTERSECT [ ALL | DISTINCT ] <query primary>

<query primary> ::=
    <simple table>
    | <left paren> <query expression body> <right paren>
    | <table value constructor>
    | <explicit table>
```

**é€’å½’æŸ¥è¯¢çš„è¯­ä¹‰å®šä¹‰**ï¼š

é€’å½’æŸ¥è¯¢ `WITH RECURSIVE cte_name AS (Q)` å®šä¹‰äº†ä¸€ä¸ªé€’å½’å…³ç³»$R_{rec}$ï¼Œå…¶ä¸­ï¼š

1. **åŸºç¡€æŸ¥è¯¢ï¼ˆBase Caseï¼‰**ï¼š$Q_{base}$æ˜¯é€’å½’æŸ¥è¯¢ä¸­çš„ç¬¬ä¸€ä¸ªæŸ¥è¯¢é¡¹ï¼Œä¸å¼•ç”¨$cte\_name$
2. **é€’å½’æŸ¥è¯¢ï¼ˆRecursive Caseï¼‰**ï¼š$Q_{rec}$æ˜¯é€’å½’æŸ¥è¯¢ä¸­çš„åç»­æŸ¥è¯¢é¡¹ï¼Œå¼•ç”¨$cte\_name$
3. **å›ºå®šç‚¹è¯­ä¹‰**ï¼š$R_{rec}$æ˜¯é€’å½’æŸ¥è¯¢çš„å›ºå®šç‚¹ï¼Œæ»¡è¶³ï¼š
   $$R_{rec} = Q_{base} \cup Q_{rec}(R_{rec})$$

**æœ€å°å›ºå®šç‚¹è¯­ä¹‰**ï¼š

é€’å½’æŸ¥è¯¢ä½¿ç”¨æœ€å°å›ºå®šç‚¹ï¼ˆLeast Fixed Pointï¼‰è¯­ä¹‰ï¼Œå³$R_{rec}$æ˜¯æ»¡è¶³ä¸Šè¿°ç­‰å¼çš„æœ€å°å…³ç³»ã€‚

å½¢å¼åŒ–åœ°ï¼Œå¯¹äºé€’å½’æŸ¥è¯¢$Q$ï¼Œå…¶å›ºå®šç‚¹å®šä¹‰ä¸ºï¼š
$$R_{rec} = \mu X. (Q_{base} \cup Q_{rec}(X))$$

å…¶ä¸­$\mu$è¡¨ç¤ºæœ€å°å›ºå®šç‚¹æ“ä½œç¬¦ã€‚

**é€’å½’æŸ¥è¯¢çš„è¿­ä»£è®¡ç®—**ï¼š

é€’å½’å…³ç³»$R_{rec}$å¯ä»¥é€šè¿‡è¿­ä»£è®¡ç®—å¾—åˆ°ï¼š

1. $R_0 = \emptyset$ï¼ˆåˆå§‹ä¸ºç©ºå…³ç³»ï¼‰
2. $R_{i+1} = Q_{base} \cup Q_{rec}(R_i)$ï¼ˆè¿­ä»£è®¡ç®—ï¼‰
3. å½“$R_{i+1} = R_i$æ—¶ï¼Œ$R_{rec} = R_i$ï¼ˆè¾¾åˆ°å›ºå®šç‚¹ï¼‰

### 2.2 è¯­æ³•ç»“æ„

**é€’å½’CTEè¯­æ³•**ï¼š

```sql
WITH RECURSIVE cte_name AS (
    -- åŸºç¡€æŸ¥è¯¢ï¼ˆé”šç‚¹ï¼‰
    SELECT ...
    UNION ALL
    -- é€’å½’æŸ¥è¯¢
    SELECT ... FROM cte_name WHERE ...
)
SELECT * FROM cte_name;
```

---

## ä¸‰ã€é€’å½’æŸ¥è¯¢åº”ç”¨

### 3.1 å±‚æ¬¡ç»“æ„æŸ¥è¯¢

**åœºæ™¯1ï¼šç»„ç»‡æ¶æ„æŸ¥è¯¢**:

**ä¸šåŠ¡éœ€æ±‚**ï¼šæŸ¥è¯¢å®Œæ•´çš„ç»„ç»‡æ¶æ„æ ‘ï¼ŒåŒ…æ‹¬æ‰€æœ‰å±‚çº§å…³ç³»ã€‚

**æ•°æ®æ¨¡å‹**ï¼š

```mermaid
erDiagram
    Organization ||--o{ Organization : "parent"
    Organization {
        int id PK
        string name
        int parent_id FK
        string type
    }
```

**ERå›¾è¯´æ˜**ï¼š

- ç»„ç»‡è¡¨è‡ªå¼•ç”¨ï¼Œé€šè¿‡parent_idå»ºç«‹å±‚çº§å…³ç³»
- æ ¹èŠ‚ç‚¹çš„parent_idä¸ºNULL

**æŸ¥è¯¢**ï¼š

```sql
WITH RECURSIVE org_tree AS (
    -- åŸºç¡€æŸ¥è¯¢ï¼šæ ¹èŠ‚ç‚¹
    SELECT
        id,
        name,
        parent_id,
        0 as level,
        CAST(name AS VARCHAR(1000)) as path
    FROM Organization
    WHERE parent_id IS NULL

    UNION ALL

    -- é€’å½’æŸ¥è¯¢ï¼šå­èŠ‚ç‚¹
    SELECT
        o.id,
        o.name,
        o.parent_id,
        ot.level + 1,
        ot.path || ' > ' || o.name
    FROM Organization o
    JOIN org_tree ot ON o.parent_id = ot.id
    WHERE ot.level < 10  -- é˜²æ­¢æ— é™é€’å½’
)
SELECT
    id,
    name,
    parent_id,
    level,
    path
FROM org_tree
ORDER BY path;
```

**æŸ¥è¯¢æ‰§è¡Œæµç¨‹æ—¶åºå›¾**ï¼š

```mermaid
sequenceDiagram
    participant Query
    participant CTE
    participant Organization

    Query->>CTE: åˆå§‹åŒ–åŸºç¡€æŸ¥è¯¢
    CTE->>Organization: æŸ¥è¯¢æ ¹èŠ‚ç‚¹(parent_id IS NULL)
    Organization-->>CTE: è¿”å›æ ¹èŠ‚ç‚¹

    loop é€’å½’è¿­ä»£
        CTE->>CTE: æ£€æŸ¥ç»ˆæ­¢æ¡ä»¶(level < 10)
        CTE->>Organization: æŸ¥è¯¢å­èŠ‚ç‚¹(parent_id = å½“å‰èŠ‚ç‚¹id)
        Organization-->>CTE: è¿”å›å­èŠ‚ç‚¹
        CTE->>CTE: åˆå¹¶ç»“æœ(UNION ALL)
    end

    CTE-->>Query: è¿”å›å®Œæ•´æ ‘ç»“æ„
```

**æŸ¥è¯¢ç»“æœç¤ºä¾‹**ï¼š

```text
| id | name     | parent_id | level | path                    |
|----|----------|-----------|-------|-------------------------|
| 1  | æ€»å…¬å¸   | NULL      | 0     | æ€»å…¬å¸                  |
| 2  | æŠ€æœ¯éƒ¨   | 1         | 1     | æ€»å…¬å¸ > æŠ€æœ¯éƒ¨         |
| 3  | å¼€å‘ç»„   | 2         | 2     | æ€»å…¬å¸ > æŠ€æœ¯éƒ¨ > å¼€å‘ç»„|
| 4  | æµ‹è¯•ç»„   | 2         | 2     | æ€»å…¬å¸ > æŠ€æœ¯éƒ¨ > æµ‹è¯•ç»„|
```

**åœºæ™¯2ï¼šè¯„è®ºæ ‘æŸ¥è¯¢**:

**ä¸šåŠ¡éœ€æ±‚**ï¼šæŸ¥è¯¢è¯„è®ºåŠå…¶æ‰€æœ‰å›å¤ï¼Œæ„å»ºè¯„è®ºæ ‘ã€‚

**æ•°æ®æ¨¡å‹**ï¼š

```mermaid
erDiagram
    Comment ||--o{ Comment : "å›å¤"
    Comment {
        int comment_id PK
        int post_id FK
        int parent_comment_id FK
        string content
        date created_at
    }
```

**æŸ¥è¯¢**ï¼š

```sql
WITH RECURSIVE comment_tree AS (
    -- åŸºç¡€æŸ¥è¯¢ï¼šé¡¶çº§è¯„è®º
    SELECT
        comment_id,
        post_id,
        parent_comment_id,
        content,
        created_at,
        0 as depth,
        CAST(comment_id AS VARCHAR(1000)) as thread_path
    FROM Comment
    WHERE post_id = :post_id
      AND parent_comment_id IS NULL

    UNION ALL

    -- é€’å½’æŸ¥è¯¢ï¼šå›å¤
    SELECT
        c.comment_id,
        c.post_id,
        c.parent_comment_id,
        c.content,
        c.created_at,
        ct.depth + 1,
        ct.thread_path || '.' || c.comment_id
    FROM Comment c
    JOIN comment_tree ct ON c.parent_comment_id = ct.comment_id
    WHERE ct.depth < 10
)
SELECT
    comment_id,
    content,
    depth,
    thread_path,
    created_at
FROM comment_tree
ORDER BY thread_path;
```

**æ€§èƒ½ä¼˜åŒ–**ï¼š

```sql
-- åˆ›å»ºç´¢å¼•ä¼˜åŒ–é€’å½’æŸ¥è¯¢
CREATE INDEX idx_comment_parent ON Comment(parent_comment_id);
CREATE INDEX idx_comment_post ON Comment(post_id, parent_comment_id);

-- é™åˆ¶é€’å½’æ·±åº¦
WHERE ct.depth < 10  -- é˜²æ­¢è¿‡æ·±é€’å½’
```

---

## å››ã€ç»ˆæ­¢æ¡ä»¶

### 4.1 ç»ˆæ­¢æ¡ä»¶é‡è¦æ€§

**ç»ˆæ­¢æ¡ä»¶**ï¼š

é€’å½’æŸ¥è¯¢å¿…é¡»åŒ…å«ç»ˆæ­¢æ¡ä»¶ï¼Œå¦åˆ™å¯èƒ½å¯¼è‡´æ— é™å¾ªç¯ï¼š

```sql
WITH RECURSIVE cte AS (
    SELECT 1 as n
    UNION ALL
    SELECT n + 1 FROM cte WHERE n < 10  -- ç»ˆæ­¢æ¡ä»¶
)
SELECT * FROM cte;
```

---

## äº”ã€æ€§èƒ½ä¼˜åŒ–

### 5.1 ä¼˜åŒ–å»ºè®®

**ä¼˜åŒ–å»ºè®®**ï¼š

1. **ç´¢å¼•ä¼˜åŒ–**ï¼šä¸ºé€’å½’æŸ¥è¯¢çš„å…³è”å­—æ®µåˆ›å»ºç´¢å¼•
2. **æ·±åº¦é™åˆ¶**ï¼šä½¿ç”¨WHEREå­å¥é™åˆ¶é€’å½’æ·±åº¦ï¼Œé˜²æ­¢æ— é™é€’å½’
3. **ç‰©åŒ–è§†å›¾**ï¼šå¯¹äºé¢‘ç¹æŸ¥è¯¢çš„å±‚æ¬¡ç»“æ„ï¼Œä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜ç»“æœ
4. **æŸ¥è¯¢é‡å†™**ï¼šå¯¹äºå›ºå®šå±‚çº§ï¼Œè€ƒè™‘ä½¿ç”¨è‡ªè¿æ¥æ›¿ä»£é€’å½’æŸ¥è¯¢

**æ€§èƒ½ä¼˜åŒ–ç¤ºä¾‹**ï¼š

```sql
-- åˆ›å»ºç´¢å¼•ä¼˜åŒ–é€’å½’æŸ¥è¯¢
CREATE INDEX idx_organization_parent ON Organization(parent_id);
CREATE INDEX idx_organization_id ON Organization(id);

-- ä¼˜åŒ–åçš„é€’å½’æŸ¥è¯¢ï¼ˆé™åˆ¶æ·±åº¦ï¼‰
WITH RECURSIVE org_tree AS (
    SELECT
        id,
        name,
        parent_id,
        0 as level,
        CAST(name AS VARCHAR(1000)) as path
    FROM Organization
    WHERE parent_id IS NULL

    UNION ALL

    SELECT
        o.id,
        o.name,
        o.parent_id,
        ot.level + 1,
        ot.path || ' > ' || o.name
    FROM Organization o
    JOIN org_tree ot ON o.parent_id = ot.id
    WHERE ot.level < 10  -- é™åˆ¶é€’å½’æ·±åº¦
)
SELECT * FROM org_tree
WHERE level <= 5;  -- åªæŸ¥è¯¢å‰5å±‚
```

**æ€§èƒ½å¯¹æ¯”**ï¼š

| ä¼˜åŒ–æ–¹æ³• | æŸ¥è¯¢æ—¶é—´ | å†…å­˜ä½¿ç”¨ | é€‚ç”¨åœºæ™¯ |
|---------|---------|---------|---------|
| **æ— ä¼˜åŒ–** | 100% | 100% | å°æ•°æ®é›† |
| **ç´¢å¼•ä¼˜åŒ–** | 30% | 100% | å¤§æ•°æ®é›† |
| **æ·±åº¦é™åˆ¶** | 50% | 50% | æ·±å±‚ç»“æ„ |
| **ç‰©åŒ–è§†å›¾** | 10% | 150% | é¢‘ç¹æŸ¥è¯¢ |

**é€’å½’æŸ¥è¯¢ç»ˆæ­¢æ¡ä»¶å½¢å¼åŒ–å®šä¹‰**ï¼š

```latex
é€’å½’æŸ¥è¯¢ç»ˆæ­¢æ¡ä»¶ï¼š

WITH RECURSIVE cte AS (
    base_query
    UNION ALL
    recursive_query
)

ç»ˆæ­¢æ¡ä»¶ï¼š
1. åŸºç¡€æ¡ä»¶ï¼šbase_query ç»“æœä¸ºç©º
2. é€’å½’æ¡ä»¶ï¼šrecursive_query ç»“æœä¸ºç©º
3. æ·±åº¦æ¡ä»¶ï¼šlevel < max_depth
4. å¾ªç¯æ£€æµ‹ï¼švisited.contains(current_node)
```

**ç»ˆæ­¢æ¡ä»¶è¯æ˜**ï¼š

```latex
å®šç†ï¼šå¦‚æœé€’å½’æŸ¥è¯¢æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼Œåˆ™å¿…ç„¶ç»ˆæ­¢ï¼š

1. åŸºç¡€æŸ¥è¯¢æœ‰é™ï¼š|base_query| < âˆ
2. é€’å½’å…³ç³»æœ‰é™ï¼š|recursive_relation| < âˆ
3. æ·±åº¦é™åˆ¶ï¼šmax_depth < âˆ
4. æ— å¾ªç¯ï¼šâˆ€n: visited.contains(n) âŸ¹ n ä¸å†è¢«è®¿é—®

è¯æ˜ï¼š
å‡è®¾é€’å½’æŸ¥è¯¢ä¸ç»ˆæ­¢ï¼Œåˆ™å­˜åœ¨æ— é™åºåˆ—ï¼š
nâ‚ â†’ nâ‚‚ â†’ nâ‚ƒ â†’ ...

ç”±äºå…³ç³»æœ‰é™ï¼Œå¿…ç„¶å­˜åœ¨å¾ªç¯ï¼š
náµ¢ = nâ±¼ (i < j)

ä½†æ ¹æ®æ¡ä»¶4ï¼Œå¾ªç¯èŠ‚ç‚¹ä¸ä¼šè¢«é‡å¤è®¿é—®ï¼ŒçŸ›ç›¾ã€‚
å› æ­¤é€’å½’æŸ¥è¯¢å¿…ç„¶ç»ˆæ­¢ã€‚âœ“
```

---

## å…­ã€å›¾éå†å®Œæ•´æ¡ˆä¾‹ï¼šç¤¾äº¤ç½‘ç»œå¥½å‹æ¨è ğŸ†•

### 6.1 ä¸šåŠ¡åœºæ™¯æè¿°

**èƒŒæ™¯**ï¼šç¤¾äº¤ç½‘ç»œéœ€è¦å®ç°"ä½ å¯èƒ½è®¤è¯†çš„äºº"æ¨èåŠŸèƒ½ï¼š

- æŸ¥æ‰¾ç”¨æˆ·çš„Nåº¦å¥½å‹ï¼ˆå¥½å‹çš„å¥½å‹çš„å¥½å‹...ï¼‰
- è®¡ç®—ä¸¤ä¸ªç”¨æˆ·ä¹‹é—´çš„æœ€çŸ­è·¯å¾„
- å‘ç°å…±åŒå¥½å‹

**æ•°æ®æ¨¡å‹**ï¼š

```sql
-- PostgreSQL 18 / SQLite 3.45+ é€šç”¨
CREATE TABLE users (
    user_id     INTEGER PRIMARY KEY,
    username    TEXT NOT NULL,
    created_at  DATE DEFAULT CURRENT_DATE
);

CREATE TABLE friendships (
    user_id_1   INTEGER NOT NULL,
    user_id_2   INTEGER NOT NULL,
    created_at  DATE DEFAULT CURRENT_DATE,
    PRIMARY KEY (user_id_1, user_id_2),
    FOREIGN KEY (user_id_1) REFERENCES users(user_id),
    FOREIGN KEY (user_id_2) REFERENCES users(user_id),
    CHECK (user_id_1 < user_id_2)  -- é¿å…é‡å¤å­˜å‚¨
);

-- æµ‹è¯•æ•°æ®
INSERT INTO users VALUES
(1, 'Alice', '2020-01-01'),
(2, 'Bob', '2020-02-15'),
(3, 'Charlie', '2020-03-20'),
(4, 'Diana', '2020-04-10'),
(5, 'Eve', '2020-05-05'),
(6, 'Frank', '2020-06-15'),
(7, 'Grace', '2020-07-20');

INSERT INTO friendships VALUES
(1, 2, '2020-06-01'),  -- Alice - Bob
(1, 3, '2020-07-01'),  -- Alice - Charlie
(2, 3, '2020-08-01'),  -- Bob - Charlie
(2, 4, '2020-09-01'),  -- Bob - Diana
(3, 5, '2020-10-01'),  -- Charlie - Eve
(4, 5, '2020-11-01'),  -- Diana - Eve
(5, 6, '2020-12-01'),  -- Eve - Frank
(6, 7, '2021-01-01');  -- Frank - Grace
```

### 6.2 æ¡ˆä¾‹1ï¼šæŸ¥æ‰¾Nåº¦å¥½å‹

**éœ€æ±‚**ï¼šæŸ¥æ‰¾ç”¨æˆ·Alice(user_id=1)çš„1-3åº¦å¥½å‹ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š

```text
å®šä¹‰ï¼šNåº¦å¥½å‹å‡½æ•° Friends_N
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Friends_1(u) = {v | (u,v) âˆˆ friendships âˆ¨ (v,u) âˆˆ friendships}

Friends_N(u) = Friends_1(Friends_{N-1}(u)) \ (â‹ƒ_{i=0}^{N-1} Friends_i(u))

å…¶ä¸­ Friends_0(u) = {u}

æ€§è´¨ï¼šNåº¦å¥½å‹ä¸åŒ…å«å·²å‘ç°çš„ä½åº¦å¥½å‹
```

**PostgreSQL 18 å®ç°**ï¼š

```sql
-- PostgreSQL 18: æŸ¥æ‰¾Aliceçš„1-3åº¦å¥½å‹
WITH RECURSIVE friend_degrees AS (
    -- é”šå®šæˆå‘˜ï¼šèµ·å§‹ç”¨æˆ·
    SELECT
        1 AS user_id,  -- Alice
        0 AS degree,
        ARRAY[1] AS visited_path,
        '{1}'::INTEGER[] AS all_visited

    UNION ALL

    -- é€’å½’æˆå‘˜ï¼šéå†å¥½å‹å…³ç³»
    SELECT DISTINCT
        CASE
            WHEN f.user_id_1 = fd.user_id THEN f.user_id_2
            ELSE f.user_id_1
        END AS user_id,
        fd.degree + 1,
        fd.visited_path ||
            CASE
                WHEN f.user_id_1 = fd.user_id THEN f.user_id_2
                ELSE f.user_id_1
            END,
        fd.all_visited ||
            CASE
                WHEN f.user_id_1 = fd.user_id THEN f.user_id_2
                ELSE f.user_id_1
            END
    FROM friend_degrees fd
    JOIN friendships f ON (f.user_id_1 = fd.user_id OR f.user_id_2 = fd.user_id)
    WHERE fd.degree < 3  -- é™åˆ¶åˆ°3åº¦
      AND NOT (
          CASE
              WHEN f.user_id_1 = fd.user_id THEN f.user_id_2
              ELSE f.user_id_1
          END = ANY(fd.all_visited)
      )  -- é¿å…é‡å¤è®¿é—®
)
SELECT DISTINCT
    fd.degree AS "åº¦æ•°",
    u.username AS "ç”¨æˆ·å",
    fd.user_id AS "ç”¨æˆ·ID"
FROM friend_degrees fd
JOIN users u ON fd.user_id = u.user_id
WHERE fd.degree > 0
ORDER BY fd.degree, u.username;

/*
ç»“æœ:
 åº¦æ•° |  ç”¨æˆ·å  | ç”¨æˆ·ID
------+----------+--------
    1 | Bob      |      2
    1 | Charlie  |      3
    2 | Diana    |      4
    2 | Eve      |      5
    3 | Frank    |      6
*/
```

### 6.3 æ¡ˆä¾‹2ï¼šè®¡ç®—æœ€çŸ­è·¯å¾„

**éœ€æ±‚**ï¼šè®¡ç®—Alice(1)åˆ°Grace(7)ä¹‹é—´çš„æœ€çŸ­ç¤¾äº¤è·¯å¾„ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š

```text
å®šä¹‰ï¼šæœ€çŸ­è·¯å¾„å‡½æ•° ShortestPath
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ShortestPath(s, t) = argmin_{p âˆˆ Paths(s,t)} |p|

å…¶ä¸­ Paths(s,t) = æ‰€æœ‰ä»såˆ°tçš„è·¯å¾„é›†åˆ

BFSæ€§è´¨ï¼šé€’å½’æŸ¥è¯¢çš„å¹¿åº¦ä¼˜å…ˆç‰¹æ€§ä¿è¯é¦–æ¬¡åˆ°è¾¾å³ä¸ºæœ€çŸ­è·¯å¾„
```

**PostgreSQL 18 å®ç°**ï¼š

```sql
-- PostgreSQL 18: è®¡ç®—Aliceåˆ°Graceçš„æœ€çŸ­è·¯å¾„
WITH RECURSIVE shortest_path AS (
    -- èµ·ç‚¹
    SELECT
        1 AS current_user,
        0 AS distance,
        ARRAY[1] AS path,
        ARRAY['Alice'] AS path_names,
        FALSE AS found

    UNION ALL

    -- BFSéå†
    SELECT
        CASE WHEN f.user_id_1 = sp.current_user THEN f.user_id_2
             ELSE f.user_id_1
        END,
        sp.distance + 1,
        sp.path ||
            CASE WHEN f.user_id_1 = sp.current_user THEN f.user_id_2
                 ELSE f.user_id_1
            END,
        sp.path_names || u.username,
        CASE WHEN f.user_id_1 = sp.current_user THEN f.user_id_2
             ELSE f.user_id_1
        END = 7  -- Graceçš„ID
    FROM shortest_path sp
    JOIN friendships f ON (f.user_id_1 = sp.current_user OR f.user_id_2 = sp.current_user)
    JOIN users u ON u.user_id =
        CASE WHEN f.user_id_1 = sp.current_user THEN f.user_id_2
             ELSE f.user_id_1
        END
    WHERE NOT sp.found
      AND sp.distance < 10  -- é˜²æ­¢æ— é™å¾ªç¯
      AND NOT (
          CASE WHEN f.user_id_1 = sp.current_user THEN f.user_id_2
               ELSE f.user_id_1
          END = ANY(sp.path)
      )
)
SELECT
    distance AS "è·¯å¾„é•¿åº¦",
    array_to_string(path_names, ' â†’ ') AS "è·¯å¾„"
FROM shortest_path
WHERE current_user = 7
ORDER BY distance
LIMIT 1;

/*
ç»“æœ:
 è·¯å¾„é•¿åº¦ |                     è·¯å¾„
----------+-----------------------------------------------
        4 | Alice â†’ Charlie â†’ Eve â†’ Frank â†’ Grace
*/
```

### 6.4 æ¡ˆä¾‹3ï¼šå‘ç°å…±åŒå¥½å‹

**PostgreSQL 18 å®ç°**ï¼š

```sql
-- PostgreSQL 18: æŸ¥æ‰¾Aliceå’ŒDianaçš„å…±åŒå¥½å‹
WITH alice_friends AS (
    SELECT
        CASE WHEN user_id_1 = 1 THEN user_id_2 ELSE user_id_1 END AS friend_id
    FROM friendships
    WHERE user_id_1 = 1 OR user_id_2 = 1
),
diana_friends AS (
    SELECT
        CASE WHEN user_id_1 = 4 THEN user_id_2 ELSE user_id_1 END AS friend_id
    FROM friendships
    WHERE user_id_1 = 4 OR user_id_2 = 4
)
SELECT
    u.username AS "å…±åŒå¥½å‹",
    u.user_id
FROM alice_friends af
JOIN diana_friends df ON af.friend_id = df.friend_id
JOIN users u ON af.friend_id = u.user_id;

/*
ç»“æœ:
 å…±åŒå¥½å‹ | user_id
----------+---------
 Bob      |       2
*/
```

### 6.5 SQLite 3.45+ å›¾éå†å®ç°

```sql
-- SQLite 3.45+: æŸ¥æ‰¾Nåº¦å¥½å‹ï¼ˆä½¿ç”¨å­—ç¬¦ä¸²å­˜å‚¨è·¯å¾„ï¼‰
WITH RECURSIVE friend_degrees AS (
    SELECT
        1 AS user_id,
        0 AS degree,
        '1' AS visited

    UNION ALL

    SELECT DISTINCT
        CASE
            WHEN f.user_id_1 = fd.user_id THEN f.user_id_2
            ELSE f.user_id_1
        END,
        fd.degree + 1,
        fd.visited || ',' ||
            CASE
                WHEN f.user_id_1 = fd.user_id THEN f.user_id_2
                ELSE f.user_id_1
            END
    FROM friend_degrees fd
    JOIN friendships f ON (f.user_id_1 = fd.user_id OR f.user_id_2 = fd.user_id)
    WHERE fd.degree < 3
      AND instr(fd.visited,
          CASE
              WHEN f.user_id_1 = fd.user_id THEN f.user_id_2
              ELSE f.user_id_1
          END || '') = 0
)
SELECT DISTINCT
    fd.degree AS "åº¦æ•°",
    u.username AS "ç”¨æˆ·å"
FROM friend_degrees fd
JOIN users u ON fd.user_id = u.user_id
WHERE fd.degree > 0
ORDER BY fd.degree, u.username;
```

---

## ä¸ƒã€PostgreSQL 18 é€’å½’æŸ¥è¯¢æ–°ç‰¹æ€§ ğŸ†•

### 7.1 SEARCHå­å¥ï¼ˆæ·±åº¦/å¹¿åº¦ä¼˜å…ˆï¼‰

```sql
-- PostgreSQL 18: SEARCH DEPTH FIRST (æ·±åº¦ä¼˜å…ˆ)
WITH RECURSIVE tree AS (
    SELECT id, name, parent_id, ARRAY[id] AS path
    FROM organization WHERE parent_id IS NULL
    UNION ALL
    SELECT o.id, o.name, o.parent_id, t.path || o.id
    FROM organization o JOIN tree t ON o.parent_id = t.id
)
SEARCH DEPTH FIRST BY id SET ordercol
SELECT * FROM tree ORDER BY ordercol;

-- PostgreSQL 18: SEARCH BREADTH FIRST (å¹¿åº¦ä¼˜å…ˆ)
WITH RECURSIVE tree AS (
    SELECT id, name, parent_id, ARRAY[id] AS path
    FROM organization WHERE parent_id IS NULL
    UNION ALL
    SELECT o.id, o.name, o.parent_id, t.path || o.id
    FROM organization o JOIN tree t ON o.parent_id = t.id
)
SEARCH BREADTH FIRST BY id SET ordercol
SELECT * FROM tree ORDER BY ordercol;
```

### 7.2 CYCLEå­å¥ï¼ˆå¾ªç¯æ£€æµ‹ï¼‰

```sql
-- PostgreSQL 18: è‡ªåŠ¨å¾ªç¯æ£€æµ‹
WITH RECURSIVE traverse AS (
    SELECT
        user_id_1 AS current,
        user_id_2 AS next_node,
        ARRAY[user_id_1] AS path
    FROM friendships
    WHERE user_id_1 = 1

    UNION ALL

    SELECT
        t.next_node,
        CASE WHEN f.user_id_1 = t.next_node THEN f.user_id_2
             ELSE f.user_id_1
        END,
        t.path || t.next_node
    FROM traverse t
    JOIN friendships f ON (f.user_id_1 = t.next_node OR f.user_id_2 = t.next_node)
)
CYCLE current SET is_cycle USING path
SELECT * FROM traverse WHERE NOT is_cycle;
```

### 7.3 å¹¶è¡Œé€’å½’æŸ¥è¯¢ä¼˜åŒ–

```sql
-- PostgreSQL 18: æŸ¥çœ‹é€’å½’æŸ¥è¯¢æ˜¯å¦ä½¿ç”¨å¹¶è¡Œ
EXPLAIN (ANALYZE, VERBOSE)
WITH RECURSIVE large_tree AS (
    SELECT id, parent_id FROM big_organization WHERE parent_id IS NULL
    UNION ALL
    SELECT o.id, o.parent_id
    FROM big_organization o JOIN large_tree lt ON o.parent_id = lt.id
)
SELECT COUNT(*) FROM large_tree;

-- PostgreSQL 18 å¹¶è¡Œé€’å½’æç¤º
-- é€’å½’CTEç›®å‰ä¸æ”¯æŒå¹¶è¡Œæ‰§è¡Œï¼Œä½†ä¸»æŸ¥è¯¢å¯ä»¥å¹¶è¡Œ
-- å¤§æ•°æ®é›†å»ºè®®ä½¿ç”¨ç‰©åŒ–è§†å›¾æˆ–ltreeæ‰©å±•
```

---

## å…«ã€SQLite 3.45+ é€’å½’æŸ¥è¯¢ç‰¹æ€§ ğŸ†•

### 8.1 é€’å½’æ·±åº¦é™åˆ¶

```sql
-- SQLite: æŸ¥è¯¢å½“å‰é€’å½’æ·±åº¦é™åˆ¶
SELECT sqlite_compileoption_get(0);

-- SQLite: åœ¨åº”ç”¨ä»£ç ä¸­è®¾ç½®é€’å½’æ·±åº¦
-- sqlite3_limit(db, SQLITE_LIMIT_EXPR_DEPTH, 1000);

-- SQLite 3.45+: åœ¨æŸ¥è¯¢ä¸­æ˜¾å¼é™åˆ¶æ·±åº¦
WITH RECURSIVE cnt(x, depth) AS (
    SELECT 1, 1
    UNION ALL
    SELECT x+1, depth+1 FROM cnt WHERE depth < 100  -- æ˜¾å¼æ·±åº¦é™åˆ¶
)
SELECT * FROM cnt;
```

### 8.2 é€’å½’æŸ¥è¯¢æ€§èƒ½ä¼˜åŒ–

```sql
-- SQLite 3.45+: ä½¿ç”¨ç´¢å¼•ä¼˜åŒ–é€’å½’æŸ¥è¯¢
CREATE INDEX IF NOT EXISTS idx_friendships_user1 ON friendships(user_id_1);
CREATE INDEX IF NOT EXISTS idx_friendships_user2 ON friendships(user_id_2);

-- SQLite: åˆ†ææŸ¥è¯¢è®¡åˆ’
EXPLAIN QUERY PLAN
WITH RECURSIVE friend_chain AS (
    SELECT user_id_2 AS friend_id FROM friendships WHERE user_id_1 = 1
    UNION
    SELECT f.user_id_2
    FROM friendships f
    JOIN friend_chain fc ON f.user_id_1 = fc.friend_id
)
SELECT * FROM friend_chain;
```

---

## ä¹ã€é€’å½’æŸ¥è¯¢å½¢å¼åŒ–ç†è®ºè¡¥å…… ğŸ†•

### 9.1 æœ€å°å›ºå®šç‚¹è¯­ä¹‰å®Œæ•´è¯æ˜

```text
å®šç†ï¼šé€’å½’CTEè®¡ç®—æœ€å°å›ºå®šç‚¹
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

è®¾é€’å½’CTEå®šä¹‰ä¸º:
  WITH RECURSIVE T AS (B UNION ALL R(T))

å…¶ä¸­:
  B = åŸºç¡€æŸ¥è¯¢ (ä¸å¼•ç”¨T)
  R(T) = é€’å½’æŸ¥è¯¢ (å¼•ç”¨T)

å®šä¹‰è¿­ä»£åºåˆ—:
  Tâ‚€ = âˆ…
  Táµ¢â‚Šâ‚ = B âˆª R(Táµ¢)

å®šç†é™ˆè¿°:
  é€’å½’CTEçš„ç»“æœ = â‹ƒáµ¢â‚Œâ‚€^âˆ Táµ¢ = lfp(Î»X. B âˆª R(X))

è¯æ˜:
  1. å•è°ƒæ€§: X âŠ† Y âŸ¹ R(X) âŠ† R(Y) (ç”±SQLè¯­ä¹‰ä¿è¯)

  2. é€’å¢æ€§: Táµ¢ âŠ† Táµ¢â‚Šâ‚
     è¯: Tâ‚€ = âˆ… âŠ† B âŠ† B âˆª R(B) = Tâ‚
         å‡è®¾ Táµ¢â‚‹â‚ âŠ† Táµ¢
         åˆ™ R(Táµ¢â‚‹â‚) âŠ† R(Táµ¢) (å•è°ƒæ€§)
         æ•… Táµ¢ = B âˆª R(Táµ¢â‚‹â‚) âŠ† B âˆª R(Táµ¢) = Táµ¢â‚Šâ‚ âœ“

  3. æœ‰é™æ”¶æ•›: è‹¥å…³ç³»æœ‰é™ï¼Œåˆ™ âˆƒn: Tâ‚™ = Tâ‚™â‚Šâ‚
     è¯: Táµ¢ âŠ† æœ‰é™å…¨é›†Uï¼Œé€’å¢åºåˆ—å¿…æœ‰ä¸Šç•Œ

  4. å›ºå®šç‚¹: T* = â‹ƒáµ¢ Táµ¢ æ»¡è¶³ T* = B âˆª R(T*)
     è¯: T* = â‹ƒáµ¢ Táµ¢ = â‹ƒáµ¢ (B âˆª R(Táµ¢â‚‹â‚)) = B âˆª R(â‹ƒáµ¢â‚‹â‚ Táµ¢â‚‹â‚) = B âˆª R(T*)

  5. æœ€å°æ€§: âˆ€å›ºå®šç‚¹X: T* âŠ† X
     è¯: å½’çº³è¯æ˜ Táµ¢ âŠ† X
         åŸºç¡€: Tâ‚€ = âˆ… âŠ† X âœ“
         å½’çº³: Táµ¢ âŠ† X âŸ¹ Táµ¢â‚Šâ‚ = B âˆª R(Táµ¢) âŠ† B âˆª R(X) = X âœ“
         æ•… T* = â‹ƒáµ¢ Táµ¢ âŠ† X âœ“

âˆ´ é€’å½’CTEè®¡ç®—æœ€å°å›ºå®šç‚¹ âˆ
```

### 9.2 UNION vs UNION ALLè¯­ä¹‰å·®å¼‚

```text
å®šç†ï¼šUNIONä¸UNION ALLçš„è¯­ä¹‰å·®å¼‚
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

UNION ALLè¯­ä¹‰:
  Táµ¢â‚Šâ‚ = B âˆª R(Táµ¢)  (å…è®¸é‡å¤ï¼Œæ¯æ¬¡è¿­ä»£ä¿ç•™æ‰€æœ‰å…ƒç»„)

UNIONè¯­ä¹‰:
  Táµ¢â‚Šâ‚ = B âˆª R(Táµ¢ \ Táµ¢â‚‹â‚)  (å»é‡ï¼Œåªå¤„ç†æ–°å¢å…ƒç»„)

æ€§èƒ½å½±å“:
  - UNION ALL: å¯èƒ½äº§ç”ŸæŒ‡æ•°çº§é‡å¤ï¼Œéœ€æ‰‹åŠ¨å»é‡
  - UNION: è‡ªåŠ¨å»é‡ï¼Œä½†æ¯æ¬¡è¿­ä»£éœ€é¢å¤–æ’åº/å“ˆå¸Œ

PostgreSQLè¡Œä¸º:
  - WITH RECURSIVE + UNION ALL: æ ‡å‡†è¡Œä¸º
  - WITH RECURSIVE + UNION: è‡ªåŠ¨å»é‡ï¼Œæ¨èç”¨äºå›¾éå†

SQLiteè¡Œä¸º:
  - åŒPostgreSQLï¼ŒUNIONè‡ªåŠ¨å»é‡
```

---

## åã€ç›¸å…³èµ„æº

### ç›¸å…³æ–‡æ¡£

- [å…¬å…±è¡¨è¡¨è¾¾å¼(CTE)](./05.02-å…¬å…±è¡¨è¡¨è¾¾å¼(CTE).md) - CTEè¯¦è§£ä¸å®Œæ•´æ¡ˆä¾‹
- [01.06-æ•°å­¦åŸºç¡€åˆ°SQLå› æœé“¾](../01-ç†è®ºåŸºç¡€/01.06-æ•°å­¦åŸºç¡€åˆ°SQLå› æœé“¾.md) - å›ºå®šç‚¹ç†è®º
- [03.08-æ‰§è¡Œå¼•æ“å½¢å¼åŒ–ç†è®º](../03-å½¢å¼åŒ–æ¨¡å‹/03.08-æ‰§è¡Œå¼•æ“å½¢å¼åŒ–ç†è®º.md) - é€’å½’ç®—å­å®ç°

### å¤–éƒ¨èµ„æº

- [PostgreSQL 18 Recursive Queries](https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-RECURSIVE)
- [SQLite Recursive Common Table Expressions](https://www.sqlite.org/lang_with.html#recursivecte)

---

**ç»´æŠ¤è€…**: SQL Standards Team
**æœ€åæ›´æ–°**: 2025-12-01
