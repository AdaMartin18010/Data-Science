# é«˜çº§SQLæŠ€å·§ä¸æ€§èƒ½æ¨¡å¼

> **åˆ›å»ºæ—¥æœŸ**ï¼š2025-12-04
> **ç‰ˆæœ¬**ï¼šPostgreSQL 18 / MySQL 8.4 / SQLite 3.47.x
> **éš¾åº¦**ï¼šâ­â­â­â­â­

---

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£æ±‡æ€»é«˜çº§SQLæŠ€å·§å’Œæ€§èƒ½ä¼˜åŒ–æ¨¡å¼ï¼Œé€‚ç”¨äºæœ‰ç»éªŒçš„å¼€å‘è€…ã€‚

---

## ğŸ“‘ ç›®å½•

- [é«˜çº§SQLæŠ€å·§ä¸æ€§èƒ½æ¨¡å¼](#é«˜çº§sqlæŠ€å·§ä¸æ€§èƒ½æ¨¡å¼)
  - [ğŸ“‹ æ¦‚è¿°](#-æ¦‚è¿°)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [ä¸€ã€çª—å£å‡½æ•°é«˜çº§æŠ€å·§](#ä¸€çª—å£å‡½æ•°é«˜çº§æŠ€å·§)
    - [1.1 æ»‘åŠ¨çª—å£è®¡ç®—](#11-æ»‘åŠ¨çª—å£è®¡ç®—)
    - [1.2 Gapå¡«å……ä¸æ’å€¼](#12-gapå¡«å……ä¸æ’å€¼)
    - [1.3 ä¼šè¯åŒ–ï¼ˆSessionizationï¼‰](#13-ä¼šè¯åŒ–sessionization)
  - [äºŒã€CTEé«˜çº§æ¨¡å¼](#äºŒcteé«˜çº§æ¨¡å¼)
    - [2.1 é€’å½’ç”Ÿæˆåºåˆ—](#21-é€’å½’ç”Ÿæˆåºåˆ—)
    - [2.2 å›¾éå†ç®—æ³•](#22-å›¾éå†ç®—æ³•)
    - [2.3 å±‚æ¬¡æ•°æ®æ‰å¹³åŒ–](#23-å±‚æ¬¡æ•°æ®æ‰å¹³åŒ–)
  - [ä¸‰ã€æ€§èƒ½ä¼˜åŒ–é«˜çº§æ¨¡å¼](#ä¸‰æ€§èƒ½ä¼˜åŒ–é«˜çº§æ¨¡å¼)
    - [3.1 ç´¢å¼•ä¼˜åŒ–æŠ€å·§](#31-ç´¢å¼•ä¼˜åŒ–æŠ€å·§)
    - [3.2 å­æŸ¥è¯¢ä¼˜åŒ–](#32-å­æŸ¥è¯¢ä¼˜åŒ–)
    - [3.3 æ‰¹é‡æ“ä½œä¼˜åŒ–](#33-æ‰¹é‡æ“ä½œä¼˜åŒ–)
  - [å››ã€SQLåæ¨¡å¼ä¸è§£å†³æ–¹æ¡ˆ](#å››sqlåæ¨¡å¼ä¸è§£å†³æ–¹æ¡ˆ)
    - [4.1 N+1æŸ¥è¯¢é—®é¢˜](#41-n1æŸ¥è¯¢é—®é¢˜)
    - [4.2 éšå¼ç±»å‹è½¬æ¢](#42-éšå¼ç±»å‹è½¬æ¢)
    - [4.3 è¿‡åº¦ä½¿ç”¨OR](#43-è¿‡åº¦ä½¿ç”¨or)

---

## ä¸€ã€çª—å£å‡½æ•°é«˜çº§æŠ€å·§

### 1.1 æ»‘åŠ¨çª—å£è®¡ç®—

```sql
-- è®¡ç®—7æ—¥ç§»åŠ¨å¹³å‡ï¼ˆé«˜æ•ˆå®ç°ï¼‰

SELECT
    date,
    revenue,
    -- æ ‡å‡†ç§»åŠ¨å¹³å‡
    AVG(revenue) OVER (
        ORDER BY date
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS ma_7day,
    -- åŠ æƒç§»åŠ¨å¹³å‡ï¼ˆè¿‘æœŸæƒé‡æ›´å¤§ï¼‰
    (
        revenue * 7 +
        LAG(revenue, 1) OVER (ORDER BY date) * 6 +
        LAG(revenue, 2) OVER (ORDER BY date) * 5 +
        LAG(revenue, 3) OVER (ORDER BY date) * 4 +
        LAG(revenue, 4) OVER (ORDER BY date) * 3 +
        LAG(revenue, 5) OVER (ORDER BY date) * 2 +
        LAG(revenue, 6) OVER (ORDER BY date) * 1
    ) / 28.0 AS wma_7day,
    -- æŒ‡æ•°ç§»åŠ¨å¹³å‡ï¼ˆEMAï¼‰
    revenue - LAG(revenue) OVER (ORDER BY date) AS daily_change
FROM daily_sales
ORDER BY date;

-- EMAé€’å½’è®¡ç®—ï¼ˆéœ€è¦CTEï¼‰
WITH RECURSIVE ema AS (
    SELECT
        date,
        revenue,
        revenue AS ema_value,
        ROW_NUMBER() OVER (ORDER BY date) AS rn
    FROM daily_sales
    WHERE date = (SELECT MIN(date) FROM daily_sales)

    UNION ALL

    SELECT
        s.date,
        s.revenue,
        -- EMAå…¬å¼: EMA_today = Î± * Price_today + (1-Î±) * EMA_yesterday
        0.3 * s.revenue + 0.7 * e.ema_value AS ema_value,
        e.rn + 1
    FROM daily_sales s
    JOIN ema e ON s.date = e.date + INTERVAL '1 day'
)
SELECT date, revenue, ema_value
FROM ema
ORDER BY date;
```

### 1.2 Gapå¡«å……ä¸æ’å€¼

```sql
-- å¡«å……æ—¶é—´åºåˆ—ä¸­çš„ç¼ºå¤±å€¼

WITH RECURSIVE date_series AS (
    -- ç”Ÿæˆè¿ç»­æ—¥æœŸåºåˆ—
    SELECT DATE('2025-01-01') AS date
    UNION ALL
    SELECT DATE(date, '+1 day')
    FROM date_series
    WHERE date < '2025-12-31'
),
filled_data AS (
    SELECT
        ds.date,
        COALESCE(s.revenue, 0) AS revenue,
        -- å‰å‘å¡«å……ï¼ˆä½¿ç”¨ä¸Šä¸€ä¸ªéNULLå€¼ï¼‰
        COALESCE(
            s.revenue,
            LAG(s.revenue) IGNORE NULLS OVER (ORDER BY ds.date)
        ) AS revenue_ffill,
        -- åå‘å¡«å……
        COALESCE(
            s.revenue,
            LEAD(s.revenue) IGNORE NULLS OVER (ORDER BY ds.date)
        ) AS revenue_bfill
    FROM date_series ds
    LEFT JOIN daily_sales s ON ds.date = s.date
)
SELECT
    date,
    revenue,
    revenue_ffill,
    revenue_bfill,
    -- çº¿æ€§æ’å€¼
    (revenue_ffill + revenue_bfill) / 2.0 AS revenue_interpolated
FROM filled_data;
```

### 1.3 ä¼šè¯åŒ–ï¼ˆSessionizationï¼‰

```sql
-- å°†ç”¨æˆ·äº‹ä»¶åˆ’åˆ†ä¸ºä¼šè¯ï¼ˆ30åˆ†é’Ÿæ— æ´»åŠ¨å³æ–°ä¼šè¯ï¼‰

WITH events_with_gaps AS (
    SELECT
        user_id,
        event_time,
        event_type,
        -- è®¡ç®—ä¸ä¸Šä¸€ä¸ªäº‹ä»¶çš„æ—¶é—´å·®
        TIMESTAMPDIFF(MINUTE,
            LAG(event_time) OVER (PARTITION BY user_id ORDER BY event_time),
            event_time
        ) AS minutes_since_last
    FROM user_events
),
session_starts AS (
    SELECT
        user_id,
        event_time,
        event_type,
        -- æ ‡è®°ä¼šè¯å¼€å§‹ï¼ˆé¦–ä¸ªäº‹ä»¶æˆ–è·ç¦»ä¸Šæ¬¡>30åˆ†é’Ÿï¼‰
        CASE
            WHEN minutes_since_last IS NULL THEN 1
            WHEN minutes_since_last > 30 THEN 1
            ELSE 0
        END AS is_session_start
    FROM events_with_gaps
),
sessions AS (
    SELECT
        user_id,
        event_time,
        event_type,
        -- ç´¯åŠ ä¼šè¯å¼€å§‹æ ‡è®°å¾—åˆ°session_id
        SUM(is_session_start) OVER (
            PARTITION BY user_id
            ORDER BY event_time
        ) AS session_id
    FROM session_starts
)
SELECT
    user_id,
    session_id,
    MIN(event_time) AS session_start,
    MAX(event_time) AS session_end,
    COUNT(*) AS event_count,
    TIMESTAMPDIFF(MINUTE, MIN(event_time), MAX(event_time)) AS duration_minutes
FROM sessions
GROUP BY user_id, session_id
ORDER BY user_id, session_id;
```

---

## äºŒã€CTEé«˜çº§æ¨¡å¼

### 2.1 é€’å½’ç”Ÿæˆåºåˆ—

```sql
-- ç”Ÿæˆ1åˆ°100çš„æ•°å­—åºåˆ—ï¼ˆSQLiteï¼‰
WITH RECURSIVE nums(n) AS (
    SELECT 1
    UNION ALL
    SELECT n + 1 FROM nums WHERE n < 100
)
SELECT n FROM nums;

-- ç”Ÿæˆæ—¥æœŸåºåˆ—ï¼ˆPostgreSQLï¼‰
WITH RECURSIVE dates AS (
    SELECT DATE '2025-01-01' AS d
    UNION ALL
    SELECT d + INTERVAL '1 day'
    FROM dates
    WHERE d < '2025-12-31'
)
SELECT d, TO_CHAR(d, 'Day') AS day_name
FROM dates;

-- ç”Ÿæˆæ–æ³¢é‚£å¥‘æ•°åˆ—
WITH RECURSIVE fib(n, a, b) AS (
    SELECT 1, 0, 1
    UNION ALL
    SELECT n + 1, b, a + b
    FROM fib
    WHERE n < 20
)
SELECT n, b AS fibonacci
FROM fib;
```

### 2.2 å›¾éå†ç®—æ³•

```sql
-- æŸ¥æ‰¾ç¤¾äº¤ç½‘ç»œä¸­çš„Nåº¦å¥½å‹

WITH RECURSIVE friend_network(user_id, friend_id, degree) AS (
    -- èµ·å§‹ç”¨æˆ·
    SELECT 1 AS user_id, 1 AS friend_id, 0 AS degree

    UNION

    -- é€’å½’æŸ¥æ‰¾æœ‹å‹çš„æœ‹å‹
    SELECT
        fn.user_id,
        f.friend_id,
        fn.degree + 1
    FROM friend_network fn
    JOIN friendships f ON fn.friend_id = f.user_id
    WHERE fn.degree < 3  -- é™åˆ¶ä¸º3åº¦å¥½å‹
        AND f.friend_id != fn.user_id  -- æ’é™¤è‡ªå·±
)
SELECT DISTINCT friend_id, MIN(degree) AS closest_degree
FROM friend_network
WHERE user_id = 1 AND friend_id != 1
GROUP BY friend_id
ORDER BY closest_degree, friend_id;

-- æŸ¥æ‰¾æœ€çŸ­è·¯å¾„ï¼ˆå¸¦è·¯å¾„è®°å½•ï¼‰

WITH RECURSIVE paths(from_id, to_id, path, total_distance, depth) AS (
    SELECT
        from_city AS from_id,
        to_city AS to_id,
        ARRAY[from_city, to_city] AS path,
        distance AS total_distance,
        1 AS depth
    FROM roads
    WHERE from_city = 1  -- èµ·ç‚¹

    UNION ALL

    SELECT
        p.from_id,
        r.to_city,
        p.path || r.to_city,
        p.total_distance + r.distance,
        p.depth + 1
    FROM paths p
    JOIN roads r ON p.to_id = r.from_city
    WHERE r.to_city != ALL(p.path)  -- é¿å…å¾ªç¯
        AND p.depth < 10  -- é™åˆ¶æ·±åº¦
)
SELECT from_id, to_id, path, total_distance
FROM paths
WHERE to_id = 100  -- ç»ˆç‚¹
ORDER BY total_distance
LIMIT 1;  -- æœ€çŸ­è·¯å¾„
```

### 2.3 å±‚æ¬¡æ•°æ®æ‰å¹³åŒ–

```sql
-- å°†æ ‘å½¢ç»„ç»‡ç»“æ„æ‰å¹³åŒ–ä¸ºä¸€çº§åˆ—è¡¨ï¼ˆå«å®Œæ•´è·¯å¾„ï¼‰

WITH RECURSIVE org_flat AS (
    -- æ ¹èŠ‚ç‚¹
    SELECT
        id,
        name,
        parent_id,
        name AS full_path,
        0 AS level,
        CAST(id AS TEXT) AS id_path
    FROM organizations
    WHERE parent_id IS NULL

    UNION ALL

    -- é€’å½’å­èŠ‚ç‚¹
    SELECT
        o.id,
        o.name,
        o.parent_id,
        of.full_path || ' > ' || o.name AS full_path,
        of.level + 1,
        of.id_path || '.' || CAST(o.id AS TEXT)
    FROM organizations o
    JOIN org_flat of ON o.parent_id = of.id
)
SELECT id, name, level, full_path, id_path
FROM org_flat
ORDER BY id_path;

-- ç»“æœç¤ºä¾‹ï¼š
-- id | name      | level | full_path                    | id_path
-- 1  | å…¬å¸      | 0     | å…¬å¸                         | 1
-- 2  | ç ”å‘éƒ¨    | 1     | å…¬å¸ > ç ”å‘éƒ¨                | 1.2
-- 5  | å‰ç«¯ç»„    | 2     | å…¬å¸ > ç ”å‘éƒ¨ > å‰ç«¯ç»„       | 1.2.5
```

---

## ä¸‰ã€æ€§èƒ½ä¼˜åŒ–é«˜çº§æ¨¡å¼

### 3.1 ç´¢å¼•ä¼˜åŒ–æŠ€å·§

```sql
-- æŠ€å·§1: è¦†ç›–ç´¢å¼•ï¼ˆé¿å…å›è¡¨ï¼‰

-- åä¾‹å­
CREATE INDEX idx_users_age ON users(age);
SELECT id, name, age FROM users WHERE age > 25;
-- æŸ¥è¯¢è¿‡ç¨‹: ç´¢å¼•æ‰«æ â†’ å›è¡¨è·å–name â†’ è¿”å›ç»“æœ

-- å¥½ä¾‹å­ï¼šè¦†ç›–ç´¢å¼•
CREATE INDEX idx_users_age_name ON users(age, id, name);
SELECT id, name, age FROM users WHERE age > 25;
-- æŸ¥è¯¢è¿‡ç¨‹: ç´¢å¼•æ‰«æï¼ˆæ‰€æœ‰åˆ—éƒ½åœ¨ç´¢å¼•ä¸­ï¼‰â†’ ç›´æ¥è¿”å›
-- æ€§èƒ½æå‡: 50-70%

-- æŠ€å·§2: éƒ¨åˆ†ç´¢å¼•ï¼ˆèŠ‚çœç©ºé—´ï¼‰

-- åä¾‹å­
CREATE INDEX idx_orders_status ON orders(status);
-- ç´¢å¼•å¤§å°: æ‰€æœ‰è¡Œ

-- å¥½ä¾‹å­
CREATE INDEX idx_orders_pending ON orders(status)
WHERE status IN ('pending', 'processing');
-- ç´¢å¼•å¤§å°: ä»…å¾…å¤„ç†è®¢å•ï¼ˆå¯èƒ½åªæœ‰5%ï¼‰
-- ç©ºé—´èŠ‚çœ: 95%

-- æŠ€å·§3: å‡½æ•°ç´¢å¼•

-- PostgreSQL: æ”¯æŒè¡¨è¾¾å¼ç´¢å¼•
CREATE INDEX idx_users_lower_email ON users(LOWER(email));
SELECT * FROM users WHERE LOWER(email) = 'alice@example.com';
-- ä½¿ç”¨ç´¢å¼•ï¼Œå¤§å°å†™ä¸æ•æ„ŸæŸ¥è¯¢

-- æŠ€å·§4: å¤šåˆ—ç´¢å¼•é¡ºåº

-- åä¾‹å­
CREATE INDEX idx_bad ON orders(status, created_at, user_id);
SELECT * FROM orders WHERE user_id = 123 AND status = 'paid';
-- æ— æ³•ä½¿ç”¨ç´¢å¼•ï¼ˆuser_idä¸æ˜¯ç¬¬ä¸€åˆ—ï¼‰

-- å¥½ä¾‹å­
CREATE INDEX idx_good ON orders(user_id, status, created_at);
SELECT * FROM orders WHERE user_id = 123 AND status = 'paid'
ORDER BY created_at DESC;
-- å®Œç¾ä½¿ç”¨ç´¢å¼•ï¼ˆæ‰€æœ‰åˆ—éƒ½åœ¨ç´¢å¼•ä¸­ä¸”é¡ºåºåŒ¹é…ï¼‰

-- ç´¢å¼•åˆ—é¡ºåºåŸåˆ™ï¼š
-- 1. ç­‰å€¼æŸ¥è¯¢åˆ—åœ¨å‰ï¼ˆWHERE col = ?ï¼‰
-- 2. èŒƒå›´æŸ¥è¯¢åˆ—åœ¨åï¼ˆWHERE col > ?ï¼‰
-- 3. æ’åºåˆ—æ”¾æœ€åï¼ˆORDER BY colï¼‰
```

### 3.2 å­æŸ¥è¯¢ä¼˜åŒ–

```sql
-- åæ¨¡å¼ï¼šç›¸å…³å­æŸ¥è¯¢ï¼ˆCorrelated Subqueryï¼‰

-- æ…¢æŸ¥è¯¢ï¼ˆO(nÂ²)å¤æ‚åº¦ï¼‰
SELECT
    u.id,
    u.name,
    (SELECT COUNT(*) FROM orders o WHERE o.user_id = u.id) AS order_count
FROM users u;
-- æ¯ä¸ªç”¨æˆ·éƒ½æ‰§è¡Œä¸€æ¬¡å­æŸ¥è¯¢

-- ä¼˜åŒ–æ–¹æ¡ˆ1: JOINï¼ˆO(n)å¤æ‚åº¦ï¼‰
SELECT
    u.id,
    u.name,
    COUNT(o.order_id) AS order_count
FROM users u
LEFT JOIN orders o ON u.user_id = o.user_id
GROUP BY u.id, u.name;
-- ä¸€æ¬¡JOINï¼Œæ€§èƒ½æå‡10-100å€

-- ä¼˜åŒ–æ–¹æ¡ˆ2: çª—å£å‡½æ•°
SELECT DISTINCT
    u.id,
    u.name,
    COUNT(o.order_id) OVER (PARTITION BY u.id) AS order_count
FROM users u
LEFT JOIN orders o ON u.user_id = o.user_id;

-- åæ¨¡å¼ï¼šEXISTSåœ¨SELECTä¸­

-- æ…¢æŸ¥è¯¢
SELECT
    p.id,
    p.name,
    EXISTS(SELECT 1 FROM inventory i WHERE i.product_id = p.id AND i.stock > 0) AS in_stock
FROM products p;

-- ä¼˜åŒ–æ–¹æ¡ˆ: LEFT JOIN + CASE
SELECT
    p.id,
    p.name,
    CASE WHEN i.product_id IS NOT NULL THEN 1 ELSE 0 END AS in_stock
FROM products p
LEFT JOIN (
    SELECT DISTINCT product_id FROM inventory WHERE stock > 0
) i ON p.id = i.product_id;
```

### 3.3 æ‰¹é‡æ“ä½œä¼˜åŒ–

```sql
-- æ‰¹é‡UPSERTï¼ˆPostgreSQL 18ï¼‰

-- æ–¹æ¡ˆ1: INSERT ... ON CONFLICTï¼ˆåŸå­æ€§ï¼‰
INSERT INTO products (id, name, price, stock)
VALUES
    (1, 'Product1', 10.99, 100),
    (2, 'Product2', 20.99, 50),
    ...  -- 1000è¡Œ
ON CONFLICT (id) DO UPDATE SET
    name = EXCLUDED.name,
    price = EXCLUDED.price,
    stock = EXCLUDED.stock,
    updated_at = CURRENT_TIMESTAMP;

-- æ–¹æ¡ˆ2: MERGEï¼ˆSQL:2023æ ‡å‡†ï¼ŒSQL Serveræ”¯æŒï¼‰
MERGE INTO products AS target
USING (VALUES
    (1, 'Product1', 10.99, 100),
    (2, 'Product2', 20.99, 50)
) AS source(id, name, price, stock)
ON target.id = source.id
WHEN MATCHED THEN
    UPDATE SET name = source.name, price = source.price, stock = source.stock
WHEN NOT MATCHED THEN
    INSERT (id, name, price, stock) VALUES (source.id, source.name, source.price, source.stock);

-- æ–¹æ¡ˆ3: ä¸´æ—¶è¡¨+JOINæ›´æ–°ï¼ˆæ‰€æœ‰æ•°æ®åº“é€šç”¨ï¼‰
BEGIN;

CREATE TEMP TABLE temp_updates (
    id INTEGER,
    name TEXT,
    price DECIMAL,
    stock INTEGER
);

-- æ‰¹é‡æ’å…¥ä¸´æ—¶è¡¨
INSERT INTO temp_updates VALUES
    (1, 'Product1', 10.99, 100),
    (2, 'Product2', 20.99, 50),
    ...;

-- UPDATE from JOIN
UPDATE products p
SET
    name = t.name,
    price = t.price,
    stock = t.stock
FROM temp_updates t
WHERE p.id = t.id;

-- INSERT ä¸å­˜åœ¨çš„è¡Œ
INSERT INTO products (id, name, price, stock)
SELECT id, name, price, stock
FROM temp_updates t
WHERE NOT EXISTS (SELECT 1 FROM products p WHERE p.id = t.id);

COMMIT;

-- æ€§èƒ½å¯¹æ¯”ï¼ˆ100Kè¡Œï¼‰ï¼š
-- é€è¡ŒUPSERT: 120ç§’
-- æ–¹æ¡ˆ1: 8ç§’ï¼ˆ15x fasterï¼‰
-- æ–¹æ¡ˆ2: 10ç§’ï¼ˆ12x fasterï¼‰
-- æ–¹æ¡ˆ3: 12ç§’ï¼ˆ10x fasterï¼‰
```

---

## å››ã€SQLåæ¨¡å¼ä¸è§£å†³æ–¹æ¡ˆ

### 4.1 N+1æŸ¥è¯¢é—®é¢˜

```python
# åæ¨¡å¼ï¼šN+1æŸ¥è¯¢

# åä¾‹å­ï¼ˆDjango ORMï¼‰
users = User.objects.all()  # 1æ¬¡æŸ¥è¯¢
for user in users:
    orders = user.orders.all()  # Næ¬¡æŸ¥è¯¢ï¼ˆæ¯ä¸ªç”¨æˆ·1æ¬¡ï¼‰
    print(f"{user.name}: {len(orders)} orders")
# æ€»æŸ¥è¯¢æ•°: 1 + N

# ä¼˜åŒ–æ–¹æ¡ˆ1: JOINé¢„åŠ è½½
users = User.objects.prefetch_related('orders').all()  # 2æ¬¡æŸ¥è¯¢
for user in users:
    orders = user.orders.all()  # æ— é¢å¤–æŸ¥è¯¢
    print(f"{user.name}: {len(orders)} orders")
# æ€»æŸ¥è¯¢æ•°: 2ï¼ˆ1æ¬¡users + 1æ¬¡ordersï¼‰

# ä¼˜åŒ–æ–¹æ¡ˆ2: å•æ¬¡èšåˆæŸ¥è¯¢
cursor.execute("""
    SELECT u.id, u.name, COUNT(o.id) AS order_count
    FROM users u
    LEFT JOIN orders o ON u.id = o.user_id
    GROUP BY u.id, u.name
""")
# æ€»æŸ¥è¯¢æ•°: 1
```

### 4.2 éšå¼ç±»å‹è½¬æ¢

```sql
-- åæ¨¡å¼ï¼šéšå¼ç±»å‹è½¬æ¢å¯¼è‡´ç´¢å¼•å¤±æ•ˆ

-- åä¾‹å­
CREATE INDEX idx_users_id_str ON users(id_str);  -- id_stræ˜¯TEXTç±»å‹
SELECT * FROM users WHERE id_str = 123;  -- æ•°å­—æŸ¥è¯¢TEXTåˆ—
-- ç´¢å¼•å¤±æ•ˆï¼å…¨è¡¨æ‰«æ

-- å¥½ä¾‹å­
SELECT * FROM users WHERE id_str = '123';  -- æ˜¾å¼è½¬æ¢ä¸ºTEXT
-- ä½¿ç”¨ç´¢å¼•

-- åä¾‹å­2
CREATE INDEX idx_created ON orders(created_at);  -- TIMESTAMP
SELECT * FROM orders WHERE created_at::DATE = '2025-12-04';  -- å¯¹åˆ—åº”ç”¨å‡½æ•°
-- ç´¢å¼•å¤±æ•ˆï¼

-- å¥½ä¾‹å­
SELECT * FROM orders
WHERE created_at >= '2025-12-04 00:00:00'
    AND created_at < '2025-12-05 00:00:00';
-- ä½¿ç”¨ç´¢å¼•èŒƒå›´æ‰«æ
```

### 4.3 è¿‡åº¦ä½¿ç”¨OR

```sql
-- åæ¨¡å¼ï¼šå¤šä¸ªORæ¡ä»¶

-- æ…¢æŸ¥è¯¢
SELECT * FROM users
WHERE city = 'NYC'
    OR city = 'LA'
    OR city = 'SF'
    OR city = 'Boston';
-- å¯èƒ½æ— æ³•æœ‰æ•ˆä½¿ç”¨ç´¢å¼•

-- ä¼˜åŒ–æ–¹æ¡ˆ1: IN
SELECT * FROM users
WHERE city IN ('NYC', 'LA', 'SF', 'Boston');
-- æ›´å®¹æ˜“ä¼˜åŒ–

-- ä¼˜åŒ–æ–¹æ¡ˆ2: UNION ALLï¼ˆå¦‚æœORè¿æ¥ä¸åŒåˆ—ï¼‰
SELECT * FROM users WHERE city = 'NYC'
UNION ALL
SELECT * FROM users WHERE age > 60;
-- æ¯ä¸ªæŸ¥è¯¢éƒ½èƒ½ä½¿ç”¨å¯¹åº”ç´¢å¼•

-- ä¼˜åŒ–æ–¹æ¡ˆ3: ä¸´æ—¶è¡¨+JOINï¼ˆå¤§é‡ORï¼‰
CREATE TEMP TABLE target_cities (city TEXT);
INSERT INTO target_cities VALUES ('NYC'), ('LA'), ('SF'), ('Boston');

SELECT u.*
FROM users u
JOIN target_cities t ON u.city = t.city;
```

---

**æŠ€å·§æ€»ç»“**ï¼š

æœ¬æ–‡æ¡£æ¶µç›–ï¼š

- âœ… çª—å£å‡½æ•°é«˜çº§åº”ç”¨ï¼ˆç§»åŠ¨å¹³å‡/EMA/Gapå¡«å……/ä¼šè¯åŒ–ï¼‰
- âœ… CTEé«˜çº§æ¨¡å¼ï¼ˆåºåˆ—ç”Ÿæˆ/å›¾éå†/å±‚æ¬¡æ‰å¹³åŒ–ï¼‰
- âœ… æ€§èƒ½ä¼˜åŒ–æ¨¡å¼ï¼ˆè¦†ç›–ç´¢å¼•/æ‰¹é‡UPSERT/å­æŸ¥è¯¢ä¼˜åŒ–ï¼‰
- âœ… åæ¨¡å¼è¯†åˆ«ï¼ˆN+1æŸ¥è¯¢/ç±»å‹è½¬æ¢/ORæ»¥ç”¨ï¼‰

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0
**æœ€åæ›´æ–°**: 2025-12-04
**ç»´æŠ¤è€…**: SQL Standards Team
