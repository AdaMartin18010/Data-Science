# SQL图查询与递归CTE完整实战

> **创建日期**: 2025-12-04
> **标准**: SQL:2023 (WITH RECURSIVE)
> **难度**: ⭐⭐⭐⭐⭐

---

## 递归CTE语法

```sql
-- 递归CTE基本结构
WITH RECURSIVE cte_name(column_list) AS (
    -- 1. 基础查询（Anchor Query）
    SELECT ...
    FROM ...
    WHERE ...

    UNION [ALL]

    -- 2. 递归查询（Recursive Query）
    SELECT ...
    FROM cte_name  -- 引用自身
    JOIN ...
    WHERE ...  -- 终止条件
)
SELECT * FROM cte_name;
```

---

## 实战1：组织架构树（层级查询）

### 场景：查询员工的完整汇报链

```sql
-- 表结构
CREATE TABLE employees (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL,
    manager_id INTEGER,  -- 上级ID，CEO为NULL
    title TEXT,
    FOREIGN KEY (manager_id) REFERENCES employees(id)
);

-- 示例数据
INSERT INTO employees VALUES
    (1, 'Alice CEO', NULL, 'CEO'),
    (2, 'Bob CTO', 1, 'CTO'),
    (3, 'Charlie CFO', 1, 'CFO'),
    (4, 'David Manager', 2, 'Engineering Manager'),
    (5, 'Eve Engineer', 4, 'Senior Engineer'),
    (6, 'Frank Engineer', 4, 'Junior Engineer'),
    (7, 'Grace Accountant', 3, 'Senior Accountant');

-- 查询1：向上查找汇报链（Eve的所有上级）
WITH RECURSIVE reporting_chain AS (
    -- 基础：从Eve开始
    SELECT
        id,
        name,
        manager_id,
        title,
        0 AS level,  -- 层级
        name AS path  -- 路径
    FROM employees
    WHERE id = 5  -- Eve

    UNION ALL

    -- 递归：查找上级
    SELECT
        e.id,
        e.name,
        e.manager_id,
        e.title,
        rc.level + 1,
        e.name || ' > ' || rc.path  -- 构建路径
    FROM employees e
    JOIN reporting_chain rc ON e.id = rc.manager_id
)
SELECT
    level,
    name,
    title,
    path
FROM reporting_chain
ORDER BY level DESC;

-- 结果：
-- level | name        | title                | path
-- ------+-------------+---------------------+--------------------------------
--   3   | Alice CEO   | CEO                 | Alice CEO > Bob CTO > David Manager > Eve Engineer
--   2   | Bob CTO     | CTO                 | Bob CTO > David Manager > Eve Engineer
--   1   | David Manager| Engineering Manager | David Manager > Eve Engineer
--   0   | Eve Engineer | Senior Engineer    | Eve Engineer

-- 查询2：向下查找所有下属（Bob的所有下属）
WITH RECURSIVE subordinates AS (
    -- 基础：Bob自己
    SELECT
        id,
        name,
        manager_id,
        title,
        0 AS level
    FROM employees
    WHERE id = 2  -- Bob

    UNION ALL

    -- 递归：查找下属
    SELECT
        e.id,
        e.name,
        e.manager_id,
        e.title,
        s.level + 1
    FROM employees e
    JOIN subordinates s ON e.manager_id = s.id
)
SELECT
    level,
    name,
    title
FROM subordinates
ORDER BY level, name;

-- 结果：
-- level | name           | title
-- ------+----------------+---------------------
--   0   | Bob CTO        | CTO
--   1   | David Manager  | Engineering Manager
--   2   | Eve Engineer   | Senior Engineer
--   2   | Frank Engineer | Junior Engineer

-- 查询3：树形可视化
WITH RECURSIVE org_tree AS (
    SELECT
        id,
        name,
        manager_id,
        title,
        0 AS level,
        CAST(name AS TEXT) AS tree
    FROM employees
    WHERE manager_id IS NULL

    UNION ALL

    SELECT
        e.id,
        e.name,
        e.manager_id,
        e.title,
        ot.level + 1,
        ot.tree || '
   ' || REPEAT('  ', ot.level + 1) || '└─ ' || e.name
    FROM employees e
    JOIN org_tree ot ON e.manager_id = ot.id
)
SELECT tree FROM org_tree WHERE level = (SELECT MAX(level) FROM org_tree);

-- 结果：
-- tree
-- --------
-- Alice CEO
--   └─ Bob CTO
--     └─ David Manager
--       └─ Eve Engineer
--       └─ Frank Engineer
--   └─ Charlie CFO
--     └─ Grace Accountant
```

---

## 实战2：社交网络图（N度好友）

### 场景：查找共同好友、好友推荐

```sql
-- 表结构
CREATE TABLE friendships (
    user_id INTEGER NOT NULL,
    friend_id INTEGER NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (user_id, friend_id)
);

-- 双向关系（A-B = B-A）
CREATE TRIGGER friendship_bidirectional AFTER INSERT ON friendships
FOR EACH ROW
BEGIN
    INSERT OR IGNORE INTO friendships (user_id, friend_id)
    VALUES (NEW.friend_id, NEW.user_id);
END;

-- 示例数据（社交网络图）
--    1 --- 2 --- 3 --- 4
--    |     |     |
--    5 --- 6     7
--          |
--          8
INSERT INTO friendships (user_id, friend_id) VALUES
    (1, 2), (1, 5),
    (2, 3), (2, 6),
    (3, 4), (3, 7),
    (5, 6),
    (6, 8);

-- 查询1：N度好友（用户1的2度好友）
WITH RECURSIVE friend_graph AS (
    -- 基础：1度好友
    SELECT
        friend_id AS user_id,
        1 AS degree,
        CAST(1 AS TEXT) || ' -> ' || friend_id AS path
    FROM friendships
    WHERE user_id = 1

    UNION

    -- 递归：N度好友
    SELECT
        f.friend_id,
        fg.degree + 1,
        fg.path || ' -> ' || f.friend_id
    FROM friendships f
    JOIN friend_graph fg ON f.user_id = fg.user_id
    WHERE fg.degree < 2  -- 限制最多2度
        AND f.friend_id != 1  -- 排除自己
)
SELECT DISTINCT
    user_id,
    MIN(degree) AS shortest_degree,
    MIN(path) AS shortest_path
FROM friend_graph
GROUP BY user_id
ORDER BY shortest_degree, user_id;

-- 结果：
-- user_id | shortest_degree | shortest_path
-- --------+-----------------+-------------------
--    2    |       1         | 1 -> 2
--    5    |       1         | 1 -> 5
--    3    |       2         | 1 -> 2 -> 3
--    6    |       2         | 1 -> 2 -> 6

-- 查询2：共同好友（用户1和用户3的共同好友）
WITH user1_friends AS (
    SELECT friend_id FROM friendships WHERE user_id = 1
),
user3_friends AS (
    SELECT friend_id FROM friendships WHERE user_id = 3
)
SELECT
    f1.friend_id AS mutual_friend
FROM user1_friends f1
INNER JOIN user3_friends f3 ON f1.friend_id = f3.friend_id;

-- 结果：
-- mutual_friend
-- --------------
--       2

-- 查询3：好友推荐（2度好友但不是1度好友）
WITH RECURSIVE friend_graph AS (
    SELECT
        1 AS source_user,
        friend_id AS user_id,
        1 AS degree
    FROM friendships
    WHERE user_id = 1

    UNION

    SELECT
        fg.source_user,
        f.friend_id,
        fg.degree + 1
    FROM friendships f
    JOIN friend_graph fg ON f.user_id = fg.user_id
    WHERE fg.degree = 1
)
SELECT
    user_id AS recommended_friend,
    COUNT(*) AS mutual_friends_count
FROM friend_graph
WHERE degree = 2
    AND user_id NOT IN (SELECT friend_id FROM friendships WHERE user_id = 1)
    AND user_id != 1
GROUP BY user_id
ORDER BY mutual_friends_count DESC;

-- 结果：
-- recommended_friend | mutual_friends_count
-- -------------------+---------------------
--         3          |          1
--         6          |          2
```

---

## 实战3：最短路径（图算法）

### 场景：城市间最短路径

```sql
-- 表结构
CREATE TABLE routes (
    from_city TEXT NOT NULL,
    to_city TEXT NOT NULL,
    distance INTEGER NOT NULL,
    PRIMARY KEY (from_city, to_city)
);

-- 示例数据（无向图）
INSERT INTO routes VALUES
    ('A', 'B', 5),
    ('B', 'A', 5),
    ('A', 'C', 3),
    ('C', 'A', 3),
    ('B', 'C', 1),
    ('C', 'B', 1),
    ('B', 'D', 7),
    ('D', 'B', 7),
    ('C', 'D', 4),
    ('D', 'C', 4),
    ('C', 'E', 6),
    ('E', 'C', 6),
    ('D', 'E', 2),
    ('E', 'D', 2);

-- 查询：A到E的最短路径（Dijkstra算法简化版）
WITH RECURSIVE shortest_path AS (
    -- 基础：从A开始
    SELECT
        'A' AS city,
        0 AS total_distance,
        CAST('A' AS TEXT) AS path

    UNION ALL

    -- 递归：扩展路径
    SELECT
        r.to_city,
        sp.total_distance + r.distance,
        sp.path || ' -> ' || r.to_city
    FROM routes r
    JOIN shortest_path sp ON r.from_city = sp.city
    WHERE sp.path NOT LIKE '%' || r.to_city || '%'  -- 避免环路
        AND sp.total_distance + r.distance < 100  -- 防止无限递归
)
SELECT
    city AS destination,
    MIN(total_distance) AS shortest_distance,
    (
        SELECT path
        FROM shortest_path sp2
        WHERE sp2.city = sp1.city
            AND sp2.total_distance = MIN(sp1.total_distance)
        LIMIT 1
    ) AS shortest_path
FROM shortest_path sp1
WHERE city = 'E'
GROUP BY city;

-- 结果：
-- destination | shortest_distance | shortest_path
-- ------------+-------------------+-----------------
--      E      |        9          | A -> C -> B -> C -> D -> E

-- 优化：使用PostgreSQL SEARCH/CYCLE子句（SQL:2023）
WITH RECURSIVE shortest_path AS (
    SELECT
        'A' AS city,
        0 AS total_distance,
        ARRAY['A'] AS path

    UNION ALL

    SELECT
        r.to_city,
        sp.total_distance + r.distance,
        sp.path || r.to_city
    FROM routes r
    JOIN shortest_path sp ON r.from_city = sp.city
    WHERE NOT (r.to_city = ANY(sp.path))  -- 避免环路
)
SEARCH DEPTH FIRST BY city SET order_col  -- 深度优先
CYCLE city SET is_cycle USING path_arr  -- 环路检测
SELECT
    city,
    MIN(total_distance) AS shortest_distance
FROM shortest_path
WHERE city = 'E' AND NOT is_cycle
GROUP BY city;
```

---

## 实战4：物料清单（BOM爆炸）

### 场景：制造业BOM展开

```sql
-- 表结构
CREATE TABLE bom (
    product_id TEXT NOT NULL,
    component_id TEXT NOT NULL,
    quantity INTEGER NOT NULL,
    PRIMARY KEY (product_id, component_id)
);

-- 示例数据
-- Car
--   ├─ Engine (1)
--   │   ├─ Piston (4)
--   │   └─ Spark Plug (4)
--   ├─ Wheel (4)
--   │   └─ Tire (1)
--   └─ Body (1)

INSERT INTO bom VALUES
    ('Car', 'Engine', 1),
    ('Car', 'Wheel', 4),
    ('Car', 'Body', 1),
    ('Engine', 'Piston', 4),
    ('Engine', 'Spark Plug', 4),
    ('Wheel', 'Tire', 1);

-- 查询：Car的完整物料清单（带数量计算）
WITH RECURSIVE bom_explosion AS (
    -- 基础：顶层产品
    SELECT
        'Car' AS product_id,
        'Car' AS component_id,
        1 AS quantity,
        0 AS level,
        CAST('Car' AS TEXT) AS path

    UNION ALL

    -- 递归：展开子件
    SELECT
        be.product_id,
        b.component_id,
        be.quantity * b.quantity,  -- 数量累乘
        be.level + 1,
        be.path || ' > ' || b.component_id
    FROM bom b
    JOIN bom_explosion be ON b.product_id = be.component_id
)
SELECT
    level,
    component_id,
    SUM(quantity) AS total_quantity,
    MIN(path) AS sample_path
FROM bom_explosion
WHERE level > 0
GROUP BY level, component_id
ORDER BY level, component_id;

-- 结果：
-- level | component_id | total_quantity | sample_path
-- ------+--------------+----------------+-------------------------
--   1   | Body         |       1        | Car > Body
--   1   | Engine       |       1        | Car > Engine
--   1   | Wheel        |       4        | Car > Wheel
--   2   | Piston       |       4        | Car > Engine > Piston
--   2   | Spark Plug   |       4        | Car > Engine > Spark Plug
--   2   | Tire         |       4        | Car > Wheel > Tire

-- 采购清单（只包含叶子节点）
WITH RECURSIVE bom_explosion AS (
    SELECT
        'Car' AS product_id,
        'Car' AS component_id,
        1 AS quantity,
        0 AS level
    UNION ALL
    SELECT
        be.product_id,
        b.component_id,
        be.quantity * b.quantity,
        be.level + 1
    FROM bom b
    JOIN bom_explosion be ON b.product_id = be.component_id
)
SELECT
    component_id,
    SUM(quantity) AS total_quantity
FROM bom_explosion
WHERE component_id NOT IN (SELECT DISTINCT product_id FROM bom)
    AND component_id != 'Car'
GROUP BY component_id
ORDER BY component_id;

-- 结果：
-- component_id | total_quantity
-- -------------+---------------
--   Body       |       1
--   Piston     |       4
--   Spark Plug |       4
--   Tire       |       4
```

---

## 性能优化技巧

### 1. 使用UNION而不是UNION ALL（去重）

```sql
-- ✅ 避免重复访问节点
WITH RECURSIVE graph AS (
    ...
    UNION  -- 自动去重
    ...
)
```

### 2. 添加终止条件

```sql
-- ✅ 防止无限递归
WITH RECURSIVE cte AS (
    ...
    WHERE level < 10  -- 限制层级
        AND NOT is_cycle  -- 检测环路
)
```

### 3. 索引优化

```sql
-- ✅ 为递归JOIN的列创建索引
CREATE INDEX idx_employees_manager ON employees(manager_id);
CREATE INDEX idx_friendships_user ON friendships(user_id, friend_id);
```

### 4. PostgreSQL SEARCH/CYCLE子句

```sql
-- ✅ 使用SQL:2023标准的SEARCH和CYCLE
WITH RECURSIVE cte AS (
    ...
)
SEARCH DEPTH FIRST BY id SET order_col
CYCLE id SET is_cycle USING path_arr
SELECT ...;
```

---

**文档版本**: v1.0.0
**最后更新**: 2025-12-04
