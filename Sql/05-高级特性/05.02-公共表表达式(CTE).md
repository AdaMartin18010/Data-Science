# 公共表表达式(CTE)

> **创建日期**：2025-01-15
> **最后更新**：2025-01-16
> **版本**：v1.0.0
> **难度**：⭐⭐⭐
> **应用场景**：复杂查询简化、递归查询、查询可读性提升

---

## 📋 目录

- [公共表表达式(CTE)](#公共表表达式cte)
  - [📋 目录](#-目录)
  - [一、概述](#一概述)
    - [1.0 CTE历史背景](#10-cte历史背景)
    - [1.1 CTE应用场景决策树](#11-cte应用场景决策树)
    - [1.2 CTE vs 子查询对比矩阵](#12-cte-vs-子查询对比矩阵)
  - [二、CTE语法](#二cte语法)
    - [2.1 CTE的形式化定义](#21-cte的形式化定义)
    - [2.2 基本语法](#22-基本语法)
    - [2.3 示例](#23-示例)
  - [三、递归CTE](#三递归cte)
    - [3.1 递归CTE语法](#31-递归cte语法)
    - [3.2 递归CTE示例](#32-递归cte示例)
  - [四、CTE应用场景](#四cte应用场景)
    - [4.1 查询简化](#41-查询简化)
    - [4.1.1 场景示例1：复杂查询简化](#411-场景示例1复杂查询简化)
    - [4.1.2 场景示例2：多步骤数据分析](#412-场景示例2多步骤数据分析)
  - [五、性能考虑](#五性能考虑)
    - [5.1 性能优化](#51-性能优化)
  - [六、相关资源](#六相关资源)
    - [相关文档](#相关文档)

---

## 一、概述

**公共表表达式（CTE, Common Table Expression）**是SQL:1999引入的特性，用于定义临时的命名结果集。

**CTE特点**：

- 提高查询可读性
- 支持递归查询
- 可以多次引用

### 1.0 CTE历史背景

**CTE的发展历程**：

- **SQL:1999**：正式引入CTE（WITH子句），包括普通CTE和递归CTE（WITH RECURSIVE）
- **SQL:2003**：增强了CTE的功能，改进了递归CTE的语义
- **SQL:2008**：进一步完善了CTE的语法和性能优化
- **SQL:2011**：增强了CTE在复杂查询中的应用
- **SQL:2016**：改进了CTE的性能优化支持
- **SQL:2023**：进一步完善了CTE的语法和功能

**CTE的设计动机**：

CTE的设计是为了解决传统SQL在复杂查询中的局限性：

1. **查询可读性问题**：复杂的嵌套子查询难以理解和维护
2. **代码重复问题**：同一个子查询在查询中多次出现，导致代码重复
3. **递归查询需求**：需要处理层次结构和图数据，传统SQL难以实现
4. **查询组织问题**：需要更好的方式组织复杂查询的逻辑

**CTE与关系模型的关系**：

CTE可以看作是关系代数中"临时关系"概念的SQL实现。在关系代数中，我们可以定义中间关系并在后续操作中使用，CTE提供了类似的机制，允许在SQL查询中定义临时关系并在查询中引用。

### 1.1 CTE应用场景决策树

```mermaid
flowchart TD
    A[需要CTE?] --> B{查询是否复杂?}
    B -->|是| C{需要递归?}
    B -->|否| D[可能不需要CTE]
    C -->|是| E[使用WITH RECURSIVE]
    C -->|否| F{需要多次引用?}
    F -->|是| G[使用WITH CTE]
    F -->|否| H{需要提高可读性?}
    H -->|是| G
    H -->|否| D
    E --> I[递归CTE]
    G --> J[普通CTE]
```

### 1.2 CTE vs 子查询对比矩阵

| 特性 | CTE | 子查询 | 视图 | 临时表 |
|------|-----|--------|------|--------|
| **可读性** | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ |
| **性能** | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **递归支持** | ✅ | ❌ | ❌ | ⚠️ |
| **作用域** | 单查询 | 单查询 | 全局 | 会话 |
| **可维护性** | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ |

---

## 二、CTE语法

### 2.1 CTE的形式化定义

**CTE的BNF语法定义**（基于SQL:1999标准）：

```bnf
<with clause> ::=
    WITH [ RECURSIVE ] <with list>

<with list> ::=
    <with list element> [ { <comma> <with list element> }... ]

<with list element> ::=
    <query name> [ <left paren> <with column list> <right paren> ]
    AS <left paren> <query expression> <right paren>

<with column list> ::=
    <column name list>

<query name> ::=
    <identifier>
```

**CTE的语义定义**：

对于CTE `WITH cte_name AS (Q)`，CTE定义了一个临时关系$R_{cte}$，其中：

- $R_{cte}$是查询表达式$Q$的结果关系
- $R_{cte}$的作用域是包含该CTE的查询表达式
- 在查询表达式中，可以通过名称$cte\_name$引用$R_{cte}$

**递归CTE的语义定义**：

对于递归CTE `WITH RECURSIVE cte_name AS (Q)`，递归CTE定义了一个递归关系$R_{rec}$，其中：

- $R_{rec}$是递归查询表达式$Q$的固定点（fixed point）
- 递归查询表达式$Q$通常包含：
  - 基础查询（base case）：$Q_{base}$
  - 递归查询（recursive case）：$Q_{rec}$，引用$cte\_name$
- $R_{rec} = \mu X. (Q_{base} \cup Q_{rec}(X))$，其中$\mu$表示最小固定点操作符

### 2.2 基本语法

**CTE语法**：

```sql
WITH cte_name AS (
    SELECT ...
)
SELECT * FROM cte_name;
```

### 2.3 示例

**示例**：

```sql
WITH high_scores AS (
    SELECT * FROM Scores WHERE score > 90
)
SELECT * FROM high_scores;
```

---

## 三、递归CTE

### 3.1 递归CTE语法

**递归CTE**：

```sql
WITH RECURSIVE cte_name AS (
    -- 基础查询
    SELECT ...
    UNION ALL
    -- 递归查询
    SELECT ... FROM cte_name WHERE ...
)
SELECT * FROM cte_name;
```

### 3.2 递归CTE示例

**示例**：

```sql
WITH RECURSIVE hierarchy AS (
    SELECT id, name, parent_id, 0 as level
    FROM Employees WHERE parent_id IS NULL
    UNION ALL
    SELECT e.id, e.name, e.parent_id, h.level + 1
    FROM Employees e
    JOIN hierarchy h ON e.parent_id = h.id
)
SELECT * FROM hierarchy;
```

---

## 四、CTE应用场景

### 4.1 查询简化

### 4.1.1 场景示例1：复杂查询简化

**业务需求**：查询销售额超过10000的月份，并计算同比增长率。

**数据模型**：

```mermaid
erDiagram
    Sales {
        date date
        product_id int
        amount decimal
    }
```

**CTE查询实现**：

```sql
WITH monthly_sales AS (
    SELECT
        DATE_TRUNC('month', date) as month,
        SUM(amount) as total
    FROM Sales
    GROUP BY DATE_TRUNC('month', date)
),
high_sales_months AS (
    SELECT
        month,
        total,
        LAG(total, 12) OVER (ORDER BY month) as prev_year_total
    FROM monthly_sales
    WHERE total > 10000
)
SELECT
    month,
    total,
    prev_year_total,
    (total - prev_year_total) * 100.0 / prev_year_total as yoy_growth
FROM high_sales_months
ORDER BY month;
```

### 4.1.2 场景示例2：多步骤数据分析

**业务需求**：分析学生选课情况，找出选课数量最多的学生及其选课详情。

**数据模型**：

```mermaid
erDiagram
    Student ||--o{ Enrollment : "选课"
    Course ||--o{ Enrollment : "被选"
    Student {
        int student_id PK
        string name
    }
    Course {
        int course_id PK
        string course_name
    }
    Enrollment {
        int student_id FK
        int course_id FK
        int score
    }
```

**多步骤CTE查询实现**：

```sql
-- 步骤1：统计每个学生的选课数量
WITH student_course_count AS (
    SELECT
        student_id,
        COUNT(*) as course_count
    FROM Enrollment
    GROUP BY student_id
),
-- 步骤2：找出选课数量最多的学生
top_students AS (
    SELECT student_id
    FROM student_course_count
    WHERE course_count = (SELECT MAX(course_count) FROM student_course_count)
)
-- 步骤3：查询这些学生的选课详情
SELECT
    s.name,
    c.course_name,
    e.score
FROM top_students ts
JOIN Student s ON ts.student_id = s.student_id
JOIN Enrollment e ON s.student_id = e.student_id
JOIN Course c ON e.course_id = c.course_id
ORDER BY s.name, e.score DESC;
```

**CTE执行流程时序图**：

```mermaid
sequenceDiagram
    participant Client
    participant QueryEngine
    participant CTE1
    participant CTE2
    participant Storage

    Client->>QueryEngine: WITH CTE1 AS (...), CTE2 AS (...)
    QueryEngine->>CTE1: 执行第一个CTE
    CTE1->>Storage: 查询Enrollment表
    Storage-->>CTE1: 返回数据
    CTE1->>CTE1: 计算course_count
    CTE1-->>QueryEngine: 返回CTE1结果
    QueryEngine->>CTE2: 执行第二个CTE（引用CTE1）
    CTE2->>CTE2: 使用CTE1结果
    CTE2-->>QueryEngine: 返回CTE2结果
    QueryEngine->>Storage: 执行主查询（引用CTE2）
    Storage-->>QueryEngine: 返回最终结果
    QueryEngine-->>Client: 返回结果集
```

---

## 五、性能考虑

### 5.1 性能优化

**性能考虑**：

1. CTE可能被物化
2. 递归CTE需要注意终止条件
3. 合理使用索引

---

## 六、相关资源

### 相关文档

- [递归查询详解](./05.03-递归查询详解.md) - 递归查询
- [窗口函数详解](./05.01-窗口函数详解.md) - 窗口函数

---

**维护者**: SQL Standards Team
**最后更新**: 2025-01-16
