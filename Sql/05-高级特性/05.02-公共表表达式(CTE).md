# å…¬å…±è¡¨è¡¨è¾¾å¼(CTE)

> **åˆ›å»ºæ—¥æœŸ**ï¼š2025-01-15
> **æœ€åæ›´æ–°**ï¼š2025-01-16
> **ç‰ˆæœ¬**ï¼šv1.0.0
> **éš¾åº¦**ï¼šâ­â­â­
> **åº”ç”¨åœºæ™¯**ï¼šå¤æ‚æŸ¥è¯¢ç®€åŒ–ã€é€’å½’æŸ¥è¯¢ã€æŸ¥è¯¢å¯è¯»æ€§æå‡

---

## ğŸ“‹ ç›®å½•

- [å…¬å…±è¡¨è¡¨è¾¾å¼(CTE)](#å…¬å…±è¡¨è¡¨è¾¾å¼cte)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ä¸€ã€æ¦‚è¿°](#ä¸€æ¦‚è¿°)
    - [1.0 CTEå†å²èƒŒæ™¯](#10-cteå†å²èƒŒæ™¯)
    - [1.1 CTEåº”ç”¨åœºæ™¯å†³ç­–æ ‘](#11-cteåº”ç”¨åœºæ™¯å†³ç­–æ ‘)
    - [1.2 CTE vs å­æŸ¥è¯¢å¯¹æ¯”çŸ©é˜µ](#12-cte-vs-å­æŸ¥è¯¢å¯¹æ¯”çŸ©é˜µ)
  - [äºŒã€CTEè¯­æ³•](#äºŒcteè¯­æ³•)
    - [2.1 CTEçš„å½¢å¼åŒ–å®šä¹‰](#21-cteçš„å½¢å¼åŒ–å®šä¹‰)
    - [2.2 åŸºæœ¬è¯­æ³•](#22-åŸºæœ¬è¯­æ³•)
    - [2.3 ç¤ºä¾‹](#23-ç¤ºä¾‹)
  - [ä¸‰ã€é€’å½’CTE](#ä¸‰é€’å½’cte)
    - [3.1 é€’å½’CTEè¯­æ³•](#31-é€’å½’cteè¯­æ³•)
    - [3.2 é€’å½’CTEç¤ºä¾‹](#32-é€’å½’cteç¤ºä¾‹)
  - [å››ã€CTEåº”ç”¨åœºæ™¯](#å››cteåº”ç”¨åœºæ™¯)
    - [4.1 æŸ¥è¯¢ç®€åŒ–](#41-æŸ¥è¯¢ç®€åŒ–)
    - [4.1.1 åœºæ™¯ç¤ºä¾‹1ï¼šå¤æ‚æŸ¥è¯¢ç®€åŒ–](#411-åœºæ™¯ç¤ºä¾‹1å¤æ‚æŸ¥è¯¢ç®€åŒ–)
    - [4.1.2 åœºæ™¯ç¤ºä¾‹2ï¼šå¤šæ­¥éª¤æ•°æ®åˆ†æ](#412-åœºæ™¯ç¤ºä¾‹2å¤šæ­¥éª¤æ•°æ®åˆ†æ)
  - [äº”ã€æ€§èƒ½è€ƒè™‘](#äº”æ€§èƒ½è€ƒè™‘)
    - [5.1 æ€§èƒ½ä¼˜åŒ–](#51-æ€§èƒ½ä¼˜åŒ–)
  - [å…­ã€å®Œæ•´ä¸šåŠ¡æ¡ˆä¾‹ï¼šç»„ç»‡æ¶æ„æŸ¥è¯¢ ğŸ†•](#å…­å®Œæ•´ä¸šåŠ¡æ¡ˆä¾‹ç»„ç»‡æ¶æ„æŸ¥è¯¢-)
    - [6.1 ä¸šåŠ¡åœºæ™¯æè¿°](#61-ä¸šåŠ¡åœºæ™¯æè¿°)
    - [6.2 æ¡ˆä¾‹1ï¼šæŸ¥è¯¢å‘˜å·¥çš„å®Œæ•´æ±‡æŠ¥é“¾](#62-æ¡ˆä¾‹1æŸ¥è¯¢å‘˜å·¥çš„å®Œæ•´æ±‡æŠ¥é“¾)
    - [6.3 æ¡ˆä¾‹2ï¼šæŸ¥è¯¢ç®¡ç†è€…çš„æ‰€æœ‰ä¸‹å±](#63-æ¡ˆä¾‹2æŸ¥è¯¢ç®¡ç†è€…çš„æ‰€æœ‰ä¸‹å±)
    - [6.4 æ¡ˆä¾‹3ï¼šç»„ç»‡æ¶æ„å®Œæ•´å¯è§†åŒ–](#64-æ¡ˆä¾‹3ç»„ç»‡æ¶æ„å®Œæ•´å¯è§†åŒ–)
    - [6.5 æ€§èƒ½ä¼˜åŒ–ä¸æ‰§è¡Œè®¡åˆ’åˆ†æ](#65-æ€§èƒ½ä¼˜åŒ–ä¸æ‰§è¡Œè®¡åˆ’åˆ†æ)
    - [6.6 é€’å½’ç»ˆæ­¢æ¡ä»¶å½¢å¼åŒ–è¯æ˜](#66-é€’å½’ç»ˆæ­¢æ¡ä»¶å½¢å¼åŒ–è¯æ˜)
  - [ä¸ƒã€PostgreSQL 18 CTEæ–°ç‰¹æ€§ ğŸ†•](#ä¸ƒpostgresql-18-cteæ–°ç‰¹æ€§-)
    - [7.1 MATERIALIZEDæ§åˆ¶](#71-materializedæ§åˆ¶)
    - [7.2 SEARCHå’ŒCYCLEå­å¥ï¼ˆSQL:2023ï¼‰](#72-searchå’Œcycleå­å¥sql2023)
  - [å…«ã€SQLite 3.45+ CTEç‰¹æ€§ ğŸ†•](#å…«sqlite-345-cteç‰¹æ€§-)
    - [8.1 é€’å½’æŸ¥è¯¢åŸºæœ¬ç”¨æ³•](#81-é€’å½’æŸ¥è¯¢åŸºæœ¬ç”¨æ³•)
    - [8.2 WITHå­å¥çš„å¤šCTEç”¨æ³•](#82-withå­å¥çš„å¤šcteç”¨æ³•)
  - [ä¹ã€ç›¸å…³èµ„æº](#ä¹ç›¸å…³èµ„æº)
    - [ç›¸å…³æ–‡æ¡£](#ç›¸å…³æ–‡æ¡£)
    - [å¤–éƒ¨èµ„æº](#å¤–éƒ¨èµ„æº)

---

## ä¸€ã€æ¦‚è¿°

**å…¬å…±è¡¨è¡¨è¾¾å¼ï¼ˆCTE, Common Table Expressionï¼‰**æ˜¯SQL:1999å¼•å…¥çš„ç‰¹æ€§ï¼Œç”¨äºå®šä¹‰ä¸´æ—¶çš„å‘½åç»“æœé›†ã€‚

**CTEç‰¹ç‚¹**ï¼š

- æé«˜æŸ¥è¯¢å¯è¯»æ€§
- æ”¯æŒé€’å½’æŸ¥è¯¢
- å¯ä»¥å¤šæ¬¡å¼•ç”¨

### 1.0 CTEå†å²èƒŒæ™¯

**CTEçš„å‘å±•å†ç¨‹**ï¼š

- **SQL:1999**ï¼šæ­£å¼å¼•å…¥CTEï¼ˆWITHå­å¥ï¼‰ï¼ŒåŒ…æ‹¬æ™®é€šCTEå’Œé€’å½’CTEï¼ˆWITH RECURSIVEï¼‰
- **SQL:2003**ï¼šå¢å¼ºäº†CTEçš„åŠŸèƒ½ï¼Œæ”¹è¿›äº†é€’å½’CTEçš„è¯­ä¹‰
- **SQL:2008**ï¼šè¿›ä¸€æ­¥å®Œå–„äº†CTEçš„è¯­æ³•å’Œæ€§èƒ½ä¼˜åŒ–
- **SQL:2011**ï¼šå¢å¼ºäº†CTEåœ¨å¤æ‚æŸ¥è¯¢ä¸­çš„åº”ç”¨
- **SQL:2016**ï¼šæ”¹è¿›äº†CTEçš„æ€§èƒ½ä¼˜åŒ–æ”¯æŒ
- **SQL:2023**ï¼šè¿›ä¸€æ­¥å®Œå–„äº†CTEçš„è¯­æ³•å’ŒåŠŸèƒ½

**CTEçš„è®¾è®¡åŠ¨æœº**ï¼š

CTEçš„è®¾è®¡æ˜¯ä¸ºäº†è§£å†³ä¼ ç»ŸSQLåœ¨å¤æ‚æŸ¥è¯¢ä¸­çš„å±€é™æ€§ï¼š

1. **æŸ¥è¯¢å¯è¯»æ€§é—®é¢˜**ï¼šå¤æ‚çš„åµŒå¥—å­æŸ¥è¯¢éš¾ä»¥ç†è§£å’Œç»´æŠ¤
2. **ä»£ç é‡å¤é—®é¢˜**ï¼šåŒä¸€ä¸ªå­æŸ¥è¯¢åœ¨æŸ¥è¯¢ä¸­å¤šæ¬¡å‡ºç°ï¼Œå¯¼è‡´ä»£ç é‡å¤
3. **é€’å½’æŸ¥è¯¢éœ€æ±‚**ï¼šéœ€è¦å¤„ç†å±‚æ¬¡ç»“æ„å’Œå›¾æ•°æ®ï¼Œä¼ ç»ŸSQLéš¾ä»¥å®ç°
4. **æŸ¥è¯¢ç»„ç»‡é—®é¢˜**ï¼šéœ€è¦æ›´å¥½çš„æ–¹å¼ç»„ç»‡å¤æ‚æŸ¥è¯¢çš„é€»è¾‘

**CTEä¸å…³ç³»æ¨¡å‹çš„å…³ç³»**ï¼š

CTEå¯ä»¥çœ‹ä½œæ˜¯å…³ç³»ä»£æ•°ä¸­"ä¸´æ—¶å…³ç³»"æ¦‚å¿µçš„SQLå®ç°ã€‚åœ¨å…³ç³»ä»£æ•°ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸­é—´å…³ç³»å¹¶åœ¨åç»­æ“ä½œä¸­ä½¿ç”¨ï¼ŒCTEæä¾›äº†ç±»ä¼¼çš„æœºåˆ¶ï¼Œå…è®¸åœ¨SQLæŸ¥è¯¢ä¸­å®šä¹‰ä¸´æ—¶å…³ç³»å¹¶åœ¨æŸ¥è¯¢ä¸­å¼•ç”¨ã€‚

### 1.1 CTEåº”ç”¨åœºæ™¯å†³ç­–æ ‘

```mermaid
flowchart TD
    A[éœ€è¦CTE?] --> B{æŸ¥è¯¢æ˜¯å¦å¤æ‚?}
    B -->|æ˜¯| C{éœ€è¦é€’å½’?}
    B -->|å¦| D[å¯èƒ½ä¸éœ€è¦CTE]
    C -->|æ˜¯| E[ä½¿ç”¨WITH RECURSIVE]
    C -->|å¦| F{éœ€è¦å¤šæ¬¡å¼•ç”¨?}
    F -->|æ˜¯| G[ä½¿ç”¨WITH CTE]
    F -->|å¦| H{éœ€è¦æé«˜å¯è¯»æ€§?}
    H -->|æ˜¯| G
    H -->|å¦| D
    E --> I[é€’å½’CTE]
    G --> J[æ™®é€šCTE]
```

### 1.2 CTE vs å­æŸ¥è¯¢å¯¹æ¯”çŸ©é˜µ

| ç‰¹æ€§ | CTE | å­æŸ¥è¯¢ | è§†å›¾ | ä¸´æ—¶è¡¨ |
|------|-----|--------|------|--------|
| **å¯è¯»æ€§** | â­â­â­â­â­ | â­â­ | â­â­â­â­ | â­â­â­ |
| **æ€§èƒ½** | â­â­â­â­ | â­â­â­ | â­â­â­â­ | â­â­â­â­â­ |
| **é€’å½’æ”¯æŒ** | âœ… | âŒ | âŒ | âš ï¸ |
| **ä½œç”¨åŸŸ** | å•æŸ¥è¯¢ | å•æŸ¥è¯¢ | å…¨å±€ | ä¼šè¯ |
| **å¯ç»´æŠ¤æ€§** | â­â­â­â­â­ | â­â­ | â­â­â­â­ | â­â­â­ |

---

## äºŒã€CTEè¯­æ³•

### 2.1 CTEçš„å½¢å¼åŒ–å®šä¹‰

**CTEçš„BNFè¯­æ³•å®šä¹‰**ï¼ˆåŸºäºSQL:1999æ ‡å‡†ï¼‰ï¼š

```bnf
<with clause> ::=
    WITH [ RECURSIVE ] <with list>

<with list> ::=
    <with list element> [ { <comma> <with list element> }... ]

<with list element> ::=
    <query name> [ <left paren> <with column list> <right paren> ]
    AS <left paren> <query expression> <right paren>

<with column list> ::=
    <column name list>

<query name> ::=
    <identifier>
```

**CTEçš„è¯­ä¹‰å®šä¹‰**ï¼š

å¯¹äºCTE `WITH cte_name AS (Q)`ï¼ŒCTEå®šä¹‰äº†ä¸€ä¸ªä¸´æ—¶å…³ç³»$R_{cte}$ï¼Œå…¶ä¸­ï¼š

- $R_{cte}$æ˜¯æŸ¥è¯¢è¡¨è¾¾å¼$Q$çš„ç»“æœå…³ç³»
- $R_{cte}$çš„ä½œç”¨åŸŸæ˜¯åŒ…å«è¯¥CTEçš„æŸ¥è¯¢è¡¨è¾¾å¼
- åœ¨æŸ¥è¯¢è¡¨è¾¾å¼ä¸­ï¼Œå¯ä»¥é€šè¿‡åç§°$cte\_name$å¼•ç”¨$R_{cte}$

**é€’å½’CTEçš„è¯­ä¹‰å®šä¹‰**ï¼š

å¯¹äºé€’å½’CTE `WITH RECURSIVE cte_name AS (Q)`ï¼Œé€’å½’CTEå®šä¹‰äº†ä¸€ä¸ªé€’å½’å…³ç³»$R_{rec}$ï¼Œå…¶ä¸­ï¼š

- $R_{rec}$æ˜¯é€’å½’æŸ¥è¯¢è¡¨è¾¾å¼$Q$çš„å›ºå®šç‚¹ï¼ˆfixed pointï¼‰
- é€’å½’æŸ¥è¯¢è¡¨è¾¾å¼$Q$é€šå¸¸åŒ…å«ï¼š
  - åŸºç¡€æŸ¥è¯¢ï¼ˆbase caseï¼‰ï¼š$Q_{base}$
  - é€’å½’æŸ¥è¯¢ï¼ˆrecursive caseï¼‰ï¼š$Q_{rec}$ï¼Œå¼•ç”¨$cte\_name$
- $R_{rec} = \mu X. (Q_{base} \cup Q_{rec}(X))$ï¼Œå…¶ä¸­$\mu$è¡¨ç¤ºæœ€å°å›ºå®šç‚¹æ“ä½œç¬¦

### 2.2 åŸºæœ¬è¯­æ³•

**CTEè¯­æ³•**ï¼š

```sql
WITH cte_name AS (
    SELECT ...
)
SELECT * FROM cte_name;
```

### 2.3 ç¤ºä¾‹

**ç¤ºä¾‹**ï¼š

```sql
WITH high_scores AS (
    SELECT * FROM Scores WHERE score > 90
)
SELECT * FROM high_scores;
```

---

## ä¸‰ã€é€’å½’CTE

### 3.1 é€’å½’CTEè¯­æ³•

**é€’å½’CTE**ï¼š

```sql
WITH RECURSIVE cte_name AS (
    -- åŸºç¡€æŸ¥è¯¢
    SELECT ...
    UNION ALL
    -- é€’å½’æŸ¥è¯¢
    SELECT ... FROM cte_name WHERE ...
)
SELECT * FROM cte_name;
```

### 3.2 é€’å½’CTEç¤ºä¾‹

**ç¤ºä¾‹**ï¼š

```sql
WITH RECURSIVE hierarchy AS (
    SELECT id, name, parent_id, 0 as level
    FROM Employees WHERE parent_id IS NULL
    UNION ALL
    SELECT e.id, e.name, e.parent_id, h.level + 1
    FROM Employees e
    JOIN hierarchy h ON e.parent_id = h.id
)
SELECT * FROM hierarchy;
```

---

## å››ã€CTEåº”ç”¨åœºæ™¯

### 4.1 æŸ¥è¯¢ç®€åŒ–

### 4.1.1 åœºæ™¯ç¤ºä¾‹1ï¼šå¤æ‚æŸ¥è¯¢ç®€åŒ–

**ä¸šåŠ¡éœ€æ±‚**ï¼šæŸ¥è¯¢é”€å”®é¢è¶…è¿‡10000çš„æœˆä»½ï¼Œå¹¶è®¡ç®—åŒæ¯”å¢é•¿ç‡ã€‚

**æ•°æ®æ¨¡å‹**ï¼š

```mermaid
erDiagram
    Sales {
        date date
        product_id int
        amount decimal
    }
```

**CTEæŸ¥è¯¢å®ç°**ï¼š

```sql
WITH monthly_sales AS (
    SELECT
        DATE_TRUNC('month', date) as month,
        SUM(amount) as total
    FROM Sales
    GROUP BY DATE_TRUNC('month', date)
),
high_sales_months AS (
    SELECT
        month,
        total,
        LAG(total, 12) OVER (ORDER BY month) as prev_year_total
    FROM monthly_sales
    WHERE total > 10000
)
SELECT
    month,
    total,
    prev_year_total,
    (total - prev_year_total) * 100.0 / prev_year_total as yoy_growth
FROM high_sales_months
ORDER BY month;
```

### 4.1.2 åœºæ™¯ç¤ºä¾‹2ï¼šå¤šæ­¥éª¤æ•°æ®åˆ†æ

**ä¸šåŠ¡éœ€æ±‚**ï¼šåˆ†æå­¦ç”Ÿé€‰è¯¾æƒ…å†µï¼Œæ‰¾å‡ºé€‰è¯¾æ•°é‡æœ€å¤šçš„å­¦ç”ŸåŠå…¶é€‰è¯¾è¯¦æƒ…ã€‚

**æ•°æ®æ¨¡å‹**ï¼š

```mermaid
erDiagram
    Student ||--o{ Enrollment : "é€‰è¯¾"
    Course ||--o{ Enrollment : "è¢«é€‰"
    Student {
        int student_id PK
        string name
    }
    Course {
        int course_id PK
        string course_name
    }
    Enrollment {
        int student_id FK
        int course_id FK
        int score
    }
```

**å¤šæ­¥éª¤CTEæŸ¥è¯¢å®ç°**ï¼š

```sql
-- æ­¥éª¤1ï¼šç»Ÿè®¡æ¯ä¸ªå­¦ç”Ÿçš„é€‰è¯¾æ•°é‡
WITH student_course_count AS (
    SELECT
        student_id,
        COUNT(*) as course_count
    FROM Enrollment
    GROUP BY student_id
),
-- æ­¥éª¤2ï¼šæ‰¾å‡ºé€‰è¯¾æ•°é‡æœ€å¤šçš„å­¦ç”Ÿ
top_students AS (
    SELECT student_id
    FROM student_course_count
    WHERE course_count = (SELECT MAX(course_count) FROM student_course_count)
)
-- æ­¥éª¤3ï¼šæŸ¥è¯¢è¿™äº›å­¦ç”Ÿçš„é€‰è¯¾è¯¦æƒ…
SELECT
    s.name,
    c.course_name,
    e.score
FROM top_students ts
JOIN Student s ON ts.student_id = s.student_id
JOIN Enrollment e ON s.student_id = e.student_id
JOIN Course c ON e.course_id = c.course_id
ORDER BY s.name, e.score DESC;
```

**CTEæ‰§è¡Œæµç¨‹æ—¶åºå›¾**ï¼š

```mermaid
sequenceDiagram
    participant Client
    participant QueryEngine
    participant CTE1
    participant CTE2
    participant Storage

    Client->>QueryEngine: WITH CTE1 AS (...), CTE2 AS (...)
    QueryEngine->>CTE1: æ‰§è¡Œç¬¬ä¸€ä¸ªCTE
    CTE1->>Storage: æŸ¥è¯¢Enrollmentè¡¨
    Storage-->>CTE1: è¿”å›æ•°æ®
    CTE1->>CTE1: è®¡ç®—course_count
    CTE1-->>QueryEngine: è¿”å›CTE1ç»“æœ
    QueryEngine->>CTE2: æ‰§è¡Œç¬¬äºŒä¸ªCTEï¼ˆå¼•ç”¨CTE1ï¼‰
    CTE2->>CTE2: ä½¿ç”¨CTE1ç»“æœ
    CTE2-->>QueryEngine: è¿”å›CTE2ç»“æœ
    QueryEngine->>Storage: æ‰§è¡Œä¸»æŸ¥è¯¢ï¼ˆå¼•ç”¨CTE2ï¼‰
    Storage-->>QueryEngine: è¿”å›æœ€ç»ˆç»“æœ
    QueryEngine-->>Client: è¿”å›ç»“æœé›†
```

---

## äº”ã€æ€§èƒ½è€ƒè™‘

### 5.1 æ€§èƒ½ä¼˜åŒ–

**æ€§èƒ½è€ƒè™‘**ï¼š

1. CTEå¯èƒ½è¢«ç‰©åŒ–
2. é€’å½’CTEéœ€è¦æ³¨æ„ç»ˆæ­¢æ¡ä»¶
3. åˆç†ä½¿ç”¨ç´¢å¼•

---

## å…­ã€å®Œæ•´ä¸šåŠ¡æ¡ˆä¾‹ï¼šç»„ç»‡æ¶æ„æŸ¥è¯¢ ğŸ†•

### 6.1 ä¸šåŠ¡åœºæ™¯æè¿°

**èƒŒæ™¯**ï¼šä¼ä¸šéœ€è¦æŸ¥è¯¢ç»„ç»‡æ¶æ„ä¿¡æ¯ï¼ŒåŒ…æ‹¬ï¼š

- å‘˜å·¥çš„å®Œæ•´æ±‡æŠ¥é“¾ï¼ˆä»å‘˜å·¥åˆ°CEOï¼‰
- æŸç®¡ç†è€…ä¸‹å±çš„æ‰€æœ‰å‘˜å·¥ï¼ˆç›´æ¥+é—´æ¥ï¼‰
- ç»„ç»‡å±‚çº§æ·±åº¦ç»Ÿè®¡

**æ•°æ®æ¨¡å‹**ï¼š

```sql
-- PostgreSQL 18 / SQLite 3.45+ é€šç”¨
CREATE TABLE employees (
    emp_id      INTEGER PRIMARY KEY,
    emp_name    TEXT NOT NULL,
    title       TEXT NOT NULL,
    manager_id  INTEGER REFERENCES employees(emp_id),
    salary      DECIMAL(10,2),
    hire_date   DATE
);

-- æµ‹è¯•æ•°æ®
INSERT INTO employees VALUES
(1, 'å¼ æ€»', 'CEO', NULL, 500000, '2010-01-01'),
(2, 'æå‰¯æ€»', 'VP Engineering', 1, 300000, '2012-03-15'),
(3, 'ç‹å‰¯æ€»', 'VP Sales', 1, 280000, '2013-06-20'),
(4, 'èµµç»ç†', 'Engineering Manager', 2, 150000, '2015-09-01'),
(5, 'é’±ç»ç†', 'Sales Manager', 3, 140000, '2016-02-10'),
(6, 'å­™å·¥ç¨‹å¸ˆ', 'Senior Engineer', 4, 80000, '2018-07-15'),
(7, 'å‘¨å·¥ç¨‹å¸ˆ', 'Engineer', 4, 60000, '2020-03-01'),
(8, 'å´é”€å”®', 'Sales Rep', 5, 50000, '2021-01-15'),
(9, 'éƒ‘å·¥ç¨‹å¸ˆ', 'Junior Engineer', 6, 45000, '2023-06-01');
```

### 6.2 æ¡ˆä¾‹1ï¼šæŸ¥è¯¢å‘˜å·¥çš„å®Œæ•´æ±‡æŠ¥é“¾

**éœ€æ±‚**ï¼šç»™å®šå‘˜å·¥IDï¼ŒæŸ¥è¯¢ä»è¯¥å‘˜å·¥åˆ°CEOçš„å®Œæ•´æ±‡æŠ¥é“¾ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š

```text
å®šä¹‰ï¼šæ±‡æŠ¥é“¾å‡½æ•° ReportChain
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ReportChain(emp_id) =
    {emp_id} âˆª
    (IF manager_id(emp_id) â‰  NULL
     THEN ReportChain(manager_id(emp_id))
     ELSE âˆ…)

ç»ˆæ­¢æ¡ä»¶ï¼šmanager_id = NULL (åˆ°è¾¾CEO)
```

**PostgreSQL 18 å®ç°**ï¼š

```sql
-- PostgreSQL 18: æŸ¥è¯¢å‘˜å·¥9(éƒ‘å·¥ç¨‹å¸ˆ)çš„å®Œæ•´æ±‡æŠ¥é“¾
WITH RECURSIVE report_chain AS (
    -- é”šå®šæˆå‘˜ï¼šèµ·å§‹å‘˜å·¥
    SELECT
        emp_id,
        emp_name,
        title,
        manager_id,
        1 AS level,
        ARRAY[emp_name] AS path,
        emp_name::TEXT AS path_string
    FROM employees
    WHERE emp_id = 9  -- èµ·å§‹å‘˜å·¥ID

    UNION ALL

    -- é€’å½’æˆå‘˜ï¼šæ²¿manager_idå‘ä¸Šéå†
    SELECT
        e.emp_id,
        e.emp_name,
        e.title,
        e.manager_id,
        rc.level + 1,
        rc.path || e.emp_name,
        rc.path_string || ' â†’ ' || e.emp_name
    FROM employees e
    INNER JOIN report_chain rc ON e.emp_id = rc.manager_id
)
SELECT
    level AS "å±‚çº§",
    emp_name AS "å§“å",
    title AS "èŒä½",
    path_string AS "æ±‡æŠ¥è·¯å¾„"
FROM report_chain
ORDER BY level;

/*
ç»“æœ:
 å±‚çº§ |   å§“å    |       èŒä½        |              æ±‡æŠ¥è·¯å¾„
------+-----------+-------------------+--------------------------------------
    1 | éƒ‘å·¥ç¨‹å¸ˆ  | Junior Engineer   | éƒ‘å·¥ç¨‹å¸ˆ
    2 | å­™å·¥ç¨‹å¸ˆ  | Senior Engineer   | éƒ‘å·¥ç¨‹å¸ˆ â†’ å­™å·¥ç¨‹å¸ˆ
    3 | èµµç»ç†    | Engineering Manager| éƒ‘å·¥ç¨‹å¸ˆ â†’ å­™å·¥ç¨‹å¸ˆ â†’ èµµç»ç†
    4 | æå‰¯æ€»    | VP Engineering    | éƒ‘å·¥ç¨‹å¸ˆ â†’ å­™å·¥ç¨‹å¸ˆ â†’ èµµç»ç† â†’ æå‰¯æ€»
    5 | å¼ æ€»      | CEO               | éƒ‘å·¥ç¨‹å¸ˆ â†’ å­™å·¥ç¨‹å¸ˆ â†’ èµµç»ç† â†’ æå‰¯æ€» â†’ å¼ æ€»
*/
```

**SQLite 3.45+ å®ç°**ï¼š

```sql
-- SQLite 3.45+: è·¯å¾„ä½¿ç”¨å­—ç¬¦ä¸²æ‹¼æ¥ï¼ˆæ— ARRAYç±»å‹ï¼‰
WITH RECURSIVE report_chain AS (
    SELECT
        emp_id,
        emp_name,
        title,
        manager_id,
        1 AS level,
        emp_name AS path_string
    FROM employees
    WHERE emp_id = 9

    UNION ALL

    SELECT
        e.emp_id,
        e.emp_name,
        e.title,
        e.manager_id,
        rc.level + 1,
        rc.path_string || ' â†’ ' || e.emp_name
    FROM employees e
    INNER JOIN report_chain rc ON e.emp_id = rc.manager_id
)
SELECT * FROM report_chain ORDER BY level;
```

### 6.3 æ¡ˆä¾‹2ï¼šæŸ¥è¯¢ç®¡ç†è€…çš„æ‰€æœ‰ä¸‹å±

**éœ€æ±‚**ï¼šç»™å®šç®¡ç†è€…IDï¼ŒæŸ¥è¯¢å…¶æ‰€æœ‰ç›´æ¥å’Œé—´æ¥ä¸‹å±ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š

```text
å®šä¹‰ï¼šä¸‹å±é›†åˆå‡½æ•° Subordinates
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Subordinates(mgr_id) =
    DirectReports(mgr_id) âˆª
    â‹ƒ{Subordinates(emp_id) | emp_id âˆˆ DirectReports(mgr_id)}

å…¶ä¸­ï¼šDirectReports(mgr_id) = {e | e.manager_id = mgr_id}

å®šç†ï¼šé€’å½’ç»ˆæ­¢æ€§
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ç”±äºç»„ç»‡æ¶æ„æ˜¯æœ‰å‘æ— ç¯å›¾(DAG)ï¼Œé€’å½’å¿…ç„¶ç»ˆæ­¢ã€‚
è¯æ˜ï¼šæ¯æ¬¡é€’å½’æ·±åº¦å¢åŠ 1ï¼Œç»„ç»‡å±‚çº§æœ‰ä¸Šç•ŒNï¼Œæ•…æœ€å¤šNæ¬¡é€’å½’ã€‚
```

**PostgreSQL 18 å®ç°ï¼ˆå«ç»Ÿè®¡ï¼‰**ï¼š

```sql
-- PostgreSQL 18: æŸ¥è¯¢æå‰¯æ€»(emp_id=2)çš„æ‰€æœ‰ä¸‹å±
WITH RECURSIVE subordinates AS (
    -- é”šå®šæˆå‘˜ï¼šç›´æ¥ä¸‹å±
    SELECT
        emp_id,
        emp_name,
        title,
        salary,
        manager_id,
        1 AS depth
    FROM employees
    WHERE manager_id = 2  -- æå‰¯æ€»çš„ID

    UNION ALL

    -- é€’å½’æˆå‘˜ï¼šé—´æ¥ä¸‹å±
    SELECT
        e.emp_id,
        e.emp_name,
        e.title,
        e.salary,
        e.manager_id,
        s.depth + 1
    FROM employees e
    INNER JOIN subordinates s ON e.manager_id = s.emp_id
)
SELECT
    emp_id,
    emp_name,
    title,
    salary,
    depth AS "å±‚çº§æ·±åº¦"
FROM subordinates
ORDER BY depth, emp_name;

-- æ±‡æ€»ç»Ÿè®¡
WITH RECURSIVE subordinates AS (
    SELECT emp_id, emp_name, salary, 1 AS depth
    FROM employees WHERE manager_id = 2
    UNION ALL
    SELECT e.emp_id, e.emp_name, e.salary, s.depth + 1
    FROM employees e
    INNER JOIN subordinates s ON e.manager_id = s.emp_id
)
SELECT
    COUNT(*) AS "ä¸‹å±æ€»æ•°",
    MAX(depth) AS "æœ€å¤§å±‚çº§æ·±åº¦",
    SUM(salary) AS "ä¸‹å±è–ªèµ„æ€»å’Œ",
    ROUND(AVG(salary), 2) AS "ä¸‹å±å¹³å‡è–ªèµ„"
FROM subordinates;

/*
ç»“æœ:
 ä¸‹å±æ€»æ•° | æœ€å¤§å±‚çº§æ·±åº¦ | ä¸‹å±è–ªèµ„æ€»å’Œ | ä¸‹å±å¹³å‡è–ªèµ„
----------+--------------+--------------+--------------
        4 |            3 |    245000.00 |     61250.00
*/
```

### 6.4 æ¡ˆä¾‹3ï¼šç»„ç»‡æ¶æ„å®Œæ•´å¯è§†åŒ–

**PostgreSQL 18 å®ç°ï¼ˆæ ‘å½¢å±•ç¤ºï¼‰**ï¼š

```sql
-- PostgreSQL 18: å®Œæ•´ç»„ç»‡æ¶æ„æ ‘å½¢å±•ç¤º
WITH RECURSIVE org_tree AS (
    -- CEOä½œä¸ºæ ¹èŠ‚ç‚¹
    SELECT
        emp_id,
        emp_name,
        title,
        manager_id,
        0 AS level,
        emp_name::TEXT AS tree_path,
        LPAD('', 0) || emp_name AS tree_display
    FROM employees
    WHERE manager_id IS NULL

    UNION ALL

    SELECT
        e.emp_id,
        e.emp_name,
        e.title,
        e.manager_id,
        ot.level + 1,
        ot.tree_path || '/' || e.emp_name,
        LPAD('', (ot.level + 1) * 4) || 'â”œâ”€â”€ ' || e.emp_name
    FROM employees e
    INNER JOIN org_tree ot ON e.manager_id = ot.emp_id
)
SELECT
    tree_display AS "ç»„ç»‡æ¶æ„",
    title AS "èŒä½",
    level AS "å±‚çº§"
FROM org_tree
ORDER BY tree_path;

/*
ç»“æœ:
         ç»„ç»‡æ¶æ„          |        èŒä½         | å±‚çº§
---------------------------+---------------------+------
 å¼ æ€»                      | CEO                 |    0
     â”œâ”€â”€ æå‰¯æ€»            | VP Engineering      |    1
         â”œâ”€â”€ èµµç»ç†        | Engineering Manager |    2
             â”œâ”€â”€ å­™å·¥ç¨‹å¸ˆ  | Senior Engineer     |    3
                 â”œâ”€â”€ éƒ‘å·¥ç¨‹å¸ˆ | Junior Engineer  |    4
             â”œâ”€â”€ å‘¨å·¥ç¨‹å¸ˆ  | Engineer            |    3
     â”œâ”€â”€ ç‹å‰¯æ€»            | VP Sales            |    1
         â”œâ”€â”€ é’±ç»ç†        | Sales Manager       |    2
             â”œâ”€â”€ å´é”€å”®    | Sales Rep           |    3
*/
```

### 6.5 æ€§èƒ½ä¼˜åŒ–ä¸æ‰§è¡Œè®¡åˆ’åˆ†æ

**PostgreSQL 18 æ‰§è¡Œè®¡åˆ’åˆ†æ**ï¼š

```sql
-- æŸ¥çœ‹é€’å½’CTEæ‰§è¡Œè®¡åˆ’
EXPLAIN (ANALYZE, BUFFERS, FORMAT TEXT)
WITH RECURSIVE subordinates AS (
    SELECT emp_id, emp_name, manager_id, 1 AS depth
    FROM employees WHERE manager_id = 2
    UNION ALL
    SELECT e.emp_id, e.emp_name, e.manager_id, s.depth + 1
    FROM employees e
    INNER JOIN subordinates s ON e.manager_id = s.emp_id
)
SELECT * FROM subordinates;

/*
æ‰§è¡Œè®¡åˆ’è§£è¯»:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. CTE Scan: æ‰«æé€’å½’CTEç»“æœ
2. WorkTable Scan: å·¥ä½œè¡¨æ‰«æï¼ˆå­˜å‚¨ä¸­é—´é€’å½’ç»“æœï¼‰
3. Recursive Union: åˆå¹¶é”šå®šæˆå‘˜å’Œé€’å½’æˆå‘˜
4. Index Scan: ä½¿ç”¨manager_idç´¢å¼•åŠ é€Ÿè¿æ¥

ä¼˜åŒ–å»ºè®®:
- åˆ›å»º manager_id ç´¢å¼•: CREATE INDEX idx_emp_manager ON employees(manager_id);
- PostgreSQL 18 è‡ªåŠ¨æ£€æµ‹é€’å½’æ·±åº¦ï¼Œé¿å…æ— é™å¾ªç¯
*/
```

**SQLite ä¼˜åŒ–**ï¼š

```sql
-- SQLite: åˆ›å»ºç´¢å¼•ä¼˜åŒ–é€’å½’æŸ¥è¯¢
CREATE INDEX idx_emp_manager ON employees(manager_id);

-- SQLite é€’å½’æŸ¥è¯¢é™åˆ¶è®¾ç½®
-- é»˜è®¤æœ€å¤§é€’å½’æ·±åº¦1000ï¼Œå¯é€šè¿‡PRAGMAè°ƒæ•´
PRAGMA recursive_triggers = ON;
```

### 6.6 é€’å½’ç»ˆæ­¢æ¡ä»¶å½¢å¼åŒ–è¯æ˜

```text
å®šç†ï¼šç»„ç»‡æ¶æ„é€’å½’æŸ¥è¯¢çš„ç»ˆæ­¢æ€§
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ç»™å®šç»„ç»‡æ¶æ„è¡¨ E = {(emp_id, manager_id, ...)}

å‰ææ¡ä»¶:
  P1: âˆ€ e âˆˆ E: e.manager_id â‰  e.emp_id (æ— è‡ªå¼•ç”¨)
  P2: Â¬âˆƒ cycle âŠ† E: å½¢æˆmanager_idçš„ç¯ (æ— ç¯)
  P3: |E| = n < âˆ (å‘˜å·¥æ•°æœ‰é™)

è¯æ˜é€’å½’ç»ˆæ­¢:
  è®¾ depth(e) = é€’å½’åˆ°è¾¾eæ—¶çš„æ·±åº¦

  åŸºç¡€æƒ…å†µ: depth(anchor) = 1
  é€’å½’æƒ…å†µ: depth(e) = depth(parent(e)) + 1

  ç”±P1å’ŒP2ï¼Œmanager_idå…³ç³»æ„æˆæœ‰å‘æ— ç¯å›¾(DAG)
  ç”±P3ï¼ŒDAGçš„æœ€é•¿è·¯å¾„ â‰¤ n

  âˆ´ é€’å½’æ·±åº¦ â‰¤ nï¼Œé€’å½’å¿…ç„¶ç»ˆæ­¢ âˆ

PostgreSQL 18 å®ç°ä¿æŠ¤:
  - é»˜è®¤é€’å½’æ·±åº¦æ— é™åˆ¶ï¼Œä½†é€šè¿‡å·¥ä½œå†…å­˜é™åˆ¶é—´æ¥æ§åˆ¶
  - å¯ä½¿ç”¨ CYCLE å­å¥æ£€æµ‹å¾ªç¯ï¼ˆSQL:2023æ ‡å‡†ï¼‰

SQLite å®ç°ä¿æŠ¤:
  - é»˜è®¤æœ€å¤§é€’å½’æ·±åº¦ 1,000,000
  - å¯é€šè¿‡ sqlite3_limit(SQLITE_LIMIT_RECURSIVE_DEPTH, N) è°ƒæ•´
```

---

## ä¸ƒã€PostgreSQL 18 CTEæ–°ç‰¹æ€§ ğŸ†•

### 7.1 MATERIALIZEDæ§åˆ¶

```sql
-- PostgreSQL 18: æ˜¾å¼æ§åˆ¶CTEç‰©åŒ–è¡Œä¸º
WITH monthly_stats AS MATERIALIZED (
    -- å¼ºåˆ¶ç‰©åŒ–ï¼šCTEç»“æœå­˜å‚¨åœ¨ä¸´æ—¶ç©ºé—´ï¼Œé€‚åˆå¤šæ¬¡å¼•ç”¨
    SELECT DATE_TRUNC('month', hire_date) AS month, COUNT(*) AS cnt
    FROM employees
    GROUP BY 1
)
SELECT * FROM monthly_stats WHERE cnt > 1;

WITH monthly_stats AS NOT MATERIALIZED (
    -- ä¸ç‰©åŒ–ï¼šCTEå†…è”åˆ°ä¸»æŸ¥è¯¢ï¼Œé€‚åˆå•æ¬¡å¼•ç”¨
    SELECT DATE_TRUNC('month', hire_date) AS month, COUNT(*) AS cnt
    FROM employees
    GROUP BY 1
)
SELECT * FROM monthly_stats WHERE cnt > 1;
```

### 7.2 SEARCHå’ŒCYCLEå­å¥ï¼ˆSQL:2023ï¼‰

```sql
-- PostgreSQL 18: SEARCHå­å¥æ§åˆ¶éå†é¡ºåº
WITH RECURSIVE org_tree AS (
    SELECT emp_id, emp_name, manager_id, ARRAY[emp_id] AS path
    FROM employees WHERE manager_id IS NULL
    UNION ALL
    SELECT e.emp_id, e.emp_name, e.manager_id, ot.path || e.emp_id
    FROM employees e JOIN org_tree ot ON e.manager_id = ot.emp_id
)
SEARCH DEPTH FIRST BY emp_id SET ordercol  -- æ·±åº¦ä¼˜å…ˆ
SELECT * FROM org_tree ORDER BY ordercol;

-- PostgreSQL 18: CYCLEå­å¥æ£€æµ‹å¾ªç¯
WITH RECURSIVE traverse AS (
    SELECT emp_id, manager_id, ARRAY[emp_id] AS path, false AS is_cycle
    FROM employees WHERE emp_id = 1
    UNION ALL
    SELECT e.emp_id, e.manager_id, t.path || e.emp_id, e.emp_id = ANY(t.path)
    FROM employees e JOIN traverse t ON e.manager_id = t.emp_id
    WHERE NOT t.is_cycle
)
CYCLE emp_id SET is_cycle USING path
SELECT * FROM traverse WHERE NOT is_cycle;
```

---

## å…«ã€SQLite 3.45+ CTEç‰¹æ€§ ğŸ†•

### 8.1 é€’å½’æŸ¥è¯¢åŸºæœ¬ç”¨æ³•

```sql
-- SQLite 3.45+: é€’å½’CTEå®Œæ•´ç¤ºä¾‹
WITH RECURSIVE
  cnt(x) AS (
    SELECT 1              -- é”šå®šæˆå‘˜
    UNION ALL
    SELECT x+1 FROM cnt   -- é€’å½’æˆå‘˜
    WHERE x < 10          -- ç»ˆæ­¢æ¡ä»¶
  )
SELECT x FROM cnt;

-- SQLite: ç”Ÿæˆæ—¥æœŸåºåˆ—
WITH RECURSIVE dates(d) AS (
    SELECT date('2025-01-01')
    UNION ALL
    SELECT date(d, '+1 day') FROM dates WHERE d < '2025-01-31'
)
SELECT d AS "æ—¥æœŸ", strftime('%w', d) AS "æ˜ŸæœŸ" FROM dates;
```

### 8.2 WITHå­å¥çš„å¤šCTEç”¨æ³•

```sql
-- SQLite 3.45+: å¤šä¸ªCTEåä½œ
WITH
    dept_count AS (
        SELECT manager_id, COUNT(*) AS direct_reports
        FROM employees
        WHERE manager_id IS NOT NULL
        GROUP BY manager_id
    ),
    high_performers AS (
        SELECT emp_id, emp_name, salary
        FROM employees
        WHERE salary > (SELECT AVG(salary) FROM employees)
    )
SELECT
    e.emp_name,
    e.title,
    COALESCE(dc.direct_reports, 0) AS "ç›´æ¥ä¸‹å±æ•°",
    CASE WHEN hp.emp_id IS NOT NULL THEN 'æ˜¯' ELSE 'å¦' END AS "é«˜ç»©æ•ˆ"
FROM employees e
LEFT JOIN dept_count dc ON e.emp_id = dc.manager_id
LEFT JOIN high_performers hp ON e.emp_id = hp.emp_id
ORDER BY e.salary DESC;
```

---

## ä¹ã€ç›¸å…³èµ„æº

### ç›¸å…³æ–‡æ¡£

- [é€’å½’æŸ¥è¯¢è¯¦è§£](./05.03-é€’å½’æŸ¥è¯¢è¯¦è§£.md) - é€’å½’æŸ¥è¯¢æ·±å…¥åˆ†æ
- [çª—å£å‡½æ•°è¯¦è§£](./05.01-çª—å£å‡½æ•°è¯¦è§£.md) - çª—å£å‡½æ•°ä¸CTEé…åˆ
- [01.06-æ•°å­¦åŸºç¡€åˆ°SQLå› æœé“¾](../01-ç†è®ºåŸºç¡€/01.06-æ•°å­¦åŸºç¡€åˆ°SQLå› æœé“¾.md) - é€’å½’çš„æ•°å­¦åŸºç¡€
- [09.07-å†³ç­–æ¨ç†è§„åˆ™åº“](../09-æ•´åˆèµ„æº/09.07-å†³ç­–æ¨ç†è§„åˆ™åº“.md) - CTEé€‰æ‹©å†³ç­–è§„åˆ™

### å¤–éƒ¨èµ„æº

- [PostgreSQL 18 WITH Queries](https://www.postgresql.org/docs/current/queries-with.html)
- [SQLite WITH Clause](https://www.sqlite.org/lang_with.html)

---

**ç»´æŠ¤è€…**: SQL Standards Team
**æœ€åæ›´æ–°**: 2025-12-01
