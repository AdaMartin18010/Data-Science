# 窗口函数详解

> **创建日期**：2025-01-15
> **最后更新**：2025-01-16
> **版本**：v1.0.0
> **难度**：⭐⭐⭐⭐
> **应用场景**：数据分析、排名计算、累计统计

---

## 📋 目录

- [窗口函数详解](#窗口函数详解)
  - [📋 目录](#-目录)
  - [一、概述](#一概述)
    - [1.0 窗口函数历史背景](#10-窗口函数历史背景)
    - [1.1 窗口函数知识体系思维导图](#11-窗口函数知识体系思维导图)
    - [1.2 窗口函数选择决策树](#12-窗口函数选择决策树)
  - [二、窗口函数语法](#二窗口函数语法)
    - [2.1 窗口函数的形式化定义](#21-窗口函数的形式化定义)
    - [2.2 基本语法](#22-基本语法)
    - [2.3 示例](#23-示例)
  - [三、窗口函数类型](#三窗口函数类型)
    - [3.1 排名函数](#31-排名函数)
    - [3.2 聚合函数](#32-聚合函数)
    - [3.3 值函数](#33-值函数)
  - [四、窗口函数应用](#四窗口函数应用)
    - [4.1 排名应用](#41-排名应用)
    - [4.1.1 场景示例：学生成绩排名分析](#411-场景示例学生成绩排名分析)
    - [4.2 累计统计](#42-累计统计)
    - [4.2.1 场景示例：销售累计统计和移动平均](#421-场景示例销售累计统计和移动平均)
    - [4.2.2 场景示例：同比环比分析](#422-场景示例同比环比分析)
  - [五、性能优化](#五性能优化)
    - [5.1 优化建议](#51-优化建议)
    - [5.2 窗口函数的性能考虑](#52-窗口函数的性能考虑)
  - [六、窗口函数标准演进](#六窗口函数标准演进)
    - [6.1 SQL:2003标准](#61-sql2003标准)
    - [6.2 SQL:2008标准](#62-sql2008标准)
    - [6.3 SQL:2011标准](#63-sql2011标准)
    - [6.4 SQL:2016标准](#64-sql2016标准)
    - [6.5 SQL:2023标准](#65-sql2023标准)
  - [七、窗口函数与关系模型的对应关系](#七窗口函数与关系模型的对应关系)
    - [7.1 窗口函数的关系代数扩展](#71-窗口函数的关系代数扩展)
    - [7.2 窗口函数的查询优化](#72-窗口函数的查询优化)
  - [八、相关资源](#八相关资源)
    - [相关文档](#相关文档)

---

## 一、概述

**窗口函数（Window Functions）**是SQL:2003引入的高级特性，用于在查询结果集的窗口上执行计算。

**窗口函数特点**：

- 不改变结果集行数
- 可以访问同一查询中其他行的数据
- 支持分区和排序

### 1.0 窗口函数历史背景

**窗口函数的发展历程**：

- **SQL:1999**：引入了OLAP函数的概念，为窗口函数奠定了基础
- **SQL:2003**：正式引入窗口函数（Window Functions），包括排名函数、聚合窗口函数和值函数
- **SQL:2008**：增强了窗口函数功能，改进了ROWS和RANGE子句
- **SQL:2011**：添加了更多窗口函数，如PERCENT_RANK、CUME_DIST等
- **SQL:2016**：增强了窗口函数的性能优化支持
- **SQL:2023**：进一步完善了窗口函数的语法和功能

**窗口函数的设计动机**：

窗口函数的设计是为了解决传统SQL在数据分析中的局限性：

1. **排名问题**：需要计算排名、百分比排名等，传统SQL需要复杂的自连接或子查询
2. **累计统计**：需要计算累计和、移动平均等，传统SQL难以高效实现
3. **前后值访问**：需要访问前一行或后一行的值，传统SQL需要自连接
4. **分区计算**：需要在不同分区内独立计算，传统SQL需要多次查询

**窗口函数与关系模型的关系**：

窗口函数扩展了关系代数的表达能力，允许在关系上定义"窗口"（Window），在窗口内执行计算。这可以看作是关系代数的一种扩展，提供了更强大的数据分析能力。

### 1.1 窗口函数知识体系思维导图

```mermaid
mindmap
  root((窗口函数))
    函数类型
      排名函数
        ROW_NUMBER
        RANK
        DENSE_RANK
        PERCENT_RANK
      聚合函数
        SUM OVER
        AVG OVER
        COUNT OVER
        MAX/MIN OVER
      值函数
        LAG
        LEAD
        FIRST_VALUE
        LAST_VALUE
    窗口定义
      PARTITION BY
        分区划分
        独立计算
      ORDER BY
        排序规则
        计算顺序
      ROWS/RANGE
        行范围
        值范围
    应用场景
      排名统计
        学生排名
        销售排名
      累计统计
        累计销售额
        累计用户数
      移动平均
        股票价格
        温度趋势
      同比环比
        月度对比
        年度对比
    性能优化
      分区优化
        减少计算量
        并行处理
      索引使用
        排序优化
        范围查询
```

### 1.2 窗口函数选择决策树

```mermaid
flowchart TD
    A[需要窗口函数?] --> B{需要排名?}
    B -->|是| C{允许并列?}
    C -->|否| D[使用ROW_NUMBER]
    C -->|是| E{并列后连续?}
    E -->|是| F[使用DENSE_RANK]
    E -->|否| G[使用RANK]
    B -->|否| H{需要聚合?}
    H -->|是| I{需要累计?}
    I -->|是| J[使用SUM/AVG OVER ORDER BY]
    I -->|否| K[使用SUM/AVG OVER PARTITION BY]
    H -->|否| L{需要前后值?}
    L -->|是| M{前一行?}
    M -->|是| N[使用LAG]
    M -->|否| O[使用LEAD]
    L -->|否| P{需要首尾值?}
    P -->|是| Q{第一个值?}
    Q -->|是| R[使用FIRST_VALUE]
    Q -->|否| S[使用LAST_VALUE]
```

---

## 二、窗口函数语法

### 2.1 窗口函数的形式化定义

**窗口函数的BNF语法定义**（基于SQL:2003标准）：

```bnf
<window function> ::=
    <window function type> OVER <window specification>

<window function type> ::=
    <rank function>
    | <aggregate function>
    | <value function>

<window specification> ::=
    [ <window name> ]
    | [ <partition clause> ] [ <order clause> ] [ <frame clause> ]

<partition clause> ::=
    PARTITION BY <value expression> [ { <comma> <value expression> }... ]

<order clause> ::=
    ORDER BY <sort specification> [ { <comma> <sort specification> }... ]

<frame clause> ::=
    <frame units> <frame extent> [ <frame exclusion> ]

<frame units> ::=
    ROWS
    | RANGE
    | GROUPS

<frame extent> ::=
    <frame start>
    | <frame between>

<frame start> ::=
    UNBOUNDED PRECEDING
    | <unsigned value specification> PRECEDING
    | CURRENT ROW

<frame between> ::=
    BETWEEN <frame bound> AND <frame bound>

<frame bound> ::=
    <frame start>
    | UNBOUNDED FOLLOWING
    | <unsigned value specification> FOLLOWING

<frame exclusion> ::=
    EXCLUDE CURRENT ROW
    | EXCLUDE GROUP
    | EXCLUDE TIES
    | EXCLUDE NO OTHERS
```

**窗口函数的语义定义**：

窗口函数在关系$R$上定义了一个窗口$W$，窗口函数$f$在窗口$W$内的每一行$r$上计算值$f(r, W)$。

形式化地，对于关系$R$和窗口函数$f$：

- 窗口$W$由分区子句$P$、排序子句$O$和框架子句$F$定义
- 对于每一行$r \in R$，窗口$W(r)$是满足以下条件的行的集合：
  - 如果存在分区子句$P$，则$W(r)$中的行与$r$在分区属性上具有相同的值
  - 如果存在排序子句$O$，则$W(r)$中的行按照$O$排序
  - 如果存在框架子句$F$，则$W(r)$中的行在框架范围内

### 2.2 基本语法

**窗口函数语法**：

```sql
function_name([arguments]) OVER (
    [PARTITION BY partition_list]
    [ORDER BY order_list]
    [ROWS | RANGE frame_clause]
)
```

### 2.3 示例

**示例**：

```sql
SELECT
    student_id,
    score,
    ROW_NUMBER() OVER (PARTITION BY class ORDER BY score DESC) as rank
FROM Scores;
```

---

## 三、窗口函数类型

### 3.1 排名函数

**排名函数**：

- ROW_NUMBER()：行号
- RANK()：排名（允许并列）
- DENSE_RANK()：密集排名
- PERCENT_RANK()：百分比排名

### 3.2 聚合函数

**聚合窗口函数**：

- SUM() OVER()
- AVG() OVER()
- COUNT() OVER()
- MAX() OVER()
- MIN() OVER()

### 3.3 值函数

**值函数**：

- LAG()：前一行值
- LEAD()：后一行值
- FIRST_VALUE()：窗口第一个值
- LAST_VALUE()：窗口最后一个值

---

## 四、窗口函数应用

### 4.1 排名应用

### 4.1.1 场景示例：学生成绩排名分析

**业务需求**：计算每门课程的学生排名，并分析成绩分布。

**数据模型**：

```mermaid
erDiagram
    Student ||--o{ Enrollment : "选课"
    Course ||--o{ Enrollment : "被选"
    Student {
        int student_id PK
        string name
        string class
    }
    Course {
        int course_id PK
        string course_name
    }
    Enrollment {
        int student_id FK
        int course_id FK
        int score
    }
```

**排名查询实现**：

```sql
SELECT
    c.course_name,
    s.name,
    s.class,
    e.score,
    RANK() OVER (PARTITION BY e.course_id ORDER BY e.score DESC) as course_rank,
    DENSE_RANK() OVER (PARTITION BY e.course_id ORDER BY e.score DESC) as dense_rank,
    ROW_NUMBER() OVER (PARTITION BY e.course_id ORDER BY e.score DESC) as row_number,
    PERCENT_RANK() OVER (PARTITION BY e.course_id ORDER BY e.score DESC) as percent_rank
FROM Enrollment e
JOIN Student s ON e.student_id = s.student_id
JOIN Course c ON e.course_id = c.course_id
ORDER BY c.course_name, course_rank;
```

**查询执行流程时序图**：

```mermaid
sequenceDiagram
    participant Client
    participant QueryEngine
    participant WindowFunction
    participant Storage

    Client->>QueryEngine: SELECT with RANK() OVER
    QueryEngine->>Storage: 读取Enrollment表
    Storage-->>QueryEngine: 返回数据
    QueryEngine->>WindowFunction: 按course_id分区
    WindowFunction->>WindowFunction: 在每个分区内按score排序
    WindowFunction->>WindowFunction: 计算RANK()
    WindowFunction-->>QueryEngine: 返回排名结果
    QueryEngine-->>Client: 返回最终结果
```

### 4.2 累计统计

### 4.2.1 场景示例：销售累计统计和移动平均

**业务需求**：计算每日销售额的累计值和7日移动平均。

**数据模型**：

```mermaid
erDiagram
    Sales {
        date date PK
        product_id int
        amount decimal
        quantity int
    }
```

**累计统计查询实现**：

```sql
SELECT
    date,
    amount,
    SUM(amount) OVER (ORDER BY date) as cumulative_sales,
    AVG(amount) OVER (
        ORDER BY date
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) as moving_avg_7d,
    SUM(amount) OVER (
        ORDER BY date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) as moving_sum_30d
FROM Sales
ORDER BY date;
```

### 4.2.2 场景示例：同比环比分析

**业务需求**：计算月度销售额的同比和环比增长率。

**同比环比查询实现**：

```sql
WITH monthly_sales AS (
    SELECT
        DATE_TRUNC('month', date) as month,
        SUM(amount) as total_sales
    FROM Sales
    GROUP BY DATE_TRUNC('month', date)
)
SELECT
    month,
    total_sales,
    LAG(total_sales, 1) OVER (ORDER BY month) as prev_month,
    LAG(total_sales, 12) OVER (ORDER BY month) as prev_year,
    (total_sales - LAG(total_sales, 1) OVER (ORDER BY month)) * 100.0 /
        LAG(total_sales, 1) OVER (ORDER BY month) as month_over_month_pct,
    (total_sales - LAG(total_sales, 12) OVER (ORDER BY month)) * 100.0 /
        LAG(total_sales, 12) OVER (ORDER BY month) as year_over_year_pct
FROM monthly_sales
ORDER BY month;
```

---

## 五、性能优化

### 5.1 优化建议

**性能优化**：

1. 合理使用PARTITION BY
2. 避免不必要的排序
3. 使用索引支持窗口函数

### 5.2 窗口函数的性能考虑

**窗口函数的执行模型**：

窗口函数的执行通常包括以下步骤：

1. **分区划分**：根据PARTITION BY子句将数据划分为多个分区
2. **排序**：在每个分区内根据ORDER BY子句排序
3. **框架计算**：对于每一行，根据框架子句确定窗口范围
4. **函数计算**：在窗口范围内计算窗口函数的值

**性能优化策略**：

1. **分区优化**：
   - 合理选择分区键，避免分区过多或过少
   - 使用索引支持分区键的查找

2. **排序优化**：
   - 使用索引支持排序操作
   - 避免不必要的排序

3. **框架优化**：
   - 使用ROWS而不是RANGE（如果可能），因为ROWS更高效
   - 避免使用UNBOUNDED FOLLOWING（如果可能）

---

## 六、窗口函数标准演进

### 6.1 SQL:2003标准

**SQL:2003引入的窗口函数**：

- 排名函数：ROW_NUMBER、RANK、DENSE_RANK
- 聚合窗口函数：SUM、AVG、COUNT、MAX、MIN等
- 值函数：LAG、LEAD、FIRST_VALUE、LAST_VALUE

**SQL:2003的窗口函数特性**：

- 支持PARTITION BY子句
- 支持ORDER BY子句
- 支持ROWS和RANGE框架

### 6.2 SQL:2008标准

**SQL:2008的增强**：

- 改进了ROWS和RANGE框架的语义
- 增强了窗口函数的性能优化支持

### 6.3 SQL:2011标准

**SQL:2011的新增函数**：

- PERCENT_RANK：计算百分比排名
- CUME_DIST：计算累积分布
- NTH_VALUE：获取第N个值

### 6.4 SQL:2016标准

**SQL:2016的增强**：

- 增强了窗口函数的性能优化
- 改进了窗口函数的语法

### 6.5 SQL:2023标准

**SQL:2023的新特性**：

- 支持GROUPS框架单位
- 支持EXCLUDE子句（EXCLUDE CURRENT ROW、EXCLUDE GROUP、EXCLUDE TIES）
- 增强了窗口函数的表达能力

---

## 七、窗口函数与关系模型的对应关系

### 7.1 窗口函数的关系代数扩展

**窗口函数可以看作是关系代数的一种扩展**：

传统的关系代数操作（选择、投影、连接等）是"集合操作"，而窗口函数是"有序集合操作"。

**窗口函数的关系代数表示**：

对于窗口函数$f$和关系$R$，窗口函数可以表示为：
$$\text{Window}(R, f, P, O, F) = \{ (r, f(r, W(r))) \mid r \in R \}$$

其中：

- $P$是分区子句
- $O$是排序子句
- $F$是框架子句
- $W(r)$是行$r$的窗口

### 7.2 窗口函数的查询优化

**窗口函数的查询优化规则**：

1. **投影下推**：窗口函数之前的投影可以下推到窗口函数之前
2. **选择下推**：窗口函数之前的选择可以下推到窗口函数之前（需要谨慎处理）
3. **窗口合并**：多个窗口函数可以合并为一次窗口计算

---

## 八、相关资源

### 相关文档

- [公共表表达式(CTE)](./05.02-公共表表达式(CTE).md) - CTE详解
- [数据查询语言(DQL)](../04-语法规范/04.03-数据查询语言(DQL).md) - DQL语法

---

**维护者**: SQL Standards Team
**最后更新**: 2025-01-16
