# SQL分析函数完整实战

> **创建日期**: 2025-12-04
> **标准**: SQL:2023
> **难度**: ⭐⭐⭐⭐⭐

---

## 分析函数总览

```text
SQL分析函数分类
══════════════════════════════════════════════════════════════════════════════

1. 排名函数
   ├─ ROW_NUMBER() - 唯一行号
   ├─ RANK() - 排名（有间隙）
   ├─ DENSE_RANK() - 密集排名
   └─ NTILE(n) - 分组

2. 偏移函数
   ├─ LAG() - 前一行
   ├─ LEAD() - 后一行
   ├─ FIRST_VALUE() - 窗口首行
   └─ LAST_VALUE() - 窗口末行

3. 聚合函数（窗口版本）
   ├─ SUM() OVER
   ├─ AVG() OVER
   ├─ COUNT() OVER
   ├─ MAX() OVER
   └─ MIN() OVER

4. 统计函数
   ├─ PERCENT_RANK() - 百分比排名
   ├─ CUME_DIST() - 累积分布
   ├─ PERCENTILE_CONT() - 连续百分位
   └─ PERCENTILE_DISC() - 离散百分位
```

---

## 实战1：排行榜（排名函数）

### 场景：游戏排行榜

```sql
-- 表结构
CREATE TABLE game_scores (
    user_id INTEGER,
    username TEXT,
    score INTEGER,
    play_date DATE
);

-- 示例数据
INSERT INTO game_scores VALUES
    (1, 'Alice', 9500, '2025-12-01'),
    (2, 'Bob', 9500, '2025-12-02'),
    (3, 'Charlie', 9200, '2025-12-01'),
    (4, 'David', 9200, '2025-12-03'),
    (5, 'Eve', 8800, '2025-12-02'),
    (6, 'Frank', 8800, '2025-12-01'),
    (7, 'Grace', 8500, '2025-12-03');

-- 查询1：排行榜（ROW_NUMBER vs RANK vs DENSE_RANK）
SELECT
    username,
    score,
    ROW_NUMBER() OVER (ORDER BY score DESC) as row_num,
    RANK() OVER (ORDER BY score DESC) as rank,
    DENSE_RANK() OVER (ORDER BY score DESC) as dense_rank
FROM game_scores;

-- 结果：
-- username | score | row_num | rank | dense_rank
-- ---------+-------+---------+------+------------
-- Alice    | 9500  |    1    |  1   |     1
-- Bob      | 9500  |    2    |  1   |     1  (并列第1)
-- Charlie  | 9200  |    3    |  3   |     2  (注意RANK跳到3)
-- David    | 9200  |    4    |  3   |     2
-- Eve      | 8800  |    5    |  5   |     3
-- Frank    | 8800  |    6    |  5   |     3
-- Grace    | 8500  |    7    |  7   |     4

-- 差异说明：
-- ROW_NUMBER: 1, 2, 3, 4, 5, 6, 7 (唯一，按顺序)
-- RANK: 1, 1, 3, 3, 5, 5, 7 (并列后跳过)
-- DENSE_RANK: 1, 1, 2, 2, 3, 3, 4 (并列后不跳过)

-- 查询2：分组排行榜（每日TOP 3）
SELECT * FROM (
    SELECT
        play_date,
        username,
        score,
        ROW_NUMBER() OVER (
            PARTITION BY play_date
            ORDER BY score DESC
        ) as rank_in_day
    FROM game_scores
)
WHERE rank_in_day <= 3;

-- 结果：
-- play_date  | username | score | rank_in_day
-- -----------+----------+-------+-------------
-- 2025-12-01 | Alice    | 9500  |     1
-- 2025-12-01 | Charlie  | 9200  |     2
-- 2025-12-01 | Frank    | 8800  |     3
-- 2025-12-02 | Bob      | 9500  |     1
-- 2025-12-02 | Eve      | 8800  |     2
-- 2025-12-03 | David    | 9200  |     1
-- 2025-12-03 | Grace    | 8500  |     2
```

---

## 实战2：同比环比分析（偏移函数）

### 场景：销售额环比增长

```sql
-- 表结构
CREATE TABLE monthly_sales (
    year INTEGER,
    month INTEGER,
    sales_amount DECIMAL(10, 2)
);

-- 示例数据
INSERT INTO monthly_sales VALUES
    (2024, 1, 100000), (2024, 2, 105000), (2024, 3, 110000),
    (2024, 4, 108000), (2024, 5, 112000), (2024, 6, 120000),
    (2025, 1, 130000), (2025, 2, 135000), (2025, 3, 140000);

-- 查询1：环比增长（LAG）
SELECT
    year,
    month,
    sales_amount,
    LAG(sales_amount, 1) OVER (ORDER BY year, month) as prev_month_sales,
    sales_amount - LAG(sales_amount, 1) OVER (ORDER BY year, month) as mom_growth,
    ROUND(
        (sales_amount - LAG(sales_amount, 1) OVER (ORDER BY year, month)) * 100.0 /
        LAG(sales_amount, 1) OVER (ORDER BY year, month),
        2
    ) as mom_growth_pct
FROM monthly_sales;

-- 结果：
-- year | month | sales_amount | prev_month_sales | mom_growth | mom_growth_pct
-- -----+-------+--------------+------------------+------------+----------------
-- 2024 |   1   |   100000     |      NULL        |    NULL    |      NULL
-- 2024 |   2   |   105000     |     100000       |    5000    |      5.00
-- 2024 |   3   |   110000     |     105000       |    5000    |      4.76
-- ...

-- 查询2：同比增长（LAG 12个月）
SELECT
    year,
    month,
    sales_amount,
    LAG(sales_amount, 12) OVER (ORDER BY year, month) as same_month_last_year,
    sales_amount - LAG(sales_amount, 12) OVER (ORDER BY year, month) as yoy_growth,
    ROUND(
        (sales_amount - LAG(sales_amount, 12) OVER (ORDER BY year, month)) * 100.0 /
        LAG(sales_amount, 12) OVER (ORDER BY year, month),
        2
    ) as yoy_growth_pct
FROM monthly_sales;

-- 查询3：移动平均（3个月）
SELECT
    year,
    month,
    sales_amount,
    AVG(sales_amount) OVER (
        ORDER BY year, month
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) as ma_3months
FROM monthly_sales;

-- 结果：
-- year | month | sales_amount | ma_3months
-- -----+-------+--------------+------------
-- 2024 |   1   |   100000     |  100000.00 (只有1个月)
-- 2024 |   2   |   105000     |  102500.00 ((100000+105000)/2)
-- 2024 |   3   |   110000     |  105000.00 ((100000+105000+110000)/3)
-- 2024 |   4   |   108000     |  107666.67 ((105000+110000+108000)/3)
```

---

## 实战3：累积计算（聚合窗口函数）

### 场景：累积销售额

```sql
-- 查询：累积销售额和占比
SELECT
    year,
    month,
    sales_amount,
    -- 累积销售额
    SUM(sales_amount) OVER (
        ORDER BY year, month
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) as cumulative_sales,
    -- 年度累积销售额
    SUM(sales_amount) OVER (
        PARTITION BY year
        ORDER BY month
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) as ytd_sales,
    -- 当月占年度总额百分比
    ROUND(
        sales_amount * 100.0 / SUM(sales_amount) OVER (PARTITION BY year),
        2
    ) as pct_of_year_total
FROM monthly_sales;

-- 结果：
-- year | month | sales_amount | cumulative_sales | ytd_sales | pct_of_year_total
-- -----+-------+--------------+------------------+-----------+-------------------
-- 2024 |   1   |   100000     |     100000       |  100000   |      15.04
-- 2024 |   2   |   105000     |     205000       |  205000   |      15.79
-- 2024 |   3   |   110000     |     315000       |  315000   |      16.54
-- 2024 |   4   |   108000     |     423000       |  423000   |      16.24
-- 2024 |   5   |   112000     |     535000       |  535000   |      16.84
-- 2024 |   6   |   120000     |     655000       |  655000   |      18.05
-- 2025 |   1   |   130000     |     785000       |  130000   |      32.10
-- 2025 |   2   |   135000     |     920000       |  265000   |      33.33
-- 2025 |   3   |   140000     |    1060000       |  405000   |      34.57
```

---

## 实战4：用户留存分析

### 场景：Cohort留存率

```sql
-- 表结构
CREATE TABLE user_logins (
    user_id INTEGER,
    login_date DATE
);

-- 示例数据（2025-01注册用户）
INSERT INTO user_logins VALUES
    -- 用户1：1/1注册，1/2, 1/8, 1/15登录
    (1, '2025-01-01'), (1, '2025-01-02'), (1, '2025-01-08'), (1, '2025-01-15'),
    -- 用户2：1/1注册，1/3登录
    (2, '2025-01-01'), (2, '2025-01-03'),
    -- 用户3：1/1注册，1/2, 1/9登录
    (3, '2025-01-01'), (3, '2025-01-02'), (3, '2025-01-09');

-- 查询：留存率分析
WITH first_login AS (
    -- 每个用户的首次登录（注册日期）
    SELECT
        user_id,
        MIN(login_date) as cohort_date
    FROM user_logins
    GROUP BY user_id
),
user_activity AS (
    -- 用户活动与注册日期
    SELECT
        ul.user_id,
        fl.cohort_date,
        ul.login_date,
        JULIANDAY(ul.login_date) - JULIANDAY(fl.cohort_date) as days_since_signup
    FROM user_logins ul
    JOIN first_login fl ON ul.user_id = fl.user_id
),
retention AS (
    -- 按天聚合留存
    SELECT
        cohort_date,
        days_since_signup,
        COUNT(DISTINCT user_id) as active_users
    FROM user_activity
    GROUP BY cohort_date, days_since_signup
)
SELECT
    cohort_date,
    days_since_signup as day,
    active_users,
    ROUND(
        active_users * 100.0 / FIRST_VALUE(active_users) OVER (
            PARTITION BY cohort_date
            ORDER BY days_since_signup
        ),
        2
    ) as retention_rate_pct
FROM retention
ORDER BY cohort_date, days_since_signup;

-- 结果：
-- cohort_date | day | active_users | retention_rate_pct
-- ------------+-----+--------------+--------------------
-- 2025-01-01  |  0  |      3       |      100.00  (注册日)
-- 2025-01-01  |  1  |      2       |       66.67  (次日留存)
-- 2025-01-01  |  2  |      1       |       33.33  (第3天)
-- 2025-01-01  |  7  |      1       |       33.33  (第8天)
-- 2025-01-01  |  8  |      1       |       33.33  (第9天)
-- 2025-01-01  | 14  |      1       |       33.33  (第15天)
```

---

## 实战5：分位数与分组（NTILE, PERCENTILE）

### 场景：用户价值分层

```sql
-- 表结构
CREATE TABLE user_spending (
    user_id INTEGER PRIMARY KEY,
    total_amount DECIMAL(10, 2)
);

-- 示例数据
INSERT INTO user_spending VALUES
    (1, 10000), (2, 5000), (3, 3000), (4, 2500), (5, 2000),
    (6, 1500), (7, 1000), (8, 800), (9, 600), (10, 500);

-- 查询1：分层（NTILE）
SELECT
    user_id,
    total_amount,
    NTILE(4) OVER (ORDER BY total_amount DESC) as quartile,
    CASE NTILE(4) OVER (ORDER BY total_amount DESC)
        WHEN 1 THEN 'VIP'
        WHEN 2 THEN 'High'
        WHEN 3 THEN 'Medium'
        WHEN 4 THEN 'Low'
    END as tier
FROM user_spending;

-- 结果：
-- user_id | total_amount | quartile | tier
-- --------+--------------+----------+--------
--    1    |    10000     |    1     | VIP
--    2    |     5000     |    1     | VIP
--    3    |     3000     |    1     | VIP
--    4    |     2500     |    2     | High
--    5     |     2000     |    2     | High
--    6    |     1500     |    2     | High
--    7    |     1000     |    3     | Medium
--    8    |      800     |    3     | Medium
--    9    |      600     |    4     | Low
--   10    |      500     |    4     | Low

-- 查询2：百分位数（PostgreSQL）
SELECT
    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY total_amount) as p25,
    PERCENTILE_CONT(0.50) WITHIN GROUP (ORDER BY total_amount) as p50_median,
    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY total_amount) as p75,
    PERCENTILE_CONT(0.90) WITHIN GROUP (ORDER BY total_amount) as p90
FROM user_spending;

-- 结果：
--  p25  | p50_median | p75  |  p90
-- ------+------------+------+-------
--  850  |   1750     | 2750 | 5500

-- 查询3：累积分布（CUME_DIST）
SELECT
    user_id,
    total_amount,
    CUME_DIST() OVER (ORDER BY total_amount) as cume_dist,
    ROUND(CUME_DIST() OVER (ORDER BY total_amount) * 100, 2) as percentile
FROM user_spending;

-- 结果：
-- user_id | total_amount | cume_dist | percentile
-- --------+--------------+-----------+------------
--   10    |      500     |   0.1     |    10.00  (前10%)
--    9    |      600     |   0.2     |    20.00
--    8    |      800     |   0.3     |    30.00
--    7    |     1000     |   0.4     |    40.00
--    6    |     1500     |   0.5     |    50.00
--    5    |     2000     |   0.6     |    60.00
--    4    |     2500     |   0.7     |    70.00
--    3    |     3000     |   0.8     |    80.00
--    2    |     5000     |   0.9     |    90.00
--    1    |    10000     |   1.0     |   100.00
```

---

## 性能优化技巧

### 1. 索引优化

```sql
-- 窗口函数性能依赖ORDER BY的索引

-- ❌ 无索引（慢）
SELECT
    user_id,
    ROW_NUMBER() OVER (ORDER BY created_at DESC) as rn
FROM users;
-- 需要排序，100万行需要2秒

-- ✅ 创建索引（快）
CREATE INDEX idx_users_created ON users(created_at DESC);
-- 现在只需0.1秒
```

### 2. 避免重复计算

```sql
-- ❌ 重复计算窗口函数（慢）
SELECT
    user_id,
    ROW_NUMBER() OVER (ORDER BY score DESC) as rank,
    score,
    score - LAG(score) OVER (ORDER BY score DESC) as score_diff
FROM game_scores;
-- ORDER BY score DESC 计算2次

-- ✅ 使用CTE缓存（快）
WITH ranked AS (
    SELECT
        user_id,
        score,
        ROW_NUMBER() OVER (ORDER BY score DESC) as rank
    FROM game_scores
)
SELECT
    user_id,
    rank,
    score,
    score - LAG(score) OVER (ORDER BY rank) as score_diff
FROM ranked;
```

---

**文档版本**: v1.0.0
**最后更新**: 2025-12-04
