# 数据库高可用架构实战

> **创建日期**: 2025-12-04
> **覆盖**: PostgreSQL主从复制、MySQL Group Replication、SQLite分布式方案
> **难度**: ⭐⭐⭐⭐⭐

---

## 高可用架构模式

```text
高可用架构分类
══════════════════════════════════════════════════════════════════════════════

1. 主从复制（Master-Slave）
   ├─ 单主多从
   ├─ 读写分离
   └─ 故障自动切换

2. 主主复制（Master-Master）
   ├─ 双向复制
   ├─ 多活写入
   └─ 冲突解决

3. 集群模式（Cluster）
   ├─ Shared-Nothing
   ├─ 一致性协议（Raft/Paxos）
   └─ 分片（Sharding）

4. 云原生（Cloud-Native）
   ├─ 容器化（Kubernetes）
   ├─ 自动扩缩容
   └─ 托管服务（RDS）

可用性指标：
• 99.9% (3个9)  = 年停机时间 8.76小时
• 99.99% (4个9) = 年停机时间 52.56分钟
• 99.999% (5个9) = 年停机时间 5.26分钟
```

---

## 方案1：PostgreSQL主从复制（Streaming Replication）

### 架构图

```text
PostgreSQL主从复制架构
═══════════════════════════════════════════════════════════════

                    ┌──────────────┐
                    │  Application │
                    └───────┬──────┘
                            │
                    ┌───────▼──────┐
                    │ Load Balancer│
                    │   (HAProxy)  │
                    └───┬──────┬───┘
                        │      │
            Write       │      │       Read
        ┌───────────────┘      └───────────────┐
        │                                      │
┌───────▼────────┐                    ┌───────▼────────┐
│  Primary (RW)  │ ──Streaming WAL──> │ Standby 1 (RO) │
│  PostgreSQL    │                    │  PostgreSQL    │
│  Port: 5432    │                    │  Port: 5432    │
└────────────────┘                    └────────────────┘
        │                                      │
        │                             ┌────────▼────────┐
        └─────────────────────────────>│ Standby 2 (RO) │
                                      │  PostgreSQL    │
                                      │  Port: 5432    │
                                      └────────────────┘

特点:
• Primary: 读写
• Standby: 只读（Hot Standby）
• 异步/同步复制可选
• 自动故障切换（配合Patroni）
```

### 主库配置

```bash
# 1. 主库配置（postgresql.conf）
# 启用WAL归档和复制
wal_level = replica
max_wal_senders = 3  # 允许3个从库
wal_keep_size = 1GB  # 保留1GB的WAL
hot_standby = on

# 同步复制（可选，保证数据不丢失）
synchronous_commit = on
synchronous_standby_names = 'standby1,standby2'

# 2. 允许复制连接（pg_hba.conf）
# TYPE  DATABASE  USER        ADDRESS         METHOD
host    replication  replicator  192.168.1.0/24  md5

# 3. 创建复制用户
CREATE ROLE replicator WITH REPLICATION LOGIN PASSWORD 'secure_password';

# 4. 重启PostgreSQL
sudo systemctl restart postgresql
```

### 从库配置

```bash
# 1. 基础备份（在从库服务器执行）
sudo -u postgres pg_basebackup \
    -h primary_host \
    -D /var/lib/postgresql/14/main \
    -U replicator \
    -P \
    -v \
    -R \
    -X stream \
    -C -S standby1

# 参数说明：
# -h: 主库地址
# -D: 数据目录
# -U: 复制用户
# -P: 显示进度
# -v: 详细输出
# -R: 自动创建 standby.signal 和配置
# -X stream: 流式传输WAL
# -C -S: 创建复制槽 standby1

# 2. 从库配置（postgresql.auto.conf，-R会自动生成）
primary_conninfo = 'host=primary_host port=5432 user=replicator password=secure_password'
primary_slot_name = 'standby1'

# 3. 启动从库
sudo systemctl start postgresql

# 4. 验证复制状态
# 主库执行：
SELECT * FROM pg_stat_replication;

# 从库执行：
SELECT pg_is_in_recovery();  -- 应返回 t (true)
SELECT pg_last_wal_receive_lsn(), pg_last_wal_replay_lsn();
```

### 自动故障切换（Patroni）

```yaml
# patroni.yml（主库）
scope: postgres-cluster
name: node1

restapi:
  listen: 0.0.0.0:8008
  connect_address: 192.168.1.10:8008

etcd3:
  hosts: 192.168.1.20:2379,192.168.1.21:2379,192.168.1.22:2379

bootstrap:
  dcs:
    ttl: 30
    loop_wait: 10
    retry_timeout: 10
    maximum_lag_on_failover: 1048576
    postgresql:
      use_pg_rewind: true
      parameters:
        wal_level: replica
        hot_standby: on
        max_wal_senders: 3

postgresql:
  listen: 0.0.0.0:5432
  connect_address: 192.168.1.10:5432
  data_dir: /var/lib/postgresql/14/main
  authentication:
    replication:
      username: replicator
      password: secure_password
    superuser:
      username: postgres
      password: postgres_password

tags:
  nofailover: false
  noloadbalance: false
  clonefrom: false
  nosync: false
```

```bash
# 安装Patroni
sudo apt install python3-pip python3-etcd
sudo pip3 install patroni[etcd]

# 启动Patroni
sudo systemctl start patroni

# 查看集群状态
patronictl -c /etc/patroni/patroni.yml list

# 输出：
# + Cluster: postgres-cluster (7183749823047139000) ---+----+-----------+
# | Member | Host           | Role    | State   | TL | Lag in MB |
# +--------+----------------+---------+---------+----+-----------+
# | node1  | 192.168.1.10   | Leader  | running |  1 |           |
# | node2  | 192.168.1.11   | Replica | running |  1 |         0 |
# | node3  | 192.168.1.12   | Replica | running |  1 |         0 |
# +--------+----------------+---------+---------+----+-----------+

# 手动故障切换
patronictl -c /etc/patroni/patroni.yml switchover --master node1 --candidate node2
```

---

## 方案2：MySQL Group Replication

### 架构图

```text
MySQL Group Replication架构
═══════════════════════════════════════════════════════════════

┌────────────────────────────────────────────────────┐
│            Application Layer                       │
└────────────────┬───────────────────────────────────┘
                 │
        ┌────────▼────────┐
        │  MySQL Router   │ (读写分离，自动路由)
        └───┬─────────┬───┘
            │         │
    ┌───────┴───┐     └───────┬───────┐
    │           │             │       │
┌───▼────┐  ┌──▼─────┐  ┌────▼──┐  ┌─▼──────┐
│ Node 1 │  │ Node 2 │  │ Node 3│  │ Node 4 │
│(Primary)  │(Second)│  │(Second│  │(Second)│
│  RW    │  │   RO   │  │   RO  │  │   RO   │
└───┬────┘  └───┬────┘  └───┬───┘  └───┬────┘
    │           │           │          │
    └───────────┴───────────┴──────────┘
         Group Communication (Paxos)

特点:
• 多主写入（可选，单主模式推荐）
• 自动故障检测和恢复
• 一致性保证（基于Paxos）
• 自动数据冲突解决
```

### 配置

```ini
# 1. MySQL配置（my.cnf）所有节点相同

[mysqld]
# 服务器ID（每个节点唯一）
server_id=1  # Node 2改为2, Node 3改为3

# 启用GTID
gtid_mode=ON
enforce_gtid_consistency=ON

# 复制相关
log_bin=mysql-bin
binlog_format=ROW
binlog_checksum=NONE
master_info_repository=TABLE
relay_log_info_repository=TABLE

# Group Replication配置
plugin_load_add='group_replication.so'
transaction_write_set_extraction=XXHASH64

# 组名（所有节点相同）
group_replication_group_name="aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa"

# 本地地址（每个节点不同）
group_replication_local_address="192.168.1.10:33061"  # Node 1

# 组成员（所有节点相同）
group_replication_group_seeds="192.168.1.10:33061,192.168.1.11:33061,192.168.1.12:33061"

# 启动时不自动启动Group Replication
group_replication_start_on_boot=OFF

# 单主模式（推荐）
group_replication_single_primary_mode=ON
group_replication_enforce_update_everywhere_checks=OFF
```

```sql
-- 2. 配置复制用户（所有节点执行）
CREATE USER 'repl'@'%' IDENTIFIED BY 'secure_password';
GRANT REPLICATION SLAVE ON *.* TO 'repl'@'%';
GRANT CONNECTION_ADMIN ON *.* TO 'repl'@'%';
GRANT BACKUP_ADMIN ON *.* TO 'repl'@'%';
GRANT GROUP_REPLICATION_STREAM ON *.* TO 'repl'@'%';
FLUSH PRIVILEGES;

-- 配置复制通道
CHANGE REPLICATION SOURCE TO
    SOURCE_USER='repl',
    SOURCE_PASSWORD='secure_password'
    FOR CHANNEL 'group_replication_recovery';

-- 3. 启动Group Replication

-- Node 1（引导节点）
SET GLOBAL group_replication_bootstrap_group=ON;
START GROUP_REPLICATION;
SET GLOBAL group_replication_bootstrap_group=OFF;

-- Node 2/3/4（加入节点）
START GROUP_REPLICATION;

-- 4. 验证集群状态
SELECT * FROM performance_schema.replication_group_members;

-- 输出：
-- CHANNEL_NAME              | MEMBER_ID                            | MEMBER_HOST     | MEMBER_PORT | MEMBER_STATE | MEMBER_ROLE
-- --------------------------+--------------------------------------+-----------------+-------------+--------------+------------
-- group_replication_applier | aaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa    | 192.168.1.10    | 3306        | ONLINE       | PRIMARY
-- group_replication_applier | bbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb    | 192.168.1.11    | 3306        | ONLINE       | SECONDARY
-- group_replication_applier | ccccc-cccc-cccc-cccc-cccccccccccc    | 192.168.1.12    | 3306        | ONLINE       | SECONDARY
```

---

## 方案3：SQLite分布式方案（LiteFS）

### 架构图

```text
LiteFS分布式SQLite架构
═══════════════════════════════════════════════════════════════

┌────────────────────────────────────┐
│       Application Instances        │
│  ┌──────┐  ┌──────┐  ┌──────┐     │
│  │ App1 │  │ App2 │  │ App3 │     │
│  └──┬───┘  └──┬───┘  └──┬───┘     │
│     │         │         │          │
│  ┌──▼─────────▼─────────▼───┐     │
│  │      LiteFS FUSE Mount    │     │
│  │  (本地SQLite读写)          │     │
│  └──────────┬────────────────┘     │
└─────────────┼──────────────────────┘
              │
        ┌─────▼──────┐
        │  Primary   │
        │  LiteFS    │
        │ (Leader)   │
        └─────┬──────┘
              │ WAL复制
      ┌───────┼───────┐
      │               │
┌─────▼──────┐  ┌────▼───────┐
│ Replica 1  │  │ Replica 2  │
│  LiteFS    │  │  LiteFS    │
│ (Follower) │  │ (Follower) │
└────────────┘  └────────────┘

特点:
• FUSE文件系统（透明代理）
• Leader自动选举（Consul）
• WAL流式复制
• 最终一致性
```

### 配置

```yaml
# litefs.yml
fuse:
  dir: "/litefs"
  debug: false

data:
  dir: "/var/lib/litefs"

exec:
  - cmd: "/app/myapp"
    if-candidate: true

# Consul配置（用于Leader选举）
lease:
  type: "consul"
  advertise-url: "http://node1.example.com:20202"
  consul:
    url: "http://consul.example.com:8500"
    key: "litefs/primary"

proxy:
  addr: ":20202"
  target: "localhost:8080"
  db: "mydb.db"

# 日志
log:
  level: "info"
  format: "text"
```

```bash
# 部署LiteFS（Docker Compose）
version: "3"
services:
  # Consul（Leader选举）
  consul:
    image: consul:latest
    ports:
      - "8500:8500"
    command: "agent -server -ui -bootstrap-expect=1 -client=0.0.0.0"

  # Node 1（Primary候选）
  app1:
    image: myapp:latest
    volumes:
      - litefs1:/litefs
      - ./litefs.yml:/etc/litefs.yml
    environment:
      - LITEFS_CONFIG=/etc/litefs.yml
    depends_on:
      - consul

  # Node 2（Replica候选）
  app2:
    image: myapp:latest
    volumes:
      - litefs2:/litefs
      - ./litefs.yml:/etc/litefs.yml
    environment:
      - LITEFS_CONFIG=/etc/litefs.yml
    depends_on:
      - consul

volumes:
  litefs1:
  litefs2:
```

---

## 读写分离中间件（HAProxy）

```haproxy
# haproxy.cfg
global
    maxconn 4096
    log 127.0.0.1 local0

defaults
    log global
    mode tcp
    option tcplog
    timeout connect 5000ms
    timeout client 50000ms
    timeout server 50000ms

# PostgreSQL写入（路由到Primary）
listen postgres_write
    bind *:5433
    mode tcp
    balance roundrobin
    option pgsql-check user postgres
    server primary 192.168.1.10:5432 check

# PostgreSQL读取（路由到所有节点）
listen postgres_read
    bind *:5434
    mode tcp
    balance roundrobin
    option pgsql-check user postgres
    server primary 192.168.1.10:5432 check weight 1
    server standby1 192.168.1.11:5432 check weight 2
    server standby2 192.168.1.12:5432 check weight 2

# 统计页面
listen stats
    bind *:8404
    stats enable
    stats uri /stats
    stats refresh 30s
    stats admin if TRUE
```

```python
# Python应用连接代码
import psycopg2

class DatabasePool:
    def __init__(self):
        # 写连接（Primary）
        self.write_conn = psycopg2.connect(
            host='haproxy_host',
            port=5433,
            database='mydb',
            user='myuser',
            password='mypass'
        )

        # 读连接池（Standby）
        self.read_pool = []
        for _ in range(5):
            conn = psycopg2.connect(
                host='haproxy_host',
                port=5434,
                database='mydb',
                user='myuser',
                password='mypass'
            )
            self.read_pool.append(conn)

    def execute_write(self, sql, params=()):
        """写操作"""
        cursor = self.write_conn.cursor()
        cursor.execute(sql, params)
        self.write_conn.commit()
        return cursor.rowcount

    def execute_read(self, sql, params=()):
        """读操作"""
        import random
        conn = random.choice(self.read_pool)
        cursor = conn.cursor()
        cursor.execute(sql, params)
        return cursor.fetchall()
```

---

## 监控与告警

```python
# database_monitor.py
import psycopg2
import time
import smtplib
from email.mime.text import MIMEText

class DatabaseMonitor:
    def __init__(self, dsn, thresholds):
        self.dsn = dsn
        self.thresholds = thresholds

    def check_replication_lag(self):
        """检查复制延迟"""
        conn = psycopg2.connect(self.dsn)
        cursor = conn.cursor()

        # 主库查询
        cursor.execute("""
            SELECT
                client_addr,
                state,
                sent_lsn,
                write_lsn,
                flush_lsn,
                replay_lsn,
                pg_wal_lsn_diff(sent_lsn, replay_lsn) / 1024 / 1024 AS lag_mb
            FROM pg_stat_replication
        """)

        for row in cursor.fetchall():
            lag_mb = row[-1]
            if lag_mb > self.thresholds['replication_lag_mb']:
                self.send_alert(
                    f"复制延迟过高: {row[0]}, 延迟 {lag_mb:.2f} MB"
                )

        conn.close()

    def check_connection_count(self):
        """检查连接数"""
        conn = psycopg2.connect(self.dsn)
        cursor = conn.cursor()

        cursor.execute("SELECT count(*) FROM pg_stat_activity")
        conn_count = cursor.fetchone()[0]

        cursor.execute("SHOW max_connections")
        max_conn = int(cursor.fetchone()[0])

        usage_pct = (conn_count / max_conn) * 100

        if usage_pct > self.thresholds['connection_usage_pct']:
            self.send_alert(
                f"连接数过高: {conn_count}/{max_conn} ({usage_pct:.1f}%)"
            )

        conn.close()

    def send_alert(self, message):
        """发送告警邮件"""
        msg = MIMEText(message)
        msg['Subject'] = 'Database Alert'
        msg['From'] = 'monitor@example.com'
        msg['To'] = 'admin@example.com'

        smtp = smtplib.SMTP('smtp.example.com')
        smtp.send_message(msg)
        smtp.quit()

        print(f"⚠️  ALERT: {message}")

    def run(self, interval=60):
        """监控循环"""
        while True:
            try:
                self.check_replication_lag()
                self.check_connection_count()
            except Exception as e:
                print(f"监控错误: {e}")

            time.sleep(interval)

# 使用
monitor = DatabaseMonitor(
    dsn='postgresql://postgres:password@primary_host/postgres',
    thresholds={
        'replication_lag_mb': 100,  # 100MB
        'connection_usage_pct': 80,  # 80%
    }
)
monitor.run()
```

---

**文档版本**: v1.0.0
**最后更新**: 2025-12-04
