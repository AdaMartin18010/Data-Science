# SQL注入防护完整指南

> **创建日期**: 2025-12-05
> **安全等级**: ⭐⭐⭐⭐⭐ Critical
> **适用**: 所有SQL数据库

---

## SQL注入原理

```text
SQL注入攻击原理
══════════════════════════════════════════════════════════════════════════════

正常查询:
  SELECT * FROM users WHERE username = 'alice' AND password = 'secret123';

SQL注入（恶意输入）:
  username = "admin' --"
  password = "任意值"

拼接后的SQL:
  SELECT * FROM users WHERE username = 'admin' --' AND password = '任意值';
                                            ↑注释掉后面的条件

等价于:
  SELECT * FROM users WHERE username = 'admin';

结果：绕过密码验证！

危险示例（Python）:
# ❌ 错误：字符串拼接
username = request.form['username']
password = request.form['password']
sql = f"SELECT * FROM users WHERE username = '{username}' AND password = '{password}'"
cursor.execute(sql)
```

---

## 攻击类型分类

### 1. 经典SQL注入

```sql
-- 攻击1：注释绕过
输入: admin' --
SQL: SELECT * FROM users WHERE username = 'admin' --' AND password = '...'

-- 攻击2：永真条件
输入: ' OR '1'='1
SQL: SELECT * FROM users WHERE username = '' OR '1'='1' AND password = '...'
-- 永远为真，返回所有用户

-- 攻击3：UNION查询
输入: ' UNION SELECT card_number, cvv, NULL FROM credit_cards --
SQL: SELECT id, username, email FROM users WHERE id = ''
     UNION SELECT card_number, cvv, NULL FROM credit_cards --'
-- 泄露敏感数据

-- 攻击4：堆叠查询
输入: '; DROP TABLE users; --
SQL: SELECT * FROM products WHERE id = ''; DROP TABLE users; --'
-- MySQL不支持堆叠，但PostgreSQL/SQL Server支持！
```

### 2. 盲注（Blind SQL Injection）

```sql
-- 时间盲注
输入: ' AND IF(SUBSTRING(password,1,1)='a', SLEEP(5), 0) --

-- 逐字符爆破密码
for char in 'abcdefghijklmnopqrstuvwxyz0123456789':
    payload = f"' AND IF(SUBSTRING(password,1,1)='{char}', SLEEP(5), 0) --"
    start = time.time()
    inject(payload)
    elapsed = time.time() - start
    if elapsed > 5:
        print(f"First char: {char}")
        break

-- 布尔盲注
输入: ' AND (SELECT COUNT(*) FROM users) > 100 --
-- 根据返回结果（有无数据）判断条件真假
```

### 3. 二阶注入（Second-Order Injection）

```sql
-- 第一步：插入恶意数据（经过转义，看似安全）
INSERT INTO users (username) VALUES ('admin''--');  -- username = admin'--

-- 第二步：读取并再次使用（未转义）
username = db.query("SELECT username FROM users WHERE id = 1")[0]
sql = f"DELETE FROM logs WHERE username = '{username}'"
-- 实际执行：DELETE FROM logs WHERE username = 'admin'--'
-- 删除所有日志！
```

---

## 防护方案

### 方案1：参数化查询（强烈推荐）⭐⭐⭐⭐⭐

```python
# ✅ 正确：使用参数化查询

# PostgreSQL (psycopg2)
import psycopg2

conn = psycopg2.connect("...")
cursor = conn.cursor()

username = request.form['username']
password = request.form['password']

# 使用参数占位符
cursor.execute(
    "SELECT * FROM users WHERE username = %s AND password = %s",
    (username, password)  # 参数元组
)

# MySQL (mysql-connector-python)
import mysql.connector

conn = mysql.connector.connect(...)
cursor = conn.cursor()

cursor.execute(
    "SELECT * FROM users WHERE username = %s AND password = %s",
    (username, password)
)

# SQLite (sqlite3)
import sqlite3

conn = sqlite3.connect('app.db')
cursor = conn.cursor()

cursor.execute(
    "SELECT * FROM users WHERE username = ? AND password = ?",
    (username, password)
)

# SQL Server (pyodbc)
import pyodbc

conn = pyodbc.connect(...)
cursor = conn.cursor()

cursor.execute(
    "SELECT * FROM users WHERE username = ? AND password = ?",
    username, password
)

原理：
• 参数值不参与SQL解析
• 数据库将参数作为"数据"而非"代码"
• 即使包含特殊字符也安全
```

### 方案2：ORM框架

```python
# ✅ 使用ORM（SQLAlchemy）

from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

Base = declarative_base()

class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    username = Column(String(50))
    password = Column(String(100))

engine = create_engine('postgresql://...')
Session = sessionmaker(bind=engine)
session = Session()

# 查询（自动参数化）
username = request.form['username']
password = request.form['password']

user = session.query(User).filter(
    User.username == username,
    User.password == password
).first()

# ORM生成的SQL（安全）:
# SELECT * FROM users WHERE username = %s AND password = %s

优势:
• 自动参数化
• 类型安全
• 业务逻辑与SQL分离
• 跨数据库兼容

ORM示例（其他语言）:
• Java: Hibernate, MyBatis
• C#: Entity Framework
• Ruby: ActiveRecord
• PHP: Eloquent (Laravel)
```

### 方案3：输入验证（辅助防护）

```python
# ✅ 输入验证（但不能单独依赖）

import re

def validate_username(username):
    """用户名验证"""
    # 只允许字母、数字、下划线
    if not re.match(r'^[a-zA-Z0-9_]{3,20}$', username):
        raise ValueError("Invalid username")
    return username

def validate_email(email):
    """邮箱验证"""
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(pattern, email):
        raise ValueError("Invalid email")
    return email

def validate_integer(value):
    """整数验证"""
    try:
        return int(value)
    except ValueError:
        raise ValueError("Invalid integer")

# 使用
username = validate_username(request.form['username'])
user_id = validate_integer(request.form['user_id'])

# 仍然使用参数化查询！
cursor.execute(
    "SELECT * FROM users WHERE username = %s AND id = %s",
    (username, user_id)
)

白名单 vs 黑名单:
✓ 白名单（推荐）: 只允许合法字符
✗ 黑名单（不推荐）: 过滤危险字符（容易遗漏）

危险的黑名单:
# ❌ 不安全
def unsafe_filter(input):
    # 尝试过滤特殊字符
    return input.replace("'", "").replace("--", "").replace(";", "")

# 仍可绕过：
# 输入：admin'/**/OR/**/1=1/**/--
# 使用空格注释绕过
```

---

## 存储过程/函数注入

```sql
-- 场景：动态SQL

-- ❌ 不安全的存储过程
CREATE OR REPLACE FUNCTION search_users(search_term TEXT)
RETURNS TABLE (id INT, username TEXT) AS $$
BEGIN
    RETURN QUERY EXECUTE
        'SELECT id, username FROM users WHERE username LIKE ''%' || search_term || '%''';
END;
$$ LANGUAGE plpgsql;

-- 攻击：
SELECT * FROM search_users('%'' OR 1=1 --');
-- 实际执行：
-- SELECT id, username FROM users WHERE username LIKE '%%' OR 1=1 --%%'

-- ✅ 安全的存储过程（使用EXECUTE with USING）
CREATE OR REPLACE FUNCTION search_users_safe(search_term TEXT)
RETURNS TABLE (id INT, username TEXT) AS $$
BEGIN
    RETURN QUERY EXECUTE
        'SELECT id, username FROM users WHERE username LIKE $1'
    USING '%' || search_term || '%';  -- 参数化
END;
$$ LANGUAGE plpgsql;

-- MySQL示例
DELIMITER $$

CREATE PROCEDURE search_users_safe(IN search_term VARCHAR(100))
BEGIN
    SET @sql = 'SELECT id, username FROM users WHERE username LIKE ?';
    PREPARE stmt FROM @sql;
    SET @param = CONCAT('%', search_term, '%');
    EXECUTE stmt USING @param;
    DEALLOCATE PREPARE stmt;
END$$

DELIMITER ;
```

---

## ORM注入风险

```python
# ⚠️ ORM也可能有注入风险

from sqlalchemy import text

# ❌ 不安全：使用text()和字符串拼接
username = request.form['username']
sql = text(f"SELECT * FROM users WHERE username = '{username}'")
result = session.execute(sql)

# ✅ 安全：使用text()和参数绑定
username = request.form['username']
sql = text("SELECT * FROM users WHERE username = :username")
result = session.execute(sql, {"username": username})

# ❌ Django ORM不安全用法
User.objects.extra(where=[f"username = '{username}'"])  # 危险！

# ✅ Django ORM安全用法
User.objects.filter(username=username)  # 安全

# ❌ raw()不安全用法
User.objects.raw(f"SELECT * FROM users WHERE username = '{username}'")

# ✅ raw()安全用法
User.objects.raw("SELECT * FROM users WHERE username = %s", [username])
```

---

## 防护检查清单

```text
SQL注入防护Checklist
══════════════════════════════════════════════════════════════════════════════

□ 代码层面
  □ 所有SQL查询使用参数化查询/预编译语句
  □ 避免字符串拼接构造SQL
  □ ORM查询避免raw()或extra()
  □ 存储过程使用EXECUTE...USING
  □ 动态表名/列名使用白名单验证

□ 输入验证
  □ 实施输入白名单验证
  □ 长度限制检查
  □ 类型检查（整数/邮箱/日期）
  □ 特殊字符过滤（辅助措施）

□ 数据库配置
  □ 最小权限原则（应用账户只需CRUD权限）
  □ 禁止DROP/ALTER权限
  □ 禁止GRANT权限
  □ 分离管理账户和应用账户

□ 网络安全
  □ 使用防火墙（只允许应用服务器连接）
  □ 禁止数据库直接暴露到公网
  □ 使用SSL/TLS加密连接

□ 监控与审计
  □ 启用慢查询日志
  □ 监控异常查询模式
  □ 审计数据库访问日志
  □ 设置告警（如UNION/DROP关键词）

□ WAF（Web Application Firewall）
  □ ModSecurity规则
  □ 云WAF（AWS WAF/Azure WAF）
  □ SQL注入特征识别
```

---

## 安全配置

### PostgreSQL安全配置

```sql
-- 1. 创建应用专用账户（最小权限）
CREATE USER app_user WITH PASSWORD 'secure_password';

-- 2. 只授予必要权限
GRANT CONNECT ON DATABASE mydb TO app_user;
GRANT USAGE ON SCHEMA public TO app_user;
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO app_user;
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO app_user;

-- 3. 禁止危险权限
-- ✗ 不授予：DROP, ALTER, CREATE, GRANT

-- 4. 行级安全（RLS）
ALTER TABLE orders ENABLE ROW LEVEL SECURITY;

CREATE POLICY user_orders_policy ON orders
FOR ALL
TO app_user
USING (user_id = current_setting('app.current_user_id')::INT);

-- 应用设置current_user_id
SET app.current_user_id = 123;
SELECT * FROM orders;  -- 只能看到user_id=123的订单

-- 5. 连接限制
ALTER USER app_user CONNECTION LIMIT 100;

-- 6. pg_hba.conf配置
# TYPE  DATABASE  USER      ADDRESS        METHOD
host    mydb      app_user  10.0.0.0/8     md5      # 内网
host    mydb      app_user  0.0.0.0/0      reject   # 拒绝外网
```

### MySQL安全配置

```sql
-- 1. 创建应用账户
CREATE USER 'app_user'@'10.0.%.%' IDENTIFIED BY 'secure_password';

-- 2. 授予权限
GRANT SELECT, INSERT, UPDATE, DELETE ON mydb.* TO 'app_user'@'10.0.%.%';

-- 3. 禁止LOAD DATA（防止读取服务器文件）
REVOKE FILE ON *.* FROM 'app_user'@'10.0.%.%';

-- 4. 禁止SUPER权限
-- 默认不授予

-- 5. 连接限制
ALTER USER 'app_user'@'10.0.%.%' WITH MAX_USER_CONNECTIONS 100;

-- 6. 启用审计插件
INSTALL PLUGIN audit_log SONAME 'audit_log.so';
SET GLOBAL audit_log_file = '/var/log/mysql/audit.log';
SET GLOBAL audit_log_policy = 'ALL';
```

---

## 防护代码模板

### Python防护模板

```python
import psycopg2
from psycopg2 import sql
import re

class SafeDatabase:
    """安全的数据库操作封装"""

    def __init__(self, dsn):
        self.conn = psycopg2.connect(dsn)

    def safe_query(self, table, columns, conditions):
        """安全查询（带验证）"""
        # 验证表名（白名单）
        allowed_tables = ['users', 'orders', 'products']
        if table not in allowed_tables:
            raise ValueError(f"Invalid table: {table}")

        # 验证列名（白名单）
        allowed_columns = {
            'users': ['id', 'username', 'email'],
            'orders': ['id', 'user_id', 'total'],
            'products': ['id', 'name', 'price']
        }
        for col in columns:
            if col not in allowed_columns[table]:
                raise ValueError(f"Invalid column: {col}")

        # 构造查询（使用psycopg2.sql防止表名注入）
        query = sql.SQL("SELECT {columns} FROM {table} WHERE {conditions}").format(
            columns=sql.SQL(', ').join(map(sql.Identifier, columns)),
            table=sql.Identifier(table),
            conditions=sql.SQL(' AND ').join(
                sql.SQL("{} = %s").format(sql.Identifier(k))
                for k in conditions.keys()
            )
        )

        # 执行（参数化）
        cursor = self.conn.cursor()
        cursor.execute(query, list(conditions.values()))
        return cursor.fetchall()

    def safe_insert(self, table, data):
        """安全插入"""
        # 验证表名
        # 验证列名
        # ...

        columns = data.keys()
        query = sql.SQL("INSERT INTO {table} ({columns}) VALUES ({placeholders})").format(
            table=sql.Identifier(table),
            columns=sql.SQL(', ').join(map(sql.Identifier, columns)),
            placeholders=sql.SQL(', ').join(sql.Placeholder() * len(columns))
        )

        cursor = self.conn.cursor()
        cursor.execute(query, list(data.values()))
        self.conn.commit()
        return cursor.lastrowid

# 使用
db = SafeDatabase('postgresql://...')
users = db.safe_query('users', ['id', 'username'], {'username': user_input})
```

### Node.js防护模板

```javascript
// ✅ 使用pg库（PostgreSQL）
const { Pool } = require('pg');
const pool = new Pool({ connectionString: '...' });

async function safeQuery(username, password) {
    // 参数化查询
    const result = await pool.query(
        'SELECT * FROM users WHERE username = $1 AND password = $2',
        [username, password]
    );
    return result.rows;
}

// ✅ 使用mysql2库（MySQL）
const mysql = require('mysql2/promise');
const pool = mysql.createPool({ ... });

async function safeQuery(username, password) {
    const [rows] = await pool.execute(
        'SELECT * FROM users WHERE username = ? AND password = ?',
        [username, password]
    );
    return rows;
}

// ⚠️ 动态表名（需要白名单）
function safeQueryTable(tableName, columns, conditions) {
    // 白名单验证
    const allowedTables = ['users', 'orders', 'products'];
    if (!allowedTables.includes(tableName)) {
        throw new Error('Invalid table');
    }

    // 使用mysql2的escapeId（转义标识符）
    const connection = await pool.getConnection();
    const sql = `SELECT ?? FROM ?? WHERE ?`;
    const [rows] = await connection.query(sql, [columns, tableName, conditions]);
    connection.release();
    return rows;
}
```

---

## 测试与检测

### 自动化测试

```python
# SQL注入测试用例

import pytest

class TestSQLInjection:
    """SQL注入测试套件"""

    @pytest.fixture
    def db(self):
        # 测试数据库
        conn = sqlite3.connect(':memory:')
        conn.execute('CREATE TABLE users (id INTEGER, username TEXT, password TEXT)')
        conn.execute("INSERT INTO users VALUES (1, 'admin', 'secret')")
        conn.commit()
        return conn

    def test_classic_injection(self, db):
        """测试经典注入"""
        # 恶意输入
        username = "admin' --"

        # ❌ 不安全方法（应该失败）
        try:
            cursor = db.execute(f"SELECT * FROM users WHERE username = '{username}'")
            rows = cursor.fetchall()
            assert len(rows) == 0, "SQL injection vulnerability!"
        except:
            pass  # 预期错误

        # ✅ 安全方法（应该成功）
        cursor = db.execute("SELECT * FROM users WHERE username = ?", (username,))
        rows = cursor.fetchall()
        assert len(rows) == 0, "No user found (safe)"

    def test_union_injection(self, db):
        """测试UNION注入"""
        username = "' UNION SELECT 999, 'hacker', 'hacked' --"

        # 安全方法
        cursor = db.execute("SELECT * FROM users WHERE username = ?", (username,))
        rows = cursor.fetchall()
        assert len(rows) == 0  # 安全，找不到该用户名

    def test_blind_injection(self, db):
        """测试盲注"""
        # 尝试时间盲注
        import time
        username = "' AND (SELECT CASE WHEN 1=1 THEN sqlite_version() END) --"

        start = time.time()
        cursor = db.execute("SELECT * FROM users WHERE username = ?", (username,))
        elapsed = time.time() - start

        assert elapsed < 0.1, "Query should be fast (no delay injection)"

# 运行测试
pytest test_sql_injection.py
```

### 手动渗透测试

```text
SQL注入测试Payload库
══════════════════════════════════════════════════════════════════════════════

经典注入:
• ' OR '1'='1
• ' OR 1=1 --
• admin' --
• admin' #
• ' UNION SELECT NULL, NULL --

数字注入:
• 1 OR 1=1
• 1' OR '1'='1
• 1 AND 1=2 UNION SELECT ...

时间盲注:
• ' AND SLEEP(5) --  (MySQL)
• ' AND pg_sleep(5) --  (PostgreSQL)
• ' AND (SELECT COUNT(*) FROM generate_series(1,10000000)) --  (延迟)

布尔盲注:
• ' AND (SELECT COUNT(*) FROM users) > 0 --
• ' AND SUBSTRING(password,1,1)='a' --

堆叠查询:
• '; DROP TABLE users; --
• '; INSERT INTO admins VALUES ('hacker', 'hacked'); --

NoSQL注入（MongoDB）:
• {"username": {"$ne": null}, "password": {"$ne": null}}
• {"username": {"$gt": ""}, "password": {"$gt": ""}}

测试工具:
• sqlmap: 自动化SQL注入工具
• Burp Suite: Web渗透测试
• OWASP ZAP: 安全扫描
```

---

**文档版本**: v1.0
**最后更新**: 2025-12-05
**安全等级**: Critical⭐⭐⭐⭐⭐
