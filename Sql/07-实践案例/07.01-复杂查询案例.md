# å¤æ‚æŸ¥è¯¢æ¡ˆä¾‹

> **åˆ›å»ºæ—¥æœŸ**ï¼š2025-01-15
> **æœ€åæ›´æ–°**ï¼š2025-12-01
> **ç‰ˆæœ¬**ï¼šv2.0.0
> **éš¾åº¦**ï¼šâ­â­â­â­
> **åº”ç”¨åœºæ™¯**ï¼šå¤æ‚æŸ¥è¯¢è®¾è®¡ã€æ€§èƒ½ä¼˜åŒ–ã€æœ€ä½³å®è·µã€RAGæ£€ç´¢

---

## ğŸ“‹ ç›®å½•

- [å¤æ‚æŸ¥è¯¢æ¡ˆä¾‹](#å¤æ‚æŸ¥è¯¢æ¡ˆä¾‹)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ä¸€ã€æ¦‚è¿°](#ä¸€æ¦‚è¿°)
    - [1.1 å¤æ‚æŸ¥è¯¢åˆ†ç±»æ€ç»´å¯¼å›¾](#11-å¤æ‚æŸ¥è¯¢åˆ†ç±»æ€ç»´å¯¼å›¾)
    - [1.2 æŸ¥è¯¢å¤æ‚åº¦å¯¹æ¯”çŸ©é˜µ](#12-æŸ¥è¯¢å¤æ‚åº¦å¯¹æ¯”çŸ©é˜µ)
  - [äºŒã€å¤šè¡¨è¿æ¥æŸ¥è¯¢](#äºŒå¤šè¡¨è¿æ¥æŸ¥è¯¢)
    - [2.1 æ¡ˆä¾‹ï¼šå­¦ç”Ÿé€‰è¯¾æŸ¥è¯¢](#21-æ¡ˆä¾‹å­¦ç”Ÿé€‰è¯¾æŸ¥è¯¢)
    - [æ–¹æ¡ˆ1ï¼šç›¸å…³å­æŸ¥è¯¢ï¼ˆåŸºç¡€æ–¹æ¡ˆï¼‰](#æ–¹æ¡ˆ1ç›¸å…³å­æŸ¥è¯¢åŸºç¡€æ–¹æ¡ˆ)
    - [æ–¹æ¡ˆ2ï¼šçª—å£å‡½æ•°ï¼ˆæ¨èæ–¹æ¡ˆï¼‰](#æ–¹æ¡ˆ2çª—å£å‡½æ•°æ¨èæ–¹æ¡ˆ)
  - [å››ã€çª—å£å‡½æ•°åº”ç”¨](#å››çª—å£å‡½æ•°åº”ç”¨)
    - [4.1 æ¡ˆä¾‹ï¼šå­¦ç”Ÿæˆç»©æ’å](#41-æ¡ˆä¾‹å­¦ç”Ÿæˆç»©æ’å)
  - [äº”ã€é€’å½’æŸ¥è¯¢åº”ç”¨](#äº”é€’å½’æŸ¥è¯¢åº”ç”¨)
    - [5.1 æ¡ˆä¾‹ï¼šç»„ç»‡å±‚æ¬¡ç»“æ„](#51-æ¡ˆä¾‹ç»„ç»‡å±‚æ¬¡ç»“æ„)
  - [å…­ã€æ€§èƒ½ä¼˜åŒ–](#å…­æ€§èƒ½ä¼˜åŒ–)
    - [6.1 ä¼˜åŒ–å»ºè®®](#61-ä¼˜åŒ–å»ºè®®)
      - [1. ç´¢å¼•ä¼˜åŒ–](#1-ç´¢å¼•ä¼˜åŒ–)
      - [2. æŸ¥è¯¢é‡å†™](#2-æŸ¥è¯¢é‡å†™)
      - [3. ä½¿ç”¨EXPLAINåˆ†ææŸ¥è¯¢è®¡åˆ’](#3-ä½¿ç”¨explainåˆ†ææŸ¥è¯¢è®¡åˆ’)
  - [ä¸ƒã€2025 RAGæ£€ç´¢æ¡ˆä¾‹](#ä¸ƒ2025-ragæ£€ç´¢æ¡ˆä¾‹)
    - [7.1 ä¼ä¸šçŸ¥è¯†åº“RAG Schema](#71-ä¼ä¸šçŸ¥è¯†åº“rag-schema)
    - [7.2 æ··åˆæ£€ç´¢æŸ¥è¯¢](#72-æ··åˆæ£€ç´¢æŸ¥è¯¢)
    - [7.3 RAGä¸Šä¸‹æ–‡æ„å»º](#73-ragä¸Šä¸‹æ–‡æ„å»º)
    - [7.4 æŸ¥è¯¢æ—¥å¿—ä¸åˆ†æ](#74-æŸ¥è¯¢æ—¥å¿—ä¸åˆ†æ)
    - [7.5 2025 RAGæŸ¥è¯¢æ¨¡å¼çŸ©é˜µ](#75-2025-ragæŸ¥è¯¢æ¨¡å¼çŸ©é˜µ)
  - [å…«ã€ç«¯åˆ°ç«¯ä¸šåŠ¡æ¡ˆä¾‹ï¼šç”µå•†è®¢å•ç³»ç»Ÿ ğŸ†•](#å…«ç«¯åˆ°ç«¯ä¸šåŠ¡æ¡ˆä¾‹ç”µå•†è®¢å•ç³»ç»Ÿ-)
    - [8.1 ä¸šåŠ¡éœ€æ±‚æè¿°](#81-ä¸šåŠ¡éœ€æ±‚æè¿°)
    - [8.2 PostgreSQL 18 æ•°æ®æ¨¡å‹](#82-postgresql-18-æ•°æ®æ¨¡å‹)
    - [8.3 æ ¸å¿ƒä¸šåŠ¡æŸ¥è¯¢](#83-æ ¸å¿ƒä¸šåŠ¡æŸ¥è¯¢)
    - [8.4 SQLite 3.45+ ç®€åŒ–ç‰ˆæœ¬](#84-sqlite-345-ç®€åŒ–ç‰ˆæœ¬)
    - [8.5 æ€§èƒ½ä¼˜åŒ–å»ºè®®](#85-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
  - [ä¹ã€ç›¸å…³èµ„æº](#ä¹ç›¸å…³èµ„æº)
    - [ç›¸å…³æ–‡æ¡£](#ç›¸å…³æ–‡æ¡£)
    - [2025æ–°èµ„æº](#2025æ–°èµ„æº)

---

## ä¸€ã€æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›å¤æ‚SQLæŸ¥è¯¢çš„å®é™…æ¡ˆä¾‹ï¼Œå±•ç¤ºå¦‚ä½•è®¾è®¡é«˜æ•ˆçš„å¤æ‚æŸ¥è¯¢ã€‚

### 1.1 å¤æ‚æŸ¥è¯¢åˆ†ç±»æ€ç»´å¯¼å›¾

```mermaid
mindmap
  root((å¤æ‚æŸ¥è¯¢))
    å¤šè¡¨è¿æ¥
      å†…è¿æ¥
        ç­‰å€¼è¿æ¥
        éç­‰å€¼è¿æ¥
      å¤–è¿æ¥
        å·¦å¤–è¿æ¥
        å³å¤–è¿æ¥
        å…¨å¤–è¿æ¥
      è‡ªè¿æ¥
        å±‚æ¬¡ç»“æ„
        é€’å½’å…³ç³»
    å­æŸ¥è¯¢
      æ ‡é‡å­æŸ¥è¯¢
        å•å€¼è¿”å›
        æ¡ä»¶åˆ¤æ–­
      ç›¸å…³å­æŸ¥è¯¢
        å¤–éƒ¨å¼•ç”¨
        é€è¡Œå¤„ç†
      åµŒå¥—å­æŸ¥è¯¢
        å¤šå±‚åµŒå¥—
        å¤æ‚é€»è¾‘
    çª—å£å‡½æ•°
      æ’åå‡½æ•°
        ROW_NUMBER
        RANK
        DENSE_RANK
      èšåˆçª—å£
        ç´¯è®¡ç»Ÿè®¡
        ç§»åŠ¨å¹³å‡
      å€¼å‡½æ•°
        LAG/LEAD
        FIRST/LAST
    é€’å½’æŸ¥è¯¢
      WITH RECURSIVE
        å±‚æ¬¡éå†
        å›¾éå†
        æ ‘å½¢ç»“æ„
    é›†åˆæ“ä½œ
      UNION
        å¹¶é›†
        å»é‡
      INTERSECT
        äº¤é›†
      EXCEPT
        å·®é›†
```

### 1.2 æŸ¥è¯¢å¤æ‚åº¦å¯¹æ¯”çŸ©é˜µ

| æŸ¥è¯¢ç±»å‹ | å¤æ‚åº¦ | æ€§èƒ½å½±å“ | ä¼˜åŒ–éš¾åº¦ | é€‚ç”¨åœºæ™¯ |
|---------|--------|---------|---------|---------|
| **ç®€å•æŸ¥è¯¢** | â­ | ä½ | æ˜“ | å•è¡¨æŸ¥è¯¢ |
| **å¤šè¡¨è¿æ¥** | â­â­ | ä¸­ | ä¸­ | å…³è”æŸ¥è¯¢ |
| **å­æŸ¥è¯¢** | â­â­â­ | ä¸­-é«˜ | ä¸­-éš¾ | å¤æ‚æ¡ä»¶ |
| **çª—å£å‡½æ•°** | â­â­â­ | ä¸­ | ä¸­ | æ’åç»Ÿè®¡ |
| **é€’å½’æŸ¥è¯¢** | â­â­â­â­ | é«˜ | éš¾ | å±‚æ¬¡ç»“æ„ |
| **å¤æ‚ç»„åˆ** | â­â­â­â­â­ | å¾ˆé«˜ | å¾ˆéš¾ | ç»¼åˆåœºæ™¯ |

---

## äºŒã€å¤šè¡¨è¿æ¥æŸ¥è¯¢

### 2.1 æ¡ˆä¾‹ï¼šå­¦ç”Ÿé€‰è¯¾æŸ¥è¯¢

**éœ€æ±‚**ï¼šæŸ¥è¯¢æ¯ä¸ªå­¦ç”Ÿé€‰ä¿®çš„è¯¾ç¨‹åŠå…¶æˆç»©

**ERå›¾**ï¼š

```mermaid
erDiagram
    Student ||--o{ Enrollment : "é€‰è¯¾"
    Course ||--o{ Enrollment : "è¢«é€‰"
    Student {
        int student_id PK
        string name
        int age
        string major
    }
    Course {
        int course_id PK
        string course_name
        string instructor
        int credits
    }
    Enrollment {
        int student_id FK
        int course_id FK
        int score
        date enroll_date
    }
```

**æ•°æ®æ¨¡å‹**ï¼š

```text
å­¦ç”Ÿè¡¨(Student)ï¼š
| student_id | name | age | major |
|------------|------|-----|-------|
| 1          | å¼ ä¸‰ | 20  | è®¡ç®—æœº |
| 2          | æå›› | 21  | æ•°å­¦   |

è¯¾ç¨‹è¡¨(Course)ï¼š
| course_id | course_name | instructor | credits |
|-----------|-------------|------------|---------|
| 101       | æ•°æ®åº“      | ç‹è€å¸ˆ     | 3       |
| 102       | ç®—æ³•        | æè€å¸ˆ     | 4       |

é€‰è¯¾è¡¨(Enrollment)ï¼š
| student_id | course_id | score | enroll_date |
|------------|-----------|-------|-------------|
| 1          | 101       | 85    | 2024-01-15  |
| 1          | 102       | 90    | 2024-01-15  |
| 2          | 101       | 78    | 2024-01-16  |
```

**æŸ¥è¯¢**ï¼š

```sql
SELECT
    s.student_id,
    s.name,
    c.course_name,
    e.score
FROM Student s
INNER JOIN Enrollment e ON s.student_id = e.student_id
INNER JOIN Course c ON e.course_id = c.course_id
ORDER BY s.student_id, e.score DESC;
```

**æŸ¥è¯¢æ‰§è¡Œæµç¨‹æ—¶åºå›¾**ï¼š

```mermaid
sequenceDiagram
    participant Client
    participant Optimizer
    participant Executor
    participant Student
    participant Enrollment
    participant Course

    Client->>Optimizer: æäº¤SQLæŸ¥è¯¢
    Optimizer->>Optimizer: è§£ææŸ¥è¯¢
    Optimizer->>Optimizer: ç”Ÿæˆæ‰§è¡Œè®¡åˆ’
    Optimizer->>Executor: æ‰§è¡Œè®¡åˆ’

    Executor->>Student: æ‰«æStudentè¡¨
    Student-->>Executor: è¿”å›å­¦ç”Ÿæ•°æ®

    Executor->>Enrollment: è¿æ¥Enrollmentè¡¨
    Enrollment-->>Executor: è¿”å›é€‰è¯¾æ•°æ®

    Executor->>Course: è¿æ¥Courseè¡¨
    Course-->>Executor: è¿”å›è¯¾ç¨‹æ•°æ®

    Executor->>Executor: æ’åºç»“æœ
    Executor-->>Client: è¿”å›æœ€ç»ˆç»“æœ
```

**å…³ç³»ä»£æ•°è¡¨ç¤º**ï¼š

```latex
Ï€_{student_id, name, course_name, score}(
    Ïƒ_{Student.student_id = Enrollment.student_id}(
        Student Ã— Enrollment
    ) â‹ˆ_{Enrollment.course_id = Course.course_id} Course
)
```

**æŸ¥è¯¢ç»“æœ**ï¼š

```text
| student_id | name | course_name | score |
|------------|------|-------------|-------|
| 1          | å¼ ä¸‰ | ç®—æ³•        | 90    |
| 1          | å¼ ä¸‰ | æ•°æ®åº“      | 85    |
| 2          | æå›› | æ•°æ®åº“      | 78    |
```

**æ€§èƒ½ä¼˜åŒ–å»ºè®®**ï¼š

1. **ç´¢å¼•ä¼˜åŒ–**ï¼š

    ```sql
   CREATE INDEX idx_enrollment_student ON Enrollment(student_id);
   CREATE INDEX idx_enrollment_course ON Enrollment(course_id);
   ```

2. **æŸ¥è¯¢ä¼˜åŒ–**ï¼š
   - ä½¿ç”¨INNER JOINè€ŒéWHEREè¿æ¥
   - ç¡®ä¿è¿æ¥æ¡ä»¶ä¸Šæœ‰ç´¢å¼•
   - è€ƒè™‘ä½¿ç”¨è¦†ç›–ç´¢å¼•

---

## ä¸‰ã€å¤æ‚å­æŸ¥è¯¢

### 3.1 æ¡ˆä¾‹ï¼šæ‰¾å‡ºæ¯é—¨è¯¾ç¨‹çš„æœ€é«˜åˆ†å­¦ç”Ÿ

**åœºæ™¯æè¿°**ï¼šåœ¨åœ¨çº¿æ•™è‚²ç³»ç»Ÿä¸­ï¼Œéœ€è¦æ‰¾å‡ºæ¯é—¨è¯¾ç¨‹çš„æœ€é«˜åˆ†å­¦ç”Ÿï¼Œç”¨äºç”Ÿæˆè¯¾ç¨‹æ’è¡Œæ¦œå’Œä¼˜ç§€å­¦ç”Ÿè¡¨å½°ã€‚

**ä¸šåŠ¡éœ€æ±‚**ï¼š

- æ¯é—¨è¯¾ç¨‹åªæ˜¾ç¤ºä¸€ä¸ªæœ€é«˜åˆ†å­¦ç”Ÿï¼ˆå¦‚æœæœ‰å¹¶åˆ—ï¼Œæ˜¾ç¤ºæ‰€æœ‰ï¼‰
- éœ€è¦æ˜¾ç¤ºå­¦ç”Ÿå§“åã€è¯¾ç¨‹åç§°å’Œåˆ†æ•°
- æŒ‰è¯¾ç¨‹åç§°æ’åº

**ERå›¾**ï¼š

```mermaid
erDiagram
    Student ||--o{ Enrollment : "é€‰è¯¾"
    Course ||--o{ Enrollment : "è¢«é€‰"
    Student {
        int student_id PK
        string name
        int age
        string major
    }
    Course {
        int course_id PK
        string course_name
        string instructor
        int credits
    }
    Enrollment {
        int student_id FK
        int course_id FK
        int score
        date enroll_date
    }
```

**æŸ¥è¯¢æ–¹æ¡ˆå¯¹æ¯”**ï¼š

| æ–¹æ¡ˆ | SQLå®ç° | æ€§èƒ½ | å¤æ‚åº¦ | æ¨èåº¦ |
|------|---------|------|--------|--------|
| **æ–¹æ¡ˆ1ï¼šç›¸å…³å­æŸ¥è¯¢** | WHEREå­æŸ¥è¯¢ | â­â­ | â­â­ | â­â­â­ |
| **æ–¹æ¡ˆ2ï¼šçª—å£å‡½æ•°** | RANK() OVER | â­â­â­â­ | â­â­â­ | â­â­â­â­â­ |
| **æ–¹æ¡ˆ3ï¼šè‡ªè¿æ¥** | è‡ªè¿æ¥+MAX | â­â­â­ | â­â­â­â­ | â­â­â­ |

### æ–¹æ¡ˆ1ï¼šç›¸å…³å­æŸ¥è¯¢ï¼ˆåŸºç¡€æ–¹æ¡ˆï¼‰

```sql
SELECT
    c.course_name,
    s.name,
    e.score
FROM Enrollment e
JOIN Student s ON e.student_id = s.student_id
JOIN Course c ON e.course_id = c.course_id
WHERE e.score = (
    SELECT MAX(score)
    FROM Enrollment
    WHERE course_id = e.course_id
);
```

### æ–¹æ¡ˆ2ï¼šçª—å£å‡½æ•°ï¼ˆæ¨èæ–¹æ¡ˆï¼‰

```sql
WITH RankedScores AS (
    SELECT
        c.course_name,
        s.name,
        e.score,
        RANK() OVER (PARTITION BY e.course_id ORDER BY e.score DESC) as rank
    FROM Enrollment e
    JOIN Student s ON e.student_id = s.student_id
    JOIN Course c ON e.course_id = c.course_id
)
SELECT course_name, name, score
FROM RankedScores
WHERE rank = 1
ORDER BY course_name;
```

**æ‰§è¡Œè®¡åˆ’å¯¹æ¯”**ï¼š

```mermaid
graph TD
    A[æŸ¥è¯¢å¼€å§‹] --> B{é€‰æ‹©æ–¹æ¡ˆ}
    B -->|æ–¹æ¡ˆ1| C[ç›¸å…³å­æŸ¥è¯¢]
    B -->|æ–¹æ¡ˆ2| D[çª—å£å‡½æ•°]
    B -->|æ–¹æ¡ˆ3| E[è‡ªè¿æ¥]

    C --> C1[æ‰«æEnrollment]
    C1 --> C2[å¯¹æ¯è¡Œæ‰§è¡Œå­æŸ¥è¯¢]
    C2 --> C3[è®¡ç®—MAX]
    C3 --> C4[è¿”å›ç»“æœ]

    D --> D1[æ‰«æEnrollment]
    D1 --> D2[è®¡ç®—çª—å£å‡½æ•°]
    D2 --> D3[è¿‡æ»¤rank=1]
    D3 --> D4[è¿”å›ç»“æœ]

    E --> E1[è‡ªè¿æ¥Enrollment]
    E1 --> E2[åˆ†ç»„èšåˆMAX]
    E2 --> E3[è¿æ¥è¿‡æ»¤]
    E3 --> E4[è¿”å›ç»“æœ]

    C4 --> F[ç»“æœè¾“å‡º]
    D4 --> F
    E4 --> F
```

**æ€§èƒ½åˆ†æ**ï¼š

| æ•°æ®é‡ | æ–¹æ¡ˆ1è€—æ—¶ | æ–¹æ¡ˆ2è€—æ—¶ | æ–¹æ¡ˆ3è€—æ—¶ | æ¨èæ–¹æ¡ˆ |
|--------|----------|----------|----------|---------|
| 1ä¸‡æ¡ | 0.5s | 0.2s | 0.3s | æ–¹æ¡ˆ2 |
| 10ä¸‡æ¡ | 15s | 1.5s | 3s | æ–¹æ¡ˆ2 |
| 100ä¸‡æ¡ | è¶…æ—¶ | 8s | 25s | æ–¹æ¡ˆ2 |

**å…³ç³»ä»£æ•°è¡¨ç¤º**ï¼š

```latex
æ–¹æ¡ˆ1ï¼ˆç›¸å…³å­æŸ¥è¯¢ï¼‰ï¼š
Ï€_{course_name, name, score}(
    Ïƒ_{score = MAX_{course_id}(Enrollment)}(
        Enrollment â‹ˆ Student â‹ˆ Course
    )
)

æ–¹æ¡ˆ2ï¼ˆçª—å£å‡½æ•°ï¼‰ï¼š
Ï€_{course_name, name, score}(
    Ïƒ_{rank = 1}(
        RANK_{course_id, score DESC}(
            Enrollment â‹ˆ Student â‹ˆ Course
        )
    )
)
```

**æŸ¥è¯¢ç»“æœç¤ºä¾‹**ï¼š

```text
| course_name | name | score |
|-------------|------|-------|
| ç®—æ³•        | å¼ ä¸‰ | 90    |
| æ•°æ®åº“      | å¼ ä¸‰ | 85    |
```

**æ€§èƒ½ä¼˜åŒ–**ï¼š

```sql
-- åˆ›å»ºç´¢å¼•ä¼˜åŒ–å­æŸ¥è¯¢
CREATE INDEX idx_enrollment_course_score ON Enrollment(course_id, score DESC);

-- ä½¿ç”¨ç‰©åŒ–è§†å›¾ï¼ˆå¦‚æœæ•°æ®åº“æ”¯æŒï¼‰
CREATE MATERIALIZED VIEW mv_course_max_scores AS
SELECT
    course_id,
    MAX(score) as max_score
FROM Enrollment
GROUP BY course_id;
```

---

## å››ã€çª—å£å‡½æ•°åº”ç”¨

### 4.1 æ¡ˆä¾‹ï¼šå­¦ç”Ÿæˆç»©æ’å

**æŸ¥è¯¢**ï¼š

```sql
SELECT
    student_id,
    course_id,
    score,
    RANK() OVER (PARTITION BY course_id ORDER BY score DESC) as rank
FROM Enrollment;
```

---

## äº”ã€é€’å½’æŸ¥è¯¢åº”ç”¨

### 5.1 æ¡ˆä¾‹ï¼šç»„ç»‡å±‚æ¬¡ç»“æ„

**æŸ¥è¯¢**ï¼š

```sql
WITH RECURSIVE org_tree AS (
    SELECT id, name, parent_id, 0 as level
    FROM Organization WHERE parent_id IS NULL
    UNION ALL
    SELECT o.id, o.name, o.parent_id, ot.level + 1
    FROM Organization o
    JOIN org_tree ot ON o.parent_id = ot.id
)
SELECT * FROM org_tree;
```

---

## å…­ã€æ€§èƒ½ä¼˜åŒ–

### 6.1 ä¼˜åŒ–å»ºè®®

**æ€§èƒ½ä¼˜åŒ–å†³ç­–æ ‘**ï¼š

```mermaid
flowchart TD
    A[æŸ¥è¯¢æ€§èƒ½é—®é¢˜] --> B{é—®é¢˜ç±»å‹}
    B -->|æ…¢æŸ¥è¯¢| C{æŸ¥è¯¢ç±»å‹}
    B -->|é«˜èµ„æº| D[èµ„æºä¼˜åŒ–]

    C -->|è¿æ¥æŸ¥è¯¢| E[è¿æ¥ä¼˜åŒ–]
    C -->|å­æŸ¥è¯¢| F[å­æŸ¥è¯¢ä¼˜åŒ–]
    C -->|èšåˆæŸ¥è¯¢| G[èšåˆä¼˜åŒ–]

    E --> E1[åˆ›å»ºç´¢å¼•]
    E --> E2[ä¼˜åŒ–è¿æ¥é¡ºåº]
    E --> E3[ä½¿ç”¨è¦†ç›–ç´¢å¼•]

    F --> F1[è½¬æ¢ä¸ºJOIN]
    F --> F2[ä½¿ç”¨çª—å£å‡½æ•°]
    F --> F3[ä½¿ç”¨CTE]

    G --> G1[åˆ›å»ºèšåˆç´¢å¼•]
    G --> G2[ä½¿ç”¨ç‰©åŒ–è§†å›¾]
    G --> G3[åˆ†åŒºè¡¨]

    D --> D1[é™åˆ¶ç»“æœé›†]
    D --> D2[ä½¿ç”¨åˆ†é¡µ]
    D --> D3[ç¼“å­˜ç»“æœ]
```

**ä¼˜åŒ–ç­–ç•¥å¯¹æ¯”çŸ©é˜µ**ï¼š

| ä¼˜åŒ–ç­–ç•¥ | é€‚ç”¨åœºæ™¯ | æ€§èƒ½æå‡ | å®ç°éš¾åº¦ | ç»´æŠ¤æˆæœ¬ |
|---------|---------|---------|---------|---------|
| **ç´¢å¼•ä¼˜åŒ–** | é¢‘ç¹æŸ¥è¯¢å­—æ®µ | â­â­â­â­ | â­â­ | â­â­ |
| **æŸ¥è¯¢é‡å†™** | å¤æ‚å­æŸ¥è¯¢ | â­â­â­ | â­â­â­ | â­ |
| **ç‰©åŒ–è§†å›¾** | é‡å¤èšåˆæŸ¥è¯¢ | â­â­â­â­â­ | â­â­â­â­ | â­â­â­ |
| **åˆ†åŒºè¡¨** | å¤§æ•°æ®é‡è¡¨ | â­â­â­â­ | â­â­â­â­ | â­â­â­ |
| **æŸ¥è¯¢ç¼“å­˜** | é‡å¤æŸ¥è¯¢ | â­â­â­â­ | â­â­ | â­â­ |

**å…·ä½“ä¼˜åŒ–å»ºè®®**ï¼š

#### 1. ç´¢å¼•ä¼˜åŒ–

```sql
-- ä¸ºè¿æ¥å­—æ®µåˆ›å»ºç´¢å¼•
CREATE INDEX idx_enrollment_student ON Enrollment(student_id);
CREATE INDEX idx_enrollment_course ON Enrollment(course_id);

-- ä¸ºWHEREæ¡ä»¶åˆ›å»ºç´¢å¼•
CREATE INDEX idx_enrollment_score ON Enrollment(score);

-- åˆ›å»ºå¤åˆç´¢å¼•
CREATE INDEX idx_enrollment_course_score ON Enrollment(course_id, score DESC);
```

#### 2. æŸ¥è¯¢é‡å†™

```sql
-- åŸå§‹æŸ¥è¯¢ï¼ˆç›¸å…³å­æŸ¥è¯¢ï¼‰
SELECT * FROM Enrollment e
WHERE e.score = (
    SELECT MAX(score) FROM Enrollment
    WHERE course_id = e.course_id
);

-- ä¼˜åŒ–åï¼ˆçª—å£å‡½æ•°ï¼‰
WITH RankedScores AS (
    SELECT *,
        RANK() OVER (PARTITION BY course_id ORDER BY score DESC) as rank
    FROM Enrollment
)
SELECT * FROM RankedScores WHERE rank = 1;
```

#### 3. ä½¿ç”¨EXPLAINåˆ†ææŸ¥è¯¢è®¡åˆ’

```sql
-- PostgreSQL
EXPLAIN ANALYZE SELECT ...;

-- MySQL
EXPLAIN SELECT ...;

-- SQL Server
SET SHOWPLAN_ALL ON;
SELECT ...;
```

---

## ä¸ƒã€2025 RAGæ£€ç´¢æ¡ˆä¾‹

### 7.1 ä¼ä¸šçŸ¥è¯†åº“RAG Schema

```sql
-- ä¼ä¸šçŸ¥è¯†åº“å®Œæ•´Schema
CREATE EXTENSION IF NOT EXISTS vector;
CREATE EXTENSION IF NOT EXISTS pg_trgm;

-- æ–‡æ¡£è¡¨
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    title TEXT NOT NULL,
    content TEXT NOT NULL,
    source_url TEXT,
    doc_type VARCHAR(50),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- æ–‡æ¡£åˆ†å—è¡¨
CREATE TABLE document_chunks (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID REFERENCES documents(id) ON DELETE CASCADE,
    chunk_index INTEGER NOT NULL,
    content TEXT NOT NULL,
    embedding vector(1536),
    token_count INTEGER,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(document_id, chunk_index)
);

-- å‘é‡ç´¢å¼• (HNSW)
CREATE INDEX idx_chunks_embedding ON document_chunks
    USING hnsw (embedding vector_cosine_ops);

-- å…¨æ–‡ç´¢å¼•
ALTER TABLE document_chunks ADD COLUMN tsv tsvector
    GENERATED ALWAYS AS (to_tsvector('chinese', content)) STORED;
CREATE INDEX idx_chunks_tsv ON document_chunks USING gin(tsv);

-- JSONç´¢å¼•
CREATE INDEX idx_chunks_metadata ON document_chunks USING gin(metadata);
```

### 7.2 æ··åˆæ£€ç´¢æŸ¥è¯¢

```sql
-- æ··åˆæ£€ç´¢ï¼šå‘é‡ + å…¨æ–‡ + å…ƒæ•°æ®è¿‡æ»¤
CREATE OR REPLACE FUNCTION hybrid_search(
    query_text TEXT,
    query_embedding vector(1536),
    filter_metadata JSONB DEFAULT '{}',
    vector_weight FLOAT DEFAULT 0.7,
    keyword_weight FLOAT DEFAULT 0.3,
    limit_count INTEGER DEFAULT 10
) RETURNS TABLE (
    chunk_id UUID,
    document_id UUID,
    content TEXT,
    metadata JSONB,
    vector_score FLOAT,
    keyword_score FLOAT,
    combined_score FLOAT
) AS $$
BEGIN
    RETURN QUERY
    WITH
    -- å‘é‡æ£€ç´¢
    vector_results AS (
        SELECT
            id,
            document_id,
            content,
            metadata,
            1 - (embedding <=> query_embedding) AS score
        FROM document_chunks
        WHERE (filter_metadata = '{}' OR metadata @> filter_metadata)
        ORDER BY embedding <=> query_embedding
        LIMIT limit_count * 3
    ),
    -- å…³é”®è¯æ£€ç´¢
    keyword_results AS (
        SELECT
            id,
            document_id,
            content,
            metadata,
            ts_rank_cd(tsv, plainto_tsquery('chinese', query_text)) AS score
        FROM document_chunks
        WHERE tsv @@ plainto_tsquery('chinese', query_text)
          AND (filter_metadata = '{}' OR metadata @> filter_metadata)
        ORDER BY score DESC
        LIMIT limit_count * 3
    ),
    -- RRFèåˆ
    combined AS (
        SELECT
            COALESCE(v.id, k.id) AS chunk_id,
            COALESCE(v.document_id, k.document_id) AS document_id,
            COALESCE(v.content, k.content) AS content,
            COALESCE(v.metadata, k.metadata) AS metadata,
            COALESCE(v.score, 0) AS vector_score,
            COALESCE(k.score, 0) AS keyword_score,
            (COALESCE(v.score, 0) * vector_weight +
             COALESCE(k.score, 0) * keyword_weight) AS combined_score
        FROM vector_results v
        FULL OUTER JOIN keyword_results k ON v.id = k.id
    )
    SELECT * FROM combined
    ORDER BY combined_score DESC
    LIMIT limit_count;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨ç¤ºä¾‹
SELECT * FROM hybrid_search(
    'å¦‚ä½•é…ç½®PostgreSQLè¿æ¥æ± ',
    '[0.1, 0.2, ...]'::vector,
    '{"category": "database"}'::jsonb
);
```

### 7.3 RAGä¸Šä¸‹æ–‡æ„å»º

```sql
-- æ„å»ºLLMä¸Šä¸‹æ–‡
CREATE OR REPLACE FUNCTION build_rag_context(
    query_embedding vector(1536),
    max_tokens INTEGER DEFAULT 4000,
    max_chunks INTEGER DEFAULT 5
) RETURNS JSONB AS $$
DECLARE
    result JSONB;
    total_tokens INTEGER := 0;
    chunk_count INTEGER := 0;
BEGIN
    WITH ranked_chunks AS (
        SELECT
            dc.id,
            dc.content,
            dc.token_count,
            dc.metadata,
            d.title AS doc_title,
            1 - (dc.embedding <=> query_embedding) AS similarity,
            ROW_NUMBER() OVER (ORDER BY dc.embedding <=> query_embedding) AS rank
        FROM document_chunks dc
        JOIN documents d ON dc.document_id = d.id
        ORDER BY dc.embedding <=> query_embedding
        LIMIT max_chunks * 2
    ),
    selected_chunks AS (
        SELECT *
        FROM ranked_chunks
        WHERE rank <= max_chunks
    )
    SELECT jsonb_build_object(
        'chunks', jsonb_agg(
            jsonb_build_object(
                'id', id,
                'title', doc_title,
                'content', content,
                'similarity', ROUND(similarity::numeric, 4),
                'metadata', metadata
            ) ORDER BY similarity DESC
        ),
        'total_chunks', COUNT(*),
        'total_tokens', SUM(token_count),
        'avg_similarity', ROUND(AVG(similarity)::numeric, 4)
    )
    INTO result
    FROM selected_chunks;

    RETURN result;
END;
$$ LANGUAGE plpgsql;
```

### 7.4 æŸ¥è¯¢æ—¥å¿—ä¸åˆ†æ

```sql
-- æŸ¥è¯¢æ—¥å¿—è¡¨
CREATE TABLE query_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID,
    query_text TEXT NOT NULL,
    query_embedding vector(1536),
    result_count INTEGER,
    latency_ms INTEGER,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- æŸ¥è¯¢åˆ†æï¼šçƒ­é—¨æŸ¥è¯¢
WITH query_stats AS (
    SELECT
        query_text,
        COUNT(*) AS query_count,
        AVG(latency_ms) AS avg_latency,
        AVG(result_count) AS avg_results
    FROM query_logs
    WHERE created_at > NOW() - INTERVAL '7 days'
    GROUP BY query_text
)
SELECT
    query_text,
    query_count,
    avg_latency,
    avg_results,
    -- æ’å
    ROW_NUMBER() OVER (ORDER BY query_count DESC) AS popularity_rank,
    -- ç´¯è®¡å æ¯”
    SUM(query_count) OVER (ORDER BY query_count DESC) * 100.0 /
        SUM(query_count) OVER () AS cumulative_pct
FROM query_stats
ORDER BY query_count DESC
LIMIT 20;
```

### 7.5 2025 RAGæŸ¥è¯¢æ¨¡å¼çŸ©é˜µ

| æŸ¥è¯¢æ¨¡å¼ | SQLç‰¹æ€§ | é€‚ç”¨åœºæ™¯ | å¤æ‚åº¦ |
|---------|--------|---------|-------|
| **å‘é‡æ£€ç´¢** | `<=>` æ“ä½œç¬¦ | è¯­ä¹‰æœç´¢ | â­â­ |
| **æ··åˆæ£€ç´¢** | å‘é‡ + å…¨æ–‡ | ç²¾å‡†+è¯­ä¹‰ | â­â­â­ |
| **RRFèåˆ** | CTE + çª—å£å‡½æ•° | å¤šè·¯å¬å› | â­â­â­â­ |
| **ä¸Šä¸‹æ–‡æ„å»º** | JSONBèšåˆ | LLMè¾“å…¥ | â­â­â­ |
| **æŸ¥è¯¢åˆ†æ** | çª—å£å‡½æ•° | è¿è¥åˆ†æ | â­â­â­ |

---

## å…«ã€ç«¯åˆ°ç«¯ä¸šåŠ¡æ¡ˆä¾‹ï¼šç”µå•†è®¢å•ç³»ç»Ÿ ğŸ†•

### 8.1 ä¸šåŠ¡éœ€æ±‚æè¿°

**ç”µå•†å¹³å°æ ¸å¿ƒéœ€æ±‚**ï¼š

- è®¢å•ç®¡ç†ï¼ˆåˆ›å»ºã€æ”¯ä»˜ã€å‘è´§ã€å®Œæˆï¼‰
- åº“å­˜ç®¡ç†ï¼ˆæ‰£å‡ã€å›æ»šã€é¢„è­¦ï¼‰
- ç”¨æˆ·åˆ†æï¼ˆRFMæ¨¡å‹ã€ç”¨æˆ·ç”»åƒï¼‰
- ä¿ƒé”€æ´»åŠ¨ï¼ˆä¼˜æƒ åˆ¸ã€æ»¡å‡ï¼‰

### 8.2 PostgreSQL 18 æ•°æ®æ¨¡å‹

```sql
-- PostgreSQL 18: ç”µå•†è®¢å•ç³»ç»Ÿå®Œæ•´Schema
-- ç”¨æˆ·è¡¨
CREATE TABLE users (
    user_id     BIGSERIAL PRIMARY KEY,
    username    VARCHAR(50) UNIQUE NOT NULL,
    email       VARCHAR(100) UNIQUE NOT NULL,
    phone       VARCHAR(20),
    created_at  TIMESTAMPTZ DEFAULT NOW(),
    -- PostgreSQL 18: è™šæ‹Ÿç”Ÿæˆåˆ—
    user_level  VARCHAR(10) GENERATED ALWAYS AS (
        CASE
            WHEN total_orders >= 100 THEN 'VIP'
            WHEN total_orders >= 10 THEN 'Gold'
            ELSE 'Normal'
        END
    ) STORED,
    total_orders INTEGER DEFAULT 0
);

-- å•†å“è¡¨
CREATE TABLE products (
    product_id  BIGSERIAL PRIMARY KEY,
    name        VARCHAR(200) NOT NULL,
    category_id INTEGER NOT NULL,
    price       DECIMAL(10,2) NOT NULL,
    stock       INTEGER NOT NULL DEFAULT 0 CHECK (stock >= 0),
    status      VARCHAR(20) DEFAULT 'active',
    attributes  JSONB DEFAULT '{}',
    created_at  TIMESTAMPTZ DEFAULT NOW(),
    -- å…¨æ–‡æœç´¢å‘é‡
    search_vector TSVECTOR GENERATED ALWAYS AS (
        setweight(to_tsvector('chinese', name), 'A') ||
        setweight(to_tsvector('chinese', COALESCE(attributes->>'description', '')), 'B')
    ) STORED
);

-- è®¢å•è¡¨
CREATE TABLE orders (
    order_id    BIGSERIAL PRIMARY KEY,
    user_id     BIGINT NOT NULL REFERENCES users(user_id),
    status      VARCHAR(20) NOT NULL DEFAULT 'pending',
    total_amount DECIMAL(12,2) NOT NULL,
    discount_amount DECIMAL(10,2) DEFAULT 0,
    pay_amount  DECIMAL(12,2) GENERATED ALWAYS AS (total_amount - discount_amount) STORED,
    created_at  TIMESTAMPTZ DEFAULT NOW(),
    paid_at     TIMESTAMPTZ,
    shipped_at  TIMESTAMPTZ,
    completed_at TIMESTAMPTZ,
    -- è®¢å•çŠ¶æ€çº¦æŸ
    CONSTRAINT valid_status CHECK (status IN ('pending', 'paid', 'shipped', 'completed', 'cancelled'))
);

-- è®¢å•æ˜ç»†è¡¨
CREATE TABLE order_items (
    item_id     BIGSERIAL PRIMARY KEY,
    order_id    BIGINT NOT NULL REFERENCES orders(order_id),
    product_id  BIGINT NOT NULL REFERENCES products(product_id),
    quantity    INTEGER NOT NULL CHECK (quantity > 0),
    unit_price  DECIMAL(10,2) NOT NULL,
    subtotal    DECIMAL(12,2) GENERATED ALWAYS AS (quantity * unit_price) STORED
);

-- åº“å­˜å˜åŠ¨æ—¥å¿—
CREATE TABLE inventory_logs (
    log_id      BIGSERIAL PRIMARY KEY,
    product_id  BIGINT NOT NULL REFERENCES products(product_id),
    change_type VARCHAR(20) NOT NULL, -- 'sale', 'return', 'restock', 'adjustment'
    quantity    INTEGER NOT NULL,
    order_id    BIGINT REFERENCES orders(order_id),
    created_at  TIMESTAMPTZ DEFAULT NOW()
);

-- ç´¢å¼•
CREATE INDEX idx_orders_user ON orders(user_id);
CREATE INDEX idx_orders_status ON orders(status);
CREATE INDEX idx_orders_created ON orders(created_at);
CREATE INDEX idx_products_search ON products USING GIN(search_vector);
CREATE INDEX idx_products_category ON products(category_id);
```

### 8.3 æ ¸å¿ƒä¸šåŠ¡æŸ¥è¯¢

**8.3.1 åˆ›å»ºè®¢å•ï¼ˆå«åº“å­˜æ‰£å‡ï¼‰**:

```sql
-- PostgreSQL 18: åŸå­æ€§è®¢å•åˆ›å»º
CREATE OR REPLACE FUNCTION create_order(
    p_user_id BIGINT,
    p_items JSONB  -- [{"product_id": 1, "quantity": 2}, ...]
) RETURNS BIGINT AS $$
DECLARE
    v_order_id BIGINT;
    v_total DECIMAL(12,2) := 0;
    v_item JSONB;
    v_product RECORD;
BEGIN
    -- 1. åˆ›å»ºè®¢å•å¤´
    INSERT INTO orders (user_id, status, total_amount)
    VALUES (p_user_id, 'pending', 0)
    RETURNING order_id INTO v_order_id;

    -- 2. å¤„ç†æ¯ä¸ªå•†å“
    FOR v_item IN SELECT * FROM jsonb_array_elements(p_items)
    LOOP
        -- è·å–å•†å“ä¿¡æ¯å¹¶é”å®šè¡Œ
        SELECT * INTO v_product
        FROM products
        WHERE product_id = (v_item->>'product_id')::BIGINT
        FOR UPDATE;

        -- æ£€æŸ¥åº“å­˜
        IF v_product.stock < (v_item->>'quantity')::INTEGER THEN
            RAISE EXCEPTION 'å•†å“ % åº“å­˜ä¸è¶³', v_product.name;
        END IF;

        -- æ‰£å‡åº“å­˜
        UPDATE products
        SET stock = stock - (v_item->>'quantity')::INTEGER
        WHERE product_id = v_product.product_id;

        -- è®°å½•åº“å­˜å˜åŠ¨
        INSERT INTO inventory_logs (product_id, change_type, quantity, order_id)
        VALUES (v_product.product_id, 'sale', -(v_item->>'quantity')::INTEGER, v_order_id);

        -- åˆ›å»ºè®¢å•æ˜ç»†
        INSERT INTO order_items (order_id, product_id, quantity, unit_price)
        VALUES (v_order_id, v_product.product_id, (v_item->>'quantity')::INTEGER, v_product.price);

        v_total := v_total + v_product.price * (v_item->>'quantity')::INTEGER;
    END LOOP;

    -- 3. æ›´æ–°è®¢å•æ€»é‡‘é¢
    UPDATE orders SET total_amount = v_total WHERE order_id = v_order_id;

    -- 4. æ›´æ–°ç”¨æˆ·è®¢å•æ•°
    UPDATE users SET total_orders = total_orders + 1 WHERE user_id = p_user_id;

    RETURN v_order_id;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨ç¤ºä¾‹
SELECT create_order(
    1,
    '[{"product_id": 101, "quantity": 2}, {"product_id": 102, "quantity": 1}]'::JSONB
);
```

**8.3.2 ç”¨æˆ·RFMåˆ†æï¼ˆé«˜çº§çª—å£å‡½æ•°ï¼‰**:

```sql
-- PostgreSQL 18: RFMç”¨æˆ·ä»·å€¼åˆ†æ
WITH user_metrics AS (
    SELECT
        u.user_id,
        u.username,
        -- Recency: æœ€åä¸€æ¬¡è´­ä¹°è·ä»Šå¤©æ•°
        EXTRACT(DAY FROM NOW() - MAX(o.paid_at)) AS recency_days,
        -- Frequency: è´­ä¹°æ¬¡æ•°
        COUNT(DISTINCT o.order_id) AS frequency,
        -- Monetary: æ€»æ¶ˆè´¹é‡‘é¢
        COALESCE(SUM(o.pay_amount), 0) AS monetary
    FROM users u
    LEFT JOIN orders o ON u.user_id = o.user_id AND o.status = 'completed'
    GROUP BY u.user_id, u.username
),
rfm_scores AS (
    SELECT
        user_id,
        username,
        recency_days,
        frequency,
        monetary,
        -- RFMæ‰“åˆ† (1-5åˆ†)
        NTILE(5) OVER (ORDER BY recency_days DESC) AS r_score,
        NTILE(5) OVER (ORDER BY frequency) AS f_score,
        NTILE(5) OVER (ORDER BY monetary) AS m_score
    FROM user_metrics
    WHERE frequency > 0  -- æ’é™¤ä»æœªè´­ä¹°çš„ç”¨æˆ·
)
SELECT
    user_id,
    username,
    recency_days,
    frequency,
    monetary,
    r_score,
    f_score,
    m_score,
    r_score + f_score + m_score AS rfm_total,
    -- ç”¨æˆ·åˆ†ç¾¤
    CASE
        WHEN r_score >= 4 AND f_score >= 4 AND m_score >= 4 THEN 'é‡è¦ä»·å€¼å®¢æˆ·'
        WHEN r_score >= 4 AND f_score >= 4 THEN 'é‡è¦å‘å±•å®¢æˆ·'
        WHEN r_score >= 4 AND m_score >= 4 THEN 'é‡è¦ä¿æŒå®¢æˆ·'
        WHEN f_score >= 4 AND m_score >= 4 THEN 'é‡è¦æŒ½ç•™å®¢æˆ·'
        WHEN r_score >= 4 THEN 'ä¸€èˆ¬å‘å±•å®¢æˆ·'
        WHEN f_score >= 4 THEN 'ä¸€èˆ¬ä¿æŒå®¢æˆ·'
        WHEN m_score >= 4 THEN 'ä¸€èˆ¬æŒ½ç•™å®¢æˆ·'
        ELSE 'ä¸€èˆ¬å®¢æˆ·'
    END AS customer_segment,
    -- åˆ†ç¾¤å†…æ’å
    ROW_NUMBER() OVER (
        PARTITION BY
            CASE
                WHEN r_score >= 4 AND f_score >= 4 AND m_score >= 4 THEN 'é‡è¦ä»·å€¼å®¢æˆ·'
                WHEN r_score >= 4 AND f_score >= 4 THEN 'é‡è¦å‘å±•å®¢æˆ·'
                ELSE 'å…¶ä»–'
            END
        ORDER BY monetary DESC
    ) AS segment_rank
FROM rfm_scores
ORDER BY rfm_total DESC, monetary DESC;
```

**8.3.3 é”€å”®è¶‹åŠ¿åˆ†æï¼ˆæ—¶é—´åºåˆ—ï¼‰**:

```sql
-- PostgreSQL 18: é”€å”®è¶‹åŠ¿ä¸åŒæ¯”ç¯æ¯”åˆ†æ
WITH daily_sales AS (
    SELECT
        DATE(created_at) AS sale_date,
        COUNT(DISTINCT order_id) AS order_count,
        SUM(pay_amount) AS revenue,
        COUNT(DISTINCT user_id) AS unique_customers
    FROM orders
    WHERE status IN ('paid', 'shipped', 'completed')
      AND created_at >= CURRENT_DATE - INTERVAL '90 days'
    GROUP BY DATE(created_at)
),
sales_with_trends AS (
    SELECT
        sale_date,
        order_count,
        revenue,
        unique_customers,
        -- 7æ—¥ç§»åŠ¨å¹³å‡
        AVG(revenue) OVER (
            ORDER BY sale_date
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) AS revenue_ma7,
        -- ç¯æ¯”ï¼ˆä¸å‰ä¸€å¤©å¯¹æ¯”ï¼‰
        revenue - LAG(revenue) OVER (ORDER BY sale_date) AS revenue_dod,
        -- åŒæ¯”ï¼ˆä¸å»å¹´åŒæ—¥å¯¹æ¯”ï¼‰
        revenue - LAG(revenue, 365) OVER (ORDER BY sale_date) AS revenue_yoy,
        -- å‘¨ç´¯è®¡
        SUM(revenue) OVER (
            PARTITION BY DATE_TRUNC('week', sale_date)
            ORDER BY sale_date
        ) AS weekly_cumulative
    FROM daily_sales
)
SELECT
    sale_date,
    order_count,
    revenue,
    ROUND(revenue_ma7, 2) AS "7æ—¥å‡å€¼",
    ROUND(revenue_dod, 2) AS "æ—¥ç¯æ¯”",
    ROUND(revenue_yoy, 2) AS "å¹´åŒæ¯”",
    ROUND(weekly_cumulative, 2) AS "å‘¨ç´¯è®¡",
    -- è¶‹åŠ¿æŒ‡æ ‡
    CASE
        WHEN revenue > revenue_ma7 * 1.1 THEN 'â†‘â†‘'
        WHEN revenue > revenue_ma7 THEN 'â†‘'
        WHEN revenue < revenue_ma7 * 0.9 THEN 'â†“â†“'
        WHEN revenue < revenue_ma7 THEN 'â†“'
        ELSE 'â†’'
    END AS trend
FROM sales_with_trends
ORDER BY sale_date DESC
LIMIT 30;
```

### 8.4 SQLite 3.45+ ç®€åŒ–ç‰ˆæœ¬

```sql
-- SQLite 3.45+: ç®€åŒ–ç‰ˆç”µå•†æŸ¥è¯¢
-- åˆ›å»ºè®¢å•ï¼ˆä¸æ”¯æŒå­˜å‚¨è¿‡ç¨‹ï¼Œä½¿ç”¨è§¦å‘å™¨ï¼‰
CREATE TRIGGER after_order_item_insert
AFTER INSERT ON order_items
BEGIN
    -- æ‰£å‡åº“å­˜
    UPDATE products
    SET stock = stock - NEW.quantity
    WHERE product_id = NEW.product_id;

    -- æ›´æ–°è®¢å•æ€»é‡‘é¢
    UPDATE orders
    SET total_amount = (
        SELECT SUM(quantity * unit_price)
        FROM order_items
        WHERE order_id = NEW.order_id
    )
    WHERE order_id = NEW.order_id;
END;

-- SQLite: RFMåˆ†æï¼ˆçª—å£å‡½æ•°ï¼‰
WITH user_metrics AS (
    SELECT
        u.user_id,
        u.username,
        julianday('now') - julianday(MAX(o.paid_at)) AS recency_days,
        COUNT(DISTINCT o.order_id) AS frequency,
        COALESCE(SUM(o.total_amount - o.discount_amount), 0) AS monetary
    FROM users u
    LEFT JOIN orders o ON u.user_id = o.user_id AND o.status = 'completed'
    GROUP BY u.user_id, u.username
)
SELECT
    user_id,
    username,
    recency_days,
    frequency,
    monetary,
    -- SQLiteæ”¯æŒNTILE
    NTILE(5) OVER (ORDER BY recency_days DESC) AS r_score,
    NTILE(5) OVER (ORDER BY frequency) AS f_score,
    NTILE(5) OVER (ORDER BY monetary) AS m_score
FROM user_metrics
WHERE frequency > 0;

-- SQLite 3.45+: ä½¿ç”¨JSONå‡½æ•°
SELECT
    order_id,
    json_group_array(
        json_object(
            'product_id', product_id,
            'quantity', quantity,
            'subtotal', quantity * unit_price
        )
    ) AS items_json
FROM order_items
GROUP BY order_id;
```

### 8.5 æ€§èƒ½ä¼˜åŒ–å»ºè®®

```sql
-- PostgreSQL 18: æ‰§è¡Œè®¡åˆ’åˆ†æ
EXPLAIN (ANALYZE, BUFFERS, FORMAT TEXT)
SELECT * FROM rfm_analysis_view WHERE customer_segment = 'é‡è¦ä»·å€¼å®¢æˆ·';

-- å…³é”®ç´¢å¼•
CREATE INDEX CONCURRENTLY idx_orders_user_status ON orders(user_id, status);
CREATE INDEX CONCURRENTLY idx_orders_paid_at ON orders(paid_at) WHERE status = 'completed';

-- ç‰©åŒ–è§†å›¾ï¼ˆå®šæœŸåˆ·æ–°ï¼‰
CREATE MATERIALIZED VIEW mv_daily_sales AS
SELECT DATE(created_at) AS sale_date, COUNT(*) AS orders, SUM(pay_amount) AS revenue
FROM orders WHERE status IN ('paid', 'shipped', 'completed')
GROUP BY DATE(created_at);

-- åˆ·æ–°ç‰©åŒ–è§†å›¾
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_daily_sales;
```

---

## ä¹ã€ç›¸å…³èµ„æº

### ç›¸å…³æ–‡æ¡£

- [æ•°æ®åˆ†ææ¡ˆä¾‹](./07.02-æ•°æ®åˆ†ææ¡ˆä¾‹.md) - æ•°æ®åˆ†ææŸ¥è¯¢
- [ETLæµç¨‹æ¡ˆä¾‹](./07.03-ETLæµç¨‹æ¡ˆä¾‹.md) - ETLæŸ¥è¯¢
- [çª—å£å‡½æ•°è¯¦è§£](../05-é«˜çº§ç‰¹æ€§/05.01-çª—å£å‡½æ•°è¯¦è§£.md) - çª—å£å‡½æ•°ä¸å‘é‡åˆ†æ
- [äº‹åŠ¡ç†è®º](../01-ç†è®ºåŸºç¡€/01.05-äº‹åŠ¡ç†è®º.md) - ğŸ†• äº‹åŠ¡éš”ç¦»ä¸å¹¶å‘æ§åˆ¶

### 2025æ–°èµ„æº

- [pgvectoræ–‡æ¡£](https://github.com/pgvector/pgvector)
- [LangChain PostgreSQLé›†æˆ](https://python.langchain.com/docs/integrations/vectorstores/pgvector)
- [PostgreSQL 18 Release Notes](https://www.postgresql.org/docs/18/release-18.html)

---

**ç»´æŠ¤è€…**: SQL Standards Team
**æœ€åæ›´æ–°**: 2025-12-01
