# SQL面试题完整题库

> **创建日期**: 2025-12-05
> **难度分级**: 初级/中级/高级/专家
> **覆盖**: 理论+实战

---

## 初级题（20题）

### 题1：基础查询

```sql
-- 表结构
CREATE TABLE employees (
    id INTEGER PRIMARY KEY,
    name TEXT,
    department TEXT,
    salary DECIMAL(10, 2)
);

-- 问题1：查询所有员工
SELECT * FROM employees;

-- 问题2：查询工资>5000的员工
SELECT * FROM employees WHERE salary > 5000;

-- 问题3：查询IT部门员工数量
SELECT COUNT(*) FROM employees WHERE department = 'IT';

-- 问题4：查询每个部门的平均工资
SELECT department, AVG(salary) as avg_salary
FROM employees
GROUP BY department;

-- 问题5：查询工资前3名
SELECT * FROM employees
ORDER BY salary DESC
LIMIT 3;
```

### 题2：JOIN查询

```sql
-- 表结构
CREATE TABLE orders (
    id INTEGER PRIMARY KEY,
    user_id INTEGER,
    total DECIMAL(10, 2)
);

CREATE TABLE users (
    id INTEGER PRIMARY KEY,
    name TEXT
);

-- 问题：查询每个用户的订单总额
SELECT
    u.name,
    COALESCE(SUM(o.total), 0) as total_amount
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id, u.name;

-- 常见错误：使用INNER JOIN（丢失无订单用户）
-- 常见错误：不使用COALESCE（NULL变为NULL）
```

---

## 中级题（15题）

### 题3：第N高工资

```sql
-- 问题：查询第2高的工资

-- 方案1：子查询
SELECT MAX(salary) as second_highest
FROM employees
WHERE salary < (SELECT MAX(salary) FROM employees);

-- 方案2：LIMIT OFFSET
SELECT salary
FROM employees
ORDER BY salary DESC
LIMIT 1 OFFSET 1;

-- 方案3：窗口函数（推荐）
SELECT DISTINCT salary as second_highest
FROM (
    SELECT
        salary,
        DENSE_RANK() OVER (ORDER BY salary DESC) as rank
    FROM employees
)
WHERE rank = 2;

-- 变体：查询第N高工资（N作为参数）
WITH ranked AS (
    SELECT
        salary,
        DENSE_RANK() OVER (ORDER BY salary DESC) as rank
    FROM employees
)
SELECT salary
FROM ranked
WHERE rank = :N;
```

### 题4：连续登录天数

```sql
-- 表结构
CREATE TABLE user_logins (
    user_id INTEGER,
    login_date DATE
);

-- 问题：找出连续登录≥3天的用户

-- 方案：使用ROW_NUMBER检测连续性
WITH numbered AS (
    SELECT
        user_id,
        login_date,
        ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY login_date) as rn,
        DATE_SUB(login_date, INTERVAL rn DAY) as group_id
    FROM (
        SELECT DISTINCT user_id, login_date FROM user_logins
    ) t
),
groups AS (
    SELECT
        user_id,
        group_id,
        COUNT(*) as consecutive_days
    FROM numbered
    GROUP BY user_id, group_id
    HAVING COUNT(*) >= 3
)
SELECT DISTINCT user_id
FROM groups;

-- 原理：
-- 日期 - ROW_NUMBER = 常数（连续日期）
-- 2025-01-01 - 1 = 2024-12-31
-- 2025-01-02 - 2 = 2024-12-31 (相同！)
-- 2025-01-03 - 3 = 2024-12-31 (相同！)
```

### 题5：删除重复数据

```sql
-- 表结构
CREATE TABLE duplicates (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    email TEXT,
    name TEXT
);

-- 问题：删除重复的email，保留id最小的

-- 方案1：自连接DELETE
DELETE FROM duplicates
WHERE id NOT IN (
    SELECT MIN(id)
    FROM duplicates
    GROUP BY email
);

-- 方案2：窗口函数（PostgreSQL）
DELETE FROM duplicates
WHERE id IN (
    SELECT id
    FROM (
        SELECT
            id,
            ROW_NUMBER() OVER (PARTITION BY email ORDER BY id) as rn
        FROM duplicates
    )
    WHERE rn > 1
);

-- 方案3：CTE（PostgreSQL）
WITH duplicates_to_delete AS (
    SELECT id
    FROM (
        SELECT
            id,
            ROW_NUMBER() OVER (PARTITION BY email ORDER BY id) as rn
        FROM duplicates
    )
    WHERE rn > 1
)
DELETE FROM duplicates
WHERE id IN (SELECT id FROM duplicates_to_delete);
```

---

## 高级题（10题）

### 题6：查询中位数

```sql
-- 问题：查询员工工资中位数

-- 方案1：百分位函数（PostgreSQL）
SELECT PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY salary) as median
FROM employees;

-- 方案2：窗口函数（通用）
WITH ranked AS (
    SELECT
        salary,
        ROW_NUMBER() OVER (ORDER BY salary) as rn,
        COUNT(*) OVER () as total
    FROM employees
)
SELECT AVG(salary) as median
FROM ranked
WHERE rn IN (FLOOR((total + 1) / 2.0), CEIL((total + 1) / 2.0));

-- 奇数个：取中间值
-- 偶数个：取中间两个的平均
```

### 题7：查找部门工资超过平均工资的员工

```sql
-- 问题：每个部门中工资高于该部门平均工资的员工

-- 方案1：子查询
SELECT e1.*
FROM employees e1
WHERE e1.salary > (
    SELECT AVG(e2.salary)
    FROM employees e2
    WHERE e2.department = e1.department
);

-- 方案2：窗口函数（推荐）
SELECT *
FROM (
    SELECT
        *,
        AVG(salary) OVER (PARTITION BY department) as dept_avg
    FROM employees
)
WHERE salary > dept_avg;

-- 性能对比：
-- 方案1：N次子查询（N=员工数）
-- 方案2：1次扫描+窗口计算
```

### 题8：树形结构查询（递归CTE）

```sql
-- 表结构
CREATE TABLE employees_tree (
    id INTEGER,
    name TEXT,
    manager_id INTEGER
);

-- 问题1：查询某员工的所有下属（递归）

WITH RECURSIVE subordinates AS (
    -- 基础：查询目标员工
    SELECT id, name, manager_id, 0 as level
    FROM employees_tree
    WHERE id = 1  -- 目标员工ID

    UNION ALL

    -- 递归：查询下属
    SELECT e.id, e.name, e.manager_id, s.level + 1
    FROM employees_tree e
    JOIN subordinates s ON e.manager_id = s.id
)
SELECT * FROM subordinates WHERE level > 0;

-- 问题2：查询层级关系（带路径）

WITH RECURSIVE hierarchy AS (
    SELECT
        id,
        name,
        manager_id,
        CAST(name AS TEXT) as path,
        0 as level
    FROM employees_tree
    WHERE manager_id IS NULL

    UNION ALL

    SELECT
        e.id,
        e.name,
        e.manager_id,
        h.path || ' > ' || e.name,
        h.level + 1
    FROM employees_tree e
    JOIN hierarchy h ON e.manager_id = h.id
)
SELECT * FROM hierarchy ORDER BY path;
```

---

## 专家题（5题）

### 题9：查询间隙（Gap）

```sql
-- 表结构
CREATE TABLE numbers (
    num INTEGER PRIMARY KEY
);

INSERT INTO numbers VALUES (1), (2), (3), (5), (7), (8), (10);

-- 问题：找出缺失的数字范围

-- 方案：自连接查找间隙
SELECT
    n1.num + 1 as gap_start,
    MIN(n2.num) - 1 as gap_end
FROM numbers n1
LEFT JOIN numbers n2 ON n2.num > n1.num
WHERE NOT EXISTS (
    SELECT 1 FROM numbers n3
    WHERE n3.num = n1.num + 1
)
GROUP BY n1.num
HAVING MIN(n2.num) IS NOT NULL;

-- 结果：
-- gap_start | gap_end
-- ----------|--------
--     4     |    4
--     6     |    6
--     9     |    9
```

### 题10：查询库存分配（复杂约束）

```sql
-- 表结构
CREATE TABLE inventory (
    warehouse_id INTEGER,
    product_id INTEGER,
    stock INTEGER
);

CREATE TABLE orders_pending (
    order_id INTEGER,
    product_id INTEGER,
    quantity INTEGER
);

-- 问题：为订单分配库存（优先就近仓库，FIFO）

WITH order_allocation AS (
    SELECT
        o.order_id,
        o.product_id,
        o.quantity,
        i.warehouse_id,
        i.stock,
        ROW_NUMBER() OVER (
            PARTITION BY o.order_id
            ORDER BY i.warehouse_id
        ) as priority
    FROM orders_pending o
    JOIN inventory i ON o.product_id = i.product_id
    WHERE i.stock > 0
),
cumulative AS (
    SELECT
        *,
        SUM(stock) OVER (
            PARTITION BY order_id
            ORDER BY priority
            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
        ) as cumsum
    FROM order_allocation
)
SELECT
    order_id,
    warehouse_id,
    CASE
        WHEN cumsum - stock >= quantity THEN 0
        WHEN cumsum < quantity THEN stock
        ELSE quantity - (cumsum - stock)
    END as allocated_quantity
FROM cumulative
WHERE cumsum - stock < quantity;

-- 复杂度：涉及窗口函数、CASE表达式、累积计算
```

---

##理论题（5题）

### 题11：范式判断

```text
问题：判断以下关系的范式级别

关系R(学生ID, 课程ID, 教师ID, 教师办公室, 成绩)
函数依赖:
• (学生ID, 课程ID) → 成绩
• 课程ID → 教师ID
• 教师ID → 教师办公室

答案：
1. 是否1NF？✓ 是（所有属性原子）

2. 是否2NF？✗ 否
   原因：存在部分依赖
   • 课程ID → 教师ID（部分依赖于候选键(学生ID, 课程ID)）

3. 如何分解到3NF？
   R1(学生ID, 课程ID, 成绩)
   R2(课程ID, 教师ID)
   R3(教师ID, 教师办公室)

4. 是否BCNF？✗ 否
   如果教师ID不是超键但决定教师办公室
```

### 题12：事务隔离级别

```text
问题：以下场景会出现哪些异常？

场景1：
T1: SELECT balance FROM accounts WHERE id = 1;  -- 读到100
T2: UPDATE accounts SET balance = 200 WHERE id = 1;
T2: COMMIT;
T1: SELECT balance FROM accounts WHERE id = 1;  -- 读到200

答案：不可重复读（Non-repeatable Read）
• Read Uncommitted: ✓可能出现
• Read Committed: ✓可能出现
• Repeatable Read: ✗不会出现
• Serializable: ✗不会出现

场景2：
T1: SELECT SUM(balance) FROM accounts WHERE user_id = 1;  -- sum=200
T2: INSERT INTO accounts VALUES (3, 1, 100);
T2: COMMIT;
T1: SELECT SUM(balance) FROM accounts WHERE user_id = 1;  -- sum=300

答案：幻读（Phantom Read）
• Read Uncommitted: ✓可能出现
• Read Committed: ✓可能出现
• Repeatable Read (MySQL): ✗不会出现（Next-Key Lock）
• Repeatable Read (PostgreSQL): ✗不会出现（MVCC）
• Serializable: ✗不会出现

场景3：写偏序（Write Skew）
T1: SELECT SUM(balance) FROM accounts;  -- 200
T1: IF sum > 100 THEN UPDATE accounts SET balance = 0 WHERE id = 1;
T2: SELECT SUM(balance) FROM accounts;  -- 200
T2: IF sum > 100 THEN UPDATE accounts SET balance = 0 WHERE id = 2;
T1: COMMIT;
T2: COMMIT;
-- 最终sum=0（违反约束！）

答案：写偏序
• Snapshot Isolation: ✓可能出现
• Serializable: ✗不会出现
```

---

**文档版本**: v1.0
**最后更新**: 2025-12-05
**题目总数**: 40+题
