# 完整项目实战：电商系统端到端实现

> **创建日期**：2025-12-04
> **版本**：PostgreSQL 18 + SQLite 3.47.x
> **难度**：⭐⭐⭐⭐⭐
> **预计时间**：8-12小时

---

## 📋 项目概述

本案例演示一个完整的电商系统从需求分析到SQL实现的全流程，包括：

- 需求分析与ER建模
- PostgreSQL 18主数据库设计
- SQLite 3.47.x本地缓存/移动端设计
- MVCC并发控制实践
- 性能优化与监控

---

## 📑 目录

- [完整项目实战：电商系统端到端实现](#完整项目实战电商系统端到端实现)
  - [📋 项目概述](#-项目概述)
  - [📑 目录](#-目录)
  - [一、需求分析与ER建模](#一需求分析与er建模)
    - [1.1 业务需求](#11-业务需求)
    - [1.2 ER模型设计](#12-er模型设计)
    - [1.3 业务规则](#13-业务规则)
  - [二、PostgreSQL 18数据库设计](#二postgresql-18数据库设计)
    - [2.1 表结构设计（DDL）](#21-表结构设计ddl)
    - [2.2 索引设计](#22-索引设计)
    - [2.3 约束与触发器](#23-约束与触发器)
  - [三、核心业务逻辑实现](#三核心业务逻辑实现)
    - [3.1 用户注册与登录](#31-用户注册与登录)
    - [3.2 商品浏览与搜索](#32-商品浏览与搜索)
    - [3.3 购物车管理](#33-购物车管理)
    - [3.4 订单创建（MVCC并发控制）](#34-订单创建mvcc并发控制)
    - [3.5 库存扣减（ACID保证）](#35-库存扣减acid保证)
  - [四、数据分析查询](#四数据分析查询)
    - [4.1 销售报表（窗口函数）](#41-销售报表窗口函数)
    - [4.2 用户行为分析（CTE+JSON）](#42-用户行为分析ctejson)
    - [4.3 RFM模型（数据科学应用）](#43-rfm模型数据科学应用)
  - [五、SQLite移动端设计](#五sqlite移动端设计)
    - [5.1 本地数据库Schema](#51-本地数据库schema)
    - [5.2 离线支持与同步](#52-离线支持与同步)
    - [5.3 WAL模式配置](#53-wal模式配置)
  - [六、性能优化实践](#六性能优化实践)
    - [6.1 PostgreSQL优化](#61-postgresql优化)
    - [6.2 SQLite优化](#62-sqlite优化)
  - [七、监控与故障处理](#七监控与故障处理)
    - [7.1 性能监控](#71-性能监控)
    - [7.2 常见问题处理](#72-常见问题处理)

---

## 一、需求分析与ER建模

### 1.1 业务需求

**电商核心功能**：

- 用户管理：注册、登录、个人信息
- 商品管理：商品信息、库存、价格
- 购物车：添加商品、修改数量
- 订单系统：创建订单、支付、发货、退款
- 数据分析：销售统计、用户行为、RFM分析

**非功能需求**：

- 并发：支持1000+并发用户
- 性能：订单创建<200ms，查询<50ms
- 可靠性：ACID事务保证，零数据丢失
- 可用性：99.9%可用性，故障自动恢复

### 1.2 ER模型设计

```text
电商系统ER图
══════════════════════════════════════════════════════════════════════════════

┌──────────────┐                    ┌──────────────┐
│    Users     │                    │   Products   │
│──────────────│                    │──────────────│
│ PK user_id   │                    │ PK product_id│
│    username  │                    │    name      │
│    email     │                    │    price     │
│    password  │                    │    stock     │
│    created_at│                    │    category  │
└──────┬───────┘                    └──────┬───────┘
       │                                   │
       │ 1                              N  │
       │                                   │
       │         ┌──────────────┐          │
       └────────>│   Orders     │<─────────┘
                 │──────────────│ N
                 │ PK order_id  │
                 │ FK user_id   │
                 │    total     │
                 │    status    │
                 │    created_at│
                 └──────┬───────┘
                        │ 1
                        │
                        │ N
                 ┌──────▼───────┐          ┌──────────────┐
                 │ OrderItems   │────────> │   Products   │
                 │──────────────│ N      1 │──────────────│
                 │ PK item_id   │          │              │
                 │ FK order_id  │          │              │
                 │ FK product_id│          │              │
                 │    quantity  │          │              │
                 │    price     │          │              │
                 └──────────────┘          └──────────────┘

═══════════════════════════════════════════════════════════════════════════

关键关系：
• Users 1 : N Orders（一个用户多个订单）
• Orders 1 : N OrderItems（一个订单多个商品）
• Products 1 : N OrderItems（一个商品在多个订单中）
```

### 1.3 业务规则

```text
业务规则约束
══════════════════════════════════════════════════════════════════════════════

完整性约束：
1. 用户email唯一
2. 商品库存≥0
3. 订单总额=sum(item.price * item.quantity)
4. 订单状态：pending → paid → shipped → completed

并发控制规则：
1. 库存扣减必须原子性
2. 同一用户并发下单需要隔离
3. 库存扣减使用悲观锁或乐观锁

数据一致性规则：
1. 订单创建后，库存立即扣减
2. 订单取消后，库存回滚
3. 支付失败后，订单状态回滚
```

---

## 二、PostgreSQL 18数据库设计

### 2.1 表结构设计（DDL）

```sql
-- PostgreSQL 18电商数据库完整DDL

-- 1. 用户表
CREATE TABLE users (
    user_id BIGSERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    phone VARCHAR(20),
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    status VARCHAR(20) NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'inactive', 'banned')),

    -- PostgreSQL 18: 生成列
    email_domain VARCHAR(100) GENERATED ALWAYS AS (
        substring(email from '@(.*)$')
    ) STORED
);

-- 2. 商品表
CREATE TABLE products (
    product_id BIGSERIAL PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    description TEXT,
    price DECIMAL(10, 2) NOT NULL CHECK (price >= 0),
    stock INT NOT NULL DEFAULT 0 CHECK (stock >= 0),
    category VARCHAR(50) NOT NULL,
    tags TEXT[], -- PostgreSQL数组类型
    attributes JSONB, -- PostgreSQL 18 JSONB增强
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,

    -- 全文搜索向量（PostgreSQL特性）
    search_vector tsvector GENERATED ALWAYS AS (
        to_tsvector('english', coalesce(name, '') || ' ' || coalesce(description, ''))
    ) STORED
);

-- 3. 订单表
CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(user_id),
    total_amount DECIMAL(10, 2) NOT NULL CHECK (total_amount >= 0),
    status VARCHAR(20) NOT NULL DEFAULT 'pending'
        CHECK (status IN ('pending', 'paid', 'shipped', 'completed', 'cancelled')),
    payment_method VARCHAR(20),
    shipping_address JSONB NOT NULL, -- 结构化地址数据
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    paid_at TIMESTAMPTZ,
    shipped_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ,

    -- PostgreSQL 18: 时态追踪
    CONSTRAINT valid_status_transition CHECK (
        (status = 'pending' AND paid_at IS NULL) OR
        (status IN ('paid', 'shipped', 'completed') AND paid_at IS NOT NULL)
    )
);

-- 4. 订单项表
CREATE TABLE order_items (
    item_id BIGSERIAL PRIMARY KEY,
    order_id BIGINT NOT NULL REFERENCES orders(order_id) ON DELETE CASCADE,
    product_id BIGINT NOT NULL REFERENCES products(product_id),
    quantity INT NOT NULL CHECK (quantity > 0),
    price DECIMAL(10, 2) NOT NULL CHECK (price >= 0), -- 下单时价格快照
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- 5. 购物车表
CREATE TABLE cart_items (
    cart_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(user_id),
    product_id BIGINT NOT NULL REFERENCES products(product_id),
    quantity INT NOT NULL CHECK (quantity > 0),
    added_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,

    UNIQUE(user_id, product_id) -- 同一用户同一商品只有一条记录
);

-- 6. 库存变动历史表（审计）
CREATE TABLE stock_history (
    history_id BIGSERIAL PRIMARY KEY,
    product_id BIGINT NOT NULL REFERENCES products(product_id),
    order_id BIGINT REFERENCES orders(order_id),
    change_amount INT NOT NULL, -- 正数=入库，负数=出库
    stock_before INT NOT NULL,
    stock_after INT NOT NULL,
    reason VARCHAR(50) NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_by VARCHAR(50)
);

-- PostgreSQL 18: 分区表（按时间分区订单）
CREATE TABLE orders_partitioned (
    LIKE orders INCLUDING ALL
) PARTITION BY RANGE (created_at);

CREATE TABLE orders_2025_q1 PARTITION OF orders_partitioned
    FOR VALUES FROM ('2025-01-01') TO ('2025-04-01');

CREATE TABLE orders_2025_q2 PARTITION OF orders_partitioned
    FOR VALUES FROM ('2025-04-01') TO ('2025-07-01');
```

### 2.2 索引设计

```sql
-- 索引设计策略

-- 1. 用户表索引
CREATE INDEX idx_users_email ON users(email); -- 登录查询
CREATE INDEX idx_users_created_at ON users(created_at); -- 时间范围查询
CREATE INDEX idx_users_status ON users(status) WHERE status != 'active'; -- 部分索引

-- 2. 商品表索引
CREATE INDEX idx_products_category ON products(category); -- 分类浏览
CREATE INDEX idx_products_price ON products(price); -- 价格排序
CREATE INDEX idx_products_stock ON products(stock) WHERE stock > 0; -- 有货商品
-- 全文搜索索引（GIN）
CREATE INDEX idx_products_search ON products USING GIN(search_vector);
-- JSONB索引
CREATE INDEX idx_products_attrs ON products USING GIN(attributes);

-- 3. 订单表索引
CREATE INDEX idx_orders_user_id ON orders(user_id, created_at DESC); -- 用户订单查询
CREATE INDEX idx_orders_status ON orders(status, created_at)
    WHERE status IN ('pending', 'paid'); -- 待处理订单
CREATE INDEX idx_orders_created_at ON orders(created_at); -- 时间范围查询

-- 4. 订单项表索引
CREATE INDEX idx_order_items_order_id ON order_items(order_id); -- 订单详情查询
CREATE INDEX idx_order_items_product_id ON order_items(product_id); -- 商品销售统计

-- 5. 购物车表索引
CREATE INDEX idx_cart_user_id ON cart_items(user_id); -- 购物车查询

-- 6. 库存历史表索引（分区表）
CREATE INDEX idx_stock_history_product ON stock_history(product_id, created_at DESC);
CREATE INDEX idx_stock_history_order ON stock_history(order_id) WHERE order_id IS NOT NULL;
```

### 2.3 约束与触发器

```sql
-- 触发器：自动更新updated_at

CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER users_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER products_updated_at
    BEFORE UPDATE ON products
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- 触发器：记录库存变动

CREATE OR REPLACE FUNCTION log_stock_change()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'UPDATE' AND OLD.stock != NEW.stock THEN
        INSERT INTO stock_history (
            product_id, change_amount, stock_before, stock_after, reason
        ) VALUES (
            NEW.product_id,
            NEW.stock - OLD.stock,
            OLD.stock,
            NEW.stock,
            'order_or_restock'
        );
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER products_stock_change
    AFTER UPDATE ON products
    FOR EACH ROW
    EXECUTE FUNCTION log_stock_change();

-- 触发器：订单总额校验

CREATE OR REPLACE FUNCTION validate_order_total()
RETURNS TRIGGER AS $$
DECLARE
    calculated_total DECIMAL(10, 2);
BEGIN
    SELECT SUM(price * quantity) INTO calculated_total
    FROM order_items
    WHERE order_id = NEW.order_id;

    IF ABS(calculated_total - NEW.total_amount) > 0.01 THEN
        RAISE EXCEPTION '订单总额不匹配: 计算值=%, 实际值=%', calculated_total, NEW.total_amount;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER orders_total_validation
    BEFORE INSERT OR UPDATE ON orders
    FOR EACH ROW
    EXECUTE FUNCTION validate_order_total();
```

---

## 三、核心业务逻辑实现

### 3.1 用户注册与登录

```sql
-- 用户注册（含冲突处理）

-- PostgreSQL 18: INSERT ... ON CONFLICT
CREATE OR REPLACE FUNCTION register_user(
    p_username VARCHAR(50),
    p_email VARCHAR(100),
    p_password_hash VARCHAR(255)
) RETURNS BIGINT AS $$
DECLARE
    v_user_id BIGINT;
BEGIN
    INSERT INTO users (username, email, password_hash)
    VALUES (p_username, p_email, p_password_hash)
    ON CONFLICT (email) DO UPDATE
        SET username = EXCLUDED.username
    RETURNING user_id INTO v_user_id;

    RETURN v_user_id;
EXCEPTION
    WHEN unique_violation THEN
        RAISE EXCEPTION '用户名或邮箱已存在';
    WHEN OTHERS THEN
        RAISE EXCEPTION '注册失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- 使用示例
SELECT register_user('alice', 'alice@example.com', 'hash123');

-- 用户登录验证
SELECT user_id, username, email
FROM users
WHERE email = $1 AND password_hash = $2 AND status = 'active';
```

### 3.2 商品浏览与搜索

```sql
-- 商品分类浏览（含分页）

WITH product_list AS (
    SELECT
        product_id,
        name,
        price,
        stock,
        attributes,
        -- PostgreSQL 18: ROW_NUMBER窗口函数
        ROW_NUMBER() OVER (PARTITION BY category ORDER BY created_at DESC) as rn
    FROM products
    WHERE category = $1 AND stock > 0
)
SELECT product_id, name, price, stock, attributes
FROM product_list
WHERE rn BETWEEN $2 AND $3; -- 分页: OFFSET, LIMIT

-- 全文搜索（PostgreSQL GIN索引）

SELECT
    product_id,
    name,
    price,
    stock,
    ts_rank(search_vector, query) AS rank
FROM products,
     to_tsquery('english', $1) query
WHERE search_vector @@ query
    AND stock > 0
ORDER BY rank DESC, created_at DESC
LIMIT 20;

-- JSONB属性搜索（PostgreSQL 18增强）

SELECT product_id, name, price, attributes
FROM products
WHERE attributes @> '{"brand": "Apple"}'::jsonb  -- 包含指定属性
    AND attributes ? 'color'  -- 存在color键
    AND (attributes->>'size')::int >= 6  -- 尺寸条件
    AND stock > 0
ORDER BY price;
```

### 3.3 购物车管理

```sql
-- 添加到购物车（UPSERT）

INSERT INTO cart_items (user_id, product_id, quantity)
VALUES ($1, $2, $3)
ON CONFLICT (user_id, product_id)
DO UPDATE SET
    quantity = cart_items.quantity + EXCLUDED.quantity,
    added_at = CURRENT_TIMESTAMP;

-- 查看购物车（JOIN查询）

SELECT
    c.cart_id,
    c.product_id,
    p.name,
    p.price,
    c.quantity,
    (p.price * c.quantity) AS subtotal,
    CASE
        WHEN p.stock >= c.quantity THEN '有货'
        WHEN p.stock > 0 THEN '库存不足'
        ELSE '无货'
    END AS stock_status
FROM cart_items c
JOIN products p ON c.product_id = p.product_id
WHERE c.user_id = $1
ORDER BY c.added_at DESC;

-- 清空购物车

DELETE FROM cart_items WHERE user_id = $1;
```

### 3.4 订单创建（MVCC并发控制）

```sql
-- 订单创建完整流程（利用PostgreSQL 18 MVCC）

CREATE OR REPLACE FUNCTION create_order(
    p_user_id BIGINT,
    p_cart_items JSONB, -- [{product_id, quantity}, ...]
    p_shipping_address JSONB
) RETURNS BIGINT AS $$
DECLARE
    v_order_id BIGINT;
    v_total_amount DECIMAL(10, 2) := 0;
    v_item JSONB;
    v_product_price DECIMAL(10, 2);
    v_product_stock INT;
BEGIN
    -- 1. 创建订单（获取order_id）
    INSERT INTO orders (user_id, total_amount, status, shipping_address)
    VALUES (p_user_id, 0, 'pending', p_shipping_address)
    RETURNING order_id INTO v_order_id;

    -- 2. 遍历购物车项，创建订单项并扣减库存
    FOR v_item IN SELECT * FROM jsonb_array_elements(p_cart_items)
    LOOP
        -- 2.1 检查商品信息和库存（SELECT FOR UPDATE加悲观锁）
        SELECT price, stock INTO v_product_price, v_product_stock
        FROM products
        WHERE product_id = (v_item->>'product_id')::BIGINT
        FOR UPDATE; -- 悲观锁，防止并发库存问题

        IF NOT FOUND THEN
            RAISE EXCEPTION '商品不存在: product_id=%', v_item->>'product_id';
        END IF;

        IF v_product_stock < (v_item->>'quantity')::INT THEN
            RAISE EXCEPTION '库存不足: 商品%, 需要%, 剩余%',
                v_item->>'product_id', v_item->>'quantity', v_product_stock;
        END IF;

        -- 2.2 创建订单项
        INSERT INTO order_items (order_id, product_id, quantity, price)
        VALUES (
            v_order_id,
            (v_item->>'product_id')::BIGINT,
            (v_item->>'quantity')::INT,
            v_product_price
        );

        -- 2.3 扣减库存
        UPDATE products
        SET stock = stock - (v_item->>'quantity')::INT
        WHERE product_id = (v_item->>'product_id')::BIGINT;

        -- 2.4 累加订单总额
        v_total_amount := v_total_amount +
            (v_product_price * (v_item->>'quantity')::INT);
    END LOOP;

    -- 3. 更新订单总额
    UPDATE orders
    SET total_amount = v_total_amount
    WHERE order_id = v_order_id;

    -- 4. 清空购物车
    DELETE FROM cart_items
    WHERE user_id = p_user_id
        AND product_id IN (
            SELECT (value->>'product_id')::BIGINT
            FROM jsonb_array_elements(p_cart_items)
        );

    RETURN v_order_id;
END;
$$ LANGUAGE plpgsql;

-- 使用示例（完整事务）
BEGIN;
SET TRANSACTION ISOLATION LEVEL READ COMMITTED; -- 或REPEATABLE READ

SELECT create_order(
    1001, -- user_id
    '[
        {"product_id": 5001, "quantity": 2},
        {"product_id": 5002, "quantity": 1}
    ]'::jsonb,
    '{"address": "123 Main St", "city": "NYC", "zip": "10001"}'::jsonb
);

COMMIT;

-- 错误处理示例
BEGIN;
    SELECT create_order(...);
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE NOTICE '订单创建失败: %', SQLERRM;
```

### 3.5 库存扣减（ACID保证）

```sql
-- 方案1: 悲观锁（SELECT FOR UPDATE）

BEGIN ISOLATION LEVEL READ COMMITTED;

-- 锁定商品行
SELECT product_id, stock INTO v_product_id, v_current_stock
FROM products
WHERE product_id = $1
FOR UPDATE; -- 其他事务等待此事务完成

-- 检查库存
IF v_current_stock < $2 THEN
    RAISE EXCEPTION '库存不足';
END IF;

-- 扣减库存
UPDATE products
SET stock = stock - $2
WHERE product_id = $1;

COMMIT;

-- 方案2: 乐观锁（版本号）

-- 添加version列
ALTER TABLE products ADD COLUMN version INT NOT NULL DEFAULT 1;

-- 乐观锁更新
UPDATE products
SET stock = stock - $2,
    version = version + 1
WHERE product_id = $1
    AND version = $3  -- 传入的版本号
    AND stock >= $2;

-- 检查更新结果
GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
IF v_rows_affected = 0 THEN
    -- 版本冲突或库存不足，需要重试
    RAISE EXCEPTION '库存扣减失败，请重试';
END IF;

-- 方案3: 使用MVCC避免锁（适合读多写少）

-- 直接更新，利用PostgreSQL MVCC
UPDATE products
SET stock = stock - $2
WHERE product_id = $1
    AND stock >= $2;  -- CHECK约束确保stock不为负

-- 检查是否成功
IF NOT FOUND THEN
    RAISE EXCEPTION '库存不足或商品不存在';
END IF;

-- PostgreSQL MVCC自动处理并发：
-- • 每个事务看到自己的快照
-- • First-committer-wins规则
-- • 冲突事务自动abort
```

---

## 四、数据分析查询

### 4.1 销售报表（窗口函数）

```sql
-- 每日销售统计（使用PostgreSQL 18窗口函数增强）

WITH daily_sales AS (
    SELECT
        DATE(o.created_at) AS sale_date,
        SUM(o.total_amount) AS daily_total,
        COUNT(DISTINCT o.order_id) AS order_count,
        COUNT(DISTINCT o.user_id) AS customer_count
    FROM orders o
    WHERE o.status IN ('paid', 'shipped', 'completed')
        AND o.created_at >= CURRENT_DATE - INTERVAL '30 days'
    GROUP BY DATE(o.created_at)
)
SELECT
    sale_date,
    daily_total,
    order_count,
    customer_count,
    -- 移动平均（7天）
    AVG(daily_total) OVER (
        ORDER BY sale_date
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS ma_7day,
    -- 环比增长
    (daily_total - LAG(daily_total) OVER (ORDER BY sale_date)) /
        NULLIF(LAG(daily_total) OVER (ORDER BY sale_date), 0) * 100 AS daily_growth_pct,
    -- 累计销售额
    SUM(daily_total) OVER (ORDER BY sale_date) AS cumulative_total,
    -- 排名
    DENSE_RANK() OVER (ORDER BY daily_total DESC) AS sales_rank
FROM daily_sales
ORDER BY sale_date DESC;

-- 商品销售TOP 10（多维分析）

SELECT
    p.product_id,
    p.name,
    p.category,
    COUNT(DISTINCT oi.order_id) AS order_count,
    SUM(oi.quantity) AS total_quantity,
    SUM(oi.price * oi.quantity) AS total_revenue,
    AVG(oi.price) AS avg_price,
    -- PostgreSQL 18: FILTER子句
    COUNT(*) FILTER (WHERE o.created_at >= CURRENT_DATE - 7) AS orders_last_week,
    -- 排名（按销售额）
    RANK() OVER (PARTITION BY p.category ORDER BY SUM(oi.price * oi.quantity) DESC) AS category_rank
FROM products p
JOIN order_items oi ON p.product_id = oi.product_id
JOIN orders o ON oi.order_id = o.order_id
WHERE o.status IN ('paid', 'shipped', 'completed')
    AND o.created_at >= CURRENT_DATE - 30
GROUP BY p.product_id, p.name, p.category
HAVING SUM(oi.price * oi.quantity) > 0
ORDER BY total_revenue DESC
LIMIT 10;
```

### 4.2 用户行为分析（CTE+JSON）

```sql
-- 用户购买路径分析（递归CTE）

WITH RECURSIVE user_journey AS (
    -- 基础：第一次访问
    SELECT
        user_id,
        MIN(created_at) AS first_visit,
        1 AS step
    FROM orders
    GROUP BY user_id

    UNION ALL

    -- 递归：后续订单
    SELECT
        o.user_id,
        o.created_at,
        uj.step + 1
    FROM orders o
    JOIN user_journey uj ON o.user_id = uj.user_id
    WHERE o.created_at > uj.first_visit
        AND uj.step < 10  -- 限制递归深度
)
SELECT
    user_id,
    COUNT(*) AS total_orders,
    JSONB_AGG(
        JSONB_BUILD_OBJECT(
            'step', step,
            'date', first_visit,
            'days_since_first', EXTRACT(DAY FROM (first_visit - MIN(first_visit) OVER (PARTITION BY user_id)))
        ) ORDER BY step
    ) AS journey
FROM user_journey
GROUP BY user_id
HAVING COUNT(*) >= 2  -- 至少2次购买
ORDER BY total_orders DESC
LIMIT 100;

-- 用户画像（JSONB聚合）

SELECT
    u.user_id,
    u.username,
    u.email,
    JSONB_BUILD_OBJECT(
        'total_orders', COUNT(DISTINCT o.order_id),
        'total_spent', COALESCE(SUM(o.total_amount), 0),
        'avg_order_value', COALESCE(AVG(o.total_amount), 0),
        'favorite_categories', (
            SELECT JSONB_AGG(DISTINCT p.category)
            FROM order_items oi
            JOIN products p ON oi.product_id = p.product_id
            WHERE oi.order_id = ANY(ARRAY_AGG(o.order_id))
        ),
        'last_order_date', MAX(o.created_at),
        'days_since_last_order', EXTRACT(DAY FROM (CURRENT_TIMESTAMP - MAX(o.created_at)))
    ) AS profile
FROM users u
LEFT JOIN orders o ON u.user_id = o.user_id
    AND o.status IN ('paid', 'shipped', 'completed')
WHERE u.status = 'active'
GROUP BY u.user_id, u.username, u.email
ORDER BY COALESCE(SUM(o.total_amount), 0) DESC;
```

### 4.3 RFM模型（数据科学应用）

```sql
-- RFM分析：Recency（最近）、Frequency（频率）、Monetary（金额）

WITH customer_rfm AS (
    SELECT
        u.user_id,
        u.username,
        u.email,
        -- R: 最近一次购买距今天数
        EXTRACT(DAY FROM (CURRENT_DATE - MAX(o.created_at))) AS recency_days,
        -- F: 购买次数
        COUNT(DISTINCT o.order_id) AS frequency,
        -- M: 总消费金额
        SUM(o.total_amount) AS monetary
    FROM users u
    LEFT JOIN orders o ON u.user_id = o.user_id
        AND o.status IN ('paid', 'shipped', 'completed')
    WHERE u.status = 'active'
    GROUP BY u.user_id, u.username, u.email
),
rfm_scores AS (
    SELECT
        *,
        -- 计算RFM分数（使用NTILE分位数）
        NTILE(5) OVER (ORDER BY recency_days) AS r_score,  -- 越小越好
        NTILE(5) OVER (ORDER BY frequency DESC) AS f_score, -- 越大越好
        NTILE(5) OVER (ORDER BY monetary DESC) AS m_score,  -- 越大越好
        -- 综合评分
        (5 - NTILE(5) OVER (ORDER BY recency_days)) +  -- 反转R分数
        NTILE(5) OVER (ORDER BY frequency DESC) +
        NTILE(5) OVER (ORDER BY monetary DESC) AS total_score
    FROM customer_rfm
)
SELECT
    user_id,
    username,
    email,
    recency_days,
    frequency,
    monetary,
    r_score,
    f_score,
    m_score,
    total_score,
    -- 客户分级
    CASE
        WHEN total_score >= 12 THEN '重要保持客户'
        WHEN total_score >= 9 THEN '重要发展客户'
        WHEN total_score >= 6 THEN '一般客户'
        ELSE '流失预警客户'
    END AS customer_segment
FROM rfm_scores
ORDER BY total_score DESC;
```

---

## 五、SQLite移动端设计

### 5.1 本地数据库Schema

```sql
-- SQLite 3.47.x 移动端数据库设计

-- 用户信息（简化）
CREATE TABLE users (
    user_id INTEGER PRIMARY KEY,
    username TEXT NOT NULL,
    email TEXT NOT NULL UNIQUE,
    sync_version INTEGER NOT NULL DEFAULT 0, -- 同步版本号
    last_sync_at TEXT -- ISO8601时间戳
) STRICT; -- SQLite 3.37+ STRICT模式

-- 商品缓存（离线浏览）
CREATE TABLE products_cache (
    product_id INTEGER PRIMARY KEY,
    name TEXT NOT NULL,
    price REAL NOT NULL CHECK (price >= 0),
    stock INTEGER NOT NULL CHECK (stock >= 0),
    category TEXT NOT NULL,
    attributes TEXT, -- JSON字符串
    image_url TEXT,
    cached_at TEXT NOT NULL,

    -- SQLite 3.31+: 生成列
    price_tier TEXT GENERATED ALWAYS AS (
        CASE
            WHEN price < 10 THEN 'budget'
            WHEN price < 100 THEN 'standard'
            ELSE 'premium'
        END
    ) VIRTUAL
) STRICT;

-- 本地购物车
CREATE TABLE cart_local (
    cart_id INTEGER PRIMARY KEY AUTOINCREMENT,
    product_id INTEGER NOT NULL,
    quantity INTEGER NOT NULL CHECK (quantity > 0),
    added_at TEXT NOT NULL,
    synced INTEGER NOT NULL DEFAULT 0, -- 0=未同步, 1=已同步

    FOREIGN KEY (product_id) REFERENCES products_cache(product_id)
) STRICT;

-- 订单历史（只读同步）
CREATE TABLE orders_history (
    order_id INTEGER PRIMARY KEY,
    user_id INTEGER NOT NULL,
    total_amount REAL NOT NULL,
    status TEXT NOT NULL,
    items TEXT NOT NULL, -- JSONB字符串
    created_at TEXT NOT NULL,
    synced_at TEXT NOT NULL
) STRICT;

-- 同步日志
CREATE TABLE sync_log (
    log_id INTEGER PRIMARY KEY AUTOINCREMENT,
    table_name TEXT NOT NULL,
    operation TEXT NOT NULL, -- 'pull' or 'push'
    records_count INTEGER NOT NULL,
    sync_at TEXT NOT NULL,
    status TEXT NOT NULL, -- 'success' or 'failed'
    error_message TEXT
) STRICT;
```

### 5.2 离线支持与同步

```sql
-- 离线操作支持

-- 1. 本地购物车添加
INSERT INTO cart_local (product_id, quantity, added_at, synced)
VALUES (?, ?, datetime('now'), 0);

-- 2. 检查待同步项
SELECT cart_id, product_id, quantity
FROM cart_local
WHERE synced = 0;

-- 3. 同步到服务器（应用层HTTP请求）
-- 成功后标记为已同步
UPDATE cart_local SET synced = 1 WHERE cart_id = ?;

-- 4. 从服务器拉取订单
-- INSERT INTO orders_history ... FROM server_api

-- 5. 增量同步（基于版本号）
-- 只同步version > last_sync_version的数据
```

### 5.3 WAL模式配置

```sql
-- SQLite 3.47.x移动端最佳配置

-- 启用WAL模式（提高并发）
PRAGMA journal_mode=WAL;

-- 同步模式（移动端推荐NORMAL）
PRAGMA synchronous=NORMAL; -- 平衡性能与数据安全

-- 缓存大小（移动端适中）
PRAGMA cache_size=-8000; -- 8MB缓存

-- 自动checkpoint
PRAGMA wal_autocheckpoint=1000; -- 每1000页触发

-- 临时表使用内存
PRAGMA temp_store=MEMORY;

-- mmap（减少内存复制）
PRAGMA mmap_size=268435456; -- 256MB

-- 启用外键
PRAGMA foreign_keys=ON;

-- 查询优化
PRAGMA optimize; -- 定期执行
```

---

## 六、性能优化实践

### 6.1 PostgreSQL优化

```sql
-- 1. 查询优化：使用EXPLAIN ANALYZE

EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT p.name, SUM(oi.quantity) AS total_sold
FROM products p
JOIN order_items oi ON p.product_id = oi.product_id
JOIN orders o ON oi.order_id = o.order_id
WHERE o.status IN ('paid', 'shipped', 'completed')
    AND o.created_at >= CURRENT_DATE - 30
GROUP BY p.product_id, p.name
ORDER BY total_sold DESC
LIMIT 10;

-- 优化结果分析：
-- • Index Scan vs Seq Scan
-- • Buffers: 命中率
-- • Planning Time vs Execution Time

-- 2. 物化视图（预计算）

CREATE MATERIALIZED VIEW mv_daily_sales AS
SELECT
    DATE(created_at) AS sale_date,
    COUNT(*) AS order_count,
    SUM(total_amount) AS total_amount,
    AVG(total_amount) AS avg_amount
FROM orders
WHERE status IN ('paid', 'shipped', 'completed')
GROUP BY DATE(created_at);

CREATE INDEX idx_mv_daily_sales_date ON mv_daily_sales(sale_date);

-- 定期刷新
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_daily_sales;

-- 3. 分区表优化

-- 查询自动路由到相应分区
SELECT * FROM orders_partitioned
WHERE created_at >= '2025-01-01' AND created_at < '2025-04-01';
-- 只扫描orders_2025_q1分区

-- 4. 并行查询（PostgreSQL 18）

SET max_parallel_workers_per_gather = 4;

SELECT product_id, COUNT(*)
FROM order_items
GROUP BY product_id
HAVING COUNT(*) > 100;
-- 自动并行执行

-- 5. 统计信息更新

ANALYZE products;
ANALYZE orders;
ANALYZE order_items;
```

### 6.2 SQLite优化

```sql
-- 1. 批量操作优化

BEGIN IMMEDIATE; -- 立即获取写锁

-- 批量插入
INSERT INTO products_cache (product_id, name, price, stock, category, cached_at)
VALUES
    (1, 'Product1', 19.99, 100, 'Electronics', datetime('now')),
    (2, 'Product2', 29.99, 50, 'Electronics', datetime('now')),
    ... -- 1000行
;

COMMIT;
-- 性能: 单个事务比1000个事务快100倍

-- 2. 索引优化

-- 查看查询计划
EXPLAIN QUERY PLAN
SELECT * FROM products_cache WHERE category = 'Electronics';

-- 如果显示SCAN TABLE，创建索引
CREATE INDEX IF NOT EXISTS idx_products_category
ON products_cache(category);

-- 3. 更新统计信息

ANALYZE;

-- 4. 定期维护

-- 清理空闲空间
VACUUM;

-- Checkpoint WAL
PRAGMA wal_checkpoint(TRUNCATE);

-- 5. 查询优化

-- 避免SELECT *
SELECT product_id, name, price FROM products_cache WHERE ...;

-- 使用覆盖索引
CREATE INDEX idx_products_price_name ON products_cache(price, name);
SELECT price, name FROM products_cache WHERE price < 100;
-- 只扫描索引，不回表
```

---

## 七、监控与故障处理

### 7.1 性能监控

```python
# PostgreSQL监控

import psycopg2

conn = psycopg2.connect(...)

# 1. 活跃连接数
cursor.execute("""
    SELECT count(*) as active_connections
    FROM pg_stat_activity
    WHERE state = 'active';
""")

# 2. 慢查询TOP 10
cursor.execute("""
    SELECT query, calls, total_exec_time, mean_exec_time
    FROM pg_stat_statements
    WHERE mean_exec_time > 100  -- >100ms
    ORDER BY mean_exec_time DESC
    LIMIT 10;
""")

# 3. 表膨胀检查
cursor.execute("""
    SELECT
        schemaname, tablename,
        pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size,
        n_dead_tup AS dead_tuples
    FROM pg_stat_user_tables
    WHERE n_dead_tup > 1000
    ORDER BY n_dead_tup DESC;
""")

# 4. 锁等待
cursor.execute("""
    SELECT pid, usename, wait_event_type, wait_event, query
    FROM pg_stat_activity
    WHERE wait_event IS NOT NULL;
""")
```

```python
# SQLite监控

import sqlite3

conn = sqlite3.connect('mobile.db')

# 1. WAL文件大小
cursor = conn.execute("PRAGMA wal_checkpoint(PASSIVE)")
wal_info = cursor.fetchone()
print(f"WAL frames: {wal_info[0]}, Checkpointed: {wal_info[1]}")

# 2. 数据库大小
cursor = conn.execute("PRAGMA page_count")
page_count = cursor.fetchone()[0]
cursor = conn.execute("PRAGMA page_size")
page_size = cursor.fetchone()[0]
size_mb = (page_count * page_size) / 1024 / 1024
print(f"Database size: {size_mb:.2f}MB")

# 3. 索引使用
cursor = conn.execute("SELECT * FROM sqlite_stat1")
for row in cursor:
    print(f"Table: {row[0]}, Index: {row[1]}, Stats: {row[2]}")
```

### 7.2 常见问题处理

```sql
-- PostgreSQL: 死锁处理

-- 查看死锁
SELECT * FROM pg_stat_activity WHERE wait_event_type = 'Lock';

-- 杀死死锁进程
SELECT pg_terminate_backend(pid) FROM pg_stat_activity
WHERE state = 'active' AND query_start < NOW() - INTERVAL '5 minutes';

-- 避免死锁：按相同顺序访问资源
BEGIN;
SELECT * FROM products WHERE product_id = 1 FOR UPDATE;
SELECT * FROM products WHERE product_id = 2 FOR UPDATE;
-- 统一按ID升序加锁

-- SQLite: SQLITE_BUSY处理

-- 设置超时
PRAGMA busy_timeout=5000; -- 5秒

-- Python重试逻辑
import time
def execute_with_retry(conn, sql, params, max_retries=5):
    for i in range(max_retries):
        try:
            return conn.execute(sql, params)
        except sqlite3.OperationalError as e:
            if "database is locked" in str(e) and i < max_retries - 1:
                time.sleep(0.1 * (2 ** i))  # 指数退避
            else:
                raise
```

---

**项目完成！** 🎉

这个端到端案例涵盖了：

- ✅ ER建模 → SQL DDL映射
- ✅ PostgreSQL 18最新特性（分区表、JSONB、窗口函数）
- ✅ SQLite 3.47.x移动端应用
- ✅ MVCC并发控制实践
- ✅ ACID事务保证
- ✅ 数据科学应用（RFM模型）
- ✅ 性能优化与监控

---

**文档版本**: v1.0.0
**最后更新**: 2025-12-04
**维护者**: SQL Standards Team
