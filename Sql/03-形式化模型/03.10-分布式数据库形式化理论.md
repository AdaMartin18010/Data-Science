# 分布式数据库形式化理论

> **创建日期**：2025-12-01
> **最后更新**：2025-12-01
> **版本**：v1.0.0
> **形式化层次**：L4-可验证
> **对标课程**：CMU 15-721, MIT 6.824
> **目的**：建立分布式数据库系统的完整形式化理论体系

---

## 📋 目录

- [分布式数据库形式化理论](#分布式数据库形式化理论)
  - [📋 目录](#-目录)
  - [一、概述](#一概述)
    - [1.1 分布式数据库知识体系](#11-分布式数据库知识体系)
    - [1.2 CAP定理](#12-cap定理)
  - [二、分布式事务形式化](#二分布式事务形式化)
    - [2.1 两阶段提交协议 (2PC)](#21-两阶段提交协议-2pc)
    - [2.2 三阶段提交协议 (3PC)](#22-三阶段提交协议-3pc)
    - [2.3 Saga模式](#23-saga模式)
  - [三、一致性模型形式化](#三一致性模型形式化)
    - [3.1 强一致性](#31-强一致性)
    - [3.2 弱一致性](#32-弱一致性)
    - [3.3 PACELC定理](#33-pacelc定理)
  - [四、分布式查询形式化](#四分布式查询形式化)
    - [4.1 分布式连接策略](#41-分布式连接策略)
    - [4.2 分布式聚合](#42-分布式聚合)
  - [五、复制协议形式化](#五复制协议形式化)
    - [5.1 主从复制](#51-主从复制)
    - [5.2 Raft一致性协议](#52-raft一致性协议)
  - [六、正确性证明](#六正确性证明)
    - [6.1 分布式事务正确性](#61-分布式事务正确性)
    - [6.2 一致性协议正确性](#62-一致性协议正确性)
  - [七、相关资源](#七相关资源)
    - [内部链接](#内部链接)
    - [外部资源](#外部资源)

---

## 一、概述

### 1.1 分布式数据库知识体系

```text
┌─────────────────────────────────────────────────────────────────────────┐
│                    分布式数据库形式化知识体系                             │
└─────────────────────────────────────────────────────────────────────────┘

                        分布式数据库
                             │
        ┌────────┬───────────┼───────────┬────────┐
        │        │           │           │        │
        ▼        ▼           ▼           ▼        ▼
    分布式    一致性      分布式     复制      分区
    事务      模型        查询       协议      策略
        │        │           │           │        │
    ┌───┴───┐    │       ┌───┴───┐   ┌───┴───┐    │
    │       │    │       │       │   │       │    │
    ▼       ▼    ▼       ▼       ▼   ▼       ▼    ▼
   2PC    Saga CAP     分布式  分布式 主从  多主  Hash
   3PC    TCC  PACELC   JOIN   聚合  复制  复制  Range
```

### 1.2 CAP定理

```text
定理1.1 (CAP定理 - Brewer 2000)
───────────────────────────────

在分布式系统中，最多只能同时满足以下三个中的两个：
- Consistency (C): 所有节点看到相同数据
- Availability (A): 每个请求都能收到响应
- Partition Tolerance (P): 网络分区时系统继续运行

形式化定义：
───────────
设S为分布式系统，N为节点集合

C: ∀n₁, n₂ ∈ N, ∀t: read(n₁, t) = read(n₂, t)

A: ∀n ∈ N, ∀req: ∃resp: respond(n, req, resp) 在有限时间内

P: 系统在网络分区时继续正常工作

证明(不可能三角)：
────────────────
假设系统同时满足CAP

场景：节点n₁和n₂之间网络分区

1. 由P，系统继续运行
2. 客户端向n₁发送write(x, v)
3. 由A，n₁必须响应（假设成功）
4. 客户端向n₂发送read(x)
5. 由A，n₂必须响应
6. 由于分区，n₂无法获取v
7. n₂返回旧值v'，违反C

矛盾！故CAP三者不可兼得
Q.E.D.

系统选择：
─────────
- CP系统: 牺牲可用性 (例: HBase, MongoDB)
- AP系统: 牺牲一致性 (例: Cassandra, DynamoDB)
- CA系统: 不存在（必须容忍分区）
```

---

## 二、分布式事务形式化

### 2.1 两阶段提交协议 (2PC)

```text
定义2.1 (2PC协议)
─────────────────

参与者: Coordinator (C), Participants (P₁, ..., Pₙ)

Phase 1 (Prepare/Voting):
  C → Pᵢ: PREPARE
  Pᵢ → C: VOTE_YES 或 VOTE_NO

Phase 2 (Commit/Abort):
  if 所有Pᵢ投VOTE_YES then
    C → Pᵢ: COMMIT
  else
    C → Pᵢ: ABORT

状态机：
────────
Coordinator:
  INIT --prepare→ WAIT --allYes→ COMMITTED
                       --anyNo→ ABORTED

Participant:
  INIT --prepare→ READY --commit→ COMMITTED
                        --abort→ ABORTED

形式化属性：
───────────
安全性(Safety):
  若任一Pᵢ提交，则所有Pⱼ最终提交
  若任一Pᵢ回滚，则所有Pⱼ最终回滚

活性(Liveness):
  若无故障，事务最终完成

阻塞问题：
─────────
若Coordinator在Phase 2前故障：
- 参与者处于READY状态
- 无法独立决定提交或回滚
- 系统阻塞

定理2.1 (2PC阻塞性)
────────────────────

2PC是阻塞协议

证明：
设C在发送COMMIT前故障
P₁已投VOTE_YES，处于READY
P₁不知道其他参与者的投票
P₁无法安全地单方面决定
故阻塞
Q.E.D.
```

### 2.2 三阶段提交协议 (3PC)

```text
定义2.2 (3PC协议)
─────────────────

增加Pre-Commit阶段以解决阻塞

Phase 1 (CanCommit):
  C → Pᵢ: CAN_COMMIT?
  Pᵢ → C: YES 或 NO

Phase 2 (PreCommit):
  if 所有YES then
    C → Pᵢ: PRE_COMMIT
    Pᵢ → C: ACK
  else
    C → Pᵢ: ABORT

Phase 3 (DoCommit):
  C → Pᵢ: DO_COMMIT

超时规则：
─────────
- 参与者在PreCommit阶段超时: ABORT
- 参与者在DoCommit阶段超时: COMMIT (因已知全局决定)

定理2.2 (3PC非阻塞性)
──────────────────────

3PC在无网络分区时非阻塞

证明大纲：
参与者可根据当前状态和超时独立决定
- INIT/WAIT: 超时则ABORT
- PRECOMMIT: 超时则COMMIT
故非阻塞
```

### 2.3 Saga模式

```text
定义2.3 (Saga)
──────────────

Saga是一系列本地事务T₁, T₂, ..., Tₙ
每个Tᵢ有补偿事务Cᵢ

执行规则：
─────────
顺序执行: T₁ → T₂ → ... → Tₙ

若Tₖ失败:
  执行补偿: Cₖ₋₁ → Cₖ₋₂ → ... → C₁

形式化语义：
───────────
Saga(T₁...Tₙ, C₁...Cₙ):
  for i = 1 to n:
    if Tᵢ fails then
      for j = i-1 downto 1:
        Cⱼ()
      return FAILED
  return SUCCESS

正确性条件：
───────────
∀i: Cᵢ(Tᵢ(s)) = s  // 补偿恢复原状态

定理2.3 (Saga最终一致性)
────────────────────────

Saga保证最终一致性，但不保证隔离性

证明：
无论成功或失败，系统最终到达一致状态
- 成功: 所有Tᵢ完成
- 失败: 所有已执行Tⱼ被补偿
但中间状态对其他事务可见（无隔离）
```

---

## 三、一致性模型形式化

### 3.1 强一致性

```text
定义3.1 (线性一致性 - Linearizability)
──────────────────────────────────────

操作看起来是原子的，且按实时顺序发生

形式化：
设History H为操作序列
H是线性一致的 ⟺
存在操作的全序S，满足:
1. S尊重实时顺序: op₁ ends before op₂ starts ⟹ op₁ <_S op₂
2. S是顺序一致的: 操作结果与S中顺序执行一致

定义3.2 (顺序一致性 - Sequential Consistency)
─────────────────────────────────────────────

所有进程看到相同的操作顺序，且每个进程的操作按程序顺序

形式化：
H是顺序一致的 ⟺
存在全序S，满足:
1. 程序顺序: ∀进程P, ∀op₁, op₂ ∈ P: 若op₁ <_P op₂ 则 op₁ <_S op₂
2. 结果一致: 操作结果与S中顺序执行一致

区别：
线性一致性要求尊重实时顺序
顺序一致性只要求尊重程序顺序
```

### 3.2 弱一致性

```text
定义3.3 (最终一致性 - Eventual Consistency)
────────────────────────────────────────────

若无新更新，所有副本最终收敛到相同值

形式化：
∀x, 若 ∀t > t₀: no_update(x, t)
则 ∃t₁: ∀t > t₁, ∀replica r: read(r, x, t) = v

定义3.4 (因果一致性 - Causal Consistency)
─────────────────────────────────────────

因果相关的操作按因果顺序观察

因果关系:
op₁ → op₂ (op₁ happens-before op₂) 若:
1. 同一进程: op₁在op₂之前
2. 读写依赖: op₂读取op₁写入的值
3. 传递: op₁ → op₃ ∧ op₃ → op₂

H是因果一致的 ⟺
∀进程P, ∀op₁ → op₂: P观察到op₁在op₂之前
```

### 3.3 PACELC定理

```text
定理3.1 (PACELC - Abadi 2012)
─────────────────────────────

CAP的扩展：即使无分区，也需在延迟和一致性间权衡

if Partition then
  choose between Availability and Consistency
else
  choose between Latency and Consistency

系统分类：
─────────
┌───────────┬──────────────┬──────────────┐
│ 系统       │ P时选择      │ 正常时选择    │
├───────────┼──────────────┼──────────────┤
│ DynamoDB  │ A (可用)     │ L (低延迟)   │
│ Cassandra │ A            │ L            │
│ MongoDB   │ C (一致)     │ L            │
│ PNUTS     │ A            │ C (一致)     │
│ VoltDB    │ C            │ C            │
└───────────┴──────────────┴──────────────┘
```

---

## 四、分布式查询形式化

### 4.1 分布式连接策略

```text
定义4.1 (分布式连接)
────────────────────

设R在节点N_R，S在节点N_S，查询R ⋈ S

策略1: Ship-Whole
将R或S完整传输到对方节点
Cost = |R| 或 |S|

策略2: Semi-Join
1. N_R计算π_A(R)发送给N_S
2. N_S计算S' = S ⋉ π_A(R)发送给N_R
3. N_R计算R ⋈ S'
Cost = |π_A(R)| + |S'|
优势: |S'| ≤ |S|

策略3: Bloom-Join
1. N_R构建R上连接键的Bloom过滤器BF_R
2. 发送BF_R给N_S
3. N_S过滤: S' = {s ∈ S | BF_R.contains(s.A)}
4. 发送S'给N_R
Cost = |BF_R| + |S'| + 假阳性

选择规则：
─────────
Rule D1: Ship-Whole选择
If: min(|R|, |S|) < threshold
Then: Ship较小表

Rule D2: Semi-Join选择
If: 选择率低 (|S'| << |S|)
Then: 使用Semi-Join

Rule D3: Bloom-Join选择
If: 需要减少网络传输且可接受假阳性
Then: 使用Bloom-Join
```

### 4.2 分布式聚合

```text
定义4.2 (分布式聚合)
────────────────────

对于聚合函数AGG，设数据分布在节点N₁...Nₙ

可分解聚合(Decomposable):
AGG可分解 ⟺ ∃combine函数使得:
AGG(D) = combine(AGG(D₁), ..., AGG(Dₙ))

可分解聚合：
- SUM: combine = +
- COUNT: combine = +
- MIN: combine = min
- MAX: combine = max
- AVG: 使用(SUM, COUNT)组合

不可分解聚合：
- MEDIAN
- DISTINCT COUNT (近似)

两阶段执行：
Phase 1 (Local): 每个节点计算local_AGG
Phase 2 (Global): 协调者combine所有local结果

复杂度: O(分区数) 网络往返
```

---

## 五、复制协议形式化

### 5.1 主从复制

```text
定义5.1 (主从复制)
──────────────────

Primary (P) 处理所有写入
Secondaries (S₁...Sₙ) 复制Primary的日志

同步复制:
write(x, v):
  P.apply(x, v)
  ∀Sᵢ: send_and_wait(Sᵢ, log)
  return SUCCESS

异步复制:
write(x, v):
  P.apply(x, v)
  async: ∀Sᵢ: send(Sᵢ, log)
  return SUCCESS

权衡：
- 同步: 强一致，高延迟
- 异步: 最终一致，低延迟，可能丢失

定理5.1 (复制延迟界)
────────────────────

对于异步复制，副本延迟无界

证明：
网络延迟无上界
故副本可能任意落后
```

### 5.2 Raft一致性协议

```text
定义5.2 (Raft核心)
──────────────────

Raft通过选举Leader保证一致性

状态：
- Follower: 被动响应
- Candidate: 参与选举
- Leader: 处理所有请求

关键属性：
1. Election Safety: 每个任期最多一个Leader
2. Leader Append-Only: Leader只追加日志
3. Log Matching: 相同(term, index)的日志相同
4. Leader Completeness: 已提交日志出现在所有未来Leader

选举规则：
─────────
收到RequestVote(candidate, term, lastLogIndex, lastLogTerm):
if term > currentTerm then
  currentTerm := term
  votedFor := null
if votedFor = null ∧ candidate日志至少一样新 then
  grant vote

日志复制：
─────────
Leader:
  append entry to local log
  send AppendEntries to all followers
  when majority ack:
    commit entry
    apply to state machine

Follower:
  if log matches:
    append entries
    ack
  else:
    reject

定理5.2 (Raft安全性)
────────────────────

Raft保证所有已提交日志最终应用到所有节点

证明大纲：
1. Leader Completeness保证提交的日志在所有未来Leader中
2. Log Matching保证日志一致性传递
3. 故所有节点最终具有所有已提交日志
```

---

## 六、正确性证明

### 6.1 分布式事务正确性

```text
定理6.1 (2PC原子性)
───────────────────

2PC保证分布式事务原子性

证明：
设事务T涉及参与者P₁...Pₙ

Case 1: 所有Pᵢ投VOTE_YES
  Coordinator发送COMMIT
  所有Pᵢ收到COMMIT后提交
  ∀Pᵢ: committed(T)
  原子性满足

Case 2: 存在Pⱼ投VOTE_NO
  Coordinator发送ABORT
  所有Pᵢ收到ABORT后回滚
  ∀Pᵢ: aborted(T)
  原子性满足

Q.E.D.

定理6.2 (Saga最终一致性)
────────────────────────

Saga在正确补偿下保证最终一致性

证明：
设Saga S = (T₁...Tₙ, C₁...Cₙ)

Case 1: 所有Tᵢ成功
  结果状态 = Tₙ(...T₂(T₁(s₀))...)
  一致状态

Case 2: Tₖ失败
  执行补偿 C₁...Cₖ₋₁
  由Cᵢ(Tᵢ(s)) = s
  结果状态 = C₁(C₂(...Cₖ₋₁(Tₖ₋₁(...T₁(s₀))...)...))
            = s₀
  回到初始一致状态

Q.E.D.
```

### 6.2 一致性协议正确性

```text
定理6.3 (Raft一致性)
────────────────────

Raft保证线性一致性

证明大纲：
1. 每个客户端请求由Leader顺序处理
2. Leader按日志顺序应用到状态机
3. 所有节点应用相同的日志序列
4. 相同的状态机转换产生相同的结果
5. 客户端观察到的结果与某个全序一致

结合实时响应和确定性状态机，保证线性一致性
```

---

## 七、相关资源

### 内部链接

- [事务理论](../01-理论基础/01.05-事务理论.md)
- [并发控制形式化理论](./03.09-并发控制形式化理论.md)
- [执行引擎形式化理论](./03.08-执行引擎形式化理论.md)

### 外部资源

- Lynch, N. "Distributed Algorithms"
- Kleppmann, M. "Designing Data-Intensive Applications"
- Raft论文: "In Search of an Understandable Consensus Algorithm"
- CMU 15-721 Lecture Notes

---

**维护者**: SQL Standards Team
**创建日期**: 2025-12-01
**对标课程**: CMU 15-721, MIT 6.824
