# SQL类型系统形式化

> **创建日期**: 2025-12-04
> **标准**: SQL:2023
> **难度**: ⭐⭐⭐⭐⭐

---

## 类型系统总览

```text
SQL类型层次结构
══════════════════════════════════════════════════════════════════════════════

                        Type
                          │
          ┌───────────────┼───────────────┐
          │               │               │
      Predefined      Constructed      User-Defined
          │               │               │
    ┌─────┴─────┐    ┌────┴────┐    ┌────┴────┐
    │           │    │         │    │         │
Numeric   Character  ROW    ARRAY  DISTINCT  STRUCTURED
    │           │
┌───┴───┐   ┌───┴───┐
│       │   │       │
INT  DECIMAL CHAR VARCHAR
```

---

## 形式化定义

### 定义1.1 类型域

```text
定义1.1 类型域（Type Domain）
═══════════════════════════════════════════════════════════════

类型 τ 定义为五元组:
  τ = (D, =, <, ops, constraints)

其中:
• D: 值域（Domain of values）
• =: 相等关系
• <: 全序关系（如果存在）
• ops: 操作集合 {op_1, op_2, ...}
• constraints: 约束集合

示例（INTEGER类型）:
  D = ℤ ∩ [-2^31, 2^31-1]
  = : 标准整数相等
  < : 标准整数小于
  ops = {+, -, *, /, MOD, ...}
  constraints = {NOT NULL, CHECK(...), ...}
```

### 定义1.2 类型兼容性

```text
定义1.2 类型兼容性（Type Compatibility）
═══════════════════════════════════════════════════════════════

τ_1 兼容于 τ_2 (τ_1 ⊆ τ_2) 当且仅当:
  1. D_1 ⊆ D_2 (值域包含)
  2. ∀ v ∈ D_1, cast(v, τ_2)保持语义

示例:
  SMALLINT ⊆ INTEGER ⊆ BIGINT
  CHAR(n) ⊆ CHAR(m) 当 n ≤ m
  INTEGER ⊄ VARCHAR (需要显式转换)
```

---

## 数值类型形式化

### 定理1.1 整数运算封闭性

```text
定理1.1：整数类型在有限域上运算可能溢出
═══════════════════════════════════════════════════════════════

给定 INTEGER 类型，定义域 D = [-2^31, 2^31-1]

对于加法运算 + : D × D → D
  ∃ a, b ∈ D, a + b ∉ D

证明（反例）:
  设 a = 2^31 - 1 (最大值)
  设 b = 1

  数学上: a + b = 2^31
  但: 2^31 ∉ D

  实际行为（数据库相关）:
  • PostgreSQL: 抛出异常 (integer out of range)
  • MySQL: 静默截断或返回NULL（取决于sql_mode）
  • SQLite: 自动提升为REAL类型

∴ 整数运算在有限域不封闭 ∎
```

### 定理1.2 浮点数精度丢失

```text
定理1.2：浮点数运算不满足结合律
═══════════════════════════════════════════════════════════════

给定 FLOAT 类型（IEEE 754单精度）

定理: (a + b) + c ≠ a + (b + c) 对某些a, b, c

证明（实际SQL）:

SELECT
    (0.1 + 0.2) + 0.3 as left_assoc,
    0.1 + (0.2 + 0.3) as right_assoc,
    ((0.1 + 0.2) + 0.3) = (0.1 + (0.2 + 0.3)) as equal;

-- PostgreSQL结果:
--  left_assoc | right_assoc | equal
-- ------------+-------------+-------
--  0.6000000000000001 | 0.6 | f

分析:
  • 0.1, 0.2无法精确表示为二进制浮点数
  • (0.1 + 0.2) ≈ 0.30000000000000004
  • 舍入误差累积不同

教训:
  • 不要用 = 比较浮点数
  • 使用 ABS(a - b) < ε
  • 金融计算使用 DECIMAL

∴ 浮点运算不满足结合律 ∎
```

### DECIMAL类型形式化

```text
定义1.3 DECIMAL类型
═══════════════════════════════════════════════════════════════

DECIMAL(p, s) 定义：
  • p: 精度（总位数）, 1 ≤ p ≤ 38
  • s: 小数位数, 0 ≤ s ≤ p

值域:
  D = {n / 10^s | n ∈ ℤ, |n| < 10^(p-s)}

示例 DECIMAL(5, 2):
  D = {n / 100 | n ∈ ℤ, |n| < 1000}
  有效值: -999.99, ..., 0, ..., 999.99

定理1.3：DECIMAL运算精度保持
  对于 a, b ∈ DECIMAL(p, s)
  a + b ∈ DECIMAL(p+1, s)
  a * b ∈ DECIMAL(2p, 2s)

  证明：
    最大值相加: (10^p - 1) + (10^p - 1) = 2*10^p - 2 < 10^(p+1)
    最大值相乘: (10^p - 1)^2 < 10^(2p)

  实现：数据库自动扩展精度或四舍五入
```

---

## 字符类型形式化

### 定义2.1 字符串类型

```text
定义2.1 字符串类型
═══════════════════════════════════════════════════════════════

CHAR(n) 定义:
  D = {s ∈ Σ* | |s| = n}
  其中 Σ 是字符集（如UTF-8）

VARCHAR(n) 定义:
  D = {s ∈ Σ* | |s| ≤ n}

差异:
  • CHAR(n): 固定长度，空格填充
  • VARCHAR(n): 可变长度，不填充

存储:
  CHAR(n): n * sizeof(char)
  VARCHAR(n): length(s) + 1 (长度前缀)
```

### 定理2.1 字符串比较规则

```text
定理2.1：字符串比较依赖校对规则（Collation）
═══════════════════════════════════════════════════════════════

给定校对规则 C: Σ* × Σ* → {-1, 0, 1}

定理: 不同校对规则下，比较结果可能不同

示例（PostgreSQL）:

SELECT 'a' < 'A' as case_sensitive_en,
       'a' < 'A' COLLATE "en_US" as case_insensitive_en;

--  case_sensitive_en | case_insensitive_en
-- -------------------+---------------------
--  f                 | f

SELECT 'ä' < 'z' as german_dict,
       'ä' < 'z' COLLATE "de_DE" as german_phone;

--  german_dict | german_phone
-- -------------+--------------
--  t           | f  (ä排在z后，德语电话簿排序)

校对规则定义:
  • Accent Sensitivity: é ≠ e
  • Case Sensitivity: A ≠ a
  • Kana Sensitivity: カ ≠ か (片假名 vs 平假名)

∎
```

---

## 时间类型形式化

### 定义3.1 时间类型

```text
定义3.1 时间类型
═══════════════════════════════════════════════════════════════

DATE:
  D = {(y, m, d) | y ∈ [0001, 9999], m ∈ [1, 12], d ∈ [1, days_in_month(y, m)]}

TIME:
  D = {(h, m, s, f) | h ∈ [0, 23], m ∈ [0, 59], s ∈ [0, 59], f ∈ [0, 10^p)}
  其中 f: 小数秒, p: 精度

TIMESTAMP:
  D = DATE × TIME

TIMESTAMP WITH TIME ZONE:
  D = TIMESTAMP × TZ
  其中 TZ = {-12:00, ..., +14:00} (时区偏移)
```

### 定理3.1 时区转换一致性

```text
定理3.1：时区转换保持时刻不变
═══════════════════════════════════════════════════════════════

给定 TIMESTAMP WITH TIME ZONE 类型

转换函数:
  to_tz(t, tz_from, tz_to) = t + (tz_to - tz_from)

性质：时刻不变
  ∀ t ∈ TIMESTAMP, ∀ tz_1, tz_2 ∈ TZ,
    unix_epoch(t, tz_1) = unix_epoch(to_tz(t, tz_1, tz_2), tz_2)

证明（示例）:
  t = '2025-12-04 10:00:00 +08:00' (北京时间)

  转换为UTC:
    t' = '2025-12-04 02:00:00 +00:00'

  Unix时间戳:
    epoch(t) = 1733270400
    epoch(t') = 1733270400

  ∴ 相等 ∎

反例（TIMESTAMP WITHOUT TIME ZONE）:
  t1 = '2025-12-04 10:00:00' (假设本地时间=+08:00)
  t2 = '2025-12-04 10:00:00' (假设本地时间=+00:00)

  看起来相同，但:
    epoch(t1) = 1733270400
    epoch(t2) = 1733299200 (相差8小时！)

  ∴ TIMESTAMP WITHOUT TIME ZONE 不安全
```

---

## NULL值语义

### 定义4.1 三值逻辑

```text
定义4.1 三值逻辑（Three-Valued Logic）
═══════════════════════════════════════════════════════════════

真值域: {TRUE, FALSE, UNKNOWN}

逻辑运算:

AND:
  TRUE AND TRUE = TRUE
  TRUE AND FALSE = FALSE
  TRUE AND UNKNOWN = UNKNOWN
  FALSE AND UNKNOWN = FALSE
  UNKNOWN AND UNKNOWN = UNKNOWN

OR:
  TRUE OR TRUE = TRUE
  TRUE OR FALSE = TRUE
  TRUE OR UNKNOWN = TRUE
  FALSE OR UNKNOWN = UNKNOWN
  UNKNOWN OR UNKNOWN = UNKNOWN

NOT:
  NOT TRUE = FALSE
  NOT FALSE = TRUE
  NOT UNKNOWN = UNKNOWN

真值表:
  AND  | T   F   U      OR   | T   F   U      NOT |
  -----+----------      -----+----------      ----+---
  T    | T   F   U      T    | T   T   T      T   | F
  F    | F   F   F      F    | T   F   U      F   | T
  U    | U   F   U      U    | T   U   U      U   | U
```

### 定理4.1 NULL比较规则

```text
定理4.1：NULL不等于任何值（包括自身）
═══════════════════════════════════════════════════════════════

定理: ∀ v, NULL = v → UNKNOWN (包括v = NULL)

证明（实际SQL）:

SELECT
    NULL = NULL as eq_null,
    NULL <> NULL as neq_null,
    NULL > 5 as gt_5,
    NULL IS NULL as is_null;

--  eq_null | neq_null | gt_5 | is_null
-- ---------+----------+------+---------
--  NULL    | NULL     | NULL | t

分析:
  • NULL = NULL → UNKNOWN (不是TRUE)
  • WHERE NULL = NULL 不返回行（UNKNOWN过滤掉）
  • 只有 IS NULL 返回TRUE

常见陷阱:

-- ❌ 错误
SELECT * FROM users WHERE age != 30;
-- 不返回age=NULL的行！

-- ✅ 正确
SELECT * FROM users WHERE age != 30 OR age IS NULL;

∎
```

---

## 类型转换形式化

### 定义5.1 隐式转换

```text
定义5.1 隐式类型转换（Implicit Cast）
═══════════════════════════════════════════════════════════════

隐式转换关系 ⇝: Type → Type

规则:
  1. 数值类型: SMALLINT ⇝ INTEGER ⇝ BIGINT ⇝ DECIMAL ⇝ FLOAT
  2. 字符类型: CHAR(n) ⇝ VARCHAR(m) (n ≤ m)
  3. 时间类型: DATE ⇝ TIMESTAMP

传递性:
  If τ_1 ⇝ τ_2 and τ_2 ⇝ τ_3, then τ_1 ⇝ τ_3

示例（PostgreSQL）:

SELECT 1 + 2.5;  -- INTEGER ⇝ DECIMAL, 结果: 3.5

SELECT '2025-12-04' + INTERVAL '1 day';  -- TEXT ⇝ DATE, 结果: 2025-12-05
```

### 定理5.1 隐式转换可能导致精度丢失

```text
定理5.1：隐式转换可能导致精度丢失
═══════════════════════════════════════════════════════════════

反例:

SELECT
    9999999999999999::BIGINT as orig,
    9999999999999999::BIGINT::FLOAT as converted;

--      orig       |    converted
-- ----------------+------------------
--  9999999999999999 | 1.0e+16  (精度丢失！)

分析:
  • FLOAT（IEEE 754单精度）只有23位尾数
  • 无法精确表示16位十进制整数
  • 转换后丢失精度

教训:
  • 避免 BIGINT → FLOAT
  • 使用 DECIMAL 保持精度
  • 显式转换提醒开发者

∎
```

---

## 数组类型（SQL:2023）

### 定义6.1 数组类型

```text
定义6.1 数组类型
═══════════════════════════════════════════════════════════════

ARRAY[τ] 定义:
  D = {[v_1, v_2, ..., v_n] | v_i ∈ τ.D, n ≥ 0}

操作:
  • 索引访问: arr[i] (1-based)
  • 切片: arr[i:j]
  • 连接: arr1 || arr2
  • 长度: array_length(arr, 1)

示例（PostgreSQL）:

CREATE TABLE posts (
    id INTEGER PRIMARY KEY,
    title TEXT,
    tags TEXT[]  -- 数组类型
);

INSERT INTO posts VALUES (1, 'SQL Tutorial', ARRAY['sql', 'database']);

SELECT * FROM posts WHERE 'sql' = ANY(tags);

-- 数组操作
SELECT
    tags[1] as first_tag,
    array_length(tags, 1) as tag_count,
    tags || ARRAY['tutorial'] as new_tags
FROM posts;
```

---

**文档版本**: v1.0.0
**最后更新**: 2025-12-04
