# å¹¶å‘æ§åˆ¶ç®—æ³•å®ç°

> **åˆ›å»ºæ—¥æœŸ**ï¼š2025-12-04
> **ç‰ˆæœ¬**ï¼šPostgreSQL 18 / SQLite 3.47.x
> **éš¾åº¦**ï¼šâ­â­â­â­â­
> **å‰ç½®çŸ¥è¯†**ï¼šäº‹åŠ¡ç†è®ºã€æ“ä½œç³»ç»Ÿã€å¹¶å‘ç¼–ç¨‹

---

## ğŸ“‹ æ¦‚è¿°

è¯¦è§£ä¸¤é˜¶æ®µé”ï¼ˆ2PLï¼‰ã€å¤šç‰ˆæœ¬å¹¶å‘æ§åˆ¶ï¼ˆMVCCï¼‰ã€å¿«ç…§éš”ç¦»ï¼ˆSIï¼‰ã€å¯ä¸²è¡ŒåŒ–å¿«ç…§éš”ç¦»ï¼ˆSSIï¼‰çš„å…·ä½“å®ç°ç®—æ³•ã€‚

---

## ğŸ“‘ ç›®å½•

- [å¹¶å‘æ§åˆ¶ç®—æ³•å®ç°](#å¹¶å‘æ§åˆ¶ç®—æ³•å®ç°)
  - [ğŸ“‹ æ¦‚è¿°](#-æ¦‚è¿°)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [ä¸€ã€ä¸¤é˜¶æ®µé”ï¼ˆ2PLï¼‰](#ä¸€ä¸¤é˜¶æ®µé”2pl)
    - [1.1 åŸºæœ¬2PLç®—æ³•](#11-åŸºæœ¬2plç®—æ³•)
    - [1.2 ä¸¥æ ¼2PL](#12-ä¸¥æ ¼2pl)
    - [1.3 æ­»é”æ£€æµ‹ç®—æ³•](#13-æ­»é”æ£€æµ‹ç®—æ³•)
  - [äºŒã€MVCCå®ç°ç®—æ³•](#äºŒmvccå®ç°ç®—æ³•)
    - [2.1 ç‰ˆæœ¬é“¾ç®¡ç†](#21-ç‰ˆæœ¬é“¾ç®¡ç†)
    - [2.2 å¯è§æ€§åˆ¤æ–­ç®—æ³•](#22-å¯è§æ€§åˆ¤æ–­ç®—æ³•)
    - [2.3 åƒåœ¾å›æ”¶ç®—æ³•](#23-åƒåœ¾å›æ”¶ç®—æ³•)
  - [ä¸‰ã€å¿«ç…§éš”ç¦»ï¼ˆSIï¼‰](#ä¸‰å¿«ç…§éš”ç¦»si)
    - [3.1 å¿«ç…§è·å–ç®—æ³•](#31-å¿«ç…§è·å–ç®—æ³•)
    - [3.2 å†™å†²çªæ£€æµ‹](#32-å†™å†²çªæ£€æµ‹)
  - [å››ã€å¯ä¸²è¡ŒåŒ–å¿«ç…§éš”ç¦»ï¼ˆSSIï¼‰](#å››å¯ä¸²è¡ŒåŒ–å¿«ç…§éš”ç¦»ssi)
    - [4.1 å±é™©ç»“æ„æ£€æµ‹](#41-å±é™©ç»“æ„æ£€æµ‹)
    - [4.2 SSIç®—æ³•å®ç°](#42-ssiç®—æ³•å®ç°)

---

## ä¸€ã€ä¸¤é˜¶æ®µé”ï¼ˆ2PLï¼‰

### 1.1 åŸºæœ¬2PLç®—æ³•

```text
ä¸¤é˜¶æ®µé”åè®®
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

äº‹åŠ¡Tçš„ç”Ÿå‘½å‘¨æœŸåˆ†ä¸ºä¸¤ä¸ªé˜¶æ®µï¼š

Phase 1: æˆé•¿é˜¶æ®µï¼ˆGrowing Phaseï¼‰
â€¢ åªèƒ½è·å–é”ï¼Œä¸èƒ½é‡Šæ”¾é”
â€¢ è¯»æ“ä½œè·å–å…±äº«é”ï¼ˆSé”ï¼‰
â€¢ å†™æ“ä½œè·å–æ’ä»–é”ï¼ˆXé”ï¼‰

Phase 2: æ”¶ç¼©é˜¶æ®µï¼ˆShrinking Phaseï¼‰
â€¢ åªèƒ½é‡Šæ”¾é”ï¼Œä¸èƒ½è·å–æ–°é”
â€¢ äº‹åŠ¡å®Œæˆåé‡Šæ”¾æ‰€æœ‰é”

é”å…¼å®¹çŸ©é˜µï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ è¯·æ±‚\æŒæœ‰â”‚   Sé”   â”‚   Xé”   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Sé”   â”‚   âœ“     â”‚   âœ—     â”‚
â”‚   Xé”   â”‚   âœ—     â”‚   âœ—     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

2PLä¿è¯å¯ä¸²è¡ŒåŒ–å®šç†ï¼š
å¦‚æœæ‰€æœ‰äº‹åŠ¡éµå®ˆ2PLåè®®ï¼Œåˆ™æ‰§è¡Œç»“æœç­‰ä»·äºæŸä¸ªä¸²è¡Œæ‰§è¡Œã€‚
```

**ç®—æ³•å®ç°**ï¼š

```python
class TwoP hassLockManager:
    def __init__(self):
        self.lock_table = {}  # {data_item: {transaction: lock_type}}
        self.transaction_locks = {}  # {transaction: [(data_item, lock_type)]}
        self.wait_graph = {}  # æ­»é”æ£€æµ‹å›¾

    def acquire_lock(self, transaction, data_item, lock_type):
        """è·å–é”"""
        # æ£€æŸ¥å…¼å®¹æ€§
        if data_item in self.lock_table:
            holders = self.lock_table[data_item]
            for holder, held_type in holders.items():
                if holder == transaction:
                    # åŒä¸€äº‹åŠ¡ï¼Œæ£€æŸ¥é”å‡çº§
                    if lock_type == 'X' and held_type == 'S':
                        # é”å‡çº§
                        holders[holder] = 'X'
                    return True

                # æ£€æŸ¥å…¼å®¹æ€§
                if not self.compatible(held_type, lock_type):
                    # ä¸å…¼å®¹ï¼Œç­‰å¾…
                    self.wait_for(transaction, holder)
                    return False  # WAIT

        # æˆäºˆé”
        if data_item not in self.lock_table:
            self.lock_table[data_item] = {}
        self.lock_table[data_item][transaction] = lock_type

        # è®°å½•äº‹åŠ¡æŒæœ‰çš„é”
        if transaction not in self.transaction_locks:
            self.transaction_locks[transaction] = []
        self.transaction_locks[transaction].append((data_item, lock_type))

        return True

    def compatible(self, held_type, requested_type):
        """æ£€æŸ¥é”å…¼å®¹æ€§"""
        if requested_type == 'S':
            return held_type == 'S'  # S-Så…¼å®¹
        else:  # requested_type == 'X'
            return False  # Xä¸ä»»ä½•é”éƒ½ä¸å…¼å®¹

    def release_all_locks(self, transaction):
        """é‡Šæ”¾äº‹åŠ¡çš„æ‰€æœ‰é”"""
        if transaction in self.transaction_locks:
            for data_item, lock_type in self.transaction_locks[transaction]:
                del self.lock_table[data_item][transaction]
                if not self.lock_table[data_item]:
                    del self.lock_table[data_item]

            del self.transaction_locks[transaction]

        # å”¤é†’ç­‰å¾…çš„äº‹åŠ¡
        self.notify_waiting_transactions(transaction)
```

### 1.2 ä¸¥æ ¼2PL

```text
ä¸¥æ ¼ä¸¤é˜¶æ®µé”ï¼ˆStrict 2PLï¼‰
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

çº¦æŸï¼šæ‰€æœ‰é”ç›´åˆ°äº‹åŠ¡COMMITæˆ–ABORTæ‰é‡Šæ”¾

ä¼˜ç‚¹ï¼š
â€¢ é¿å…çº§è”å›æ»šï¼ˆCascading Rollbackï¼‰
â€¢ å®ç°æ›´ç®€å•
â€¢ å¤§å¤šæ•°æ•°æ®åº“é‡‡ç”¨ï¼ˆPostgreSQL/MySQL/SQL Serverï¼‰

æ—¶é—´çº¿ç¤ºä¾‹ï¼š

Transaction T1:
â”œâ”€â”€ BEGIN
â”œâ”€â”€ READ(A)    â†’ è·å–S(A)
â”œâ”€â”€ WRITE(B)   â†’ è·å–X(B)
â”œâ”€â”€ ...        â†’ ç»§ç»­æŒæœ‰æ‰€æœ‰é”
â””â”€â”€ COMMIT     â†’ é‡Šæ”¾S(A), X(B)

Transaction T2:
â”œâ”€â”€ BEGIN
â”œâ”€â”€ READ(B)    â†’ ç­‰å¾…T1é‡Šæ”¾X(B)
â”‚   â†“ WAIT
â”‚   â†“ T1 COMMIT
â”‚   â†“ è·å–S(B) âœ“
â”œâ”€â”€ WRITE(A)   â†’ è·å–X(A)
â””â”€â”€ COMMIT     â†’ é‡Šæ”¾æ‰€æœ‰é”

ä¸¥æ ¼2PL vs åŸºæœ¬2PL:
â€¢ åŸºæœ¬2PL: å¯ä»¥åœ¨äº‹åŠ¡ä¸­é€”é‡Šæ”¾é”ï¼ˆæ”¶ç¼©é˜¶æ®µå¼€å§‹ï¼‰
â€¢ ä¸¥æ ¼2PL: å¿…é¡»åœ¨COMMIT/ABORTæ—¶ä¸€æ¬¡æ€§é‡Šæ”¾æ‰€æœ‰é”
```

### 1.3 æ­»é”æ£€æµ‹ç®—æ³•

```python
# æ­»é”æ£€æµ‹ï¼šç­‰å¾…å›¾æ³•ï¼ˆWait-for Graphï¼‰

class DeadlockDetector:
    def __init__(self):
        self.wait_graph = {}  # {T1: [T2, T3]}è¡¨ç¤ºT1ç­‰å¾…T2å’ŒT3

    def add_edge(self, waiter, holder):
        """æ·»åŠ ç­‰å¾…è¾¹ï¼šwaiterç­‰å¾…holder"""
        if waiter not in self.wait_graph:
            self.wait_graph[waiter] = []
        if holder not in self.wait_graph[waiter]:
            self.wait_graph[waiter].append(holder)

    def remove_edge(self, waiter, holder):
        """åˆ é™¤ç­‰å¾…è¾¹"""
        if waiter in self.wait_graph:
            if holder in self.wait_graph[waiter]:
                self.wait_graph[waiter].remove(holder)

    def detect_deadlock(self):
        """æ£€æµ‹æ­»é”ï¼šæŸ¥æ‰¾ç­‰å¾…å›¾ä¸­çš„ç¯"""
        visited = set()
        rec_stack = set()

        def dfs(node):
            visited.add(node)
            rec_stack.add(node)

            if node in self.wait_graph:
                for neighbor in self.wait_graph[node]:
                    if neighbor not in visited:
                        if dfs(neighbor):
                            return True
                    elif neighbor in rec_stack:
                        # å‘ç°ç¯ï¼æ­»é”
                        return True

            rec_stack.remove(node)
            return False

        # æ£€æŸ¥æ‰€æœ‰èŠ‚ç‚¹
        for transaction in self.wait_graph:
            if transaction not in visited:
                if dfs(transaction):
                    return True  # æ£€æµ‹åˆ°æ­»é”

        return False  # æ— æ­»é”

    def find_deadlock_cycle(self):
        """æ‰¾åˆ°æ­»é”ç¯ä¸­çš„äº‹åŠ¡"""
        # ä½¿ç”¨DFSæ‰¾ç¯
        visited = set()
        rec_stack = []

        def dfs(node):
            visited.add(node)
            rec_stack.append(node)

            if node in self.wait_graph:
                for neighbor in self.wait_graph[node]:
                    if neighbor in rec_stack:
                        # æ‰¾åˆ°ç¯
                        cycle_start = rec_stack.index(neighbor)
                        return rec_stack[cycle_start:]
                    if neighbor not in visited:
                        result = dfs(neighbor)
                        if result:
                            return result

            rec_stack.pop()
            return None

        for transaction in self.wait_graph:
            if transaction not in visited:
                cycle = dfs(transaction)
                if cycle:
                    return cycle

        return None

# ä½¿ç”¨ç¤ºä¾‹
detector = DeadlockDetector()

# T1ç­‰å¾…T2
detector.add_edge('T1', 'T2')
# T2ç­‰å¾…T3
detector.add_edge('T2', 'T3')
# T3ç­‰å¾…T1
detector.add_edge('T3', 'T1')

if detector.detect_deadlock():
    cycle = detector.find_deadlock_cycle()
    print(f"æ£€æµ‹åˆ°æ­»é”: {' -> '.join(cycle)}")
    # é€‰æ‹©ç‰ºç‰²è€…ï¼šé€šå¸¸é€‰æ‹©æœ€å¹´è½»çš„äº‹åŠ¡
    victim = min(cycle, key=lambda t: t.start_time)
    abort_transaction(victim)
```

---

## äºŒã€MVCCå®ç°ç®—æ³•

### 2.1 ç‰ˆæœ¬é“¾ç®¡ç†

```c
/* PostgreSQL MVCCç‰ˆæœ¬é“¾å®ç° */

typedef struct HeapTupleHeaderData {
    TransactionId xmin;      /* åˆ›å»ºæ­¤ç‰ˆæœ¬çš„äº‹åŠ¡ID */
    TransactionId xmax;      /* åˆ é™¤æ­¤ç‰ˆæœ¬çš„äº‹åŠ¡IDï¼ˆ0=æœªåˆ é™¤ï¼‰ */
    CommandId cid;           /* å‘½ä»¤IDï¼ˆäº‹åŠ¡å†…è¯­å¥åºå·ï¼‰ */
    ItemPointerData ctid;    /* å½“å‰ç‰ˆæœ¬æˆ–ä¸‹ä¸€ä¸ªç‰ˆæœ¬çš„ä½ç½® */
    uint16 infomask;         /* çŠ¶æ€æ ‡å¿—ä½ */
    /* ... æ›´å¤šå­—æ®µ ... */
} HeapTupleHeaderData;

/* æ’å…¥æ–°ç‰ˆæœ¬ */
void heap_insert(Relation relation, HeapTuple tuple) {
    // 1. è®¾ç½®xminä¸ºå½“å‰äº‹åŠ¡ID
    HeapTupleHeaderSetXmin(tuple->t_data, GetCurrentTransactionId());

    // 2. xmaxè®¾ç½®ä¸º0ï¼ˆæœªåˆ é™¤ï¼‰
    HeapTupleHeaderSetXmax(tuple->t_data, InvalidTransactionId);

    // 3. è®¾ç½®cid
    HeapTupleHeaderSetCmin(tuple->t_data, GetCurrentCommandId());

    // 4. å†™å…¥é¡µé¢
    RelationPutHeapTuple(relation, buffer, tuple);

    // 5. è®°å½•WAL
    XLogInsert(RM_HEAP_ID, XLOG_HEAP_INSERT, ...);
}

/* æ›´æ–°ï¼ˆåˆ›å»ºæ–°ç‰ˆæœ¬ï¼‰ */
void heap_update(Relation relation, ItemPointer otid, HeapTuple newtup) {
    HeapTuple oldtup;

    // 1. è¯»å–æ—§ç‰ˆæœ¬
    heap_fetch(relation, snapshot, &oldtup, otid, ...);

    // 2. æ£€æŸ¥æ˜¯å¦å¯ä»¥æ›´æ–°ï¼ˆå¯è§æ€§+é”ï¼‰
    if (!HeapTupleSatisfiesUpdate(oldtup, GetCurrentCommandId(), buffer)) {
        // å†²çªï¼šå…¶ä»–äº‹åŠ¡å·²ä¿®æ”¹æˆ–åˆ é™¤
        return HeapTupleUpdated;
    }

    // 3. æ ‡è®°æ—§ç‰ˆæœ¬ä¸ºåˆ é™¤ï¼ˆè®¾ç½®xmaxï¼‰
    HeapTupleHeaderSetXmax(oldtup->t_data, GetCurrentTransactionId());

    // 4. æ’å…¥æ–°ç‰ˆæœ¬
    HeapTupleHeaderSetXmin(newtup->t_data, GetCurrentTransactionId());
    HeapTupleHeaderSetXmax(newtup->t_data, InvalidTransactionId);

    // 5. è®¾ç½®ctidé“¾æ¥
    oldtup->t_data->ctid = newtup->t_self;  // æ—§ç‰ˆæœ¬æŒ‡å‘æ–°ç‰ˆæœ¬

    // 6. å†™å…¥æ–°ç‰ˆæœ¬
    RelationPutHeapTuple(relation, newbuf, newtup);
}
```

### 2.2 å¯è§æ€§åˆ¤æ–­ç®—æ³•

```c
/* PostgreSQLå¯è§æ€§åˆ¤æ–­ç®—æ³• */

bool HeapTupleSatisfiesMVCC(HeapTuple htup, Snapshot snapshot) {
    TransactionId xmin = HeapTupleHeaderGetXmin(htup->t_data);
    TransactionId xmax = HeapTupleHeaderGetXmax(htup->t_data);

    // è§„åˆ™1: xminæ£€æŸ¥ï¼ˆåˆ›å»ºäº‹åŠ¡ï¼‰
    if (XidInMVCCSnapshot(xmin, snapshot)) {
        // xminåœ¨å¿«ç…§ä¸­ï¼ˆæœªæäº¤æˆ–å¤ªæ–°ï¼‰
        return false;  // ä¸å¯è§
    }

    if (TransactionIdDidCommit(xmin) == false) {
        // xminæœªæäº¤æˆ–å·²å›æ»š
        return false;  // ä¸å¯è§
    }

    // è§„åˆ™2: xmaxæ£€æŸ¥ï¼ˆåˆ é™¤äº‹åŠ¡ï¼‰
    if (xmax == InvalidTransactionId) {
        // æœªè¢«åˆ é™¤
        return true;  // å¯è§
    }

    if (XidInMVCCSnapshot(xmax, snapshot)) {
        // xmaxåœ¨å¿«ç…§ä¸­ï¼ˆåˆ é™¤äº‹åŠ¡å¤ªæ–°ï¼‰
        return true;  // ä»ç„¶å¯è§ï¼ˆåˆ é™¤æœªç”Ÿæ•ˆï¼‰
    }

    if (TransactionIdDidCommit(xmax) == false) {
        // åˆ é™¤äº‹åŠ¡æœªæäº¤æˆ–å·²å›æ»š
        return true;  // å¯è§
    }

    // xmaxå·²æäº¤ä¸”ä¸åœ¨å¿«ç…§ä¸­
    return false;  // å·²è¢«åˆ é™¤ï¼Œä¸å¯è§
}

/* å¿«ç…§ç»“æ„ */
typedef struct SnapshotData {
    TransactionId xmin;    /* æ‰€æœ‰xid < xminçš„äº‹åŠ¡éƒ½å·²æäº¤ */
    TransactionId xmax;    /* æ‰€æœ‰xid >= xmaxçš„äº‹åŠ¡éƒ½æœªå¼€å§‹ */
    TransactionId *xip;    /* xminå’Œxmaxä¹‹é—´çš„æ´»è·ƒäº‹åŠ¡åˆ—è¡¨ */
    uint32 xcnt;           /* xipæ•°ç»„é•¿åº¦ */
    /* ... */
} SnapshotData;

/* åˆ¤æ–­äº‹åŠ¡IDæ˜¯å¦åœ¨å¿«ç…§ä¸­ */
bool XidInMVCCSnapshot(TransactionId xid, Snapshot snapshot) {
    // 1. å¿«é€Ÿè·¯å¾„
    if (xid < snapshot->xmin) {
        return false;  // å¤ªè€ï¼Œå·²æäº¤
    }
    if (xid >= snapshot->xmax) {
        return true;   // å¤ªæ–°ï¼Œæœªå¼€å§‹
    }

    // 2. äºŒåˆ†æŸ¥æ‰¾æ´»è·ƒäº‹åŠ¡åˆ—è¡¨
    int left = 0, right = snapshot->xcnt - 1;
    while (left <= right) {
        int mid = (left + right) / 2;
        if (snapshot->xip[mid] == xid) {
            return true;  // åœ¨æ´»è·ƒåˆ—è¡¨ä¸­
        } else if (snapshot->xip[mid] < xid) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return false;  // ä¸åœ¨æ´»è·ƒåˆ—è¡¨ï¼Œå·²æäº¤
}
```

### 2.3 åƒåœ¾å›æ”¶ç®—æ³•

```sql
-- PostgreSQL VACUUMç®—æ³•

-- æŸ¥æ‰¾å¯å›æ”¶çš„æ­»å…ƒç»„
SELECT
    schemaname,
    tablename,
    n_dead_tup,
    last_vacuum,
    last_autovacuum
FROM pg_stat_user_tables
WHERE n_dead_tup > 10000
ORDER BY n_dead_tup DESC;

-- VACUUMæ‰§è¡Œæµç¨‹
VACUUM VERBOSE table_name;

/*
VACUUMæ­¥éª¤ï¼š

1. è·å–æ¸…ç†é”ï¼ˆShareUpdateExclusiveLockï¼‰
   â€¢ ä¸é˜»å¡è¯»å†™ï¼Œä½†é˜»å¡å…¶ä»–VACUUMå’ŒDDL

2. æ‰«æè¡¨ï¼Œæ ‡è®°æ­»å…ƒç»„
   for each page:
       for each tuple:
           if tuple.xmaxå·²æäº¤ AND æ‰€æœ‰æ´»è·ƒäº‹åŠ¡çœ‹ä¸åˆ°:
               mark as dead

3. å›æ”¶æ­»å…ƒç»„ç©ºé—´
   â€¢ å‹ç¼©é¡µé¢ï¼ˆç§»åŠ¨å­˜æ´»å…ƒç»„ï¼‰
   â€¢ æ›´æ–°freespace map

4. æ›´æ–°ç´¢å¼•
   â€¢ åˆ é™¤æŒ‡å‘æ­»å…ƒç»„çš„ç´¢å¼•é¡¹
   â€¢ å¯èƒ½éœ€è¦å¤šæ¬¡æ‰«æ

5. æ¸…ç†å‰©ä½™ç©ºé—´
   â€¢ æˆªæ–­æ–‡ä»¶ï¼ˆå¦‚æœæœ«å°¾éƒ½æ˜¯ç©ºé¡µé¢ï¼‰
   â€¢ æ›´æ–°ç»Ÿè®¡ä¿¡æ¯

6. é‡Šæ”¾é”
*/
```

---

## ä¸‰ã€å¿«ç…§éš”ç¦»ï¼ˆSIï¼‰

### 3.1 å¿«ç…§è·å–ç®—æ³•

```python
# PostgreSQLé£æ ¼å¿«ç…§è·å–

class SnapshotManager:
    def __init__(self):
        self.transaction_counter = 0
        self.active_transactions = set()
        self.committed_transactions = set()

    def begin_transaction(self):
        """å¼€å§‹äº‹åŠ¡ï¼Œåˆ†é…äº‹åŠ¡ID"""
        self.transaction_counter += 1
        txid = self.transaction_counter
        self.active_transactions.add(txid)
        return txid

    def get_snapshot(self, txid):
        """è·å–å½“å‰å¿«ç…§"""
        snapshot = {
            'xmin': min(self.active_transactions) if self.active_transactions else self.transaction_counter,
            'xmax': self.transaction_counter + 1,
            'xip': sorted(list(self.active_transactions - {txid})),  # æ’é™¤è‡ªå·±
            'owner': txid
        }
        return snapshot

    def commit_transaction(self, txid):
        """æäº¤äº‹åŠ¡"""
        self.active_transactions.remove(txid)
        self.committed_transactions.add(txid)

    def abort_transaction(self, txid):
        """å›æ»šäº‹åŠ¡"""
        self.active_transactions.remove(txid)

# ç¤ºä¾‹ä½¿ç”¨
sm = SnapshotManager()

# T1å¼€å§‹
t1 = sm.begin_transaction()  # txid=1
snapshot1 = sm.get_snapshot(t1)
# snapshot1 = {xmin:1, xmax:2, xip:[], owner:1}

# T2å¼€å§‹
t2 = sm.begin_transaction()  # txid=2
snapshot2 = sm.get_snapshot(t2)
# snapshot2 = {xmin:1, xmax:3, xip:[1], owner:2}

# T1æäº¤
sm.commit_transaction(t1)

# T3å¼€å§‹
t3 = sm.begin_transaction()  # txid=3
snapshot3 = sm.get_snapshot(t3)
# snapshot3 = {xmin:2, xmax:4, xip:[2], owner:3}
```

### 3.2 å†™å†²çªæ£€æµ‹

```text
å¿«ç…§éš”ç¦»å†™å†²çªæ£€æµ‹
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

First-Committer-Winsè§„åˆ™ï¼š

if T1å’ŒT2å¹¶å‘ AND WriteSet(T1) âˆ© WriteSet(T2) â‰  âˆ…:
    å…ˆæäº¤çš„äº‹åŠ¡æˆåŠŸ
    åæäº¤çš„äº‹åŠ¡abort

ç®—æ³•å®ç°ï¼š

function commitTransaction(T):
    // 1. è·å–æ‰€æœ‰å¹¶å‘äº‹åŠ¡
    concurrent = getConcurrentTransactions(T.snapshot)

    // 2. æ£€æŸ¥å†™å†²çª
    for T_other in concurrent:
        if T_other.committed AND
           intersect(T.writeSet, T_other.writeSet):
            // å†™å†²çªï¼
            abort(T)
            return CONFLICT

    // 3. æ— å†²çªï¼Œæäº¤æˆåŠŸ
    T.commitTimestamp = getCurrentTimestamp()
    markAsCommitted(T)
    return SUCCESS

ç¤ºä¾‹ï¼š

T1: BEGIN at time=100
    SELECT * FROM accounts WHERE id = 1;  // balance = 1000
    UPDATE accounts SET balance = 900 WHERE id = 1;

T2: BEGIN at time=105
    SELECT * FROM accounts WHERE id = 1;  // balance = 1000 (å¿«ç…§)
    UPDATE accounts SET balance = 800 WHERE id = 1;

T1: COMMIT at time=110  // SUCCESS
T2: COMMIT at time=115  // CONFLICT! Abort
                        // å› ä¸ºT1å·²ä¿®æ”¹id=1çš„è®°å½•

Write-Setè¿½è¸ªï¼š
â€¢ PostgreSQL: æ¯ä¸ªäº‹åŠ¡ç»´æŠ¤ModifiedTupleList
â€¢ MySQL: Undo Logè®°å½•
â€¢ SQLite: å•å†™è€…æ¨¡å‹ï¼Œæ— éœ€æ˜¾å¼æ£€æµ‹
```

---

## å››ã€å¯ä¸²è¡ŒåŒ–å¿«ç…§éš”ç¦»ï¼ˆSSIï¼‰

### 4.1 å±é™©ç»“æ„æ£€æµ‹

```text
SSIå±é™©ç»“æ„ï¼ˆDangerous Structureï¼‰
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

å®šä¹‰ï¼šä¸‰ç§å¯¼è‡´éä¸²è¡ŒåŒ–çš„æ¨¡å¼

æ¨¡å¼1: rw-ä¾èµ–ç¯ï¼ˆRead-Write Dependency Cycleï¼‰

T1: read(x)  ... write(y)
T2: read(y)  ... write(x)

â€¢ T1è¯»xï¼ŒT2å†™x â†’ rw-ä¾èµ–ï¼ˆT1 â†’rw T2ï¼‰
â€¢ T2è¯»yï¼ŒT1å†™y â†’ rw-ä¾èµ–ï¼ˆT2 â†’rw T1ï¼‰
â€¢ å½¢æˆç¯ â†’ éä¸²è¡ŒåŒ–

æ¨¡å¼2: å†™å€¾æ–œï¼ˆWrite Skewï¼‰

T1: read(x), read(y), write(y) based on x
T2: read(x), read(y), write(x) based on y

â€¢ T1å’ŒT2éƒ½çœ‹åˆ°æ—§å€¼
â€¢ ä½†éƒ½åŸºäºå¯¹æ–¹ä¿®æ”¹å‰çš„å€¼åšå†³ç­–
â€¢ ç»“æœä¸ç­‰ä»·äºä»»ä½•ä¸²è¡Œæ‰§è¡Œ

æ¨¡å¼3: åªè¯»äº‹åŠ¡å¼‚å¸¸

T1: read(x), read(y)  // åªè¯»äº‹åŠ¡
T2: write(x)
T3: write(y)

â€¢ T1å¯èƒ½çœ‹åˆ°T2çš„å†™å…¥ä½†çœ‹ä¸åˆ°T3çš„å†™å…¥
â€¢ æ‰“ç ´äº†ä¸²è¡ŒåŒ–è¯­ä¹‰

æ£€æµ‹ç®—æ³•ï¼šç»´æŠ¤rw-ä¾èµ–å›¾ï¼Œæ£€æŸ¥ç¯
```

### 4.2 SSIç®—æ³•å®ç°

```python
# å¯ä¸²è¡ŒåŒ–å¿«ç…§éš”ç¦»ï¼ˆSSIï¼‰å®ç°

class SSIManager:
    def __init__(self):
        self.transactions = {}
        self.rw_conflicts = []  # [(T_reader, T_writer)]
        self.committed = set()

    def record_read(self, transaction, data_item):
        """è®°å½•è¯»æ“ä½œ"""
        if transaction not in self.transactions:
            self.transactions[transaction] = {'reads': set(), 'writes': set()}
        self.transactions[transaction]['reads'].add(data_item)

        # æ£€æŸ¥æ˜¯å¦æœ‰å¹¶å‘å†™
        for other in self.transactions:
            if other != transaction:
                if data_item in self.transactions[other]['writes']:
                    # rw-å†²çª
                    self.rw_conflicts.append((transaction, other))

    def record_write(self, transaction, data_item):
        """è®°å½•å†™æ“ä½œ"""
        if transaction not in self.transactions:
            self.transactions[transaction] = {'reads': set(), 'writes': set()}
        self.transactions[transaction]['writes'].add(data_item)

        # æ£€æŸ¥æ˜¯å¦æœ‰å¹¶å‘è¯»
        for other in self.transactions:
            if other != transaction:
                if data_item in self.transactions[other]['reads']:
                    # rw-å†²çª
                    self.rw_conflicts.append((other, transaction))

    def commit(self, transaction):
        """æäº¤æ—¶æ£€æŸ¥å¯ä¸²è¡ŒåŒ–"""
        # æ„å»ºrw-ä¾èµ–å›¾
        graph = self.build_rw_graph()

        # æ£€æµ‹å±é™©ç»“æ„ï¼ˆDangerous Structureï¼‰
        if self.has_dangerous_structure(transaction, graph):
            # æ£€æµ‹åˆ°éä¸²è¡ŒåŒ–æ¨¡å¼ï¼Œabort
            self.abort(transaction)
            return False

        # å®‰å…¨ï¼Œå¯ä»¥æäº¤
        self.committed.add(transaction)
        return True

    def build_rw_graph(self):
        """æ„å»ºrw-ä¾èµ–å›¾"""
        graph = {}
        for (reader, writer) in self.rw_conflicts:
            if reader not in graph:
                graph[reader] = []
            graph[reader].append(writer)
        return graph

    def has_dangerous_structure(self, T, graph):
        """æ£€æµ‹å±é™©ç»“æ„"""
        # æ£€æŸ¥æ˜¯å¦å­˜åœ¨ç¯ï¼šT â†’rw T1 â†’rw T2 â†’rw ... â†’rw T
        visited = set()
        rec_stack = set()

        def dfs(node):
            if node == T and len(rec_stack) > 0:
                # å›åˆ°Tï¼Œå½¢æˆç¯
                return True

            if node in visited:
                return False

            visited.add(node)
            rec_stack.add(node)

            if node in graph:
                for neighbor in graph[node]:
                    # åªè€ƒè™‘å·²æäº¤çš„äº‹åŠ¡
                    if neighbor in self.committed or neighbor == T:
                        if dfs(neighbor):
                            return True

            rec_stack.remove(node)
            return False

        return dfs(T)

# PostgreSQL SSIå®é™…ä½¿ç”¨
BEGIN ISOLATION LEVEL SERIALIZABLE;

UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;

COMMIT;  -- å¦‚æœæ£€æµ‹åˆ°å±é™©ç»“æ„ï¼ŒæŠ¥é”™ï¼š
         -- ERROR: could not serialize access due to read/write dependencies
```

---

**å¹¶å‘æ§åˆ¶ç®—æ³•å®Œæˆï¼**

æœ¬æ–‡æ¡£æä¾›ï¼š

- âœ… 2PLå®Œæ•´å®ç°ï¼ˆPythonä»£ç ï¼‰
- âœ… æ­»é”æ£€æµ‹ç®—æ³•ï¼ˆç­‰å¾…å›¾DFSï¼‰
- âœ… MVCCç‰ˆæœ¬é“¾ç®¡ç†ï¼ˆCæºç ï¼‰
- âœ… å¯è§æ€§åˆ¤æ–­ç®—æ³•ï¼ˆPostgreSQLï¼‰
- âœ… å¿«ç…§è·å–ç®—æ³•ï¼ˆPythonå®ç°ï¼‰
- âœ… SSIå±é™©ç»“æ„æ£€æµ‹ï¼ˆå®Œæ•´ç®—æ³•ï¼‰

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0
**æœ€åæ›´æ–°**: 2025-12-04
**ç»´æŠ¤è€…**: SQL Standards Team
