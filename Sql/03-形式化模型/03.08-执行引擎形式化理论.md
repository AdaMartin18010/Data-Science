# æ‰§è¡Œå¼•æ“å½¢å¼åŒ–ç†è®º

> **åˆ›å»ºæ—¥æœŸ**ï¼š2025-12-01
> **æœ€åæ›´æ–°**ï¼š2025-12-01
> **ç‰ˆæœ¬**ï¼šv1.0.0
> **å½¢å¼åŒ–å±‚æ¬¡**ï¼šL4-å¯éªŒè¯
> **å¯¹æ ‡è¯¾ç¨‹**ï¼šCMU 15-445, MIT 6.830, Berkeley CS186
> **ç›®çš„**ï¼šå»ºç«‹æŸ¥è¯¢æ‰§è¡Œå¼•æ“çš„å®Œæ•´å½¢å¼åŒ–ç†è®ºä½“ç³»

---

## ğŸ“‹ ç›®å½•

- [æ‰§è¡Œå¼•æ“å½¢å¼åŒ–ç†è®º](#æ‰§è¡Œå¼•æ“å½¢å¼åŒ–ç†è®º)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ä¸€ã€æ¦‚è¿°](#ä¸€æ¦‚è¿°)
    - [1.1 æ‰§è¡Œå¼•æ“çŸ¥è¯†ä½“ç³»](#11-æ‰§è¡Œå¼•æ“çŸ¥è¯†ä½“ç³»)
    - [1.2 å› æœé“¾](#12-å› æœé“¾)
  - [äºŒã€æ‰§è¡Œæ¨¡å‹å½¢å¼åŒ–](#äºŒæ‰§è¡Œæ¨¡å‹å½¢å¼åŒ–)
    - [2.1 ç«å±±æ¨¡å‹ (Volcano/Iterator Model)](#21-ç«å±±æ¨¡å‹-volcanoiterator-model)
    - [2.2 å‘é‡åŒ–æ‰§è¡Œæ¨¡å‹](#22-å‘é‡åŒ–æ‰§è¡Œæ¨¡å‹)
    - [2.3 ç¼–è¯‘æ‰§è¡Œæ¨¡å‹](#23-ç¼–è¯‘æ‰§è¡Œæ¨¡å‹)
  - [ä¸‰ã€ç®—å­ä»£æ•°å½¢å¼åŒ–](#ä¸‰ç®—å­ä»£æ•°å½¢å¼åŒ–)
    - [3.1 ç®—å­ç±»å‹ç³»ç»Ÿ](#31-ç®—å­ç±»å‹ç³»ç»Ÿ)
    - [3.2 ç®—å­ä»£æ•°æ€§è´¨](#32-ç®—å­ä»£æ•°æ€§è´¨)
    - [3.3 ç‰©ç†ç®—å­å®ç°](#33-ç‰©ç†ç®—å­å®ç°)
  - [å››ã€å†…å­˜ç®¡ç†å½¢å¼åŒ–](#å››å†…å­˜ç®¡ç†å½¢å¼åŒ–)
    - [4.1 ç¼“å†²æ± ç®¡ç†](#41-ç¼“å†²æ± ç®¡ç†)
    - [4.2 æ›¿æ¢ç­–ç•¥å½¢å¼åŒ–](#42-æ›¿æ¢ç­–ç•¥å½¢å¼åŒ–)
    - [4.3 æº¢å‡ºå¤„ç†](#43-æº¢å‡ºå¤„ç†)
  - [äº”ã€æ‰§è¡Œä¼˜åŒ–å½¢å¼åŒ–](#äº”æ‰§è¡Œä¼˜åŒ–å½¢å¼åŒ–)
    - [5.1 ç®¡é“æ‰§è¡Œ](#51-ç®¡é“æ‰§è¡Œ)
    - [5.2 å¹¶è¡Œæ‰§è¡Œ](#52-å¹¶è¡Œæ‰§è¡Œ)
    - [5.3 å‘é‡åŒ–ä¼˜åŒ–](#53-å‘é‡åŒ–ä¼˜åŒ–)
  - [å…­ã€æ­£ç¡®æ€§è¯æ˜](#å…­æ­£ç¡®æ€§è¯æ˜)
    - [6.1 è¯­ä¹‰ä¿æŒè¯æ˜](#61-è¯­ä¹‰ä¿æŒè¯æ˜)
    - [6.2 ä¼˜åŒ–æ­£ç¡®æ€§è¯æ˜](#62-ä¼˜åŒ–æ­£ç¡®æ€§è¯æ˜)
    - [6.3 å¹¶å‘æ­£ç¡®æ€§](#63-å¹¶å‘æ­£ç¡®æ€§)
  - [ä¸ƒã€ç›¸å…³èµ„æº](#ä¸ƒç›¸å…³èµ„æº)
    - [å†…éƒ¨é“¾æ¥](#å†…éƒ¨é“¾æ¥)
    - [å¤–éƒ¨èµ„æº](#å¤–éƒ¨èµ„æº)

---

## ä¸€ã€æ¦‚è¿°

### 1.1 æ‰§è¡Œå¼•æ“çŸ¥è¯†ä½“ç³»

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       æ‰§è¡Œå¼•æ“å½¢å¼åŒ–çŸ¥è¯†ä½“ç³»                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                          æ‰§è¡Œå¼•æ“
                              â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚         â”‚           â”‚           â”‚         â”‚
        â–¼         â–¼           â–¼           â–¼         â–¼
    æ‰§è¡Œæ¨¡å‹   ç®—å­ä½“ç³»    å†…å­˜ç®¡ç†    å¹¶è¡Œæ‰§è¡Œ   æ­£ç¡®æ€§
        â”‚         â”‚           â”‚           â”‚         â”‚
    â”Œâ”€â”€â”€â”´â”€â”€â”€â” â”Œâ”€â”€â”€â”´â”€â”€â”€â”  â”Œâ”€â”€â”€â”´â”€â”€â”€â”  â”Œâ”€â”€â”€â”´â”€â”€â”€â”       â”‚
    â”‚       â”‚ â”‚       â”‚  â”‚       â”‚  â”‚       â”‚       â”‚
    â–¼       â–¼ â–¼       â–¼  â–¼       â–¼  â–¼       â–¼       â–¼
  ç«å±±   å‘é‡åŒ–  ç‰©ç†  é€»è¾‘  ç¼“å†²   æº¢å‡º  ç®¡é“  åˆ†åŒº  è¯­ä¹‰
  æ¨¡å‹    æ‰§è¡Œ   ç®—å­  ç®—å­  ç®¡ç†   å¤„ç†  å¹¶è¡Œ  å¹¶è¡Œ  ä¿æŒ
```

### 1.2 å› æœé“¾

```text
SQLæŸ¥è¯¢ â”€â”€[è§£æ]â”€â”€â†’ AST â”€â”€[åˆ†æ]â”€â”€â†’ é€»è¾‘è®¡åˆ’
                                      â”‚
                           â”€â”€[ä¼˜åŒ–]â”€â”€â”€â”˜
                                      â”‚
                                      â–¼
                               ç‰©ç†è®¡åˆ’ â”€â”€[å®ä¾‹åŒ–]â”€â”€â†’ ç®—å­æ ‘
                                                       â”‚
                                            â”€â”€[æ‰§è¡Œ]â”€â”€â”€â”˜
                                                       â”‚
                                                       â–¼
                                                   ç»“æœé›†
```

---

## äºŒã€æ‰§è¡Œæ¨¡å‹å½¢å¼åŒ–

### 2.1 ç«å±±æ¨¡å‹ (Volcano/Iterator Model)

```text
å®šä¹‰2.1 (è¿­ä»£å™¨æ¥å£)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ç®—å­Oçš„è¿­ä»£å™¨æ¥å£å®šä¹‰ä¸ºä¸‰å…ƒç»„ï¼š
O = (open, next, close)

å…¶ä¸­ï¼š
- open: () â†’ State       åˆå§‹åŒ–ç®—å­çŠ¶æ€
- next: State â†’ (Tuple | EOF, State)   è¿”å›ä¸‹ä¸€ä¸ªå…ƒç»„
- close: State â†’ ()      æ¸…ç†èµ„æº

å½¢å¼åŒ–è¯­ä¹‰ï¼š
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
è®¾Sä¸ºç®—å­çŠ¶æ€ç©ºé—´ï¼ŒTä¸ºå…ƒç»„ç©ºé—´

open: () â†’ S
åˆå§‹æ¡ä»¶ï¼šæ— 
åç½®æ¡ä»¶ï¼šsâ‚€ âˆˆ S æ˜¯æœ‰æ•ˆåˆå§‹çŠ¶æ€

next: S â†’ (T âˆª {EOF}) Ã— S
å‰ç½®æ¡ä»¶ï¼šs âˆˆ S æ˜¯æœ‰æ•ˆçŠ¶æ€
åç½®æ¡ä»¶ï¼š
  è‹¥å­˜åœ¨æœªè¿”å›å…ƒç»„tï¼Œåˆ™è¿”å›(t, s')
  è‹¥æ‰€æœ‰å…ƒç»„å·²è¿”å›ï¼Œåˆ™è¿”å›(EOF, s_final)

close: S â†’ ()
å‰ç½®æ¡ä»¶ï¼šs âˆˆ S
åç½®æ¡ä»¶ï¼šé‡Šæ”¾så ç”¨çš„æ‰€æœ‰èµ„æº
```

**ç«å±±æ¨¡å‹ç®—å­å®šä¹‰**ï¼š

```text
ç®—å­2.1.1 (TableScan)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
TableScan(R) = (open_R, next_R, close_R)

open_R():
  cursor := R.first()
  return State(cursor)

next_R(s):
  if s.cursor = R.end() then
    return (EOF, s)
  else
    t := *s.cursor
    s.cursor := s.cursor + 1
    return (t, s)

close_R(s):
  release(s.cursor)

å¤æ‚åº¦ï¼šO(n) å…¶ä¸­n = |R|

ç®—å­2.1.2 (Filter)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Filter(child, predicate p) = (open_F, next_F, close_F)

open_F():
  child.open()
  return State(child)

next_F(s):
  loop:
    (t, s') := s.child.next()
    if t = EOF then return (EOF, s')
    if p(t) then return (t, s')
  end loop

close_F(s):
  s.child.close()

å¤æ‚åº¦ï¼šO(n) å…¶ä¸­n = |childè¾“å‡º|

ç®—å­2.1.3 (HashJoin)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
HashJoin(build, probe, join_key) = (open_HJ, next_HJ, close_HJ)

open_HJ():
  build.open()
  H := new HashTable()
  // æ„å»ºé˜¶æ®µ
  loop:
    (t, _) := build.next()
    if t = EOF then break
    H.insert(t[join_key], t)
  end loop
  build.close()
  probe.open()
  return State(H, probe, empty_buffer)

next_HJ(s):
  // æ£€æŸ¥ç¼“å†²åŒº
  if not s.buffer.empty() then
    return (s.buffer.pop(), s)

  // æ¢æµ‹é˜¶æ®µ
  loop:
    (t_probe, s') := s.probe.next()
    if t_probe = EOF then return (EOF, s')
    matches := s.H.lookup(t_probe[join_key])
    for m in matches:
      s.buffer.push(concat(t_probe, m))
    if not s.buffer.empty() then
      return (s.buffer.pop(), s)
  end loop

close_HJ(s):
  s.probe.close()
  s.H.clear()

å¤æ‚åº¦ï¼š
  æ„å»º: O(|build|)
  æ¢æµ‹: O(|probe| Ã— åŒ¹é…æ•°)
  æ€»ä½“: O(|build| + |probe|) å¹³å‡æƒ…å†µ
```

### 2.2 å‘é‡åŒ–æ‰§è¡Œæ¨¡å‹

```text
å®šä¹‰2.2 (å‘é‡åŒ–è¿­ä»£å™¨)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

å‘é‡åŒ–ç®—å­Oçš„æ¥å£å®šä¹‰ä¸ºï¼š
O_vec = (open, next_batch, close)

å…¶ä¸­ï¼š
- next_batch: State â†’ (Vector<Tuple> | EOF, State)

æ‰¹æ¬¡å¤§å°ï¼šBï¼ˆé€šå¸¸1024-4096ï¼‰

å½¢å¼åŒ–å®šä¹‰ï¼š
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
next_batch(s):
  batch := []
  for i in 1..B:
    (t, s') := underlying_next(s)
    if t = EOF then
      if batch.empty() then return (EOF, s')
      else return (batch, s')
    batch.append(t)
  return (batch, s')

ä¼˜åŠ¿åˆ†æï¼š
â”€â”€â”€â”€â”€â”€â”€â”€â”€
è®¾nä¸ºå…ƒç»„æ•°ï¼ŒBä¸ºæ‰¹æ¬¡å¤§å°

ç«å±±æ¨¡å‹å‡½æ•°è°ƒç”¨æ•°: n
å‘é‡åŒ–æ¨¡å‹å‡½æ•°è°ƒç”¨æ•°: âŒˆn/BâŒ‰

å‡å°‘å€æ•°: B

è¯æ˜ï¼šå‘é‡åŒ–æ‰§è¡Œå¯¹CPUå‹å¥½
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
è®¾C_callä¸ºå‡½æ•°è°ƒç”¨å¼€é”€ï¼ŒC_processä¸ºå¤„ç†å¼€é”€

ç«å±±æ¨¡å‹æ€»å¼€é”€: n Ã— (C_call + C_process)
å‘é‡åŒ–æ€»å¼€é”€: âŒˆn/BâŒ‰ Ã— C_call + n Ã— C_process

èŠ‚çœ: n Ã— C_call - âŒˆn/BâŒ‰ Ã— C_call â‰ˆ n Ã— C_call Ã— (1 - 1/B)

å½“B=1024æ—¶ï¼ŒèŠ‚çœçº¦99.9%çš„å‡½æ•°è°ƒç”¨å¼€é”€
```

### 2.3 ç¼–è¯‘æ‰§è¡Œæ¨¡å‹

```text
å®šä¹‰2.3 (æŸ¥è¯¢ç¼–è¯‘)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

æŸ¥è¯¢ç¼–è¯‘æ˜¯ä»é€»è¾‘è®¡åˆ’åˆ°æœºå™¨ä»£ç çš„è½¬æ¢ï¼š
Compile: Plan â†’ MachineCode

å½¢å¼åŒ–å®šä¹‰ï¼š
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ç»™å®šæŸ¥è¯¢è®¡åˆ’Pï¼Œç¼–è¯‘ç”Ÿæˆä»£ç Cï¼Œæ»¡è¶³ï¼š
âˆ€ DB: Execute(C, DB) â‰¡ Interpret(P, DB)

å³ç¼–è¯‘æ‰§è¡Œä¸è§£é‡Šæ‰§è¡Œè¯­ä¹‰ç­‰ä»·

ä»£ç ç”Ÿæˆè§„åˆ™ï¼š
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Rule C1 (Scanç”Ÿæˆ):
Compile(Scan(R)) =
  "for each tuple t in R:
     emit(t)"

Rule C2 (Filterç”Ÿæˆ):
Compile(Filter(child, p)) =
  Compile(child) with emit(t) replaced by
  "if p(t): emit(t)"

Rule C3 (HashJoinç”Ÿæˆ):
Compile(HashJoin(build, probe, key)) =
  "H := new HashTable()
   for each t in build:
     H.insert(t[key], t)
   for each t in probe:
     for m in H.lookup(t[key]):
       emit(concat(t, m))"
```

---

## ä¸‰ã€ç®—å­ä»£æ•°å½¢å¼åŒ–

### 3.1 ç®—å­ç±»å‹ç³»ç»Ÿ

```text
å®šä¹‰3.1 (ç®—å­ç±»å‹)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ç®—å­ç±»å‹ç­¾åï¼š
Op : Schema* â†’ Schema

å¸¸è§ç®—å­ç±»å‹ï¼š
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
TableScan : () â†’ Schema(R)
Filter(p) : Schema â†’ Schema
Project(A) : Schema â†’ Schema[A]
Join(Î¸) : Schema Ã— Schema â†’ Schema âˆª Schema
Union : Schema Ã— Schema â†’ Schema (è¦æ±‚ç›¸åŒ)
Aggregate(G, agg) : Schema â†’ Schema(G, agg_result)
Sort(A) : Schema â†’ Schema
Limit(n) : Schema â†’ Schema

ç±»å‹è§„åˆ™ï¼š
â”€â”€â”€â”€â”€â”€â”€â”€â”€
Rule T-Scan:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Scan(R) : Schema(R)

Rule T-Filter:
Î“ âŠ¢ e : S    Î“ âŠ¢ p : S â†’ Bool
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Filter(e, p) : S

Rule T-Join:
Î“ âŠ¢ eâ‚ : Sâ‚    Î“ âŠ¢ eâ‚‚ : Sâ‚‚
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Join(eâ‚, eâ‚‚, Î¸) : Sâ‚ âŠ Sâ‚‚

Rule T-Project:
Î“ âŠ¢ e : S    A âŠ† attrs(S)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Project(e, A) : S[A]
```

### 3.2 ç®—å­ä»£æ•°æ€§è´¨

```text
å®šç†3.1 (ç®—å­å°é—­æ€§)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

å¯¹ä»»æ„ç®—å­Opå’Œæœ‰æ•ˆè¾“å…¥ï¼Œè¾“å‡ºä»æ˜¯æœ‰æ•ˆå…³ç³»

è¯æ˜ï¼š
å¯¹æ¯ä¸ªç®—å­å½’çº³è¯æ˜è¾“å‡ºæ»¡è¶³å…³ç³»å®šä¹‰ï¼ˆå…ƒç»„é›†åˆï¼‰

å®šç†3.2 (ç®—å­å¯ç»„åˆæ€§)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

è‹¥Opâ‚: Sâ‚ â†’ Sâ‚‚ ä¸” Opâ‚‚: Sâ‚‚ â†’ Sâ‚ƒ
åˆ™ Opâ‚‚ âˆ˜ Opâ‚: Sâ‚ â†’ Sâ‚ƒ

è¯æ˜ï¼š
ç”±ç±»å‹ç³»ç»Ÿè§„åˆ™ç›´æ¥å¾—åˆ°

å®šç†3.3 (è¯­ä¹‰ç­‰ä»·å˜æ¢)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ä»¥ä¸‹å˜æ¢ä¿æŒè¯­ä¹‰ç­‰ä»·ï¼š

1. Filterä¸‹æ¨:
   Filter(Join(A, B), p_A) â‰¡ Join(Filter(A, p_A), B)
   æ¡ä»¶: attrs(p_A) âŠ† attrs(A)

2. æŠ•å½±ä¸‹æ¨:
   Project(Join(A, B), X) â‰¡ Project(Join(Project(A, X_A), Project(B, X_B)), X)
   æ¡ä»¶: X_A, X_BåŒ…å«è¿æ¥å±æ€§

3. è¿æ¥äº¤æ¢:
   Join(A, B) â‰¡ Join(B, A)

4. è¿æ¥ç»“åˆ:
   Join(Join(A, B), C) â‰¡ Join(A, Join(B, C))
```

### 3.3 ç‰©ç†ç®—å­å®ç°

```text
è¡¨3.1 ç‰©ç†ç®—å­å¯¹æ¯”çŸ©é˜µ
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ç‰©ç†ç®—å­       â”‚ æ—¶é—´å¤æ‚åº¦    â”‚ ç©ºé—´å¤æ‚åº¦    â”‚ é€‚ç”¨åœºæ™¯          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ SeqScan       â”‚ O(n)         â”‚ O(1)         â”‚ å…¨è¡¨æ‰«æ          â”‚
â”‚ IndexScan     â”‚ O(log n + k) â”‚ O(1)         â”‚ é€‰æ‹©ç‡<10%        â”‚
â”‚ BitmapScan    â”‚ O(n)         â”‚ O(n/8)       â”‚ å¤šæ¡ä»¶OR          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ NestedLoop    â”‚ O(n Ã— m)     â”‚ O(1)         â”‚ å°å¤–è¡¨+ç´¢å¼•       â”‚
â”‚ HashJoin      â”‚ O(n + m)     â”‚ O(min(n,m))  â”‚ ç­‰å€¼è¿æ¥          â”‚
â”‚ MergeJoin     â”‚ O(n + m)     â”‚ O(1)         â”‚ å·²æ’åºè¾“å…¥        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ HashAggregate â”‚ O(n)         â”‚ O(groups)    â”‚ æ— åºèšåˆ          â”‚
â”‚ GroupAggregateâ”‚ O(n log n)   â”‚ O(1)         â”‚ å·²æ’åº/éœ€æ’åº     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ QuickSort     â”‚ O(n log n)   â”‚ O(n)         â”‚ å†…å­˜æ’åº          â”‚
â”‚ ExternalSort  â”‚ O(n log n)   â”‚ O(M)         â”‚ å¤–éƒ¨æ’åº          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

å…¶ä¸­: n, m = è¾“å…¥å¤§å°, k = è¿”å›è¡Œæ•°, M = å†…å­˜å¤§å°
```

---

## å››ã€å†…å­˜ç®¡ç†å½¢å¼åŒ–

### 4.1 ç¼“å†²æ± ç®¡ç†

```text
å®šä¹‰4.1 (ç¼“å†²æ± )
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ç¼“å†²æ± Bæ˜¯ä»é¡µé¢IDåˆ°å†…å­˜å¸§çš„æ˜ å°„ï¼š
B : PageID â†’ Frame âˆª {âŠ¥}

ç¼“å†²æ± çŠ¶æ€ï¼š
S_B = (frames, page_table, dirty_flags, pin_counts)

æ“ä½œè¯­ä¹‰ï¼š
â”€â”€â”€â”€â”€â”€â”€â”€â”€

FetchPage(pid):
å‰ç½®: pidæ˜¯æœ‰æ•ˆé¡µé¢ID
åç½®:
  if page_table[pid] â‰  âŠ¥ then
    pin_counts[pid]++
    return frames[page_table[pid]]
  else
    frame := evict_and_load(pid)
    page_table[pid] := frame
    pin_counts[pid] := 1
    return frames[frame]

UnpinPage(pid, dirty):
å‰ç½®: pin_counts[pid] > 0
åç½®:
  pin_counts[pid]--
  if dirty then dirty_flags[pid] := true

FlushPage(pid):
å‰ç½®: page_table[pid] â‰  âŠ¥
åç½®:
  if dirty_flags[pid] then
    disk.write(pid, frames[page_table[pid]])
    dirty_flags[pid] := false
```

### 4.2 æ›¿æ¢ç­–ç•¥å½¢å¼åŒ–

```text
å®šä¹‰4.2 (LRUæ›¿æ¢)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

LRUç­–ç•¥é€‰æ‹©æœ€è¿‘æœ€å°‘ä½¿ç”¨çš„é¡µé¢é©±é€

å½¢å¼åŒ–å®šä¹‰ï¼š
è®¾access_time(p)ä¸ºé¡µé¢pçš„æœ€åè®¿é—®æ—¶é—´
evict() := argmin{access_time(p) | pin_counts[p] = 0}

å®šç†4.1 (LRUç«äº‰æ¯”)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
å¯¹äºå¤§å°ä¸ºkçš„ç¼“å†²æ± ï¼ŒLRUçš„ç«äº‰æ¯”ä¸ºk

è¯æ˜ï¼š
è®¾OPTä¸ºæœ€ä¼˜ç¦»çº¿ç®—æ³•
å¯¹ä»»æ„è®¿é—®åºåˆ—Ïƒï¼Œ
  faults_LRU(Ïƒ) â‰¤ k Ã— faults_OPT(Ïƒ)

å®šä¹‰4.3 (Clockæ›¿æ¢)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Clockæ˜¯LRUçš„è¿‘ä¼¼ï¼Œä½¿ç”¨å¼•ç”¨ä½

clock_evict():
  loop:
    page := clock_hand.current()
    if ref_bit[page] = 0 and pin_counts[page] = 0 then
      return page
    ref_bit[page] := 0
    clock_hand.advance()
```

### 4.3 æº¢å‡ºå¤„ç†

```text
å®šä¹‰4.4 (å¤–éƒ¨æ’åº)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

å½“æ•°æ®è¶…å‡ºå†…å­˜æ—¶ä½¿ç”¨å¤–éƒ¨æ’åº

ç®—æ³•ï¼šä¸¤é˜¶æ®µå½’å¹¶æ’åº

Phase 1 (æ’åºé˜¶æ®µ):
  å°†è¾“å…¥åˆ†æˆå¤§å°ä¸ºMçš„å—
  å¯¹æ¯ä¸ªå—è¿›è¡Œå†…å­˜æ’åº
  å†™å…¥ä¸´æ—¶æ–‡ä»¶ä½œä¸ºrun

Phase 2 (å½’å¹¶é˜¶æ®µ):
  ä½¿ç”¨B-1ä¸ªè¾“å…¥ç¼“å†²ï¼Œ1ä¸ªè¾“å‡ºç¼“å†²
  è¿›è¡ŒB-1è·¯å½’å¹¶

å¤æ‚åº¦åˆ†æï¼š
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
è®¾Nä¸ºæ€»æ•°æ®é‡ï¼ŒMä¸ºå†…å­˜å¤§å°ï¼ŒBä¸ºç¼“å†²é¡µæ•°

Runæ•°é‡: âŒˆN/MâŒ‰
å½’å¹¶è¶Ÿæ•°: âŒˆlog_{B-1}(âŒˆN/MâŒ‰)âŒ‰
I/Oæ¬¡æ•°: 2N Ã— (1 + å½’å¹¶è¶Ÿæ•°)

å®šç†4.2 (å¤–éƒ¨æ’åºI/Oä¸‹ç•Œ)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
å¤–éƒ¨æ’åºçš„I/Oå¤æ‚åº¦ä¸‹ç•Œä¸ºÎ©(N/B Ã— log_{M/B}(N/B))
```

---

## äº”ã€æ‰§è¡Œä¼˜åŒ–å½¢å¼åŒ–

### 5.1 ç®¡é“æ‰§è¡Œ

```text
å®šä¹‰5.1 (ç®¡é“)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ç®¡é“æ˜¯ä¸€ç»„å¯ä»¥æµå¼æ‰§è¡Œçš„ç®—å­åºåˆ—

ç®¡é“æ¡ä»¶ï¼š
ç®—å­Opæ˜¯ç®¡é“å®‰å…¨çš„ âŸº Opä¸éœ€è¦ç‰©åŒ–å…¨éƒ¨è¾“å…¥

ç®¡é“é˜»æ–­ç‚¹ï¼ˆPipeline Breakerï¼‰ï¼š
- Sortï¼ˆéœ€è¦å…¨éƒ¨è¾“å…¥ï¼‰
- HashJoinçš„æ„å»ºç«¯
- Aggregateï¼ˆæŸäº›èšåˆå‡½æ•°ï¼‰

ç®¡é“ä¼˜åŒ–ç›®æ ‡ï¼š
æœ€å°åŒ–ç‰©åŒ–æ¬¡æ•°ï¼Œæœ€å¤§åŒ–ç®¡é“é•¿åº¦

å®šç†5.1 (ç®¡é“æ­£ç¡®æ€§)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ç®¡é“æ‰§è¡Œä¸ç‰©åŒ–æ‰§è¡Œè¯­ä¹‰ç­‰ä»·

è¯æ˜ï¼š
è®¾Pä¸ºç®¡é“ï¼ŒMä¸ºç‰©åŒ–æ‰§è¡Œ
âˆ€ input I: P(I) = M(I)
ç”±ç®—å­è¯­ä¹‰çš„ç¡®å®šæ€§å¾—è¯
```

### 5.2 å¹¶è¡Œæ‰§è¡Œ

```text
å®šä¹‰5.2 (æ•°æ®å¹¶è¡Œ)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

æ•°æ®å¹¶è¡Œå°†æ•°æ®åˆ†åŒºåå¹¶è¡Œå¤„ç†

åˆ†åŒºç­–ç•¥ï¼š
- Hashåˆ†åŒº: partition(t) = hash(t[key]) mod P
- Rangeåˆ†åŒº: partition(t) = range_index(t[key])
- Round-robin: partition(t) = (i++) mod P

å¹¶è¡Œç®—å­ï¼š
Parallel_Op(input, P) =
  Union(Op(partition_1), ..., Op(partition_P))

å®šç†5.2 (å¹¶è¡Œæ­£ç¡®æ€§)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
å¯¹å¯åˆ†åŒºç®—å­Op:
Parallel_Op(input, P) â‰¡ Op(input)

æ¡ä»¶ï¼šOpæ˜¯åˆ†åŒºæ— å…³çš„ï¼ˆpartition-agnosticï¼‰

å¯åˆ†åŒºç®—å­ï¼šScan, Filter, Project
éœ€è¦é‡åˆ†åŒºï¼šJoin, Aggregate

Exchangeç®—å­ï¼š
Exchange(input, target_partitioning) =
  repartition input according to target_partitioning
```

### 5.3 å‘é‡åŒ–ä¼˜åŒ–

```text
å®šä¹‰5.3 (SIMDå‘é‡åŒ–)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

SIMDå¯¹å¤šä¸ªæ•°æ®åŒæ—¶æ‰§è¡Œç›¸åŒæ“ä½œ

å‘é‡åŒ–Filter:
vectorized_filter(batch, predicate):
  mask := evaluate_predicate_simd(batch, predicate)
  return compact(batch, mask)

å‘é‡åŒ–Hash:
vectorized_hash(batch, key):
  return simd_hash(batch[key])

æ€§èƒ½æ¨¡å‹ï¼š
â”€â”€â”€â”€â”€â”€â”€â”€â”€
è®¾Wä¸ºSIMDå®½åº¦ï¼ˆå¦‚AVX-512ä¸º8ä¸ª64ä½æ•´æ•°ï¼‰

æ ‡é‡æ“ä½œ: næ¬¡å¾ªç¯
å‘é‡åŒ–æ“ä½œ: âŒˆn/WâŒ‰æ¬¡å¾ªç¯

åŠ é€Ÿæ¯”: W Ã— (1 - overhead)

å…¸å‹åŠ é€Ÿ: 4-8xï¼ˆè€ƒè™‘å†…å­˜å¸¦å®½å’Œåˆ†æ”¯å¼€é”€ï¼‰
```

---

## å…­ã€æ­£ç¡®æ€§è¯æ˜

### 6.1 è¯­ä¹‰ä¿æŒè¯æ˜

```text
å®šç†6.1 (æ‰§è¡Œæ­£ç¡®æ€§)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

å¯¹ä»»æ„æŸ¥è¯¢Qå’Œæ•°æ®åº“çŠ¶æ€DB:
Execute(Compile(Q), DB) = Semantics(Q, DB)

è¯æ˜ï¼š
å¯¹æŸ¥è¯¢ç»“æ„å½’çº³

åŸºç¡€æƒ…å†µï¼šTableScan
  Execute(Scan(R)) = {t | t âˆˆ R} = [[R]]

å½’çº³æƒ…å†µï¼šFilter
  å‡è®¾Execute(Compile(child)) = [[child]]
  Execute(Compile(Filter(child, p)))
  = {t | t âˆˆ Execute(child) âˆ§ p(t)}  (ç”±Filterè¯­ä¹‰)
  = {t | t âˆˆ [[child]] âˆ§ p(t)}       (å½’çº³å‡è®¾)
  = [[Filter(child, p)]]             (Filterè¯­ä¹‰å®šä¹‰)

å…¶ä»–ç®—å­ç±»ä¼¼è¯æ˜
Q.E.D.
```

### 6.2 ä¼˜åŒ–æ­£ç¡®æ€§è¯æ˜

```text
å®šç†6.2 (ç­‰ä»·å˜æ¢æ­£ç¡®æ€§)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

æ‰€æœ‰æŸ¥è¯¢ä¼˜åŒ–å˜æ¢ä¿æŒè¯­ä¹‰ç­‰ä»·

è¯æ˜ç¤ºä¾‹ï¼šé€‰æ‹©ä¸‹æ¨æ­£ç¡®æ€§

éœ€è¯: [[Ïƒ_p(R â‹ˆ S)]] = [[Ïƒ_p(R) â‹ˆ S]] å½“attrs(p) âŠ† attrs(R)

è®¾t âˆˆ [[Ïƒ_p(R â‹ˆ S)]]
âŸº t âˆˆ R â‹ˆ S âˆ§ p(t)
âŸº âˆƒrâˆˆR, sâˆˆS: t = râ‹ˆs âˆ§ p(râ‹ˆs)
âŸº âˆƒrâˆˆR, sâˆˆS: t = râ‹ˆs âˆ§ p(r)     (å› attrs(p) âŠ† attrs(R))
âŸº âˆƒrâˆˆÏƒ_p(R), sâˆˆS: t = râ‹ˆs
âŸº t âˆˆ [[Ïƒ_p(R) â‹ˆ S]]
Q.E.D.
```

### 6.3 å¹¶å‘æ­£ç¡®æ€§

```text
å®šç†6.3 (å¹¶è¡Œæ‰§è¡Œæ­£ç¡®æ€§)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

å¹¶è¡Œæ‰§è¡Œä¸ä¸²è¡Œæ‰§è¡Œç»“æœç­‰ä»·ï¼ˆå¯¹äº¤æ¢/ç»“åˆç®—å­ï¼‰

è¯æ˜ï¼š
è®¾Opä¸ºæ»¡è¶³äº¤æ¢å¾‹å’Œç»“åˆå¾‹çš„ç®—å­ï¼ˆå¦‚SUM, COUNTï¼‰

Parallel_Op(input, P)
= Op(partition_1) âŠ• ... âŠ• Op(partition_P)
= Op(partition_1 âˆª ... âˆª partition_P)        (ç»“åˆå¾‹)
= Op(input)                                   (åˆ†åŒºå®Œæ•´æ€§)

å¯¹äºéäº¤æ¢ç®—å­ï¼ˆå¦‚ORDER BYï¼‰ï¼Œéœ€è¦é¢å¤–çš„mergeé˜¶æ®µ
```

---

## ä¸ƒã€ç›¸å…³èµ„æº

### å†…éƒ¨é“¾æ¥

- [SQLå½¢å¼åŒ–è¯­ä¹‰](./03.01-SQLå½¢å¼åŒ–è¯­ä¹‰.md)
- [ä»£ä»·æ¨¡å‹ç†è®º](./03.06-ä»£ä»·æ¨¡å‹ç†è®º.md)
- [æ•°å­¦åŸºç¡€åˆ°SQLå› æœé“¾](../01-ç†è®ºåŸºç¡€/01.06-æ•°å­¦åŸºç¡€åˆ°SQLå› æœé“¾.md)
- [å†³ç­–æ¨ç†è§„åˆ™åº“](../09-æ•´åˆèµ„æº/09.07-å†³ç­–æ¨ç†è§„åˆ™åº“.md)

### å¤–éƒ¨èµ„æº

- CMU 15-445: Database Systems (Andy Pavlo)
- MIT 6.830: Database Systems
- Graefe, G. "Volcano: An Extensible and Parallel Query Evaluation System"
- Neumann, T. "Efficiently Compiling Efficient Query Plans for Modern Hardware"

---

**ç»´æŠ¤è€…**: SQL Standards Team
**åˆ›å»ºæ—¥æœŸ**: 2025-12-01
**å¯¹æ ‡è¯¾ç¨‹**: CMU 15-445, MIT 6.830
