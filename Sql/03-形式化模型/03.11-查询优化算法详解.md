# æŸ¥è¯¢ä¼˜åŒ–ç®—æ³•è¯¦è§£

> **åˆ›å»ºæ—¥æœŸ**ï¼š2025-12-04
> **é€‚ç”¨æ•°æ®åº“**ï¼šPostgreSQL 18 / MySQL 8.4 / SQLite 3.47.x
> **éš¾åº¦**ï¼šâ­â­â­â­â­
> **å‰ç½®çŸ¥è¯†**ï¼šå…³ç³»ä»£æ•°ã€ç®—æ³•åˆ†æ

---

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦è§£æŸ¥è¯¢ä¼˜åŒ–å™¨çš„æ ¸å¿ƒç®—æ³•ï¼ŒåŒ…æ‹¬ä»£ä»·ä¼°ç®—ã€è¿æ¥é¡ºåºé€‰æ‹©ã€ç´¢å¼•é€‰æ‹©ç­‰ã€‚

---

## ğŸ“‘ ç›®å½•

- [æŸ¥è¯¢ä¼˜åŒ–ç®—æ³•è¯¦è§£](#æŸ¥è¯¢ä¼˜åŒ–ç®—æ³•è¯¦è§£)
  - [ğŸ“‹ æ¦‚è¿°](#-æ¦‚è¿°)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [ä¸€ã€æŸ¥è¯¢ä¼˜åŒ–å™¨æ¶æ„](#ä¸€æŸ¥è¯¢ä¼˜åŒ–å™¨æ¶æ„)
    - [1.1 ä¼˜åŒ–å™¨æµç¨‹](#11-ä¼˜åŒ–å™¨æµç¨‹)
    - [1.2 ä»£ä»·æ¨¡å‹](#12-ä»£ä»·æ¨¡å‹)
  - [äºŒã€è¿æ¥é¡ºåºä¼˜åŒ–](#äºŒè¿æ¥é¡ºåºä¼˜åŒ–)
    - [2.1 åŠ¨æ€è§„åˆ’ç®—æ³•](#21-åŠ¨æ€è§„åˆ’ç®—æ³•)
    - [2.2 è´ªå¿ƒç®—æ³•](#22-è´ªå¿ƒç®—æ³•)
    - [2.3 é—ä¼ ç®—æ³•](#23-é—ä¼ ç®—æ³•)
  - [ä¸‰ã€ç´¢å¼•é€‰æ‹©ç®—æ³•](#ä¸‰ç´¢å¼•é€‰æ‹©ç®—æ³•)
    - [3.1 é€‰æ‹©æ€§ä¼°ç®—](#31-é€‰æ‹©æ€§ä¼°ç®—)
    - [3.2 ç´¢å¼•é€‰æ‹©ç­–ç•¥](#32-ç´¢å¼•é€‰æ‹©ç­–ç•¥)
  - [å››ã€å­æŸ¥è¯¢ä¼˜åŒ–](#å››å­æŸ¥è¯¢ä¼˜åŒ–)
    - [4.1 å­æŸ¥è¯¢æ‰å¹³åŒ–](#41-å­æŸ¥è¯¢æ‰å¹³åŒ–)
    - [4.2 å­æŸ¥è¯¢ç‰©åŒ–](#42-å­æŸ¥è¯¢ç‰©åŒ–)
  - [äº”ã€å®é™…æ¡ˆä¾‹åˆ†æ](#äº”å®é™…æ¡ˆä¾‹åˆ†æ)
    - [5.1 PostgreSQLä¼˜åŒ–å™¨](#51-postgresqlä¼˜åŒ–å™¨)
    - [5.2 SQLiteä¼˜åŒ–å™¨](#52-sqliteä¼˜åŒ–å™¨)

---

## ä¸€ã€æŸ¥è¯¢ä¼˜åŒ–å™¨æ¶æ„

### 1.1 ä¼˜åŒ–å™¨æµç¨‹

```text
æŸ¥è¯¢ä¼˜åŒ–å™¨å®Œæ•´æµç¨‹
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SQLæŸ¥è¯¢
    â”‚
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. è§£æä¸è¯­æ³•åˆ†æ                      â”‚
â”‚    SQL â†’ è¯­æ³•æ ‘ï¼ˆParse Treeï¼‰          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. è¯­ä¹‰åˆ†æä¸éªŒè¯                      â”‚
â”‚    â€¢ è¡¨/åˆ—å­˜åœ¨æ€§æ£€æŸ¥                   â”‚
â”‚    â€¢ ç±»å‹å…¼å®¹æ€§æ£€æŸ¥                    â”‚
â”‚    â€¢ æƒé™æ£€æŸ¥                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. é€»è¾‘ä¼˜åŒ–ï¼ˆLogical Optimizationï¼‰    â”‚
â”‚    â€¢ å¸¸é‡æŠ˜å                           â”‚
â”‚    â€¢ è°“è¯ä¸‹æ¨                          â”‚
â”‚    â€¢ æŠ•å½±è£å‰ª                          â”‚
â”‚    â€¢ å­æŸ¥è¯¢æ‰å¹³åŒ–                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4. ç‰©ç†ä¼˜åŒ–ï¼ˆPhysical Optimizationï¼‰   â”‚
â”‚    â€¢ è®¿é—®è·¯å¾„é€‰æ‹©ï¼ˆå…¨è¡¨æ‰«æ vs ç´¢å¼•ï¼‰ â”‚
â”‚    â€¢ è¿æ¥ç®—æ³•é€‰æ‹©ï¼ˆNested Loop/Hash/Mergeï¼‰â”‚
â”‚    â€¢ è¿æ¥é¡ºåºé€‰æ‹©ï¼ˆåŠ¨æ€è§„åˆ’/è´ªå¿ƒï¼‰    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 5. ä»£ä»·ä¼°ç®—ä¸è®¡åˆ’ç”Ÿæˆ                  â”‚
â”‚    â€¢ ä¼°ç®—æ¯ä¸ªç®—å­çš„ä»£ä»·                â”‚
â”‚    â€¢ é€‰æ‹©æœ€ä¼˜æ‰§è¡Œè®¡åˆ’                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
æ‰§è¡Œè®¡åˆ’ï¼ˆExecution Planï¼‰
```

### 1.2 ä»£ä»·æ¨¡å‹

```text
æŸ¥è¯¢ä»£ä»·ä¼°ç®—æ¨¡å‹
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Cost = C_CPU + C_IO + C_Network

1. CPUä»£ä»·ï¼ˆC_CPUï¼‰
   C_CPU = N_tuples Ã— C_tuple_processing

   å…¶ä¸­ï¼š
   â€¢ N_tuples = å¤„ç†çš„å…ƒç»„æ•°
   â€¢ C_tuple_processing = æ¯å…ƒç»„å¤„ç†ä»£ä»·ï¼ˆå¸¸æ•°ï¼‰

   å…¸å‹å€¼ï¼š
   â€¢ ç®€å•è¿‡æ»¤: 0.01ms/tuple
   â€¢ JOINæ“ä½œ: 0.1ms/tuple
   â€¢ èšåˆè®¡ç®—: 0.05ms/tuple

2. IOä»£ä»·ï¼ˆC_IOï¼‰
   C_IO = N_pages Ã— C_page_read

   å…¶ä¸­ï¼š
   â€¢ N_pages = è¯»å–çš„é¡µé¢æ•°
   â€¢ C_page_read = é¡µé¢è¯»å–ä»£ä»·

   å…¸å‹å€¼ï¼š
   â€¢ é¡ºåºè¯»: 0.01ms/page (SSD)
   â€¢ éšæœºè¯»: 0.1ms/page (SSD)
   â€¢ é¡ºåºè¯»: 5ms/page (HDD)
   â€¢ éšæœºè¯»: 10ms/page (HDD)

3. ç½‘ç»œä»£ä»·ï¼ˆC_Networkï¼Œåˆ†å¸ƒå¼æ•°æ®åº“ï¼‰
   C_Network = N_messages Ã— C_message + Data_size Ã— C_bandwidth

ä»£ä»·ä¼°ç®—ç¤ºä¾‹ï¼š

æŸ¥è¯¢: SELECT * FROM users WHERE age > 25;

æ–¹æ¡ˆA: å…¨è¡¨æ‰«æ
â€¢ N_tuples = 1,000,000
â€¢ N_pages = 50,000 (å‡è®¾æ¯é¡µ20æ¡è®°å½•)
â€¢ C_IO = 50,000 Ã— 0.01ms = 500ms
â€¢ C_CPU = 1,000,000 Ã— 0.01ms = 10,000ms
â€¢ Total = 10,500ms

æ–¹æ¡ˆB: ç´¢å¼•æ‰«æï¼ˆå‡è®¾30%è®°å½•æ»¡è¶³æ¡ä»¶ï¼‰
â€¢ N_tuples = 300,000
â€¢ N_pages_index = 2,000 (B-Treeç´¢å¼•é¡µé¢)
â€¢ N_pages_table = 15,000 (å›è¡¨)
â€¢ C_IO = (2,000 + 15,000) Ã— 0.1ms = 1,700ms (éšæœºIO)
â€¢ C_CPU = 300,000 Ã— 0.01ms = 3,000ms
â€¢ Total = 4,700ms

é€‰æ‹©ï¼šæ–¹æ¡ˆBï¼ˆç´¢å¼•æ‰«æï¼‰æ›´ä¼˜
```

---

## äºŒã€è¿æ¥é¡ºåºä¼˜åŒ–

### 2.1 åŠ¨æ€è§„åˆ’ç®—æ³•

```text
è¿æ¥é¡ºåºä¼˜åŒ–ï¼šåŠ¨æ€è§„åˆ’ï¼ˆPostgreSQLä½¿ç”¨ï¼‰
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

é—®é¢˜ï¼šç»™å®šnä¸ªè¡¨çš„JOINï¼Œå¦‚ä½•ç¡®å®šæœ€ä¼˜è¿æ¥é¡ºåºï¼Ÿ

æš´åŠ›æœç´¢ï¼šn!ç§å¯èƒ½ï¼ˆn=10æ—¶ï¼Œ3,628,800ç§ï¼‰

åŠ¨æ€è§„åˆ’ç®—æ³•ï¼ˆSystem Ré£æ ¼ï¼‰ï¼š

è¾“å…¥ï¼šTables = {T1, T2, ..., Tn}
è¾“å‡ºï¼šæœ€ä¼˜è¿æ¥é¡ºåº

ç®—æ³•ï¼š

// DPçŠ¶æ€ï¼šdp[S] = è¿æ¥é›†åˆSä¸­è¡¨çš„æœ€ä¼˜è®¡åˆ’
// Sç”¨ä½æ©ç è¡¨ç¤ºï¼Œå¦‚{T1, T3} = 0b101

for size = 1 to n:  // é›†åˆå¤§å°
    for each subset S of size:
        if size == 1:
            // å•è¡¨ï¼šé€‰æ‹©æœ€ä¼˜è®¿é—®è·¯å¾„
            dp[S] = chooseBestScan(S)
        else:
            // å¤šè¡¨ï¼šæšä¸¾æ‰€æœ‰åˆ†å‰²æ–¹å¼
            bestCost = INFINITY
            for each split (S1, S2) where S1 âˆª S2 = S and S1 âˆ© S2 = âˆ…:
                // å°è¯•è¿æ¥é¡ºåº dp[S1] â¨ dp[S2]
                cost = dp[S1].cost + dp[S2].cost + joinCost(S1, S2)
                if cost < bestCost:
                    bestCost = cost
                    dp[S] = createPlan(dp[S1], dp[S2], joinMethod)

return dp[{T1, T2, ..., Tn}]

æ—¶é—´å¤æ‚åº¦ï¼šO(3^n)
ç©ºé—´å¤æ‚åº¦ï¼šO(2^n)

PostgreSQLä¼˜åŒ–ï¼š
â€¢ n > 12æ—¶ï¼Œä½¿ç”¨é—ä¼ ç®—æ³•æˆ–è´ªå¿ƒç®—æ³•
â€¢ å‰ªæï¼šCross Product Pruningï¼ˆé¿å…ç¬›å¡å°”ç§¯ï¼‰
â€¢ ç¼“å­˜ï¼šè®°å¿†åŒ–å·²è®¡ç®—çš„å­é—®é¢˜
```

### 2.2 è´ªå¿ƒç®—æ³•

```text
è´ªå¿ƒè¿æ¥é¡ºåºç®—æ³•ï¼ˆMySQLä½¿ç”¨ï¼‰
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ç®—æ³•æ€æƒ³ï¼šæ¯æ¬¡é€‰æ‹©ä»£ä»·æœ€å°çš„è¿æ¥

function greedyJoinOrder(tables):
    result = []
    remaining = tables.copy()

    // 1. é€‰æ‹©æœ€å°çš„è¡¨ä½œä¸ºèµ·ç‚¹
    current = findSmallestTable(remaining)
    result.append(current)
    remaining.remove(current)

    // 2. è´ªå¿ƒé€‰æ‹©ä¸‹ä¸€ä¸ªè¡¨
    while remaining:
        bestTable = NULL
        bestCost = INFINITY

        for table in remaining:
            // ä¼°ç®—ä¸å½“å‰ç»“æœé›†è¿æ¥çš„ä»£ä»·
            cost = estimateJoinCost(current, table)
            if cost < bestCost:
                bestCost = cost
                bestTable = table

        result.append(bestTable)
        remaining.remove(bestTable)
        current = joinResult(current, bestTable)

    return result

æ—¶é—´å¤æ‚åº¦ï¼šO(nÂ²)
ç©ºé—´å¤æ‚åº¦ï¼šO(n)

ä¼˜ç‚¹ï¼š
â€¢ å¿«é€Ÿï¼šé€‚åˆå¤§é‡è¡¨çš„JOIN
â€¢ ç®€å•ï¼šæ˜“äºå®ç°

ç¼ºç‚¹ï¼š
â€¢ éæœ€ä¼˜ï¼šå¯èƒ½é”™è¿‡å…¨å±€æœ€ä¼˜è§£
â€¢ è´ªå¿ƒé€‰æ‹©å¯èƒ½å¯¼è‡´å±€éƒ¨æœ€ä¼˜

å®é™…æ•ˆæœï¼š
â€¢ n < 5: é€šå¸¸æ‰¾åˆ°æœ€ä¼˜è§£
â€¢ n > 10: å¯èƒ½å·®20-50%
```

### 2.3 é—ä¼ ç®—æ³•

```sql
-- PostgreSQLï¼šå¤§é‡è¡¨JOINæ—¶çš„é—ä¼ ç®—æ³•

-- ç¤ºä¾‹ï¼š10è¡¨JOIN
SELECT *
FROM t1, t2, t3, t4, t5, t6, t7, t8, t9, t10
WHERE t1.id = t2.fk
    AND t2.id = t3.fk
    AND t3.id = t4.fk
    AND t4.id = t5.fk
    AND t5.id = t6.fk
    AND t6.id = t7.fk
    AND t7.id = t8.fk
    AND t8.id = t9.fk
    AND t9.id = t10.fk;

-- PostgreSQL GEQOï¼ˆé—ä¼ æŸ¥è¯¢ä¼˜åŒ–å™¨ï¼‰é…ç½®
SET geqo = on;
SET geqo_threshold = 12;  -- 12ä¸ªè¡¨ä»¥ä¸Šä½¿ç”¨GEQO
SET geqo_effort = 5;       -- æœç´¢åŠªåŠ›ç¨‹åº¦(1-10)
SET geqo_generations = 0;  -- 0=è‡ªåŠ¨
SET geqo_pool_size = 0;    -- 0=è‡ªåŠ¨

-- æŸ¥çœ‹ä¼˜åŒ–å™¨ä½¿ç”¨çš„ç®—æ³•
EXPLAIN (VERBOSE, COSTS) SELECT ...;
-- è¾“å‡ºä¼šæ˜¾ç¤ºæ˜¯å¦ä½¿ç”¨äº†GEQO
```

---

## ä¸‰ã€ç´¢å¼•é€‰æ‹©ç®—æ³•

### 3.1 é€‰æ‹©æ€§ä¼°ç®—

```text
ç´¢å¼•é€‰æ‹©æ€§ä¼°ç®—
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

é€‰æ‹©æ€§ï¼ˆSelectivityï¼‰= æ»¡è¶³æ¡ä»¶çš„è¡Œæ•° / æ€»è¡Œæ•°

æ–¹æ³•1: ç»Ÿè®¡ç›´æ–¹å›¾ï¼ˆHistogramï¼‰

-- PostgreSQLæ”¶é›†ç»Ÿè®¡ä¿¡æ¯
ANALYZE table_name;

-- å­˜å‚¨åœ¨pg_statsä¸­ï¼š
SELECT
    tablename,
    attname,
    n_distinct,     -- å”¯ä¸€å€¼æ•°é‡
    most_common_vals,  -- æœ€å¸¸è§å€¼
    most_common_freqs  -- é¢‘ç‡
FROM pg_stats
WHERE tablename = 'users';

ä¼°ç®—selectivity:
â€¢ ç­‰å€¼æŸ¥è¯¢ï¼ˆcol = valueï¼‰:
  SELECT1 (col = value) = 1 / n_distinct

â€¢ èŒƒå›´æŸ¥è¯¢ï¼ˆcol > valueï¼‰:
  å‡è®¾å‡åŒ€åˆ†å¸ƒ: SELECTRANGE = (max - value) / (max - min)

â€¢ LIKEæŸ¥è¯¢ï¼ˆcol LIKE 'prefix%'ï¼‰:
  åŸºäºç›´æ–¹å›¾ä¼°ç®—

æ–¹æ³•2: é‡‡æ ·ä¼°ç®—

-- éšæœºé‡‡æ ·1000è¡Œä¼°ç®—é€‰æ‹©æ€§
WITH sample AS (
    SELECT * FROM large_table TABLESAMPLE SYSTEM (0.1)  -- 0.1%é‡‡æ ·
    LIMIT 1000
)
SELECT
    COUNT(*) FILTER (WHERE age > 25) * 1.0 / COUNT(*) AS estimated_selectivity
FROM sample;

æ–¹æ³•3: HyperLogLogï¼ˆå”¯ä¸€å€¼ä¼°ç®—ï¼‰

-- PostgreSQLæ‰©å±•
SELECT hll_cardinality(hll_add_agg(hll_hash_text(email)))
FROM users;
-- ä¼°ç®—å”¯ä¸€emailæ•°é‡ï¼Œè¯¯å·®<2%
```

### 3.2 ç´¢å¼•é€‰æ‹©ç­–ç•¥

```text
ç´¢å¼•é€‰æ‹©å†³ç­–ç®—æ³•
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

è¾“å…¥ï¼š
â€¢ Query Q
â€¢ Available Indexes I = {idx1, idx2, ..., idxn}
â€¢ Table Statistics S

è¾“å‡ºï¼šæœ€ä¼˜ç´¢å¼•æˆ–å…¨è¡¨æ‰«æ

ç®—æ³•ï¼š

function chooseIndex(Q, I, S):
    plans = []

    // 1. å…¨è¡¨æ‰«ææ–¹æ¡ˆ
    seqScanCost = S.n_pages Ã— COST_SEQ_PAGE
    plans.append(('SeqScan', seqScanCost))

    // 2. æ¯ä¸ªç´¢å¼•çš„æ‰«ææ–¹æ¡ˆ
    for idx in I:
        if canUseIndex(Q.predicate, idx):
            // ä¼°ç®—ç´¢å¼•æ‰«æä»£ä»·
            selectivity = estimateSelectivity(Q.predicate, S)
            n_index_pages = idx.n_pages
            n_table_pages = S.n_pages Ã— selectivity

            // ç´¢å¼•æ‰«æ + å›è¡¨
            indexScanCost = n_index_pages Ã— COST_RANDOM_PAGE +
                           n_table_pages Ã— COST_RANDOM_PAGE

            plans.append((idx.name, indexScanCost))

    // 3. é€‰æ‹©æœ€å°ä»£ä»·æ–¹æ¡ˆ
    return min(plans, key=lambda x: x[1])

å®é™…åº”ç”¨ç¤ºä¾‹ï¼š

-- æŸ¥è¯¢
SELECT * FROM users WHERE age > 25 AND city = 'NYC';

-- å¯ç”¨ç´¢å¼•
idx_age (age)
idx_city (city)
idx_age_city (age, city)  -- å¤åˆç´¢å¼•

ä»£ä»·ä¼°ç®—ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æ–¹æ¡ˆ             â”‚ é€‰æ‹©æ€§       â”‚ ä»£ä»·ä¼°ç®—                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ SeqScan          â”‚ 100%         â”‚ 50,000é¡µ Ã— 0.01ms = 500msâ”‚
â”‚ idx_age          â”‚ 30%          â”‚ 100é¡µ + 15,000é¡µÃ—0.1ms   â”‚
â”‚                  â”‚              â”‚ = 1,501ms                â”‚
â”‚ idx_city         â”‚ 5%           â”‚ 50é¡µ + 2,500é¡µÃ—0.1ms     â”‚
â”‚                  â”‚              â”‚ = 250.5ms âœ“æœ€ä¼˜          â”‚
â”‚ idx_age_city     â”‚ 1.5%         â”‚ 30é¡µ + 750é¡µÃ—0.1ms       â”‚
â”‚                  â”‚              â”‚ = 75.3ms âœ“âœ“æœ€ä¼˜          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

é€‰æ‹©ï¼šidx_age_cityï¼ˆå¤åˆç´¢å¼•ï¼‰
```

---

## å››ã€å­æŸ¥è¯¢ä¼˜åŒ–

### 4.1 å­æŸ¥è¯¢æ‰å¹³åŒ–

```sql
-- å­æŸ¥è¯¢æ‰å¹³åŒ–è½¬æ¢

-- åŸæŸ¥è¯¢ï¼ˆä½æ•ˆï¼‰
SELECT *
FROM orders o
WHERE o.user_id IN (
    SELECT user_id FROM users WHERE city = 'NYC'
);

-- ä¼˜åŒ–å™¨è‡ªåŠ¨è½¬æ¢ä¸ºï¼ˆé«˜æ•ˆï¼‰
SELECT o.*
FROM orders o
JOIN users u ON o.user_id = u.user_id
WHERE u.city = 'NYC';

-- è½¬æ¢æ¡ä»¶ï¼š
-- 1. å­æŸ¥è¯¢æ˜¯ç®€å•çš„SELECT
-- 2. æ— èšåˆå‡½æ•°
-- 3. æ— LIMIT/OFFSET
-- 4. å¤–å±‚æŸ¥è¯¢ä¸å­æŸ¥è¯¢æ— å†²çªåˆ—å
```

**æ‰å¹³åŒ–ç®—æ³•**ï¼š

```text
å­æŸ¥è¯¢æ‰å¹³åŒ–ç®—æ³•
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function flattenSubquery(query):
    // è¯†åˆ«INå­æŸ¥è¯¢
    if query has form: "col IN (SELECT col2 FROM table WHERE ...)"

        // è½¬æ¢ä¸ºåŠè¿æ¥ï¼ˆSemi-Joinï¼‰
        rewrite as:
          SELECT * FROM outer_table o
          WHERE EXISTS (
              SELECT 1 FROM inner_table i
              WHERE o.col = i.col2 AND inner_predicate
          )

        // è¿›ä¸€æ­¥è½¬æ¢ä¸ºJOIN
        rewrite as:
          SELECT DISTINCT o.*
          FROM outer_table o
          JOIN inner_table i ON o.col = i.col2
          WHERE inner_predicate

    return rewritten_query

æ€§èƒ½æå‡ï¼š
â€¢ åŸINå­æŸ¥è¯¢: O(n Ã— m)ï¼Œnæ¬¡å¤–å±‚Ã—mæ¬¡å†…å±‚
â€¢ è½¬æ¢ä¸ºJOIN: O(n + m)ï¼Œä¸€æ¬¡æ‰«æ
â€¢ æå‡æ¯”ä¾‹: 10-100å€
```

### 4.2 å­æŸ¥è¯¢ç‰©åŒ–

```sql
-- å­æŸ¥è¯¢ç‰©åŒ–ï¼ˆMaterializationï¼‰

-- åŸæŸ¥è¯¢
SELECT o.*
FROM orders o
WHERE o.product_id IN (
    SELECT product_id
    FROM products
    WHERE category = 'Electronics' AND price > 100
);

-- ä¼˜åŒ–å™¨ç­–ç•¥ï¼šå…ˆç‰©åŒ–å­æŸ¥è¯¢

-- Step 1: ç‰©åŒ–å­æŸ¥è¯¢åˆ°ä¸´æ—¶è¡¨
CREATE TEMP TABLE subquery_result AS
SELECT product_id
FROM products
WHERE category = 'Electronics' AND price > 100;

-- Step 2: JOINä¸´æ—¶è¡¨
SELECT o.*
FROM orders o
JOIN subquery_result s ON o.product_id = s.product_id;

-- ä½•æ—¶ç‰©åŒ–ï¼Ÿ
-- â€¢ å­æŸ¥è¯¢ç»“æœé›†è¾ƒå°ï¼ˆ< 1000è¡Œï¼‰
-- â€¢ å¤–å±‚æŸ¥è¯¢å¤šæ¬¡å¼•ç”¨å­æŸ¥è¯¢
-- â€¢ å­æŸ¥è¯¢è®¡ç®—ä»£ä»·é«˜
```

---

## äº”ã€å®é™…æ¡ˆä¾‹åˆ†æ

### 5.1 PostgreSQLä¼˜åŒ–å™¨

```sql
-- PostgreSQLæŸ¥è¯¢è®¡åˆ’åˆ†æ

EXPLAIN (ANALYZE, BUFFERS, VERBOSE, WAL)
SELECT u.name, COUNT(o.order_id) AS order_count
FROM users u
LEFT JOIN orders o ON u.user_id = o.user_id
WHERE u.created_at >= '2024-01-01'
GROUP BY u.user_id, u.name
HAVING COUNT(o.order_id) > 5
ORDER BY order_count DESC
LIMIT 100;

/* è¾“å‡ºç¤ºä¾‹ï¼ˆPostgreSQL 18ï¼‰:

Limit  (cost=15234.56..15234.81 rows=100 width=48)
       (actual time=125.234..125.456 rows=100 loops=1)
  Buffers: shared hit=8765 read=234
  ->  Sort  (cost=15234.56..15456.78 rows=88889 width=48)
            (actual time=125.231..125.389 rows=100 loops=1)
        Sort Key: (count(o.order_id)) DESC
        Sort Method: top-N heapsort  Memory: 32kB
        Buffers: shared hit=8765 read=234
        ->  HashAggregate  (cost=12345.67..13456.78 rows=88889 width=48)
                     (actual time=98.123..112.456 rows=50000 loops=1)
              Group Key: u.user_id
              Batches: 1  Memory Usage: 12MB
              Buffers: shared hit=8765 read=234
              ->  Hash Left Join  (cost=2345.67..9876.54 rows=500000 width=40)
                           (actual time=23.456..78.901 rows=500000 loops=1)
                    Hash Cond: (u.user_id = o.user_id)
                    Buffers: shared hit=8765 read=234
                    ->  Index Scan using idx_users_created on users u
                              (cost=0.43..1234.56 rows=50000 width=36)
                              (actual time=0.023..15.678 rows=50000 loops=1)
                          Index Cond: (created_at >= '2024-01-01')
                          Buffers: shared hit=1234
                    ->  Hash  (cost=1234.56..1234.56 rows=100000 width=12)
                             (actual time=23.123..23.123 rows=100000 loops=1)
                          Buckets: 131072  Batches: 1  Memory Usage: 5MB
                          Buffers: shared hit=7531 read=234
                          ->  Seq Scan on orders o
                                    (cost=0.00..1234.56 rows=100000 width=12)
                                    (actual time=0.012..12.345 rows=100000 loops=1)
                                Buffers: shared hit=7531 read=234

Planning Time: 2.345 ms
Execution Time: 125.789 ms
*/

å…³é”®ä¿¡æ¯è§£è¯»ï¼š
â€¢ cost=å¯åŠ¨ä»£ä»·..æ€»ä»£ä»·
â€¢ rows=ä¼°ç®—è¡Œæ•°
â€¢ width=å¹³å‡è¡Œå®½åº¦ï¼ˆå­—èŠ‚ï¼‰
â€¢ actual time=å®é™…æ—¶é—´
â€¢ Buffers hit=ç¼“å­˜å‘½ä¸­ï¼Œread=ç£ç›˜è¯»å–
â€¢ Memory Usage=å†…å­˜ä½¿ç”¨é‡

ä¼˜åŒ–ç‚¹è¯†åˆ«ï¼š
âœ“ ä½¿ç”¨äº†ç´¢å¼•ï¼ˆidx_users_createdï¼‰
âœ“ Hash Joinï¼ˆé«˜æ•ˆï¼‰
âœ“ ç¼“å­˜å‘½ä¸­ç‡é«˜ï¼ˆshared hit=8765 vs read=234ï¼‰
âœ“ top-N heapsortï¼ˆLIMITä¼˜åŒ–ï¼‰
```

### 5.2 SQLiteä¼˜åŒ–å™¨

```sql
-- SQLiteæŸ¥è¯¢è®¡åˆ’åˆ†æ

EXPLAIN QUERY PLAN
SELECT u.name, COUNT(o.order_id) AS order_count
FROM users u
LEFT JOIN orders o ON u.user_id = o.user_id
WHERE u.created_at >= '2024-01-01'
GROUP BY u.user_id, u.name
HAVING COUNT(o.order_id) > 5
ORDER BY order_count DESC
LIMIT 100;

/* è¾“å‡ºç¤ºä¾‹ï¼ˆSQLite 3.47.xï¼‰:

QUERY PLAN
|--SCAN u USING INDEX idx_users_created (created_at>?)
`--SEARCH o USING INDEX idx_orders_user (user_id=?)
*/

-- SQLiteè¯¦ç»†å­—èŠ‚ç 
EXPLAIN
SELECT ...;

/* è¾“å‡ºVDBEå­—èŠ‚ç ï¼ˆç®€åŒ–ï¼‰:

addr  opcode         p1    p2    p3    p4             comment
----  -------------  ----  ----  ----  -------------  -------
0     Init           0     45    0                    Start
1     OpenRead       0     2     0     3              root=2; users
2     OpenRead       1     5     0     2              root=5; orders
3     String8        0     1     0     2024-01-01     r[1]='2024-01-01'
4     SeekGE         0     44    1     1              key=r[1]
5     Column         0     0     2                    r[2]=users.user_id
6     Column         0     1     3                    r[3]=users.name
7     SeekGE         1     11    2     1              key=r[2]
8     Column         1     0     4                    r[4]=orders.order_id
9     AggStep        0     4     5     count(*)       accum=r[5]
10    Next           1     7     0                    loop back to 7
11    AggFinal       5     1     0     count(*)       output=r[5]
12    Ge             5     43    6     5              if r[5]>=5
13    ResultRow      3     3     0                    output=r[3..5]
...
43    Halt           0     0     0                    End
*/

SQLiteä¼˜åŒ–å™¨ç‰¹ç‚¹ï¼š
â€¢ åŸºäºè§„åˆ™ï¼ˆRule-Basedï¼‰ä¸ºä¸»
â€¢ ä»£ä»·ä¼°ç®—ï¼ˆCost-Basedï¼‰ä¸ºè¾…
â€¢ ç®€å•ä½†æœ‰æ•ˆ
â€¢ é€‚åˆå°å‹æ•°æ®åº“
```

---

**æŸ¥è¯¢ä¼˜åŒ–ç®—æ³•è¯¦è§£å®Œæˆï¼**

æœ¬æ–‡æ¡£æä¾›ï¼š

- âœ… ä¼˜åŒ–å™¨æ¶æ„ä¸ä»£ä»·æ¨¡å‹
- âœ… åŠ¨æ€è§„åˆ’è¿æ¥é¡ºåºç®—æ³•ï¼ˆO(3^n)ï¼‰
- âœ… è´ªå¿ƒç®—æ³•ï¼ˆO(nÂ²)ï¼‰
- âœ… ç´¢å¼•é€‰æ‹©æ€§ä¼°ç®—æ–¹æ³•
- âœ… å­æŸ¥è¯¢æ‰å¹³åŒ–ä¸ç‰©åŒ–
- âœ… PostgreSQL vs SQLiteä¼˜åŒ–å™¨å¯¹æ¯”
- âœ… å®é™…EXPLAINè¾“å‡ºåˆ†æ

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0
**æœ€åæ›´æ–°**: 2025-12-04
**ç»´æŠ¤è€…**: SQL Standards Team
