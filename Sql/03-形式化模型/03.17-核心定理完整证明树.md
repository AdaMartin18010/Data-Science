# 核心定理完整证明树

> **创建日期**: 2025-12-05
> **版本**: v1.0
> **用途**: 展示SQL核心定理的完整证明路径

---

## 证明树1：可串行化理论

```text
可串行化完整证明树
══════════════════════════════════════════════════════════════════════════════

                    [定理T3.08]
               可串行化充分性定理
          若H是可串行化历史，则H正确
                        │
          ┌─────────────┼─────────────┐
          │             │             │
     [引理3.08.1]  [引理3.08.2]  [引理3.08.3]
     冲突等价性    视图等价性    CSR充分条件
          │             │             │
    ┌─────┴─────┐       │       ┌─────┴─────┐
[L3.08.1.1]  [L3.08.1.2] │  [L3.08.3.1]  [L3.08.3.2]
读写冲突     写写冲突    │  依赖图定义  无环充分性
定义         定义        │       │             │
    │             │       │       │             │
    └─────────────┴───────┴───────┴─────────────┘
                        │
                 [基础定义D1]
              happens-before关系
                        │
                 [公理A5]
              事务原子性公理

═══════════════════════════════════════════════════════════════

详细证明路径:

Step 0: 公理基础
───────────────
A5. 事务原子性公理
    ∀ 事务T, final(T) ∈ {commit, abort}

Step 1: 基础定义
───────────────
D1. Happens-Before关系
    op1 <_H op2 ⟺ op1在op2之前执行

D2. 冲突操作
    Conflict(op_i, op_j) ⟺
      (op_i ≠ op_j) ∧
      (∃ x, {op_i, op_j} ⊆ {r(x), w(x)}) ∧
      (w(x) ∈ {op_i, op_j})

Step 2: 引理证明
───────────────
L3.08.1.1 读写冲突
    r_i(x) <_H w_j(x) ⇒ r_i读取的不是w_j写入的值

    证明：
      由<_H的定义，r_i在w_j之前执行
      ∴ r_i读取的是w_j之前的版本
      ∎

L3.08.1.2 写写冲突
    w_i(x) <_H w_j(x) ⇒ w_i的写入被w_j覆盖

    证明：
      由<_H的定义，w_i在w_j之前执行
      最终值由w_j决定
      ∎

L3.08.3.1 依赖图构造
    G = (T, E)
      T: 事务集合
      E: {(T_i, T_j) | ∃冲突操作 op_i ∈ T_i, op_j ∈ T_j, op_i <_H op_j}

    引理：G是有向图

    证明：显然 ∎

L3.08.3.2 无环充分性
    若G无环，则H是冲突可串行化的

    证明（拓扑排序）:
      G无环 ⇒ 存在拓扑序 T_1, T_2, ..., T_n
      构造串行历史 S：按拓扑序执行所有事务

      需证：H ≡_conflict S

      ∀ 冲突操作对 (op_i, op_j):
        G中有边 (T_i, T_j) ⇒ T_i在T_j前
        ∴ 在S中，op_i在op_j前
        ∴ 冲突顺序保持

      ∴ H ≡_conflict S ∎

Step 3: 主定理证明
───────────────
引理3.08.1 冲突等价性
    H ≡_conflict S ⇒ H和S在所有冲突操作上顺序相同

    证明：由定义 ∎

引理3.08.2 视图等价性
    H ≡_view S ⇒ H和S对所有读操作返回相同值

    证明：
      ∀ r_i(x) in H:
        设H中r_i(x)读取w_j(x)
        S中r_i(x)也读取w_j(x)（视图等价）
        ∴ 读取值相同
      ∎

引理3.08.3 CSR充分条件
    冲突可串行化 ⇒ 可串行化

    证明：
      设H是CSR，即∃串行历史S, H ≡_conflict S
      由引理3.08.1，冲突顺序相同
      由引理3.08.2，读取值相同
      ∴ H和S等价
      ∴ H可串行化
      ∎

定理3.08 可串行化充分性
    若H的依赖图无环，则H可串行化

    证明：
      依赖图无环
        ⇒ （由L3.08.3.2）H是CSR
        ⇒ （由引理3.08.3）H可串行化
      ∎

应用：
• 2PL保证无环（T4.01）
• MVCC+SSI保证无环（T4.07）
```

---

## 证明树2：MVCC快照隔离

```text
MVCC快照隔离证明树
══════════════════════════════════════════════════════════════════════════════

                    [定理T4.05]
              MVCC提供快照隔离（SI）
                        │
          ┌─────────────┼─────────────┐
          │             │             │
     [引理4.05.1]  [引理4.05.2]  [引理4.05.3]
     快照一致性    读取不变性    写隔离性
          │             │             │
    ┌─────┴─────┐       │       ┌─────┴─────┐
[L4.05.1.1]  [L4.05.1.2] │  [L4.05.3.1]  [L4.05.3.2]
版本链定义  可见性规则   │  版本创建    提交原子性
    │             │       │       │             │
    └─────────────┴───────┴───────┴─────────────┘
                        │
                 [定义D4.05]
               快照定义与规则
                        │
                 [公理A5]
              事务原子性公理

═══════════════════════════════════════════════════════════════

详细证明:

定义D4.05 快照
──────────────
快照 S_i = {(x, v, txn_id) | txn_id ≤ start_txn_id_i}

可见性规则:
  visible(tuple, snap) ⟺
    tuple.xmin ≤ snap.xmax ∧
    (tuple.xmax = 0 ∨ tuple.xmax > snap.xmax)

引理4.05.1 快照一致性
──────────────────────
事务T_i的所有读操作基于同一快照S_i

证明:
  设T_i在txn_id = N时开始
  定义S_i = {(x, v, t) | t ≤ N}

  ∀ r_i(x) in T_i:
    r_i(x)读取max{t | (x, v, t) ∈ S_i}的版本

  因为S_i在T_i开始时确定，不再变化
  ∴ 所有读操作基于同一快照
  ∎

引理4.05.2 读取不变性
──────────────────────
同一事务中多次读取同一数据项，返回相同值

证明:
  ∀ r_i(x) in T_i，两次读取

  第一次: r_i(x) 读取版本 (x, v1, t1)
    其中t1 = max{t | t ≤ N}

  第二次: r_i(x) 读取版本 (x, v2, t2)
    其中t2 = max{t | t ≤ N}

  因为S_i不变，t1 = t2
  ∴ v1 = v2
  ∎

引理4.05.3 写隔离性
──────────────────────
事务的写操作在提交前对其他事务不可见

证明:
  设T_i在txn_id = N+1写入
  设T_j是并发事务，start_txn_id_j = M

  Case 1: M < N+1 (T_j先开始)
    T_j的快照S_j只包含txn_id ≤ M的版本
    T_i的写入txn_id = N+1 > M
    ∴ T_i的写入不在S_j中
    ∴ T_j看不到T_i的写入

  Case 2: M = N+1 (T_j同时开始)
    T_j的快照S_j = {t ≤ N+1}
    但T_i未提交时，txn_id=N+1的版本不可见（uncommitted标记）
    ∴ T_j仍看不到

  Case 3: M > N+1 (T_j后开始)
    若T_i已提交，T_j可见T_i的写入（正常）
    若T_i未提交，T_j看不到（同Case 2）

  ∴ 提交前写隔离
  ∎

定理T4.05 MVCC快照隔离
─────────────────────
MVCC实现快照隔离（SI）

证明:
  快照隔离定义（Berenson et al. 1995）:
    1. 事务读操作基于一致快照 → 引理4.05.1 ✓
    2. 事务读同一项返回相同值 → 引理4.05.2 ✓
    3. 事务写在提交前不可见 → 引理4.05.3 ✓

  ∴ MVCC满足SI定义
  ∎
```

---

## 证明树3：查询优化正确性

```text
查询优化正确性证明树
══════════════════════════════════════════════════════════════════════════════

                  [定理T3.19]
            查询改写规则完备性
        所有等价查询可通过规则推导
                      │
        ┌─────────────┼─────────────┐
        │             │             │
   [引理3.19.1]  [引理3.19.2]  [引理3.19.3]
   规则正确性    规则完备性    终止性
        │             │             │
   ┌────┴────┐        │        ┌────┴────┐
[Rule1-8]  [...]      │    [规则应用] [...]
正确性证明            │    计数递减
        │             │             │
        └─────────────┴─────────────┘
                      │
               [定理T2.07]
            SELECT等价性定理
                      │
              [定理T1.01]
           关系代数完备性
                      │
               [公理A1]
            关系封闭性公理

═══════════════════════════════════════════════════════════════

8条重写规则证明:

规则1: 选择合并
───────────────
σ_p(σ_q(R)) ≡ σ_{p∧q}(R)

证明:
  ∀ 元组t

  t ∈ σ_p(σ_q(R))
  ⟺ t ∈ σ_q(R) ∧ p(t)  [选择定义]
  ⟺ t ∈ R ∧ q(t) ∧ p(t)  [选择定义]
  ⟺ t ∈ R ∧ (p ∧ q)(t)  [逻辑合取]
  ⟺ t ∈ σ_{p∧q}(R)  [选择定义]

  ∴ 两边等价 ∎

规则2: 选择下推（JOIN）
─────────────────────
σ_p(R ⋈ S) ≡ σ_p(R) ⋈ S  [条件：p只涉及R的列]

证明:
  设p = p_R（p只涉及R）

  σ_p(R ⋈ S)
  = σ_p(σ_{R.key=S.key}(R × S))  [JOIN定义]
  = σ_{R.key=S.key}(σ_p(R × S))  [选择交换，规则1应用]
  = σ_{R.key=S.key}(σ_p(R) × S)  [p只涉及R，选择提前]
  = σ_p(R) ⋈ S  [JOIN定义]
  ∎

规则3: 投影下推（JOIN）
─────────────────────
π_A(R ⋈ S) ≡ π_A(π_{A∪B}(R) ⋈ π_{A∪C}(S))
  [条件：B是R的JOIN列，C是S的JOIN列，A⊆B∪C]

证明:
  设JOIN条件为R.b = S.c，其中b∈B, c∈C

  左边：
    π_A(R ⋈ S)
    = {t[A] | t ∈ R ⋈ S}

  右边：
    π_A(π_{A∪B}(R) ⋈ π_{A∪C}(S))
    = {t[A] | t ∈ π_{A∪B}(R) ⋈ π_{A∪C}(S)}

  需证：对任意t[A]，左边有 ⟺ 右边有

  (⇒) 设t ∈ R ⋈ S
    令t_R = t[A∪B] ∈ π_{A∪B}(R)
    令t_S = t[A∪C] ∈ π_{A∪C}(S)
    则t_R ⋈ t_S = t
    ∴ t[A]在右边

  (⇐) 设t'[A]在右边
    则∃ t_R ∈ π_{A∪B}(R), t_S ∈ π_{A∪C}(S), t_R ⋈ t_S
    由投影定义，∃ t ∈ R ⋈ S, t[A∪B]=t_R, t[A∪C]=t_S
    ∴ t'[A] = t[A]在左边

  ∴ 两边等价 ∎

规则4: 投影消除
───────────────
π_A(π_B(R)) ≡ π_A(R)  [条件：A ⊆ B]

证明:
  π_A(π_B(R))
  = {t[A] | t ∈ π_B(R)}
  = {t[A] | ∃ s ∈ R, t = s[B]}
  = {s[B][A] | s ∈ R}
  = {s[A] | s ∈ R}  [因为A ⊆ B]
  = π_A(R)
  ∎

规则5: JOIN交换律
─────────────────
R ⋈_p S ≡ S ⋈_p R

证明:
  R ⋈_p S
  = σ_p(R × S)  [JOIN定义]
  = σ_p(S × R)  [笛卡尔积交换律]
  = S ⋈_p R  [JOIN定义]
  ∎

规则6: JOIN结合律
─────────────────
(R ⋈ S) ⋈ T ≡ R ⋈ (S ⋈ T)

证明:
  (R ⋈ S) ⋈ T
  = σ_{cond1}(σ_{cond2}(R × S) × T)  [展开JOIN]
  = σ_{cond1∧cond2}(R × S × T)  [选择合并]
  = σ_{cond2}(R × σ_{cond1}(S × T))  [条件分解]
  = R ⋈ (S ⋈ T)  [收缩JOIN]
  ∎

规则7: 子查询扁平化
─────────────────
SELECT * FROM R WHERE x IN (SELECT y FROM S)
≡
SELECT DISTINCT R.* FROM R, S WHERE R.x = S.y

证明:
  左边语义：
    {t_R | t_R ∈ R ∧ t_R.x ∈ π_y(S)}

  右边语义:
    {t_R | ∃ t_S ∈ S, t_R ∈ R ∧ t_R.x = t_S.y}

  (⇒) 设t_R满足左边
    ∃ t_S ∈ S, t_R.x = t_S.y （因为t_R.x ∈ π_y(S)）
    ∴ t_R满足右边

  (⇐) 设t_R满足右边
    ∃ t_S ∈ S, t_R.x = t_S.y
    ∴ t_R.x ∈ π_y(S)
    ∴ t_R满足左边

  ∴ 等价 ∎

规则8: 聚合下推
───────────────
SELECT SUM(x) FROM (SELECT x FROM R WHERE p)
≡
SELECT SUM(x) FROM R WHERE p

证明:
  左边：
    SUM(π_x(σ_p(R)))

  右边：
    SUM_p(R)  [带过滤的聚合]

  因为SUM只依赖x列，WHERE过滤不影响

  详细:
    左边 = Σ{t.x | t ∈ R ∧ p(t)}
    右边 = Σ{t.x | t ∈ R ∧ p(t)}

  ∴ 相等 ∎

定理T3.19 查询改写完备性
──────────────────────────
任意等价查询Q1和Q2，可通过有限次规则应用，将Q1转换为Q2

证明（归纳法）:
  基础：单表查询，规则1-4充分

  归纳：n表JOIN查询
    假设n-1表查询可转换
    对于n表：
      • 使用规则5-6调整JOIN顺序
      • 使用规则2-3下推选择/投影
      • 使用规则7-8简化子查询
      • 递归应用到子查询（n-1表）

  终止性：每次应用减少操作符数量或简化结构

  ∴ 有限步骤内可转换
  ∎
```

---

## 证明树4：B-Tree正确性

```text
B-Tree正确性证明树
══════════════════════════════════════════════════════════════════════════════

                  [定理T3.24]
             B-Tree平衡性不变式
         所有叶子深度相同且 ≤ ⌈log_b n⌉
                      │
        ┌─────────────┼─────────────┐
        │             │             │
   [引理3.24.1]  [引理3.24.2]  [引理3.24.3]
   插入保持平衡  删除保持平衡  搜索正确性
        │             │             │
   ┌────┴────┐   ┌────┴────┐       │
[分裂算法] [...]  [合并算法] [...]  [...]
   正确性          正确性
        │             │             │
        └─────────────┴─────────────┘
                      │
              [定义D3.24]
         B-Tree结构定义与不变式
                      │
             [算法A3.24]
         插入/删除/搜索算法

═══════════════════════════════════════════════════════════════

定义D3.24 B-Tree不变式
────────────────────
对于阶数为m的B-Tree:
  I1. 每个节点最多m个子节点
  I2. 非根内部节点至少⌈m/2⌉个子节点
  I3. 根节点至少2个子节点（除非是叶子）
  I4. 所有叶子在同一深度
  I5. 节点有k个子节点，则有k-1个键
  I6. 键保持有序

引理3.24.1 插入保持平衡
────────────────────────
插入操作后，不变式I1-I6仍然成立

证明（情况分析）:
  Case 1: 叶子未满（keys < m-1）
    直接插入，不变式不变 ✓

  Case 2: 叶子已满（keys = m-1）
    分裂为两个节点：
      Left: ⌈m/2⌉-1 键
      Right: ⌊m/2⌋ 键

    验证不变式:
      I1: Left和Right都≤m ✓
      I2: Left和Right都≥⌈m/2⌉-1 ✓
      I4: 深度不变（同级分裂） ✓
      I5: 父节点keys+1 ✓
      I6: 键保持有序 ✓

  Case 3: 分裂传播到根
    创建新根，深度+1
    I4: 所有叶子深度同时+1 ✓

  ∴ 插入保持不变式 ∎

引理3.24.2 删除保持平衡
────────────────────────
删除操作后，不变式I1-I6仍然成立

证明（情况分析）:
  Case 1: 删除后仍满足最小键数
    直接删除 ✓

  Case 2: 删除后低于最小键数
    Sub-case 2a: 兄弟节点有富余键
      借用键（Rotate）
      不变式保持 ✓

    Sub-case 2b: 兄弟节点无富余键
      合并节点（Merge）
      两节点 ⌈m/2⌉-1 + ⌈m/2⌉-1 < m ✓
      深度不变 ✓

  Case 3: 合并传播到根
    根只剩1个子节点→删除根，深度-1
    I4: 所有叶子深度同时-1 ✓

  ∴ 删除保持不变式 ∎

定理T3.24 B-Tree平衡性
────────────────────────
B-Tree始终保持平衡，高度 h ≤ ⌈log_⌈m/2⌉ n⌉

证明:
  由引理3.24.1和3.24.2，不变式I4始终成立
  ∴ 所有叶子深度相同（平衡）

  高度界限（归纳法）:
    基础(h=1): 根节点，最多m-1键 ✓

    归纳: 假设h层树最少有 ⌈m/2⌉^h - 1 键

    h+1层树:
      根: ≥2个子节点
      其他节点: ≥⌈m/2⌉个子节点
      最少键数: 2(⌈m/2⌉^(h-1) - 1) + (2⌈m/2⌉-2)(⌈m/2⌉^(h-1) - 1)
               = 2⌈m/2⌉^h - 2
               ≈ ⌈m/2⌉^(h+1)

    反过来，n个键最多需要h = ⌈log_⌈m/2⌉ n⌉

  ∴ 高度界限成立 ∎
```

---

**文档版本**: v1.0
**最后更新**: 2025-12-05
**证明树数量**: 4个核心定理
