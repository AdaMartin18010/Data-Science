# 并发控制形式化理论

> **创建日期**：2025-12-01
> **最后更新**：2025-12-01
> **版本**：v1.0.0
> **形式化层次**：L4-可验证
> **对标课程**：MIT 6.830, CMU 15-445
> **目的**：建立数据库并发控制的完整形式化理论体系

---

## 📋 目录

- [并发控制形式化理论](#并发控制形式化理论)
  - [📋 目录](#-目录)
  - [一、概述](#一概述)
    - [1.1 并发控制知识体系](#11-并发控制知识体系)
    - [1.2 因果链](#12-因果链)
  - [二、调度理论形式化](#二调度理论形式化)
    - [2.1 基本定义](#21-基本定义)
    - [2.2 可串行化理论](#22-可串行化理论)
    - [2.3 视图可串行化](#23-视图可串行化)
  - [三、两阶段锁协议形式化](#三两阶段锁协议形式化)
    - [3.1 锁的形式化定义](#31-锁的形式化定义)
    - [3.2 两阶段锁协议](#32-两阶段锁协议)
    - [3.3 锁粒度](#33-锁粒度)
  - [四、MVCC形式化](#四mvcc形式化)
    - [4.1 多版本存储模型](#41-多版本存储模型)
    - [4.2 快照隔离](#42-快照隔离)
    - [4.3 可串行化快照隔离](#43-可串行化快照隔离)
  - [五、死锁理论](#五死锁理论)
    - [5.1 死锁定义](#51-死锁定义)
    - [5.2 死锁检测](#52-死锁检测)
    - [5.3 死锁预防](#53-死锁预防)
  - [六、正确性证明](#六正确性证明)
    - [6.1 隔离级别正确性](#61-隔离级别正确性)
    - [6.2 综合正确性](#62-综合正确性)
  - [七、相关资源](#七相关资源)
    - [内部链接](#内部链接)
    - [外部资源](#外部资源)

---

## 一、概述

### 1.1 并发控制知识体系

```text
┌─────────────────────────────────────────────────────────────────────────┐
│                      并发控制形式化知识体系                               │
└─────────────────────────────────────────────────────────────────────────┘

                         并发控制
                             │
        ┌────────┬───────────┼───────────┬────────┐
        │        │           │           │        │
        ▼        ▼           ▼           ▼        ▼
    调度理论   锁协议     多版本      死锁     隔离级别
        │        │         控制        处理        │
    ┌───┴───┐   │      ┌───┴───┐  ┌───┴───┐      │
    │       │   │      │       │  │       │      │
    ▼       ▼   ▼      ▼       ▼  ▼       ▼      ▼
  冲突   视图  2PL   快照    SI   检测  预防   读已提交
  可串  可串  S2PL  隔离   SSI           WW    可重复读
  行化  行化                                   串行化
```

### 1.2 因果链

```text
并发执行需求
    │
    │ 导致
    ▼
正确性问题（更新丢失、脏读、不可重复读、幻读）
    │
    │ 解决方案
    ├──→ 锁机制 ──→ 2PL ──→ 冲突可串行化
    │
    └──→ 多版本 ──→ MVCC ──→ 快照隔离
              │
              └──→ SSI ──→ 可串行化
```

---

## 二、调度理论形式化

### 2.1 基本定义

```text
定义2.1 (事务)
──────────────

事务T是操作序列：
T = (o₁, o₂, ..., oₙ, c/a)

其中：
- oᵢ ∈ {r(x), w(x)} 读写操作
- c = commit, a = abort
- 最后必须是c或a

定义2.2 (调度)
──────────────

调度S是一组事务操作的全序排列，保持每个事务内部操作顺序

S = (T₁ ∪ T₂ ∪ ... ∪ Tₙ) 的一个全序

满足：∀Tᵢ, ∀oⱼ, oₖ ∈ Tᵢ: 若oⱼ <_Tᵢ oₖ 则 oⱼ <_S oₖ

定义2.3 (串行调度)
──────────────────

串行调度S_serial中，每个事务的所有操作连续执行

S_serial = T_{π(1)} · T_{π(2)} · ... · T_{π(n)}

其中π是事务的某个排列

定义2.4 (冲突操作)
──────────────────

两个操作冲突 ⟺
1. 它们属于不同事务
2. 它们访问同一数据项
3. 至少有一个是写操作

形式化：
conflict(oᵢ, oⱼ) ⟺
  trans(oᵢ) ≠ trans(oⱼ) ∧
  item(oᵢ) = item(oⱼ) ∧
  (oᵢ ∈ W ∨ oⱼ ∈ W)

冲突类型：
- 写-写 (WW): w₁(x), w₂(x)
- 读-写 (RW): r₁(x), w₂(x)
- 写-读 (WR): w₁(x), r₂(x)
```

### 2.2 可串行化理论

```text
定义2.5 (冲突等价)
──────────────────

调度S₁和S₂冲突等价 ⟺
1. 包含相同事务和操作
2. 所有冲突操作的相对顺序相同

定义2.6 (冲突可串行化)
──────────────────────

调度S是冲突可串行化的 ⟺
S冲突等价于某个串行调度

定义2.7 (优先图)
────────────────

调度S的优先图G(S) = (V, E)

V = {T₁, T₂, ..., Tₙ} (所有事务)
E = {(Tᵢ, Tⱼ) | 存在冲突操作oᵢ <_S oⱼ, oᵢ∈Tᵢ, oⱼ∈Tⱼ}

定理2.1 (冲突可串行化判定)
──────────────────────────

调度S是冲突可串行化的 ⟺ G(S)是无环的

证明：
─────
(⟹) 设S冲突等价于串行调度Sₛ = T_{i₁}·...·T_{iₙ}
    对任意边(Tᵢ, Tⱼ)∈E，存在冲突操作oᵢ <_S oⱼ
    在Sₛ中相对顺序相同，故Tᵢ在Tⱼ之前
    拓扑序为i₁, ..., iₙ，无环

(⟸) G(S)无环，存在拓扑序T_{i₁}, ..., T_{iₙ}
    构造串行调度Sₛ = T_{i₁}·...·T_{iₙ}
    对任意冲突操作对，由边定义和拓扑序，顺序保持
    故S冲突等价于Sₛ
Q.E.D.

算法2.1 (冲突可串行化判定)
──────────────────────────

Input: 调度S
Output: 是否冲突可串行化

1. 构造优先图G(S)
2. 检测G(S)是否有环（DFS/拓扑排序）
3. 无环则可串行化

复杂度: O(n² × m) 其中n=事务数, m=操作数
```

### 2.3 视图可串行化

```text
定义2.8 (视图等价)
──────────────────

调度S₁和S₂视图等价 ⟺
1. 相同的初始读：若Tᵢ在S₁中读取x的初始值，则在S₂中也是
2. 相同的读来源：若Tᵢ在S₁中读取Tⱼ写的x，则在S₂中也是
3. 相同的最终写：若Tᵢ在S₁中最后写x，则在S₂中也是

定义2.9 (视图可串行化)
──────────────────────

调度S是视图可串行化的 ⟺
S视图等价于某个串行调度

定理2.2 (视图可串行化包含冲突可串行化)
──────────────────────────────────────

冲突可串行化 ⟹ 视图可串行化

证明：
冲突等价保持读写来源关系
冲突等价 ⟹ 视图等价
故冲突可串行化 ⟹ 视图可串行化

注：反之不成立（视图可串行化判定是NP完全的）
```

---

## 三、两阶段锁协议形式化

### 3.1 锁的形式化定义

```text
定义3.1 (锁模式)
────────────────

锁模式集合 L = {S, X, ∅}
- S: 共享锁（读锁）
- X: 排他锁（写锁）
- ∅: 无锁

锁兼容矩阵：
┌─────┬─────┬─────┐
│     │  S  │  X  │
├─────┼─────┼─────┤
│  S  │ Yes │ No  │
│  X  │ No  │ No  │
└─────┴─────┴─────┘

定义3.2 (锁操作)
────────────────

lock_S(x): 请求x的共享锁
lock_X(x): 请求x的排他锁
unlock(x): 释放x的锁

锁操作语义：
lock_S(x):
  wait until ∀T': lock_X(x) ∉ held_by(T')
  add S(x) to held_by(T)

lock_X(x):
  wait until ∀T': (lock_S(x) ∉ held_by(T') ∧ lock_X(x) ∉ held_by(T'))
  add X(x) to held_by(T)

unlock(x):
  remove lock(x) from held_by(T)
```

### 3.2 两阶段锁协议

```text
定义3.3 (两阶段锁 - 2PL)
────────────────────────

事务T遵循2PL ⟺ T的执行分为两个阶段：

增长阶段(Growing Phase): 只能获取锁，不能释放
收缩阶段(Shrinking Phase): 只能释放锁，不能获取

形式化：
设lock_point(T)为T获取最后一个锁的时刻

∀ lock操作l, unlock操作u ∈ T:
  time(l) ≤ lock_point(T) ≤ time(u)

定理3.1 (2PL保证冲突可串行化)
────────────────────────────

若所有事务遵循2PL，则任何执行调度都是冲突可串行化的

证明：
─────
假设调度S不是冲突可串行化的
则优先图G(S)有环: T₁ → T₂ → ... → Tₖ → T₁

对于边Tᵢ → Tᵢ₊₁，存在冲突操作oᵢ <_S oᵢ₊₁

由冲突操作定义，访问同一数据项需要不兼容的锁
故: lock_point(Tᵢ) < lock_point(Tᵢ₊₁)

沿环传递:
lock_point(T₁) < lock_point(T₂) < ... < lock_point(Tₖ) < lock_point(T₁)

矛盾！故不存在环，S是冲突可串行化的
Q.E.D.

定义3.4 (严格两阶段锁 - S2PL)
────────────────────────────

事务T遵循S2PL ⟺
1. T遵循2PL
2. T的所有排他锁在commit后才释放

优势：避免级联回滚

定义3.5 (强两阶段锁 - SS2PL)
────────────────────────────

事务T遵循SS2PL ⟺
1. T遵循2PL
2. T的所有锁在commit后才释放

优势：可恢复性 + 避免级联回滚
```

### 3.3 锁粒度

```text
定义3.6 (意向锁)
────────────────

意向锁用于多粒度锁定

意向锁类型：
- IS: 意向共享锁（意图在子节点获取S锁）
- IX: 意向排他锁（意图在子节点获取X锁）
- SIX: 共享+意向排他（持有S锁，意图在子节点获取X锁）

意向锁兼容矩阵：
┌─────┬─────┬─────┬─────┬─────┬─────┐
│     │ IS  │ IX  │  S  │ SIX │  X  │
├─────┼─────┼─────┼─────┼─────┼─────┤
│ IS  │ Yes │ Yes │ Yes │ Yes │ No  │
│ IX  │ Yes │ Yes │ No  │ No  │ No  │
│ S   │ Yes │ No  │ Yes │ No  │ No  │
│ SIX │ Yes │ No  │ No  │ No  │ No  │
│ X   │ No  │ No  │ No  │ No  │ No  │
└─────┴─────┴─────┴─────┴─────┴─────┘

锁定协议：
1. 锁定节点前，必须先锁定其所有祖先
2. 对祖先使用意向锁，对目标使用实际锁
3. 解锁时自底向上
```

---

## 四、MVCC形式化

### 4.1 多版本存储模型

```text
定义4.1 (版本)
──────────────

数据项x的版本v = (value, ts_begin, ts_end)

- value: 值
- ts_begin: 创建时间戳
- ts_end: 失效时间戳（∞表示当前有效）

版本链：每个数据项维护版本历史
versions(x) = [v₁, v₂, ..., vₙ] 按ts_begin排序

定义4.2 (快照)
──────────────

事务T在时间戳ts的快照：
snapshot(T, ts) = {(x, v) | v ∈ versions(x) ∧
                           ts_begin(v) ≤ ts < ts_end(v)}

定义4.3 (可见性规则)
────────────────────

版本v对事务T可见 ⟺
1. v.ts_begin < T.ts_begin (版本在T开始前创建)
2. v.ts_end > T.ts_begin 或 v.ts_end = ∞ (版本在T开始时有效)
3. 创建v的事务已提交
```

### 4.2 快照隔离

```text
定义4.4 (快照隔离 - SI)
──────────────────────

事务T在SI下执行：

1. 开始时获取快照: T.snapshot := current_ts()

2. 读操作: read(x)
   返回snapshot(T, T.snapshot)中x的值

3. 写操作: write(x, v)
   创建新版本，ts_begin = T.commit_ts

4. 提交: commit(T)
   First-Committer-Wins规则：
   若∃T'已提交，T'.ts_begin < T.ts_begin < T'.ts_commit
   且 write_set(T) ∩ write_set(T') ≠ ∅
   则abort(T)

定理4.1 (SI防止异常)
────────────────────

快照隔离防止以下异常：
✓ 脏读 (Dirty Read)
✓ 不可重复读 (Non-repeatable Read)
✓ 幻读 (Phantom Read)  [对读取的数据]
✗ 写偏序 (Write Skew)

证明（脏读）：
事务只读取已提交版本，故不会读到未提交数据

证明（不可重复读）：
事务使用固定快照，多次读取返回相同值
```

### 4.3 可串行化快照隔离

```text
定义4.5 (SSI - Serializable Snapshot Isolation)
──────────────────────────────────────────────

SSI在SI基础上检测危险结构：

危险结构定义：
存在三个事务T₁, T₂, T₃（可能T₁=T₃）形成：
T₁ --rw--> T₂ --rw--> T₃

其中rw边表示：T_i读取的数据被T_j修改

检测规则：
1. 跟踪in-conflict: 有事务读取了我写的数据
2. 跟踪out-conflict: 我读取的数据被其他事务写了
3. 若事务同时有in和out conflict，abort

定理4.2 (SSI正确性)
────────────────────

SSI保证可串行化

证明大纲：
假设存在非可串行化执行
则序列化图有环
环中必存在两个连续rw边（危险结构）
SSI检测到并abort
矛盾
Q.E.D.
```

---

## 五、死锁理论

### 5.1 死锁定义

```text
定义5.1 (等待图)
────────────────

等待图WG = (V, E)

V = {T₁, ..., Tₙ} (活跃事务)
E = {(Tᵢ, Tⱼ) | Tᵢ等待Tⱼ持有的锁}

定义5.2 (死锁)
──────────────

死锁存在 ⟺ WG有环

形式化：
∃ T₁, ..., Tₖ: T₁ waits T₂ waits ... waits Tₖ waits T₁

定理5.1 (死锁必要条件)
──────────────────────

死锁发生当且仅当同时满足：
1. 互斥: 资源不共享
2. 持有等待: 持有资源同时等待其他资源
3. 不可抢占: 资源不能被强制释放
4. 循环等待: 存在循环等待链
```

### 5.2 死锁检测

```text
算法5.1 (死锁检测)
──────────────────

定期执行：
1. 构建等待图WG
2. 检测环（DFS）
3. 若存在环，选择牺牲者abort

牺牲者选择策略：
- 最年轻事务（最少工作量）
- 最少锁持有者
- 已重试次数最少者

复杂度: O(V + E) = O(n + n²) = O(n²)
```

### 5.3 死锁预防

```text
算法5.2 (Wait-Die)
──────────────────

当Tᵢ请求Tⱼ持有的锁：
if ts(Tᵢ) < ts(Tⱼ) then  // Tᵢ更老
    Tᵢ waits
else
    abort(Tᵢ)  // Tᵢ更年轻，让它死

性质：只允许老→新方向等待，无环

算法5.3 (Wound-Wait)
────────────────────

当Tᵢ请求Tⱼ持有的锁：
if ts(Tᵢ) < ts(Tⱼ) then  // Tᵢ更老
    abort(Tⱼ)  // 伤害年轻的
else
    Tᵢ waits   // 年轻的等老的

性质：只允许新→老方向等待，无环

定理5.2 (预防正确性)
────────────────────

Wait-Die和Wound-Wait都保证无死锁

证明(Wait-Die)：
假设存在环 T₁ waits T₂ waits ... waits Tₖ waits T₁
由Wait-Die规则: ts(T₁) < ts(T₂) < ... < ts(Tₖ) < ts(T₁)
矛盾！
Q.E.D.
```

---

## 六、正确性证明

### 6.1 隔离级别正确性

```text
定理6.1 (隔离级别层次)
──────────────────────

READ UNCOMMITTED ⊂ READ COMMITTED ⊂ REPEATABLE READ ⊂ SERIALIZABLE

每个级别防止的异常：
┌─────────────────────┬─────┬─────────┬─────┬──────────┐
│ 隔离级别             │脏读 │不可重复读│幻读 │写偏序    │
├─────────────────────┼─────┼─────────┼─────┼──────────┤
│ READ UNCOMMITTED    │ ✗   │ ✗       │ ✗   │ ✗        │
│ READ COMMITTED      │ ✓   │ ✗       │ ✗   │ ✗        │
│ REPEATABLE READ     │ ✓   │ ✓       │ ✗   │ ✗        │
│ SERIALIZABLE        │ ✓   │ ✓       │ ✓   │ ✓        │
└─────────────────────┴─────┴─────────┴─────┴──────────┘

定理6.2 (SERIALIZABLE等价可串行化)
──────────────────────────────────

SERIALIZABLE隔离级别的调度是可串行化的

证明：
SERIALIZABLE使用S2PL或SSI
两者都保证可串行化（定理3.1, 4.2）
Q.E.D.
```

### 6.2 综合正确性

```text
定理6.3 (并发控制正确性)
────────────────────────

正确的并发控制保证：
1. 一致性: 事务将数据库从一致状态转换到另一致状态
2. 隔离性: 并发事务不相互干扰
3. 可恢复性: 系统可从故障中恢复

证明框架：
1. 使用可串行化调度
2. 使用WAL确保持久性
3. 使用ARIES恢复算法
综合保证ACID
```

---

## 七、相关资源

### 内部链接

- [事务理论](../01-理论基础/01.05-事务理论.md)
- [SQL形式化语义](./03.01-SQL形式化语义.md)
- [执行引擎形式化理论](./03.08-执行引擎形式化理论.md)

### 外部资源

- Bernstein, P.A. "Concurrency Control and Recovery in Database Systems"
- Weikum, G. "Transactional Information Systems"
- MIT 6.830 Lecture Notes
- CMU 15-445 Lecture Notes

---

**维护者**: SQL Standards Team
**创建日期**: 2025-12-01
**对标课程**: MIT 6.830, CMU 15-445
