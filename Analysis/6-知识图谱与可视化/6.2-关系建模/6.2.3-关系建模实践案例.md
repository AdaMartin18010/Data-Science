# å…³ç³»å»ºæ¨¡å®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [å…³ç³»å»ºæ¨¡å®è·µæ¡ˆä¾‹](#å…³ç³»å»ºæ¨¡å®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2. å­¦æœ¯çŸ¥è¯†å›¾è°±å…³ç³»å»ºæ¨¡](#2-å­¦æœ¯çŸ¥è¯†å›¾è°±å…³ç³»å»ºæ¨¡)
    - [2.1. è®ºæ–‡å¼•ç”¨å…³ç³»å»ºæ¨¡](#21-è®ºæ–‡å¼•ç”¨å…³ç³»å»ºæ¨¡)
  - [3. å­¦ç§‘çŸ¥è¯†å›¾è°±æ„å»º](#3-å­¦ç§‘çŸ¥è¯†å›¾è°±æ„å»º)
  - [4. ä¼ä¸šçŸ¥è¯†å›¾è°±å…³ç³»å»ºæ¨¡](#4-ä¼ä¸šçŸ¥è¯†å›¾è°±å…³ç³»å»ºæ¨¡)
    - [4.1. ç»„ç»‡æ¶æ„å…³ç³»å»ºæ¨¡](#41-ç»„ç»‡æ¶æ„å…³ç³»å»ºæ¨¡)
  - [5. äº§å“çŸ¥è¯†å›¾è°±å»ºæ¨¡](#5-äº§å“çŸ¥è¯†å›¾è°±å»ºæ¨¡)
  - [6. ç¤¾äº¤ç½‘ç»œå…³ç³»å»ºæ¨¡](#6-ç¤¾äº¤ç½‘ç»œå…³ç³»å»ºæ¨¡)
    - [6.1. ç”¨æˆ·å…³ç³»ç½‘ç»œå»ºæ¨¡](#61-ç”¨æˆ·å…³ç³»ç½‘ç»œå»ºæ¨¡)
  - [7. æ€»ç»“](#7-æ€»ç»“)

---


## 1. æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›çŸ¥è¯†å›¾è°±å…³ç³»å»ºæ¨¡çš„å®è·µåº”ç”¨æ¡ˆä¾‹ï¼Œæ¶µç›–å­¦æœ¯çŸ¥è¯†å›¾è°±ã€ä¼ä¸šçŸ¥è¯†å›¾è°±ã€ç¤¾äº¤ç½‘ç»œåˆ†æç­‰å®é™…åœºæ™¯ã€‚

## 2. å­¦æœ¯çŸ¥è¯†å›¾è°±å…³ç³»å»ºæ¨¡

### 2.1. è®ºæ–‡å¼•ç”¨å…³ç³»å»ºæ¨¡

```python
import networkx as nx
import matplotlib.pyplot as plt
from typing import Dict, List, Tuple

class AcademicKnowledgeGraph:
    def __init__(self):
        self.graph = nx.DiGraph()
        self.papers = {}
        self.authors = {}
        self.venues = {}

    def add_paper(self, paper_id: str, title: str, authors: List[str],
                  venue: str, year: int, citations: List[str] = None):
        """æ·»åŠ è®ºæ–‡èŠ‚ç‚¹"""
        self.papers[paper_id] = {
            'title': title,
            'authors': authors,
            'venue': venue,
            'year': year
        }

# æ·»åŠ è®ºæ–‡èŠ‚ç‚¹
        self.graph.add_node(paper_id,
                           type='paper',
                           title=title,
                           year=year)

# æ·»åŠ ä½œè€…å…³ç³»
        for author in authors:
            if author not in self.authors:
                self.authors[author] = []
            self.authors[author].append(paper_id)
            self.graph.add_node(author, type='author')
            self.graph.add_edge(author, paper_id, relation='wrote')

# æ·»åŠ å¼•ç”¨å…³ç³»
        if citations:
            for cited_paper in citations:
                if cited_paper in self.papers:
                    self.graph.add_edge(paper_id, cited_paper, relation='cites')

    def get_paper_citations(self, paper_id: str) -> List[str]:
        """è·å–è®ºæ–‡çš„å¼•ç”¨åˆ—è¡¨"""
        if paper_id in self.graph:
            return list(self.graph.predecessors(paper_id))
        return []

    def get_paper_references(self, paper_id: str) -> List[str]:
        """è·å–è®ºæ–‡çš„å‚è€ƒæ–‡çŒ®åˆ—è¡¨"""
        if paper_id in self.graph:
            return list(self.graph.successors(paper_id))
        return []

    def calculate_h_index(self, author: str) -> int:
        """è®¡ç®—ä½œè€…çš„hæŒ‡æ•°"""
        if author not in self.authors:
            return 0

        paper_ids = self.authors[author]
        citation_counts = []

        for paper_id in paper_ids:
            citations = len(self.get_paper_citations(paper_id))
            citation_counts.append(citations)

        citation_counts.sort(reverse=True)
        h_index = 0
        for i, count in enumerate(citation_counts):
            if count >= i + 1:
                h_index = i + 1
            else:
                break

        return h_index

    def find_influential_papers(self, top_k: int = 10) -> List[Tuple[str, int]]:
        """æ‰¾åˆ°æœ€æœ‰å½±å“åŠ›çš„è®ºæ–‡ï¼ˆåŸºäºè¢«å¼•ç”¨æ¬¡æ•°ï¼‰"""
        paper_influence = []
        for paper_id in self.papers:
            citations = len(self.get_paper_citations(paper_id))
            paper_influence.append((paper_id, citations))

        paper_influence.sort(key=lambda x: x[1], reverse=True)
        return paper_influence[:top_k]

    def visualize_citation_network(self, paper_id: str, depth: int = 2):
        """å¯è§†åŒ–è®ºæ–‡çš„å¼•ç”¨ç½‘ç»œ"""
        subgraph = nx.DiGraph()
        nodes_to_add = {paper_id}

# æ„å»ºå­å›¾
        for _ in range(depth):
            new_nodes = set()
            for node in nodes_to_add:
                if node in self.graph:
                    subgraph.add_node(node, **self.graph.nodes[node])
                    for neighbor in self.graph.predecessors(node):
                        subgraph.add_node(neighbor, **self.graph.nodes[neighbor])
                        subgraph.add_edge(node, neighbor, **self.graph.edges[node, neighbor])
                        new_nodes.add(neighbor)
                    for neighbor in self.graph.successors(node):
                        subgraph.add_node(neighbor, **self.graph.nodes[neighbor])
                        subgraph.add_edge(neighbor, node, **self.graph.edges[neighbor, node])
                        new_nodes.add(neighbor)
            nodes_to_add = new_nodes

# ç»˜åˆ¶ç½‘ç»œ
        plt.figure(figsize=(12, 8))
        pos = nx.spring_layout(subgraph)

# ç»˜åˆ¶èŠ‚ç‚¹
        nx.draw_networkx_nodes(subgraph, pos,
                              node_color='lightblue',
                              node_size=1000)

# ç»˜åˆ¶è¾¹
        nx.draw_networkx_edges(subgraph, pos,
                              edge_color='gray',
                              arrows=True,
                              arrowsize=20)

# æ·»åŠ æ ‡ç­¾
        labels = {node: self.papers.get(node, {}).get('title', node)[:20]
                 for node in subgraph.nodes()}
        nx.draw_networkx_labels(subgraph, pos, labels, font_size=8)

        plt.title(f"è®ºæ–‡å¼•ç”¨ç½‘ç»œ: {self.papers[paper_id]['title']}")
        plt.axis('off')
        plt.show()

# ä½¿ç”¨ç¤ºä¾‹
academic_kg = AcademicKnowledgeGraph()

# æ·»åŠ è®ºæ–‡æ•°æ®
academic_kg.add_paper("P1", "æ·±åº¦å­¦ä¹ åŸºç¡€", ["å¼ ä¸‰", "æå››"], "ICML", 2020, ["P2", "P3"])
academic_kg.add_paper("P2", "ç¥ç»ç½‘ç»œç†è®º", ["ç‹äº”"], "NIPS", 2019, ["P3"])
academic_kg.add_paper("P3", "æœºå™¨å­¦ä¹ å…¥é—¨", ["å¼ ä¸‰"], "JMLR", 2018)

# è®¡ç®—hæŒ‡æ•°
h_index = academic_kg.calculate_h_index("å¼ ä¸‰")
print(f"å¼ ä¸‰çš„hæŒ‡æ•°: {h_index}")

# æ‰¾åˆ°æœ€æœ‰å½±å“åŠ›çš„è®ºæ–‡
influential = academic_kg.find_influential_papers(3)
print("æœ€æœ‰å½±å“åŠ›çš„è®ºæ–‡:", influential)
```

## 3. å­¦ç§‘çŸ¥è¯†å›¾è°±æ„å»º

```python
class SubjectKnowledgeGraph:
    def __init__(self):
        self.graph = nx.Graph()
        self.concepts = {}
        self.relationships = {}

    def add_concept(self, concept_id: str, name: str, category: str,
                   description: str = ""):
        """æ·»åŠ æ¦‚å¿µèŠ‚ç‚¹"""
        self.concepts[concept_id] = {
            'name': name,
            'category': category,
            'description': description
        }
        self.graph.add_node(concept_id,
                           name=name,
                           category=category,
                           description=description)

    def add_relationship(self, concept1: str, concept2: str,
                        relation_type: str, weight: float = 1.0):
        """æ·»åŠ æ¦‚å¿µé—´å…³ç³»"""
        if concept1 in self.concepts and concept2 in self.concepts:
            self.graph.add_edge(concept1, concept2,
                               relation=relation_type,
                               weight=weight)

            if relation_type not in self.relationships:
                self.relationships[relation_type] = []
            self.relationships[relation_type].append((concept1, concept2))

    def find_related_concepts(self, concept_id: str, max_distance: int = 2) -> List[str]:
        """æ‰¾åˆ°ç›¸å…³æ¦‚å¿µ"""
        if concept_id not in self.graph:
            return []

        related = set()
        for node in nx.single_source_shortest_path_length(self.graph, concept_id,
                                                         cutoff=max_distance):
            if node != concept_id:
                related.add(node)

        return list(related)

    def get_concept_clusters(self) -> Dict[str, List[str]]:
        """è·å–æ¦‚å¿µèšç±»"""
        clusters = {}
        components = list(nx.connected_components(self.graph))

        for i, component in enumerate(components):
            cluster_name = f"Cluster_{i+1}"
            clusters[cluster_name] = list(component)

        return clusters

    def calculate_concept_centrality(self) -> Dict[str, float]:
        """è®¡ç®—æ¦‚å¿µä¸­å¿ƒæ€§"""
        centrality = nx.betweenness_centrality(self.graph)
        return centrality

    def find_central_concepts(self, top_k: int = 10) -> List[Tuple[str, float]]:
        """æ‰¾åˆ°æ ¸å¿ƒæ¦‚å¿µ"""
        centrality = self.calculate_concept_centrality()
        sorted_concepts = sorted(centrality.items(),
                               key=lambda x: x[1], reverse=True)
        return sorted_concepts[:top_k]

# ä½¿ç”¨ç¤ºä¾‹
subject_kg = SubjectKnowledgeGraph()

# æ·»åŠ è®¡ç®—æœºç§‘å­¦æ¦‚å¿µ
subject_kg.add_concept("CS1", "ç®—æ³•", "è®¡ç®—æœºç§‘å­¦", "è§£å†³é—®é¢˜çš„æ­¥éª¤")
subject_kg.add_concept("CS2", "æ•°æ®ç»“æ„", "è®¡ç®—æœºç§‘å­¦", "æ•°æ®çš„ç»„ç»‡æ–¹å¼")
subject_kg.add_concept("CS3", "ç¼–ç¨‹è¯­è¨€", "è®¡ç®—æœºç§‘å­¦", "ä¸è®¡ç®—æœºé€šä¿¡çš„å·¥å…·")
subject_kg.add_concept("CS4", "æ•°æ®åº“", "è®¡ç®—æœºç§‘å­¦", "æ•°æ®å­˜å‚¨å’Œç®¡ç†")
subject_kg.add_concept("CS5", "ç½‘ç»œ", "è®¡ç®—æœºç§‘å­¦", "è®¡ç®—æœºé—´çš„é€šä¿¡")

# æ·»åŠ å…³ç³»
subject_kg.add_relationship("CS1", "CS2", "ä¾èµ–", 0.8)
subject_kg.add_relationship("CS3", "CS1", "å®ç°", 0.9)
subject_kg.add_relationship("CS4", "CS2", "åº”ç”¨", 0.7)
subject_kg.add_relationship("CS5", "CS3", "æ”¯æŒ", 0.6)

# æ‰¾åˆ°æ ¸å¿ƒæ¦‚å¿µ
central_concepts = subject_kg.find_central_concepts(3)
print("æ ¸å¿ƒæ¦‚å¿µ:", central_concepts)
```

## 4. ä¼ä¸šçŸ¥è¯†å›¾è°±å…³ç³»å»ºæ¨¡

### 4.1. ç»„ç»‡æ¶æ„å…³ç³»å»ºæ¨¡

```python
class OrganizationKnowledgeGraph:
    def __init__(self):
        self.graph = nx.DiGraph()
        self.employees = {}
        self.departments = {}
        self.projects = {}

    def add_employee(self, emp_id: str, name: str, title: str,
                    department: str, skills: List[str] = None):
        """æ·»åŠ å‘˜å·¥èŠ‚ç‚¹"""
        self.employees[emp_id] = {
            'name': name,
            'title': title,
            'department': department,
            'skills': skills or []
        }

        self.graph.add_node(emp_id,
                           type='employee',
                           name=name,
                           title=title,
                           department=department,
                           skills=skills or [])

# æ·»åŠ éƒ¨é—¨å…³ç³»
        if department not in self.departments:
            self.departments[department] = []
        self.departments[department].append(emp_id)
        self.graph.add_node(department, type='department')
        self.graph.add_edge(emp_id, department, relation='belongs_to')

    def add_project(self, project_id: str, name: str,
                   team_members: List[str], manager: str):
        """æ·»åŠ é¡¹ç›®èŠ‚ç‚¹"""
        self.projects[project_id] = {
            'name': name,
            'team_members': team_members,
            'manager': manager
        }

        self.graph.add_node(project_id,
                           type='project',
                           name=name,
                           manager=manager)

# æ·»åŠ é¡¹ç›®å…³ç³»
        for member in team_members:
            if member in self.employees:
                self.graph.add_edge(member, project_id, relation='works_on')

        if manager in self.employees:
            self.graph.add_edge(manager, project_id, relation='manages')

    def add_collaboration(self, emp1: str, emp2: str,
                         project: str, collaboration_type: str):
        """æ·»åŠ åä½œå…³ç³»"""
        if emp1 in self.employees and emp2 in self.employees:
            self.graph.add_edge(emp1, emp2,
                               relation='collaborates_with',
                               project=project,
                               type=collaboration_type)

    def find_team_members(self, project_id: str) -> List[str]:
        """æ‰¾åˆ°é¡¹ç›®å›¢é˜Ÿæˆå‘˜"""
        if project_id in self.graph:
            return list(self.graph.predecessors(project_id))
        return []

    def find_employee_projects(self, emp_id: str) -> List[str]:
        """æ‰¾åˆ°å‘˜å·¥å‚ä¸çš„é¡¹ç›®"""
        if emp_id in self.graph:
            return list(self.graph.successors(emp_id))
        return []

    def find_skill_experts(self, skill: str) -> List[str]:
        """æ‰¾åˆ°æŠ€èƒ½ä¸“å®¶"""
        experts = []
        for emp_id, emp_data in self.employees.items():
            if skill in emp_data.get('skills', []):
                experts.append(emp_id)
        return experts

    def calculate_employee_centrality(self) -> Dict[str, float]:
        """è®¡ç®—å‘˜å·¥ä¸­å¿ƒæ€§"""
        centrality = nx.betweenness_centrality(self.graph)
        return {emp_id: centrality.get(emp_id, 0)
                for emp_id in self.employees}

    def find_key_employees(self, top_k: int = 5) -> List[Tuple[str, float]]:
        """æ‰¾åˆ°å…³é”®å‘˜å·¥"""
        centrality = self.calculate_employee_centrality()
        sorted_employees = sorted(centrality.items(),
                                key=lambda x: x[1], reverse=True)
        return sorted_employees[:top_k]

# ä½¿ç”¨ç¤ºä¾‹
org_kg = OrganizationKnowledgeGraph()

# æ·»åŠ å‘˜å·¥
org_kg.add_employee("E1", "å¼ ä¸‰", "è½¯ä»¶å·¥ç¨‹å¸ˆ", "æŠ€æœ¯éƒ¨", ["Python", "Java"])
org_kg.add_employee("E2", "æå››", "é¡¹ç›®ç»ç†", "æŠ€æœ¯éƒ¨", ["é¡¹ç›®ç®¡ç†", "æ•æ·"])
org_kg.add_employee("E3", "ç‹äº”", "æ•°æ®ç§‘å­¦å®¶", "æ•°æ®éƒ¨", ["Python", "æœºå™¨å­¦ä¹ "])

# æ·»åŠ é¡¹ç›®
org_kg.add_project("P1", "AIå¹³å°å¼€å‘", ["E1", "E3"], "E2")

# æ·»åŠ åä½œå…³ç³»
org_kg.add_collaboration("E1", "E3", "P1", "æŠ€æœ¯åä½œ")

# æ‰¾åˆ°å…³é”®å‘˜å·¥
key_employees = org_kg.find_key_employees(3)
print("å…³é”®å‘˜å·¥:", key_employees)

# æ‰¾åˆ°æŠ€èƒ½ä¸“å®¶
python_experts = org_kg.find_skill_experts("Python")
print("Pythonä¸“å®¶:", python_experts)
```

## 5. äº§å“çŸ¥è¯†å›¾è°±å»ºæ¨¡

```python
class ProductKnowledgeGraph:
    def __init__(self):
        self.graph = nx.Graph()
        self.products = {}
        self.features = {}
        self.categories = {}

    def add_product(self, product_id: str, name: str, category: str,
                   price: float, features: List[str] = None):
        """æ·»åŠ äº§å“èŠ‚ç‚¹"""
        self.products[product_id] = {
            'name': name,
            'category': category,
            'price': price,
            'features': features or []
        }

        self.graph.add_node(product_id,
                           type='product',
                           name=name,
                           category=category,
                           price=price)

# æ·»åŠ ç‰¹å¾å…³ç³»
        if features:
            for feature in features:
                if feature not in self.features:
                    self.features[feature] = []
                self.features[feature].append(product_id)
                self.graph.add_node(feature, type='feature')
                self.graph.add_edge(product_id, feature, relation='has_feature')

# æ·»åŠ åˆ†ç±»å…³ç³»
        if category not in self.categories:
            self.categories[category] = []
        self.categories[category].append(product_id)
        self.graph.add_node(category, type='category')
        self.graph.add_edge(product_id, category, relation='belongs_to')

    def add_similarity(self, product1: str, product2: str, similarity_score: float):
        """æ·»åŠ äº§å“ç›¸ä¼¼æ€§å…³ç³»"""
        if product1 in self.products and product2 in self.products:
            self.graph.add_edge(product1, product2,
                               relation='similar_to',
                               similarity=similarity_score)

    def find_similar_products(self, product_id: str, threshold: float = 0.5) -> List[Tuple[str, float]]:
        """æ‰¾åˆ°ç›¸ä¼¼äº§å“"""
        if product_id not in self.graph:
            return []

        similar_products = []
        for neighbor in self.graph.neighbors(product_id):
            edge_data = self.graph.edges[product_id, neighbor]
            if (edge_data.get('relation') == 'similar_to' and
                edge_data.get('similarity', 0) >= threshold):
                similar_products.append((neighbor, edge_data['similarity']))

        similar_products.sort(key=lambda x: x[1], reverse=True)
        return similar_products

    def find_products_by_feature(self, feature: str) -> List[str]:
        """æ ¹æ®ç‰¹å¾æ‰¾åˆ°äº§å“"""
        return self.features.get(feature, [])

    def find_products_by_category(self, category: str) -> List[str]:
        """æ ¹æ®åˆ†ç±»æ‰¾åˆ°äº§å“"""
        return self.categories.get(category, [])

    def get_product_recommendations(self, user_features: List[str],
                                  top_k: int = 5) -> List[Tuple[str, float]]:
        """åŸºäºç”¨æˆ·ç‰¹å¾æ¨èäº§å“"""
        recommendations = {}

        for feature in user_features:
            products = self.find_products_by_feature(feature)
            for product_id in products:
                if product_id not in recommendations:
                    recommendations[product_id] = 0
                recommendations[product_id] += 1

# è®¡ç®—æ¨èåˆ†æ•°
        sorted_recommendations = sorted(recommendations.items(),
                                      key=lambda x: x[1], reverse=True)
        return sorted_recommendations[:top_k]

# ä½¿ç”¨ç¤ºä¾‹
product_kg = ProductKnowledgeGraph()

# æ·»åŠ äº§å“
product_kg.add_product("P1", "iPhone 13", "æ‰‹æœº", 5999.0,
                      ["5G", "A15èŠ¯ç‰‡", "è¶…å¹¿è§’ç›¸æœº"])
product_kg.add_product("P2", "Samsung S21", "æ‰‹æœº", 4999.0,
                      ["5G", "éªé¾™888", "è¶…å¹¿è§’ç›¸æœº"])
product_kg.add_product("P3", "MacBook Pro", "ç¬”è®°æœ¬", 12999.0,
                      ["M1èŠ¯ç‰‡", "Retinaæ˜¾ç¤ºå±"])

# æ·»åŠ ç›¸ä¼¼æ€§å…³ç³»
product_kg.add_similarity("P1", "P2", 0.8)
product_kg.add_similarity("P1", "P3", 0.3)

# æ‰¾åˆ°ç›¸ä¼¼äº§å“
similar = product_kg.find_similar_products("P1", 0.5)
print("ä¸iPhone 13ç›¸ä¼¼çš„äº§å“:", similar)

# åŸºäºç‰¹å¾æ¨è
recommendations = product_kg.get_product_recommendations(["5G", "è¶…å¹¿è§’ç›¸æœº"], 3)
print("æ¨èäº§å“:", recommendations)
```

## 6. ç¤¾äº¤ç½‘ç»œå…³ç³»å»ºæ¨¡

### 6.1. ç”¨æˆ·å…³ç³»ç½‘ç»œå»ºæ¨¡

```python
class SocialNetworkGraph:
    def __init__(self):
        self.graph = nx.Graph()
        self.users = {}
        self.posts = {}
        self.interactions = {}

    def add_user(self, user_id: str, name: str, interests: List[str] = None):
        """æ·»åŠ ç”¨æˆ·èŠ‚ç‚¹"""
        self.users[user_id] = {
            'name': name,
            'interests': interests or []
        }

        self.graph.add_node(user_id,
                           type='user',
                           name=name,
                           interests=interests or [])

    def add_friendship(self, user1: str, user2: str, friendship_type: str = "friend"):
        """æ·»åŠ å¥½å‹å…³ç³»"""
        if user1 in self.users and user2 in self.users:
            self.graph.add_edge(user1, user2,
                               relation='friend',
                               type=friendship_type)

    def add_post(self, post_id: str, author: str, content: str,
                tags: List[str] = None):
        """æ·»åŠ å¸–å­èŠ‚ç‚¹"""
        self.posts[post_id] = {
            'author': author,
            'content': content,
            'tags': tags or []
        }

        self.graph.add_node(post_id,
                           type='post',
                           author=author,
                           content=content,
                           tags=tags or [])

# æ·»åŠ ä½œè€…å…³ç³»
        if author in self.users:
            self.graph.add_edge(author, post_id, relation='authored')

    def add_interaction(self, user: str, post: str, interaction_type: str):
        """æ·»åŠ ç”¨æˆ·ä¸å¸–å­çš„äº¤äº’"""
        if user in self.users and post in self.posts:
            self.graph.add_edge(user, post,
                               relation='interacted',
                               type=interaction_type)

    def find_friends(self, user_id: str) -> List[str]:
        """æ‰¾åˆ°ç”¨æˆ·çš„å¥½å‹"""
        if user_id in self.graph:
            return list(self.graph.neighbors(user_id))
        return []

    def find_common_friends(self, user1: str, user2: str) -> List[str]:
        """æ‰¾åˆ°å…±åŒå¥½å‹"""
        friends1 = set(self.find_friends(user1))
        friends2 = set(self.find_friends(user2))
        return list(friends1.intersection(friends2))

    def find_user_posts(self, user_id: str) -> List[str]:
        """æ‰¾åˆ°ç”¨æˆ·å‘å¸ƒçš„å¸–å­"""
        if user_id in self.graph:
            posts = []
            for neighbor in self.graph.neighbors(user_id):
                if self.graph.nodes[neighbor].get('type') == 'post':
                    posts.append(neighbor)
            return posts
        return []

    def find_popular_posts(self, top_k: int = 10) -> List[Tuple[str, int]]:
        """æ‰¾åˆ°çƒ­é—¨å¸–å­"""
        post_popularity = {}
        for post_id in self.posts:
            interactions = 0
            for neighbor in self.graph.neighbors(post_id):
                if self.graph.nodes[neighbor].get('type') == 'user':
                    interactions += 1
            post_popularity[post_id] = interactions

        sorted_posts = sorted(post_popularity.items(),
                            key=lambda x: x[1], reverse=True)
        return sorted_posts[:top_k]

    def find_influential_users(self, top_k: int = 10) -> List[Tuple[str, int]]:
        """æ‰¾åˆ°æœ‰å½±å“åŠ›çš„ç”¨æˆ·"""
        user_influence = {}
        for user_id in self.users:
            followers = len(self.find_friends(user_id))
            posts = len(self.find_user_posts(user_id))
            user_influence[user_id] = followers + posts * 0.1

        sorted_users = sorted(user_influence.items(),
                            key=lambda x: x[1], reverse=True)
        return sorted_users[:top_k]

    def recommend_friends(self, user_id: str, top_k: int = 5) -> List[Tuple[str, int]]:
        """æ¨èå¥½å‹"""
        if user_id not in self.users:
            return []

        current_friends = set(self.find_friends(user_id))
        recommendations = {}

        for friend in current_friends:
            friend_friends = self.find_friends(friend)
            for potential_friend in friend_friends:
                if (potential_friend != user_id and
                    potential_friend not in current_friends):
                    if potential_friend not in recommendations:
                        recommendations[potential_friend] = 0
                    recommendations[potential_friend] += 1

        sorted_recommendations = sorted(recommendations.items(),
                                      key=lambda x: x[1], reverse=True)
        return sorted_recommendations[:top_k]

# ä½¿ç”¨ç¤ºä¾‹
social_kg = SocialNetworkGraph()

# æ·»åŠ ç”¨æˆ·
social_kg.add_user("U1", "å¼ ä¸‰", ["æŠ€æœ¯", "éŸ³ä¹"])
social_kg.add_user("U2", "æå››", ["æŠ€æœ¯", "è¿åŠ¨"])
social_kg.add_user("U3", "ç‹äº”", ["éŸ³ä¹", "ç”µå½±"])

# æ·»åŠ å¥½å‹å…³ç³»
social_kg.add_friendship("U1", "U2")
social_kg.add_friendship("U1", "U3")
social_kg.add_friendship("U2", "U3")

# æ·»åŠ å¸–å­
social_kg.add_post("P1", "U1", "åˆ†äº«ä¸€ä¸ªæŠ€æœ¯æ–‡ç« ", ["æŠ€æœ¯"])
social_kg.add_post("P2", "U2", "ä»Šå¤©è·‘æ­¥äº†", ["è¿åŠ¨"])

# æ·»åŠ äº¤äº’
social_kg.add_interaction("U2", "P1", "ç‚¹èµ")
social_kg.add_interaction("U3", "P1", "è¯„è®º")

# æ‰¾åˆ°æœ‰å½±å“åŠ›çš„ç”¨æˆ·
influential = social_kg.find_influential_users(3)
print("æœ‰å½±å“åŠ›çš„ç”¨æˆ·:", influential)

# æ¨èå¥½å‹
recommendations = social_kg.recommend_friends("U1", 3)
print("æ¨èå¥½å‹:", recommendations)
```

## 7. æ€»ç»“

æœ¬æ–‡æ¡£æä¾›äº†çŸ¥è¯†å›¾è°±å…³ç³»å»ºæ¨¡çš„å®è·µæ¡ˆä¾‹ï¼Œæ¶µç›–ï¼š

1. **å­¦æœ¯çŸ¥è¯†å›¾è°±**ï¼šè®ºæ–‡å¼•ç”¨å…³ç³»ã€å­¦ç§‘æ¦‚å¿µå…³ç³»
2. **ä¼ä¸šçŸ¥è¯†å›¾è°±**ï¼šç»„ç»‡æ¶æ„å…³ç³»ã€äº§å“çŸ¥è¯†å…³ç³»
3. **ç¤¾äº¤ç½‘ç»œå…³ç³»**ï¼šç”¨æˆ·å…³ç³»ç½‘ç»œã€å†…å®¹äº¤äº’å…³ç³»

æ¯ä¸ªæ¡ˆä¾‹éƒ½åŒ…å«ï¼š

- æ•°æ®æ¨¡å‹è®¾è®¡
- å…³ç³»ç±»å‹å®šä¹‰
- æŸ¥è¯¢å’Œåˆ†æåŠŸèƒ½
- å®é™…åº”ç”¨åœºæ™¯

è¿™äº›å®è·µæ¡ˆä¾‹å±•ç¤ºäº†çŸ¥è¯†å›¾è°±åœ¨ä¸åŒé¢†åŸŸçš„åº”ç”¨ä»·å€¼ï¼Œä¸ºæ„å»ºå¤æ‚çš„å…³ç³»ç½‘ç»œæä¾›äº†å‚è€ƒã€‚
