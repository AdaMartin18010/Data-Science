# 关系建模实践案例

## 概述

本文档提供知识图谱关系建模的实践应用案例，涵盖学术知识图谱、企业知识图谱、社交网络分析等实际场景。

## 1. 学术知识图谱关系建模

### 1.1 论文引用关系建模

```python
import networkx as nx
import matplotlib.pyplot as plt
from typing import Dict, List, Tuple

class AcademicKnowledgeGraph:
    def __init__(self):
        self.graph = nx.DiGraph()
        self.papers = {}
        self.authors = {}
        self.venues = {}
    
    def add_paper(self, paper_id: str, title: str, authors: List[str], 
                  venue: str, year: int, citations: List[str] = None):
        """添加论文节点"""
        self.papers[paper_id] = {
            'title': title,
            'authors': authors,
            'venue': venue,
            'year': year
        }
        
        # 添加论文节点
        self.graph.add_node(paper_id, 
                           type='paper', 
                           title=title, 
                           year=year)
        
        # 添加作者关系
        for author in authors:
            if author not in self.authors:
                self.authors[author] = []
            self.authors[author].append(paper_id)
            self.graph.add_node(author, type='author')
            self.graph.add_edge(author, paper_id, relation='wrote')
        
        # 添加引用关系
        if citations:
            for cited_paper in citations:
                if cited_paper in self.papers:
                    self.graph.add_edge(paper_id, cited_paper, relation='cites')
    
    def get_paper_citations(self, paper_id: str) -> List[str]:
        """获取论文的引用列表"""
        if paper_id in self.graph:
            return list(self.graph.predecessors(paper_id))
        return []
    
    def get_paper_references(self, paper_id: str) -> List[str]:
        """获取论文的参考文献列表"""
        if paper_id in self.graph:
            return list(self.graph.successors(paper_id))
        return []
    
    def calculate_h_index(self, author: str) -> int:
        """计算作者的h指数"""
        if author not in self.authors:
            return 0
        
        paper_ids = self.authors[author]
        citation_counts = []
        
        for paper_id in paper_ids:
            citations = len(self.get_paper_citations(paper_id))
            citation_counts.append(citations)
        
        citation_counts.sort(reverse=True)
        h_index = 0
        for i, count in enumerate(citation_counts):
            if count >= i + 1:
                h_index = i + 1
            else:
                break
        
        return h_index
    
    def find_influential_papers(self, top_k: int = 10) -> List[Tuple[str, int]]:
        """找到最有影响力的论文（基于被引用次数）"""
        paper_influence = []
        for paper_id in self.papers:
            citations = len(self.get_paper_citations(paper_id))
            paper_influence.append((paper_id, citations))
        
        paper_influence.sort(key=lambda x: x[1], reverse=True)
        return paper_influence[:top_k]
    
    def visualize_citation_network(self, paper_id: str, depth: int = 2):
        """可视化论文的引用网络"""
        subgraph = nx.DiGraph()
        nodes_to_add = {paper_id}
        
        # 构建子图
        for _ in range(depth):
            new_nodes = set()
            for node in nodes_to_add:
                if node in self.graph:
                    subgraph.add_node(node, **self.graph.nodes[node])
                    for neighbor in self.graph.predecessors(node):
                        subgraph.add_node(neighbor, **self.graph.nodes[neighbor])
                        subgraph.add_edge(node, neighbor, **self.graph.edges[node, neighbor])
                        new_nodes.add(neighbor)
                    for neighbor in self.graph.successors(node):
                        subgraph.add_node(neighbor, **self.graph.nodes[neighbor])
                        subgraph.add_edge(neighbor, node, **self.graph.edges[neighbor, node])
                        new_nodes.add(neighbor)
            nodes_to_add = new_nodes
        
        # 绘制网络
        plt.figure(figsize=(12, 8))
        pos = nx.spring_layout(subgraph)
        
        # 绘制节点
        nx.draw_networkx_nodes(subgraph, pos, 
                              node_color='lightblue', 
                              node_size=1000)
        
        # 绘制边
        nx.draw_networkx_edges(subgraph, pos, 
                              edge_color='gray', 
                              arrows=True, 
                              arrowsize=20)
        
        # 添加标签
        labels = {node: self.papers.get(node, {}).get('title', node)[:20] 
                 for node in subgraph.nodes()}
        nx.draw_networkx_labels(subgraph, pos, labels, font_size=8)
        
        plt.title(f"论文引用网络: {self.papers[paper_id]['title']}")
        plt.axis('off')
        plt.show()

# 使用示例
academic_kg = AcademicKnowledgeGraph()

# 添加论文数据
academic_kg.add_paper("P1", "深度学习基础", ["张三", "李四"], "ICML", 2020, ["P2", "P3"])
academic_kg.add_paper("P2", "神经网络理论", ["王五"], "NIPS", 2019, ["P3"])
academic_kg.add_paper("P3", "机器学习入门", ["张三"], "JMLR", 2018)

# 计算h指数
h_index = academic_kg.calculate_h_index("张三")
print(f"张三的h指数: {h_index}")

# 找到最有影响力的论文
influential = academic_kg.find_influential_papers(3)
print("最有影响力的论文:", influential)
```

### 1.2 学科知识图谱构建

```python
class SubjectKnowledgeGraph:
    def __init__(self):
        self.graph = nx.Graph()
        self.concepts = {}
        self.relationships = {}
    
    def add_concept(self, concept_id: str, name: str, category: str, 
                   description: str = ""):
        """添加概念节点"""
        self.concepts[concept_id] = {
            'name': name,
            'category': category,
            'description': description
        }
        self.graph.add_node(concept_id, 
                           name=name, 
                           category=category,
                           description=description)
    
    def add_relationship(self, concept1: str, concept2: str, 
                        relation_type: str, weight: float = 1.0):
        """添加概念间关系"""
        if concept1 in self.concepts and concept2 in self.concepts:
            self.graph.add_edge(concept1, concept2, 
                               relation=relation_type, 
                               weight=weight)
            
            if relation_type not in self.relationships:
                self.relationships[relation_type] = []
            self.relationships[relation_type].append((concept1, concept2))
    
    def find_related_concepts(self, concept_id: str, max_distance: int = 2) -> List[str]:
        """找到相关概念"""
        if concept_id not in self.graph:
            return []
        
        related = set()
        for node in nx.single_source_shortest_path_length(self.graph, concept_id, 
                                                         cutoff=max_distance):
            if node != concept_id:
                related.add(node)
        
        return list(related)
    
    def get_concept_clusters(self) -> Dict[str, List[str]]:
        """获取概念聚类"""
        clusters = {}
        components = list(nx.connected_components(self.graph))
        
        for i, component in enumerate(components):
            cluster_name = f"Cluster_{i+1}"
            clusters[cluster_name] = list(component)
        
        return clusters
    
    def calculate_concept_centrality(self) -> Dict[str, float]:
        """计算概念中心性"""
        centrality = nx.betweenness_centrality(self.graph)
        return centrality
    
    def find_central_concepts(self, top_k: int = 10) -> List[Tuple[str, float]]:
        """找到核心概念"""
        centrality = self.calculate_concept_centrality()
        sorted_concepts = sorted(centrality.items(), 
                               key=lambda x: x[1], reverse=True)
        return sorted_concepts[:top_k]

# 使用示例
subject_kg = SubjectKnowledgeGraph()

# 添加计算机科学概念
subject_kg.add_concept("CS1", "算法", "计算机科学", "解决问题的步骤")
subject_kg.add_concept("CS2", "数据结构", "计算机科学", "数据的组织方式")
subject_kg.add_concept("CS3", "编程语言", "计算机科学", "与计算机通信的工具")
subject_kg.add_concept("CS4", "数据库", "计算机科学", "数据存储和管理")
subject_kg.add_concept("CS5", "网络", "计算机科学", "计算机间的通信")

# 添加关系
subject_kg.add_relationship("CS1", "CS2", "依赖", 0.8)
subject_kg.add_relationship("CS3", "CS1", "实现", 0.9)
subject_kg.add_relationship("CS4", "CS2", "应用", 0.7)
subject_kg.add_relationship("CS5", "CS3", "支持", 0.6)

# 找到核心概念
central_concepts = subject_kg.find_central_concepts(3)
print("核心概念:", central_concepts)
```

## 2. 企业知识图谱关系建模

### 2.1 组织架构关系建模

```python
class OrganizationKnowledgeGraph:
    def __init__(self):
        self.graph = nx.DiGraph()
        self.employees = {}
        self.departments = {}
        self.projects = {}
    
    def add_employee(self, emp_id: str, name: str, title: str, 
                    department: str, skills: List[str] = None):
        """添加员工节点"""
        self.employees[emp_id] = {
            'name': name,
            'title': title,
            'department': department,
            'skills': skills or []
        }
        
        self.graph.add_node(emp_id, 
                           type='employee',
                           name=name,
                           title=title,
                           department=department,
                           skills=skills or [])
        
        # 添加部门关系
        if department not in self.departments:
            self.departments[department] = []
        self.departments[department].append(emp_id)
        self.graph.add_node(department, type='department')
        self.graph.add_edge(emp_id, department, relation='belongs_to')
    
    def add_project(self, project_id: str, name: str, 
                   team_members: List[str], manager: str):
        """添加项目节点"""
        self.projects[project_id] = {
            'name': name,
            'team_members': team_members,
            'manager': manager
        }
        
        self.graph.add_node(project_id, 
                           type='project',
                           name=name,
                           manager=manager)
        
        # 添加项目关系
        for member in team_members:
            if member in self.employees:
                self.graph.add_edge(member, project_id, relation='works_on')
        
        if manager in self.employees:
            self.graph.add_edge(manager, project_id, relation='manages')
    
    def add_collaboration(self, emp1: str, emp2: str, 
                         project: str, collaboration_type: str):
        """添加协作关系"""
        if emp1 in self.employees and emp2 in self.employees:
            self.graph.add_edge(emp1, emp2, 
                               relation='collaborates_with',
                               project=project,
                               type=collaboration_type)
    
    def find_team_members(self, project_id: str) -> List[str]:
        """找到项目团队成员"""
        if project_id in self.graph:
            return list(self.graph.predecessors(project_id))
        return []
    
    def find_employee_projects(self, emp_id: str) -> List[str]:
        """找到员工参与的项目"""
        if emp_id in self.graph:
            return list(self.graph.successors(emp_id))
        return []
    
    def find_skill_experts(self, skill: str) -> List[str]:
        """找到技能专家"""
        experts = []
        for emp_id, emp_data in self.employees.items():
            if skill in emp_data.get('skills', []):
                experts.append(emp_id)
        return experts
    
    def calculate_employee_centrality(self) -> Dict[str, float]:
        """计算员工中心性"""
        centrality = nx.betweenness_centrality(self.graph)
        return {emp_id: centrality.get(emp_id, 0) 
                for emp_id in self.employees}
    
    def find_key_employees(self, top_k: int = 5) -> List[Tuple[str, float]]:
        """找到关键员工"""
        centrality = self.calculate_employee_centrality()
        sorted_employees = sorted(centrality.items(), 
                                key=lambda x: x[1], reverse=True)
        return sorted_employees[:top_k]

# 使用示例
org_kg = OrganizationKnowledgeGraph()

# 添加员工
org_kg.add_employee("E1", "张三", "软件工程师", "技术部", ["Python", "Java"])
org_kg.add_employee("E2", "李四", "项目经理", "技术部", ["项目管理", "敏捷"])
org_kg.add_employee("E3", "王五", "数据科学家", "数据部", ["Python", "机器学习"])

# 添加项目
org_kg.add_project("P1", "AI平台开发", ["E1", "E3"], "E2")

# 添加协作关系
org_kg.add_collaboration("E1", "E3", "P1", "技术协作")

# 找到关键员工
key_employees = org_kg.find_key_employees(3)
print("关键员工:", key_employees)

# 找到技能专家
python_experts = org_kg.find_skill_experts("Python")
print("Python专家:", python_experts)
```

### 2.2 产品知识图谱建模

```python
class ProductKnowledgeGraph:
    def __init__(self):
        self.graph = nx.Graph()
        self.products = {}
        self.features = {}
        self.categories = {}
    
    def add_product(self, product_id: str, name: str, category: str, 
                   price: float, features: List[str] = None):
        """添加产品节点"""
        self.products[product_id] = {
            'name': name,
            'category': category,
            'price': price,
            'features': features or []
        }
        
        self.graph.add_node(product_id, 
                           type='product',
                           name=name,
                           category=category,
                           price=price)
        
        # 添加特征关系
        if features:
            for feature in features:
                if feature not in self.features:
                    self.features[feature] = []
                self.features[feature].append(product_id)
                self.graph.add_node(feature, type='feature')
                self.graph.add_edge(product_id, feature, relation='has_feature')
        
        # 添加分类关系
        if category not in self.categories:
            self.categories[category] = []
        self.categories[category].append(product_id)
        self.graph.add_node(category, type='category')
        self.graph.add_edge(product_id, category, relation='belongs_to')
    
    def add_similarity(self, product1: str, product2: str, similarity_score: float):
        """添加产品相似性关系"""
        if product1 in self.products and product2 in self.products:
            self.graph.add_edge(product1, product2, 
                               relation='similar_to',
                               similarity=similarity_score)
    
    def find_similar_products(self, product_id: str, threshold: float = 0.5) -> List[Tuple[str, float]]:
        """找到相似产品"""
        if product_id not in self.graph:
            return []
        
        similar_products = []
        for neighbor in self.graph.neighbors(product_id):
            edge_data = self.graph.edges[product_id, neighbor]
            if (edge_data.get('relation') == 'similar_to' and 
                edge_data.get('similarity', 0) >= threshold):
                similar_products.append((neighbor, edge_data['similarity']))
        
        similar_products.sort(key=lambda x: x[1], reverse=True)
        return similar_products
    
    def find_products_by_feature(self, feature: str) -> List[str]:
        """根据特征找到产品"""
        return self.features.get(feature, [])
    
    def find_products_by_category(self, category: str) -> List[str]:
        """根据分类找到产品"""
        return self.categories.get(category, [])
    
    def get_product_recommendations(self, user_features: List[str], 
                                  top_k: int = 5) -> List[Tuple[str, float]]:
        """基于用户特征推荐产品"""
        recommendations = {}
        
        for feature in user_features:
            products = self.find_products_by_feature(feature)
            for product_id in products:
                if product_id not in recommendations:
                    recommendations[product_id] = 0
                recommendations[product_id] += 1
        
        # 计算推荐分数
        sorted_recommendations = sorted(recommendations.items(), 
                                      key=lambda x: x[1], reverse=True)
        return sorted_recommendations[:top_k]

# 使用示例
product_kg = ProductKnowledgeGraph()

# 添加产品
product_kg.add_product("P1", "iPhone 13", "手机", 5999.0, 
                      ["5G", "A15芯片", "超广角相机"])
product_kg.add_product("P2", "Samsung S21", "手机", 4999.0, 
                      ["5G", "骁龙888", "超广角相机"])
product_kg.add_product("P3", "MacBook Pro", "笔记本", 12999.0, 
                      ["M1芯片", "Retina显示屏"])

# 添加相似性关系
product_kg.add_similarity("P1", "P2", 0.8)
product_kg.add_similarity("P1", "P3", 0.3)

# 找到相似产品
similar = product_kg.find_similar_products("P1", 0.5)
print("与iPhone 13相似的产品:", similar)

# 基于特征推荐
recommendations = product_kg.get_product_recommendations(["5G", "超广角相机"], 3)
print("推荐产品:", recommendations)
```

## 3. 社交网络关系建模

### 3.1 用户关系网络建模

```python
class SocialNetworkGraph:
    def __init__(self):
        self.graph = nx.Graph()
        self.users = {}
        self.posts = {}
        self.interactions = {}
    
    def add_user(self, user_id: str, name: str, interests: List[str] = None):
        """添加用户节点"""
        self.users[user_id] = {
            'name': name,
            'interests': interests or []
        }
        
        self.graph.add_node(user_id, 
                           type='user',
                           name=name,
                           interests=interests or [])
    
    def add_friendship(self, user1: str, user2: str, friendship_type: str = "friend"):
        """添加好友关系"""
        if user1 in self.users and user2 in self.users:
            self.graph.add_edge(user1, user2, 
                               relation='friend',
                               type=friendship_type)
    
    def add_post(self, post_id: str, author: str, content: str, 
                tags: List[str] = None):
        """添加帖子节点"""
        self.posts[post_id] = {
            'author': author,
            'content': content,
            'tags': tags or []
        }
        
        self.graph.add_node(post_id, 
                           type='post',
                           author=author,
                           content=content,
                           tags=tags or [])
        
        # 添加作者关系
        if author in self.users:
            self.graph.add_edge(author, post_id, relation='authored')
    
    def add_interaction(self, user: str, post: str, interaction_type: str):
        """添加用户与帖子的交互"""
        if user in self.users and post in self.posts:
            self.graph.add_edge(user, post, 
                               relation='interacted',
                               type=interaction_type)
    
    def find_friends(self, user_id: str) -> List[str]:
        """找到用户的好友"""
        if user_id in self.graph:
            return list(self.graph.neighbors(user_id))
        return []
    
    def find_common_friends(self, user1: str, user2: str) -> List[str]:
        """找到共同好友"""
        friends1 = set(self.find_friends(user1))
        friends2 = set(self.find_friends(user2))
        return list(friends1.intersection(friends2))
    
    def find_user_posts(self, user_id: str) -> List[str]:
        """找到用户发布的帖子"""
        if user_id in self.graph:
            posts = []
            for neighbor in self.graph.neighbors(user_id):
                if self.graph.nodes[neighbor].get('type') == 'post':
                    posts.append(neighbor)
            return posts
        return []
    
    def find_popular_posts(self, top_k: int = 10) -> List[Tuple[str, int]]:
        """找到热门帖子"""
        post_popularity = {}
        for post_id in self.posts:
            interactions = 0
            for neighbor in self.graph.neighbors(post_id):
                if self.graph.nodes[neighbor].get('type') == 'user':
                    interactions += 1
            post_popularity[post_id] = interactions
        
        sorted_posts = sorted(post_popularity.items(), 
                            key=lambda x: x[1], reverse=True)
        return sorted_posts[:top_k]
    
    def find_influential_users(self, top_k: int = 10) -> List[Tuple[str, int]]:
        """找到有影响力的用户"""
        user_influence = {}
        for user_id in self.users:
            followers = len(self.find_friends(user_id))
            posts = len(self.find_user_posts(user_id))
            user_influence[user_id] = followers + posts * 0.1
        
        sorted_users = sorted(user_influence.items(), 
                            key=lambda x: x[1], reverse=True)
        return sorted_users[:top_k]
    
    def recommend_friends(self, user_id: str, top_k: int = 5) -> List[Tuple[str, int]]:
        """推荐好友"""
        if user_id not in self.users:
            return []
        
        current_friends = set(self.find_friends(user_id))
        recommendations = {}
        
        for friend in current_friends:
            friend_friends = self.find_friends(friend)
            for potential_friend in friend_friends:
                if (potential_friend != user_id and 
                    potential_friend not in current_friends):
                    if potential_friend not in recommendations:
                        recommendations[potential_friend] = 0
                    recommendations[potential_friend] += 1
        
        sorted_recommendations = sorted(recommendations.items(), 
                                      key=lambda x: x[1], reverse=True)
        return sorted_recommendations[:top_k]

# 使用示例
social_kg = SocialNetworkGraph()

# 添加用户
social_kg.add_user("U1", "张三", ["技术", "音乐"])
social_kg.add_user("U2", "李四", ["技术", "运动"])
social_kg.add_user("U3", "王五", ["音乐", "电影"])

# 添加好友关系
social_kg.add_friendship("U1", "U2")
social_kg.add_friendship("U1", "U3")
social_kg.add_friendship("U2", "U3")

# 添加帖子
social_kg.add_post("P1", "U1", "分享一个技术文章", ["技术"])
social_kg.add_post("P2", "U2", "今天跑步了", ["运动"])

# 添加交互
social_kg.add_interaction("U2", "P1", "点赞")
social_kg.add_interaction("U3", "P1", "评论")

# 找到有影响力的用户
influential = social_kg.find_influential_users(3)
print("有影响力的用户:", influential)

# 推荐好友
recommendations = social_kg.recommend_friends("U1", 3)
print("推荐好友:", recommendations)
```

## 4. 总结

本文档提供了知识图谱关系建模的实践案例，涵盖：

1. **学术知识图谱**：论文引用关系、学科概念关系
2. **企业知识图谱**：组织架构关系、产品知识关系
3. **社交网络关系**：用户关系网络、内容交互关系

每个案例都包含：

- 数据模型设计
- 关系类型定义
- 查询和分析功能
- 实际应用场景

这些实践案例展示了知识图谱在不同领域的应用价值，为构建复杂的关系网络提供了参考。
