# 6.1.4 知识表示实践案例

## 1. 概述

本文档提供知识表示的实际应用案例，包括本体构建、语义网络实现、知识图谱构建等具体实践。

## 2. 本体构建实践

### 2.1 教育领域本体构建

```python
import rdflib
from rdflib import Graph, Namespace, Literal, URIRef
from rdflib.namespace import RDF, RDFS, OWL

class EducationOntology:
    def __init__(self):
        self.g = Graph()
        self.EDU = Namespace("http://example.org/education#")
        self.g.bind("edu", self.EDU)
        
    def build_education_ontology(self):
        """构建教育领域本体"""
        
        # 定义类
        self.g.add((self.EDU.Person, RDF.type, OWL.Class))
        self.g.add((self.EDU.Student, RDF.type, OWL.Class))
        self.g.add((self.EDU.Teacher, RDF.type, OWL.Class))
        self.g.add((self.EDU.Course, RDF.type, OWL.Class))
        
        # 定义子类关系
        self.g.add((self.EDU.Student, RDFS.subClassOf, self.EDU.Person))
        self.g.add((self.EDU.Teacher, RDFS.subClassOf, self.EDU.Person))
        
        # 定义属性
        self.g.add((self.EDU.hasName, RDF.type, OWL.DatatypeProperty))
        self.g.add((self.EDU.enrollsIn, RDF.type, OWL.ObjectProperty))
        self.g.add((self.EDU.teaches, RDF.type, OWL.ObjectProperty))
        
        return self.g
    
    def add_instances(self):
        """添加实例数据"""
        
        # 添加人员实例
        alice = URIRef(self.EDU + "Alice")
        charlie = URIRef(self.EDU + "Charlie")
        
        # 添加课程实例
        cs101 = URIRef(self.EDU + "CS101")
        
        # 定义实例类型
        self.g.add((alice, RDF.type, self.EDU.Student))
        self.g.add((charlie, RDF.type, self.EDU.Teacher))
        self.g.add((cs101, RDF.type, self.EDU.Course))
        
        # 添加属性值
        self.g.add((alice, self.EDU.hasName, Literal("Alice Smith")))
        self.g.add((alice, self.EDU.enrollsIn, cs101))
        self.g.add((charlie, self.EDU.hasName, Literal("Charlie Brown")))
        self.g.add((charlie, self.EDU.teaches, cs101))
        
        return self.g
```

## 3. 语义网络实现

### 3.1 基于图的语义网络

```python
import networkx as nx
import matplotlib.pyplot as plt

class SemanticNetwork:
    def __init__(self):
        self.graph = nx.DiGraph()
        
    def add_concept(self, concept_id, concept_name, concept_type="Entity"):
        """添加概念节点"""
        self.graph.add_node(concept_id, 
                           name=concept_name, 
                           type=concept_type)
        
    def add_relation(self, source_id, target_id, relation_type, relation_name):
        """添加关系边"""
        self.graph.add_edge(source_id, target_id, 
                           type=relation_type, 
                           name=relation_name)
        
    def find_path(self, source_id, target_id, max_length=3):
        """查找两个概念之间的路径"""
        try:
            paths = list(nx.all_simple_paths(self.graph, source_id, target_id, 
                                           cutoff=max_length))
            return paths
        except nx.NetworkXNoPath:
            return []
    
    def visualize_network(self, title="语义网络"):
        """可视化语义网络"""
        plt.figure(figsize=(12, 8))
        pos = nx.spring_layout(self.graph, k=1, iterations=50)
        
        nx.draw_networkx_nodes(self.graph, pos, 
                              node_color='lightblue',
                              node_size=1000)
        nx.draw_networkx_edges(self.graph, pos, 
                              edge_color='gray',
                              arrows=True,
                              arrowsize=20)
        
        labels = {node: self.graph.nodes[node]['name'] 
                 for node in self.graph.nodes()}
        nx.draw_networkx_labels(self.graph, pos, labels)
        
        plt.title(title)
        plt.axis('off')
        plt.show()

# 使用示例
def semantic_network_example():
    """语义网络使用示例"""
    network = SemanticNetwork()
    
    # 添加概念
    network.add_concept("person", "人", "Entity")
    network.add_concept("student", "学生", "Entity")
    network.add_concept("teacher", "教师", "Entity")
    network.add_concept("course", "课程", "Entity")
    
    # 添加关系
    network.add_relation("student", "person", "is_a", "是一个")
    network.add_relation("teacher", "person", "is_a", "是一个")
    network.add_relation("student", "course", "takes", "选修")
    network.add_relation("teacher", "course", "teaches", "教授")
    
    # 查找路径
    paths = network.find_path("student", "course")
    print("学生到课程的路径:")
    for path in paths:
        print(f"  {' -> '.join([network.graph.nodes[node]['name'] for node in path])}")
    
    # 可视化
    network.visualize_network("教育领域语义网络")
    
    return network
```

## 4. 知识图谱构建实践

### 4.1 基于Python的知识图谱

```python
import pandas as pd
from collections import defaultdict

class PythonKnowledgeGraph:
    def __init__(self):
        self.entities = defaultdict(dict)
        self.relationships = defaultdict(list)
        self.entity_types = defaultdict(str)
        
    def add_entity(self, entity_id, entity_type, properties):
        """添加实体"""
        self.entities[entity_id] = properties
        self.entity_types[entity_id] = entity_type
        
    def add_relationship(self, source_id, target_id, relationship_type, properties=None):
        """添加关系"""
        if properties is None:
            properties = {}
            
        relationship = {
            'source': source_id,
            'target': target_id,
            'type': relationship_type,
            'properties': properties
        }
        
        self.relationships[source_id].append(relationship)
        
    def get_entity(self, entity_id):
        """获取实体"""
        return {
            'id': entity_id,
            'type': self.entity_types[entity_id],
            'properties': self.entities[entity_id]
        }
    
    def get_relationships(self, entity_id):
        """获取实体的关系"""
        return self.relationships[entity_id]
    
    def find_path(self, start_id, end_id, max_depth=3):
        """查找路径"""
        def dfs(current_id, target_id, path, depth):
            if depth > max_depth:
                return None
            if current_id == target_id:
                return path
                
            for rel in self.relationships[current_id]:
                next_id = rel['target']
                if next_id not in [p['id'] for p in path]:
                    new_path = path + [{'id': next_id, 'relationship': rel}]
                    result = dfs(next_id, target_id, new_path, depth + 1)
                    if result:
                        return result
            return None
        
        return dfs(start_id, end_id, [{'id': start_id}], 0)
    
    def query_by_type(self, entity_type):
        """按类型查询实体"""
        entities = []
        for entity_id, e_type in self.entity_types.items():
            if e_type == entity_type:
                entities.append(self.get_entity(entity_id))
        return entities

# 使用示例
def python_knowledge_graph_example():
    """Python知识图谱示例"""
    kg = PythonKnowledgeGraph()
    
    # 添加实体
    kg.add_entity("P001", "Person", {"name": "张三", "age": 30, "occupation": "工程师"})
    kg.add_entity("P002", "Person", {"name": "李四", "age": 35, "occupation": "经理"})
    kg.add_entity("C001", "Company", {"name": "腾讯", "industry": "互联网"})
    
    # 添加关系
    kg.add_relationship("P001", "C001", "WORKS_FOR", {"start_date": "2020-01-01"})
    kg.add_relationship("P001", "P002", "KNOWS", {"since": "2018"})
    
    # 查询实体
    person = kg.get_entity("P001")
    print(f"实体信息: {person}")
    
    # 查询关系
    relationships = kg.get_relationships("P001")
    print(f"关系信息: {relationships}")
    
    # 查找路径
    path = kg.find_path("P001", "C001")
    print(f"路径: {path}")
    
    # 按类型查询
    persons = kg.query_by_type("Person")
    print(f"所有人员: {persons}")
    
    return kg
```

## 5. 知识推理实践

### 5.1 基于规则的推理

```python
class RuleBasedReasoner:
    def __init__(self):
        self.rules = []
        self.facts = set()
        
    def add_rule(self, condition, conclusion):
        """添加规则"""
        self.rules.append({
            'condition': condition,
            'conclusion': conclusion
        })
    
    def add_fact(self, fact):
        """添加事实"""
        self.facts.add(fact)
    
    def forward_chaining(self):
        """前向推理"""
        new_facts = set()
        changed = True
        
        while changed:
            changed = False
            for rule in self.rules:
                if self.evaluate_condition(rule['condition']) and rule['conclusion'] not in self.facts:
                    self.facts.add(rule['conclusion'])
                    new_facts.add(rule['conclusion'])
                    changed = True
        
        return new_facts
    
    def evaluate_condition(self, condition):
        """评估条件"""
        if isinstance(condition, str):
            return condition in self.facts
        elif isinstance(condition, list):
            if condition[0] == 'AND':
                return all(self.evaluate_condition(c) for c in condition[1:])
            elif condition[0] == 'OR':
                return any(self.evaluate_condition(c) for c in condition[1:])
        return False

# 使用示例
def rule_based_reasoning_example():
    """基于规则的推理示例"""
    reasoner = RuleBasedReasoner()
    
    # 添加事实
    reasoner.add_fact("is_student(张三)")
    reasoner.add_fact("takes_course(张三, 数学)")
    reasoner.add_fact("is_course(数学)")
    
    # 添加规则
    reasoner.add_rule("is_student(X)", "can_graduate(X)")
    reasoner.add_rule(["is_student(X)", "takes_course(X, Y)", "is_course(Y)"], "has_knowledge(X, Y)")
    
    # 前向推理
    new_facts = reasoner.forward_chaining()
    print(f"推理得到的新事实: {new_facts}")
    
    return reasoner
```

## 6. 总结

本文档提供了知识表示的实际应用案例，包括：

1. **本体构建实践**：教育领域的本体构建
2. **语义网络实现**：基于图的语义网络
3. **知识图谱构建**：基于Python的知识图谱
4. **知识推理实践**：基于规则的推理系统

这些案例展示了知识表示在实际应用中的具体实现方法，为构建智能知识系统提供了实用的参考。
