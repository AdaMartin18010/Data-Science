# 6.1.4 çŸ¥è¯†è¡¨ç¤ºå®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [6.1.4 çŸ¥è¯†è¡¨ç¤ºå®è·µæ¡ˆä¾‹](#614-çŸ¥è¯†è¡¨ç¤ºå®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2. æœ¬ä½“æ„å»ºå®è·µ](#2-æœ¬ä½“æ„å»ºå®è·µ)
    - [2.1. æ•™è‚²é¢†åŸŸæœ¬ä½“æ„å»º](#21-æ•™è‚²é¢†åŸŸæœ¬ä½“æ„å»º)
  - [3. è¯­ä¹‰ç½‘ç»œå®ç°](#3-è¯­ä¹‰ç½‘ç»œå®ç°)
    - [3.1. åŸºäºå›¾çš„è¯­ä¹‰ç½‘ç»œ](#31-åŸºäºå›¾çš„è¯­ä¹‰ç½‘ç»œ)
  - [4. çŸ¥è¯†å›¾è°±æ„å»ºå®è·µ](#4-çŸ¥è¯†å›¾è°±æ„å»ºå®è·µ)
    - [4.1. åŸºäºPythonçš„çŸ¥è¯†å›¾è°±](#41-åŸºäºpythonçš„çŸ¥è¯†å›¾è°±)
  - [5. çŸ¥è¯†æ¨ç†å®è·µ](#5-çŸ¥è¯†æ¨ç†å®è·µ)
    - [5.1. åŸºäºè§„åˆ™çš„æ¨ç†](#51-åŸºäºè§„åˆ™çš„æ¨ç†)
  - [6. æ€»ç»“](#6-æ€»ç»“)

---


## 1. æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›çŸ¥è¯†è¡¨ç¤ºçš„å®é™…åº”ç”¨æ¡ˆä¾‹ï¼ŒåŒ…æ‹¬æœ¬ä½“æ„å»ºã€è¯­ä¹‰ç½‘ç»œå®ç°ã€çŸ¥è¯†å›¾è°±æ„å»ºç­‰å…·ä½“å®è·µã€‚

## 2. æœ¬ä½“æ„å»ºå®è·µ

### 2.1. æ•™è‚²é¢†åŸŸæœ¬ä½“æ„å»º

```python
import rdflib
from rdflib import Graph, Namespace, Literal, URIRef
from rdflib.namespace import RDF, RDFS, OWL

class EducationOntology:
    def __init__(self):
        self.g = Graph()
        self.EDU = Namespace("http://example.org/education#")
        self.g.bind("edu", self.EDU)

    def build_education_ontology(self):
        """æ„å»ºæ•™è‚²é¢†åŸŸæœ¬ä½“"""

# å®šä¹‰ç±»
        self.g.add((self.EDU.Person, RDF.type, OWL.Class))
        self.g.add((self.EDU.Student, RDF.type, OWL.Class))
        self.g.add((self.EDU.Teacher, RDF.type, OWL.Class))
        self.g.add((self.EDU.Course, RDF.type, OWL.Class))

# å®šä¹‰å­ç±»å…³ç³»
        self.g.add((self.EDU.Student, RDFS.subClassOf, self.EDU.Person))
        self.g.add((self.EDU.Teacher, RDFS.subClassOf, self.EDU.Person))

# å®šä¹‰å±æ€§
        self.g.add((self.EDU.hasName, RDF.type, OWL.DatatypeProperty))
        self.g.add((self.EDU.enrollsIn, RDF.type, OWL.ObjectProperty))
        self.g.add((self.EDU.teaches, RDF.type, OWL.ObjectProperty))

        return self.g

    def add_instances(self):
        """æ·»åŠ å®ä¾‹æ•°æ®"""

# æ·»åŠ äººå‘˜å®ä¾‹
        alice = URIRef(self.EDU + "Alice")
        charlie = URIRef(self.EDU + "Charlie")

# æ·»åŠ è¯¾ç¨‹å®ä¾‹
        cs101 = URIRef(self.EDU + "CS101")

# å®šä¹‰å®ä¾‹ç±»å‹
        self.g.add((alice, RDF.type, self.EDU.Student))
        self.g.add((charlie, RDF.type, self.EDU.Teacher))
        self.g.add((cs101, RDF.type, self.EDU.Course))

# æ·»åŠ å±æ€§å€¼
        self.g.add((alice, self.EDU.hasName, Literal("Alice Smith")))
        self.g.add((alice, self.EDU.enrollsIn, cs101))
        self.g.add((charlie, self.EDU.hasName, Literal("Charlie Brown")))
        self.g.add((charlie, self.EDU.teaches, cs101))

        return self.g
```

## 3. è¯­ä¹‰ç½‘ç»œå®ç°

### 3.1. åŸºäºå›¾çš„è¯­ä¹‰ç½‘ç»œ

```python
import networkx as nx
import matplotlib.pyplot as plt

class SemanticNetwork:
    def __init__(self):
        self.graph = nx.DiGraph()

    def add_concept(self, concept_id, concept_name, concept_type="Entity"):
        """æ·»åŠ æ¦‚å¿µèŠ‚ç‚¹"""
        self.graph.add_node(concept_id,
                           name=concept_name,
                           type=concept_type)

    def add_relation(self, source_id, target_id, relation_type, relation_name):
        """æ·»åŠ å…³ç³»è¾¹"""
        self.graph.add_edge(source_id, target_id,
                           type=relation_type,
                           name=relation_name)

    def find_path(self, source_id, target_id, max_length=3):
        """æŸ¥æ‰¾ä¸¤ä¸ªæ¦‚å¿µä¹‹é—´çš„è·¯å¾„"""
        try:
            paths = list(nx.all_simple_paths(self.graph, source_id, target_id,
                                           cutoff=max_length))
            return paths
        except nx.NetworkXNoPath:
            return []

    def visualize_network(self, title="è¯­ä¹‰ç½‘ç»œ"):
        """å¯è§†åŒ–è¯­ä¹‰ç½‘ç»œ"""
        plt.figure(figsize=(12, 8))
        pos = nx.spring_layout(self.graph, k=1, iterations=50)

        nx.draw_networkx_nodes(self.graph, pos,
                              node_color='lightblue',
                              node_size=1000)
        nx.draw_networkx_edges(self.graph, pos,
                              edge_color='gray',
                              arrows=True,
                              arrowsize=20)

        labels = {node: self.graph.nodes[node]['name']
                 for node in self.graph.nodes()}
        nx.draw_networkx_labels(self.graph, pos, labels)

        plt.title(title)
        plt.axis('off')
        plt.show()

# ä½¿ç”¨ç¤ºä¾‹
def semantic_network_example():
    """è¯­ä¹‰ç½‘ç»œä½¿ç”¨ç¤ºä¾‹"""
    network = SemanticNetwork()

# æ·»åŠ æ¦‚å¿µ
    network.add_concept("person", "äºº", "Entity")
    network.add_concept("student", "å­¦ç”Ÿ", "Entity")
    network.add_concept("teacher", "æ•™å¸ˆ", "Entity")
    network.add_concept("course", "è¯¾ç¨‹", "Entity")

# æ·»åŠ å…³ç³»
    network.add_relation("student", "person", "is_a", "æ˜¯ä¸€ä¸ª")
    network.add_relation("teacher", "person", "is_a", "æ˜¯ä¸€ä¸ª")
    network.add_relation("student", "course", "takes", "é€‰ä¿®")
    network.add_relation("teacher", "course", "teaches", "æ•™æˆ")

# æŸ¥æ‰¾è·¯å¾„
    paths = network.find_path("student", "course")
    print("å­¦ç”Ÿåˆ°è¯¾ç¨‹çš„è·¯å¾„:")
    for path in paths:
        print(f"  {' -> '.join([network.graph.nodes[node]['name'] for node in path])}")

# å¯è§†åŒ–
    network.visualize_network("æ•™è‚²é¢†åŸŸè¯­ä¹‰ç½‘ç»œ")

    return network
```

## 4. çŸ¥è¯†å›¾è°±æ„å»ºå®è·µ

### 4.1. åŸºäºPythonçš„çŸ¥è¯†å›¾è°±

```python
import pandas as pd
from collections import defaultdict

class PythonKnowledgeGraph:
    def __init__(self):
        self.entities = defaultdict(dict)
        self.relationships = defaultdict(list)
        self.entity_types = defaultdict(str)

    def add_entity(self, entity_id, entity_type, properties):
        """æ·»åŠ å®ä½“"""
        self.entities[entity_id] = properties
        self.entity_types[entity_id] = entity_type

    def add_relationship(self, source_id, target_id, relationship_type, properties=None):
        """æ·»åŠ å…³ç³»"""
        if properties is None:
            properties = {}

        relationship = {
            'source': source_id,
            'target': target_id,
            'type': relationship_type,
            'properties': properties
        }

        self.relationships[source_id].append(relationship)

    def get_entity(self, entity_id):
        """è·å–å®ä½“"""
        return {
            'id': entity_id,
            'type': self.entity_types[entity_id],
            'properties': self.entities[entity_id]
        }

    def get_relationships(self, entity_id):
        """è·å–å®ä½“çš„å…³ç³»"""
        return self.relationships[entity_id]

    def find_path(self, start_id, end_id, max_depth=3):
        """æŸ¥æ‰¾è·¯å¾„"""
        def dfs(current_id, target_id, path, depth):
            if depth > max_depth:
                return None
            if current_id == target_id:
                return path

            for rel in self.relationships[current_id]:
                next_id = rel['target']
                if next_id not in [p['id'] for p in path]:
                    new_path = path + [{'id': next_id, 'relationship': rel}]
                    result = dfs(next_id, target_id, new_path, depth + 1)
                    if result:
                        return result
            return None

        return dfs(start_id, end_id, [{'id': start_id}], 0)

    def query_by_type(self, entity_type):
        """æŒ‰ç±»å‹æŸ¥è¯¢å®ä½“"""
        entities = []
        for entity_id, e_type in self.entity_types.items():
            if e_type == entity_type:
                entities.append(self.get_entity(entity_id))
        return entities

# ä½¿ç”¨ç¤ºä¾‹
def python_knowledge_graph_example():
    """PythonçŸ¥è¯†å›¾è°±ç¤ºä¾‹"""
    kg = PythonKnowledgeGraph()

# æ·»åŠ å®ä½“
    kg.add_entity("P001", "Person", {"name": "å¼ ä¸‰", "age": 30, "occupation": "å·¥ç¨‹å¸ˆ"})
    kg.add_entity("P002", "Person", {"name": "æå››", "age": 35, "occupation": "ç»ç†"})
    kg.add_entity("C001", "Company", {"name": "è…¾è®¯", "industry": "äº’è”ç½‘"})

# æ·»åŠ å…³ç³»
    kg.add_relationship("P001", "C001", "WORKS_FOR", {"start_date": "2020-01-01"})
    kg.add_relationship("P001", "P002", "KNOWS", {"since": "2018"})

# æŸ¥è¯¢å®ä½“
    person = kg.get_entity("P001")
    print(f"å®ä½“ä¿¡æ¯: {person}")

# æŸ¥è¯¢å…³ç³»
    relationships = kg.get_relationships("P001")
    print(f"å…³ç³»ä¿¡æ¯: {relationships}")

# æŸ¥æ‰¾è·¯å¾„
    path = kg.find_path("P001", "C001")
    print(f"è·¯å¾„: {path}")

# æŒ‰ç±»å‹æŸ¥è¯¢
    persons = kg.query_by_type("Person")
    print(f"æ‰€æœ‰äººå‘˜: {persons}")

    return kg
```

## 5. çŸ¥è¯†æ¨ç†å®è·µ

### 5.1. åŸºäºè§„åˆ™çš„æ¨ç†

```python
class RuleBasedReasoner:
    def __init__(self):
        self.rules = []
        self.facts = set()

    def add_rule(self, condition, conclusion):
        """æ·»åŠ è§„åˆ™"""
        self.rules.append({
            'condition': condition,
            'conclusion': conclusion
        })

    def add_fact(self, fact):
        """æ·»åŠ äº‹å®"""
        self.facts.add(fact)

    def forward_chaining(self):
        """å‰å‘æ¨ç†"""
        new_facts = set()
        changed = True

        while changed:
            changed = False
            for rule in self.rules:
                if self.evaluate_condition(rule['condition']) and rule['conclusion'] not in self.facts:
                    self.facts.add(rule['conclusion'])
                    new_facts.add(rule['conclusion'])
                    changed = True

        return new_facts

    def evaluate_condition(self, condition):
        """è¯„ä¼°æ¡ä»¶"""
        if isinstance(condition, str):
            return condition in self.facts
        elif isinstance(condition, list):
            if condition[0] == 'AND':
                return all(self.evaluate_condition(c) for c in condition[1:])
            elif condition[0] == 'OR':
                return any(self.evaluate_condition(c) for c in condition[1:])
        return False

# ä½¿ç”¨ç¤ºä¾‹
def rule_based_reasoning_example():
    """åŸºäºè§„åˆ™çš„æ¨ç†ç¤ºä¾‹"""
    reasoner = RuleBasedReasoner()

# æ·»åŠ äº‹å®
    reasoner.add_fact("is_student(å¼ ä¸‰)")
    reasoner.add_fact("takes_course(å¼ ä¸‰, æ•°å­¦)")
    reasoner.add_fact("is_course(æ•°å­¦)")

# æ·»åŠ è§„åˆ™
    reasoner.add_rule("is_student(X)", "can_graduate(X)")
    reasoner.add_rule(["is_student(X)", "takes_course(X, Y)", "is_course(Y)"], "has_knowledge(X, Y)")

# å‰å‘æ¨ç†
    new_facts = reasoner.forward_chaining()
    print(f"æ¨ç†å¾—åˆ°çš„æ–°äº‹å®: {new_facts}")

    return reasoner
```

## 6. æ€»ç»“

æœ¬æ–‡æ¡£æä¾›äº†çŸ¥è¯†è¡¨ç¤ºçš„å®é™…åº”ç”¨æ¡ˆä¾‹ï¼ŒåŒ…æ‹¬ï¼š

1. **æœ¬ä½“æ„å»ºå®è·µ**ï¼šæ•™è‚²é¢†åŸŸçš„æœ¬ä½“æ„å»º
2. **è¯­ä¹‰ç½‘ç»œå®ç°**ï¼šåŸºäºå›¾çš„è¯­ä¹‰ç½‘ç»œ
3. **çŸ¥è¯†å›¾è°±æ„å»º**ï¼šåŸºäºPythonçš„çŸ¥è¯†å›¾è°±
4. **çŸ¥è¯†æ¨ç†å®è·µ**ï¼šåŸºäºè§„åˆ™çš„æ¨ç†ç³»ç»Ÿ

è¿™äº›æ¡ˆä¾‹å±•ç¤ºäº†çŸ¥è¯†è¡¨ç¤ºåœ¨å®é™…åº”ç”¨ä¸­çš„å…·ä½“å®ç°æ–¹æ³•ï¼Œä¸ºæ„å»ºæ™ºèƒ½çŸ¥è¯†ç³»ç»Ÿæä¾›äº†å®ç”¨çš„å‚è€ƒã€‚
