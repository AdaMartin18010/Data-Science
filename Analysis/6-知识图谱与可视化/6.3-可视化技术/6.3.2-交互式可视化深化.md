# 交互式可视化深化

## 1. 交互设计原则

### 用户交互模式

```javascript
// 交互式可视化基础框架
class InteractiveVisualization {
    constructor(container, data) {
        this.container = container;
        this.data = data;
        this.interactions = new Map();
        this.state = {
            selectedNodes: new Set(),
            highlightedEdges: new Set(),
            zoomLevel: 1,
            panOffset: { x: 0, y: 0 }
        };
        
        this.initInteractions();
    }
    
    initInteractions() {
        // 鼠标交互
        this.interactions.set('click', this.handleClick.bind(this));
        this.interactions.set('hover', this.handleHover.bind(this));
        this.interactions.set('drag', this.handleDrag.bind(this));
        
        // 键盘交互
        this.interactions.set('keydown', this.handleKeydown.bind(this));
        
        // 触摸交互
        this.interactions.set('touchstart', this.handleTouchStart.bind(this));
        this.interactions.set('touchmove', this.handleTouchMove.bind(this));
        
        this.bindEvents();
    }
    
    bindEvents() {
        this.container.addEventListener('click', this.interactions.get('click'));
        this.container.addEventListener('mouseover', this.interactions.get('hover'));
        this.container.addEventListener('mousedown', this.startDrag.bind(this));
        this.container.addEventListener('keydown', this.interactions.get('keydown'));
        this.container.addEventListener('touchstart', this.interactions.get('touchstart'));
    }
    
    handleClick(event) {
        const target = event.target;
        if (target.classList.contains('node')) {
            this.toggleNodeSelection(target.dataset.nodeId);
        } else if (target.classList.contains('edge')) {
            this.toggleEdgeHighlight(target.dataset.edgeId);
        }
        this.updateVisualization();
    }
    
    handleHover(event) {
        const target = event.target;
        if (target.classList.contains('node')) {
            this.showNodeTooltip(target);
        } else if (target.classList.contains('edge')) {
            this.showEdgeTooltip(target);
        }
    }
    
    handleDrag(event) {
        if (this.state.isDragging) {
            const deltaX = event.clientX - this.state.dragStart.x;
            const deltaY = event.clientY - this.state.dragStart.y;
            
            this.state.panOffset.x += deltaX;
            this.state.panOffset.y += deltaY;
            
            this.updateTransform();
        }
    }
    
    updateTransform() {
        const transform = `translate(${this.state.panOffset.x}px, ${this.state.panOffset.y}px) scale(${this.state.zoomLevel})`;
        this.container.style.transform = transform;
    }
}
```

### 响应式设计

```javascript
// 响应式可视化组件
class ResponsiveVisualization {
    constructor(container, data) {
        this.container = container;
        this.data = data;
        this.breakpoints = {
            mobile: 768,
            tablet: 1024,
            desktop: 1200
        };
        
        this.initResponsive();
    }
    
    initResponsive() {
        this.updateLayout();
        window.addEventListener('resize', this.debounce(this.updateLayout.bind(this), 250));
    }
    
    updateLayout() {
        const width = this.container.clientWidth;
        const height = this.container.clientHeight;
        
        if (width < this.breakpoints.mobile) {
            this.setMobileLayout();
        } else if (width < this.breakpoints.tablet) {
            this.setTabletLayout();
        } else {
            this.setDesktopLayout();
        }
        
        this.updateVisualization();
    }
    
    setMobileLayout() {
        this.config = {
            nodeSize: 8,
            fontSize: 12,
            showLabels: false,
            layout: 'force',
            maxNodes: 50
        };
    }
    
    setTabletLayout() {
        this.config = {
            nodeSize: 12,
            fontSize: 14,
            showLabels: true,
            layout: 'force',
            maxNodes: 100
        };
    }
    
    setDesktopLayout() {
        this.config = {
            nodeSize: 16,
            fontSize: 16,
            showLabels: true,
            layout: 'hierarchical',
            maxNodes: 200
        };
    }
    
    debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }
}
```

## 2. 动态可视化技术

### 动画系统

```javascript
// 动画系统
class AnimationSystem {
    constructor() {
        this.animations = new Map();
        this.easingFunctions = {
            linear: t => t,
            easeInQuad: t => t * t,
            easeOutQuad: t => t * (2 - t),
            easeInOutQuad: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t
        };
    }
    
    animate(property, fromValue, toValue, duration, easing = 'linear', callback) {
        const animationId = Date.now() + Math.random();
        const startTime = performance.now();
        const easingFunc = this.easingFunctions[easing];
        
        const animate = (currentTime) => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const easedProgress = easingFunc(progress);
            
            const currentValue = fromValue + (toValue - fromValue) * easedProgress;
            
            if (callback) {
                callback(currentValue);
            }
            
            if (progress < 1) {
                requestAnimationFrame(animate);
            } else {
                this.animations.delete(animationId);
            }
        };
        
        this.animations.set(animationId, animate);
        requestAnimationFrame(animate);
        
        return animationId;
    }
    
    stopAnimation(animationId) {
        this.animations.delete(animationId);
    }
    
    stopAllAnimations() {
        this.animations.clear();
    }
}

// 节点动画示例
class NodeAnimation {
    constructor(node, animationSystem) {
        this.node = node;
        this.animationSystem = animationSystem;
    }
    
    fadeIn(duration = 500) {
        this.node.style.opacity = '0';
        this.node.style.display = 'block';
        
        return this.animationSystem.animate(
            'opacity', 0, 1, duration, 'easeOutQuad',
            (value) => {
                this.node.style.opacity = value;
            }
        );
    }
    
    fadeOut(duration = 500) {
        return this.animationSystem.animate(
            'opacity', 1, 0, duration, 'easeInQuad',
            (value) => {
                this.node.style.opacity = value;
            }
        );
    }
    
    scaleIn(duration = 300) {
        this.node.style.transform = 'scale(0)';
        
        return this.animationSystem.animate(
            'scale', 0, 1, duration, 'easeOutQuad',
            (value) => {
                this.node.style.transform = `scale(${value})`;
            }
        );
    }
    
    moveTo(x, y, duration = 500) {
        const currentX = parseFloat(this.node.style.left) || 0;
        const currentY = parseFloat(this.node.style.top) || 0;
        
        return this.animationSystem.animate(
            'position', 0, 1, duration, 'easeInOutQuad',
            (progress) => {
                const newX = currentX + (x - currentX) * progress;
                const newY = currentY + (y - currentY) * progress;
                this.node.style.left = `${newX}px`;
                this.node.style.top = `${newY}px`;
            }
        );
    }
}
```

### 实时数据更新

```javascript
// 实时数据可视化
class RealTimeVisualization {
    constructor(container, dataSource) {
        this.container = container;
        this.dataSource = dataSource;
        this.updateQueue = [];
        this.isUpdating = false;
        
        this.initRealTimeUpdates();
    }
    
    initRealTimeUpdates() {
        // 设置数据源监听
        this.dataSource.on('dataUpdate', this.handleDataUpdate.bind(this));
        this.dataSource.on('nodeAdded', this.handleNodeAdded.bind(this));
        this.dataSource.on('nodeRemoved', this.handleNodeRemoved.bind(this));
        this.dataSource.on('edgeAdded', this.handleEdgeAdded.bind(this));
        this.dataSource.on('edgeRemoved', this.handleEdgeRemoved.bind(this));
    }
    
    handleDataUpdate(updateData) {
        this.updateQueue.push(updateData);
        
        if (!this.isUpdating) {
            this.processUpdateQueue();
        }
    }
    
    processUpdateQueue() {
        if (this.updateQueue.length === 0) {
            this.isUpdating = false;
            return;
        }
        
        this.isUpdating = true;
        const updates = this.updateQueue.splice(0, 10); // 批量处理
        
        updates.forEach(update => {
            this.applyUpdate(update);
        });
        
        this.updateVisualization();
        
        // 继续处理队列
        requestAnimationFrame(() => {
            this.processUpdateQueue();
        });
    }
    
    applyUpdate(update) {
        switch (update.type) {
            case 'nodeUpdate':
                this.updateNode(update.nodeId, update.data);
                break;
            case 'edgeUpdate':
                this.updateEdge(update.edgeId, update.data);
                break;
            case 'nodeAdd':
                this.addNode(update.node);
                break;
            case 'nodeRemove':
                this.removeNode(update.nodeId);
                break;
            case 'edgeAdd':
                this.addEdge(update.edge);
                break;
            case 'edgeRemove':
                this.removeEdge(update.edgeId);
                break;
        }
    }
    
    updateNode(nodeId, data) {
        const nodeElement = this.container.querySelector(`[data-node-id="${nodeId}"]`);
        if (nodeElement) {
            // 应用数据更新
            Object.keys(data).forEach(key => {
                if (key === 'position') {
                    this.animateNodePosition(nodeElement, data[key]);
                } else if (key === 'size') {
                    this.animateNodeSize(nodeElement, data[key]);
                } else if (key === 'color') {
                    this.animateNodeColor(nodeElement, data[key]);
                }
            });
        }
    }
    
    animateNodePosition(nodeElement, newPosition) {
        const currentX = parseFloat(nodeElement.style.left) || 0;
        const currentY = parseFloat(nodeElement.style.top) || 0;
        
        this.animationSystem.animate(
            'position', 0, 1, 300, 'easeOutQuad',
            (progress) => {
                const x = currentX + (newPosition.x - currentX) * progress;
                const y = currentY + (newPosition.y - currentY) * progress;
                nodeElement.style.left = `${x}px`;
                nodeElement.style.top = `${y}px`;
            }
        );
    }
}
```

## 3. 多维度展示

### 分层可视化

```javascript
// 分层可视化系统
class LayeredVisualization {
    constructor(container) {
        this.container = container;
        this.layers = new Map();
        this.layerOrder = [];
        
        this.initLayers();
    }
    
    initLayers() {
        // 创建基础图层
        this.createLayer('background', 0);
        this.createLayer('grid', 1);
        this.createLayer('edges', 2);
        this.createLayer('nodes', 3);
        this.createLayer('labels', 4);
        this.createLayer('overlay', 5);
        this.createLayer('tooltip', 6);
    }
    
    createLayer(name, zIndex) {
        const layer = document.createElement('div');
        layer.className = `layer layer-${name}`;
        layer.style.position = 'absolute';
        layer.style.top = '0';
        layer.style.left = '0';
        layer.style.width = '100%';
        layer.style.height = '100%';
        layer.style.zIndex = zIndex;
        layer.style.pointerEvents = 'none';
        
        this.container.appendChild(layer);
        this.layers.set(name, layer);
        this.layerOrder.push(name);
    }
    
    getLayer(name) {
        return this.layers.get(name);
    }
    
    addToLayer(layerName, element) {
        const layer = this.getLayer(layerName);
        if (layer) {
            layer.appendChild(element);
            element.style.pointerEvents = 'auto';
        }
    }
    
    removeFromLayer(layerName, element) {
        const layer = this.getLayer(layerName);
        if (layer && element.parentNode === layer) {
            layer.removeChild(element);
        }
    }
    
    setLayerVisibility(layerName, visible) {
        const layer = this.getLayer(layerName);
        if (layer) {
            layer.style.display = visible ? 'block' : 'none';
        }
    }
    
    setLayerOpacity(layerName, opacity) {
        const layer = this.getLayer(layerName);
        if (layer) {
            layer.style.opacity = opacity;
        }
    }
}

// 多维数据展示
class MultiDimensionalVisualization {
    constructor(container, data) {
        this.container = container;
        this.data = data;
        this.dimensions = new Map();
        this.currentView = 'default';
        
        this.initDimensions();
    }
    
    initDimensions() {
        // 定义不同维度的视图
        this.dimensions.set('temporal', this.createTemporalView.bind(this));
        this.dimensions.set('hierarchical', this.createHierarchicalView.bind(this));
        this.dimensions.set('spatial', this.createSpatialView.bind(this));
        this.dimensions.set('categorical', this.createCategoricalView.bind(this));
        this.dimensions.set('network', this.createNetworkView.bind(this));
    }
    
    switchView(viewName) {
        if (this.dimensions.has(viewName)) {
            this.currentView = viewName;
            this.clearContainer();
            this.dimensions.get(viewName)();
        }
    }
    
    createTemporalView() {
        // 时间维度视图
        const timeline = document.createElement('div');
        timeline.className = 'timeline-view';
        
        // 创建时间轴
        const timeAxis = this.createTimeAxis();
        timeline.appendChild(timeAxis);
        
        // 创建时间点标记
        this.data.forEach(item => {
            const timePoint = this.createTimePoint(item);
            timeline.appendChild(timePoint);
        });
        
        this.container.appendChild(timeline);
    }
    
    createHierarchicalView() {
        // 层次结构视图
        const tree = document.createElement('div');
        tree.className = 'hierarchical-view';
        
        // 创建树形结构
        const treeRoot = this.createTreeStructure(this.data);
        tree.appendChild(treeRoot);
        
        this.container.appendChild(tree);
    }
    
    createSpatialView() {
        // 空间维度视图
        const map = document.createElement('div');
        map.className = 'spatial-view';
        
        // 创建地图容器
        const mapContainer = this.createMapContainer();
        map.appendChild(mapContainer);
        
        // 添加空间标记
        this.data.forEach(item => {
            if (item.coordinates) {
                const marker = this.createSpatialMarker(item);
                mapContainer.appendChild(marker);
            }
        });
        
        this.container.appendChild(map);
    }
    
    createCategoricalView() {
        // 分类维度视图
        const categories = document.createElement('div');
        categories.className = 'categorical-view';
        
        // 按类别分组
        const groupedData = this.groupByCategory(this.data);
        
        Object.keys(groupedData).forEach(category => {
            const categoryGroup = this.createCategoryGroup(category, groupedData[category]);
            categories.appendChild(categoryGroup);
        });
        
        this.container.appendChild(categories);
    }
    
    createNetworkView() {
        // 网络关系视图
        const network = document.createElement('div');
        network.className = 'network-view';
        
        // 创建力导向图
        const forceGraph = this.createForceDirectedGraph(this.data);
        network.appendChild(forceGraph);
        
        this.container.appendChild(network);
    }
}
```

## 4. 用户界面组件

### 控制面板

```javascript
// 交互控制面板
class ControlPanel {
    constructor(container, visualization) {
        this.container = container;
        this.visualization = visualization;
        this.controls = new Map();
        
        this.createControlPanel();
    }
    
    createControlPanel() {
        const panel = document.createElement('div');
        panel.className = 'control-panel';
        panel.style.cssText = `
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 1000;
        `;
        
        // 添加视图切换控制
        this.addViewSelector(panel);
        
        // 添加缩放控制
        this.addZoomControls(panel);
        
        // 添加过滤器
        this.addFilters(panel);
        
        // 添加搜索框
        this.addSearchBox(panel);
        
        this.container.appendChild(panel);
    }
    
    addViewSelector(panel) {
        const viewSelector = document.createElement('div');
        viewSelector.className = 'view-selector';
        viewSelector.innerHTML = `
            <label>视图模式:</label>
            <select id="viewMode">
                <option value="network">网络图</option>
                <option value="hierarchical">层次图</option>
                <option value="temporal">时间轴</option>
                <option value="spatial">空间图</option>
            </select>
        `;
        
        viewSelector.querySelector('#viewMode').addEventListener('change', (e) => {
            this.visualization.switchView(e.target.value);
        });
        
        panel.appendChild(viewSelector);
    }
    
    addZoomControls(panel) {
        const zoomControls = document.createElement('div');
        zoomControls.className = 'zoom-controls';
        zoomControls.innerHTML = `
            <button id="zoomIn">+</button>
            <span id="zoomLevel">100%</span>
            <button id="zoomOut">-</button>
            <button id="resetZoom">重置</button>
        `;
        
        zoomControls.querySelector('#zoomIn').addEventListener('click', () => {
            this.visualization.zoomIn();
        });
        
        zoomControls.querySelector('#zoomOut').addEventListener('click', () => {
            this.visualization.zoomOut();
        });
        
        zoomControls.querySelector('#resetZoom').addEventListener('click', () => {
            this.visualization.resetZoom();
        });
        
        panel.appendChild(zoomControls);
    }
    
    addFilters(panel) {
        const filters = document.createElement('div');
        filters.className = 'filters';
        filters.innerHTML = `
            <label>节点类型:</label>
            <div class="filter-group">
                <input type="checkbox" id="filterPerson" checked>
                <label for="filterPerson">人员</label>
                <input type="checkbox" id="filterCompany" checked>
                <label for="filterCompany">公司</label>
                <input type="checkbox" id="filterLocation" checked>
                <label for="filterLocation">地点</label>
            </div>
        `;
        
        // 添加过滤器事件监听
        filters.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
            checkbox.addEventListener('change', () => {
                this.updateFilters();
            });
        });
        
        panel.appendChild(filters);
    }
    
    addSearchBox(panel) {
        const searchBox = document.createElement('div');
        searchBox.className = 'search-box';
        searchBox.innerHTML = `
            <input type="text" id="searchInput" placeholder="搜索节点...">
            <button id="searchBtn">搜索</button>
        `;
        
        searchBox.querySelector('#searchBtn').addEventListener('click', () => {
            const query = searchBox.querySelector('#searchInput').value;
            this.visualization.searchNodes(query);
        });
        
        searchBox.querySelector('#searchInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const query = e.target.value;
                this.visualization.searchNodes(query);
            }
        });
        
        panel.appendChild(searchBox);
    }
    
    updateFilters() {
        const filters = {
            person: this.container.querySelector('#filterPerson').checked,
            company: this.container.querySelector('#filterCompany').checked,
            location: this.container.querySelector('#filterLocation').checked
        };
        
        this.visualization.applyFilters(filters);
    }
}
```

### 工具栏

```javascript
// 可视化工具栏
class Toolbar {
    constructor(container, visualization) {
        this.container = container;
        this.visualization = visualization;
        this.tools = new Map();
        
        this.createToolbar();
    }
    
    createToolbar() {
        const toolbar = document.createElement('div');
        toolbar.className = 'toolbar';
        toolbar.style.cssText = `
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            padding: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 1000;
        `;
        
        // 添加工具按钮
        this.addToolButton(toolbar, 'select', '选择', 'cursor');
        this.addToolButton(toolbar, 'pan', '平移', 'move');
        this.addToolButton(toolbar, 'zoom', '缩放', 'search');
        this.addToolButton(toolbar, 'lasso', '套索', 'polygon');
        this.addToolButton(toolbar, 'measure', '测量', 'ruler');
        
        this.container.appendChild(toolbar);
    }
    
    addToolButton(toolbar, toolId, label, icon) {
        const button = document.createElement('button');
        button.className = 'tool-button';
        button.dataset.tool = toolId;
        button.innerHTML = `<i class="icon-${icon}"></i> ${label}`;
        button.style.cssText = `
            display: block;
            width: 100%;
            margin: 2px 0;
            padding: 8px;
            border: none;
            background: transparent;
            cursor: pointer;
            border-radius: 4px;
            transition: background-color 0.2s;
        `;
        
        button.addEventListener('click', () => {
            this.activateTool(toolId);
        });
        
        button.addEventListener('mouseenter', () => {
            button.style.backgroundColor = '#f0f0f0';
        });
        
        button.addEventListener('mouseleave', () => {
            if (!button.classList.contains('active')) {
                button.style.backgroundColor = 'transparent';
            }
        });
        
        toolbar.appendChild(button);
        this.tools.set(toolId, button);
    }
    
    activateTool(toolId) {
        // 停用所有工具
        this.tools.forEach((button, id) => {
            button.classList.remove('active');
            button.style.backgroundColor = 'transparent';
        });
        
        // 激活选中的工具
        const activeButton = this.tools.get(toolId);
        if (activeButton) {
            activeButton.classList.add('active');
            activeButton.style.backgroundColor = '#e0e0e0';
        }
        
        // 通知可视化组件切换工具
        this.visualization.setActiveTool(toolId);
    }
}
```

## 5. 性能优化

### 渲染优化

```javascript
// 高性能渲染系统
class HighPerformanceRenderer {
    constructor(container) {
        this.container = container;
        this.renderQueue = [];
        this.isRendering = false;
        this.frameCount = 0;
        this.lastFrameTime = 0;
        
        this.initRenderer();
    }
    
    initRenderer() {
        // 使用requestAnimationFrame进行渲染
        this.renderLoop();
        
        // 设置性能监控
        this.setupPerformanceMonitoring();
    }
    
    renderLoop() {
        const currentTime = performance.now();
        const deltaTime = currentTime - this.lastFrameTime;
        
        if (deltaTime >= 16.67) { // 60 FPS
            this.processRenderQueue();
            this.lastFrameTime = currentTime;
            this.frameCount++;
        }
        
        requestAnimationFrame(() => this.renderLoop());
    }
    
    processRenderQueue() {
        if (this.renderQueue.length === 0) {
            return;
        }
        
        // 批量处理渲染任务
        const batchSize = Math.min(10, this.renderQueue.length);
        const batch = this.renderQueue.splice(0, batchSize);
        
        batch.forEach(task => {
            this.executeRenderTask(task);
        });
    }
    
    executeRenderTask(task) {
        switch (task.type) {
            case 'createNode':
                this.createNodeElement(task.data);
                break;
            case 'updateNode':
                this.updateNodeElement(task.nodeId, task.data);
                break;
            case 'removeNode':
                this.removeNodeElement(task.nodeId);
                break;
            case 'createEdge':
                this.createEdgeElement(task.data);
                break;
            case 'updateEdge':
                this.updateEdgeElement(task.edgeId, task.data);
                break;
            case 'removeEdge':
                this.removeEdgeElement(task.edgeId);
                break;
        }
    }
    
    addRenderTask(task) {
        this.renderQueue.push(task);
    }
    
    setupPerformanceMonitoring() {
        // 监控渲染性能
        setInterval(() => {
            const fps = this.frameCount;
            this.frameCount = 0;
            
            if (fps < 30) {
                console.warn(`Low FPS detected: ${fps}`);
                this.optimizeRendering();
            }
        }, 1000);
    }
    
    optimizeRendering() {
        // 减少渲染质量
        this.container.style.imageRendering = 'pixelated';
        
        // 减少动画
        this.container.style.transition = 'none';
        
        // 隐藏不必要的元素
        const labels = this.container.querySelectorAll('.node-label');
        labels.forEach(label => {
            label.style.display = 'none';
        });
    }
}

// 虚拟化渲染
class VirtualizedRenderer {
    constructor(container, data) {
        this.container = container;
        this.data = data;
        this.visibleElements = new Set();
        this.elementPool = new Map();
        
        this.initVirtualization();
    }
    
    initVirtualization() {
        // 创建视口
        this.viewport = {
            x: 0,
            y: 0,
            width: this.container.clientWidth,
            height: this.container.clientHeight
        };
        
        // 监听滚动事件
        this.container.addEventListener('scroll', this.handleScroll.bind(this));
        
        // 初始渲染
        this.updateVisibleElements();
    }
    
    handleScroll() {
        this.updateViewport();
        this.updateVisibleElements();
    }
    
    updateViewport() {
        this.viewport.x = this.container.scrollLeft;
        this.viewport.y = this.container.scrollTop;
        this.viewport.width = this.container.clientWidth;
        this.viewport.height = this.container.clientHeight;
    }
    
    updateVisibleElements() {
        const newVisibleElements = new Set();
        
        this.data.forEach(item => {
            if (this.isElementVisible(item)) {
                newVisibleElements.add(item.id);
                this.ensureElementRendered(item);
            } else {
                this.hideElement(item.id);
            }
        });
        
        // 移除不可见的元素
        this.visibleElements.forEach(elementId => {
            if (!newVisibleElements.has(elementId)) {
                this.removeElement(elementId);
            }
        });
        
        this.visibleElements = newVisibleElements;
    }
    
    isElementVisible(item) {
        const elementBounds = this.getElementBounds(item);
        
        return (
            elementBounds.x < this.viewport.x + this.viewport.width &&
            elementBounds.x + elementBounds.width > this.viewport.x &&
            elementBounds.y < this.viewport.y + this.viewport.height &&
            elementBounds.y + elementBounds.height > this.viewport.y
        );
    }
    
    getElementBounds(item) {
        // 计算元素边界
        return {
            x: item.x || 0,
            y: item.y || 0,
            width: item.width || 50,
            height: item.height || 50
        };
    }
    
    ensureElementRendered(item) {
        if (!this.elementPool.has(item.id)) {
            const element = this.createElement(item);
            this.elementPool.set(item.id, element);
            this.container.appendChild(element);
        }
    }
    
    hideElement(elementId) {
        const element = this.elementPool.get(elementId);
        if (element) {
            element.style.display = 'none';
        }
    }
    
    removeElement(elementId) {
        const element = this.elementPool.get(elementId);
        if (element) {
            this.container.removeChild(element);
            this.elementPool.delete(elementId);
        }
    }
}
```

### 内存管理

```javascript
// 内存管理系统
class MemoryManager {
    constructor() {
        this.cache = new Map();
        this.cacheSize = 0;
        this.maxCacheSize = 50 * 1024 * 1024; // 50MB
        this.accessCount = new Map();
        
        this.setupMemoryMonitoring();
    }
    
    setupMemoryMonitoring() {
        // 监控内存使用
        setInterval(() => {
            this.checkMemoryUsage();
        }, 5000);
    }
    
    checkMemoryUsage() {
        if (this.cacheSize > this.maxCacheSize) {
            this.cleanupCache();
        }
    }
    
    cleanupCache() {
        // LRU缓存清理
        const entries = Array.from(this.cache.entries());
        entries.sort((a, b) => {
            const countA = this.accessCount.get(a[0]) || 0;
            const countB = this.accessCount.get(b[0]) || 0;
            return countA - countB;
        });
        
        // 移除最不常用的缓存项
        const itemsToRemove = Math.floor(entries.length * 0.3);
        for (let i = 0; i < itemsToRemove; i++) {
            const [key] = entries[i];
            this.removeFromCache(key);
        }
    }
    
    addToCache(key, value) {
        const size = this.estimateSize(value);
        
        if (this.cacheSize + size > this.maxCacheSize) {
            this.cleanupCache();
        }
        
        this.cache.set(key, value);
        this.cacheSize += size;
        this.accessCount.set(key, 0);
    }
    
    getFromCache(key) {
        const value = this.cache.get(key);
        if (value) {
            const count = this.accessCount.get(key) || 0;
            this.accessCount.set(key, count + 1);
        }
        return value;
    }
    
    removeFromCache(key) {
        const value = this.cache.get(key);
        if (value) {
            const size = this.estimateSize(value);
            this.cacheSize -= size;
            this.cache.delete(key);
            this.accessCount.delete(key);
        }
    }
    
    estimateSize(obj) {
        // 简单的大小估算
        const str = JSON.stringify(obj);
        return str.length * 2; // 假设每个字符2字节
    }
}
```

## 6. 应用案例

### 知识图谱浏览器

```javascript
// 知识图谱交互式浏览器
class KnowledgeGraphBrowser {
    constructor(container, graphData) {
        this.container = container;
        this.graphData = graphData;
        this.selectedNode = null;
        this.highlightedPath = [];
        
        this.initBrowser();
    }
    
    initBrowser() {
        // 创建主视图
        this.createMainView();
        
        // 创建侧边栏
        this.createSidebar();
        
        // 创建详情面板
        this.createDetailPanel();
        
        // 绑定事件
        this.bindEvents();
    }
    
    createMainView() {
        this.mainView = document.createElement('div');
        this.mainView.className = 'main-view';
        this.mainView.style.cssText = `
            flex: 1;
            position: relative;
            overflow: hidden;
        `;
        
        // 创建图形渲染区域
        this.graphContainer = document.createElement('div');
        this.graphContainer.className = 'graph-container';
        this.mainView.appendChild(this.graphContainer);
        
        this.container.appendChild(this.mainView);
    }
    
    createSidebar() {
        this.sidebar = document.createElement('div');
        this.sidebar.className = 'sidebar';
        this.sidebar.style.cssText = `
            width: 300px;
            background: #f5f5f5;
            border-right: 1px solid #ddd;
            overflow-y: auto;
        `;
        
        // 添加搜索框
        this.addSearchBox();
        
        // 添加过滤器
        this.addFilters();
        
        // 添加统计信息
        this.addStatistics();
        
        this.container.appendChild(this.sidebar);
    }
    
    createDetailPanel() {
        this.detailPanel = document.createElement('div');
        this.detailPanel.className = 'detail-panel';
        this.detailPanel.style.cssText = `
            position: absolute;
            right: 0;
            top: 0;
            width: 400px;
            height: 100%;
            background: white;
            border-left: 1px solid #ddd;
            transform: translateX(100%);
            transition: transform 0.3s;
            z-index: 1000;
        `;
        
        this.container.appendChild(this.detailPanel);
    }
    
    addSearchBox() {
        const searchBox = document.createElement('div');
        searchBox.className = 'search-box';
        searchBox.innerHTML = `
            <input type="text" placeholder="搜索实体..." id="searchInput">
            <button id="searchBtn">搜索</button>
        `;
        
        searchBox.querySelector('#searchBtn').addEventListener('click', () => {
            const query = searchBox.querySelector('#searchInput').value;
            this.searchEntities(query);
        });
        
        this.sidebar.appendChild(searchBox);
    }
    
    addFilters() {
        const filters = document.createElement('div');
        filters.className = 'filters';
        filters.innerHTML = `
            <h3>过滤器</h3>
            <div class="filter-group">
                <label>
                    <input type="checkbox" id="filterPerson" checked>
                    人员
                </label>
                <label>
                    <input type="checkbox" id="filterCompany" checked>
                    公司
                </label>
                <label>
                    <input type="checkbox" id="filterLocation" checked>
                    地点
                </label>
            </div>
        `;
        
        filters.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
            checkbox.addEventListener('change', () => {
                this.applyFilters();
            });
        });
        
        this.sidebar.appendChild(filters);
    }
    
    addStatistics() {
        const stats = document.createElement('div');
        stats.className = 'statistics';
        stats.innerHTML = `
            <h3>统计信息</h3>
            <div class="stat-item">
                <span>节点数量:</span>
                <span id="nodeCount">0</span>
            </div>
            <div class="stat-item">
                <span>边数量:</span>
                <span id="edgeCount">0</span>
            </div>
            <div class="stat-item">
                <span>选中节点:</span>
                <span id="selectedCount">0</span>
            </div>
        `;
        
        this.sidebar.appendChild(stats);
        this.updateStatistics();
    }
    
    bindEvents() {
        // 节点点击事件
        this.graphContainer.addEventListener('click', (e) => {
            if (e.target.classList.contains('node')) {
                this.selectNode(e.target.dataset.nodeId);
            }
        });
        
        // 节点悬停事件
        this.graphContainer.addEventListener('mouseover', (e) => {
            if (e.target.classList.contains('node')) {
                this.highlightNode(e.target.dataset.nodeId);
            }
        });
        
        // 节点离开事件
        this.graphContainer.addEventListener('mouseout', (e) => {
            if (e.target.classList.contains('node')) {
                this.unhighlightNode(e.target.dataset.nodeId);
            }
        });
    }
    
    selectNode(nodeId) {
        this.selectedNode = nodeId;
        this.showNodeDetails(nodeId);
        this.highlightConnectedNodes(nodeId);
        this.updateStatistics();
    }
    
    showNodeDetails(nodeId) {
        const node = this.graphData.nodes.find(n => n.id === nodeId);
        if (node) {
            this.detailPanel.innerHTML = `
                <div class="detail-header">
                    <h2>${node.name}</h2>
                    <button class="close-btn" onclick="this.parentElement.parentElement.style.transform='translateX(100%)'">×</button>
                </div>
                <div class="detail-content">
                    <div class="detail-section">
                        <h3>基本信息</h3>
                        <p><strong>类型:</strong> ${node.type}</p>
                        <p><strong>ID:</strong> ${node.id}</p>
                        ${node.description ? `<p><strong>描述:</strong> ${node.description}</p>` : ''}
                    </div>
                    <div class="detail-section">
                        <h3>连接关系</h3>
                        <div id="connections"></div>
                    </div>
                </div>
            `;
            
            this.detailPanel.style.transform = 'translateX(0)';
            this.loadNodeConnections(nodeId);
        }
    }
    
    loadNodeConnections(nodeId) {
        const connections = this.graphData.edges.filter(edge => 
            edge.source === nodeId || edge.target === nodeId
        );
        
        const connectionsContainer = this.detailPanel.querySelector('#connections');
        connectionsContainer.innerHTML = connections.map(edge => {
            const otherNode = edge.source === nodeId ? edge.target : edge.source;
            const node = this.graphData.nodes.find(n => n.id === otherNode);
            return `
                <div class="connection-item">
                    <span class="connection-type">${edge.type}</span>
                    <span class="connection-target">${node ? node.name : otherNode}</span>
                </div>
            `;
        }).join('');
    }
    
    highlightConnectedNodes(nodeId) {
        // 高亮连接的节点
        const connectedEdges = this.graphData.edges.filter(edge => 
            edge.source === nodeId || edge.target === nodeId
        );
        
        connectedEdges.forEach(edge => {
            const edgeElement = this.graphContainer.querySelector(`[data-edge-id="${edge.id}"]`);
            if (edgeElement) {
                edgeElement.classList.add('highlighted');
            }
        });
    }
    
    searchEntities(query) {
        const results = this.graphData.nodes.filter(node => 
            node.name.toLowerCase().includes(query.toLowerCase()) ||
            (node.description && node.description.toLowerCase().includes(query.toLowerCase()))
        );
        
        this.showSearchResults(results);
    }
    
    showSearchResults(results) {
        const resultsContainer = document.createElement('div');
        resultsContainer.className = 'search-results';
        resultsContainer.innerHTML = `
            <h3>搜索结果 (${results.length})</h3>
            ${results.map(node => `
                <div class="search-result-item" onclick="this.parentElement.parentElement.remove(); this.selectNode('${node.id}')">
                    <strong>${node.name}</strong>
                    <span class="node-type">${node.type}</span>
                </div>
            `).join('')}
        `;
        
        this.sidebar.appendChild(resultsContainer);
    }
    
    updateStatistics() {
        const nodeCount = this.graphData.nodes.length;
        const edgeCount = this.graphData.edges.length;
        const selectedCount = this.selectedNode ? 1 : 0;
        
        this.sidebar.querySelector('#nodeCount').textContent = nodeCount;
        this.sidebar.querySelector('#edgeCount').textContent = edgeCount;
        this.sidebar.querySelector('#selectedCount').textContent = selectedCount;
    }
}
```

## 7. 工具与平台

### 前端框架

1. **D3.js**：数据驱动文档
2. **Three.js**：3D图形库
3. **PixiJS**：2D渲染引擎
4. **Canvas API**：原生画布API

### 可视化库

1. **Vis.js**：动态可视化库
2. **Cytoscape.js**：图论可视化
3. **Sigma.js**：图形可视化
4. **Gephi**：网络分析平台

### 交互框架

1. **React**：用户界面库
2. **Vue.js**：渐进式框架
3. **Angular**：完整框架
4. **Svelte**：编译时框架

## 8. 发展趋势

### 技术趋势

1. **WebGL加速**：硬件加速渲染
2. **WebAssembly**：高性能计算
3. **VR/AR集成**：沉浸式可视化
4. **AI辅助交互**：智能交互设计

### 应用趋势

1. **实时协作**：多人同时编辑
2. **移动端优化**：响应式设计
3. **无障碍访问**：包容性设计
4. **数据隐私**：安全可视化

## 9. 学习资源

### 经典教材

1. **《Interactive Data Visualization》** - 交互式数据可视化
2. **《Visualization Analysis and Design》** - 可视化分析与设计
3. **《The Visual Display of Quantitative Information》** - 定量信息可视化

### 在线资源

1. **Observable**：交互式笔记本平台
2. **D3 Gallery**：D3.js示例库
3. **Visualization Universe**：可视化项目集合

### 实践项目

1. **数据仪表板**：构建交互式仪表板
2. **故事化可视化**：创建数据故事
3. **实时监控系统**：开发实时数据监控

## 多表征

交互式可视化支持多种表征方式，包括：

- 动态图形/动画（交互节点、动态布局）
- 事件流/状态机（交互逻辑）
- 向量/矩阵（动态嵌入、布局）
- 自然语言与图像
这些表征可互映，提升交互表达力。

## 形式化语义

- 语义域：$D$，如交互对象集、事件集、状态空间
- 解释函数：$I: S \to D$，将交互结构/符号映射到具体交互对象
- 语义一致性：每个交互元素/事件在$D$中有明确定义

## 形式化语法与证明

- 语法规则：如交互元素产生式、事件规则、状态转移规则
- **定理**：交互式可视化的语法系统具一致性与可扩展性。
- **证明**：由交互语法与规则递归定义，保证系统一致与可扩展。
