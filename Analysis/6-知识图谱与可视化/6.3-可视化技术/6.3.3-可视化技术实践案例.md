# 可视化技术实践案例

## 概述

本文档提供知识图谱可视化技术的实践应用案例，涵盖网络图可视化、统计图表、交互式可视化等实际场景。

## 1. 网络图可视化

### 1.1 基础网络图可视化

```python
import networkx as nx
import matplotlib.pyplot as plt
import plotly.graph_objects as go
import plotly.express as px
from typing import Dict, List, Tuple
import numpy as np

class NetworkVisualizer:
    def __init__(self):
        self.graph = nx.Graph()
        self.node_colors = {}
        self.edge_colors = {}
        self.node_sizes = {}
    
    def add_node(self, node_id: str, node_type: str = "default", 
                 attributes: Dict = None):
        """添加节点"""
        self.graph.add_node(node_id, 
                           type=node_type,
                           **(attributes or {}))
        
        # 设置默认颜色和大小
        if node_type == "person":
            self.node_colors[node_id] = "lightblue"
            self.node_sizes[node_id] = 500
        elif node_type == "organization":
            self.node_colors[node_id] = "lightgreen"
            self.node_sizes[node_id] = 800
        elif node_type == "concept":
            self.node_colors[node_id] = "lightcoral"
            self.node_sizes[node_id] = 400
        else:
            self.node_colors[node_id] = "lightgray"
            self.node_sizes[node_id] = 300
    
    def add_edge(self, node1: str, node2: str, 
                 relation_type: str = "default", weight: float = 1.0):
        """添加边"""
        self.graph.add_edge(node1, node2, 
                           relation=relation_type,
                           weight=weight)
        
        # 设置边的颜色
        if relation_type == "friend":
            self.edge_colors[(node1, node2)] = "blue"
        elif relation_type == "work":
            self.edge_colors[(node1, node2)] = "green"
        elif relation_type == "study":
            self.edge_colors[(node1, node2)] = "orange"
        else:
            self.edge_colors[(node1, node2)] = "gray"
    
    def visualize_matplotlib(self, layout: str = "spring", 
                           figsize: Tuple[int, int] = (12, 8)):
        """使用matplotlib可视化"""
        plt.figure(figsize=figsize)
        
        # 选择布局算法
        if layout == "spring":
            pos = nx.spring_layout(self.graph)
        elif layout == "circular":
            pos = nx.circular_layout(self.graph)
        elif layout == "random":
            pos = nx.random_layout(self.graph)
        elif layout == "shell":
            pos = nx.shell_layout(self.graph)
        else:
            pos = nx.spring_layout(self.graph)
        
        # 准备节点颜色和大小
        node_colors = [self.node_colors.get(node, "lightgray") 
                      for node in self.graph.nodes()]
        node_sizes = [self.node_sizes.get(node, 300) 
                     for node in self.graph.nodes()]
        
        # 准备边颜色
        edge_colors = [self.edge_colors.get(edge, "gray") 
                      for edge in self.graph.edges()]
        
        # 绘制网络
        nx.draw(self.graph, pos,
                node_color=node_colors,
                node_size=node_sizes,
                edge_color=edge_colors,
                with_labels=True,
                font_size=8,
                font_weight='bold',
                alpha=0.8)
        
        plt.title("知识图谱网络可视化")
        plt.axis('off')
        plt.show()
    
    def visualize_plotly(self, layout: str = "spring"):
        """使用plotly交互式可视化"""
        # 选择布局算法
        if layout == "spring":
            pos = nx.spring_layout(self.graph)
        elif layout == "circular":
            pos = nx.circular_layout(self.graph)
        else:
            pos = nx.spring_layout(self.graph)
        
        # 准备节点数据
        node_x = []
        node_y = []
        node_text = []
        node_colors = []
        node_sizes = []
        
        for node in self.graph.nodes():
            x, y = pos[node]
            node_x.append(x)
            node_y.append(y)
            node_text.append(f"{node}<br>类型: {self.graph.nodes[node].get('type', 'default')}")
            node_colors.append(self.node_colors.get(node, "lightgray"))
            node_sizes.append(self.node_sizes.get(node, 300))
        
        # 准备边数据
        edge_x = []
        edge_y = []
        edge_text = []
        
        for edge in self.graph.edges():
            x0, y0 = pos[edge[0]]
            x1, y1 = pos[edge[1]]
            edge_x.extend([x0, x1, None])
            edge_y.extend([y0, y1, None])
            edge_text.append(f"{edge[0]} -> {edge[1]}<br>关系: {self.graph.edges[edge]['relation']}")
        
        # 创建图形
        fig = go.Figure()
        
        # 添加边
        fig.add_trace(go.Scatter(
            x=edge_x, y=edge_y,
            line=dict(width=1, color='gray'),
            hoverinfo='none',
            mode='lines'))
        
        # 添加节点
        fig.add_trace(go.Scatter(
            x=node_x, y=node_y,
            mode='markers+text',
            hoverinfo='text',
            text=node_text,
            textposition="middle center",
            marker=dict(
                size=node_sizes,
                color=node_colors,
                line=dict(width=2, color='white')
            )))
        
        fig.update_layout(
            title="知识图谱交互式可视化",
            showlegend=False,
            hovermode='closest',
            margin=dict(b=20,l=5,r=5,t=40),
            xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
            yaxis=dict(showgrid=False, zeroline=False, showticklabels=False)
        )
        
        fig.show()

# 使用示例
visualizer = NetworkVisualizer()

# 添加节点
visualizer.add_node("张三", "person", {"age": 30, "department": "技术部"})
visualizer.add_node("李四", "person", {"age": 28, "department": "数据部"})
visualizer.add_node("王五", "person", {"age": 35, "department": "技术部"})
visualizer.add_node("公司A", "organization", {"industry": "科技"})
visualizer.add_node("机器学习", "concept", {"category": "AI"})

# 添加边
visualizer.add_edge("张三", "李四", "friend", 0.8)
visualizer.add_edge("张三", "王五", "work", 0.9)
visualizer.add_edge("李四", "机器学习", "study", 0.7)
visualizer.add_edge("张三", "公司A", "work", 0.9)

# 可视化
visualizer.visualize_matplotlib("spring", (10, 8))
```

### 1.2 分层网络图可视化

```python
class HierarchicalNetworkVisualizer:
    def __init__(self):
        self.graph = nx.DiGraph()
        self.hierarchy_levels = {}
        self.node_positions = {}
    
    def add_hierarchical_node(self, node_id: str, level: int, 
                             node_type: str = "default", attributes: Dict = None):
        """添加分层节点"""
        self.graph.add_node(node_id, 
                           level=level,
                           type=node_type,
                           **(attributes or {}))
        
        if level not in self.hierarchy_levels:
            self.hierarchy_levels[level] = []
        self.hierarchy_levels[level].append(node_id)
    
    def add_hierarchical_edge(self, from_node: str, to_node: str, 
                             relation_type: str = "default"):
        """添加分层边"""
        self.graph.add_edge(from_node, to_node, relation=relation_type)
    
    def calculate_hierarchical_layout(self, level_spacing: float = 2.0):
        """计算分层布局"""
        max_level = max(self.hierarchy_levels.keys())
        
        for level in self.hierarchy_levels:
            nodes = self.hierarchy_levels[level]
            y_pos = (max_level - level) * level_spacing
            
            for i, node in enumerate(nodes):
                x_pos = (i - len(nodes) / 2) * 1.5
                self.node_positions[node] = (x_pos, y_pos)
    
    def visualize_hierarchical(self, figsize: Tuple[int, int] = (12, 10)):
        """可视化分层网络"""
        self.calculate_hierarchical_layout()
        
        plt.figure(figsize=figsize)
        
        # 绘制边
        for edge in self.graph.edges():
            x1, y1 = self.node_positions[edge[0]]
            x2, y2 = self.node_positions[edge[1]]
            plt.plot([x1, x2], [y1, y2], 'gray', alpha=0.6, linewidth=1)
        
        # 绘制节点
        for node in self.graph.nodes():
            x, y = self.node_positions[node]
            node_type = self.graph.nodes[node].get('type', 'default')
            
            if node_type == "root":
                color = "red"
                size = 1000
            elif node_type == "branch":
                color = "orange"
                size = 600
            elif node_type == "leaf":
                color = "lightblue"
                size = 400
            else:
                color = "lightgray"
                size = 500
            
            plt.scatter(x, y, c=color, s=size, alpha=0.8, edgecolors='black')
            plt.text(x, y, node, ha='center', va='center', fontsize=8, fontweight='bold')
        
        plt.title("分层知识图谱可视化")
        plt.axis('off')
        plt.show()

# 使用示例
hierarchical_viz = HierarchicalNetworkVisualizer()

# 添加分层节点
hierarchical_viz.add_hierarchical_node("AI", 0, "root")
hierarchical_viz.add_hierarchical_node("机器学习", 1, "branch")
hierarchical_viz.add_hierarchical_node("深度学习", 1, "branch")
hierarchical_viz.add_hierarchical_node("监督学习", 2, "leaf")
hierarchical_viz.add_hierarchical_node("无监督学习", 2, "leaf")
hierarchical_viz.add_hierarchical_node("CNN", 2, "leaf")
hierarchical_viz.add_hierarchical_node("RNN", 2, "leaf")

# 添加分层边
hierarchical_viz.add_hierarchical_edge("AI", "机器学习")
hierarchical_viz.add_hierarchical_edge("AI", "深度学习")
hierarchical_viz.add_hierarchical_edge("机器学习", "监督学习")
hierarchical_viz.add_hierarchical_edge("机器学习", "无监督学习")
hierarchical_viz.add_hierarchical_edge("深度学习", "CNN")
hierarchical_viz.add_hierarchical_edge("深度学习", "RNN")

# 可视化
hierarchical_viz.visualize_hierarchical()
```

## 2. 统计图表可视化

### 2.1 知识图谱统计图表

```python
import pandas as pd
import seaborn as sns
from collections import Counter

class KnowledgeGraphAnalytics:
    def __init__(self, graph: nx.Graph):
        self.graph = graph
        self.analytics_data = {}
    
    def calculate_basic_statistics(self):
        """计算基础统计信息"""
        self.analytics_data['basic_stats'] = {
            'total_nodes': self.graph.number_of_nodes(),
            'total_edges': self.graph.number_of_edges(),
            'density': nx.density(self.graph),
            'average_degree': sum(dict(self.graph.degree()).values()) / self.graph.number_of_nodes(),
            'connected_components': nx.number_connected_components(self.graph)
        }
        return self.analytics_data['basic_stats']
    
    def calculate_centrality_metrics(self):
        """计算中心性指标"""
        self.analytics_data['centrality'] = {
            'degree_centrality': nx.degree_centrality(self.graph),
            'betweenness_centrality': nx.betweenness_centrality(self.graph),
            'closeness_centrality': nx.closeness_centrality(self.graph),
            'eigenvector_centrality': nx.eigenvector_centrality(self.graph, max_iter=1000)
        }
        return self.analytics_data['centrality']
    
    def analyze_node_types(self):
        """分析节点类型分布"""
        node_types = [self.graph.nodes[node].get('type', 'unknown') 
                     for node in self.graph.nodes()]
        type_counts = Counter(node_types)
        
        self.analytics_data['node_types'] = dict(type_counts)
        return self.analytics_data['node_types']
    
    def analyze_edge_types(self):
        """分析边类型分布"""
        edge_types = [self.graph.edges[edge].get('relation', 'unknown') 
                     for edge in self.graph.edges()]
        type_counts = Counter(edge_types)
        
        self.analytics_data['edge_types'] = dict(type_counts)
        return self.analytics_data['edge_types']
    
    def visualize_statistics(self):
        """可视化统计信息"""
        fig, axes = plt.subplots(2, 2, figsize=(15, 12))
        
        # 1. 节点类型分布
        node_types = self.analyze_node_types()
        axes[0, 0].pie(node_types.values(), labels=node_types.keys(), autopct='%1.1f%%')
        axes[0, 0].set_title('节点类型分布')
        
        # 2. 边类型分布
        edge_types = self.analyze_edge_types()
        axes[0, 1].bar(edge_types.keys(), edge_types.values())
        axes[0, 1].set_title('边类型分布')
        axes[0, 1].tick_params(axis='x', rotation=45)
        
        # 3. 度分布
        degrees = [d for n, d in self.graph.degree()]
        axes[1, 0].hist(degrees, bins=20, alpha=0.7)
        axes[1, 0].set_title('节点度分布')
        axes[1, 0].set_xlabel('度')
        axes[1, 0].set_ylabel('频次')
        
        # 4. 中心性分布
        centrality = self.calculate_centrality_metrics()
        degree_centrality = list(centrality['degree_centrality'].values())
        axes[1, 1].hist(degree_centrality, bins=20, alpha=0.7)
        axes[1, 1].set_title('度中心性分布')
        axes[1, 1].set_xlabel('度中心性')
        axes[1, 1].set_ylabel('频次')
        
        plt.tight_layout()
        plt.show()
    
    def create_summary_dashboard(self):
        """创建汇总仪表板"""
        basic_stats = self.calculate_basic_statistics()
        
        # 创建汇总表格
        summary_data = {
            '指标': ['总节点数', '总边数', '网络密度', '平均度', '连通分量数'],
            '数值': [
                basic_stats['total_nodes'],
                basic_stats['total_edges'],
                f"{basic_stats['density']:.4f}",
                f"{basic_stats['average_degree']:.2f}",
                basic_stats['connected_components']
            ]
        }
        
        df = pd.DataFrame(summary_data)
        
        # 创建可视化
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))
        
        # 左侧：汇总表格
        ax1.axis('tight')
        ax1.axis('off')
        table = ax1.table(cellText=df.values, colLabels=df.columns, 
                         cellLoc='center', loc='center')
        table.auto_set_font_size(False)
        table.set_fontsize(12)
        table.scale(1.2, 1.5)
        ax1.set_title('知识图谱统计摘要', fontsize=16, fontweight='bold')
        
        # 右侧：网络结构图
        pos = nx.spring_layout(self.graph)
        nx.draw(self.graph, pos, ax=ax2, 
                node_color='lightblue', 
                node_size=300,
                with_labels=True,
                font_size=8)
        ax2.set_title('网络结构图', fontsize=16, fontweight='bold')
        
        plt.tight_layout()
        plt.show()

# 使用示例
# 创建示例图
example_graph = nx.Graph()
example_graph.add_nodes_from(['A', 'B', 'C', 'D', 'E', 'F'])
example_graph.add_edges_from([('A', 'B'), ('A', 'C'), ('B', 'D'), 
                             ('C', 'E'), ('D', 'F'), ('E', 'F')])

# 添加节点属性
for node in example_graph.nodes():
    example_graph.nodes[node]['type'] = np.random.choice(['person', 'concept', 'organization'])

# 添加边属性
for edge in example_graph.edges():
    example_graph.edges[edge]['relation'] = np.random.choice(['friend', 'work', 'study'])

# 创建分析器
analytics = KnowledgeGraphAnalytics(example_graph)

# 可视化统计信息
analytics.visualize_statistics()
analytics.create_summary_dashboard()
```

### 2.2 时间序列可视化

```python
class TemporalKnowledgeGraphVisualizer:
    def __init__(self):
        self.temporal_data = []
        self.graph_evolution = {}
    
    def add_temporal_event(self, timestamp: str, event_type: str, 
                          source: str, target: str, weight: float = 1.0):
        """添加时间事件"""
        self.temporal_data.append({
            'timestamp': timestamp,
            'event_type': event_type,
            'source': source,
            'target': target,
            'weight': weight
        })
    
    def build_temporal_graph(self, time_window: str = 'D'):
        """构建时间序列图"""
        df = pd.DataFrame(self.temporal_data)
        df['timestamp'] = pd.to_datetime(df['timestamp'])
        df = df.set_index('timestamp')
        
        # 按时间窗口分组
        grouped = df.groupby(pd.Grouper(freq=time_window))
        
        for time_period, group in grouped:
            if not group.empty:
                period_str = time_period.strftime('%Y-%m-%d')
                self.graph_evolution[period_str] = {
                    'events': len(group),
                    'unique_sources': group['source'].nunique(),
                    'unique_targets': group['target'].nunique(),
                    'total_weight': group['weight'].sum()
                }
    
    def visualize_temporal_evolution(self):
        """可视化时间演化"""
        if not self.graph_evolution:
            self.build_temporal_graph()
        
        df_evolution = pd.DataFrame.from_dict(self.graph_evolution, orient='index')
        df_evolution.index = pd.to_datetime(df_evolution.index)
        
        fig, axes = plt.subplots(2, 2, figsize=(15, 10))
        
        # 1. 事件数量时间序列
        df_evolution['events'].plot(ax=axes[0, 0], marker='o')
        axes[0, 0].set_title('事件数量时间序列')
        axes[0, 0].set_ylabel('事件数量')
        
        # 2. 节点数量时间序列
        df_evolution[['unique_sources', 'unique_targets']].plot(ax=axes[0, 1], marker='o')
        axes[0, 1].set_title('节点数量时间序列')
        axes[0, 1].set_ylabel('节点数量')
        axes[0, 1].legend(['源节点', '目标节点'])
        
        # 3. 权重总和时间序列
        df_evolution['total_weight'].plot(ax=axes[1, 0], marker='o', color='green')
        axes[1, 0].set_title('权重总和时间序列')
        axes[1, 0].set_ylabel('权重总和')
        
        # 4. 事件类型分布
        df_temporal = pd.DataFrame(self.temporal_data)
        event_counts = df_temporal['event_type'].value_counts()
        axes[1, 1].pie(event_counts.values, labels=event_counts.index, autopct='%1.1f%%')
        axes[1, 1].set_title('事件类型分布')
        
        plt.tight_layout()
        plt.show()

# 使用示例
temporal_viz = TemporalKnowledgeGraphVisualizer()

# 添加时间事件
temporal_viz.add_temporal_event('2023-01-01', 'friend', '张三', '李四', 0.8)
temporal_viz.add_temporal_event('2023-01-02', 'work', '张三', '王五', 0.9)
temporal_viz.add_temporal_event('2023-01-03', 'study', '李四', '机器学习', 0.7)
temporal_viz.add_temporal_event('2023-01-04', 'friend', '王五', '李四', 0.6)
temporal_viz.add_temporal_event('2023-01-05', 'work', '张三', '公司A', 0.9)

# 可视化时间演化
temporal_viz.visualize_temporal_evolution()
```

## 3. 交互式可视化

### 3.1 动态交互式网络图

```python
class InteractiveNetworkVisualizer:
    def __init__(self):
        self.graph = nx.Graph()
        self.node_data = {}
        self.edge_data = {}
    
    def add_interactive_node(self, node_id: str, node_type: str, 
                           attributes: Dict = None):
        """添加交互式节点"""
        self.graph.add_node(node_id, type=node_type, **(attributes or {}))
        self.node_data[node_id] = {
            'id': node_id,
            'type': node_type,
            'attributes': attributes or {}
        }
    
    def add_interactive_edge(self, node1: str, node2: str, 
                           relation_type: str, weight: float = 1.0):
        """添加交互式边"""
        self.graph.add_edge(node1, node2, relation=relation_type, weight=weight)
        self.edge_data[(node1, node2)] = {
            'source': node1,
            'target': node2,
            'relation': relation_type,
            'weight': weight
        }
    
    def create_interactive_visualization(self):
        """创建交互式可视化"""
        # 计算布局
        pos = nx.spring_layout(self.graph)
        
        # 准备节点数据
        node_trace = go.Scatter(
            x=[],
            y=[],
            text=[],
            mode='markers',
            hoverinfo='text',
            marker=dict(
                showscale=True,
                colorscale='YlGnBu',
                reversescale=True,
                color=[],
                size=[],
                colorbar=dict(
                    thickness=15,
                    title='节点连接数',
                    xanchor='left',
                    titleside='right'
                ),
                line_width=2))
        
        # 准备边数据
        edge_trace = go.Scatter(
            x=[],
            y=[],
            line=dict(width=0.5, color='#888'),
            hoverinfo='none',
            mode='lines')
        
        # 填充节点数据
        for node in self.graph.nodes():
            x, y = pos[node]
            node_trace['x'] += tuple([x])
            node_trace['y'] += tuple([y])
            
            # 节点信息
            node_info = f"节点: {node}<br>类型: {self.graph.nodes[node]['type']}"
            if 'attributes' in self.graph.nodes[node]:
                for key, value in self.graph.nodes[node]['attributes'].items():
                    node_info += f"<br>{key}: {value}"
            node_trace['text'] += tuple([node_info])
            
            # 节点颜色和大小
            node_adjacencies = list(self.graph.neighbors(node))
            node_trace['marker']['color'] += tuple([len(node_adjacencies)])
            node_trace['marker']['size'] += tuple([len(node_adjacencies) * 10 + 10])
        
        # 填充边数据
        for edge in self.graph.edges():
            x0, y0 = pos[edge[0]]
            x1, y1 = pos[edge[1]]
            edge_trace['x'] += tuple([x0, x1, None])
            edge_trace['y'] += tuple([y0, y1, None])
        
        # 创建图形
        fig = go.Figure(data=[edge_trace, node_trace],
                       layout=go.Layout(
                           title='交互式知识图谱可视化',
                           titlefont_size=16,
                           showlegend=False,
                           hovermode='closest',
                           margin=dict(b=20,l=5,r=5,t=40),
                           annotations=[dict(
                               text="点击节点查看详细信息",
                               showarrow=False,
                               xref="paper", yref="paper",
                               x=0.005, y=-0.002,
                               xanchor='left', yanchor='bottom',
                               font=dict(size=14)
                           )],
                           xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
                           yaxis=dict(showgrid=False, zeroline=False, showticklabels=False))
                       )
        
        fig.show()
    
    def create_filterable_visualization(self):
        """创建可过滤的可视化"""
        # 获取所有节点类型
        node_types = set(self.graph.nodes[node]['type'] for node in self.graph.nodes())
        
        # 创建过滤按钮
        buttons = []
        for node_type in node_types:
            buttons.append(
                dict(
                    label=node_type,
                    method="update",
                    args=[{"visible": [True if self.graph.nodes[node]['type'] == node_type 
                                      else False for node in self.graph.nodes()]}]
                )
            )
        
        # 添加"显示全部"按钮
        buttons.append(
            dict(
                label="显示全部",
                method="update",
                args=[{"visible": [True] * len(self.graph.nodes())}]
            )
        )
        
        # 计算布局
        pos = nx.spring_layout(self.graph)
        
        # 创建节点轨迹
        node_traces = []
        for node_type in node_types:
            node_trace = go.Scatter(
                x=[],
                y=[],
                text=[],
                mode='markers',
                name=node_type,
                hoverinfo='text',
                marker=dict(size=10),
                visible=True
            )
            
            for node in self.graph.nodes():
                if self.graph.nodes[node]['type'] == node_type:
                    x, y = pos[node]
                    node_trace['x'] += tuple([x])
                    node_trace['y'] += tuple([y])
                    node_trace['text'] += tuple([f"{node} ({node_type})"])
            
            node_traces.append(node_trace)
        
        # 创建边轨迹
        edge_trace = go.Scatter(
            x=[],
            y=[],
            line=dict(width=0.5, color='#888'),
            hoverinfo='none',
            mode='lines')
        
        for edge in self.graph.edges():
            x0, y0 = pos[edge[0]]
            x1, y1 = pos[edge[1]]
            edge_trace['x'] += tuple([x0, x1, None])
            edge_trace['y'] += tuple([y0, y1, None])
        
        # 创建图形
        fig = go.Figure(data=[edge_trace] + node_traces,
                       layout=go.Layout(
                           title='可过滤的知识图谱可视化',
                           titlefont_size=16,
                           showlegend=True,
                           hovermode='closest',
                           margin=dict(b=20,l=5,r=5,t=40),
                           updatemenus=[dict(
                               buttons=buttons,
                               direction="down",
                               showactive=True,
                               x=0.1,
                               xanchor="left",
                               y=1.1,
                               yanchor="top"
                           )],
                           xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
                           yaxis=dict(showgrid=False, zeroline=False, showticklabels=False))
                       )
        
        fig.show()

# 使用示例
interactive_viz = InteractiveNetworkVisualizer()

# 添加节点
interactive_viz.add_interactive_node("张三", "person", {"age": 30, "department": "技术部"})
interactive_viz.add_interactive_node("李四", "person", {"age": 28, "department": "数据部"})
interactive_viz.add_interactive_node("王五", "person", {"age": 35, "department": "技术部"})
interactive_viz.add_interactive_node("公司A", "organization", {"industry": "科技"})
interactive_viz.add_interactive_node("机器学习", "concept", {"category": "AI"})

# 添加边
interactive_viz.add_interactive_edge("张三", "李四", "friend", 0.8)
interactive_viz.add_interactive_edge("张三", "王五", "work", 0.9)
interactive_viz.add_interactive_edge("李四", "机器学习", "study", 0.7)
interactive_viz.add_interactive_edge("张三", "公司A", "work", 0.9)

# 创建交互式可视化
interactive_viz.create_interactive_visualization()
interactive_viz.create_filterable_visualization()
```

## 4. 总结

本文档提供了知识图谱可视化技术的实践案例，涵盖：

1. **网络图可视化**：基础网络图、分层网络图
2. **统计图表可视化**：基础统计、时间序列分析
3. **交互式可视化**：动态交互、可过滤可视化

每个案例都包含：

- 数据准备和预处理
- 可视化算法实现
- 交互功能设计
- 实际应用场景

这些实践案例展示了知识图谱可视化的多种技术和方法，为构建直观、交互式的知识图谱展示系统提供了参考。
