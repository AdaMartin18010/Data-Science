# å‡½æ•°å¼ç¼–ç¨‹èŒƒå¼æ·±åŒ–

## ğŸ“‘ ç›®å½•

- [å‡½æ•°å¼ç¼–ç¨‹èŒƒå¼æ·±åŒ–](#å‡½æ•°å¼ç¼–ç¨‹èŒƒå¼æ·±åŒ–)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
- [ç†è®ºåŸºç¡€](#ç†è®ºåŸºç¡€)
  - [æ•°å­¦åŸºç¡€](#æ•°å­¦åŸºç¡€)
  - [æ ¸å¿ƒåŸåˆ™](#æ ¸å¿ƒåŸåˆ™)
- [æ ¸å¿ƒæ¦‚å¿µæ·±åŒ–](#æ ¸å¿ƒæ¦‚å¿µæ·±åŒ–)
  - [å‡½æ•°ç»„åˆ](#å‡½æ•°ç»„åˆ)
  - [å•å­ï¼ˆMonadï¼‰](#å•å­monad)
  - [å‡½å­ï¼ˆFunctorï¼‰](#å‡½å­functor)
- [é«˜çº§ç‰¹æ€§](#é«˜çº§ç‰¹æ€§)
  - [ç±»å‹ç±»ï¼ˆType Classesï¼‰](#ç±»å‹ç±»type-classes)
  - [æƒ°æ€§æ±‚å€¼](#æƒ°æ€§æ±‚å€¼)
  - [æ¨¡å¼åŒ¹é…](#æ¨¡å¼åŒ¹é…)
- [å®è·µåº”ç”¨](#å®è·µåº”ç”¨)
  - [æ•°æ®å¤„ç†ç®¡é“](#æ•°æ®å¤„ç†ç®¡é“)
  - [é”™è¯¯å¤„ç†](#é”™è¯¯å¤„ç†)
  - [å¹¶å‘ç¼–ç¨‹](#å¹¶å‘ç¼–ç¨‹)
- [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
  - [å°¾é€’å½’ä¼˜åŒ–](#å°¾é€’å½’ä¼˜åŒ–)
  - [è®°å¿†åŒ–](#è®°å¿†åŒ–)
- [å·¥å…·å’Œæ¡†æ¶](#å·¥å…·å’Œæ¡†æ¶)
  - [å¼€å‘å·¥å…·](#å¼€å‘å·¥å…·)
  - [æµ‹è¯•æ¡†æ¶](#æµ‹è¯•æ¡†æ¶)
- [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
  - [ä»£ç ç»„ç»‡](#ä»£ç ç»„ç»‡)
  - [æ€§èƒ½è€ƒè™‘](#æ€§èƒ½è€ƒè™‘)
  - [è®¾è®¡æ¨¡å¼](#è®¾è®¡æ¨¡å¼)
- [å­¦ä¹ èµ„æº](#å­¦ä¹ èµ„æº)
  - [ç»å…¸æ•™æ](#ç»å…¸æ•™æ)
  - [åœ¨çº¿èµ„æº](#åœ¨çº¿èµ„æº)
  - [å®è·µé¡¹ç›®](#å®è·µé¡¹ç›®)
---


## ç†è®ºåŸºç¡€

### æ•°å­¦åŸºç¡€

1. **Î»æ¼”ç®—**ï¼šå‡½æ•°å¼ç¼–ç¨‹çš„æ•°å­¦åŸºç¡€
2. **èŒƒç•´è®º**ï¼šæŠ½è±¡æ•°å­¦ç»“æ„
3. **ç±»å‹è®º**ï¼šå½¢å¼åŒ–ç±»å‹ç³»ç»Ÿ
4. **ä»£æ•°æ•°æ®ç±»å‹**ï¼šæ•°æ®ç»“æ„çš„æ•°å­¦è¡¨ç¤º

### æ ¸å¿ƒåŸåˆ™

1. **ä¸å¯å˜æ€§**ï¼šæ•°æ®ä¸€æ—¦åˆ›å»ºä¸å¯ä¿®æ”¹
2. **çº¯å‡½æ•°**ï¼šæ— å‰¯ä½œç”¨ï¼Œç›¸åŒè¾“å…¥æ€»æ˜¯äº§ç”Ÿç›¸åŒè¾“å‡º
3. **é«˜é˜¶å‡½æ•°**ï¼šå‡½æ•°å¯ä»¥ä½œä¸ºå‚æ•°å’Œè¿”å›å€¼
4. **æƒ°æ€§æ±‚å€¼**ï¼šåªåœ¨éœ€è¦æ—¶è®¡ç®—

## æ ¸å¿ƒæ¦‚å¿µæ·±åŒ–

### å‡½æ•°ç»„åˆ

```haskell
-- Haskellç¤ºä¾‹
compose :: (b -> c) -> (a -> b) -> a -> c
compose f g = \x -> f (g x)

-- ç®¡é“æ“ä½œ
(|>) :: a -> (a -> b) -> b
x |> f = f x
```

```scala
// Scalaç¤ºä¾‹
def compose[A, B, C](f: B => C, g: A => B): A => C =
  a => f(g(a))

// éšå¼ç±»æ‰©å±•
implicit class PipeOps[A](val a: A) extends AnyVal {
  def |>[B](f: A => B): B = f(a)
}
```

### å•å­ï¼ˆMonadï¼‰

```haskell
-- Haskell Maybeå•å­
data Maybe a = Nothing | Just a

instance Monad Maybe where
  return = Just
  Nothing >>= _ = Nothing
  Just x >>= f = f x

-- ä½¿ç”¨ç¤ºä¾‹
safeDivide :: Double -> Double -> Maybe Double
safeDivide _ 0 = Nothing
safeDivide x y = Just (x / y)
```

```scala
// Scala Optionå•å­
sealed trait Option[+A]
case class Some[+A](value: A) extends Option[A]
case object None extends Option[Nothing]

implicit class OptionOps[A](opt: Option[A]) {
  def flatMap[B](f: A => Option[B]): Option[B] = opt match {
    case Some(a) => f(a)
    case None => None
  }
}
```

### å‡½å­ï¼ˆFunctorï¼‰

```haskell
-- Haskellå‡½å­
class Functor f where
  fmap :: (a -> b) -> f a -> f b

instance Functor [] where
  fmap = map

instance Functor Maybe where
  fmap _ Nothing = Nothing
  fmap f (Just x) = Just (f x)
```

```scala
// Scalaå‡½å­
trait Functor[F[_]] {
  def map[A, B](fa: F[A])(f: A => B): F[B]
}

implicit object ListFunctor extends Functor[List] {
  def map[A, B](fa: List[A])(f: A => B): List[B] = fa.map(f)
}
```

## é«˜çº§ç‰¹æ€§

### ç±»å‹ç±»ï¼ˆType Classesï¼‰

```haskell
-- Haskellç±»å‹ç±»
class Eq a where
  (==) :: a -> a -> Bool
  (/=) :: a -> a -> Bool
  x /= y = not (x == y)

instance Eq Int where
  (==) = (Prelude.==)

instance (Eq a, Eq b) => Eq (a, b) where
  (a1, b1) == (a2, b2) = a1 == a2 && b1 == b2
```

```scala
// Scalaç±»å‹ç±»
trait Eq[A] {
  def eqv(x: A, y: A): Boolean
}

object Eq {
  def apply[A](implicit ev: Eq[A]): Eq[A] = ev

  implicit val intEq: Eq[Int] = new Eq[Int] {
    def eqv(x: Int, y: Int): Boolean = x == y
  }
}
```

### æƒ°æ€§æ±‚å€¼

```haskell
-- Haskellæƒ°æ€§åˆ—è¡¨
fibonacci :: [Integer]
fibonacci = 0 : 1 : zipWith (+) fibonacci (tail fibonacci)

-- æ— é™æµ
take 10 fibonacci -- [0,1,1,2,3,5,8,13,21,34]
```

```scala
// Scalaæƒ°æ€§æµ
def fibonacci: LazyList[BigInt] = {
  def loop(a: BigInt, b: BigInt): LazyList[BigInt] =
    a #:: loop(b, a + b)
  loop(0, 1)
}

fibonacci.take(10).toList
```

### æ¨¡å¼åŒ¹é…

```haskell
-- Haskellæ¨¡å¼åŒ¹é…
data Tree a = Empty | Node a (Tree a) (Tree a)

treeDepth :: Tree a -> Int
treeDepth Empty = 0
treeDepth (Node _ left right) = 1 + max (treeDepth left) (treeDepth right)

-- åˆ—è¡¨æ¨¡å¼åŒ¹é…
sumList :: [Int] -> Int
sumList [] = 0
sumList (x:xs) = x + sumList xs
```

```scala
// Scalaæ¨¡å¼åŒ¹é…
sealed trait Tree[+A]
case object Empty extends Tree[Nothing]
case class Node[A](value: A, left: Tree[A], right: Tree[A]) extends Tree[A]

def treeDepth[A](tree: Tree[A]): Int = tree match {
  case Empty => 0
  case Node(_, left, right) => 1 + math.max(treeDepth(left), treeDepth(right))
}
```

## å®è·µåº”ç”¨

### æ•°æ®å¤„ç†ç®¡é“

```haskell
-- Haskellæ•°æ®å¤„ç†
processData :: [String] -> [Int]
processData =
  filter (not . null) .           -- è¿‡æ»¤ç©ºå­—ç¬¦ä¸²
  map read .                       -- è½¬æ¢ä¸ºæ•°å­—
  filter (> 0) .                  -- è¿‡æ»¤æ­£æ•°
  map (* 2) .                     -- ä¹˜ä»¥2
  filter even                      -- è¿‡æ»¤å¶æ•°
```

```scala
// Scalaæ•°æ®å¤„ç†
def processData(data: List[String]): List[Int] =
  data
    .filter(_.nonEmpty)           // è¿‡æ»¤ç©ºå­—ç¬¦ä¸²
    .map(_.toInt)                 // è½¬æ¢ä¸ºæ•°å­—
    .filter(_ > 0)                // è¿‡æ»¤æ­£æ•°
    .map(_ * 2)                   // ä¹˜ä»¥2
    .filter(_ % 2 == 0)           // è¿‡æ»¤å¶æ•°
```

### é”™è¯¯å¤„ç†

```haskell
-- Haskell Eitherç±»å‹
safeDivide :: Double -> Double -> Either String Double
safeDivide _ 0 = Left "Division by zero"
safeDivide x y = Right (x / y)

-- é“¾å¼å¤„ç†
processCalculation :: Double -> Double -> Either String Double
processCalculation x y = do
  result1 <- safeDivide x y
  result2 <- safeDivide result1 2
  return (result2 * 3)
```

```scala
// Scala Eitherç±»å‹
def safeDivide(x: Double, y: Double): Either[String, Double] =
  if (y == 0) Left("Division by zero") else Right(x / y)

def processCalculation(x: Double, y: Double): Either[String, Double] =
  for {
    result1 <- safeDivide(x, y)
    result2 <- safeDivide(result1, 2)
  } yield result2 * 3
```

### å¹¶å‘ç¼–ç¨‹

```haskell
-- Haskell STM
import Control.Concurrent.STM

transfer :: TVar Int -> TVar Int -> Int -> STM ()
transfer from to amount = do
  fromBalance <- readTVar from
  toBalance <- readTVar to
  writeTVar from (fromBalance - amount)
  writeTVar to (toBalance + amount)
```

```scala
// Scala Future
import scala.concurrent.Future
import scala.concurrent.ExecutionContext.Implicits.global

def transfer(from: Account, to: Account, amount: Double): Future[Unit] =
  for {
    _ <- from.withdraw(amount)
    _ <- to.deposit(amount)
  } yield ()
```

## æ€§èƒ½ä¼˜åŒ–

### å°¾é€’å½’ä¼˜åŒ–

```haskell
-- Haskellå°¾é€’å½’
factorial :: Integer -> Integer
factorial n = go n 1
  where
    go 0 acc = acc
    go n acc = go (n - 1) (n * acc)
```

```scala
// Scalaå°¾é€’å½’
@tailrec
def factorial(n: BigInt, acc: BigInt = 1): BigInt =
  if (n <= 1) acc else factorial(n - 1, n * acc)
```

### è®°å¿†åŒ–

```haskell
-- Haskellè®°å¿†åŒ–
import Data.MemoTrie

fibonacci :: Integer -> Integer
fibonacci = memo go
  where
    go 0 = 0
    go 1 = 1
    go n = fibonacci (n - 1) + fibonacci (n - 2)
```

```scala
// Scalaè®°å¿†åŒ–
import scala.collection.mutable

def fibonacci(n: Int): BigInt = {
  val cache = mutable.Map[Int, BigInt]()

  def go(n: Int): BigInt = cache.getOrElseUpdate(n, {
    if (n <= 1) n else go(n - 1) + go(n - 2)
  })

  go(n)
}
```

## å·¥å…·å’Œæ¡†æ¶

### å¼€å‘å·¥å…·

1. **GHC**ï¼šHaskellç¼–è¯‘å™¨
2. **Stack**ï¼šHaskellæ„å»ºå·¥å…·
3. **Cabal**ï¼šåŒ…ç®¡ç†å™¨
4. **Hoogle**ï¼šå‡½æ•°æœç´¢å·¥å…·

### æµ‹è¯•æ¡†æ¶

```haskell
-- Haskell QuickCheck
import Test.QuickCheck

prop_reverse :: [Int] -> Bool
prop_reverse xs = reverse (reverse xs) == xs

-- è¿è¡Œæµ‹è¯•
main = quickCheck prop_reverse
```

```scala
// Scala ScalaCheck
import org.scalacheck.Prop.forAll

val reverseProp = forAll { (xs: List[Int]) =>
  xs.reverse.reverse == xs
}

reverseProp.check()
```

## æœ€ä½³å®è·µ

### ä»£ç ç»„ç»‡

1. **æ¨¡å—åŒ–è®¾è®¡**ï¼šæŒ‰åŠŸèƒ½åˆ†ç¦»æ¨¡å—
2. **ç±»å‹å®‰å…¨**ï¼šå……åˆ†åˆ©ç”¨ç±»å‹ç³»ç»Ÿ
3. **æ–‡æ¡£åŒ–**ï¼šä½¿ç”¨Haddockæˆ–Scaladoc
4. **æµ‹è¯•é©±åŠ¨**ï¼šç¼–å†™å±æ€§æµ‹è¯•

### æ€§èƒ½è€ƒè™‘

1. **æƒ°æ€§æ±‚å€¼**ï¼šé¿å…ä¸å¿…è¦çš„è®¡ç®—
2. **ä¸¥æ ¼æ€§åˆ†æ**ï¼šç†è§£æ±‚å€¼ç­–ç•¥
3. **å†…å­˜ç®¡ç†**ï¼šæ³¨æ„å†…å­˜æ³„æ¼
4. **å¹¶å‘å®‰å…¨**ï¼šä½¿ç”¨ä¸å¯å˜æ•°æ®ç»“æ„

### è®¾è®¡æ¨¡å¼

1. **å‡½æ•°ç»„åˆ**ï¼šæ„å»ºå¤æ‚åŠŸèƒ½
2. **å•å­å˜æ¢å™¨**ï¼šç»„åˆå¤šä¸ªå•å­
3. **è‡ªç”±å•å­**ï¼šæ„å»ºDSL
4. **é€é•œï¼ˆLensï¼‰**ï¼šå¤„ç†åµŒå¥—æ•°æ®ç»“æ„

## å­¦ä¹ èµ„æº

### ç»å…¸æ•™æ

1. **ã€ŠLearn You a Haskellã€‹**ï¼šHaskellå…¥é—¨
2. **ã€ŠReal World Haskellã€‹**ï¼šå®è·µæŒ‡å—
3. **ã€ŠFunctional Programming in Scalaã€‹**ï¼šScalaå‡½æ•°å¼ç¼–ç¨‹
4. **ã€ŠCategory Theory in Contextã€‹**ï¼šèŒƒç•´è®º

### åœ¨çº¿èµ„æº

1. **Haskell Wiki**ï¼šå®˜æ–¹æ–‡æ¡£
2. **Scala Documentation**ï¼šå®˜æ–¹æ–‡æ¡£
3. **FP Complete**ï¼šHaskellåŸ¹è®­
4. **Typelevel**ï¼šScalaå‡½æ•°å¼ç¼–ç¨‹ç¤¾åŒº

### å®è·µé¡¹ç›®

1. **ç¼–è¯‘å™¨å®ç°**ï¼šç†è§£è¯­è¨€è®¾è®¡
2. **Webæ¡†æ¶**ï¼šå®è·µåº”ç”¨å¼€å‘
3. **æ•°æ®åˆ†æ**ï¼šåˆ©ç”¨å‡½æ•°å¼ç‰¹æ€§
4. **å¹¶å‘ç³»ç»Ÿ**ï¼šæ¢ç´¢å¹¶å‘æ¨¡å‹
