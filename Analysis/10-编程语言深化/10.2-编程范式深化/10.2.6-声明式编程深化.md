# 10.2.6-声明式编程深化

## 概述

声明式编程是一种描述"做什么"而不是"怎么做"的编程范式，通过声明意图和规则来实现程序逻辑。

## 声明式编程基础

### 核心概念

```python
# 声明式编程的核心思想
程序 = 声明意图 + 规则约束 + 自动推理
```

### 基本特征

```python
# 命令式 vs 声明式
# 命令式：描述如何做
def imperative_sum(numbers):
    total = 0
    for num in numbers:
        total += num
    return total

# 声明式：描述做什么
def declarative_sum(numbers):
    return sum(numbers)  # 直接声明求和意图
```

## 函数式声明式编程

### 高阶函数

```python
from functools import reduce

# 声明式数据处理
def declarative_data_processing():
    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    
    # 声明式管道处理
    result = reduce(
        lambda acc, x: acc + x,
        filter(lambda x: x % 2 == 0,  # 过滤偶数
        map(lambda x: x * 2, numbers))  # 映射转换
    )
    
    print(f"结果: {result}")

declarative_data_processing()
```

### 函数组合

```python
from functools import reduce

def compose(*functions):
    """函数组合器"""
    def inner(arg):
        return reduce(lambda acc, f: f(acc), reversed(functions), arg)
    return inner

def add_one(x): return x + 1
def multiply_by_two(x): return x * 2
def square(x): return x ** 2

# 声明式函数组合
pipeline = compose(square, multiply_by_two, add_one)
result = pipeline(3)  # ((3 + 1) * 2) ^ 2 = 64
print(f"函数组合结果: {result}")
```

## 逻辑编程

### Prolog风格逻辑

```python
# 简单的逻辑编程实现
class LogicEngine:
    def __init__(self):
        self.facts = set()
        self.rules = []
    
    def add_fact(self, fact):
        self.facts.add(fact)
    
    def add_rule(self, head, body):
        self.rules.append((head, body))
    
    def query(self, goal):
        if goal in self.facts:
            return True
        
        for head, body in self.rules:
            if head == goal:
                if all(self.query(subgoal) for subgoal in body):
                    return True
        
        return False

# 使用示例
def logic_programming_example():
    engine = LogicEngine()
    
    # 添加事实
    engine.add_fact("parent(john, mary)")
    engine.add_fact("parent(mary, bob)")
    
    # 添加规则
    engine.add_rule("grandparent(X, Z)", ["parent(X, Y)", "parent(Y, Z)"])
    
    # 查询
    result = engine.query("grandparent(john, bob)")
    print(f"John是Bob的祖父: {result}")

logic_programming_example()
```

### 约束编程

```python
from constraint import Problem, AllDifferentConstraint

def constraint_programming_example():
    # 创建约束问题
    problem = Problem()
    
    # 变量：8皇后问题
    queens = range(8)
    problem.addVariables(queens, range(8))
    
    # 约束：所有皇后在不同行
    problem.addConstraint(AllDifferentConstraint())
    
    # 约束：对角线约束
    for i in queens:
        for j in queens:
            if i < j:
                problem.addConstraint(
                    lambda q1, q2, row1=i, row2=j: 
                    abs(q1 - q2) != abs(row1 - row2),
                    (i, j)
                )
    
    # 求解
    solutions = problem.getSolutions()
    print(f"8皇后问题解的数量: {len(solutions)}")
    
    # 显示第一个解
    if solutions:
        solution = solutions[0]
        for row, col in solution.items():
            print(f"皇后{row}在位置({row}, {col})")

constraint_programming_example()
```

## 规则引擎

### 简单规则引擎

```python
class RuleEngine:
    def __init__(self):
        self.rules = []
        self.facts = {}
    
    def add_rule(self, condition, action):
        self.rules.append((condition, action))
    
    def add_fact(self, key, value):
        self.facts[key] = value
    
    def execute(self):
        changed = True
        while changed:
            changed = False
            for condition, action in self.rules:
                if condition(self.facts):
                    if action(self.facts):
                        changed = True

# 使用示例
def rule_engine_example():
    engine = RuleEngine()
    
    # 添加事实
    engine.add_fact("temperature", 25)
    engine.add_fact("humidity", 60)
    engine.add_fact("air_conditioning", False)
    
    # 添加规则
    def hot_condition(facts):
        return facts.get("temperature", 0) > 30
    
    def hot_action(facts):
        if not facts.get("air_conditioning", False):
            facts["air_conditioning"] = True
            print("温度过高，开启空调")
            return True
        return False
    
    def humid_condition(facts):
        return facts.get("humidity", 0) > 70
    
    def humid_action(facts):
        if not facts.get("dehumidifier", False):
            facts["dehumidifier"] = True
            print("湿度过高，开启除湿器")
            return True
        return False
    
    engine.add_rule(hot_condition, hot_action)
    engine.add_rule(humid_condition, humid_action)
    
    # 执行规则
    engine.execute()

rule_engine_example()
```

## 声明式SQL

### 声明式查询

```python
import sqlite3

def declarative_sql_example():
    # 创建数据库
    conn = sqlite3.connect(":memory:")
    cursor = conn.cursor()
    
    # 创建表
    cursor.execute("""
        CREATE TABLE employees (
            id INTEGER PRIMARY KEY,
            name TEXT,
            department TEXT,
            salary REAL
        )
    """)
    
    # 插入数据
    employees_data = [
        (1, "Alice", "Engineering", 75000),
        (2, "Bob", "Marketing", 65000),
        (3, "Charlie", "Engineering", 80000),
        (4, "Diana", "HR", 60000),
        (5, "Eve", "Engineering", 90000)
    ]
    
    cursor.executemany(
        "INSERT INTO employees VALUES (?, ?, ?, ?)",
        employees_data
    )
    
    # 声明式查询：找出工程部门平均工资超过70000的员工
    cursor.execute("""
        SELECT name, salary
        FROM employees
        WHERE department = 'Engineering'
        AND salary > (
            SELECT AVG(salary)
            FROM employees
            WHERE department = 'Engineering'
        )
        ORDER BY salary DESC
    """)
    
    results = cursor.fetchall()
    print("高薪工程员工:")
    for name, salary in results:
        print(f"{name}: ${salary:,.2f}")
    
    conn.close()

declarative_sql_example()
```

## 声明式配置

### YAML配置

```python
import yaml
from dataclasses import dataclass
from typing import List, Dict

@dataclass
class DatabaseConfig:
    host: str
    port: int
    name: str
    user: str
    password: str

@dataclass
class AppConfig:
    name: str
    version: str
    debug: bool
    database: DatabaseConfig
    features: List[str]
    settings: Dict[str, str]

def declarative_config_example():
    # 声明式配置
    config_yaml = """
    name: "MyApp"
    version: "1.0.0"
    debug: true
    database:
      host: "localhost"
      port: 5432
      name: "myapp_db"
      user: "admin"
      password: "secret"
    features:
      - "authentication"
      - "authorization"
      - "logging"
    settings:
      theme: "dark"
      language: "en"
      timezone: "UTC"
    """
    
    # 解析配置
    config_data = yaml.safe_load(config_yaml)
    
    # 转换为结构化对象
    db_config = DatabaseConfig(**config_data["database"])
    app_config = AppConfig(
        name=config_data["name"],
        version=config_data["version"],
        debug=config_data["debug"],
        database=db_config,
        features=config_data["features"],
        settings=config_data["settings"]
    )
    
    print(f"应用配置: {app_config.name} v{app_config.version}")
    print(f"数据库: {app_config.database.host}:{app_config.database.port}")
    print(f"功能: {', '.join(app_config.features)}")

declarative_config_example()
```

## 声明式UI

### 声明式界面定义

```python
from dataclasses import dataclass
from typing import List, Optional

@dataclass
class UIComponent:
    type: str
    id: str
    props: dict
    children: Optional[List['UIComponent']] = None

def declarative_ui_example():
    # 声明式UI定义
    ui_structure = UIComponent(
        type="div",
        id="app",
        props={"class": "container"},
        children=[
            UIComponent(
                type="header",
                id="header",
                props={"class": "app-header"},
                children=[
                    UIComponent(
                        type="h1",
                        id="title",
                        props={"text": "我的应用"}
                    )
                ]
            ),
            UIComponent(
                type="main",
                id="main",
                props={"class": "app-main"},
                children=[
                    UIComponent(
                        type="button",
                        id="submit",
                        props={"text": "提交", "onClick": "handleSubmit"}
                    )
                ]
            )
        ]
    )
    
    # 渲染UI（模拟）
    def render_component(component, indent=0):
        spaces = "  " * indent
        print(f"{spaces}{component.type}(id='{component.id}')")
        if component.children:
            for child in component.children:
                render_component(child, indent + 1)
    
    print("声明式UI结构:")
    render_component(ui_structure)

declarative_ui_example()
```

## 声明式测试

### 行为驱动开发

```python
from dataclasses import dataclass
from typing import Callable, List

@dataclass
class Scenario:
    given: str
    when: str
    then: str
    action: Callable

class BDDTestFramework:
    def __init__(self):
        self.scenarios = []
    
    def scenario(self, description: str):
        def decorator(action: Callable):
            self.scenarios.append(Scenario(
                given="",
                when="",
                then="",
                action=action
            ))
            return action
        return decorator
    
    def given(self, description: str):
        def decorator(func):
            # 存储given描述
            return func
        return decorator
    
    def when(self, description: str):
        def decorator(func):
            # 存储when描述
            return func
        return decorator
    
    def then(self, description: str):
        def decorator(func):
            # 存储then描述
            return func
        return decorator

# 使用示例
def declarative_testing_example():
    framework = BDDTestFramework()
    
    @framework.scenario("用户登录成功")
    def test_user_login_success():
        # Given 用户已注册
        user = {"username": "testuser", "password": "password123"}
        
        # When 用户输入正确的凭据
        result = login(user["username"], user["password"])
        
        # Then 用户应该成功登录
        assert result["success"] == True
        assert result["user"]["username"] == user["username"]
    
    def login(username, password):
        # 模拟登录逻辑
        if username == "testuser" and password == "password123":
            return {
                "success": True,
                "user": {"username": username}
            }
        return {"success": False}
    
    # 执行测试
    for scenario in framework.scenarios:
        print(f"执行场景: {scenario}")
        try:
            scenario.action()
            print("✓ 测试通过")
        except Exception as e:
            print(f"✗ 测试失败: {e}")

declarative_testing_example()
```

## 声明式数据处理

### 数据管道

```python
from typing import List, Callable, Any
from dataclasses import dataclass

@dataclass
class DataPipeline:
    steps: List[Callable]
    
    def add_step(self, step: Callable):
        self.steps.append(step)
        return self
    
    def execute(self, data: Any):
        result = data
        for step in self.steps:
            result = step(result)
        return result

def declarative_data_pipeline():
    # 声明式数据处理管道
    pipeline = DataPipeline([])
    
    # 定义处理步骤
    def filter_even(data):
        return [x for x in data if x % 2 == 0]
    
    def square_data(data):
        return [x ** 2 for x in data]
    
    def sum_data(data):
        return sum(data)
    
    # 构建管道
    pipeline.add_step(filter_even).add_step(square_data).add_step(sum_data)
    
    # 执行管道
    input_data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    result = pipeline.execute(input_data)
    
    print(f"输入: {input_data}")
    print(f"输出: {result}")
    print(f"处理步骤: 过滤偶数 -> 平方 -> 求和")

declarative_data_pipeline()
```

## 声明式API设计

### RESTful API

```python
from flask import Flask, request, jsonify
from functools import wraps

app = Flask(__name__)

def declarative_api_example():
    # 声明式API路由定义
    @app.route('/users', methods=['GET'])
    def get_users():
        """获取所有用户"""
        return jsonify({"users": []})
    
    @app.route('/users/<int:user_id>', methods=['GET'])
    def get_user(user_id):
        """获取特定用户"""
        return jsonify({"user_id": user_id})
    
    @app.route('/users', methods=['POST'])
    def create_user():
        """创建新用户"""
        data = request.get_json()
        return jsonify({"message": "用户已创建", "data": data})
    
    @app.route('/users/<int:user_id>', methods=['PUT'])
    def update_user(user_id):
        """更新用户"""
        data = request.get_json()
        return jsonify({"message": "用户已更新", "user_id": user_id})
    
    @app.route('/users/<int:user_id>', methods=['DELETE'])
    def delete_user(user_id):
        """删除用户"""
        return jsonify({"message": "用户已删除", "user_id": user_id})

# 声明式中间件
def require_auth(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        auth_header = request.headers.get('Authorization')
        if not auth_header:
            return jsonify({"error": "需要认证"}), 401
        return f(*args, **kwargs)
    return decorated_function

# 使用中间件
@app.route('/protected', methods=['GET'])
@require_auth
def protected_resource():
    return jsonify({"message": "受保护的资源"})

# 启动应用
if __name__ == '__main__':
    app.run(debug=True)
```

## 声明式工作流

### 工作流定义

```python
from dataclasses import dataclass
from typing import List, Dict, Any
from enum import Enum

class TaskStatus(Enum):
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"

@dataclass
class Task:
    id: str
    name: str
    action: str
    dependencies: List[str]
    status: TaskStatus = TaskStatus.PENDING

class DeclarativeWorkflow:
    def __init__(self):
        self.tasks: Dict[str, Task] = {}
    
    def add_task(self, task: Task):
        self.tasks[task.id] = task
    
    def execute(self):
        # 拓扑排序执行任务
        completed = set()
        
        while len(completed) < len(self.tasks):
            for task_id, task in self.tasks.items():
                if task_id in completed:
                    continue
                
                # 检查依赖是否完成
                if all(dep in completed for dep in task.dependencies):
                    print(f"执行任务: {task.name}")
                    task.status = TaskStatus.RUNNING
                    
                    # 模拟任务执行
                    try:
                        # 这里执行实际任务
                        task.status = TaskStatus.COMPLETED
                        completed.add(task_id)
                        print(f"任务完成: {task.name}")
                    except Exception as e:
                        task.status = TaskStatus.FAILED
                        print(f"任务失败: {task.name} - {e}")

def declarative_workflow_example():
    workflow = DeclarativeWorkflow()
    
    # 声明式工作流定义
    workflow.add_task(Task("fetch", "获取数据", "fetch_data", []))
    workflow.add_task(Task("process", "处理数据", "process_data", ["fetch"]))
    workflow.add_task(Task("validate", "验证数据", "validate_data", ["process"]))
    workflow.add_task(Task("save", "保存数据", "save_data", ["validate"]))
    workflow.add_task(Task("notify", "发送通知", "send_notification", ["save"]))
    
    # 执行工作流
    print("开始执行声明式工作流:")
    workflow.execute()

declarative_workflow_example()
```

## 总结

声明式编程通过描述意图和规则，而不是具体的执行步骤，提供了一种更高层次的抽象，使代码更加清晰、可维护和可理解。

---

**相关链接：**

- [10.2.1-函数式编程范式深化](10.2.1-函数式编程范式深化.md)
- [10.2.2-面向对象编程范式深化](10.2.2-面向对象编程范式深化.md)
- [10.2.3-并发编程深化](10.2.3-并发编程深化.md)
- [10.2.4-异步编程深化](10.2.4-异步编程深化.md)
- [10.2.5-响应式编程深化](10.2.5-响应式编程深化.md)
