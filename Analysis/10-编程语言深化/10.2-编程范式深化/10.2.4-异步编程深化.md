# 10.2.4-异步编程深化

## 1. 概述

异步编程是一种非阻塞的编程范式，允许程序在等待I/O操作时执行其他任务，提高程序的并发性能。

## 2. 异步编程基础

### 2.1. 同步 vs 异步

```python
# 同步编程
def sync_read_file():
    with open('file.txt', 'r') as f:
        content = f.read()  # 阻塞直到读取完成
    return content

# 异步编程
async def async_read_file():
    async with aiofiles.open('file.txt', 'r') as f:
        content = await f.read()  # 非阻塞，可以切换任务
    return content
```

## 3. 事件循环

```python
import asyncio

async def main():
    task1 = asyncio.create_task(async_read_file())
    task2 = asyncio.create_task(async_read_file())
    
# 并发执行
    results = await asyncio.gather(task1, task2)
    return results

asyncio.run(main())
```

## 4. 异步编程模型

### 4.1. 协程 (Coroutines)

```python
async def coroutine_example():
    print("开始")
    await asyncio.sleep(1)  # 非阻塞等待
    print("结束")

async def main():
    task1 = asyncio.create_task(coroutine_example())
    task2 = asyncio.create_task(coroutine_example())
    await asyncio.gather(task1, task2)
```

### 4.2. Future/Promise

```python
async def fetch_data():
    await asyncio.sleep(1)  # 模拟网络请求
    return {"data": "result"}

async def main():
    future = asyncio.create_task(fetch_data())
    print("其他工作...")
    result = await future
    print(result)
```

## 5. 异步I/O操作

### 5.1. 文件操作

```python
import aiofiles

async def read_files():
    tasks = []
    for filename in ['file1.txt', 'file2.txt', 'file3.txt']:
        task = asyncio.create_task(read_file(filename))
        tasks.append(task)
    
    contents = await asyncio.gather(*tasks)
    return contents

async def read_file(filename):
    async with aiofiles.open(filename, 'r') as f:
        return await f.read()
```

### 5.2. 网络请求

```python
import aiohttp

async def fetch_urls():
    urls = [
        'https://api.example.com/data1',
        'https://api.example.com/data2',
        'https://api.example.com/data3'
    ]
    
    async with aiohttp.ClientSession() as session:
        tasks = []
        for url in urls:
            task = asyncio.create_task(fetch_url(session, url))
            tasks.append(task)
        
        results = await asyncio.gather(*tasks)
        return results

async def fetch_url(session, url):
    async with session.get(url) as response:
        return await response.json()
```

## 6. 异步控制流

### 6.1. 条件执行

```python
async def conditional_task():
    if await check_condition():
        result = await process_data()
    else:
        result = await alternative_process()
    return result
```

### 6.2. 循环和迭代

```python
async def process_items(items):
    results = []
    for item in items:
        result = await process_item(item)
        results.append(result)
    return results
```

## 7. 异步错误处理

### 7.1. 异常处理

```python
async def robust_operation():
    try:
        result = await risky_operation()
        return result
    except Exception as e:
        print(f"错误: {e}")
        return None
```

### 7.2. 超时处理

```python
async def timeout_example():
    try:
        result = await asyncio.wait_for(slow_operation(), timeout=2.0)
        return result
    except asyncio.TimeoutError:
        return "操作超时"
```

## 8. 异步编程模式

### 8.1. 生产者-消费者

```python
async def producer(queue):
    for i in range(10):
        item = f"item_{i}"
        await queue.put(item)
        await asyncio.sleep(0.1)
    await queue.put(None)  # 结束信号

async def consumer(queue):
    while True:
        item = await queue.get()
        if item is None:
            break
        print(f"处理: {item}")
        await asyncio.sleep(0.2)
        queue.task_done()
```

### 8.2. 工作池

```python
async def worker_pool():
    semaphore = asyncio.Semaphore(3)  # 限制并发数
    
    async def worker(worker_id):
        async with semaphore:
            print(f"工作者 {worker_id} 开始")
            await asyncio.sleep(1)
            print(f"工作者 {worker_id} 完成")
    
    tasks = [worker(i) for i in range(10)]
    await asyncio.gather(*tasks)
```

## 9. 异步编程最佳实践

### 9.1. 避免阻塞操作

```python
# 错误：在异步函数中使用阻塞操作
async def bad_example():
    time.sleep(1)  # 阻塞整个事件循环

# 正确：使用异步操作
async def good_example():
    await asyncio.sleep(1)  # 非阻塞
```

## 10. 资源管理

```python
async def resource_management():
    async with aiofiles.open('file.txt', 'r') as f:
        content = await f.read()
    return content
```

## 11. 异步编程与并发

### 11.1. 并发 vs 并行

```python
# 并发：多个任务交替执行
async def concurrent_tasks():
    tasks = [task1(), task2(), task3()]
    results = await asyncio.gather(*tasks)
    return results

# 并行：使用多进程
import multiprocessing

def parallel_tasks():
    with multiprocessing.Pool() as pool:
        results = pool.map(cpu_intensive_task, data)
    return results
```

## 12. 总结

异步编程通过非阻塞I/O和事件循环提供高效的并发处理能力，特别适合I/O密集型应用。理解异步编程模式对于构建高性能的现代应用程序至关重要。

---

**相关链接：**

- [10.2.1-函数式编程深化](10.2.1-函数式编程范式深化.md)
- [10.2.3-并发编程深化](10.2.3-并发编程深化.md)
