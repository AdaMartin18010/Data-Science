# 10.2.3-并发编程深化

## 概述

并发编程处理多个任务同时执行，涉及线程、进程、协程等模型。

## 并发基础

### 并发与并行

- **并发**: 任务交替执行，看起来同时进行
- **并行**: 任务真正同时执行，需要多核

### 并发原语

- **线程**: 轻量级执行单元，共享进程内存
- **进程**: 独立内存空间和执行环境
- **协程**: 用户级线程，程序控制调度

## 线程模型

### 线程创建

```python
import threading

def worker(name):
    print(f"线程 {name} 工作")
    time.sleep(2)

thread1 = threading.Thread(target=worker, args=("A",))
thread1.start()
thread1.join()
```

### 线程状态

1. 新建 → 就绪 → 运行 → 阻塞 → 终止

## 同步机制

### 锁机制

```python
class Counter:
    def __init__(self):
        self.value = 0
        self.lock = threading.Lock()
    
    def increment(self):
        with self.lock:
            self.value += 1
```

### 信号量

```python
semaphore = threading.Semaphore(3)

def worker():
    with semaphore:
        print("获得资源")
        time.sleep(1)
```

## 进程模型

### 进程创建

```python
import multiprocessing

def worker(name):
    print(f"进程 {name} 工作")

p = multiprocessing.Process(target=worker, args=("A",))
p.start()
p.join()
```

### 进程间通信

```python
parent_conn, child_conn = multiprocessing.Pipe()
parent_conn.send("Hello")
msg = child_conn.recv()
```

## 协程模型

### 异步协程

```python
import asyncio

async def worker(name, delay):
    print(f"协程 {name} 开始")
    await asyncio.sleep(delay)
    print(f"协程 {name} 完成")

async def main():
    tasks = [worker("A", 2), worker("B", 1)]
    await asyncio.gather(*tasks)

asyncio.run(main())
```

## 并发模式

### 生产者-消费者

```python
import queue

def producer(q):
    for i in range(5):
        q.put(f"Item-{i}")

def consumer(q):
    while True:
        item = q.get()
        print(f"消费: {item}")
        q.task_done()
```

### 工作池

```python
with concurrent.futures.ThreadPoolExecutor(max_workers=4) as executor:
    futures = [executor.submit(worker, i) for i in range(10)]
    results = [f.result() for f in futures]
```

## 并发控制

### 原子操作

```python
class AtomicCounter:
    def __init__(self):
        self._value = 0
        self._lock = threading.Lock()
    
    def increment(self):
        with self._lock:
            self._value += 1
```

## 并发问题

### 竞态条件

```python
def increment(self):
    current = self.counter  # 读取
    time.sleep(0.001)       # 处理
    self.counter = current + 1  # 写入
```

### 死锁

```python
def method1(self):
    self.lock1.acquire()
    self.lock2.acquire()  # 可能死锁

def method2(self):
    self.lock2.acquire()
    self.lock1.acquire()  # 可能死锁
```

## 最佳实践

### 避免共享状态

```python
@dataclass(frozen=True)
class Point:
    x: int
    y: int  # 不可变数据
```

### 线程安全数据结构

```python
safe_queue = queue.Queue()
safe_queue.put(item)
item = safe_queue.get()
```

## 总结

并发编程需要理解同步机制、避免竞态条件和死锁，采用线程安全的数据结构和不可变数据。

---

**相关链接：**

- [10.2.1-函数式编程深化](10.2.1-函数式编程范式深化.md)
- [10.2.2-面向对象编程深化](10.2.2-面向对象编程范式深化.md)
