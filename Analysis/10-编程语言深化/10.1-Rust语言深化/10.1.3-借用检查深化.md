# 10.1.3-Rust借用检查深化

## 概述

借用检查是Rust内存安全系统的核心机制，通过编译时检查确保引用的安全性和有效性。

## 借用规则基础

### 基本借用规则

1. **任意时刻，只能有一个可变引用或多个不可变引用**
2. **引用必须总是有效的**
3. **不能同时拥有可变和不可变引用**

### 借用检查器工作原理

```rust
fn main() {
    let mut data = vec![1, 2, 3];

    // 不可变借用
    let ref1 = &data;
    let ref2 = &data;  // 允许多个不可变借用

    // 可变借用 - 编译错误
    // let ref3 = &mut data;  // 错误：不能同时有可变和不可变借用

    println!("{:?}, {:?}", ref1, ref2);
}
```

## 借用检查算法

### 借用检查器实现原理

```rust
struct BorrowChecker {
    active_borrows: HashMap<VariableId, Vec<Borrow>>,
    lifetimes: HashMap<VariableId, Lifetime>,
}

struct Borrow {
    kind: BorrowKind,  // Mutable 或 Immutable
    lifetime: Lifetime,
    location: Location,
}
```

### 借用检查过程

1. **收集借用信息**: 分析代码中的所有借用操作
2. **构建借用图**: 建立借用关系的有向图
3. **检查冲突**: 验证借用规则是否被违反
4. **生命周期推断**: 自动推断引用的生命周期

## 高级借用模式

### 借用分割 (Borrow Splitting)

```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let mut point = Point { x: 0, y: 0 };

    // 借用分割：同时借用不同的字段
    let x_ref = &mut point.x;
    let y_ref = &mut point.y;

    *x_ref = 5;
    *y_ref = 10;
}
```

## 生命周期与借用检查

### 生命周期参数

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

### 生命周期推断

```rust
// 编译器自动推断生命周期
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```

## 借用检查与并发安全

### 数据竞争预防

```rust
use std::sync::{Arc, Mutex};

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }
}
```

## 借用检查器实现细节

### 借用检查算法1

```rust
fn check_borrows(borrows: &[Borrow]) -> Result<(), BorrowError> {
    for (i, borrow1) in borrows.iter().enumerate() {
        for borrow2 in &borrows[i+1..] {
            if borrow1.variable == borrow2.variable {
                match (borrow1.kind, borrow2.kind) {
                    (BorrowKind::Mutable, _) | (_, BorrowKind::Mutable) => {
                        return Err(BorrowError::MultipleMutable);
                    }
                    _ => {}
                }
            }
        }
    }
    Ok(())
}
```

## 借用检查优化

### 非词汇生命周期 (NLL)

```rust
fn main() {
    let mut data = vec![1, 2, 3];

    // 在NLL之前，这个代码会编译错误
    // 现在编译器可以识别借用不再需要
    let first = &data[0];
    println!("第一个元素: {}", first);

    // 现在可以可变借用
    data.push(4);
}
```

## 借用检查与错误处理

### 常见借用错误

```rust
fn main() {
    let mut v = vec![1, 2, 3];

    // 错误1：同时可变和不可变借用
    let first = &v[0];
    v.push(4);  // 编译错误

    // 错误2：悬垂引用
    let r;
    {
        let x = 5;
        r = &x;  // 编译错误：x的生命周期不够长
    }
    println!("r: {}", r);
}
```

### 错误修复策略

```rust
// 修复1：重新组织代码结构
fn main() {
    let mut v = vec![1, 2, 3];

    {
        let first = &v[0];
        println!("第一个元素: {}", first);
    }  // first的作用域结束

    v.push(4);  // 现在可以安全地修改
}
```

## 借用检查与性能

### 零成本抽象

```rust
// 借用检查在编译时完成，运行时零开销
fn process_slice(data: &[i32]) -> i32 {
    data.iter().sum()
}
```

## 总结

Rust的借用检查器通过编译时分析确保内存安全，防止数据竞争和悬垂引用。它是Rust零成本抽象的核心，为并发编程提供了强大的安全保障。

---

**相关链接：**

- [10.1.1-所有权系统深化](10.1.1-所有权系统深化.md)
- [10.1.2-生命周期深化](10.1.2-生命周期深化.md)
