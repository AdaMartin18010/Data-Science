# 10.1.5-内存安全深化

## 概述

内存安全是Rust语言的核心特性，通过编译时检查确保程序不会出现内存错误。

## 内存安全问题

### 常见内存错误

1. 空指针解引用
2. 悬垂指针
3. 缓冲区溢出
4. 数据竞争
5. 内存泄漏

### 传统语言的问题

```c
// C语言中的内存安全问题
int* ptr = malloc(sizeof(int));
*ptr = 42;
free(ptr);
*ptr = 100; // 悬垂指针

int arr[5];
arr[10] = 42; // 缓冲区溢出
```

## Rust内存安全机制

### 所有权系统

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1; // s1的所有权移动到s2
    
    // println!("{}", s1); // 编译错误：s1已被移动
    println!("{}", s2); // 正常工作
}
```

### 借用检查器

```rust
fn main() {
    let mut data = vec![1, 2, 3];
    
    let reference = &data; // 不可变借用
    // data.push(4); // 编译错误：同时存在可变和不可变借用
    
    println!("{:?}", reference);
    data.push(4); // 现在可以修改
}
```

### 生命周期系统

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}

fn main() {
    let string1 = String::from("long string");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(&string1, &string2);
    }
    // println!("{}", result); // 编译错误：生命周期不够长
}
```

## 内存安全保证

### 编译时检查

```rust
fn ownership_example() {
    let s = String::from("hello");
    takes_ownership(s);
    // println!("{}", s); // 编译错误：s已被移动
}

fn takes_ownership(some_string: String) {
    println!("{}", some_string);
} // some_string离开作用域并被释放
```

### 借用规则

```rust
fn borrowing_rules() {
    let mut data = vec![1, 2, 3];
    
    // 规则1：任意时刻只能有一个可变引用或多个不可变引用
    let ref1 = &data; // 不可变引用
    let ref2 = &data; // 不可变引用
    // let ref3 = &mut data; // 编译错误：不能同时有可变和不可变引用
    
    println!("{} {}", ref1[0], ref2[1]);
}
```

## 智能指针

### `Box<T>` - 堆分配

```rust
use std::boxed::Box;

fn box_example() {
    let b = Box::new(5);
    println!("b = {}", b);
} // b离开作用域时自动释放
```

### `Rc<T>` - 引用计数

```rust
use std::rc::Rc;

fn rc_example() {
    let data = Rc::new(vec![1, 2, 3]);
    let data_clone1 = Rc::clone(&data);
    let data_clone2 = Rc::clone(&data);
    
    println!("引用计数: {}", Rc::strong_count(&data));
    println!("数据: {:?}", data);
}
```

### `Arc<T>` - 原子引用计数

```rust
use std::sync::Arc;
use std::thread;

fn arc_example() {
    let counter = Arc::new(0);
    let mut handles = vec![];
    
    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            println!("线程中的计数器: {}", counter);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
}
```

## 并发安全

### `Mutex<T>` - 互斥锁

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn mutex_example() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    
    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("最终计数: {}", *counter.lock().unwrap());
}
```

### `RwLock<T>` - 读写锁

```rust
use std::sync::{Arc, RwLock};
use std::thread;

fn rwlock_example() {
    let data = Arc::new(RwLock::new(vec![1, 2, 3]));
    let mut handles = vec![];
    
    // 读取线程
    for i in 0..3 {
        let data = Arc::clone(&data);
        let handle = thread::spawn(move || {
            let read_data = data.read().unwrap();
            println!("读取线程 {}: {:?}", i, *read_data);
        });
        handles.push(handle);
    }
    
    // 写入线程
    let data = Arc::clone(&data);
    let handle = thread::spawn(move || {
        let mut write_data = data.write().unwrap();
        write_data.push(4);
        println!("写入线程: {:?}", *write_data);
    });
    handles.push(handle);
    
    for handle in handles {
        handle.join().unwrap();
    }
}
```

## 内存安全模式

### RAII模式

```rust
struct Resource {
    data: String,
}

impl Resource {
    fn new(data: String) -> Self {
        println!("创建资源: {}", data);
        Resource { data }
    }
}

impl Drop for Resource {
    fn drop(&mut self) {
        println!("释放资源: {}", self.data);
    }
}

fn raii_example() {
    let resource = Resource::new("hello".to_string());
    println!("使用资源: {}", resource.data);
} // 自动调用drop方法
```

### 内部可变性

```rust
use std::cell::RefCell;

fn interior_mutability() {
    let data = RefCell::new(5);
    
    {
        let mut borrowed = data.borrow_mut();
        *borrowed += 10;
    }
    
    println!("数据: {}", *data.borrow());
}
```

## 内存安全最佳实践

### 避免unsafe代码

```rust
// 安全的代码
fn safe_function(data: &[i32]) -> i32 {
    data.iter().sum()
}

// 不安全的代码（仅在必要时使用）
unsafe fn unsafe_function(ptr: *const i32) -> i32 {
    *ptr // 可能不安全
}
```

### 使用类型系统

```rust
// 使用强类型避免错误
struct UserId(u32);
struct ProductId(u32);

fn process_user(user_id: UserId) {
    // 类型安全，不能传入ProductId
}

fn process_product(product_id: ProductId) {
    // 类型安全，不能传入UserId
}
```

### 错误处理

```rust
use std::fs::File;
use std::io::{self, Read};

fn read_file_safely(path: &str) -> Result<String, io::Error> {
    let mut file = File::open(path)?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    Ok(contents)
}

fn main() {
    match read_file_safely("data.txt") {
        Ok(content) => println!("文件内容: {}", content),
        Err(e) => eprintln!("读取错误: {}", e),
    }
}
```

## 内存安全验证

### 1编译时检查

```rust
// 所有权检查
fn ownership_check() {
    let s = String::from("hello");
    let s_ref = &s;
    // s_ref的生命周期不能超过s
    println!("{}", s_ref);
}

// 借用检查
fn borrowing_check() {
    let mut data = vec![1, 2, 3];
    let ref1 = &data;
    let ref2 = &data;
    // 可以同时有多个不可变引用
    println!("{} {}", ref1[0], ref2[1]);
}
```

### 运行时检查

```rust
use std::cell::RefCell;

fn runtime_check() {
    let data = RefCell::new(vec![1, 2, 3]);
    
    // 运行时借用检查
    let ref1 = data.borrow();
    // let ref2 = data.borrow_mut(); // 运行时panic：已存在不可变借用
    
    println!("{:?}", *ref1);
}
```

## 总结

Rust的内存安全机制通过编译时检查、所有权系统、借用检查器和生命周期系统，有效防止了常见的内存错误，为程序提供了强大的安全保障。

---

**相关链接：**

- [10.1.1-所有权系统深化](10.1.1-所有权系统深化.md)
- [10.1.2-生命周期深化](10.1.2-生命周期深化.md)
- [10.1.3-借用检查深化](10.1.3-借用检查深化.md)
- [10.1.4-零成本抽象深化](10.1.4-零成本抽象深化.md)
- [10.1.6-并发编程深化](10.1.6-并发编程深化.md)
