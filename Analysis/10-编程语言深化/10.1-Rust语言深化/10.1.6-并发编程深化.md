# 10.1.6-并发编程深化

## 概述

Rust的并发编程模型基于所有权和类型系统，提供了内存安全的并发编程能力。

## 并发编程基础

### 线程创建

```rust
use std::thread;

fn basic_threading() {
    let handle = thread::spawn(|| {
        for i in 1..=5 {
            println!("线程中的数字: {}", i);
            thread::sleep(std::time::Duration::from_millis(100));
        }
    });

    for i in 1..=5 {
        println!("主线程中的数字: {}", i);
        thread::sleep(std::time::Duration::from_millis(100));
    }

    handle.join().unwrap();
}
```

### 线程间数据共享

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn shared_data() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("最终计数: {}", *counter.lock().unwrap());
}
```

## 同步原语

### `Mutex<T>` - 互斥锁

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn mutex_example() {
    let data = Arc::new(Mutex::new(vec![1, 2, 3]));
    let mut handles = vec![];

    for i in 0..3 {
        let data = Arc::clone(&data);
        let handle = thread::spawn(move || {
            let mut guard = data.lock().unwrap();
            guard.push(i);
            println!("线程 {} 添加了 {}", i, i);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("最终数据: {:?}", *data.lock().unwrap());
}
```

### `RwLock<T>` - 读写锁

```rust
use std::sync::{Arc, RwLock};
use std::thread;

fn rwlock_example() {
    let data = Arc::new(RwLock::new(vec![1, 2, 3]));
    let mut handles = vec![];

    // 读取线程
    for i in 0..3 {
        let data = Arc::clone(&data);
        let handle = thread::spawn(move || {
            let read_data = data.read().unwrap();
            println!("读取线程 {}: {:?}", i, *read_data);
        });
        handles.push(handle);
    }

    // 写入线程
    let data = Arc::clone(&data);
    let handle = thread::spawn(move || {
        let mut write_data = data.write().unwrap();
        write_data.push(4);
        println!("写入线程: {:?}", *write_data);
    });
    handles.push(handle);

    for handle in handles {
        handle.join().unwrap();
    }
}
```

### Condvar - 条件变量

```rust
use std::sync::{Arc, Mutex, Condvar};
use std::thread;

fn condvar_example() {
    let pair = Arc::new((Mutex::new(false), Condvar::new()));
    let pair2 = Arc::clone(&pair);

    // 等待线程
    let handle = thread::spawn(move || {
        let (lock, cvar) = &*pair2;
        let mut started = lock.lock().unwrap();
        while !*started {
            started = cvar.wait(started).unwrap();
        }
        println!("条件满足，继续执行");
    });

    // 通知线程
    thread::sleep(std::time::Duration::from_secs(1));
    let (lock, cvar) = &*pair;
    let mut started = lock.lock().unwrap();
    *started = true;
    cvar.notify_one();

    handle.join().unwrap();
}
```

## 原子操作

### AtomicUsize

```rust
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::Arc;
use std::thread;

fn atomic_example() {
    let counter = Arc::new(AtomicUsize::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            for _ in 0..1000 {
                counter.fetch_add(1, Ordering::SeqCst);
            }
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("最终计数: {}", counter.load(Ordering::SeqCst));
}
```

### 内存顺序

```rust
use std::sync::atomic::{AtomicBool, AtomicUsize, Ordering};
use std::sync::Arc;
use std::thread;

fn memory_ordering() {
    let flag = Arc::new(AtomicBool::new(false));
    let data = Arc::new(AtomicUsize::new(0));
    let flag2 = Arc::clone(&flag);
    let data2 = Arc::clone(&data);

    // 生产者线程
    let producer = thread::spawn(move || {
        data2.store(42, Ordering::Release);
        flag2.store(true, Ordering::Release);
    });

    // 消费者线程
    let consumer = thread::spawn(move || {
        while !flag.load(Ordering::Acquire) {
            thread::yield_now();
        }
        let value = data.load(Ordering::Acquire);
        println!("读取到的值: {}", value);
    });

    producer.join().unwrap();
    consumer.join().unwrap();
}
```

## 通道通信

### mpsc - 多生产者单消费者

```rust
use std::sync::mpsc;
use std::thread;

fn mpsc_example() {
    let (tx, rx) = mpsc::channel();
    let mut handles = vec![];

    // 多个生产者
    for i in 0..5 {
        let tx = tx.clone();
        let handle = thread::spawn(move || {
            tx.send(format!("消息来自线程 {}", i)).unwrap();
        });
        handles.push(handle);
    }

    // 等待所有生产者完成
    drop(tx);

    // 消费者
    for received in rx {
        println!("收到: {}", received);
    }

    for handle in handles {
        handle.join().unwrap();
    }
}
```

### 同步通道

```rust
use std::sync::mpsc;
use std::thread;

fn sync_channel_example() {
    let (tx, rx) = mpsc::sync_channel(2); // 缓冲区大小为2
    let mut handles = vec![];

    // 生产者
    for i in 0..5 {
        let tx = tx.clone();
        let handle = thread::spawn(move || {
            println!("发送消息 {}", i);
            tx.send(i).unwrap();
            println!("消息 {} 已发送", i);
        });
        handles.push(handle);
    }

    // 消费者
    let consumer = thread::spawn(move || {
        for received in rx {
            println!("收到消息: {}", received);
            thread::sleep(std::time::Duration::from_millis(500));
        }
    });

    for handle in handles {
        handle.join().unwrap();
    }
    consumer.join().unwrap();
}
```

## 异步编程

### async/await

```rust
use tokio;

async fn async_function() -> String {
    tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
    "异步操作完成".to_string()
}

async fn async_main() {
    let task1 = async_function();
    let task2 = async_function();
    
    let (result1, result2) = tokio::join!(task1, task2);
    
    println!("结果1: {}", result1);
    println!("结果2: {}", result2);
}

#[tokio::main]
async fn main() {
    async_main().await;
}
```

### 异步通道

```rust
use tokio::sync::mpsc;

async fn async_channel_example() {
    let (tx, mut rx) = mpsc::channel(100);
    
    // 异步生产者
    let producer = tokio::spawn(async move {
        for i in 0..10 {
            tx.send(i).await.unwrap();
            tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
        }
    });
    
    // 异步消费者
    let consumer = tokio::spawn(async move {
        while let Some(value) = rx.recv().await {
            println!("收到异步消息: {}", value);
        }
    });
    
    producer.await.unwrap();
    consumer.await.unwrap();
}

#[tokio::main]
async fn main() {
    async_channel_example().await;
}
```

## 并发模式

### 工作池模式

```rust
use std::sync::{Arc, Mutex};
use std::thread;
use std::collections::VecDeque;

struct ThreadPool {
    workers: Vec<Worker>,
    sender: std::sync::mpsc::Sender<Message>,
}

enum Message {
    NewJob(Job),
    Terminate,
}

type Job = Box<dyn FnOnce() + Send + 'static>;

struct Worker {
    id: usize,
    thread: Option<thread::JoinHandle<()>>,
}

impl ThreadPool {
    fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let (sender, receiver) = std::sync::mpsc::channel();
        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&receiver)));
        }

        ThreadPool { workers, sender }
    }

    fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);
        self.sender.send(Message::NewJob(job)).unwrap();
    }
}

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<std::sync::mpsc::Receiver<Message>>>) -> Worker {
        let thread = thread::spawn(move || loop {
            let message = receiver.lock().unwrap().recv().unwrap();

            match message {
                Message::NewJob(job) => {
                    println!("工作线程 {} 执行任务", id);
                    job();
                }
                Message::Terminate => {
                    println!("工作线程 {} 终止", id);
                    break;
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}

impl Drop for ThreadPool {
    fn drop(&mut self) {
        for _ in &self.workers {
            self.sender.send(Message::Terminate).unwrap();
        }

        for worker in &mut self.workers {
            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}

fn thread_pool_example() {
    let pool = ThreadPool::new(4);

    for i in 0..8 {
        pool.execute(move || {
            println!("执行任务 {}", i);
            thread::sleep(std::time::Duration::from_millis(100));
        });
    }
}
```

### 生产者-消费者模式

```rust
use std::sync::{Arc, Mutex, Condvar};
use std::thread;
use std::collections::VecDeque;

struct BoundedBuffer<T> {
    buffer: Mutex<VecDeque<T>>,
    capacity: usize,
    not_full: Condvar,
    not_empty: Condvar,
}

impl<T> BoundedBuffer<T> {
    fn new(capacity: usize) -> Self {
        BoundedBuffer {
            buffer: Mutex::new(VecDeque::new()),
            capacity,
            not_full: Condvar::new(),
            not_empty: Condvar::new(),
        }
    }

    fn push(&self, item: T) {
        let mut buffer = self.buffer.lock().unwrap();
        while buffer.len() >= self.capacity {
            buffer = self.not_full.wait(buffer).unwrap();
        }
        buffer.push_back(item);
        self.not_empty.notify_one();
    }

    fn pop(&self) -> T {
        let mut buffer = self.buffer.lock().unwrap();
        while buffer.is_empty() {
            buffer = self.not_empty.wait(buffer).unwrap();
        }
        let item = buffer.pop_front().unwrap();
        self.not_full.notify_one();
        item
    }
}

fn producer_consumer_example() {
    let buffer = Arc::new(BoundedBuffer::new(5));
    let buffer2 = Arc::clone(&buffer);

    // 生产者
    let producer = thread::spawn(move || {
        for i in 0..10 {
            buffer.push(i);
            println!("生产者: 放入 {}", i);
            thread::sleep(std::time::Duration::from_millis(200));
        }
    });

    // 消费者
    let consumer = thread::spawn(move || {
        for _ in 0..10 {
            let item = buffer2.pop();
            println!("消费者: 取出 {}", item);
            thread::sleep(std::time::Duration::from_millis(300));
        }
    });

    producer.join().unwrap();
    consumer.join().unwrap();
}
```

## 并发安全最佳实践

### 避免数据竞争

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn safe_concurrent_access() {
    let data = Arc::new(Mutex::new(vec![1, 2, 3]));
    let mut handles = vec![];

    for i in 0..3 {
        let data = Arc::clone(&data);
        let handle = thread::spawn(move || {
            let mut guard = data.lock().unwrap();
            guard.push(i);
            // 锁在作用域结束时自动释放
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("最终数据: {:?}", *data.lock().unwrap());
}
```

### 避免死锁

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn avoid_deadlock() {
    let lock1 = Arc::new(Mutex::new(1));
    let lock2 = Arc::new(Mutex::new(2));

    let lock1_clone = Arc::clone(&lock1);
    let lock2_clone = Arc::clone(&lock2);

    // 线程1：先获取lock1，再获取lock2
    let handle1 = thread::spawn(move || {
        let _guard1 = lock1_clone.lock().unwrap();
        thread::sleep(std::time::Duration::from_millis(100));
        let _guard2 = lock2_clone.lock().unwrap();
        println!("线程1完成");
    });

    // 线程2：先获取lock1，再获取lock2（避免死锁）
    let handle2 = thread::spawn(move || {
        let _guard1 = lock1.lock().unwrap();
        thread::sleep(std::time::Duration::from_millis(100));
        let _guard2 = lock2.lock().unwrap();
        println!("线程2完成");
    });

    handle1.join().unwrap();
    handle2.join().unwrap();
}
```

### 性能优化

```rust
use std::sync::{Arc, RwLock};
use std::thread;

fn performance_optimization() {
    let data = Arc::new(RwLock::new(vec![1, 2, 3, 4, 5]));
    let mut handles = vec![];

    // 多个读取线程
    for i in 0..5 {
        let data = Arc::clone(&data);
        let handle = thread::spawn(move || {
            let read_data = data.read().unwrap();
            println!("读取线程 {}: {:?}", i, *read_data);
        });
        handles.push(handle);
    }

    // 一个写入线程
    let data = Arc::clone(&data);
    let handle = thread::spawn(move || {
        let mut write_data = data.write().unwrap();
        write_data.push(6);
        println!("写入线程: {:?}", *write_data);
    });
    handles.push(handle);

    for handle in handles {
        handle.join().unwrap();
    }
}
```

## 总结

Rust的并发编程模型通过所有权系统、类型安全和精心设计的同步原语，提供了强大而安全的并发编程能力。

---

**相关链接：**

- [10.1.1-所有权系统深化](10.1.1-所有权系统深化.md)
- [10.1.2-生命周期深化](10.1.2-生命周期深化.md)
- [10.1.3-借用检查深化](10.1.3-借用检查深化.md)
- [10.1.4-零成本抽象深化](10.1.4-零成本抽象深化.md)
- [10.1.5-内存安全深化](10.1.5-内存安全深化.md)
