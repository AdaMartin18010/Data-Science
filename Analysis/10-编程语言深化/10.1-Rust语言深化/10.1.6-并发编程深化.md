# 10.1.6-å¹¶å‘ç¼–ç¨‹æ·±åŒ–

## ğŸ“‘ ç›®å½•

- [10.1.6-å¹¶å‘ç¼–ç¨‹æ·±åŒ–](#1016-å¹¶å‘ç¼–ç¨‹æ·±åŒ–)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
- [æ¦‚è¿°](#æ¦‚è¿°)
- [å¹¶å‘ç¼–ç¨‹åŸºç¡€](#å¹¶å‘ç¼–ç¨‹åŸºç¡€)
  - [çº¿ç¨‹åˆ›å»º](#çº¿ç¨‹åˆ›å»º)
  - [çº¿ç¨‹é—´æ•°æ®å…±äº«](#çº¿ç¨‹é—´æ•°æ®å…±äº«)
- [åŒæ­¥åŸè¯­](#åŒæ­¥åŸè¯­)
  - [`Mutex<T>` - äº’æ–¥é”](#mutext-äº’æ–¥é”)
  - [`RwLock<T>` - è¯»å†™é”](#rwlockt-è¯»å†™é”)
  - [Condvar - æ¡ä»¶å˜é‡](#condvar-æ¡ä»¶å˜é‡)
- [åŸå­æ“ä½œ](#åŸå­æ“ä½œ)
  - [AtomicUsize](#atomicusize)
  - [å†…å­˜é¡ºåº](#å†…å­˜é¡ºåº)
- [é€šé“é€šä¿¡](#é€šé“é€šä¿¡)
  - [mpsc - å¤šç”Ÿäº§è€…å•æ¶ˆè´¹è€…](#mpsc-å¤šç”Ÿäº§è€…å•æ¶ˆè´¹è€…)
  - [åŒæ­¥é€šé“](#åŒæ­¥é€šé“)
- [å¼‚æ­¥ç¼–ç¨‹](#å¼‚æ­¥ç¼–ç¨‹)
  - [async/await](#asyncawait)
  - [å¼‚æ­¥é€šé“](#å¼‚æ­¥é€šé“)
- [å¹¶å‘æ¨¡å¼](#å¹¶å‘æ¨¡å¼)
  - [å·¥ä½œæ± æ¨¡å¼](#å·¥ä½œæ± æ¨¡å¼)
  - [ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼](#ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼)
- [å¹¶å‘å®‰å…¨æœ€ä½³å®è·µ](#å¹¶å‘å®‰å…¨æœ€ä½³å®è·µ)
  - [é¿å…æ•°æ®ç«äº‰](#é¿å…æ•°æ®ç«äº‰)
  - [é¿å…æ­»é”](#é¿å…æ­»é”)
  - [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
- [æ€»ç»“](#æ€»ç»“)
---


## æ¦‚è¿°

Rustçš„å¹¶å‘ç¼–ç¨‹æ¨¡å‹åŸºäºæ‰€æœ‰æƒå’Œç±»å‹ç³»ç»Ÿï¼Œæä¾›äº†å†…å­˜å®‰å…¨çš„å¹¶å‘ç¼–ç¨‹èƒ½åŠ›ã€‚

## å¹¶å‘ç¼–ç¨‹åŸºç¡€

### çº¿ç¨‹åˆ›å»º

```rust
use std::thread;

fn basic_threading() {
    let handle = thread::spawn(|| {
        for i in 1..=5 {
            println!("çº¿ç¨‹ä¸­çš„æ•°å­—: {}", i);
            thread::sleep(std::time::Duration::from_millis(100));
        }
    });

    for i in 1..=5 {
        println!("ä¸»çº¿ç¨‹ä¸­çš„æ•°å­—: {}", i);
        thread::sleep(std::time::Duration::from_millis(100));
    }

    handle.join().unwrap();
}
```

### çº¿ç¨‹é—´æ•°æ®å…±äº«

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn shared_data() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("æœ€ç»ˆè®¡æ•°: {}", *counter.lock().unwrap());
}
```

## åŒæ­¥åŸè¯­

### `Mutex<T>` - äº’æ–¥é”

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn mutex_example() {
    let data = Arc::new(Mutex::new(vec![1, 2, 3]));
    let mut handles = vec![];

    for i in 0..3 {
        let data = Arc::clone(&data);
        let handle = thread::spawn(move || {
            let mut guard = data.lock().unwrap();
            guard.push(i);
            println!("çº¿ç¨‹ {} æ·»åŠ äº† {}", i, i);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("æœ€ç»ˆæ•°æ®: {:?}", *data.lock().unwrap());
}
```

### `RwLock<T>` - è¯»å†™é”

```rust
use std::sync::{Arc, RwLock};
use std::thread;

fn rwlock_example() {
    let data = Arc::new(RwLock::new(vec![1, 2, 3]));
    let mut handles = vec![];

    // è¯»å–çº¿ç¨‹
    for i in 0..3 {
        let data = Arc::clone(&data);
        let handle = thread::spawn(move || {
            let read_data = data.read().unwrap();
            println!("è¯»å–çº¿ç¨‹ {}: {:?}", i, *read_data);
        });
        handles.push(handle);
    }

    // å†™å…¥çº¿ç¨‹
    let data = Arc::clone(&data);
    let handle = thread::spawn(move || {
        let mut write_data = data.write().unwrap();
        write_data.push(4);
        println!("å†™å…¥çº¿ç¨‹: {:?}", *write_data);
    });
    handles.push(handle);

    for handle in handles {
        handle.join().unwrap();
    }
}
```

### Condvar - æ¡ä»¶å˜é‡

```rust
use std::sync::{Arc, Mutex, Condvar};
use std::thread;

fn condvar_example() {
    let pair = Arc::new((Mutex::new(false), Condvar::new()));
    let pair2 = Arc::clone(&pair);

    // ç­‰å¾…çº¿ç¨‹
    let handle = thread::spawn(move || {
        let (lock, cvar) = &*pair2;
        let mut started = lock.lock().unwrap();
        while !*started {
            started = cvar.wait(started).unwrap();
        }
        println!("æ¡ä»¶æ»¡è¶³ï¼Œç»§ç»­æ‰§è¡Œ");
    });

    // é€šçŸ¥çº¿ç¨‹
    thread::sleep(std::time::Duration::from_secs(1));
    let (lock, cvar) = &*pair;
    let mut started = lock.lock().unwrap();
    *started = true;
    cvar.notify_one();

    handle.join().unwrap();
}
```

## åŸå­æ“ä½œ

### AtomicUsize

```rust
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::Arc;
use std::thread;

fn atomic_example() {
    let counter = Arc::new(AtomicUsize::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            for _ in 0..1000 {
                counter.fetch_add(1, Ordering::SeqCst);
            }
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("æœ€ç»ˆè®¡æ•°: {}", counter.load(Ordering::SeqCst));
}
```

### å†…å­˜é¡ºåº

```rust
use std::sync::atomic::{AtomicBool, AtomicUsize, Ordering};
use std::sync::Arc;
use std::thread;

fn memory_ordering() {
    let flag = Arc::new(AtomicBool::new(false));
    let data = Arc::new(AtomicUsize::new(0));
    let flag2 = Arc::clone(&flag);
    let data2 = Arc::clone(&data);

    // ç”Ÿäº§è€…çº¿ç¨‹
    let producer = thread::spawn(move || {
        data2.store(42, Ordering::Release);
        flag2.store(true, Ordering::Release);
    });

    // æ¶ˆè´¹è€…çº¿ç¨‹
    let consumer = thread::spawn(move || {
        while !flag.load(Ordering::Acquire) {
            thread::yield_now();
        }
        let value = data.load(Ordering::Acquire);
        println!("è¯»å–åˆ°çš„å€¼: {}", value);
    });

    producer.join().unwrap();
    consumer.join().unwrap();
}
```

## é€šé“é€šä¿¡

### mpsc - å¤šç”Ÿäº§è€…å•æ¶ˆè´¹è€…

```rust
use std::sync::mpsc;
use std::thread;

fn mpsc_example() {
    let (tx, rx) = mpsc::channel();
    let mut handles = vec![];

    // å¤šä¸ªç”Ÿäº§è€…
    for i in 0..5 {
        let tx = tx.clone();
        let handle = thread::spawn(move || {
            tx.send(format!("æ¶ˆæ¯æ¥è‡ªçº¿ç¨‹ {}", i)).unwrap();
        });
        handles.push(handle);
    }

    // ç­‰å¾…æ‰€æœ‰ç”Ÿäº§è€…å®Œæˆ
    drop(tx);

    // æ¶ˆè´¹è€…
    for received in rx {
        println!("æ”¶åˆ°: {}", received);
    }

    for handle in handles {
        handle.join().unwrap();
    }
}
```

### åŒæ­¥é€šé“

```rust
use std::sync::mpsc;
use std::thread;

fn sync_channel_example() {
    let (tx, rx) = mpsc::sync_channel(2); // ç¼“å†²åŒºå¤§å°ä¸º2
    let mut handles = vec![];

    // ç”Ÿäº§è€…
    for i in 0..5 {
        let tx = tx.clone();
        let handle = thread::spawn(move || {
            println!("å‘é€æ¶ˆæ¯ {}", i);
            tx.send(i).unwrap();
            println!("æ¶ˆæ¯ {} å·²å‘é€", i);
        });
        handles.push(handle);
    }

    // æ¶ˆè´¹è€…
    let consumer = thread::spawn(move || {
        for received in rx {
            println!("æ”¶åˆ°æ¶ˆæ¯: {}", received);
            thread::sleep(std::time::Duration::from_millis(500));
        }
    });

    for handle in handles {
        handle.join().unwrap();
    }
    consumer.join().unwrap();
}
```

## å¼‚æ­¥ç¼–ç¨‹

### async/await

```rust
use tokio;

async fn async_function() -> String {
    tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
    "å¼‚æ­¥æ“ä½œå®Œæˆ".to_string()
}

async fn async_main() {
    let task1 = async_function();
    let task2 = async_function();

    let (result1, result2) = tokio::join!(task1, task2);

    println!("ç»“æœ1: {}", result1);
    println!("ç»“æœ2: {}", result2);
}

#[tokio::main]
async fn main() {
    async_main().await;
}
```

### å¼‚æ­¥é€šé“

```rust
use tokio::sync::mpsc;

async fn async_channel_example() {
    let (tx, mut rx) = mpsc::channel(100);

    // å¼‚æ­¥ç”Ÿäº§è€…
    let producer = tokio::spawn(async move {
        for i in 0..10 {
            tx.send(i).await.unwrap();
            tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
        }
    });

    // å¼‚æ­¥æ¶ˆè´¹è€…
    let consumer = tokio::spawn(async move {
        while let Some(value) = rx.recv().await {
            println!("æ”¶åˆ°å¼‚æ­¥æ¶ˆæ¯: {}", value);
        }
    });

    producer.await.unwrap();
    consumer.await.unwrap();
}

#[tokio::main]
async fn main() {
    async_channel_example().await;
}
```

## å¹¶å‘æ¨¡å¼

### å·¥ä½œæ± æ¨¡å¼

```rust
use std::sync::{Arc, Mutex};
use std::thread;
use std::collections::VecDeque;

struct ThreadPool {
    workers: Vec<Worker>,
    sender: std::sync::mpsc::Sender<Message>,
}

enum Message {
    NewJob(Job),
    Terminate,
}

type Job = Box<dyn FnOnce() + Send + 'static>;

struct Worker {
    id: usize,
    thread: Option<thread::JoinHandle<()>>,
}

impl ThreadPool {
    fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let (sender, receiver) = std::sync::mpsc::channel();
        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&receiver)));
        }

        ThreadPool { workers, sender }
    }

    fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);
        self.sender.send(Message::NewJob(job)).unwrap();
    }
}

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<std::sync::mpsc::Receiver<Message>>>) -> Worker {
        let thread = thread::spawn(move || loop {
            let message = receiver.lock().unwrap().recv().unwrap();

            match message {
                Message::NewJob(job) => {
                    println!("å·¥ä½œçº¿ç¨‹ {} æ‰§è¡Œä»»åŠ¡", id);
                    job();
                }
                Message::Terminate => {
                    println!("å·¥ä½œçº¿ç¨‹ {} ç»ˆæ­¢", id);
                    break;
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}

impl Drop for ThreadPool {
    fn drop(&mut self) {
        for _ in &self.workers {
            self.sender.send(Message::Terminate).unwrap();
        }

        for worker in &mut self.workers {
            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}

fn thread_pool_example() {
    let pool = ThreadPool::new(4);

    for i in 0..8 {
        pool.execute(move || {
            println!("æ‰§è¡Œä»»åŠ¡ {}", i);
            thread::sleep(std::time::Duration::from_millis(100));
        });
    }
}
```

### ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼

```rust
use std::sync::{Arc, Mutex, Condvar};
use std::thread;
use std::collections::VecDeque;

struct BoundedBuffer<T> {
    buffer: Mutex<VecDeque<T>>,
    capacity: usize,
    not_full: Condvar,
    not_empty: Condvar,
}

impl<T> BoundedBuffer<T> {
    fn new(capacity: usize) -> Self {
        BoundedBuffer {
            buffer: Mutex::new(VecDeque::new()),
            capacity,
            not_full: Condvar::new(),
            not_empty: Condvar::new(),
        }
    }

    fn push(&self, item: T) {
        let mut buffer = self.buffer.lock().unwrap();
        while buffer.len() >= self.capacity {
            buffer = self.not_full.wait(buffer).unwrap();
        }
        buffer.push_back(item);
        self.not_empty.notify_one();
    }

    fn pop(&self) -> T {
        let mut buffer = self.buffer.lock().unwrap();
        while buffer.is_empty() {
            buffer = self.not_empty.wait(buffer).unwrap();
        }
        let item = buffer.pop_front().unwrap();
        self.not_full.notify_one();
        item
    }
}

fn producer_consumer_example() {
    let buffer = Arc::new(BoundedBuffer::new(5));
    let buffer2 = Arc::clone(&buffer);

    // ç”Ÿäº§è€…
    let producer = thread::spawn(move || {
        for i in 0..10 {
            buffer.push(i);
            println!("ç”Ÿäº§è€…: æ”¾å…¥ {}", i);
            thread::sleep(std::time::Duration::from_millis(200));
        }
    });

    // æ¶ˆè´¹è€…
    let consumer = thread::spawn(move || {
        for _ in 0..10 {
            let item = buffer2.pop();
            println!("æ¶ˆè´¹è€…: å–å‡º {}", item);
            thread::sleep(std::time::Duration::from_millis(300));
        }
    });

    producer.join().unwrap();
    consumer.join().unwrap();
}
```

## å¹¶å‘å®‰å…¨æœ€ä½³å®è·µ

### é¿å…æ•°æ®ç«äº‰

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn safe_concurrent_access() {
    let data = Arc::new(Mutex::new(vec![1, 2, 3]));
    let mut handles = vec![];

    for i in 0..3 {
        let data = Arc::clone(&data);
        let handle = thread::spawn(move || {
            let mut guard = data.lock().unwrap();
            guard.push(i);
            // é”åœ¨ä½œç”¨åŸŸç»“æŸæ—¶è‡ªåŠ¨é‡Šæ”¾
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("æœ€ç»ˆæ•°æ®: {:?}", *data.lock().unwrap());
}
```

### é¿å…æ­»é”

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn avoid_deadlock() {
    let lock1 = Arc::new(Mutex::new(1));
    let lock2 = Arc::new(Mutex::new(2));

    let lock1_clone = Arc::clone(&lock1);
    let lock2_clone = Arc::clone(&lock2);

    // çº¿ç¨‹1ï¼šå…ˆè·å–lock1ï¼Œå†è·å–lock2
    let handle1 = thread::spawn(move || {
        let _guard1 = lock1_clone.lock().unwrap();
        thread::sleep(std::time::Duration::from_millis(100));
        let _guard2 = lock2_clone.lock().unwrap();
        println!("çº¿ç¨‹1å®Œæˆ");
    });

    // çº¿ç¨‹2ï¼šå…ˆè·å–lock1ï¼Œå†è·å–lock2ï¼ˆé¿å…æ­»é”ï¼‰
    let handle2 = thread::spawn(move || {
        let _guard1 = lock1.lock().unwrap();
        thread::sleep(std::time::Duration::from_millis(100));
        let _guard2 = lock2.lock().unwrap();
        println!("çº¿ç¨‹2å®Œæˆ");
    });

    handle1.join().unwrap();
    handle2.join().unwrap();
}
```

### æ€§èƒ½ä¼˜åŒ–

```rust
use std::sync::{Arc, RwLock};
use std::thread;

fn performance_optimization() {
    let data = Arc::new(RwLock::new(vec![1, 2, 3, 4, 5]));
    let mut handles = vec![];

    // å¤šä¸ªè¯»å–çº¿ç¨‹
    for i in 0..5 {
        let data = Arc::clone(&data);
        let handle = thread::spawn(move || {
            let read_data = data.read().unwrap();
            println!("è¯»å–çº¿ç¨‹ {}: {:?}", i, *read_data);
        });
        handles.push(handle);
    }

    // ä¸€ä¸ªå†™å…¥çº¿ç¨‹
    let data = Arc::clone(&data);
    let handle = thread::spawn(move || {
        let mut write_data = data.write().unwrap();
        write_data.push(6);
        println!("å†™å…¥çº¿ç¨‹: {:?}", *write_data);
    });
    handles.push(handle);

    for handle in handles {
        handle.join().unwrap();
    }
}
```

## æ€»ç»“

Rustçš„å¹¶å‘ç¼–ç¨‹æ¨¡å‹é€šè¿‡æ‰€æœ‰æƒç³»ç»Ÿã€ç±»å‹å®‰å…¨å’Œç²¾å¿ƒè®¾è®¡çš„åŒæ­¥åŸè¯­ï¼Œæä¾›äº†å¼ºå¤§è€Œå®‰å…¨çš„å¹¶å‘ç¼–ç¨‹èƒ½åŠ›ã€‚

---

**ç›¸å…³é“¾æ¥ï¼š**

- [10.1.1-æ‰€æœ‰æƒç³»ç»Ÿæ·±åŒ–](10.1.1-æ‰€æœ‰æƒç³»ç»Ÿæ·±åŒ–.md)
- [10.1.2-ç”Ÿå‘½å‘¨æœŸæ·±åŒ–](10.1.2-ç”Ÿå‘½å‘¨æœŸæ·±åŒ–.md)
- [10.1.3-å€Ÿç”¨æ£€æŸ¥æ·±åŒ–](10.1.3-å€Ÿç”¨æ£€æŸ¥æ·±åŒ–.md)
- [10.1.4-é›¶æˆæœ¬æŠ½è±¡æ·±åŒ–](10.1.4-é›¶æˆæœ¬æŠ½è±¡æ·±åŒ–.md)
- [10.1.5-å†…å­˜å®‰å…¨æ·±åŒ–](10.1.5-å†…å­˜å®‰å…¨æ·±åŒ–.md)
