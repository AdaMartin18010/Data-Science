# 10.1.1 RuståŸºç¡€ç†è®ºæ·±åŒ–

## ğŸ“‘ ç›®å½•

- [10.1.1 RuståŸºç¡€ç†è®ºæ·±åŒ–](#1011-ruståŸºç¡€ç†è®ºæ·±åŒ–)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
- [ç†è®ºåŸºç¡€](#ç†è®ºåŸºç¡€)
  - [Rustè¯­è¨€æ¦‚è¿°](#rustè¯­è¨€æ¦‚è¿°)
  - [æ ¸å¿ƒç‰¹æ€§](#æ ¸å¿ƒç‰¹æ€§)
- [æ‰€æœ‰æƒç³»ç»Ÿ](#æ‰€æœ‰æƒç³»ç»Ÿ)
  - [æ‰€æœ‰æƒè§„åˆ™](#æ‰€æœ‰æƒè§„åˆ™)
  - [å€Ÿç”¨å’Œå¼•ç”¨](#å€Ÿç”¨å’Œå¼•ç”¨)
  - [åˆ‡ç‰‡](#åˆ‡ç‰‡)
- [ç”Ÿå‘½å‘¨æœŸ](#ç”Ÿå‘½å‘¨æœŸ)
  - [ç”Ÿå‘½å‘¨æœŸæ³¨è§£](#ç”Ÿå‘½å‘¨æœŸæ³¨è§£)
  - [ç”Ÿå‘½å‘¨æœŸé«˜çº§ç”¨æ³•](#ç”Ÿå‘½å‘¨æœŸé«˜çº§ç”¨æ³•)
- [é”™è¯¯å¤„ç†](#é”™è¯¯å¤„ç†)
  - [Resultç±»å‹](#resultç±»å‹)
  - [Optionç±»å‹](#optionç±»å‹)
- [å¹¶å‘ç¼–ç¨‹](#å¹¶å‘ç¼–ç¨‹)
  - [çº¿ç¨‹](#çº¿ç¨‹)
  - [æ¶ˆæ¯ä¼ é€’](#æ¶ˆæ¯ä¼ é€’)
  - [å…±äº«çŠ¶æ€](#å…±äº«çŠ¶æ€)
- [æ™ºèƒ½æŒ‡é’ˆ](#æ™ºèƒ½æŒ‡é’ˆ)
  - [Box](#box)
  - [Rc](#rc)
  - [Arc](#arc)
- [æ¨¡å¼åŒ¹é…](#æ¨¡å¼åŒ¹é…)
  - [åŸºæœ¬æ¨¡å¼](#åŸºæœ¬æ¨¡å¼)
  - [é«˜çº§æ¨¡å¼](#é«˜çº§æ¨¡å¼)
- [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
  - [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
  - [*é”™è¯¯å¤„ç†*](#é”™è¯¯å¤„ç†)
  - [å¹¶å‘å®‰å…¨](#å¹¶å‘å®‰å…¨)
  - [ä»£ç ç»„ç»‡](#ä»£ç ç»„ç»‡)
- [æ€»ç»“](#æ€»ç»“)
---


## ç†è®ºåŸºç¡€

### Rustè¯­è¨€æ¦‚è¿°

Rustæ˜¯ä¸€ç§ç³»ç»Ÿç¼–ç¨‹è¯­è¨€ï¼Œä¸“æ³¨äºå†…å­˜å®‰å…¨å’Œå¹¶å‘å®‰å…¨ï¼š

- **å†…å­˜å®‰å…¨**ï¼šé€šè¿‡æ‰€æœ‰æƒç³»ç»Ÿé˜²æ­¢å†…å­˜æ³„æ¼å’Œæ•°æ®ç«äº‰
- **é›¶æˆæœ¬æŠ½è±¡**ï¼šé«˜çº§æŠ½è±¡ä¸å¸¦æ¥è¿è¡Œæ—¶å¼€é”€
- **å¹¶å‘å®‰å…¨**ï¼šç¼–è¯‘æ—¶ä¿è¯çº¿ç¨‹å®‰å…¨
- **æ€§èƒ½ä¼˜å…ˆ**ï¼šæ¥è¿‘C/C++çš„æ€§èƒ½è¡¨ç°

### æ ¸å¿ƒç‰¹æ€§

- **æ‰€æœ‰æƒç³»ç»Ÿ**ï¼šç¼–è¯‘æ—¶å†…å­˜ç®¡ç†
- **å€Ÿç”¨æ£€æŸ¥**ï¼šé˜²æ­¢æ•°æ®ç«äº‰
- **ç”Ÿå‘½å‘¨æœŸ**ï¼šç®¡ç†å¼•ç”¨çš„æœ‰æ•ˆæ€§
- **æ¨¡å¼åŒ¹é…**ï¼šå¼ºå¤§çš„æ§åˆ¶æµå·¥å…·

## æ‰€æœ‰æƒç³»ç»Ÿ

### æ‰€æœ‰æƒè§„åˆ™

```rust
// æ‰€æœ‰æƒåŸºæœ¬æ¦‚å¿µ
fn main() {
    // 1. æ¯ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…
    let s1 = String::from("hello");

    // 2. åŒä¸€æ—¶é—´åªèƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…
    let s2 = s1; // s1çš„æ‰€æœ‰æƒç§»åŠ¨åˆ°s2ï¼Œs1ä¸å†æœ‰æ•ˆ
    // println!("{}", s1); // ç¼–è¯‘é”™è¯¯ï¼šs1å·²ç»è¢«ç§»åŠ¨

    // 3. å½“æ‰€æœ‰è€…ç¦»å¼€ä½œç”¨åŸŸï¼Œå€¼è¢«ä¸¢å¼ƒ
    {
        let s3 = String::from("world");
        // s3åœ¨è¿™é‡Œæœ‰æ•ˆ
    } // s3ç¦»å¼€ä½œç”¨åŸŸï¼Œè¢«ä¸¢å¼ƒ

    // 4. å‡½æ•°å‚æ•°çš„æ‰€æœ‰æƒ
    let s4 = String::from("test");
    takes_ownership(s4); // s4çš„æ‰€æœ‰æƒç§»åŠ¨åˆ°å‡½æ•°
    // println!("{}", s4); // ç¼–è¯‘é”™è¯¯ï¼šs4å·²ç»è¢«ç§»åŠ¨

    // 5. è¿”å›å€¼è½¬ç§»æ‰€æœ‰æƒ
    let s5 = gives_ownership(); // å‡½æ•°è¿”å›å€¼è·å¾—æ‰€æœ‰æƒ
    println!("{}", s5);
}

fn takes_ownership(some_string: String) {
    println!("{}", some_string);
} // some_stringç¦»å¼€ä½œç”¨åŸŸï¼Œè¢«ä¸¢å¼ƒ

fn gives_ownership() -> String {
    let some_string = String::from("hello");
    some_string // è¿”å›some_stringï¼Œæ‰€æœ‰æƒè½¬ç§»ç»™è°ƒç”¨è€…
}
```

### å€Ÿç”¨å’Œå¼•ç”¨

```rust
// å€Ÿç”¨ç³»ç»Ÿ
fn main() {
    let mut s1 = String::from("hello");

    // ä¸å¯å˜å€Ÿç”¨
    let len = calculate_length(&s1);
    println!("Length of '{}' is {}.", s1, len);

    // å¯å˜å€Ÿç”¨
    change(&mut s1);
    println!("Changed string: {}", s1);

    // å€Ÿç”¨è§„åˆ™ç¤ºä¾‹
    let mut s2 = String::from("hello");

    let r1 = &s2; // ä¸å¯å˜å€Ÿç”¨
    let r2 = &s2; // å¦ä¸€ä¸ªä¸å¯å˜å€Ÿç”¨
    // let r3 = &mut s2; // ç¼–è¯‘é”™è¯¯ï¼šä¸èƒ½åŒæ—¶æœ‰å¯å˜å’Œä¸å¯å˜å€Ÿç”¨

    println!("{} and {}", r1, r2);
    // r1å’Œr2åœ¨è¿™é‡Œä¸å†ä½¿ç”¨

    let r3 = &mut s2; // ç°åœ¨å¯ä»¥åˆ›å»ºå¯å˜å€Ÿç”¨
    println!("{}", r3);
}

fn calculate_length(s: &String) -> usize {
    s.len()
} // sç¦»å¼€ä½œç”¨åŸŸï¼Œä½†å› ä¸ºå®ƒä¸æ‹¥æœ‰æ•°æ®ï¼Œæ‰€ä»¥ä»€ä¹ˆéƒ½ä¸ä¼šå‘ç”Ÿ

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```

### åˆ‡ç‰‡

```rust
// åˆ‡ç‰‡ç±»å‹
fn main() {
    let s = String::from("hello world");

    let hello = &s[0..5]; // æˆ–è€… &s[..5]
    let world = &s[6..11]; // æˆ–è€… &s[6..]

    println!("{} {}", hello, world);

    // å­—ç¬¦ä¸²åˆ‡ç‰‡
    let s = String::from("hello world");
    let word = first_word(&s);
    println!("First word: {}", word);

    // æ•°ç»„åˆ‡ç‰‡
    let a = [1, 2, 3, 4, 5];
    let slice = &a[1..3];
    println!("Slice: {:?}", slice);
}

fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```

## ç”Ÿå‘½å‘¨æœŸ

### ç”Ÿå‘½å‘¨æœŸæ³¨è§£

```rust
// ç”Ÿå‘½å‘¨æœŸåŸºç¡€
fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}

// ç”Ÿå‘½å‘¨æœŸæ³¨è§£
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

// ç»“æ„ä½“ä¸­çš„ç”Ÿå‘½å‘¨æœŸ
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().unwrap();
    let i = ImportantExcerpt {
        part: first_sentence,
    };
    println!("{}", i.part);
}

// ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™
fn first_word(s: &str) -> &str {
    // ç¼–è¯‘å™¨è‡ªåŠ¨æ¨æ–­ç”Ÿå‘½å‘¨æœŸ
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}

// é™æ€ç”Ÿå‘½å‘¨æœŸ
fn main() {
    let s: &'static str = "I have a static lifetime.";
    println!("{}", s);
}
```

### ç”Ÿå‘½å‘¨æœŸé«˜çº§ç”¨æ³•

```rust
// ç”Ÿå‘½å‘¨æœŸçº¦æŸ
use std::fmt::Display;

fn longest_with_an_announcement<'a, T>(
    x: &'a str,
    y: &'a str,
    ann: T,
) -> &'a str
where
    T: Display,
{
    println!("Announcement! {}", ann);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

// ç”Ÿå‘½å‘¨æœŸå‚æ•°
struct Context<'a> {
    data: &'a str,
}

struct Parser<'a> {
    context: &'a Context<'a>,
}

impl<'a> Parser<'a> {
    fn new(context: &'a Context<'a>) -> Self {
        Parser { context }
    }

    fn parse(&self) -> &'a str {
        self.context.data
    }
}

// ç”Ÿå‘½å‘¨æœŸå­ç±»å‹
fn main() {
    let mut data = vec![1, 2, 3, 4];
    let x = &mut data[0];
    let y = &mut data[1];

    // è¿™é‡Œxå’Œyæœ‰ä¸åŒçš„ç”Ÿå‘½å‘¨æœŸ
    *x += 1;
    *y += 1;
}
```

## é”™è¯¯å¤„ç†

### Resultç±»å‹

```rust
// ResultåŸºç¡€ç”¨æ³•
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let mut f = File::open("hello.txt")?;
    let mut s = String::new();
    f.read_to_string(&mut s)?;
    Ok(s)
}

// è‡ªå®šä¹‰é”™è¯¯ç±»å‹
#[derive(Debug)]
enum CustomError {
    IoError(std::io::Error),
    ParseError(std::num::ParseIntError),
}

impl From<std::io::Error> for CustomError {
    fn from(err: std::io::Error) -> CustomError {
        CustomError::IoError(err)
    }
}

impl From<std::num::ParseIntError> for CustomError {
    fn from(err: std::num::ParseIntError) -> CustomError {
        CustomError::ParseError(err)
    }
}

fn read_and_parse() -> Result<i32, CustomError> {
    let mut s = String::new();
    std::io::stdin().read_line(&mut s)?;
    let num: i32 = s.trim().parse()?;
    Ok(num)
}

// é”™è¯¯å¤„ç†æ¨¡å¼
fn handle_errors() {
    // ä½¿ç”¨match
    let result = read_and_parse();
    match result {
        Ok(num) => println!("Parsed number: {}", num),
        Err(e) => println!("Error: {:?}", e),
    }

    // ä½¿ç”¨unwrap
    let num = read_and_parse().unwrap();
    println!("Number: {}", num);

    // ä½¿ç”¨expect
    let num = read_and_parse().expect("Failed to parse number");
    println!("Number: {}", num);

    // ä½¿ç”¨?æ“ä½œç¬¦
    fn process_data() -> Result<(), CustomError> {
        let num = read_and_parse()?;
        println!("Processing number: {}", num);
        Ok(())
    }
}
```

### Optionç±»å‹

```rust
// OptionåŸºç¡€ç”¨æ³•
fn find_item(items: &[i32], target: i32) -> Option<usize> {
    for (index, &item) in items.iter().enumerate() {
        if item == target {
            return Some(index);
        }
    }
    None
}

fn main() {
    let items = vec![1, 2, 3, 4, 5];

    // ä½¿ç”¨match
    match find_item(&items, 3) {
        Some(index) => println!("Found at index: {}", index),
        None => println!("Item not found"),
    }

    // ä½¿ç”¨if let
    if let Some(index) = find_item(&items, 3) {
        println!("Found at index: {}", index);
    } else {
        println!("Item not found");
    }

    // ä½¿ç”¨unwrap
    let index = find_item(&items, 3).unwrap();
    println!("Found at index: {}", index);

    // ä½¿ç”¨unwrap_or
    let index = find_item(&items, 10).unwrap_or(0);
    println!("Index: {}", index);
}

// Optioné«˜çº§ç”¨æ³•
fn divide(a: f64, b: f64) -> Option<f64> {
    if b == 0.0 {
        None
    } else {
        Some(a / b)
    }
}

fn main() {
    let result = divide(10.0, 2.0);
    println!("Result: {:?}", result);

    let result = divide(10.0, 0.0);
    println!("Result: {:?}", result);

    // ä½¿ç”¨map
    let result = divide(10.0, 2.0).map(|x| x * 2.0);
    println!("Doubled result: {:?}", result);

    // ä½¿ç”¨and_then
    let result = divide(10.0, 2.0).and_then(|x| divide(x, 2.0));
    println!("Chained result: {:?}", result);
}
```

## å¹¶å‘ç¼–ç¨‹

### çº¿ç¨‹

```rust
use std::thread;
use std::time::Duration;

fn main() {
    // åŸºæœ¬çº¿ç¨‹åˆ›å»º
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();

    // ä½¿ç”¨moveé—­åŒ…
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!("Here's a vector: {:?}", v);
    });

    handle.join().unwrap();
}
```

### æ¶ˆæ¯ä¼ é€’

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
        // println!("val is {}", val); // ç¼–è¯‘é”™è¯¯ï¼švalå·²ç»è¢«å‘é€
    });

    let received = rx.recv().unwrap();
    println!("Got: {}", received);

    // å¤šä¸ªå‘é€è€…
    let (tx, rx) = mpsc::channel();

    let tx1 = tx.clone();
    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx1.send(val).unwrap();
            thread::sleep(Duration::from_millis(1));
        }
    });

    thread::spawn(move || {
        let vals = vec![
            String::from("more"),
            String::from("messages"),
            String::from("for"),
            String::from("you"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_millis(1));
        }
    });

    for received in rx {
        println!("Got: {}", received);
    }
}
```

### å…±äº«çŠ¶æ€

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    // ä½¿ç”¨Mutex
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());

    // ä½¿ç”¨RwLock
    use std::sync::RwLock;

    let data = Arc::new(RwLock::new(vec![1, 2, 3, 4, 5]));
    let mut handles = vec![];

    // è¯»å–çº¿ç¨‹
    for i in 0..3 {
        let data = Arc::clone(&data);
        let handle = thread::spawn(move || {
            let data = data.read().unwrap();
            println!("Reader {}: {:?}", i, *data);
        });
        handles.push(handle);
    }

    // å†™å…¥çº¿ç¨‹
    let data = Arc::clone(&data);
    let handle = thread::spawn(move || {
        let mut data = data.write().unwrap();
        data.push(6);
        println!("Writer: {:?}", *data);
    });
    handles.push(handle);

    for handle in handles {
        handle.join().unwrap();
    }
}
```

## æ™ºèƒ½æŒ‡é’ˆ

### Box

```rust
// Boxæ™ºèƒ½æŒ‡é’ˆ
fn main() {
    // åœ¨å †ä¸Šå­˜å‚¨æ•°æ®
    let b = Box::new(5);
    println!("b = {}", b);

    // é€’å½’æ•°æ®ç»“æ„
    #[derive(Debug)]
    enum List {
        Cons(i32, Box<List>),
        Nil,
    }

    let list = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));
    println!("{:?}", list);

    // å®ç°Deref trait
    use std::ops::Deref;

    struct MyBox<T>(T);

    impl<T> MyBox<T> {
        fn new(x: T) -> MyBox<T> {
            MyBox(x)
        }
    }

    impl<T> Deref for MyBox<T> {
        type Target = T;

        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```

### Rc

```rust
// Rcæ™ºèƒ½æŒ‡é’ˆ
use std::rc::Rc;

fn main() {
    // å…±äº«æ‰€æœ‰æƒ
    let a = Rc::new(List::Cons(5, Rc::new(List::Cons(10, Rc::new(List::Nil)))));
    println!("count after creating a = {}", Rc::strong_count(&a));

    let b = List::Cons(3, Rc::clone(&a));
    println!("count after creating b = {}", Rc::strong_count(&a));

    {
        let c = List::Cons(4, Rc::clone(&a));
        println!("count after creating c = {}", Rc::strong_count(&a));
    }
    println!("count after c goes out of scope = {}", Rc::strong_count(&a));

    #[derive(Debug)]
    enum List {
        Cons(i32, Rc<List>),
        Nil,
    }
}

// å¼±å¼•ç”¨
use std::rc::{Rc, Weak};
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell<Weak<Node>>,
    children: RefCell<Vec<Rc<Node>>>,
}

fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&branch);

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
}
```

### Arc

```rust
// Arcæ™ºèƒ½æŒ‡é’ˆ
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
```

## æ¨¡å¼åŒ¹é…

### åŸºæœ¬æ¨¡å¼

```rust
// æ¨¡å¼åŒ¹é…åŸºç¡€
fn main() {
    let x = 1;

    match x {
        1 => println!("one"),
        2 => println!("two"),
        3 => println!("three"),
        _ => println!("anything"),
    }

    // ç»‘å®šå€¼
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) => println!("Got 50"),
        Some(y) => println!("Matched, y = {:?}", y),
        _ => println!("Default case, x = {:?}", x),
    }

    println!("at the end: x = {:?}, y = {:?}", x, y);

    // å¤šé‡æ¨¡å¼
    let x = 1;

    match x {
        1 | 2 | 3 => println!("one, two, or three"),
        _ => println!("anything"),
    }

    // èŒƒå›´æ¨¡å¼
    let x = 5;

    match x {
        1..=5 => println!("one through five"),
        _ => println!("something else"),
    }

    // è§£æ„
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } => println!("On the x axis at {}", x),
        Point { x: 0, y } => println!("On the y axis at {}", y),
        Point { x, y } => println!("On neither axis: ({}, {})", x, y),
    }
}

struct Point {
    x: i32,
    y: i32,
}
```

### é«˜çº§æ¨¡å¼

```rust
// é«˜çº§æ¨¡å¼åŒ¹é…
fn main() {
    // å®ˆå«
    let num = Some(4);

    match num {
        Some(x) if x < 5 => println!("less than five: {}", x),
        Some(x) => println!("{}", x),
        None => (),
    }

    // @ç»‘å®š
    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello { id: id_variable @ 3..=7 } => {
            println!("Found an id in range: {}", id_variable)
        }
        Message::Hello { id: 10..=12 } => {
            println!("Found an id in another range")
        }
        Message::Hello { id } => println!("Found some other id: {}", id),
    }

    // å¿½ç•¥å€¼
    let s = Some(String::from("Hello!"));

    if let Some(_) = s {
        println!("found a string");
    }

    // å¿½ç•¥å¤šä¸ªå€¼
    let origin = Point { x: 0, y: 0 };

    match origin {
        Point { x, .. } => println!("x is {}", x),
    }

    // æ¡ä»¶å¿½ç•¥
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, _, third, _, fifth) => {
            println!("Some numbers: {}, {}, {}", first, third, fifth)
        }
    }
}

enum Message {
    Hello { id: i32 },
}
```

## æœ€ä½³å®è·µ

### æ€§èƒ½ä¼˜åŒ–

1. **é›¶æˆæœ¬æŠ½è±¡**ï¼šä½¿ç”¨é«˜çº§æŠ½è±¡ä¸å¸¦æ¥æ€§èƒ½æŸå¤±
2. **å†…å­˜å¸ƒå±€**ï¼šåˆç†è®¾è®¡æ•°æ®ç»“æ„çš„å†…å­˜å¸ƒå±€
3. **è¿­ä»£å™¨**ï¼šä½¿ç”¨è¿­ä»£å™¨è€Œä¸æ˜¯æ‰‹åŠ¨å¾ªç¯
4. **ç¼–è¯‘ä¼˜åŒ–**ï¼šåˆ©ç”¨ç¼–è¯‘å™¨çš„ä¼˜åŒ–èƒ½åŠ›

### *é”™è¯¯å¤„ç†*

1. **Resultç±»å‹**ï¼šä½¿ç”¨Resultå¤„ç†å¯æ¢å¤é”™è¯¯
2. **Optionç±»å‹**ï¼šä½¿ç”¨Optionå¤„ç†å¯é€‰å€¼
3. **è‡ªå®šä¹‰é”™è¯¯**ï¼šä¸ºç‰¹å®šé¢†åŸŸå®šä¹‰é”™è¯¯ç±»å‹
4. **é”™è¯¯ä¼ æ’­**ï¼šä½¿ç”¨?æ“ä½œç¬¦ä¼ æ’­é”™è¯¯

### å¹¶å‘å®‰å…¨

1. **æ¶ˆæ¯ä¼ é€’**ï¼šä¼˜å…ˆä½¿ç”¨æ¶ˆæ¯ä¼ é€’è€Œéå…±äº«çŠ¶æ€
2. **æ™ºèƒ½æŒ‡é’ˆ**ï¼šä½¿ç”¨Arcå’ŒMutexç®¡ç†å…±äº«çŠ¶æ€
3. **ç”Ÿå‘½å‘¨æœŸ**ï¼šç¡®ä¿å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸæ­£ç¡®
4. **æ•°æ®ç«äº‰**ï¼šç¼–è¯‘æ—¶é˜²æ­¢æ•°æ®ç«äº‰

### ä»£ç ç»„ç»‡

1. **æ¨¡å—ç³»ç»Ÿ**ï¼šåˆç†ç»„ç»‡ä»£ç æ¨¡å—
2. **traitç³»ç»Ÿ**ï¼šä½¿ç”¨traitå®šä¹‰æ¥å£
3. **æ³›å‹ç¼–ç¨‹**ï¼šä½¿ç”¨æ³›å‹æé«˜ä»£ç å¤ç”¨æ€§
4. **æ–‡æ¡£æ³¨é‡Š**ï¼šä¸ºå…¬å…±APIç¼–å†™æ–‡æ¡£

## æ€»ç»“

RuståŸºç¡€ç†è®ºä¸ºæ„å»ºå®‰å…¨ã€é«˜æ•ˆçš„ç³»ç»Ÿè½¯ä»¶æä¾›äº†å¼ºå¤§çš„å·¥å…·ã€‚é€šè¿‡æ‰€æœ‰æƒç³»ç»Ÿã€ç”Ÿå‘½å‘¨æœŸç®¡ç†ã€å¹¶å‘ç¼–ç¨‹å’Œæ¨¡å¼åŒ¹é…ç­‰ç‰¹æ€§ï¼Œå¯ä»¥ç¼–å†™å‡ºæ—¢å®‰å…¨åˆé«˜æ•ˆçš„ä»£ç ã€‚
