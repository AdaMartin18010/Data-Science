# ç¼–ç¨‹è¯­è¨€æ·±åŒ–å®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [ç¼–ç¨‹è¯­è¨€æ·±åŒ–å®è·µæ¡ˆä¾‹](#ç¼–ç¨‹è¯­è¨€æ·±åŒ–å®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
- [1. Rustè¯­è¨€å®è·µæ¡ˆä¾‹](#1-rustè¯­è¨€å®è·µæ¡ˆä¾‹)
  - [1.1. å†…å­˜å®‰å…¨ä¸æ‰€æœ‰æƒç³»ç»Ÿ](#11-å†…å­˜å®‰å…¨ä¸æ‰€æœ‰æƒç³»ç»Ÿ)
  - [1.2. é”™è¯¯å¤„ç†ä¸Resultç±»å‹](#12-é”™è¯¯å¤„ç†ä¸resultç±»å‹)
  - [1.3. å¹¶å‘ç¼–ç¨‹](#13-å¹¶å‘ç¼–ç¨‹)
- [2. ç¼–ç¨‹èŒƒå¼å®è·µæ¡ˆä¾‹](#2-ç¼–ç¨‹èŒƒå¼å®è·µæ¡ˆä¾‹)
  - [2.1. å‡½æ•°å¼ç¼–ç¨‹](#21-å‡½æ•°å¼ç¼–ç¨‹)
- [3. é¢å‘å¯¹è±¡ç¼–ç¨‹](#3-é¢å‘å¯¹è±¡ç¼–ç¨‹)
- [4. å“åº”å¼ç¼–ç¨‹](#4-å“åº”å¼ç¼–ç¨‹)
- [5. è¯­è¨€æ¯”è¾ƒå®è·µæ¡ˆä¾‹](#5-è¯­è¨€æ¯”è¾ƒå®è·µæ¡ˆä¾‹)
  - [5.1. æ€§èƒ½æ¯”è¾ƒ](#51-æ€§èƒ½æ¯”è¾ƒ)
- [6. å†…å­˜ä½¿ç”¨æ¯”è¾ƒ](#6-å†…å­˜ä½¿ç”¨æ¯”è¾ƒ)
- [7. å¹¶å‘æ€§èƒ½æ¯”è¾ƒ](#7-å¹¶å‘æ€§èƒ½æ¯”è¾ƒ)
---


## 1. Rustè¯­è¨€å®è·µæ¡ˆä¾‹

### 1.1. å†…å­˜å®‰å…¨ä¸æ‰€æœ‰æƒç³»ç»Ÿ

```rust
// Rustæ‰€æœ‰æƒç³»ç»Ÿç¤ºä¾‹
fn main() {
    // 1. åŸºæœ¬æ‰€æœ‰æƒè§„åˆ™
    let s1 = String::from("hello");
    let s2 = s1; // s1çš„æ‰€æœ‰æƒç§»åŠ¨åˆ°s2ï¼Œs1ä¸å†æœ‰æ•ˆ
    // println!("{}", s1); // ç¼–è¯‘é”™è¯¯ï¼šs1å·²è¢«ç§»åŠ¨

    // 2. å€Ÿç”¨ï¼ˆå¼•ç”¨ï¼‰
    let s3 = String::from("world");
    let len = calculate_length(&s3); // å€Ÿç”¨s3
    println!("'{}' çš„é•¿åº¦æ˜¯ {}", s3, len); // s3ä»ç„¶æœ‰æ•ˆ

    // 3. å¯å˜å€Ÿç”¨
    let mut s4 = String::from("hello");
    change(&mut s4);
    println!("ä¿®æ”¹å: {}", s4);

    // 4. åˆ‡ç‰‡
    let s5 = String::from("hello world");
    let hello = &s5[0..5];
    let world = &s5[6..11];
    println!("{} {}", hello, world);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}

fn change(some_string: &mut String) {
    some_string.push_str(" world");
}
```

### 1.2. é”™è¯¯å¤„ç†ä¸Resultç±»å‹

```rust
use std::fs::File;
use std::io::{self, Read};

// è‡ªå®šä¹‰é”™è¯¯ç±»å‹
#[derive(Debug)]
enum CustomError {
    IoError(io::Error),
    ParseError(String),
}

impl From<io::Error> for CustomError {
    fn from(err: io::Error) -> CustomError {
        CustomError::IoError(err)
    }
}

// ä½¿ç”¨Resultè¿›è¡Œé”™è¯¯å¤„ç†
fn read_username_from_file(filename: &str) -> Result<String, CustomError> {
    let mut file = File::open(filename)?;
    let mut username = String::new();
    file.read_to_string(&mut username)?;

    if username.trim().is_empty() {
        return Err(CustomError::ParseError("ç”¨æˆ·åä¸èƒ½ä¸ºç©º".to_string()));
    }

    Ok(username)
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    match read_username_from_file("username.txt") {
        Ok(username) => println!("ç”¨æˆ·å: {}", username),
        Err(e) => match e {
            CustomError::IoError(io_err) => println!("IOé”™è¯¯: {}", io_err),
            CustomError::ParseError(msg) => println!("è§£æé”™è¯¯: {}", msg),
        }
    }
}
```

### 1.3. å¹¶å‘ç¼–ç¨‹

```rust
use std::thread;
use std::sync::{Arc, Mutex};
use std::time::Duration;

// çº¿ç¨‹å®‰å…¨çš„æ•°æ®ç»“æ„
struct SharedCounter {
    value: Mutex<i32>,
}

impl SharedCounter {
    fn new() -> Self {
        SharedCounter {
            value: Mutex::new(0),
        }
    }

    fn increment(&self) {
        let mut val = self.value.lock().unwrap();
        *val += 1;
    }

    fn get_value(&self) -> i32 {
        *self.value.lock().unwrap()
    }
}

// å¤šçº¿ç¨‹ç¤ºä¾‹
fn main() {
    let counter = Arc::new(SharedCounter::new());
    let mut handles = vec![];

    // åˆ›å»ºå¤šä¸ªçº¿ç¨‹
    for i in 0..5 {
        let counter_clone = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            for _ in 0..1000 {
                counter_clone.increment();
            }
            println!("çº¿ç¨‹ {} å®Œæˆ", i);
        });
        handles.push(handle);
    }

    // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
    for handle in handles {
        handle.join().unwrap();
    }

    println!("æœ€ç»ˆè®¡æ•°: {}", counter.get_value());
}
```

## 2. ç¼–ç¨‹èŒƒå¼å®è·µæ¡ˆä¾‹

### 2.1. å‡½æ•°å¼ç¼–ç¨‹

```python
# å‡½æ•°å¼ç¼–ç¨‹ç¤ºä¾‹
from functools import reduce
from typing import List, Callable

# çº¯å‡½æ•°
def add(a: int, b: int) -> int:
    return a + b

def multiply(a: int, b: int) -> int:
    return a * b

# é«˜é˜¶å‡½æ•°
def apply_operation(func: Callable, a: int, b: int) -> int:
    return func(a, b)

# å‡½æ•°ç»„åˆ
def compose(*functions):
    def inner(arg):
        result = arg
        for f in reversed(functions):
            result = f(result)
        return result
    return inner

# ä¸å¯å˜æ•°æ®ç»“æ„
class ImmutableList:
    def __init__(self, items: List):
        self._items = tuple(items)  # ä½¿ç”¨tupleç¡®ä¿ä¸å¯å˜

    def map(self, func: Callable):
        return ImmutableList([func(item) for item in self._items])

    def filter(self, predicate: Callable):
        return ImmutableList([item for item in self._items if predicate(item)])

    def reduce(self, func: Callable, initial):
        return reduce(func, self._items, initial)

    def to_list(self):
        return list(self._items)

# ä½¿ç”¨ç¤ºä¾‹
numbers = ImmutableList([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

# å‡½æ•°å¼æ“ä½œé“¾
result = (numbers
    .filter(lambda x: x % 2 == 0)  # è¿‡æ»¤å¶æ•°
    .map(lambda x: x * x)          # å¹³æ–¹
    .reduce(lambda acc, x: acc + x, 0))  # æ±‚å’Œ

print(f"å¶æ•°çš„å¹³æ–¹å’Œ: {result}")

# å‡½æ•°ç»„åˆ
def double(x): return x * 2
def add_one(x): return x + 1
def square(x): return x ** 2

composed = compose(square, add_one, double)
print(f"ç»„åˆå‡½æ•° f(x) = (2x + 1)^2, f(3) = {composed(3)}")
```

## 3. é¢å‘å¯¹è±¡ç¼–ç¨‹

```python
# é¢å‘å¯¹è±¡ç¼–ç¨‹ç¤ºä¾‹
from abc import ABC, abstractmethod
from typing import List, Dict

# æŠ½è±¡åŸºç±»
class Shape(ABC):
    def __init__(self, color: str):
        self.color = color

    @abstractmethod
    def area(self) -> float:
        pass

    @abstractmethod
    def perimeter(self) -> float:
        pass

    def describe(self) -> str:
        return f"{self.color} {self.__class__.__name__}"

# å…·ä½“ç±»
class Circle(Shape):
    def __init__(self, color: str, radius: float):
        super().__init__(color)
        self.radius = radius

    def area(self) -> float:
        import math
        return math.pi * self.radius ** 2

    def perimeter(self) -> float:
        import math
        return 2 * math.pi * self.radius

class Rectangle(Shape):
    def __init__(self, color: str, width: float, height: float):
        super().__init__(color)
        self.width = width
        self.height = height

    def area(self) -> float:
        return self.width * self.height

    def perimeter(self) -> float:
        return 2 * (self.width + self.height)

# å·¥å‚æ¨¡å¼
class ShapeFactory:
    @staticmethod
    def create_shape(shape_type: str, **kwargs) -> Shape:
        if shape_type.lower() == "circle":
            return Circle(kwargs.get("color", "red"), kwargs.get("radius", 1.0))
        elif shape_type.lower() == "rectangle":
            return Rectangle(kwargs.get("color", "blue"),
                           kwargs.get("width", 1.0),
                           kwargs.get("height", 1.0))
        else:
            raise ValueError(f"æœªçŸ¥çš„å½¢çŠ¶ç±»å‹: {shape_type}")

# ä½¿ç”¨ç¤ºä¾‹
shapes = [
    ShapeFactory.create_shape("circle", color="red", radius=5.0),
    ShapeFactory.create_shape("rectangle", color="blue", width=4.0, height=6.0)
]

for shape in shapes:
    print(f"{shape.describe()}: é¢ç§¯={shape.area():.2f}, å‘¨é•¿={shape.perimeter():.2f}")
```

## 4. å“åº”å¼ç¼–ç¨‹

```python
# ç®€å•çš„å“åº”å¼ç¼–ç¨‹ç¤ºä¾‹
from typing import List, Callable
from dataclasses import dataclass
from datetime import datetime

@dataclass
class Event:
    timestamp: datetime
    data: any

class Observable:
    def __init__(self):
        self._observers: List[Callable] = []

    def subscribe(self, observer: Callable):
        self._observers.append(observer)

    def unsubscribe(self, observer: Callable):
        if observer in self._observers:
            self._observers.remove(observer)

    def notify(self, event: Event):
        for observer in self._observers:
            observer(event)

class DataStream(Observable):
    def __init__(self):
        super().__init__()
        self._data = []

    def add_data(self, data: any):
        event = Event(datetime.now(), data)
        self._data.append(data)
        self.notify(event)

    def get_data(self):
        return self._data.copy()

# å“åº”å¼æ“ä½œç¬¦
class ReactiveOperators:
    @staticmethod
    def filter(stream: DataStream, predicate: Callable) -> DataStream:
        filtered_stream = DataStream()

        def filter_observer(event: Event):
            if predicate(event.data):
                filtered_stream.add_data(event.data)

        stream.subscribe(filter_observer)
        return filtered_stream

    @staticmethod
    def map(stream: DataStream, transform: Callable) -> DataStream:
        mapped_stream = DataStream()

        def map_observer(event: Event):
            transformed_data = transform(event.data)
            mapped_stream.add_data(transformed_data)

        stream.subscribe(map_observer)
        return mapped_stream

# ä½¿ç”¨ç¤ºä¾‹
# åˆ›å»ºæ•°æ®æµ
data_stream = DataStream()

# åˆ›å»ºè§‚å¯Ÿè€…
def print_observer(event: Event):
    print(f"æ”¶åˆ°æ•°æ®: {event.data} at {event.timestamp}")

def count_observer(event: Event):
    print(f"æ•°æ®è®¡æ•°: {len(data_stream.get_data())}")

# è®¢é˜…è§‚å¯Ÿè€…
data_stream.subscribe(print_observer)
data_stream.subscribe(count_observer)

# æ·»åŠ æ•°æ®
data_stream.add_data("Hello")
data_stream.add_data("World")
data_stream.add_data("Reactive")
data_stream.add_data("Programming")

# ä½¿ç”¨å“åº”å¼æ“ä½œç¬¦
number_stream = DataStream()
filtered_stream = ReactiveOperators.filter(number_stream, lambda x: x > 5)
mapped_stream = ReactiveOperators.map(filtered_stream, lambda x: x * 2)

mapped_stream.subscribe(lambda event: print(f"å¤„ç†ç»“æœ: {event.data}"))

# æ·»åŠ æ•°å­—æ•°æ®
for i in range(10):
    number_stream.add_data(i)
```

## 5. è¯­è¨€æ¯”è¾ƒå®è·µæ¡ˆä¾‹

### 5.1. æ€§èƒ½æ¯”è¾ƒ

```python
# Pythonæ€§èƒ½æµ‹è¯•
import time
import cProfile
import pstats

def fibonacci_recursive(n):
    if n <= 1:
        return n
    return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)

def fibonacci_iterative(n):
    if n <= 1:
        return n
    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    return b

def fibonacci_memoization(n, memo={}):
    if n in memo:
        return memo[n]
    if n <= 1:
        return n
    memo[n] = fibonacci_memoization(n - 1, memo) + fibonacci_memoization(n - 2, memo)
    return memo[n]

# æ€§èƒ½æµ‹è¯•
def performance_test():
    n = 35

    print("æ€§èƒ½æµ‹è¯• (n = 35):")

# è¿­ä»£ç‰ˆæœ¬
    start_time = time.time()
    result_iter = fibonacci_iterative(n)
    iter_time = time.time() - start_time
    print(f"è¿­ä»£ç‰ˆæœ¬: {result_iter}, æ—¶é—´: {iter_time:.4f}ç§’")

# è®°å¿†åŒ–ç‰ˆæœ¬
    start_time = time.time()
    result_memo = fibonacci_memoization(n)
    memo_time = time.time() - start_time
    print(f"è®°å¿†åŒ–ç‰ˆæœ¬: {result_memo}, æ—¶é—´: {memo_time:.4f}ç§’")

# é€’å½’ç‰ˆæœ¬ï¼ˆæ³¨é‡Šæ‰ï¼Œå› ä¸ºå¤ªæ…¢ï¼‰
# start_time = time.time()
# result_rec = fibonacci_recursive(n)
# rec_time = time.time() - start_time
# print(f"é€’å½’ç‰ˆæœ¬: {result_rec}, æ—¶é—´: {rec_time:.4f}ç§’")

# ä½¿ç”¨cProfileè¿›è¡Œè¯¦ç»†åˆ†æ
def profile_test():
    profiler = cProfile.Profile()
    profiler.enable()

# æµ‹è¯•è®°å¿†åŒ–ç‰ˆæœ¬
    fibonacci_memoization(1000)

    profiler.disable()
    stats = pstats.Stats(profiler)
    stats.sort_stats('cumulative')
    stats.print_stats(10)

if __name__ == "__main__":
    performance_test()
    print("\nè¯¦ç»†æ€§èƒ½åˆ†æ:")
    profile_test()
```

## 6. å†…å­˜ä½¿ç”¨æ¯”è¾ƒ

```python
# å†…å­˜ä½¿ç”¨åˆ†æ
import sys
import gc
from typing import List

class MemoryAnalyzer:
    @staticmethod
    def get_memory_usage(obj):
        return sys.getsizeof(obj)

    @staticmethod
    def analyze_list_memory():
        print("åˆ—è¡¨å†…å­˜ä½¿ç”¨åˆ†æ:")

# ç©ºåˆ—è¡¨
        empty_list = []
        print(f"ç©ºåˆ—è¡¨: {MemoryAnalyzer.get_memory_usage(empty_list)} å­—èŠ‚")

# å°åˆ—è¡¨
        small_list = [1, 2, 3, 4, 5]
        print(f"å°åˆ—è¡¨: {MemoryAnalyzer.get_memory_usage(small_list)} å­—èŠ‚")

# å¤§åˆ—è¡¨
        large_list = list(range(1000))
        print(f"å¤§åˆ—è¡¨: {MemoryAnalyzer.get_memory_usage(large_list)} å­—èŠ‚")

# å­—ç¬¦ä¸²åˆ—è¡¨
        string_list = ["hello"] * 100
        print(f"å­—ç¬¦ä¸²åˆ—è¡¨: {MemoryAnalyzer.get_memory_usage(string_list)} å­—èŠ‚")

    @staticmethod
    def analyze_generator_memory():
        print("\nç”Ÿæˆå™¨å†…å­˜ä½¿ç”¨åˆ†æ:")

# åˆ—è¡¨
        list_data = list(range(1000000))
        list_memory = MemoryAnalyzer.get_memory_usage(list_data)
        print(f"åˆ—è¡¨å†…å­˜: {list_memory} å­—èŠ‚")

# ç”Ÿæˆå™¨
        generator_data = (x for x in range(1000000))
        generator_memory = MemoryAnalyzer.get_memory_usage(generator_data)
        print(f"ç”Ÿæˆå™¨å†…å­˜: {generator_memory} å­—èŠ‚")

        print(f"å†…å­˜èŠ‚çœ: {(list_memory - generator_memory) / list_memory * 100:.2f}%")

    @staticmethod
    def analyze_object_memory():
        print("\nå¯¹è±¡å†…å­˜ä½¿ç”¨åˆ†æ:")

        class SimpleObject:
            def __init__(self, value):
                self.value = value

        class SlotsObject:
            __slots__ = ['value']

            def __init__(self, value):
                self.value = value

# æ™®é€šå¯¹è±¡
        simple_obj = SimpleObject(42)
        simple_memory = MemoryAnalyzer.get_memory_usage(simple_obj)
        print(f"æ™®é€šå¯¹è±¡: {simple_memory} å­—èŠ‚")

# ä½¿ç”¨__slots__çš„å¯¹è±¡
        slots_obj = SlotsObject(42)
        slots_memory = MemoryAnalyzer.get_memory_usage(slots_obj)
        print(f"Slotså¯¹è±¡: {slots_memory} å­—èŠ‚")

        print(f"å†…å­˜èŠ‚çœ: {(simple_memory - slots_memory) / simple_memory * 100:.2f}%")

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    analyzer = MemoryAnalyzer()
    analyzer.analyze_list_memory()
    analyzer.analyze_generator_memory()
    analyzer.analyze_object_memory()
```

## 7. å¹¶å‘æ€§èƒ½æ¯”è¾ƒ

```python
# å¹¶å‘æ€§èƒ½æ¯”è¾ƒ
import threading
import multiprocessing
import asyncio
import time
from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor

class ConcurrencyBenchmark:
    def __init__(self):
        self.counter = 0
        self.lock = threading.Lock()

    def cpu_bound_task(self, n):
        """CPUå¯†é›†å‹ä»»åŠ¡"""
        result = 0
        for i in range(n):
            result += i ** 2
        return result

    def io_bound_task(self, duration):
        """IOå¯†é›†å‹ä»»åŠ¡"""
        time.sleep(duration)
        return f"IOä»»åŠ¡å®Œæˆï¼Œè€—æ—¶{duration}ç§’"

    def thread_safe_increment(self):
        """çº¿ç¨‹å®‰å…¨çš„è®¡æ•°å™¨é€’å¢"""
        with self.lock:
            self.counter += 1
            return self.counter

    def benchmark_threading(self, task_count):
        """çº¿ç¨‹æ± åŸºå‡†æµ‹è¯•"""
        start_time = time.time()

        with ThreadPoolExecutor(max_workers=4) as executor:
            futures = [executor.submit(self.io_bound_task, 0.1) for _ in range(task_count)]
            results = [future.result() for future in futures]

        end_time = time.time()
        return end_time - start_time

    def benchmark_multiprocessing(self, task_count):
        """è¿›ç¨‹æ± åŸºå‡†æµ‹è¯•"""
        start_time = time.time()

        with ProcessPoolExecutor(max_workers=4) as executor:
            futures = [executor.submit(self.cpu_bound_task, 100000) for _ in range(task_count)]
            results = [future.result() for future in futures]

        end_time = time.time()
        return end_time - start_time

    async def async_task(self, duration):
        """å¼‚æ­¥ä»»åŠ¡"""
        await asyncio.sleep(duration)
        return f"å¼‚æ­¥ä»»åŠ¡å®Œæˆï¼Œè€—æ—¶{duration}ç§’"

    async def benchmark_asyncio(self, task_count):
        """å¼‚æ­¥IOåŸºå‡†æµ‹è¯•"""
        start_time = time.time()

        tasks = [self.async_task(0.1) for _ in range(task_count)]
        results = await asyncio.gather(*tasks)

        end_time = time.time()
        return end_time - start_time

# ä½¿ç”¨ç¤ºä¾‹
async def main():
    benchmark = ConcurrencyBenchmark()
    task_count = 20

    print("å¹¶å‘æ€§èƒ½åŸºå‡†æµ‹è¯•:")
    print(f"ä»»åŠ¡æ•°é‡: {task_count}")

# çº¿ç¨‹æ± æµ‹è¯•
    thread_time = benchmark.benchmark_threading(task_count)
    print(f"çº¿ç¨‹æ± è€—æ—¶: {thread_time:.4f}ç§’")

# è¿›ç¨‹æ± æµ‹è¯•
    process_time = benchmark.benchmark_multiprocessing(task_count)
    print(f"è¿›ç¨‹æ± è€—æ—¶: {process_time:.4f}ç§’")

# å¼‚æ­¥IOæµ‹è¯•
    async_time = await benchmark.benchmark_asyncio(task_count)
    print(f"å¼‚æ­¥IOè€—æ—¶: {async_time:.4f}ç§’")

# çº¿ç¨‹å®‰å…¨æµ‹è¯•
    print("\nçº¿ç¨‹å®‰å…¨æµ‹è¯•:")
    threads = []
    for _ in range(10):
        thread = threading.Thread(target=benchmark.thread_safe_increment)
        threads.append(thread)
        thread.start()

    for thread in threads:
        thread.join()

    print(f"æœ€ç»ˆè®¡æ•°å™¨å€¼: {benchmark.counter}")

if __name__ == "__main__":
    asyncio.run(main())
```

è¿™äº›å®è·µæ¡ˆä¾‹å±•ç¤ºäº†ç¼–ç¨‹è¯­è¨€æ·±åŒ–ä¸­çš„æ ¸å¿ƒæ¦‚å¿µå’Œå®é™…åº”ç”¨ï¼ŒåŒ…æ‹¬Rustè¯­è¨€çš„å†…å­˜å®‰å…¨ç‰¹æ€§ã€ä¸åŒç¼–ç¨‹èŒƒå¼çš„å®ç°æ–¹å¼ï¼Œä»¥åŠå„ç§ç¼–ç¨‹è¯­è¨€çš„æ€§èƒ½æ¯”è¾ƒã€‚æ¯ä¸ªæ¡ˆä¾‹éƒ½æä¾›äº†å®Œæ•´çš„ä»£ç å®ç°å’Œä½¿ç”¨ç¤ºä¾‹ï¼Œå¸®åŠ©ç†è§£è¿™äº›æ¦‚å¿µçš„å®é™…åº”ç”¨ã€‚
