# 编程语言深化实践案例

## 1. Rust语言实践案例

### 1.1 内存安全与所有权系统

```rust
// Rust所有权系统示例
fn main() {
    // 1. 基本所有权规则
    let s1 = String::from("hello");
    let s2 = s1; // s1的所有权移动到s2，s1不再有效
    // println!("{}", s1); // 编译错误：s1已被移动
    
    // 2. 借用（引用）
    let s3 = String::from("world");
    let len = calculate_length(&s3); // 借用s3
    println!("'{}' 的长度是 {}", s3, len); // s3仍然有效
    
    // 3. 可变借用
    let mut s4 = String::from("hello");
    change(&mut s4);
    println!("修改后: {}", s4);
    
    // 4. 切片
    let s5 = String::from("hello world");
    let hello = &s5[0..5];
    let world = &s5[6..11];
    println!("{} {}", hello, world);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}

fn change(some_string: &mut String) {
    some_string.push_str(" world");
}
```

### 1.2 错误处理与Result类型

```rust
use std::fs::File;
use std::io::{self, Read};

// 自定义错误类型
#[derive(Debug)]
enum CustomError {
    IoError(io::Error),
    ParseError(String),
}

impl From<io::Error> for CustomError {
    fn from(err: io::Error) -> CustomError {
        CustomError::IoError(err)
    }
}

// 使用Result进行错误处理
fn read_username_from_file(filename: &str) -> Result<String, CustomError> {
    let mut file = File::open(filename)?;
    let mut username = String::new();
    file.read_to_string(&mut username)?;
    
    if username.trim().is_empty() {
        return Err(CustomError::ParseError("用户名不能为空".to_string()));
    }
    
    Ok(username)
}

// 使用示例
fn main() {
    match read_username_from_file("username.txt") {
        Ok(username) => println!("用户名: {}", username),
        Err(e) => match e {
            CustomError::IoError(io_err) => println!("IO错误: {}", io_err),
            CustomError::ParseError(msg) => println!("解析错误: {}", msg),
        }
    }
}
```

### 1.3 并发编程

```rust
use std::thread;
use std::sync::{Arc, Mutex};
use std::time::Duration;

// 线程安全的数据结构
struct SharedCounter {
    value: Mutex<i32>,
}

impl SharedCounter {
    fn new() -> Self {
        SharedCounter {
            value: Mutex::new(0),
        }
    }
    
    fn increment(&self) {
        let mut val = self.value.lock().unwrap();
        *val += 1;
    }
    
    fn get_value(&self) -> i32 {
        *self.value.lock().unwrap()
    }
}

// 多线程示例
fn main() {
    let counter = Arc::new(SharedCounter::new());
    let mut handles = vec![];
    
    // 创建多个线程
    for i in 0..5 {
        let counter_clone = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            for _ in 0..1000 {
                counter_clone.increment();
            }
            println!("线程 {} 完成", i);
        });
        handles.push(handle);
    }
    
    // 等待所有线程完成
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("最终计数: {}", counter.get_value());
}
```

## 2. 编程范式实践案例

### 2.1 函数式编程

```python
# 函数式编程示例
from functools import reduce
from typing import List, Callable

# 纯函数
def add(a: int, b: int) -> int:
    return a + b

def multiply(a: int, b: int) -> int:
    return a * b

# 高阶函数
def apply_operation(func: Callable, a: int, b: int) -> int:
    return func(a, b)

# 函数组合
def compose(*functions):
    def inner(arg):
        result = arg
        for f in reversed(functions):
            result = f(result)
        return result
    return inner

# 不可变数据结构
class ImmutableList:
    def __init__(self, items: List):
        self._items = tuple(items)  # 使用tuple确保不可变
    
    def map(self, func: Callable):
        return ImmutableList([func(item) for item in self._items])
    
    def filter(self, predicate: Callable):
        return ImmutableList([item for item in self._items if predicate(item)])
    
    def reduce(self, func: Callable, initial):
        return reduce(func, self._items, initial)
    
    def to_list(self):
        return list(self._items)

# 使用示例
numbers = ImmutableList([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

# 函数式操作链
result = (numbers
    .filter(lambda x: x % 2 == 0)  # 过滤偶数
    .map(lambda x: x * x)          # 平方
    .reduce(lambda acc, x: acc + x, 0))  # 求和

print(f"偶数的平方和: {result}")

# 函数组合
def double(x): return x * 2
def add_one(x): return x + 1
def square(x): return x ** 2

composed = compose(square, add_one, double)
print(f"组合函数 f(x) = (2x + 1)^2, f(3) = {composed(3)}")
```

### 2.2 面向对象编程

```python
# 面向对象编程示例
from abc import ABC, abstractmethod
from typing import List, Dict

# 抽象基类
class Shape(ABC):
    def __init__(self, color: str):
        self.color = color
    
    @abstractmethod
    def area(self) -> float:
        pass
    
    @abstractmethod
    def perimeter(self) -> float:
        pass
    
    def describe(self) -> str:
        return f"{self.color} {self.__class__.__name__}"

# 具体类
class Circle(Shape):
    def __init__(self, color: str, radius: float):
        super().__init__(color)
        self.radius = radius
    
    def area(self) -> float:
        import math
        return math.pi * self.radius ** 2
    
    def perimeter(self) -> float:
        import math
        return 2 * math.pi * self.radius

class Rectangle(Shape):
    def __init__(self, color: str, width: float, height: float):
        super().__init__(color)
        self.width = width
        self.height = height
    
    def area(self) -> float:
        return self.width * self.height
    
    def perimeter(self) -> float:
        return 2 * (self.width + self.height)

# 工厂模式
class ShapeFactory:
    @staticmethod
    def create_shape(shape_type: str, **kwargs) -> Shape:
        if shape_type.lower() == "circle":
            return Circle(kwargs.get("color", "red"), kwargs.get("radius", 1.0))
        elif shape_type.lower() == "rectangle":
            return Rectangle(kwargs.get("color", "blue"), 
                           kwargs.get("width", 1.0), 
                           kwargs.get("height", 1.0))
        else:
            raise ValueError(f"未知的形状类型: {shape_type}")

# 使用示例
shapes = [
    ShapeFactory.create_shape("circle", color="red", radius=5.0),
    ShapeFactory.create_shape("rectangle", color="blue", width=4.0, height=6.0)
]

for shape in shapes:
    print(f"{shape.describe()}: 面积={shape.area():.2f}, 周长={shape.perimeter():.2f}")
```

### 2.3 响应式编程

```python
# 简单的响应式编程示例
from typing import List, Callable
from dataclasses import dataclass
from datetime import datetime

@dataclass
class Event:
    timestamp: datetime
    data: any

class Observable:
    def __init__(self):
        self._observers: List[Callable] = []
    
    def subscribe(self, observer: Callable):
        self._observers.append(observer)
    
    def unsubscribe(self, observer: Callable):
        if observer in self._observers:
            self._observers.remove(observer)
    
    def notify(self, event: Event):
        for observer in self._observers:
            observer(event)

class DataStream(Observable):
    def __init__(self):
        super().__init__()
        self._data = []
    
    def add_data(self, data: any):
        event = Event(datetime.now(), data)
        self._data.append(data)
        self.notify(event)
    
    def get_data(self):
        return self._data.copy()

# 响应式操作符
class ReactiveOperators:
    @staticmethod
    def filter(stream: DataStream, predicate: Callable) -> DataStream:
        filtered_stream = DataStream()
        
        def filter_observer(event: Event):
            if predicate(event.data):
                filtered_stream.add_data(event.data)
        
        stream.subscribe(filter_observer)
        return filtered_stream
    
    @staticmethod
    def map(stream: DataStream, transform: Callable) -> DataStream:
        mapped_stream = DataStream()
        
        def map_observer(event: Event):
            transformed_data = transform(event.data)
            mapped_stream.add_data(transformed_data)
        
        stream.subscribe(map_observer)
        return mapped_stream

# 使用示例
# 创建数据流
data_stream = DataStream()

# 创建观察者
def print_observer(event: Event):
    print(f"收到数据: {event.data} at {event.timestamp}")

def count_observer(event: Event):
    print(f"数据计数: {len(data_stream.get_data())}")

# 订阅观察者
data_stream.subscribe(print_observer)
data_stream.subscribe(count_observer)

# 添加数据
data_stream.add_data("Hello")
data_stream.add_data("World")
data_stream.add_data("Reactive")
data_stream.add_data("Programming")

# 使用响应式操作符
number_stream = DataStream()
filtered_stream = ReactiveOperators.filter(number_stream, lambda x: x > 5)
mapped_stream = ReactiveOperators.map(filtered_stream, lambda x: x * 2)

mapped_stream.subscribe(lambda event: print(f"处理结果: {event.data}"))

# 添加数字数据
for i in range(10):
    number_stream.add_data(i)
```

## 3. 语言比较实践案例

### 3.1 性能比较

```python
# Python性能测试
import time
import cProfile
import pstats

def fibonacci_recursive(n):
    if n <= 1:
        return n
    return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)

def fibonacci_iterative(n):
    if n <= 1:
        return n
    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    return b

def fibonacci_memoization(n, memo={}):
    if n in memo:
        return memo[n]
    if n <= 1:
        return n
    memo[n] = fibonacci_memoization(n - 1, memo) + fibonacci_memoization(n - 2, memo)
    return memo[n]

# 性能测试
def performance_test():
    n = 35
    
    print("性能测试 (n = 35):")
    
    # 迭代版本
    start_time = time.time()
    result_iter = fibonacci_iterative(n)
    iter_time = time.time() - start_time
    print(f"迭代版本: {result_iter}, 时间: {iter_time:.4f}秒")
    
    # 记忆化版本
    start_time = time.time()
    result_memo = fibonacci_memoization(n)
    memo_time = time.time() - start_time
    print(f"记忆化版本: {result_memo}, 时间: {memo_time:.4f}秒")
    
    # 递归版本（注释掉，因为太慢）
    # start_time = time.time()
    # result_rec = fibonacci_recursive(n)
    # rec_time = time.time() - start_time
    # print(f"递归版本: {result_rec}, 时间: {rec_time:.4f}秒")

# 使用cProfile进行详细分析
def profile_test():
    profiler = cProfile.Profile()
    profiler.enable()
    
    # 测试记忆化版本
    fibonacci_memoization(1000)
    
    profiler.disable()
    stats = pstats.Stats(profiler)
    stats.sort_stats('cumulative')
    stats.print_stats(10)

if __name__ == "__main__":
    performance_test()
    print("\n详细性能分析:")
    profile_test()
```

### 3.2 内存使用比较

```python
# 内存使用分析
import sys
import gc
from typing import List

class MemoryAnalyzer:
    @staticmethod
    def get_memory_usage(obj):
        return sys.getsizeof(obj)
    
    @staticmethod
    def analyze_list_memory():
        print("列表内存使用分析:")
        
        # 空列表
        empty_list = []
        print(f"空列表: {MemoryAnalyzer.get_memory_usage(empty_list)} 字节")
        
        # 小列表
        small_list = [1, 2, 3, 4, 5]
        print(f"小列表: {MemoryAnalyzer.get_memory_usage(small_list)} 字节")
        
        # 大列表
        large_list = list(range(1000))
        print(f"大列表: {MemoryAnalyzer.get_memory_usage(large_list)} 字节")
        
        # 字符串列表
        string_list = ["hello"] * 100
        print(f"字符串列表: {MemoryAnalyzer.get_memory_usage(string_list)} 字节")
    
    @staticmethod
    def analyze_generator_memory():
        print("\n生成器内存使用分析:")
        
        # 列表
        list_data = list(range(1000000))
        list_memory = MemoryAnalyzer.get_memory_usage(list_data)
        print(f"列表内存: {list_memory} 字节")
        
        # 生成器
        generator_data = (x for x in range(1000000))
        generator_memory = MemoryAnalyzer.get_memory_usage(generator_data)
        print(f"生成器内存: {generator_memory} 字节")
        
        print(f"内存节省: {(list_memory - generator_memory) / list_memory * 100:.2f}%")
    
    @staticmethod
    def analyze_object_memory():
        print("\n对象内存使用分析:")
        
        class SimpleObject:
            def __init__(self, value):
                self.value = value
        
        class SlotsObject:
            __slots__ = ['value']
            
            def __init__(self, value):
                self.value = value
        
        # 普通对象
        simple_obj = SimpleObject(42)
        simple_memory = MemoryAnalyzer.get_memory_usage(simple_obj)
        print(f"普通对象: {simple_memory} 字节")
        
        # 使用__slots__的对象
        slots_obj = SlotsObject(42)
        slots_memory = MemoryAnalyzer.get_memory_usage(slots_obj)
        print(f"Slots对象: {slots_memory} 字节")
        
        print(f"内存节省: {(simple_memory - slots_memory) / simple_memory * 100:.2f}%")

# 使用示例
if __name__ == "__main__":
    analyzer = MemoryAnalyzer()
    analyzer.analyze_list_memory()
    analyzer.analyze_generator_memory()
    analyzer.analyze_object_memory()
```

### 3.3 并发性能比较

```python
# 并发性能比较
import threading
import multiprocessing
import asyncio
import time
from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor

class ConcurrencyBenchmark:
    def __init__(self):
        self.counter = 0
        self.lock = threading.Lock()
    
    def cpu_bound_task(self, n):
        """CPU密集型任务"""
        result = 0
        for i in range(n):
            result += i ** 2
        return result
    
    def io_bound_task(self, duration):
        """IO密集型任务"""
        time.sleep(duration)
        return f"IO任务完成，耗时{duration}秒"
    
    def thread_safe_increment(self):
        """线程安全的计数器递增"""
        with self.lock:
            self.counter += 1
            return self.counter
    
    def benchmark_threading(self, task_count):
        """线程池基准测试"""
        start_time = time.time()
        
        with ThreadPoolExecutor(max_workers=4) as executor:
            futures = [executor.submit(self.io_bound_task, 0.1) for _ in range(task_count)]
            results = [future.result() for future in futures]
        
        end_time = time.time()
        return end_time - start_time
    
    def benchmark_multiprocessing(self, task_count):
        """进程池基准测试"""
        start_time = time.time()
        
        with ProcessPoolExecutor(max_workers=4) as executor:
            futures = [executor.submit(self.cpu_bound_task, 100000) for _ in range(task_count)]
            results = [future.result() for future in futures]
        
        end_time = time.time()
        return end_time - start_time
    
    async def async_task(self, duration):
        """异步任务"""
        await asyncio.sleep(duration)
        return f"异步任务完成，耗时{duration}秒"
    
    async def benchmark_asyncio(self, task_count):
        """异步IO基准测试"""
        start_time = time.time()
        
        tasks = [self.async_task(0.1) for _ in range(task_count)]
        results = await asyncio.gather(*tasks)
        
        end_time = time.time()
        return end_time - start_time

# 使用示例
async def main():
    benchmark = ConcurrencyBenchmark()
    task_count = 20
    
    print("并发性能基准测试:")
    print(f"任务数量: {task_count}")
    
    # 线程池测试
    thread_time = benchmark.benchmark_threading(task_count)
    print(f"线程池耗时: {thread_time:.4f}秒")
    
    # 进程池测试
    process_time = benchmark.benchmark_multiprocessing(task_count)
    print(f"进程池耗时: {process_time:.4f}秒")
    
    # 异步IO测试
    async_time = await benchmark.benchmark_asyncio(task_count)
    print(f"异步IO耗时: {async_time:.4f}秒")
    
    # 线程安全测试
    print("\n线程安全测试:")
    threads = []
    for _ in range(10):
        thread = threading.Thread(target=benchmark.thread_safe_increment)
        threads.append(thread)
        thread.start()
    
    for thread in threads:
        thread.join()
    
    print(f"最终计数器值: {benchmark.counter}")

if __name__ == "__main__":
    asyncio.run(main())
```

这些实践案例展示了编程语言深化中的核心概念和实际应用，包括Rust语言的内存安全特性、不同编程范式的实现方式，以及各种编程语言的性能比较。每个案例都提供了完整的代码实现和使用示例，帮助理解这些概念的实际应用。
