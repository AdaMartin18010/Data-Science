# 1.1.1 PostgreSQL Practice Cases

## ðŸ“‘ ç›®å½•

- [1.1.1 PostgreSQL Practice Cases](#111-postgresql-practice-cases)
  - [ðŸ“‘ ç›®å½•](#-ç›®å½•)
- [1. Overview](#1-overview)
- [2. Database Design Practice Cases](#2-database-design-practice-cases)
  - [2.1. E-commerce Database Design](#21-e-commerce-database-design)
  - [2.2. Financial Database Design](#22-financial-database-design)
- [3. Performance Optimization Practice Cases](#3-performance-optimization-practice-cases)
  - [3.1. Query Optimization](#31-query-optimization)
  - [3.2. Connection Pooling and Caching](#32-connection-pooling-and-caching)
- [4. High Availability Practice Cases](#4-high-availability-practice-cases)
  - [4.1. Replication Setup](#41-replication-setup)
  - [4.2. Backup and Recovery](#42-backup-and-recovery)
- [5. Summary](#5-summary)
---


## 1. Overview

This document provides practical application cases for PostgreSQL database, covering database design, optimization, high availability, and other aspects of real-world applications.

## 2. Database Design Practice Cases

### 2.1. E-commerce Database Design

```sql
-- Create database
CREATE DATABASE ecommerce_db;
\c ecommerce_db;

-- Create users table
CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    phone VARCHAR(20),
    address TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    is_active BOOLEAN DEFAULT TRUE
);

-- Create categories table
CREATE TABLE categories (
    category_id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    parent_category_id INTEGER REFERENCES categories(category_id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Create products table
CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    description TEXT,
    price DECIMAL(10,2) NOT NULL,
    stock_quantity INTEGER NOT NULL DEFAULT 0,
    category_id INTEGER REFERENCES categories(category_id),
    sku VARCHAR(50) UNIQUE,
    weight DECIMAL(8,2),
    dimensions VARCHAR(50),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Create orders table
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(user_id),
    order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    status VARCHAR(20) DEFAULT 'pending',
    total_amount DECIMAL(10,2) NOT NULL,
    shipping_address TEXT,
    billing_address TEXT,
    payment_method VARCHAR(50),
    tracking_number VARCHAR(100)
);

-- Create order_items table
CREATE TABLE order_items (
    order_item_id SERIAL PRIMARY KEY,
    order_id INTEGER REFERENCES orders(order_id),
    product_id INTEGER REFERENCES products(product_id),
    quantity INTEGER NOT NULL,
    unit_price DECIMAL(10,2) NOT NULL,
    total_price DECIMAL(10,2) NOT NULL
);

-- Create indexes for better performance
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_products_category ON products(category_id);
CREATE INDEX idx_products_sku ON products(sku);
CREATE INDEX idx_orders_user_id ON orders(user_id);
CREATE INDEX idx_orders_status ON orders(status);
CREATE INDEX idx_order_items_order_id ON order_items(order_id);
CREATE INDEX idx_order_items_product_id ON order_items(product_id);

-- Create trigger to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_users_updated_at BEFORE UPDATE ON users
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_products_updated_at BEFORE UPDATE ON products
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Insert sample data
INSERT INTO categories (name, description) VALUES
('Electronics', 'Electronic devices and accessories'),
('Clothing', 'Fashion and apparel'),
('Books', 'Books and publications');

INSERT INTO products (name, description, price, stock_quantity, category_id, sku) VALUES
('iPhone 15', 'Latest iPhone model', 999.99, 50, 1, 'IPHONE-15-001'),
('Samsung Galaxy S24', 'Android smartphone', 899.99, 30, 1, 'SAMSUNG-S24-001'),
('Nike Running Shoes', 'Comfortable running shoes', 129.99, 100, 2, 'NIKE-RUN-001'),
('Python Programming Book', 'Learn Python programming', 49.99, 200, 3, 'BOOK-PYTHON-001');

-- Create view for product inventory
CREATE VIEW product_inventory AS
SELECT 
    p.product_id,
    p.name,
    p.sku,
    p.price,
    p.stock_quantity,
    c.name as category_name,
    CASE 
        WHEN p.stock_quantity = 0 THEN 'Out of Stock'
        WHEN p.stock_quantity < 10 THEN 'Low Stock'
        ELSE 'In Stock'
    END as stock_status
FROM products p
JOIN categories c ON p.category_id = c.category_id;

-- Create function to calculate order total
CREATE OR REPLACE FUNCTION calculate_order_total(order_id_param INTEGER)
RETURNS DECIMAL(10,2) AS $$
DECLARE
    total DECIMAL(10,2);
BEGIN
    SELECT COALESCE(SUM(total_price), 0)
    INTO total
    FROM order_items
    WHERE order_id = order_id_param;
    
    RETURN total;
END;
$$ LANGUAGE plpgsql;

-- Create function to update product stock
CREATE OR REPLACE FUNCTION update_product_stock(
    product_id_param INTEGER,
    quantity_change INTEGER
)
RETURNS BOOLEAN AS $$
DECLARE
    current_stock INTEGER;
BEGIN
    -- Get current stock
    SELECT stock_quantity INTO current_stock
    FROM products
    WHERE product_id = product_id_param;
    
    -- Check if we have enough stock
    IF current_stock + quantity_change < 0 THEN
        RETURN FALSE;
    END IF;
    
    -- Update stock
    UPDATE products
    SET stock_quantity = stock_quantity + quantity_change
    WHERE product_id = product_id_param;
    
    RETURN TRUE;
END;
$$ LANGUAGE plpgsql;
```

### 2.2. Financial Database Design

```sql
-- Create financial database
CREATE DATABASE financial_db;
\c financial_db;

-- Create customers table
CREATE TABLE customers (
    customer_id SERIAL PRIMARY KEY,
    account_number VARCHAR(20) UNIQUE NOT NULL,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    phone VARCHAR(20),
    date_of_birth DATE,
    address TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    status VARCHAR(20) DEFAULT 'active'
);

-- Create accounts table
CREATE TABLE accounts (
    account_id SERIAL PRIMARY KEY,
    customer_id INTEGER REFERENCES customers(customer_id),
    account_type VARCHAR(20) NOT NULL, -- 'savings', 'checking', 'credit'
    account_number VARCHAR(20) UNIQUE NOT NULL,
    balance DECIMAL(15,2) DEFAULT 0.00,
    currency VARCHAR(3) DEFAULT 'USD',
    interest_rate DECIMAL(5,4) DEFAULT 0.0000,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    status VARCHAR(20) DEFAULT 'active'
);

-- Create transactions table
CREATE TABLE transactions (
    transaction_id SERIAL PRIMARY KEY,
    account_id INTEGER REFERENCES accounts(account_id),
    transaction_type VARCHAR(20) NOT NULL, -- 'deposit', 'withdrawal', 'transfer', 'payment'
    amount DECIMAL(15,2) NOT NULL,
    description TEXT,
    reference_number VARCHAR(50),
    transaction_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    status VARCHAR(20) DEFAULT 'completed'
);

-- Create loans table
CREATE TABLE loans (
    loan_id SERIAL PRIMARY KEY,
    customer_id INTEGER REFERENCES customers(customer_id),
    loan_type VARCHAR(20) NOT NULL, -- 'personal', 'mortgage', 'business'
    principal_amount DECIMAL(15,2) NOT NULL,
    interest_rate DECIMAL(5,4) NOT NULL,
    term_months INTEGER NOT NULL,
    monthly_payment DECIMAL(15,2) NOT NULL,
    remaining_balance DECIMAL(15,2) NOT NULL,
    start_date DATE NOT NULL,
    end_date DATE NOT NULL,
    status VARCHAR(20) DEFAULT 'active'
);

-- Create indexes
CREATE INDEX idx_customers_account_number ON customers(account_number);
CREATE INDEX idx_customers_email ON customers(email);
CREATE INDEX idx_accounts_customer_id ON accounts(customer_id);
CREATE INDEX idx_accounts_account_number ON accounts(account_number);
CREATE INDEX idx_transactions_account_id ON transactions(account_id);
CREATE INDEX idx_transactions_date ON transactions(transaction_date);
CREATE INDEX idx_loans_customer_id ON loans(customer_id);

-- Create function to calculate loan payment
CREATE OR REPLACE FUNCTION calculate_loan_payment(
    principal DECIMAL(15,2),
    annual_rate DECIMAL(5,4),
    term_months INTEGER
)
RETURNS DECIMAL(15,2) AS $$
DECLARE
    monthly_rate DECIMAL(10,8);
    payment DECIMAL(15,2);
BEGIN
    monthly_rate := annual_rate / 12;
    
    IF monthly_rate = 0 THEN
        payment := principal / term_months;
    ELSE
        payment := principal * (monthly_rate * POWER(1 + monthly_rate, term_months)) / 
                   (POWER(1 + monthly_rate, term_months) - 1);
    END IF;
    
    RETURN ROUND(payment, 2);
END;
$$ LANGUAGE plpgsql;

-- Create function to process transaction
CREATE OR REPLACE FUNCTION process_transaction(
    account_id_param INTEGER,
    transaction_type_param VARCHAR(20),
    amount_param DECIMAL(15,2),
    description_param TEXT
)
RETURNS BOOLEAN AS $$
DECLARE
    current_balance DECIMAL(15,2);
    new_balance DECIMAL(15,2);
BEGIN
    -- Get current balance
    SELECT balance INTO current_balance
    FROM accounts
    WHERE account_id = account_id_param AND status = 'active';
    
    IF NOT FOUND THEN
        RETURN FALSE;
    END IF;
    
    -- Calculate new balance
    CASE transaction_type_param
        WHEN 'deposit' THEN
            new_balance := current_balance + amount_param;
        WHEN 'withdrawal' THEN
            IF current_balance < amount_param THEN
                RETURN FALSE; -- Insufficient funds
            END IF;
            new_balance := current_balance - amount_param;
        WHEN 'transfer' THEN
            IF current_balance < amount_param THEN
                RETURN FALSE; -- Insufficient funds
            END IF;
            new_balance := current_balance - amount_param;
        ELSE
            RETURN FALSE; -- Invalid transaction type
    END CASE;
    
    -- Update account balance
    UPDATE accounts
    SET balance = new_balance
    WHERE account_id = account_id_param;
    
    -- Insert transaction record
    INSERT INTO transactions (account_id, transaction_type, amount, description)
    VALUES (account_id_param, transaction_type_param, amount_param, description_param);
    
    RETURN TRUE;
END;
$$ LANGUAGE plpgsql;

-- Create view for account summary
CREATE VIEW account_summary AS
SELECT 
    c.customer_id,
    c.first_name,
    c.last_name,
    c.account_number as customer_account,
    a.account_id,
    a.account_type,
    a.account_number,
    a.balance,
    a.currency,
    COUNT(t.transaction_id) as transaction_count,
    MAX(t.transaction_date) as last_transaction_date
FROM customers c
JOIN accounts a ON c.customer_id = a.customer_id
LEFT JOIN transactions t ON a.account_id = t.account_id
WHERE a.status = 'active'
GROUP BY c.customer_id, c.first_name, c.last_name, c.account_number, 
         a.account_id, a.account_type, a.account_number, a.balance, a.currency;

-- Create materialized view for monthly transaction summary
CREATE MATERIALIZED VIEW monthly_transaction_summary AS
SELECT 
    DATE_TRUNC('month', transaction_date) as month,
    account_id,
    transaction_type,
    COUNT(*) as transaction_count,
    SUM(amount) as total_amount,
    AVG(amount) as average_amount
FROM transactions
WHERE status = 'completed'
GROUP BY DATE_TRUNC('month', transaction_date), account_id, transaction_type;

-- Create index on materialized view
CREATE INDEX idx_monthly_summary_month ON monthly_transaction_summary(month);
CREATE INDEX idx_monthly_summary_account ON monthly_transaction_summary(account_id);

-- Function to refresh materialized view
CREATE OR REPLACE FUNCTION refresh_monthly_summary()
RETURNS VOID AS $$
BEGIN
    REFRESH MATERIALIZED VIEW monthly_transaction_summary;
END;
$$ LANGUAGE plpgsql;
```

## 3. Performance Optimization Practice Cases

### 3.1. Query Optimization

```sql
-- Analyze query performance
EXPLAIN (ANALYZE, BUFFERS) 
SELECT 
    p.name,
    p.price,
    c.name as category_name,
    COUNT(oi.order_item_id) as total_orders,
    SUM(oi.quantity) as total_quantity
FROM products p
JOIN categories c ON p.category_id = c.category_id
LEFT JOIN order_items oi ON p.product_id = oi.product_id
LEFT JOIN orders o ON oi.order_id = o.order_id
WHERE o.status = 'completed' OR o.status IS NULL
GROUP BY p.product_id, p.name, p.price, c.name
ORDER BY total_orders DESC;

-- Create composite index for better performance
CREATE INDEX idx_orders_status_date ON orders(status, order_date);
CREATE INDEX idx_order_items_product_quantity ON order_items(product_id, quantity);

-- Partition large tables by date
CREATE TABLE transactions_partitioned (
    LIKE transactions INCLUDING ALL
) PARTITION BY RANGE (transaction_date);

-- Create partitions for different months
CREATE TABLE transactions_2024_01 PARTITION OF transactions_partitioned
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

CREATE TABLE transactions_2024_02 PARTITION OF transactions_partitioned
    FOR VALUES FROM ('2024-02-01') TO ('2024-03-01');

-- Create function to automatically create partitions
CREATE OR REPLACE FUNCTION create_monthly_partition(table_name TEXT, start_date DATE)
RETURNS VOID AS $$
DECLARE
    partition_name TEXT;
    end_date DATE;
BEGIN
    partition_name := table_name || '_' || TO_CHAR(start_date, 'YYYY_MM');
    end_date := start_date + INTERVAL '1 month';
    
    EXECUTE format('CREATE TABLE %I PARTITION OF %I FOR VALUES FROM (%L) TO (%L)',
                   partition_name, table_name, start_date, end_date);
    
    RAISE NOTICE 'Created partition: %', partition_name;
END;
$$ LANGUAGE plpgsql;

-- Create function to analyze table statistics
CREATE OR REPLACE FUNCTION analyze_table_stats(table_name TEXT)
RETURNS TABLE (
    column_name TEXT,
    data_type TEXT,
    null_ratio DECIMAL(5,4),
    distinct_values BIGINT,
    most_common_values TEXT[]
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        c.column_name::TEXT,
        c.data_type::TEXT,
        c.null_ratio,
        c.n_distinct,
        c.most_common_vals::TEXT[]
    FROM pg_stats s
    JOIN information_schema.columns c ON s.attname = c.column_name
    WHERE s.tablename = table_name AND c.table_name = table_name;
END;
$$ LANGUAGE plpgsql;
```

### 3.2. Connection Pooling and Caching

```sql
-- Create connection pool configuration
-- Using pgBouncer configuration example

-- pgbouncer.ini
[databases]
ecommerce_db = host=localhost port=5432 dbname=ecommerce_db
financial_db = host=localhost port=5432 dbname=financial_db

[pgbouncer]
listen_addr = 127.0.0.1
listen_port = 6432
auth_type = md5
auth_file = /etc/pgbouncer/userlist.txt
pool_mode = transaction
max_client_conn = 1000
default_pool_size = 20
max_db_connections = 100
max_user_connections = 100

-- Create function to monitor connection usage
CREATE OR REPLACE FUNCTION get_connection_stats()
RETURNS TABLE (
    database_name TEXT,
    active_connections INTEGER,
    idle_connections INTEGER,
    total_connections INTEGER
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        d.datname::TEXT as database_name,
        COUNT(*) FILTER (WHERE state = 'active') as active_connections,
        COUNT(*) FILTER (WHERE state = 'idle') as idle_connections,
        COUNT(*) as total_connections
    FROM pg_stat_activity a
    JOIN pg_database d ON a.datid = d.oid
    WHERE a.pid <> pg_backend_pid()
    GROUP BY d.datname;
END;
$$ LANGUAGE plpgsql;

-- Create function to kill idle connections
CREATE OR REPLACE FUNCTION kill_idle_connections(max_idle_time INTERVAL DEFAULT '1 hour')
RETURNS INTEGER AS $$
DECLARE
    killed_count INTEGER := 0;
    conn_record RECORD;
BEGIN
    FOR conn_record IN 
        SELECT pid 
        FROM pg_stat_activity 
        WHERE state = 'idle' 
        AND state_change < NOW() - max_idle_time
        AND pid <> pg_backend_pid()
    LOOP
        PERFORM pg_terminate_backend(conn_record.pid);
        killed_count := killed_count + 1;
    END LOOP;
    
    RETURN killed_count;
END;
$$ LANGUAGE plpgsql;
```

## 4. High Availability Practice Cases

### 4.1. Replication Setup

```sql
-- Primary server configuration (postgresql.conf)
wal_level = replica
max_wal_senders = 3
max_replication_slots = 3
hot_standby = on

-- Create replication user
CREATE USER replicator REPLICATION LOGIN PASSWORD 'replicator_password';

-- Create replication slot
SELECT pg_create_physical_replication_slot('replica_1_slot');

-- Backup and restore for replica setup
-- On primary server
pg_basebackup -h localhost -D /var/lib/postgresql/12/replica -U replicator -v -P -W

-- On replica server (recovery.conf)
standby_mode = 'on'
primary_conninfo = 'host=primary_server port=5432 user=replicator password=replicator_password'
primary_slot_name = 'replica_1_slot'
restore_command = 'cp /var/lib/postgresql/12/archive/%f %p'
archive_cleanup_command = 'pg_archivecleanup /var/lib/postgresql/12/archive %r'

-- Create function to check replication lag
CREATE OR REPLACE FUNCTION get_replication_lag()
RETURNS TABLE (
    client_addr INET,
    application_name TEXT,
    backend_start TIMESTAMP,
    state TEXT,
    sent_lsn PG_LSN,
    write_lsn PG_LSN,
    flush_lsn PG_LSN,
    replay_lsn PG_LSN,
    lag_seconds INTEGER
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        s.client_addr,
        s.application_name,
        s.backend_start,
        s.state,
        s.sent_lsn,
        s.write_lsn,
        s.flush_lsn,
        s.replay_lsn,
        EXTRACT(EPOCH FROM (NOW() - s.replay_lag))::INTEGER as lag_seconds
    FROM pg_stat_replication s;
END;
$$ LANGUAGE plpgsql;

-- Create function to promote replica
CREATE OR REPLACE FUNCTION promote_replica()
RETURNS TEXT AS $$
BEGIN
    -- This function would be called on the replica to promote it to primary
    -- In practice, this would be done using pg_ctl promote
    RETURN 'Replica promotion initiated';
END;
$$ LANGUAGE plpgsql;
```

### 4.2. Backup and Recovery

```sql
-- Create function to perform logical backup
CREATE OR REPLACE FUNCTION perform_logical_backup(schema_name TEXT)
RETURNS TEXT AS $$
DECLARE
    backup_file TEXT;
    tables TEXT[];
    table_name TEXT;
BEGIN
    backup_file := '/var/backups/postgresql/' || schema_name || '_' || 
                   TO_CHAR(NOW(), 'YYYY_MM_DD_HH24_MI_SS') || '.sql';
    
    -- Get all tables in schema
    SELECT array_agg(tablename) INTO tables
    FROM pg_tables
    WHERE schemaname = schema_name;
    
    -- Perform backup using pg_dump
    FOR table_name IN SELECT unnest(tables)
    LOOP
        -- In practice, this would execute pg_dump command
        RAISE NOTICE 'Backing up table: %', table_name;
    END LOOP;
    
    RETURN 'Backup completed: ' || backup_file;
END;
$$ LANGUAGE plpgsql;

-- Create function to restore from backup
CREATE OR REPLACE FUNCTION restore_from_backup(backup_file TEXT)
RETURNS TEXT AS $$
BEGIN
    -- In practice, this would execute pg_restore command
    RAISE NOTICE 'Restoring from backup: %', backup_file;
    
    RETURN 'Restore completed from: ' || backup_file;
END;
$$ LANGUAGE plpgsql;

-- Create function to check backup status
CREATE OR REPLACE FUNCTION check_backup_status()
RETURNS TABLE (
    backup_file TEXT,
    backup_size BIGINT,
    backup_date TIMESTAMP,
    backup_type TEXT
) AS $$
BEGIN
    -- This would query backup metadata
    RETURN QUERY
    SELECT 
        'backup_file.sql'::TEXT,
        1024000::BIGINT,
        NOW()::TIMESTAMP,
        'logical'::TEXT;
END;
$$ LANGUAGE plpgsql;
```

## 5. Summary

This document provides practical application cases for PostgreSQL database, including:

1. **Database Design Practice**: E-commerce and financial database design
2. **Performance Optimization Practice**: Query optimization and connection pooling
3. **High Availability Practice**: Replication setup and backup/recovery

These cases demonstrate PostgreSQL applications in various domains, providing practical references and guidance for database projects.
