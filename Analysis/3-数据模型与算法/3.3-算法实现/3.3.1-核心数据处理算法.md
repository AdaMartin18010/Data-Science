# 3.3.1 æ ¸å¿ƒæ•°æ®å¤„ç†ç®—æ³•

## ğŸ“‘ ç›®å½•

- [3.3.1 æ ¸å¿ƒæ•°æ®å¤„ç†ç®—æ³•](#331-æ ¸å¿ƒæ•°æ®å¤„ç†ç®—æ³•)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ‘˜è¦](#1-æ‘˜è¦)
  - [2. æ’åºç®—æ³•](#2-æ’åºç®—æ³•)
    - [2.1. å¿«é€Ÿæ’åºï¼ˆQuick Sortï¼‰](#21-å¿«é€Ÿæ’åºquick-sort)
      - [2.1.1. ç®—æ³•åŸç†](#211-ç®—æ³•åŸç†)
      - [2.1.2. ç®—æ³•å®ç°](#212-ç®—æ³•å®ç°)
      - [2.1.3. å¤æ‚åº¦åˆ†æ](#213-å¤æ‚åº¦åˆ†æ)
      - [2.1.4. ä¼˜åŒ–ç­–ç•¥](#214-ä¼˜åŒ–ç­–ç•¥)
    - [2.2. å½’å¹¶æ’åºï¼ˆMerge Sortï¼‰](#22-å½’å¹¶æ’åºmerge-sort)
      - [2.2.1. ç®—æ³•åŸç†](#221-ç®—æ³•åŸç†)
      - [2.2.2. ç®—æ³•å®ç°](#222-ç®—æ³•å®ç°)
      - [2.2.3. å¤æ‚åº¦åˆ†æ](#223-å¤æ‚åº¦åˆ†æ)
    - [2.3. å †æ’åºï¼ˆHeap Sortï¼‰](#23-å †æ’åºheap-sort)
      - [2.3.1. ç®—æ³•åŸç†](#231-ç®—æ³•åŸç†)
      - [2.3.2. ç®—æ³•å®ç°](#232-ç®—æ³•å®ç°)
      - [2.3.3. å¤æ‚åº¦åˆ†æ](#233-å¤æ‚åº¦åˆ†æ)
    - [2.4. æ’åºç®—æ³•å¯¹æ¯”](#24-æ’åºç®—æ³•å¯¹æ¯”)
  - [3. æŸ¥æ‰¾ç®—æ³•](#3-æŸ¥æ‰¾ç®—æ³•)
    - [3.1. äºŒåˆ†æŸ¥æ‰¾ï¼ˆBinary Searchï¼‰](#31-äºŒåˆ†æŸ¥æ‰¾binary-search)
      - [3.1.1. ç®—æ³•åŸç†](#311-ç®—æ³•åŸç†)
      - [3.1.2. ç®—æ³•å®ç°](#312-ç®—æ³•å®ç°)
      - [3.1.3. å¤æ‚åº¦åˆ†æ](#313-å¤æ‚åº¦åˆ†æ)
    - [3.2. å“ˆå¸ŒæŸ¥æ‰¾ï¼ˆHash Searchï¼‰](#32-å“ˆå¸ŒæŸ¥æ‰¾hash-search)
      - [3.2.1. ç®—æ³•åŸç†](#321-ç®—æ³•åŸç†)
      - [3.2.2. ç®—æ³•å®ç°](#322-ç®—æ³•å®ç°)
      - [3.2.3. å¤æ‚åº¦åˆ†æ](#323-å¤æ‚åº¦åˆ†æ)
    - [3.3. æŸ¥æ‰¾ç®—æ³•å¯¹æ¯”](#33-æŸ¥æ‰¾ç®—æ³•å¯¹æ¯”)
  - [4. èšåˆç®—æ³•](#4-èšåˆç®—æ³•)
    - [4.1. åŸºæœ¬èšåˆå‡½æ•°](#41-åŸºæœ¬èšåˆå‡½æ•°)
      - [4.1.1. SUMï¼ˆæ±‚å’Œï¼‰](#411-sumæ±‚å’Œ)
      - [4.1.2. AVGï¼ˆå¹³å‡å€¼ï¼‰](#412-avgå¹³å‡å€¼)
      - [4.1.3. COUNTï¼ˆè®¡æ•°ï¼‰](#413-countè®¡æ•°)
      - [4.1.4. MAX/MINï¼ˆæœ€å¤§å€¼/æœ€å°å€¼ï¼‰](#414-maxminæœ€å¤§å€¼æœ€å°å€¼)
    - [4.2. åˆ†ç»„èšåˆ](#42-åˆ†ç»„èšåˆ)
      - [4.2.1. å“ˆå¸Œåˆ†ç»„èšåˆ](#421-å“ˆå¸Œåˆ†ç»„èšåˆ)
      - [4.2.2. æ’åºåˆ†ç»„èšåˆ](#422-æ’åºåˆ†ç»„èšåˆ)
    - [4.3. çª—å£å‡½æ•°](#43-çª—å£å‡½æ•°)
      - [4.3.1. çª—å£å‡½æ•°ç±»å‹](#431-çª—å£å‡½æ•°ç±»å‹)
  - [5. åˆ†ç»„ç®—æ³•](#5-åˆ†ç»„ç®—æ³•)
    - [5.1. å“ˆå¸Œåˆ†ç»„](#51-å“ˆå¸Œåˆ†ç»„)
    - [5.2. æ’åºåˆ†ç»„](#52-æ’åºåˆ†ç»„)
    - [5.3. æ··åˆåˆ†ç»„](#53-æ··åˆåˆ†ç»„)
  - [6. å¹¶è¡Œä¸åˆ†å¸ƒå¼å¤„ç†](#6-å¹¶è¡Œä¸åˆ†å¸ƒå¼å¤„ç†)
    - [6.1. MapReduceæ¨¡å‹](#61-mapreduceæ¨¡å‹)
      - [6.1.1. MapReduceæµç¨‹](#611-mapreduceæµç¨‹)
      - [6.1.2. å®ç°ç¤ºä¾‹](#612-å®ç°ç¤ºä¾‹)
    - [6.2. å¹¶è¡Œå½’çº¦](#62-å¹¶è¡Œå½’çº¦)
    - [6.3. åˆ†æ²»ç®—æ³•](#63-åˆ†æ²»ç®—æ³•)
  - [7. å®é™…åº”ç”¨æ¡ˆä¾‹](#7-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [7.1. æ•°æ®åº“æŸ¥è¯¢å¤„ç†](#71-æ•°æ®åº“æŸ¥è¯¢å¤„ç†)
    - [7.2. å¤§æ•°æ®å¤„ç†](#72-å¤§æ•°æ®å¤„ç†)
    - [7.3. å®æ—¶æµå¤„ç†](#73-å®æ—¶æµå¤„ç†)
  - [8. å½¢å¼åŒ–å®šä¹‰ä¸è¯æ˜](#8-å½¢å¼åŒ–å®šä¹‰ä¸è¯æ˜)
    - [8.1. æ’åºç®—æ³•çš„æ­£ç¡®æ€§](#81-æ’åºç®—æ³•çš„æ­£ç¡®æ€§)
    - [8.2. äºŒåˆ†æŸ¥æ‰¾çš„æ­£ç¡®æ€§](#82-äºŒåˆ†æŸ¥æ‰¾çš„æ­£ç¡®æ€§)
  - [9. å¤šè¡¨å¾](#9-å¤šè¡¨å¾)
  - [10. æ€»ç»“ä¸å±•æœ›](#10-æ€»ç»“ä¸å±•æœ›)
    - [10.1. æ€»ç»“](#101-æ€»ç»“)
    - [10.2. å‘å±•è¶‹åŠ¿](#102-å‘å±•è¶‹åŠ¿)
    - [10.3. æŒ‘æˆ˜ä¸æœºé‡](#103-æŒ‘æˆ˜ä¸æœºé‡)

## 1. æ‘˜è¦

æœ¬æ–‡ä»¶ç³»ç»Ÿæ¢³ç†æ•°æ®ç§‘å­¦é¢†åŸŸçš„æ ¸å¿ƒæ•°æ®å¤„ç†ç®—æ³•ï¼ŒåŒ…æ‹¬æ’åºã€æŸ¥æ‰¾ã€èšåˆã€åˆ†ç»„ã€å¹¶è¡Œå¤„ç†ç­‰ï¼Œæä¾›ç†è®ºåˆ†æã€ä¼ªä»£ç ã€Rust/Go/Pythonå®ç°ç¤ºä¾‹ã€‚

**æ ¸å¿ƒå†…å®¹**ï¼š

1. **æ’åºç®—æ³•**ï¼šå¿«é€Ÿæ’åºã€å½’å¹¶æ’åºã€å †æ’åºåŠå…¶å¤æ‚åº¦åˆ†æ
2. **æŸ¥æ‰¾ç®—æ³•**ï¼šäºŒåˆ†æŸ¥æ‰¾ã€å“ˆå¸ŒæŸ¥æ‰¾åŠå…¶åº”ç”¨åœºæ™¯
3. **èšåˆç®—æ³•**ï¼šSUMã€AVGã€COUNTã€MAXã€MINç­‰èšåˆå‡½æ•°
4. **åˆ†ç»„ç®—æ³•**ï¼šå“ˆå¸Œåˆ†ç»„ã€æ’åºåˆ†ç»„ç­‰åˆ†ç»„ç­–ç•¥
5. **å¹¶è¡Œå¤„ç†**ï¼šMapReduceã€å¹¶è¡Œå½’çº¦ã€åˆ†æ²»ç®—æ³•

---

## 2. æ’åºç®—æ³•

### 2.1. å¿«é€Ÿæ’åºï¼ˆQuick Sortï¼‰

**å¿«é€Ÿæ’åº**æ˜¯ä¸€ç§åˆ†æ²»ç®—æ³•ï¼Œé€šè¿‡é€‰æ‹©ä¸€ä¸ªåŸºå‡†å…ƒç´ ï¼Œå°†æ•°ç»„åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œç„¶åé€’å½’æ’åºã€‚

#### 2.1.1. ç®—æ³•åŸç†

**åŸºæœ¬æ€æƒ³**ï¼š

1. é€‰æ‹©ä¸€ä¸ªåŸºå‡†å…ƒç´ ï¼ˆpivotï¼‰
2. å°†æ•°ç»„åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼šå°äºåŸºå‡†çš„å…ƒç´ å’Œå¤§äºåŸºå‡†çš„å…ƒç´ 
3. é€’å½’åœ°å¯¹ä¸¤éƒ¨åˆ†è¿›è¡Œæ’åº

**å½¢å¼åŒ–å®šä¹‰**ï¼š

è®¾æ•°ç»„ $A = [a_1, a_2, \ldots, a_n]$ï¼Œå¿«é€Ÿæ’åºç®—æ³•å®šä¹‰ä¸ºï¼š

$$
\text{QuickSort}(A) = \begin{cases}
A & \text{if } |A| \leq 1 \\
\text{QuickSort}(L) \cup \{p\} \cup \text{QuickSort}(R) & \text{otherwise}
\end{cases}
$$

å…¶ä¸­ï¼š

- $p$ æ˜¯åŸºå‡†å…ƒç´ 
- $L = \{a \in A: a < p\}$
- $R = \{a \in A: a > p\}$

#### 2.1.2. ç®—æ³•å®ç°

**Pythonå®ç°**ï¼š

```python
def quick_sort(arr):
    """
    å¿«é€Ÿæ’åºç®—æ³•

    æ—¶é—´å¤æ‚åº¦ï¼š
    - å¹³å‡æƒ…å†µï¼šO(n log n)
    - æœ€åæƒ…å†µï¼šO(nÂ²)
    - æœ€å¥½æƒ…å†µï¼šO(n log n)

    ç©ºé—´å¤æ‚åº¦ï¼šO(log n)ï¼ˆé€’å½’æ ˆï¼‰
    """
    if len(arr) <= 1:
        return arr

    # é€‰æ‹©åŸºå‡†å…ƒç´ ï¼ˆè¿™é‡Œé€‰æ‹©ä¸­é—´å…ƒç´ ï¼‰
    pivot = arr[len(arr) // 2]

    # åˆ†å‰²æ•°ç»„
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]

    # é€’å½’æ’åºå¹¶åˆå¹¶
    return quick_sort(left) + middle + quick_sort(right)


# åŸåœ°æ’åºç‰ˆæœ¬ï¼ˆæ›´é«˜æ•ˆï¼‰
def quick_sort_inplace(arr, low=0, high=None):
    """åŸåœ°å¿«é€Ÿæ’åºï¼ŒèŠ‚çœç©ºé—´"""
    if high is None:
        high = len(arr) - 1

    if low < high:
        # åˆ†å‰²å¹¶è·å–åŸºå‡†ä½ç½®
        pivot_index = partition(arr, low, high)

        # é€’å½’æ’åºå·¦å³ä¸¤éƒ¨åˆ†
        quick_sort_inplace(arr, low, pivot_index - 1)
        quick_sort_inplace(arr, pivot_index + 1, high)


def partition(arr, low, high):
    """åˆ†å‰²å‡½æ•°ï¼Œè¿”å›åŸºå‡†å…ƒç´ çš„æœ€ç»ˆä½ç½®"""
    # é€‰æ‹©æœ€åä¸€ä¸ªå…ƒç´ ä½œä¸ºåŸºå‡†
    pivot = arr[high]

    # å°äºåŸºå‡†çš„å…ƒç´ ç´¢å¼•
    i = low - 1

    for j in range(low, high):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]

    # å°†åŸºå‡†å…ƒç´ æ”¾åˆ°æ­£ç¡®ä½ç½®
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1
```

**Rustå®ç°**ï¼š

```rust
/// å¿«é€Ÿæ’åºç®—æ³•ï¼ˆRustå®ç°ï¼‰
pub fn quick_sort<T: Ord + Clone>(arr: &mut [T]) {
    if arr.len() <= 1 {
        return;
    }

    let pivot_index = partition(arr);
    let (left, right) = arr.split_at_mut(pivot_index);
    quick_sort(left);
    quick_sort(&mut right[1..]);
}

fn partition<T: Ord>(arr: &mut [T]) -> usize {
    let pivot_index = arr.len() - 1;
    let mut i = 0;

    for j in 0..pivot_index {
        if arr[j] <= arr[pivot_index] {
            arr.swap(i, j);
            i += 1;
        }
    }

    arr.swap(i, pivot_index);
    i
}
```

**Goå®ç°**ï¼š

```go
// QuickSort å¿«é€Ÿæ’åºç®—æ³•ï¼ˆGoå®ç°ï¼‰
func QuickSort(arr []int) {
    if len(arr) <= 1 {
        return
    }

    pivotIndex := partition(arr)
    QuickSort(arr[:pivotIndex])
    QuickSort(arr[pivotIndex+1:])
}

func partition(arr []int) int {
    pivot := arr[len(arr)-1]
    i := 0

    for j := 0; j < len(arr)-1; j++ {
        if arr[j] <= pivot {
            arr[i], arr[j] = arr[j], arr[i]
            i++
        }
    }

    arr[i], arr[len(arr)-1] = arr[len(arr)-1], arr[i]
    return i
}
```

#### 2.1.3. å¤æ‚åº¦åˆ†æ

**æ—¶é—´å¤æ‚åº¦**ï¼š

- **å¹³å‡æƒ…å†µ**ï¼š$T(n) = O(n \log n)$
  - æ¯æ¬¡åˆ†å‰²å¤§çº¦å°†æ•°ç»„åˆ†ä¸ºä¸¤åŠ
  - é€’å½’æ·±åº¦ä¸º $\log n$
  - æ¯å±‚éœ€è¦ $O(n)$ æ—¶é—´

- **æœ€åæƒ…å†µ**ï¼š$T(n) = O(n^2)$
  - å½“åŸºå‡†å…ƒç´ æ€»æ˜¯æœ€å¤§æˆ–æœ€å°æ—¶
  - é€’å½’æ·±åº¦ä¸º $n$
  - æ¯å±‚éœ€è¦ $O(n)$ æ—¶é—´

- **æœ€å¥½æƒ…å†µ**ï¼š$T(n) = O(n \log n)$
  - æ¯æ¬¡åˆ†å‰²éƒ½å®Œç¾å¹³è¡¡

**ç©ºé—´å¤æ‚åº¦**ï¼š

- **å¹³å‡æƒ…å†µ**ï¼š$S(n) = O(\log n)$ï¼ˆé€’å½’æ ˆï¼‰
- **æœ€åæƒ…å†µ**ï¼š$S(n) = O(n)$ï¼ˆé€’å½’æ ˆï¼‰

#### 2.1.4. ä¼˜åŒ–ç­–ç•¥

1. **ä¸‰è·¯å¿«æ’**ï¼šå¤„ç†é‡å¤å…ƒç´ 
2. **éšæœºåŒ–åŸºå‡†**ï¼šé¿å…æœ€åæƒ…å†µ
3. **å°æ•°ç»„ä½¿ç”¨æ’å…¥æ’åº**ï¼šå‡å°‘é€’å½’å¼€é”€

### 2.2. å½’å¹¶æ’åºï¼ˆMerge Sortï¼‰

**å½’å¹¶æ’åº**æ˜¯ä¸€ç§ç¨³å®šçš„åˆ†æ²»æ’åºç®—æ³•ï¼Œå°†æ•°ç»„åˆ†ä¸ºä¸¤åŠï¼Œåˆ†åˆ«æ’åºååˆå¹¶ã€‚

#### 2.2.1. ç®—æ³•åŸç†

**åŸºæœ¬æ€æƒ³**ï¼š

1. å°†æ•°ç»„åˆ†ä¸ºä¸¤åŠ
2. é€’å½’åœ°å¯¹ä¸¤åŠè¿›è¡Œæ’åº
3. åˆå¹¶ä¸¤ä¸ªå·²æ’åºçš„å­æ•°ç»„

**å½¢å¼åŒ–å®šä¹‰**ï¼š

$$
\text{MergeSort}(A) = \begin{cases}
A & \text{if } |A| \leq 1 \\
\text{Merge}(\text{MergeSort}(L), \text{MergeSort}(R)) & \text{otherwise}
\end{cases}
$$

å…¶ä¸­ $L$ å’Œ $R$ æ˜¯æ•°ç»„çš„ä¸¤åŠã€‚

#### 2.2.2. ç®—æ³•å®ç°

**Pythonå®ç°**ï¼š

```python
def merge_sort(arr):
    """
    å½’å¹¶æ’åºç®—æ³•

    æ—¶é—´å¤æ‚åº¦ï¼š
    - æ‰€æœ‰æƒ…å†µï¼šO(n log n)

    ç©ºé—´å¤æ‚åº¦ï¼šO(n)
    """
    if len(arr) <= 1:
        return arr

    # åˆ†å‰²æ•°ç»„
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])

    # åˆå¹¶ä¸¤ä¸ªå·²æ’åºçš„å­æ•°ç»„
    return merge(left, right)


def merge(left, right):
    """åˆå¹¶ä¸¤ä¸ªå·²æ’åºçš„æ•°ç»„"""
    result = []
    i = j = 0

    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

    # æ·»åŠ å‰©ä½™å…ƒç´ 
    result.extend(left[i:])
    result.extend(right[j:])

    return result
```

**Rustå®ç°**ï¼š

```rust
/// å½’å¹¶æ’åºç®—æ³•ï¼ˆRustå®ç°ï¼‰
pub fn merge_sort<T: Ord + Clone>(arr: &[T]) -> Vec<T> {
    if arr.len() <= 1 {
        return arr.to_vec();
    }

    let mid = arr.len() / 2;
    let left = merge_sort(&arr[..mid]);
    let right = merge_sort(&arr[mid..]);

    merge(&left, &right)
}

fn merge<T: Ord + Clone>(left: &[T], right: &[T]) -> Vec<T> {
    let mut result = Vec::with_capacity(left.len() + right.len());
    let mut i = 0;
    let mut j = 0;

    while i < left.len() && j < right.len() {
        if left[i] <= right[j] {
            result.push(left[i].clone());
            i += 1;
        } else {
            result.push(right[j].clone());
            j += 1;
        }
    }

    result.extend_from_slice(&left[i..]);
    result.extend_from_slice(&right[j..]);
    result
}
```

#### 2.2.3. å¤æ‚åº¦åˆ†æ

**æ—¶é—´å¤æ‚åº¦**ï¼š

- **æ‰€æœ‰æƒ…å†µ**ï¼š$T(n) = O(n \log n)$
  - é€’å½’æ·±åº¦ï¼š$\log n$
  - æ¯å±‚åˆå¹¶ï¼š$O(n)$

**ç©ºé—´å¤æ‚åº¦**ï¼š

- $S(n) = O(n)$ï¼ˆéœ€è¦ä¸´æ—¶æ•°ç»„ï¼‰

**ç¨³å®šæ€§**ï¼šç¨³å®šæ’åºç®—æ³•

### 2.3. å †æ’åºï¼ˆHeap Sortï¼‰

**å †æ’åº**åˆ©ç”¨å †æ•°æ®ç»“æ„è¿›è¡Œæ’åºï¼Œæ˜¯ä¸€ç§åŸåœ°æ’åºç®—æ³•ã€‚

#### 2.3.1. ç®—æ³•åŸç†

**åŸºæœ¬æ€æƒ³**ï¼š

1. æ„å»ºæœ€å¤§å †ï¼ˆæˆ–æœ€å°å †ï¼‰
2. å°†å †é¡¶å…ƒç´ ä¸æœ€åä¸€ä¸ªå…ƒç´ äº¤æ¢
3. å‡å°å †å¤§å°ï¼Œé‡æ–°å †åŒ–
4. é‡å¤æ­¥éª¤2-3ç›´åˆ°å †ä¸ºç©º

**å½¢å¼åŒ–å®šä¹‰**ï¼š

$$\text{HeapSort}(A) = \text{ExtractMax}(\text{BuildHeap}(A))$$

#### 2.3.2. ç®—æ³•å®ç°

**Pythonå®ç°**ï¼š

```python
def heap_sort(arr):
    """
    å †æ’åºç®—æ³•

    æ—¶é—´å¤æ‚åº¦ï¼š
    - æ‰€æœ‰æƒ…å†µï¼šO(n log n)

    ç©ºé—´å¤æ‚åº¦ï¼šO(1)ï¼ˆåŸåœ°æ’åºï¼‰
    """
    n = len(arr)

    # æ„å»ºæœ€å¤§å †
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    # é€ä¸ªæå–å †é¡¶å…ƒç´ 
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]  # äº¤æ¢
        heapify(arr, i, 0)  # é‡æ–°å †åŒ–


def heapify(arr, n, i):
    """å †åŒ–å‡½æ•°ï¼Œç»´æŠ¤å †æ€§è´¨"""
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    # æ‰¾åˆ°æœ€å¤§å€¼
    if left < n and arr[left] > arr[largest]:
        largest = left

    if right < n and arr[right] > arr[largest]:
        largest = right

    # å¦‚æœéœ€è¦äº¤æ¢ï¼Œé€’å½’å †åŒ–
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)
```

**Rustå®ç°**ï¼š

```rust
/// å †æ’åºç®—æ³•ï¼ˆRustå®ç°ï¼‰
pub fn heap_sort<T: Ord>(arr: &mut [T]) {
    let n = arr.len();

    // æ„å»ºæœ€å¤§å †
    for i in (0..n / 2).rev() {
        heapify(arr, n, i);
    }

    // é€ä¸ªæå–å †é¡¶å…ƒç´ 
    for i in (1..n).rev() {
        arr.swap(0, i);
        heapify(arr, i, 0);
    }
}

fn heapify<T: Ord>(arr: &mut [T], n: usize, i: usize) {
    let mut largest = i;
    let left = 2 * i + 1;
    let right = 2 * i + 2;

    if left < n && arr[left] > arr[largest] {
        largest = left;
    }

    if right < n && arr[right] > arr[largest] {
        largest = right;
    }

    if largest != i {
        arr.swap(i, largest);
        heapify(arr, n, largest);
    }
}
```

#### 2.3.3. å¤æ‚åº¦åˆ†æ

**æ—¶é—´å¤æ‚åº¦**ï¼š

- **æ‰€æœ‰æƒ…å†µ**ï¼š$T(n) = O(n \log n)$
  - æ„å»ºå †ï¼š$O(n)$
  - æå–å…ƒç´ ï¼š$O(n \log n)$

**ç©ºé—´å¤æ‚åº¦**ï¼š

- $S(n) = O(1)$ï¼ˆåŸåœ°æ’åºï¼‰

### 2.4. æ’åºç®—æ³•å¯¹æ¯”

| ç®—æ³• | å¹³å‡æ—¶é—´å¤æ‚åº¦ | æœ€åæ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | ç¨³å®šæ€§ | é€‚ç”¨åœºæ™¯ |
|------|--------------|--------------|-----------|--------|---------|
| **å¿«é€Ÿæ’åº** | $O(n \log n)$ | $O(n^2)$ | $O(\log n)$ | ä¸ç¨³å®š | é€šç”¨æ’åº |
| **å½’å¹¶æ’åº** | $O(n \log n)$ | $O(n \log n)$ | $O(n)$ | ç¨³å®š | éœ€è¦ç¨³å®šæ€§ |
| **å †æ’åº** | $O(n \log n)$ | $O(n \log n)$ | $O(1)$ | ä¸ç¨³å®š | å†…å­˜å—é™ |
| **æ’å…¥æ’åº** | $O(n^2)$ | $O(n^2)$ | $O(1)$ | ç¨³å®š | å°æ•°ç»„ |
| **å†’æ³¡æ’åº** | $O(n^2)$ | $O(n^2)$ | $O(1)$ | ç¨³å®š | æ•™å­¦ç¤ºä¾‹ |

---

## 3. æŸ¥æ‰¾ç®—æ³•

### 3.1. äºŒåˆ†æŸ¥æ‰¾ï¼ˆBinary Searchï¼‰

**äºŒåˆ†æŸ¥æ‰¾**æ˜¯ä¸€ç§åœ¨æœ‰åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç®—æ³•ã€‚

#### 3.1.1. ç®—æ³•åŸç†

**åŸºæœ¬æ€æƒ³**ï¼š

1. æ¯”è¾ƒç›®æ ‡å€¼ä¸æ•°ç»„ä¸­é—´å…ƒç´ 
2. å¦‚æœç›¸ç­‰ï¼Œè¿”å›ç´¢å¼•
3. å¦‚æœç›®æ ‡å€¼å°äºä¸­é—´å…ƒç´ ï¼Œåœ¨å·¦åŠéƒ¨åˆ†æŸ¥æ‰¾
4. å¦‚æœç›®æ ‡å€¼å¤§äºä¸­é—´å…ƒç´ ï¼Œåœ¨å³åŠéƒ¨åˆ†æŸ¥æ‰¾

**å½¢å¼åŒ–å®šä¹‰**ï¼š

$$
\text{BinarySearch}(A, x, l, r) = \begin{cases}
-1 & \text{if } l > r \\
m & \text{if } A[m] = x \\
\text{BinarySearch}(A, x, l, m-1) & \text{if } A[m] > x \\
\text{BinarySearch}(A, x, m+1, r) & \text{if } A[m] < x
\end{cases}
$$

å…¶ä¸­ $m = \lfloor (l + r) / 2 \rfloor$ã€‚

#### 3.1.2. ç®—æ³•å®ç°

**Pythonå®ç°**ï¼š

```python
def binary_search(arr, target):
    """
    äºŒåˆ†æŸ¥æ‰¾ç®—æ³•

    æ—¶é—´å¤æ‚åº¦ï¼šO(log n)
    ç©ºé—´å¤æ‚åº¦ï¼šO(1)ï¼ˆè¿­ä»£ç‰ˆæœ¬ï¼‰æˆ– O(log n)ï¼ˆé€’å½’ç‰ˆæœ¬ï¼‰

    å‰ææ¡ä»¶ï¼šæ•°ç»„å¿…é¡»æ˜¯æœ‰åºçš„
    """
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = (left + right) // 2

        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return -1  # æœªæ‰¾åˆ°


# é€’å½’ç‰ˆæœ¬
def binary_search_recursive(arr, target, left=0, right=None):
    """é€’å½’ç‰ˆæœ¬çš„äºŒåˆ†æŸ¥æ‰¾"""
    if right is None:
        right = len(arr) - 1

    if left > right:
        return -1

    mid = (left + right) // 2

    if arr[mid] == target:
        return mid
    elif arr[mid] < target:
        return binary_search_recursive(arr, target, mid + 1, right)
    else:
        return binary_search_recursive(arr, target, left, mid - 1)
```

**Rustå®ç°**ï¼š

```rust
/// äºŒåˆ†æŸ¥æ‰¾ç®—æ³•ï¼ˆRustå®ç°ï¼‰
pub fn binary_search<T: Ord>(arr: &[T], target: &T) -> Option<usize> {
    let mut left = 0;
    let mut right = arr.len();

    while left < right {
        let mid = left + (right - left) / 2;

        match arr[mid].cmp(target) {
            std::cmp::Ordering::Equal => return Some(mid),
            std::cmp::Ordering::Less => left = mid + 1,
            std::cmp::Ordering::Greater => right = mid,
        }
    }

    None
}
```

**Goå®ç°**ï¼š

```go
// BinarySearch äºŒåˆ†æŸ¥æ‰¾ç®—æ³•ï¼ˆGoå®ç°ï¼‰
func BinarySearch(arr []int, target int) int {
    left, right := 0, len(arr)-1

    for left <= right {
        mid := left + (right-left)/2

        if arr[mid] == target {
            return mid
        } else if arr[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }

    return -1
}
```

#### 3.1.3. å¤æ‚åº¦åˆ†æ

**æ—¶é—´å¤æ‚åº¦**ï¼š

- $T(n) = O(\log n)$
  - æ¯æ¬¡æ¯”è¾ƒå°†æœç´¢ç©ºé—´å‡åŠ
  - æœ€å¤šéœ€è¦ $\log_2 n$ æ¬¡æ¯”è¾ƒ

**ç©ºé—´å¤æ‚åº¦**ï¼š

- è¿­ä»£ç‰ˆæœ¬ï¼š$O(1)$
- é€’å½’ç‰ˆæœ¬ï¼š$O(\log n)$ï¼ˆé€’å½’æ ˆï¼‰

### 3.2. å“ˆå¸ŒæŸ¥æ‰¾ï¼ˆHash Searchï¼‰

**å“ˆå¸ŒæŸ¥æ‰¾**åˆ©ç”¨å“ˆå¸Œè¡¨å®ç°å¿«é€ŸæŸ¥æ‰¾ã€‚

#### 3.2.1. ç®—æ³•åŸç†

**åŸºæœ¬æ€æƒ³**ï¼š

1. ä½¿ç”¨å“ˆå¸Œå‡½æ•°å°†é”®æ˜ å°„åˆ°æ•°ç»„ç´¢å¼•
2. å¤„ç†å“ˆå¸Œå†²çªï¼ˆé“¾åœ°å€æ³•æˆ–å¼€æ”¾åœ°å€æ³•ï¼‰
3. åœ¨å“ˆå¸Œè¡¨ä¸­æŸ¥æ‰¾å…ƒç´ 

**å½¢å¼åŒ–å®šä¹‰**ï¼š

$$\text{HashSearch}(H, k) = H[h(k)]$$

å…¶ä¸­ $h$ æ˜¯å“ˆå¸Œå‡½æ•°ï¼Œ$H$ æ˜¯å“ˆå¸Œè¡¨ã€‚

#### 3.2.2. ç®—æ³•å®ç°

**Pythonå®ç°**ï¼š

```python
class HashTable:
    """å“ˆå¸Œè¡¨å®ç°ï¼ˆä½¿ç”¨é“¾åœ°å€æ³•å¤„ç†å†²çªï¼‰"""

    def __init__(self, size=10):
        self.size = size
        self.table = [[] for _ in range(size)]

    def _hash(self, key):
        """å“ˆå¸Œå‡½æ•°"""
        return hash(key) % self.size

    def insert(self, key, value):
        """æ’å…¥é”®å€¼å¯¹"""
        index = self._hash(key)
        bucket = self.table[index]

        # æ£€æŸ¥é”®æ˜¯å¦å·²å­˜åœ¨
        for i, (k, v) in enumerate(bucket):
            if k == key:
                bucket[i] = (key, value)
                return

        # æ·»åŠ æ–°é”®å€¼å¯¹
        bucket.append((key, value))

    def search(self, key):
        """æŸ¥æ‰¾é”®å¯¹åº”çš„å€¼"""
        index = self._hash(key)
        bucket = self.table[index]

        for k, v in bucket:
            if k == key:
                return v

        return None  # æœªæ‰¾åˆ°

    def delete(self, key):
        """åˆ é™¤é”®å€¼å¯¹"""
        index = self._hash(key)
        bucket = self.table[index]

        for i, (k, v) in enumerate(bucket):
            if k == key:
                del bucket[i]
                return True

        return False  # æœªæ‰¾åˆ°
```

**Rustå®ç°**ï¼š

```rust
use std::collections::HashMap;

/// å“ˆå¸ŒæŸ¥æ‰¾ï¼ˆä½¿ç”¨æ ‡å‡†åº“ï¼‰
pub fn hash_search(map: &HashMap<i32, String>, key: &i32) -> Option<&String> {
    map.get(key)
}

/// è‡ªå®šä¹‰å“ˆå¸Œè¡¨å®ç°
pub struct HashTable<K, V> {
    buckets: Vec<Vec<(K, V)>>,
    size: usize,
}

impl<K: std::hash::Hash + Eq, V> HashTable<K, V> {
    pub fn new(size: usize) -> Self {
        HashTable {
            buckets: vec![Vec::new(); size],
            size,
        }
    }

    fn hash(&self, key: &K) -> usize {
        use std::hash::{Hash, Hasher};
        let mut hasher = std::collections::hash_map::DefaultHasher::new();
        key.hash(&mut hasher);
        (hasher.finish() as usize) % self.size
    }

    pub fn insert(&mut self, key: K, value: V) {
        let index = self.hash(&key);
        let bucket = &mut self.buckets[index];

        for (k, v) in bucket.iter_mut() {
            if k == &key {
                *v = value;
                return;
            }
        }

        bucket.push((key, value));
    }

    pub fn search(&self, key: &K) -> Option<&V> {
        let index = self.hash(key);
        let bucket = &self.buckets[index];

        for (k, v) in bucket {
            if k == key {
                return Some(v);
            }
        }

        None
    }
}
```

#### 3.2.3. å¤æ‚åº¦åˆ†æ

**æ—¶é—´å¤æ‚åº¦**ï¼š

- **å¹³å‡æƒ…å†µ**ï¼š$O(1)$
- **æœ€åæƒ…å†µ**ï¼š$O(n)$ï¼ˆæ‰€æœ‰å…ƒç´ å“ˆå¸Œåˆ°åŒä¸€ä½ç½®ï¼‰

**ç©ºé—´å¤æ‚åº¦**ï¼š

- $O(n)$ï¼ˆå­˜å‚¨æ‰€æœ‰å…ƒç´ ï¼‰

### 3.3. æŸ¥æ‰¾ç®—æ³•å¯¹æ¯”

| ç®—æ³• | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | å‰ææ¡ä»¶ | é€‚ç”¨åœºæ™¯ |
|------|-----------|-----------|---------|---------|
| **äºŒåˆ†æŸ¥æ‰¾** | $O(\log n)$ | $O(1)$ | æœ‰åºæ•°ç»„ | é™æ€æŸ¥æ‰¾ |
| **å“ˆå¸ŒæŸ¥æ‰¾** | $O(1)$ å¹³å‡ | $O(n)$ | æ—  | åŠ¨æ€æŸ¥æ‰¾ |
| **çº¿æ€§æŸ¥æ‰¾** | $O(n)$ | $O(1)$ | æ—  | å°æ•°ç»„ |

---

## 4. èšåˆç®—æ³•

### 4.1. åŸºæœ¬èšåˆå‡½æ•°

**èšåˆå‡½æ•°**å¯¹ä¸€ç»„å€¼è¿›è¡Œè®¡ç®—ï¼Œè¿”å›å•ä¸ªå€¼ã€‚

#### 4.1.1. SUMï¼ˆæ±‚å’Œï¼‰

**å®šä¹‰**ï¼š

$$\text{SUM}(A) = \sum_{i=1}^{n} a_i$$

**å®ç°**ï¼š

```python
def sum_aggregate(values):
    """æ±‚å’Œèšåˆå‡½æ•°"""
    return sum(values)


# æµå¼å¤„ç†ç‰ˆæœ¬ï¼ˆé€‚ç”¨äºå¤§æ•°æ®ï¼‰
def sum_stream(iterator):
    """æµå¼æ±‚å’Œï¼Œé€‚ç”¨äºå¤§æ•°æ®é›†"""
    total = 0
    for value in iterator:
        total += value
    return total
```

**SQLå®ç°**ï¼š

```sql
SELECT SUM(amount) FROM orders;
```

#### 4.1.2. AVGï¼ˆå¹³å‡å€¼ï¼‰

**å®šä¹‰**ï¼š

$$\text{AVG}(A) = \frac{1}{n} \sum_{i=1}^{n} a_i = \frac{\text{SUM}(A)}{n}$$

**å®ç°**ï¼š

```python
def avg_aggregate(values):
    """å¹³å‡å€¼èšåˆå‡½æ•°"""
    if not values:
        return None
    return sum(values) / len(values)


# æµå¼å¤„ç†ç‰ˆæœ¬ï¼ˆé¿å…å­˜å‚¨æ‰€æœ‰å€¼ï¼‰
def avg_stream(iterator):
    """æµå¼è®¡ç®—å¹³å‡å€¼"""
    total = 0
    count = 0
    for value in iterator:
        total += value
        count += 1
    return total / count if count > 0 else None
```

**SQLå®ç°**ï¼š

```sql
SELECT AVG(amount) FROM orders;
```

#### 4.1.3. COUNTï¼ˆè®¡æ•°ï¼‰

**å®šä¹‰**ï¼š

$$\text{COUNT}(A) = |A| = n$$

**å®ç°**ï¼š

```python
def count_aggregate(values):
    """è®¡æ•°èšåˆå‡½æ•°"""
    return len(values)


# æµå¼å¤„ç†ç‰ˆæœ¬
def count_stream(iterator):
    """æµå¼è®¡æ•°"""
    count = 0
    for _ in iterator:
        count += 1
    return count
```

**SQLå®ç°**ï¼š

```sql
SELECT COUNT(*) FROM orders;
SELECT COUNT(DISTINCT user_id) FROM orders;
```

#### 4.1.4. MAX/MINï¼ˆæœ€å¤§å€¼/æœ€å°å€¼ï¼‰

**å®šä¹‰**ï¼š

$$\text{MAX}(A) = \max_{i=1}^{n} a_i$$

$$\text{MIN}(A) = \min_{i=1}^{n} a_i$$

**å®ç°**ï¼š

```python
def max_aggregate(values):
    """æœ€å¤§å€¼èšåˆå‡½æ•°"""
    if not values:
        return None
    return max(values)


def min_aggregate(values):
    """æœ€å°å€¼èšåˆå‡½æ•°"""
    if not values:
        return None
    return min(values)


# æµå¼å¤„ç†ç‰ˆæœ¬
def max_stream(iterator):
    """æµå¼è®¡ç®—æœ€å¤§å€¼"""
    max_val = None
    for value in iterator:
        if max_val is None or value > max_val:
            max_val = value
    return max_val
```

**SQLå®ç°**ï¼š

```sql
SELECT MAX(amount) FROM orders;
SELECT MIN(amount) FROM orders;
```

### 4.2. åˆ†ç»„èšåˆ

**åˆ†ç»„èšåˆ**å…ˆæŒ‰æŸä¸ªé”®åˆ†ç»„ï¼Œç„¶åå¯¹æ¯ç»„è¿›è¡Œèšåˆã€‚

#### 4.2.1. å“ˆå¸Œåˆ†ç»„èšåˆ

**ç®—æ³•æµç¨‹**ï¼š

1. ä½¿ç”¨å“ˆå¸Œè¡¨æŒ‰åˆ†ç»„é”®åˆ†ç»„
2. å¯¹æ¯ç»„åº”ç”¨èšåˆå‡½æ•°
3. è¿”å›ç»“æœ

**å®ç°**ï¼š

```python
def group_by_aggregate(data, group_key, agg_func):
    """
    åˆ†ç»„èšåˆå‡½æ•°

    å‚æ•°ï¼š
    - data: æ•°æ®åˆ—è¡¨ï¼Œæ¯ä¸ªå…ƒç´ æ˜¯å­—å…¸
    - group_key: åˆ†ç»„é”®ï¼ˆå‡½æ•°æˆ–å­—ç¬¦ä¸²ï¼‰
    - agg_func: èšåˆå‡½æ•°

    è¿”å›ï¼šåˆ†ç»„èšåˆç»“æœ
    """
    groups = {}

    # åˆ†ç»„
    for item in data:
        key = group_key(item) if callable(group_key) else item[group_key]
        if key not in groups:
            groups[key] = []
        groups[key].append(item)

    # èšåˆ
    result = {}
    for key, group in groups.items():
        result[key] = agg_func(group)

    return result


# ä½¿ç”¨ç¤ºä¾‹
data = [
    {'user_id': 1, 'amount': 100},
    {'user_id': 1, 'amount': 200},
    {'user_id': 2, 'amount': 150},
]

# æŒ‰user_idåˆ†ç»„ï¼Œè®¡ç®—æ€»é‡‘é¢
result = group_by_aggregate(
    data,
    group_key='user_id',
    agg_func=lambda group: sum(item['amount'] for item in group)
)
# ç»“æœ: {1: 300, 2: 150}
```

**SQLå®ç°**ï¼š

```sql
SELECT user_id, SUM(amount)
FROM orders
GROUP BY user_id;
```

#### 4.2.2. æ’åºåˆ†ç»„èšåˆ

**ç®—æ³•æµç¨‹**ï¼š

1. æŒ‰åˆ†ç»„é”®æ’åº
2. éå†æ’åºåçš„æ•°æ®ï¼Œè¯†åˆ«åˆ†ç»„è¾¹ç•Œ
3. å¯¹æ¯ç»„åº”ç”¨èšåˆå‡½æ•°

**å®ç°**ï¼š

```python
def group_by_sort_aggregate(data, group_key, agg_func):
    """ä½¿ç”¨æ’åºçš„åˆ†ç»„èšåˆï¼ˆé€‚ç”¨äºéœ€è¦æœ‰åºç»“æœçš„åœºæ™¯ï¼‰"""
    # æ’åº
    sorted_data = sorted(data, key=lambda x: group_key(x) if callable(group_key) else x[group_key])

    result = []
    current_key = None
    current_group = []

    for item in sorted_data:
        key = group_key(item) if callable(group_key) else item[group_key]

        if key != current_key:
            # å¤„ç†å‰ä¸€ç»„
            if current_group:
                result.append({
                    'key': current_key,
                    'value': agg_func(current_group)
                })
            # å¼€å§‹æ–°ç»„
            current_key = key
            current_group = [item]
        else:
            current_group.append(item)

    # å¤„ç†æœ€åä¸€ç»„
    if current_group:
        result.append({
            'key': current_key,
            'value': agg_func(current_group)
        })

    return result
```

### 4.3. çª—å£å‡½æ•°

**çª—å£å‡½æ•°**å¯¹ä¸€ç»„ç›¸å…³çš„è¡Œè¿›è¡Œè®¡ç®—ï¼Œè€Œä¸å°†ç»“æœåˆå¹¶ä¸ºå•è¡Œã€‚

#### 4.3.1. çª—å£å‡½æ•°ç±»å‹

1. **èšåˆçª—å£å‡½æ•°**ï¼šSUMã€AVGã€COUNTç­‰
2. **æ’åçª—å£å‡½æ•°**ï¼šRANKã€DENSE_RANKã€ROW_NUMBER
3. **å€¼çª—å£å‡½æ•°**ï¼šLAGã€LEADã€FIRST_VALUEã€LAST_VALUE

**SQLç¤ºä¾‹**ï¼š

```sql
-- è®¡ç®—æ¯ä¸ªç”¨æˆ·çš„ç´¯è®¡è®¢å•é‡‘é¢
SELECT
    user_id,
    order_date,
    amount,
    SUM(amount) OVER (PARTITION BY user_id ORDER BY order_date) AS cumulative_amount
FROM orders;

-- è®¡ç®—æ¯ä¸ªç”¨æˆ·çš„è®¢å•æ’å
SELECT
    user_id,
    order_date,
    amount,
    ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY order_date DESC) AS order_rank
FROM orders;
```

---

## 5. åˆ†ç»„ç®—æ³•

### 5.1. å“ˆå¸Œåˆ†ç»„

**å“ˆå¸Œåˆ†ç»„**ä½¿ç”¨å“ˆå¸Œè¡¨å¿«é€Ÿåˆ†ç»„ã€‚

**ç®—æ³•å¤æ‚åº¦**ï¼š

- æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$
- ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$

**å®ç°**ï¼š

```python
def hash_group(data, key_func):
    """å“ˆå¸Œåˆ†ç»„"""
    groups = {}
    for item in data:
        key = key_func(item)
        if key not in groups:
            groups[key] = []
        groups[key].append(item)
    return groups
```

### 5.2. æ’åºåˆ†ç»„

**æ’åºåˆ†ç»„**å…ˆæ’åºååˆ†ç»„ã€‚

**ç®—æ³•å¤æ‚åº¦**ï¼š

- æ—¶é—´å¤æ‚åº¦ï¼š$O(n \log n)$
- ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$

**å®ç°**ï¼š

```python
def sort_group(data, key_func):
    """æ’åºåˆ†ç»„"""
    sorted_data = sorted(data, key=key_func)
    groups = []
    current_key = None
    current_group = []

    for item in sorted_data:
        key = key_func(item)
        if key != current_key:
            if current_group:
                groups.append((current_key, current_group))
            current_key = key
            current_group = [item]
        else:
            current_group.append(item)

    if current_group:
        groups.append((current_key, current_group))

    return groups
```

### 5.3. æ··åˆåˆ†ç»„

**æ··åˆåˆ†ç»„**ç»“åˆå“ˆå¸Œå’Œæ’åºçš„ä¼˜åŠ¿ã€‚

**ç­–ç•¥**ï¼š

- å°æ•°æ®é›†ï¼šä½¿ç”¨å“ˆå¸Œåˆ†ç»„
- å¤§æ•°æ®é›†ï¼šä½¿ç”¨æ’åºåˆ†ç»„ï¼ˆæ›´å¥½çš„ç¼“å­˜å±€éƒ¨æ€§ï¼‰

---

## 6. å¹¶è¡Œä¸åˆ†å¸ƒå¼å¤„ç†

### 6.1. MapReduceæ¨¡å‹

**MapReduce**æ˜¯ä¸€ç§ç¼–ç¨‹æ¨¡å‹ï¼Œç”¨äºå¤„ç†å’Œç”Ÿæˆå¤§æ•°æ®é›†ã€‚

#### 6.1.1. MapReduceæµç¨‹

1. **Mapé˜¶æ®µ**ï¼šå°†è¾“å…¥æ•°æ®æ˜ å°„ä¸ºé”®å€¼å¯¹
2. **Shuffleé˜¶æ®µ**ï¼šæŒ‰é”®åˆ†ç»„
3. **Reduceé˜¶æ®µ**ï¼šå¯¹æ¯ç»„è¿›è¡Œå½’çº¦

**å½¢å¼åŒ–å®šä¹‰**ï¼š

$$\text{MapReduce}(D) = \text{Reduce}(\text{Shuffle}(\text{Map}(D)))$$

#### 6.1.2. å®ç°ç¤ºä¾‹

**Pythonå®ç°ï¼ˆç®€åŒ–ç‰ˆï¼‰**ï¼š

```python
def map_reduce(data, map_func, reduce_func):
    """
    MapReduceå®ç°

    å‚æ•°ï¼š
    - data: è¾“å…¥æ•°æ®
    - map_func: Mapå‡½æ•°ï¼Œè¾“å…¥ä¸€ä¸ªå…ƒç´ ï¼Œè¾“å‡ºé”®å€¼å¯¹åˆ—è¡¨
    - reduce_func: Reduceå‡½æ•°ï¼Œè¾“å…¥é”®å’Œå€¼åˆ—è¡¨ï¼Œè¾“å‡ºç»“æœ
    """
    # Mapé˜¶æ®µ
    mapped = []
    for item in data:
        mapped.extend(map_func(item))

    # Shuffleé˜¶æ®µï¼ˆåˆ†ç»„ï¼‰
    groups = {}
    for key, value in mapped:
        if key not in groups:
            groups[key] = []
        groups[key].append(value)

    # Reduceé˜¶æ®µ
    result = []
    for key, values in groups.items():
        result.append((key, reduce_func(key, values)))

    return result


# ä½¿ç”¨ç¤ºä¾‹ï¼šè¯é¢‘ç»Ÿè®¡
def word_count_map(doc):
    """Mapå‡½æ•°ï¼šå°†æ–‡æ¡£åˆ†å‰²ä¸ºå•è¯"""
    words = doc.split()
    return [(word, 1) for word in words]


def word_count_reduce(key, values):
    """Reduceå‡½æ•°ï¼šç»Ÿè®¡å•è¯å‡ºç°æ¬¡æ•°"""
    return sum(values)


# ä½¿ç”¨
documents = ["hello world", "hello python", "world python"]
result = map_reduce(documents, word_count_map, word_count_reduce)
# ç»“æœ: [('hello', 2), ('world', 2), ('python', 2)]
```

### 6.2. å¹¶è¡Œå½’çº¦

**å¹¶è¡Œå½’çº¦**å°†å½’çº¦æ“ä½œå¹¶è¡ŒåŒ–ã€‚

**å®ç°**ï¼š

```python
from multiprocessing import Pool

def parallel_reduce(data, reduce_func, num_workers=4):
    """å¹¶è¡Œå½’çº¦"""
    # åˆ†å‰²æ•°æ®
    chunk_size = len(data) // num_workers
    chunks = [data[i:i+chunk_size] for i in range(0, len(data), chunk_size)]

    # å¹¶è¡Œå¤„ç†
    with Pool(num_workers) as pool:
        results = pool.map(reduce_func, chunks)

    # åˆå¹¶ç»“æœ
    return reduce_func(results)
```

### 6.3. åˆ†æ²»ç®—æ³•

**åˆ†æ²»ç®—æ³•**å°†é—®é¢˜åˆ†è§£ä¸ºå­é—®é¢˜ï¼Œé€’å½’æ±‚è§£ååˆå¹¶ã€‚

**é€šç”¨æ¨¡æ¿**ï¼š

```python
def divide_and_conquer(problem):
    """åˆ†æ²»ç®—æ³•æ¨¡æ¿"""
    # åŸºæœ¬æƒ…å†µ
    if is_base_case(problem):
        return solve_base_case(problem)

    # åˆ†è§£
    subproblems = divide(problem)

    # é€’å½’æ±‚è§£
    subresults = [divide_and_conquer(sub) for sub in subproblems]

    # åˆå¹¶
    return combine(subresults)
```

---

## 7. å®é™…åº”ç”¨æ¡ˆä¾‹

### 7.1. æ•°æ®åº“æŸ¥è¯¢å¤„ç†

**æ’åºæ“ä½œ**ï¼š

```sql
-- ä½¿ç”¨ç´¢å¼•æ’åºï¼ˆé¿å…å®é™…æ’åºï¼‰
SELECT * FROM users ORDER BY id;

-- å¤–éƒ¨æ’åºï¼ˆå¤§æ•°æ®é›†ï¼‰
SELECT * FROM large_table ORDER BY timestamp;
```

**èšåˆæ“ä½œ**ï¼š

```sql
-- åˆ†ç»„èšåˆ
SELECT
    user_id,
    COUNT(*) AS order_count,
    SUM(amount) AS total_amount,
    AVG(amount) AS avg_amount
FROM orders
GROUP BY user_id;
```

### 7.2. å¤§æ•°æ®å¤„ç†

**MapReduceåº”ç”¨**ï¼š

- è¯é¢‘ç»Ÿè®¡
- æ—¥å¿—åˆ†æ
- æ•°æ®æ¸…æ´—
- å…³è”è§„åˆ™æŒ–æ˜

### 7.3. å®æ—¶æµå¤„ç†

**æµå¼èšåˆ**ï¼š

```python
class StreamingAggregator:
    """æµå¼èšåˆå™¨"""
    def __init__(self):
        self.count = 0
        self.sum = 0
        self.min = None
        self.max = None

    def update(self, value):
        """æ›´æ–°èšåˆçŠ¶æ€"""
        self.count += 1
        self.sum += value
        if self.min is None or value < self.min:
            self.min = value
        if self.max is None or value > self.max:
            self.max = value

    def get_result(self):
        """è·å–èšåˆç»“æœ"""
        return {
            'count': self.count,
            'sum': self.sum,
            'avg': self.sum / self.count if self.count > 0 else None,
            'min': self.min,
            'max': self.max
        }
```

---

## 8. å½¢å¼åŒ–å®šä¹‰ä¸è¯æ˜

### 8.1. æ’åºç®—æ³•çš„æ­£ç¡®æ€§

**å®šç†**ï¼šå¿«é€Ÿæ’åºç®—æ³•æ­£ç¡®åœ°å°†æ•°ç»„æ’åºã€‚

**è¯æ˜**ï¼š

1. **åŸºæœ¬æƒ…å†µ**ï¼šå½“æ•°ç»„é•¿åº¦ $\leq 1$ æ—¶ï¼Œæ•°ç»„å·²æ’åºã€‚
2. **å½’çº³å‡è®¾**ï¼šå‡è®¾å¯¹äºé•¿åº¦ $< n$ çš„æ•°ç»„ï¼Œå¿«é€Ÿæ’åºæ­£ç¡®ã€‚
3. **å½’çº³æ­¥éª¤**ï¼š
   - é€‰æ‹©åŸºå‡† $p$
   - åˆ†å‰²æ•°ç»„ä¸º $L$ï¼ˆå°äº $p$ï¼‰å’Œ $R$ï¼ˆå¤§äº $p$ï¼‰
   - é€’å½’æ’åº $L$ å’Œ $R$
   - åˆå¹¶ï¼š$L \cup \{p\} \cup R$ å·²æ’åº

å› æ­¤ï¼Œå¿«é€Ÿæ’åºæ­£ç¡®ã€‚â–¡

### 8.2. äºŒåˆ†æŸ¥æ‰¾çš„æ­£ç¡®æ€§

**å®šç†**ï¼šäºŒåˆ†æŸ¥æ‰¾åœ¨æœ‰åºæ•°ç»„ä¸­æ‰¾åˆ°ç›®æ ‡å…ƒç´ ï¼ˆå¦‚æœå­˜åœ¨ï¼‰ã€‚

**è¯æ˜**ï¼š

ä½¿ç”¨å¾ªç¯ä¸å˜é‡ï¼šå¦‚æœç›®æ ‡å…ƒç´ åœ¨æ•°ç»„ä¸­ï¼Œå®ƒä¸€å®šåœ¨ $[left, right]$ èŒƒå›´å†…ã€‚

1. **åˆå§‹åŒ–**ï¼š$left = 0, right = n-1$ï¼Œä¸å˜é‡æˆç«‹ã€‚
2. **ä¿æŒ**ï¼šæ¯æ¬¡è¿­ä»£ç¼©å°æœç´¢èŒƒå›´ï¼Œä¸å˜é‡ä¿æŒã€‚
3. **ç»ˆæ­¢**ï¼šå½“ $left > right$ æ—¶ï¼Œæœç´¢èŒƒå›´ä¸ºç©ºï¼Œå…ƒç´ ä¸å­˜åœ¨ã€‚

å› æ­¤ï¼ŒäºŒåˆ†æŸ¥æ‰¾æ­£ç¡®ã€‚â–¡

---

## 9. å¤šè¡¨å¾

æ ¸å¿ƒæ•°æ®å¤„ç†ç®—æ³•æ”¯æŒå¤šç§è¡¨å¾æ–¹å¼ï¼ŒåŒ…æ‹¬ï¼š

1. **ç¬¦å·è¡¨å¾**ï¼šç®—æ³•ä¼ªä»£ç ã€æ•°æ®ç»“æ„ã€å…¬å¼ç­‰
2. **å›¾ç»“æ„**ï¼šç®—æ³•æµç¨‹å›¾ã€æ•°æ®æµå›¾ã€ä¾èµ–å›¾ç­‰
3. **å‘é‡/å¼ é‡**ï¼šç‰¹å¾å‘é‡ã€å‚æ•°çŸ©é˜µã€åµŒå…¥
4. **è‡ªç„¶è¯­è¨€**ï¼šå®šä¹‰ã€æ³¨é‡Šã€æè¿°
5. **å›¾åƒ/å¯è§†åŒ–**ï¼šæµç¨‹å›¾ã€ç»“æ„å›¾ã€ç®—æ³•å¯è§†åŒ–ç­‰

è¿™äº›è¡¨å¾å¯äº’æ˜ ï¼Œæå‡æ•°æ®å¤„ç†ç®—æ³•çš„è¡¨è¾¾åŠ›ã€‚

---

## 10. æ€»ç»“ä¸å±•æœ›

### 10.1. æ€»ç»“

æ ¸å¿ƒæ•°æ®å¤„ç†ç®—æ³•æ˜¯æ•°æ®ç§‘å­¦çš„åŸºç¡€ï¼ŒåŒ…æ‹¬ï¼š

1. **æ’åºç®—æ³•**ï¼šå¿«é€Ÿæ’åºã€å½’å¹¶æ’åºã€å †æ’åº
2. **æŸ¥æ‰¾ç®—æ³•**ï¼šäºŒåˆ†æŸ¥æ‰¾ã€å“ˆå¸ŒæŸ¥æ‰¾
3. **èšåˆç®—æ³•**ï¼šSUMã€AVGã€COUNTã€MAXã€MIN
4. **åˆ†ç»„ç®—æ³•**ï¼šå“ˆå¸Œåˆ†ç»„ã€æ’åºåˆ†ç»„
5. **å¹¶è¡Œå¤„ç†**ï¼šMapReduceã€å¹¶è¡Œå½’çº¦ã€åˆ†æ²»ç®—æ³•

### 10.2. å‘å±•è¶‹åŠ¿

**æœªæ¥å‘å±•æ–¹å‘**ï¼š

1. **å¹¶è¡ŒåŒ–**ï¼šæ›´å¥½çš„å¹¶è¡Œç®—æ³•
2. **æµå¼å¤„ç†**ï¼šå®æ—¶æ•°æ®å¤„ç†
3. **åˆ†å¸ƒå¼**ï¼šå¤§è§„æ¨¡åˆ†å¸ƒå¼å¤„ç†
4. **ç¡¬ä»¶åŠ é€Ÿ**ï¼šGPUã€TPUåŠ é€Ÿ

### 10.3. æŒ‘æˆ˜ä¸æœºé‡

**ä¸»è¦æŒ‘æˆ˜**ï¼š

1. å¤§æ•°æ®å¤„ç†
2. å®æ—¶æ€§è¦æ±‚
3. èµ„æºé™åˆ¶

**å‘å±•æœºé‡**ï¼š

1. æ–°ç¡¬ä»¶æŠ€æœ¯
2. åˆ†å¸ƒå¼ç³»ç»Ÿæˆç†Ÿ
3. ç®—æ³•ä¼˜åŒ–

---

**å‚è€ƒæ–‡çŒ®**ï¼š

1. Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2009). *Introduction to Algorithms*.
2. Knuth, D. E. (1998). *The Art of Computer Programming*.
3. Dean, J., & Ghemawat, S. (2008). MapReduce: simplified data processing on large clusters.

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**ç‰ˆæœ¬**: v2.0
**çŠ¶æ€**: âœ… å·²å®Œæˆ
