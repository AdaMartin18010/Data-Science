# 3.3.3 å¹¶å‘æ§åˆ¶ç®—æ³•

## ğŸ“‘ ç›®å½•

- [3.3.3 å¹¶å‘æ§åˆ¶ç®—æ³•](#333-å¹¶å‘æ§åˆ¶ç®—æ³•)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ‘˜è¦](#1-æ‘˜è¦)
  - [3. å¹¶å‘æ§åˆ¶æ¦‚è¿°](#3-å¹¶å‘æ§åˆ¶æ¦‚è¿°)
  - [4. å¤šç‰ˆæœ¬å¹¶å‘æ§åˆ¶(MVCC)](#4-å¤šç‰ˆæœ¬å¹¶å‘æ§åˆ¶mvcc)
    - [4.1. ç‰ˆæœ¬é“¾ç®¡ç†](#41-ç‰ˆæœ¬é“¾ç®¡ç†)
    - [4.2. ç‰ˆæœ¬å¯è§æ€§åˆ¤æ–­](#42-ç‰ˆæœ¬å¯è§æ€§åˆ¤æ–­)
    - [4.3. å¿«ç…§éš”ç¦»å®ç°](#43-å¿«ç…§éš”ç¦»å®ç°)
  - [5. é”ç®¡ç†ç®—æ³•](#5-é”ç®¡ç†ç®—æ³•)
    - [5.1. é”å…¼å®¹çŸ©é˜µ](#51-é”å…¼å®¹çŸ©é˜µ)
  - [6. é”ç®¡ç†å™¨](#6-é”ç®¡ç†å™¨)
  - [7. æ­»é”æ£€æµ‹ç®—æ³•](#7-æ­»é”æ£€æµ‹ç®—æ³•)
    - [7.1. ç­‰å¾…å›¾æ„å»º](#71-ç­‰å¾…å›¾æ„å»º)
  - [8. æ­»é”æ£€æµ‹ä¸è§£å†³](#8-æ­»é”æ£€æµ‹ä¸è§£å†³)
  - [9. äº‹åŠ¡è°ƒåº¦ç®—æ³•](#9-äº‹åŠ¡è°ƒåº¦ç®—æ³•)
    - [9.1. å¯ä¸²è¡ŒåŒ–è°ƒåº¦](#91-å¯ä¸²è¡ŒåŒ–è°ƒåº¦)
  - [10. æœ¬åœ°è·³è½¬ä¸äº¤å‰å¼•ç”¨](#10-æœ¬åœ°è·³è½¬ä¸äº¤å‰å¼•ç”¨)
  - [11. å¤šè¡¨å¾](#11-å¤šè¡¨å¾)
  - [12. å½¢å¼åŒ–è¯­ä¹‰](#12-å½¢å¼åŒ–è¯­ä¹‰)
  - [13. å½¢å¼åŒ–è¯­æ³•ä¸è¯æ˜](#13-å½¢å¼åŒ–è¯­æ³•ä¸è¯æ˜)
  - [14. ä¸¤é˜¶æ®µé”åè®®ï¼ˆ2PLï¼‰](#14-ä¸¤é˜¶æ®µé”åè®®2pl)
    - [14.1. åŸºæœ¬2PL](#141-åŸºæœ¬2pl)
    - [14.2. ä¸¥æ ¼2PL](#142-ä¸¥æ ¼2pl)
    - [14.3. å¼º2PL](#143-å¼º2pl)
  - [15. å¤šç²’åº¦é”](#15-å¤šç²’åº¦é”)
    - [15.1. é”ç²’åº¦å±‚æ¬¡](#151-é”ç²’åº¦å±‚æ¬¡)
    - [15.2. é”å…¼å®¹çŸ©é˜µ](#152-é”å…¼å®¹çŸ©é˜µ)
    - [15.3. å¤šç²’åº¦é”å®ç°](#153-å¤šç²’åº¦é”å®ç°)
  - [16. åˆ†å¸ƒå¼å¹¶å‘æ§åˆ¶](#16-åˆ†å¸ƒå¼å¹¶å‘æ§åˆ¶)
    - [16.1. åˆ†å¸ƒå¼ä¸¤é˜¶æ®µæäº¤ï¼ˆ2PCï¼‰](#161-åˆ†å¸ƒå¼ä¸¤é˜¶æ®µæäº¤2pc)
    - [16.2. ä¸‰é˜¶æ®µæäº¤ï¼ˆ3PCï¼‰](#162-ä¸‰é˜¶æ®µæäº¤3pc)
    - [16.3. Paxosç®—æ³•](#163-paxosç®—æ³•)
  - [17. å®é™…åº”ç”¨æ¡ˆä¾‹](#17-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [17.1. PostgreSQL MVCC](#171-postgresql-mvcc)
    - [17.2. MySQL InnoDB](#172-mysql-innodb)
    - [17.3. Oracleæ•°æ®åº“](#173-oracleæ•°æ®åº“)
  - [18. æ€§èƒ½ä¼˜åŒ–](#18-æ€§èƒ½ä¼˜åŒ–)
    - [18.1. é”ä¼˜åŒ–](#181-é”ä¼˜åŒ–)
    - [18.2. æ­»é”é¢„é˜²](#182-æ­»é”é¢„é˜²)
    - [18.3. å¹¶å‘åº¦ä¼˜åŒ–](#183-å¹¶å‘åº¦ä¼˜åŒ–)
  - [19. æœ€ä½³å®è·µ](#19-æœ€ä½³å®è·µ)
    - [19.1. äº‹åŠ¡è®¾è®¡](#191-äº‹åŠ¡è®¾è®¡)
    - [19.2. é”ä½¿ç”¨](#192-é”ä½¿ç”¨)
    - [19.3. æ€§èƒ½ç›‘æ§](#193-æ€§èƒ½ç›‘æ§)
  - [20. æ€»ç»“](#20-æ€»ç»“)

---


## 1. æ‘˜è¦

æœ¬æ–‡ä»¶ç³»ç»Ÿæ¢³ç†æ•°æ®åº“å¹¶å‘æ§åˆ¶çš„æ ¸å¿ƒç®—æ³•ï¼Œä»¥PostgreSQLçš„MVCCæœºåˆ¶ä¸ºä¾‹ï¼Œæ¶µç›–å¤šç‰ˆæœ¬å¹¶å‘æ§åˆ¶ã€é”ç®¡ç†ã€æ­»é”æ£€æµ‹ã€äº‹åŠ¡è°ƒåº¦ç­‰å…³é”®æŠ€æœ¯ã€‚

---

## 3. å¹¶å‘æ§åˆ¶æ¦‚è¿°

å¹¶å‘æ§åˆ¶ç¡®ä¿å¤šä¸ªäº‹åŠ¡å¹¶å‘æ‰§è¡Œæ—¶ï¼Œæ•°æ®åº“ä¿æŒä¸€è‡´æ€§ã€‚

**æ ¸å¿ƒé—®é¢˜**ï¼š

- è„è¯» (Dirty Read)
- ä¸å¯é‡å¤è¯» (Non-repeatable Read)
- å¹»è¯» (Phantom Read)
- ä¸¢å¤±æ›´æ–° (Lost Update)

**éš”ç¦»çº§åˆ«**ï¼š

- READ UNCOMMITTED
- READ COMMITTED
- REPEATABLE READ
- SERIALIZABLE

## 4. å¤šç‰ˆæœ¬å¹¶å‘æ§åˆ¶(MVCC)

### 4.1. ç‰ˆæœ¬é“¾ç®¡ç†

```rust
// Rustå®ç°ï¼šç‰ˆæœ¬é“¾ç»“æ„
#[derive(Debug, Clone)]
struct Version {
    xmin: TransactionId,    // åˆ›å»ºè¯¥ç‰ˆæœ¬çš„äº‹åŠ¡ID
    xmax: TransactionId,    // åˆ é™¤è¯¥ç‰ˆæœ¬çš„äº‹åŠ¡ID
    cid: CommandId,         // å‘½ä»¤ID
    data: Vec<u8>,          // å®é™…æ•°æ®
    next: Option<Box<Version>>, // ä¸‹ä¸€ä¸ªç‰ˆæœ¬
}

#[derive(Debug)]
struct MVCCRecord {
    versions: Option<Box<Version>>, // ç‰ˆæœ¬é“¾å¤´
    current: Option<Box<Version>>,  // å½“å‰å¯è§ç‰ˆæœ¬
}
```

### 4.2. ç‰ˆæœ¬å¯è§æ€§åˆ¤æ–­

```rust
// Rustå®ç°ï¼šç‰ˆæœ¬å¯è§æ€§åˆ¤æ–­
impl MVCCRecord {
    fn is_visible(&self, version: &Version, snapshot: &Snapshot) -> bool {
        // æ£€æŸ¥ç‰ˆæœ¬æ˜¯å¦å¯¹å½“å‰å¿«ç…§å¯è§
        if version.xmax != INVALID_TXN_ID &&
           snapshot.is_active(version.xmax) {
            return false; // è¢«æœªæäº¤äº‹åŠ¡åˆ é™¤
        }

        if !snapshot.is_active(version.xmin) {
            return false; // åˆ›å»ºäº‹åŠ¡æœªæäº¤
        }

        true
    }

    fn get_visible_version(&self, snapshot: &Snapshot) -> Option<&Version> {
        let mut current = self.versions.as_ref();
        while let Some(version) = current {
            if self.is_visible(version, snapshot) {
                return Some(version);
            }
            current = version.next.as_ref();
        }
        None
    }
}
```

### 4.3. å¿«ç…§éš”ç¦»å®ç°

```go
// Goå®ç°ï¼šå¿«ç…§éš”ç¦»
type Snapshot struct {
    xmin    TransactionId
    xmax    TransactionId
    xip     map[TransactionId]bool // æ´»è·ƒäº‹åŠ¡åˆ—è¡¨
}

type Transaction struct {
    id        TransactionId
    snapshot  *Snapshot
    status    TransactionStatus
    startTime time.Time
}

func (t *Transaction) Begin() {
    t.snapshot = t.createSnapshot()
    t.status = ACTIVE
}

func (t *Transaction) createSnapshot() *Snapshot {
    return &Snapshot{
        xmin: getOldestActiveTxn(),
        xmax: getNextTxnId(),
        xip:  getActiveTxnList(),
    }
}
```

## 5. é”ç®¡ç†ç®—æ³•

### 5.1. é”å…¼å®¹çŸ©é˜µ

```python
# Pythonå®ç°ï¼šé”å…¼å®¹çŸ©é˜µ
class LockType:
    SHARED = 0
    EXCLUSIVE = 1
    INTENT_SHARED = 2
    INTENT_EXCLUSIVE = 3
    SHARED_INTENT_EXCLUSIVE = 4

# é”å…¼å®¹çŸ©é˜µ
LOCK_COMPATIBILITY = {
    LockType.SHARED: [True, False, True, False, False],
    LockType.EXCLUSIVE: [False, False, False, False, False],
    LockType.INTENT_SHARED: [True, False, True, True, True],
    LockType.INTENT_EXCLUSIVE: [False, False, True, True, False],
    LockType.SHARED_INTENT_EXCLUSIVE: [False, False, True, False, False]
}

def is_compatible(lock1, lock2):
    return LOCK_COMPATIBILITY[lock1][lock2]
```

## 6. é”ç®¡ç†å™¨

```go
// Goå®ç°ï¼šé”ç®¡ç†å™¨
type LockManager struct {
    locks map[string]*LockQueue
    mu    sync.RWMutex
}

type LockQueue struct {
    granted []*LockRequest
    waiting []*LockRequest
    mu      sync.Mutex
}

type LockRequest struct {
    txnId    TransactionId
    lockType LockType
    resource string
    granted  bool
    cond     *sync.Cond
}

func (lm *LockManager) AcquireLock(txnId TransactionId, resource string, lockType LockType) bool {
    lm.mu.Lock()
    queue, exists := lm.locks[resource]
    if !exists {
        queue = &LockQueue{}
        lm.locks[resource] = queue
    }
    lm.mu.Unlock()

    return queue.acquireLock(txnId, lockType)
}

func (lq *LockQueue) acquireLock(txnId TransactionId, lockType LockType) bool {
    lq.mu.Lock()
    defer lq.mu.Unlock()

    // æ£€æŸ¥æ˜¯å¦å¯ä»¥ç«‹å³è·å¾—é”
    if lq.canGrantLock(lockType) {
        lq.granted = append(lq.granted, &LockRequest{
            txnId:    txnId,
            lockType: lockType,
            granted:  true,
        })
        return true
    }

    // åŠ å…¥ç­‰å¾…é˜Ÿåˆ—
    request := &LockRequest{
        txnId:    txnId,
        lockType: lockType,
        granted:  false,
        cond:     sync.NewCond(&lq.mu),
    }
    lq.waiting = append(lq.waiting, request)

    // ç­‰å¾…é”è¢«æˆäºˆ
    for !request.granted {
        request.cond.Wait()
    }

    return true
}
```

## 7. æ­»é”æ£€æµ‹ç®—æ³•

### 7.1. ç­‰å¾…å›¾æ„å»º

```python
# Pythonå®ç°ï¼šç­‰å¾…å›¾æ„å»º
class WaitForGraph:
    def __init__(self):
        self.graph = defaultdict(set)
        self.reverse_graph = defaultdict(set)

    def add_edge(self, from_txn, to_txn):
        """æ·»åŠ ç­‰å¾…è¾¹ï¼šfrom_txn ç­‰å¾… to_txn"""
        self.graph[from_txn].add(to_txn)
        self.reverse_graph[to_txn].add(from_txn)

    def remove_edge(self, from_txn, to_txn):
        """ç§»é™¤ç­‰å¾…è¾¹"""
        self.graph[from_txn].discard(to_txn)
        self.reverse_graph[to_txn].discard(from_txn)

    def detect_cycle(self):
        """æ£€æµ‹ç¯ï¼ˆæ­»é”ï¼‰"""
        visited = set()
        rec_stack = set()

        def dfs(node):
            visited.add(node)
            rec_stack.add(node)

            for neighbor in self.graph[node]:
                if neighbor not in visited:
                    if dfs(neighbor):
                        return True
                elif neighbor in rec_stack:
                    return True

            rec_stack.remove(node)
            return False

        for node in self.graph:
            if node not in visited:
                if dfs(node):
                    return True
        return False
```

## 8. æ­»é”æ£€æµ‹ä¸è§£å†³

```go
// Goå®ç°ï¼šæ­»é”æ£€æµ‹ä¸è§£å†³
type DeadlockDetector struct {
    waitForGraph *WaitForGraph
    txnManager   *TransactionManager
}

func (dd *DeadlockDetector) DetectAndResolve() {
    if dd.waitForGraph.HasCycle() {
        // æ‰¾åˆ°æ­»é”ç¯
        cycle := dd.waitForGraph.FindCycle()

        // é€‰æ‹©ç‰ºç‰²è€…ï¼ˆé€šå¸¸é€‰æ‹©æœ€å¹´è½»çš„äº‹åŠ¡ï¼‰
        victim := dd.selectVictim(cycle)

        // ä¸­æ­¢ç‰ºç‰²è€…äº‹åŠ¡
        dd.txnManager.AbortTransaction(victim)

        // ç§»é™¤ç›¸å…³çš„ç­‰å¾…è¾¹
        dd.waitForGraph.RemoveTransactionEdges(victim)
    }
}

func (dd *DeadlockDetector) selectVictim(cycle []TransactionId) TransactionId {
    // é€‰æ‹©ç­–ç•¥ï¼šæœ€å¹´è½»çš„äº‹åŠ¡
    var youngest TransactionId
    var youngestTime time.Time

    for _, txnId := range cycle {
        txn := dd.txnManager.GetTransaction(txnId)
        if txn.StartTime.After(youngestTime) {
            youngest = txnId
            youngestTime = txn.StartTime
        }
    }

    return youngest
}
```

## 9. äº‹åŠ¡è°ƒåº¦ç®—æ³•

### 9.1. å¯ä¸²è¡ŒåŒ–è°ƒåº¦

```python
# Pythonå®ç°ï¼šå¯ä¸²è¡ŒåŒ–è°ƒåº¦æ£€æµ‹
class SerializableScheduler:
    def __init__(self):
        self.conflict_graph = defaultdict(set)

    def add_operation(self, txn_id, operation, resource):
        """æ·»åŠ æ“ä½œåˆ°è°ƒåº¦"""
# æ£€æŸ¥ä¸ä¹‹å‰æ“ä½œçš„å†²çª
        for prev_txn, prev_op, prev_resource in self.operations:
            if self.has_conflict(operation, prev_op, resource, prev_resource):
# æ·»åŠ å†²çªè¾¹
                self.conflict_graph[prev_txn].add(txn_id)

        self.operations.append((txn_id, operation, resource))

    def has_conflict(self, op1, op2, res1, res2):
        """æ£€æŸ¥ä¸¤ä¸ªæ“ä½œæ˜¯å¦æœ‰å†²çª"""
        if res1 != res2:
            return False

# è¯»å†™å†²çª
        if (op1 == 'R' and op2 == 'W') or (op1 == 'W' and op2 == 'R'):
            return True

# å†™å†™å†²çª
        if op1 == 'W' and op2 == 'W':
            return True

        return False

    def is_serializable(self):
        """æ£€æŸ¥è°ƒåº¦æ˜¯å¦å¯ä¸²è¡ŒåŒ–"""
        return not self.has_cycle()

    def has_cycle(self):
        """æ£€æµ‹å†²çªå›¾ä¸­æ˜¯å¦æœ‰ç¯"""
        visited = set()
        rec_stack = set()

        def dfs(node):
            visited.add(node)
            rec_stack.add(node)

            for neighbor in self.conflict_graph[node]:
                if neighbor not in visited:
                    if dfs(neighbor):
                        return True
                elif neighbor in rec_stack:
                    return True

            rec_stack.remove(node)
            return False

        for node in self.conflict_graph:
            if node not in visited:
                if dfs(node):
                    return True
        return False
```

## 10. æœ¬åœ°è·³è½¬ä¸äº¤å‰å¼•ç”¨

- [è¿”å›æ ¸å¿ƒæ•°æ®å¤„ç†ç®—æ³•](./3.3.1-æ ¸å¿ƒæ•°æ®å¤„ç†ç®—æ³•.md)
- [è·³è½¬åˆ°æŸ¥è¯¢ä¼˜åŒ–ç®—æ³•](./3.3.2-æŸ¥è¯¢ä¼˜åŒ–ç®—æ³•.md)
- [è·³è½¬åˆ°PostgreSQL MVCCåˆ†æ](../../1-æ•°æ®åº“ç³»ç»Ÿ/1.1-PostgreSQL/1.1.8-MVCCé«˜çº§åˆ†æä¸å½¢å¼è¯æ˜.md)
- [è·³è½¬åˆ°æ•°æ®æ¨¡å‹å½¢å¼åŒ–ç†è®º](../3.2-å½¢å¼åŒ–æ¨¡å‹/3.2.1-æ•°æ®æ¨¡å‹çš„å½¢å¼åŒ–ç†è®º.md)

---

**æœ€åæ›´æ–°**: 2024å¹´12æœˆ
**ç‰ˆæœ¬**: v1.0
**çŠ¶æ€**: âœ… å·²å®Œæˆ

## 11. å¤šè¡¨å¾

å¹¶å‘æ§åˆ¶ç®—æ³•æ”¯æŒå¤šç§è¡¨å¾æ–¹å¼ï¼ŒåŒ…æ‹¬ï¼š

- ç¬¦å·è¡¨å¾ï¼ˆå¹¶å‘åè®®ã€é”æœºåˆ¶ã€è°ƒåº¦ç®—æ³•ã€ä¼ªä»£ç ç­‰ï¼‰
- å›¾ç»“æ„ï¼ˆé”ä¾èµ–å›¾ã€è°ƒåº¦æµç¨‹å›¾ã€å†²çªå›¾ç­‰ï¼‰
- å‘é‡/å¼ é‡ï¼ˆçŠ¶æ€å‘é‡ã€å‚æ•°çŸ©é˜µã€ç‰¹å¾åµŒå…¥ï¼‰
- è‡ªç„¶è¯­è¨€ï¼ˆå®šä¹‰ã€æ³¨é‡Šã€æè¿°ï¼‰
- å›¾åƒ/å¯è§†åŒ–ï¼ˆæµç¨‹å›¾ã€ç»“æ„å›¾ã€å¹¶å‘å¯è§†åŒ–ç­‰ï¼‰
è¿™äº›è¡¨å¾å¯äº’æ˜ ï¼Œæå‡å¹¶å‘æ§åˆ¶ç®—æ³•çš„è¡¨è¾¾åŠ›ã€‚

## 12. å½¢å¼åŒ–è¯­ä¹‰

- è¯­ä¹‰åŸŸï¼š$D$ï¼Œå¦‚äº‹åŠ¡å¯¹è±¡é›†ã€é”ç©ºé—´ã€è°ƒåº¦æ¨¡å‹ç©ºé—´
- è§£é‡Šå‡½æ•°ï¼š$I: S \to D$ï¼Œå°†ç¬¦å·/ç»“æ„æ˜ å°„åˆ°å…·ä½“è¯­ä¹‰å¯¹è±¡
- è¯­ä¹‰ä¸€è‡´æ€§ï¼šæ¯ä¸ªåè®®/è°ƒåº¦/å…¬å¼åœ¨$D$ä¸­æœ‰æ˜ç¡®å®šä¹‰

## 13. å½¢å¼åŒ–è¯­æ³•ä¸è¯æ˜

- è¯­æ³•è§„åˆ™ï¼šå¦‚åè®®å®šä¹‰ã€è°ƒåº¦è§„åˆ™ã€æ¨ç†è§„åˆ™ã€çº¦æŸæ¡ä»¶
- **å®šç†**ï¼šå¹¶å‘æ§åˆ¶ç®—æ³•çš„è¯­æ³•ç³»ç»Ÿå…·ä¸€è‡´æ€§ä¸å¯æ‰©å±•æ€§ã€‚
- **è¯æ˜**ï¼šç”±åè®®å®šä¹‰ã€è°ƒåº¦è§„åˆ™ä¸æ¨ç†è§„åˆ™é€’å½’å®šä¹‰ï¼Œä¿è¯ç³»ç»Ÿä¸€è‡´ä¸å¯æ‰©å±•ã€‚

---

## 14. ä¸¤é˜¶æ®µé”åè®®ï¼ˆ2PLï¼‰

### 14.1. åŸºæœ¬2PL

**åè®®è§„åˆ™**ï¼š

1. **å¢é•¿é˜¶æ®µ**ï¼šäº‹åŠ¡åªèƒ½è·å–é”ï¼Œä¸èƒ½é‡Šæ”¾é”
2. **æ”¶ç¼©é˜¶æ®µ**ï¼šäº‹åŠ¡åªèƒ½é‡Šæ”¾é”ï¼Œä¸èƒ½è·å–é”

**å®ç°**ï¼š

```python
class TwoPhaseLocking:
    def __init__(self):
        self.transactions = {}
        self.lock_manager = LockManager()
        self.phase = {}  # äº‹åŠ¡é˜¶æ®µï¼š'growing' æˆ– 'shrinking'

    def begin_transaction(self, txn_id):
        self.transactions[txn_id] = {
            'id': txn_id,
            'locks': [],
            'phase': 'growing'
        }
        self.phase[txn_id] = 'growing'

    def acquire_lock(self, txn_id, resource_id, lock_type):
        if self.phase[txn_id] == 'shrinking':
            raise ValueError("äº‹åŠ¡å·²è¿›å…¥æ”¶ç¼©é˜¶æ®µï¼Œä¸èƒ½è·å–æ–°é”")

        if self.lock_manager.acquire_lock(txn_id, resource_id, lock_type):
            self.transactions[txn_id]['locks'].append((resource_id, lock_type))
            return True
        return False

    def release_lock(self, txn_id, resource_id):
        if self.phase[txn_id] == 'growing':
            self.phase[txn_id] = 'shrinking'

        self.lock_manager.release_lock(txn_id, resource_id)
        self.transactions[txn_id]['locks'] = [
            (rid, lt) for rid, lt in self.transactions[txn_id]['locks']
            if rid != resource_id
        ]

    def commit(self, txn_id):
        # é‡Šæ”¾æ‰€æœ‰é”
        for resource_id, _ in self.transactions[txn_id]['locks']:
            self.lock_manager.release_lock(txn_id, resource_id)
        del self.transactions[txn_id]
        del self.phase[txn_id]
```

### 14.2. ä¸¥æ ¼2PL

**ç‰¹ç‚¹**ï¼š

- æ‰€æœ‰é”åœ¨äº‹åŠ¡æäº¤æ—¶é‡Šæ”¾
- é¿å…çº§è”å›æ»š
- ä¿è¯å¯æ¢å¤æ€§

### 14.3. å¼º2PL

**ç‰¹ç‚¹**ï¼š

- æ’ä»–é”åœ¨äº‹åŠ¡æäº¤æ—¶é‡Šæ”¾
- å…±äº«é”å¯ä»¥æå‰é‡Šæ”¾
- å¹³è¡¡æ€§èƒ½å’Œå®‰å…¨æ€§

---

## 15. å¤šç²’åº¦é”

### 15.1. é”ç²’åº¦å±‚æ¬¡

**å±‚æ¬¡ç»“æ„**ï¼š

```text
æ•°æ®åº“
  â””â”€â”€ è¡¨
      â””â”€â”€ é¡µ
          â””â”€â”€ è¡Œ
```

**é”ç±»å‹**ï¼š

- **æ„å‘å…±äº«é”ï¼ˆISï¼‰**ï¼šè¡¨ç¤ºåœ¨è¾ƒä½çº§åˆ«è·å–å…±äº«é”çš„æ„å‘
- **æ„å‘æ’ä»–é”ï¼ˆIXï¼‰**ï¼šè¡¨ç¤ºåœ¨è¾ƒä½çº§åˆ«è·å–æ’ä»–é”çš„æ„å‘
- **å…±äº«æ„å‘æ’ä»–é”ï¼ˆSIXï¼‰**ï¼šå…±äº«é” + æ„å‘æ’ä»–é”

### 15.2. é”å…¼å®¹çŸ©é˜µ

|      | IS  | IX  | S   | SIX | X   |
|------|-----|-----|-----|-----|-----|
| IS   | âœ…  | âœ…  | âœ…  | âœ…  | âŒ  |
| IX   | âœ…  | âœ…  | âŒ  | âŒ  | âŒ  |
| S    | âœ…  | âŒ  | âœ…  | âŒ  | âŒ  |
| SIX  | âœ…  | âŒ  | âŒ  | âŒ  | âŒ  |
| X    | âŒ  | âŒ  | âŒ  | âŒ  | âŒ  |

### 15.3. å¤šç²’åº¦é”å®ç°

```python
class MultiGranularityLock:
    def __init__(self, resource_id, granularity):
        self.resource_id = resource_id
        self.granularity = granularity  # 'database', 'table', 'page', 'row'
        self.intention_locks = set()  # IS, IX, SIX
        self.explicit_locks = set()   # S, X
        self.children = {}  # å­èµ„æºé”

    def acquire_intention_lock(self, txn_id, lock_type):
        """è·å–æ„å‘é”"""
        if self._is_compatible_intention(lock_type):
            self.intention_locks.add((txn_id, lock_type))
            return True
        return False

    def acquire_explicit_lock(self, txn_id, lock_type):
        """è·å–æ˜¾å¼é”"""
        if self._is_compatible_explicit(lock_type):
            self.explicit_locks.add((txn_id, lock_type))
            return True
        return False

    def _is_compatible_intention(self, lock_type):
        """æ£€æŸ¥æ„å‘é”å…¼å®¹æ€§"""
        for _, existing_lock in self.intention_locks:
            if not self._compatible(lock_type, existing_lock):
                return False
        return True

    def _is_compatible_explicit(self, lock_type):
        """æ£€æŸ¥æ˜¾å¼é”å…¼å®¹æ€§"""
        for _, existing_lock in self.explicit_locks:
            if not self._compatible(lock_type, existing_lock):
                return False
        return True
```

---

## 16. åˆ†å¸ƒå¼å¹¶å‘æ§åˆ¶

### 16.1. åˆ†å¸ƒå¼ä¸¤é˜¶æ®µæäº¤ï¼ˆ2PCï¼‰

**é˜¶æ®µ1ï¼šå‡†å¤‡é˜¶æ®µ**ï¼š

1. åè°ƒè€…å‘æ‰€æœ‰å‚ä¸è€…å‘é€PREPAREæ¶ˆæ¯
2. å‚ä¸è€…æ‰§è¡Œäº‹åŠ¡ï¼Œå†™å…¥æ—¥å¿—ï¼Œä½†ä¸æäº¤
3. å‚ä¸è€…å‘åè°ƒè€…å‘é€YESæˆ–NO

**é˜¶æ®µ2ï¼šæäº¤é˜¶æ®µ**ï¼š

1. å¦‚æœæ‰€æœ‰å‚ä¸è€…éƒ½è¿”å›YESï¼Œåè°ƒè€…å‘é€COMMIT
2. å¦åˆ™ï¼Œåè°ƒè€…å‘é€ABORT
3. å‚ä¸è€…æ ¹æ®æ¶ˆæ¯æäº¤æˆ–å›æ»š

**å®ç°**ï¼š

```python
class TwoPhaseCommit:
    def __init__(self, coordinator, participants):
        self.coordinator = coordinator
        self.participants = participants
        self.state = 'INIT'

    def prepare(self):
        """å‡†å¤‡é˜¶æ®µ"""
        self.state = 'PREPARING'
        votes = []

        for participant in self.participants:
            vote = participant.prepare()
            votes.append(vote)

        if all(vote == 'YES' for vote in votes):
            return self.commit()
        else:
            return self.abort()

    def commit(self):
        """æäº¤é˜¶æ®µ"""
        self.state = 'COMMITTING'
        for participant in self.participants:
            participant.commit()
        self.state = 'COMMITTED'
        return 'COMMITTED'

    def abort(self):
        """ä¸­æ­¢é˜¶æ®µ"""
        self.state = 'ABORTING'
        for participant in self.participants:
            participant.abort()
        self.state = 'ABORTED'
        return 'ABORTED'
```

### 16.2. ä¸‰é˜¶æ®µæäº¤ï¼ˆ3PCï¼‰

**æ”¹è¿›**ï¼š

- å¢åŠ é¢„æäº¤é˜¶æ®µ
- é¿å…é˜»å¡
- æé«˜å¯ç”¨æ€§

**é˜¶æ®µ**ï¼š

1. **CanCommit**ï¼šè¯¢é—®æ˜¯å¦å¯ä»¥æäº¤
2. **PreCommit**ï¼šé¢„æäº¤ï¼Œå‡†å¤‡æäº¤
3. **DoCommit**ï¼šæ‰§è¡Œæäº¤

### 16.3. Paxosç®—æ³•

**åº”ç”¨åœºæ™¯**ï¼š

- åˆ†å¸ƒå¼ä¸€è‡´æ€§
- é€‰ä¸»ç®—æ³•
- çŠ¶æ€å¤åˆ¶

**ç®—æ³•æµç¨‹**ï¼š

1. **Prepareé˜¶æ®µ**ï¼šæè®®è€…å‘é€prepareè¯·æ±‚
2. **Promiseé˜¶æ®µ**ï¼šæ¥å—è€…å“åº”promise
3. **Accepté˜¶æ®µ**ï¼šæè®®è€…å‘é€acceptè¯·æ±‚
4. **Acceptedé˜¶æ®µ**ï¼šæ¥å—è€…å“åº”accepted

---

## 17. å®é™…åº”ç”¨æ¡ˆä¾‹

### 17.1. PostgreSQL MVCC

**å®ç°ç‰¹ç‚¹**ï¼š

- ä½¿ç”¨ç‰ˆæœ¬é“¾ç®¡ç†å¤šç‰ˆæœ¬
- å¿«ç…§éš”ç¦»å®ç°
- å¯è§æ€§åˆ¤æ–­ç®—æ³•
- åƒåœ¾å›æ”¶æœºåˆ¶

**æ€§èƒ½ä¼˜åŒ–**ï¼š

- ç‰ˆæœ¬é“¾ä¼˜åŒ–
- å¿«ç…§ä¼˜åŒ–
- åƒåœ¾å›æ”¶ä¼˜åŒ–

### 17.2. MySQL InnoDB

**å®ç°ç‰¹ç‚¹**ï¼š

- è¡Œçº§é”
- å¤šç‰ˆæœ¬å¹¶å‘æ§åˆ¶
- é—´éš™é”é˜²æ­¢å¹»è¯»
- æ­»é”æ£€æµ‹

### 17.3. Oracleæ•°æ®åº“

**å®ç°ç‰¹ç‚¹**ï¼š

- å¤šç‰ˆæœ¬è¯»ä¸€è‡´æ€§
- è¡Œçº§é”
- è‡ªåŠ¨æ­»é”æ£€æµ‹
- é”å‡çº§æœºåˆ¶

---

## 18. æ€§èƒ½ä¼˜åŒ–

### 18.1. é”ä¼˜åŒ–

**ä¼˜åŒ–ç­–ç•¥**ï¼š

- **é”ç²’åº¦é€‰æ‹©**ï¼šæ ¹æ®è®¿é—®æ¨¡å¼é€‰æ‹©åˆé€‚ç²’åº¦
- **é”è¶…æ—¶**ï¼šè®¾ç½®é”è¶…æ—¶é¿å…é•¿æ—¶é—´ç­‰å¾…
- **é”å‡çº§**ï¼šç»†ç²’åº¦é”å‡çº§ä¸ºç²—ç²’åº¦é”
- **é”é™çº§**ï¼šç²—ç²’åº¦é”é™çº§ä¸ºç»†ç²’åº¦é”

### 18.2. æ­»é”é¢„é˜²

**é¢„é˜²ç­–ç•¥**ï¼š

- **é”æ’åº**ï¼šæŒ‰å›ºå®šé¡ºåºè·å–é”
- **è¶…æ—¶æœºåˆ¶**ï¼šè®¾ç½®é”è¶…æ—¶
- **æ­»é”æ£€æµ‹**ï¼šå®šæœŸæ£€æµ‹æ­»é”
- **æ­»é”é¿å…**ï¼šä½¿ç”¨é“¶è¡Œå®¶ç®—æ³•

### 18.3. å¹¶å‘åº¦ä¼˜åŒ–

**ä¼˜åŒ–æ–¹æ³•**ï¼š

- **MVCC**ï¼šæé«˜è¯»å¹¶å‘åº¦
- **è¯»å†™åˆ†ç¦»**ï¼šåˆ†ç¦»è¯»å†™æ“ä½œ
- **åˆ†åŒº**ï¼šå‡å°‘é”ç«äº‰
- **æ— é”æ•°æ®ç»“æ„**ï¼šä½¿ç”¨CASæ“ä½œ

---

## 19. æœ€ä½³å®è·µ

### 19.1. äº‹åŠ¡è®¾è®¡

**è®¾è®¡åŸåˆ™**ï¼š

- äº‹åŠ¡å°½å¯èƒ½çŸ­
- é¿å…é•¿äº‹åŠ¡
- å‡å°‘é”æŒæœ‰æ—¶é—´
- åˆç†ä½¿ç”¨éš”ç¦»çº§åˆ«

### 19.2. é”ä½¿ç”¨

**ä½¿ç”¨å»ºè®®**ï¼š

- é€‰æ‹©åˆé€‚çš„é”ç²’åº¦
- é¿å…æ­»é”
- ä½¿ç”¨è¶…æ—¶æœºåˆ¶
- ç›‘æ§é”ç«äº‰

### 19.3. æ€§èƒ½ç›‘æ§

**ç›‘æ§æŒ‡æ ‡**ï¼š

- é”ç­‰å¾…æ—¶é—´
- æ­»é”é¢‘ç‡
- äº‹åŠ¡ååé‡
- å¹¶å‘åº¦

---

## 20. æ€»ç»“

å¹¶å‘æ§åˆ¶æ˜¯æ•°æ®åº“ç³»ç»Ÿçš„æ ¸å¿ƒåŠŸèƒ½ï¼Œé€šè¿‡é”æœºåˆ¶ã€MVCCã€æ—¶é—´æˆ³æ’åºç­‰æŠ€æœ¯ï¼Œç¡®ä¿å¤šä¸ªäº‹åŠ¡å¹¶å‘æ‰§è¡Œæ—¶æ•°æ®åº“çš„ä¸€è‡´æ€§å’Œæ­£ç¡®æ€§ã€‚éšç€åˆ†å¸ƒå¼ç³»ç»Ÿçš„å‘å±•ï¼Œåˆ†å¸ƒå¼å¹¶å‘æ§åˆ¶æŠ€æœ¯ä¹Ÿåœ¨ä¸æ–­æ¼”è¿›ã€‚

**æ ¸å¿ƒä»·å€¼**ï¼š

1. **æ•°æ®ä¸€è‡´æ€§**ï¼šä¿è¯æ•°æ®ä¸€è‡´æ€§å’Œæ­£ç¡®æ€§
2. **å¹¶å‘æ€§èƒ½**ï¼šæé«˜ç³»ç»Ÿå¹¶å‘æ€§èƒ½
3. **éš”ç¦»æ€§**ï¼šæä¾›ä¸åŒçº§åˆ«çš„éš”ç¦»æ€§
4. **å¯é æ€§**ï¼šä¿è¯ç³»ç»Ÿå¯é æ€§

**æœªæ¥å±•æœ›**ï¼š

éšç€åˆ†å¸ƒå¼ç³»ç»Ÿã€äº‘æ•°æ®åº“ç­‰æŠ€æœ¯çš„å‘å±•ï¼Œå¹¶å‘æ§åˆ¶æŠ€æœ¯å°†ç»§ç»­å‘å±•ï¼Œç‰¹åˆ«æ˜¯åœ¨åˆ†å¸ƒå¼ä¸€è‡´æ€§ã€æ— é”æ•°æ®ç»“æ„ã€é«˜æ€§èƒ½å¹¶å‘æ§åˆ¶ç­‰é¢†åŸŸï¼Œå¹¶å‘æ§åˆ¶å°†æä¾›æ›´å¼ºå¤§çš„åŠŸèƒ½å’Œæ›´å¥½çš„æ€§èƒ½ã€‚

---

[è¿”å›ä¸Šçº§ç›®å½•](../README.md)
