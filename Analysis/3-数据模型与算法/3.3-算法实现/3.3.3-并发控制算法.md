# 3.3.3 å¹¶å‘æ§åˆ¶ç®—æ³•

## ğŸ“‘ ç›®å½•

- [3.3.3 å¹¶å‘æ§åˆ¶ç®—æ³•](#333-å¹¶å‘æ§åˆ¶ç®—æ³•)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ‘˜è¦](#1-æ‘˜è¦)
  - [3. å¹¶å‘æ§åˆ¶æ¦‚è¿°](#3-å¹¶å‘æ§åˆ¶æ¦‚è¿°)
  - [4. å¤šç‰ˆæœ¬å¹¶å‘æ§åˆ¶(MVCC)](#4-å¤šç‰ˆæœ¬å¹¶å‘æ§åˆ¶mvcc)
    - [4.1. ç‰ˆæœ¬é“¾ç®¡ç†](#41-ç‰ˆæœ¬é“¾ç®¡ç†)
    - [4.2. ç‰ˆæœ¬å¯è§æ€§åˆ¤æ–­](#42-ç‰ˆæœ¬å¯è§æ€§åˆ¤æ–­)
    - [4.3. å¿«ç…§éš”ç¦»å®ç°](#43-å¿«ç…§éš”ç¦»å®ç°)
  - [5. é”ç®¡ç†ç®—æ³•](#5-é”ç®¡ç†ç®—æ³•)
    - [5.1. é”å…¼å®¹çŸ©é˜µ](#51-é”å…¼å®¹çŸ©é˜µ)
  - [6. é”ç®¡ç†å™¨](#6-é”ç®¡ç†å™¨)
  - [7. æ­»é”æ£€æµ‹ç®—æ³•](#7-æ­»é”æ£€æµ‹ç®—æ³•)
    - [7.1. ç­‰å¾…å›¾æ„å»º](#71-ç­‰å¾…å›¾æ„å»º)
  - [8. æ­»é”æ£€æµ‹ä¸è§£å†³](#8-æ­»é”æ£€æµ‹ä¸è§£å†³)
  - [9. äº‹åŠ¡è°ƒåº¦ç®—æ³•](#9-äº‹åŠ¡è°ƒåº¦ç®—æ³•)
    - [9.1. å¯ä¸²è¡ŒåŒ–è°ƒåº¦](#91-å¯ä¸²è¡ŒåŒ–è°ƒåº¦)
  - [10. æœ¬åœ°è·³è½¬ä¸äº¤å‰å¼•ç”¨](#10-æœ¬åœ°è·³è½¬ä¸äº¤å‰å¼•ç”¨)
  - [11. å¤šè¡¨å¾](#11-å¤šè¡¨å¾)
  - [12. å½¢å¼åŒ–è¯­ä¹‰](#12-å½¢å¼åŒ–è¯­ä¹‰)
  - [13. å½¢å¼åŒ–è¯­æ³•ä¸è¯æ˜](#13-å½¢å¼åŒ–è¯­æ³•ä¸è¯æ˜)

---


## 1. æ‘˜è¦

æœ¬æ–‡ä»¶ç³»ç»Ÿæ¢³ç†æ•°æ®åº“å¹¶å‘æ§åˆ¶çš„æ ¸å¿ƒç®—æ³•ï¼Œä»¥PostgreSQLçš„MVCCæœºåˆ¶ä¸ºä¾‹ï¼Œæ¶µç›–å¤šç‰ˆæœ¬å¹¶å‘æ§åˆ¶ã€é”ç®¡ç†ã€æ­»é”æ£€æµ‹ã€äº‹åŠ¡è°ƒåº¦ç­‰å…³é”®æŠ€æœ¯ã€‚

---

## 3. å¹¶å‘æ§åˆ¶æ¦‚è¿°

å¹¶å‘æ§åˆ¶ç¡®ä¿å¤šä¸ªäº‹åŠ¡å¹¶å‘æ‰§è¡Œæ—¶ï¼Œæ•°æ®åº“ä¿æŒä¸€è‡´æ€§ã€‚

**æ ¸å¿ƒé—®é¢˜**ï¼š

- è„è¯» (Dirty Read)
- ä¸å¯é‡å¤è¯» (Non-repeatable Read)
- å¹»è¯» (Phantom Read)
- ä¸¢å¤±æ›´æ–° (Lost Update)

**éš”ç¦»çº§åˆ«**ï¼š

- READ UNCOMMITTED
- READ COMMITTED
- REPEATABLE READ
- SERIALIZABLE

## 4. å¤šç‰ˆæœ¬å¹¶å‘æ§åˆ¶(MVCC)

### 4.1. ç‰ˆæœ¬é“¾ç®¡ç†

```rust
// Rustå®ç°ï¼šç‰ˆæœ¬é“¾ç»“æ„
#[derive(Debug, Clone)]
struct Version {
    xmin: TransactionId,    // åˆ›å»ºè¯¥ç‰ˆæœ¬çš„äº‹åŠ¡ID
    xmax: TransactionId,    // åˆ é™¤è¯¥ç‰ˆæœ¬çš„äº‹åŠ¡ID
    cid: CommandId,         // å‘½ä»¤ID
    data: Vec<u8>,          // å®é™…æ•°æ®
    next: Option<Box<Version>>, // ä¸‹ä¸€ä¸ªç‰ˆæœ¬
}

#[derive(Debug)]
struct MVCCRecord {
    versions: Option<Box<Version>>, // ç‰ˆæœ¬é“¾å¤´
    current: Option<Box<Version>>,  // å½“å‰å¯è§ç‰ˆæœ¬
}
```

### 4.2. ç‰ˆæœ¬å¯è§æ€§åˆ¤æ–­

```rust
// Rustå®ç°ï¼šç‰ˆæœ¬å¯è§æ€§åˆ¤æ–­
impl MVCCRecord {
    fn is_visible(&self, version: &Version, snapshot: &Snapshot) -> bool {
        // æ£€æŸ¥ç‰ˆæœ¬æ˜¯å¦å¯¹å½“å‰å¿«ç…§å¯è§
        if version.xmax != INVALID_TXN_ID &&
           snapshot.is_active(version.xmax) {
            return false; // è¢«æœªæäº¤äº‹åŠ¡åˆ é™¤
        }

        if !snapshot.is_active(version.xmin) {
            return false; // åˆ›å»ºäº‹åŠ¡æœªæäº¤
        }

        true
    }

    fn get_visible_version(&self, snapshot: &Snapshot) -> Option<&Version> {
        let mut current = self.versions.as_ref();
        while let Some(version) = current {
            if self.is_visible(version, snapshot) {
                return Some(version);
            }
            current = version.next.as_ref();
        }
        None
    }
}
```

### 4.3. å¿«ç…§éš”ç¦»å®ç°

```go
// Goå®ç°ï¼šå¿«ç…§éš”ç¦»
type Snapshot struct {
    xmin    TransactionId
    xmax    TransactionId
    xip     map[TransactionId]bool // æ´»è·ƒäº‹åŠ¡åˆ—è¡¨
}

type Transaction struct {
    id        TransactionId
    snapshot  *Snapshot
    status    TransactionStatus
    startTime time.Time
}

func (t *Transaction) Begin() {
    t.snapshot = t.createSnapshot()
    t.status = ACTIVE
}

func (t *Transaction) createSnapshot() *Snapshot {
    return &Snapshot{
        xmin: getOldestActiveTxn(),
        xmax: getNextTxnId(),
        xip:  getActiveTxnList(),
    }
}
```

## 5. é”ç®¡ç†ç®—æ³•

### 5.1. é”å…¼å®¹çŸ©é˜µ

```python
# Pythonå®ç°ï¼šé”å…¼å®¹çŸ©é˜µ
class LockType:
    SHARED = 0
    EXCLUSIVE = 1
    INTENT_SHARED = 2
    INTENT_EXCLUSIVE = 3
    SHARED_INTENT_EXCLUSIVE = 4

# é”å…¼å®¹çŸ©é˜µ
LOCK_COMPATIBILITY = {
    LockType.SHARED: [True, False, True, False, False],
    LockType.EXCLUSIVE: [False, False, False, False, False],
    LockType.INTENT_SHARED: [True, False, True, True, True],
    LockType.INTENT_EXCLUSIVE: [False, False, True, True, False],
    LockType.SHARED_INTENT_EXCLUSIVE: [False, False, True, False, False]
}

def is_compatible(lock1, lock2):
    return LOCK_COMPATIBILITY[lock1][lock2]
```

## 6. é”ç®¡ç†å™¨

```go
// Goå®ç°ï¼šé”ç®¡ç†å™¨
type LockManager struct {
    locks map[string]*LockQueue
    mu    sync.RWMutex
}

type LockQueue struct {
    granted []*LockRequest
    waiting []*LockRequest
    mu      sync.Mutex
}

type LockRequest struct {
    txnId    TransactionId
    lockType LockType
    resource string
    granted  bool
    cond     *sync.Cond
}

func (lm *LockManager) AcquireLock(txnId TransactionId, resource string, lockType LockType) bool {
    lm.mu.Lock()
    queue, exists := lm.locks[resource]
    if !exists {
        queue = &LockQueue{}
        lm.locks[resource] = queue
    }
    lm.mu.Unlock()

    return queue.acquireLock(txnId, lockType)
}

func (lq *LockQueue) acquireLock(txnId TransactionId, lockType LockType) bool {
    lq.mu.Lock()
    defer lq.mu.Unlock()

    // æ£€æŸ¥æ˜¯å¦å¯ä»¥ç«‹å³è·å¾—é”
    if lq.canGrantLock(lockType) {
        lq.granted = append(lq.granted, &LockRequest{
            txnId:    txnId,
            lockType: lockType,
            granted:  true,
        })
        return true
    }

    // åŠ å…¥ç­‰å¾…é˜Ÿåˆ—
    request := &LockRequest{
        txnId:    txnId,
        lockType: lockType,
        granted:  false,
        cond:     sync.NewCond(&lq.mu),
    }
    lq.waiting = append(lq.waiting, request)

    // ç­‰å¾…é”è¢«æˆäºˆ
    for !request.granted {
        request.cond.Wait()
    }

    return true
}
```

## 7. æ­»é”æ£€æµ‹ç®—æ³•

### 7.1. ç­‰å¾…å›¾æ„å»º

```python
# Pythonå®ç°ï¼šç­‰å¾…å›¾æ„å»º
class WaitForGraph:
    def __init__(self):
        self.graph = defaultdict(set)
        self.reverse_graph = defaultdict(set)

    def add_edge(self, from_txn, to_txn):
        """æ·»åŠ ç­‰å¾…è¾¹ï¼šfrom_txn ç­‰å¾… to_txn"""
        self.graph[from_txn].add(to_txn)
        self.reverse_graph[to_txn].add(from_txn)

    def remove_edge(self, from_txn, to_txn):
        """ç§»é™¤ç­‰å¾…è¾¹"""
        self.graph[from_txn].discard(to_txn)
        self.reverse_graph[to_txn].discard(from_txn)

    def detect_cycle(self):
        """æ£€æµ‹ç¯ï¼ˆæ­»é”ï¼‰"""
        visited = set()
        rec_stack = set()

        def dfs(node):
            visited.add(node)
            rec_stack.add(node)

            for neighbor in self.graph[node]:
                if neighbor not in visited:
                    if dfs(neighbor):
                        return True
                elif neighbor in rec_stack:
                    return True

            rec_stack.remove(node)
            return False

        for node in self.graph:
            if node not in visited:
                if dfs(node):
                    return True
        return False
```

## 8. æ­»é”æ£€æµ‹ä¸è§£å†³

```go
// Goå®ç°ï¼šæ­»é”æ£€æµ‹ä¸è§£å†³
type DeadlockDetector struct {
    waitForGraph *WaitForGraph
    txnManager   *TransactionManager
}

func (dd *DeadlockDetector) DetectAndResolve() {
    if dd.waitForGraph.HasCycle() {
        // æ‰¾åˆ°æ­»é”ç¯
        cycle := dd.waitForGraph.FindCycle()

        // é€‰æ‹©ç‰ºç‰²è€…ï¼ˆé€šå¸¸é€‰æ‹©æœ€å¹´è½»çš„äº‹åŠ¡ï¼‰
        victim := dd.selectVictim(cycle)

        // ä¸­æ­¢ç‰ºç‰²è€…äº‹åŠ¡
        dd.txnManager.AbortTransaction(victim)

        // ç§»é™¤ç›¸å…³çš„ç­‰å¾…è¾¹
        dd.waitForGraph.RemoveTransactionEdges(victim)
    }
}

func (dd *DeadlockDetector) selectVictim(cycle []TransactionId) TransactionId {
    // é€‰æ‹©ç­–ç•¥ï¼šæœ€å¹´è½»çš„äº‹åŠ¡
    var youngest TransactionId
    var youngestTime time.Time

    for _, txnId := range cycle {
        txn := dd.txnManager.GetTransaction(txnId)
        if txn.StartTime.After(youngestTime) {
            youngest = txnId
            youngestTime = txn.StartTime
        }
    }

    return youngest
}
```

## 9. äº‹åŠ¡è°ƒåº¦ç®—æ³•

### 9.1. å¯ä¸²è¡ŒåŒ–è°ƒåº¦

```python
# Pythonå®ç°ï¼šå¯ä¸²è¡ŒåŒ–è°ƒåº¦æ£€æµ‹
class SerializableScheduler:
    def __init__(self):
        self.conflict_graph = defaultdict(set)

    def add_operation(self, txn_id, operation, resource):
        """æ·»åŠ æ“ä½œåˆ°è°ƒåº¦"""
# æ£€æŸ¥ä¸ä¹‹å‰æ“ä½œçš„å†²çª
        for prev_txn, prev_op, prev_resource in self.operations:
            if self.has_conflict(operation, prev_op, resource, prev_resource):
# æ·»åŠ å†²çªè¾¹
                self.conflict_graph[prev_txn].add(txn_id)

        self.operations.append((txn_id, operation, resource))

    def has_conflict(self, op1, op2, res1, res2):
        """æ£€æŸ¥ä¸¤ä¸ªæ“ä½œæ˜¯å¦æœ‰å†²çª"""
        if res1 != res2:
            return False

# è¯»å†™å†²çª
        if (op1 == 'R' and op2 == 'W') or (op1 == 'W' and op2 == 'R'):
            return True

# å†™å†™å†²çª
        if op1 == 'W' and op2 == 'W':
            return True

        return False

    def is_serializable(self):
        """æ£€æŸ¥è°ƒåº¦æ˜¯å¦å¯ä¸²è¡ŒåŒ–"""
        return not self.has_cycle()

    def has_cycle(self):
        """æ£€æµ‹å†²çªå›¾ä¸­æ˜¯å¦æœ‰ç¯"""
        visited = set()
        rec_stack = set()

        def dfs(node):
            visited.add(node)
            rec_stack.add(node)

            for neighbor in self.conflict_graph[node]:
                if neighbor not in visited:
                    if dfs(neighbor):
                        return True
                elif neighbor in rec_stack:
                    return True

            rec_stack.remove(node)
            return False

        for node in self.conflict_graph:
            if node not in visited:
                if dfs(node):
                    return True
        return False
```

## 10. æœ¬åœ°è·³è½¬ä¸äº¤å‰å¼•ç”¨

- [è¿”å›æ ¸å¿ƒæ•°æ®å¤„ç†ç®—æ³•](./3.3.1-æ ¸å¿ƒæ•°æ®å¤„ç†ç®—æ³•.md)
- [è·³è½¬åˆ°æŸ¥è¯¢ä¼˜åŒ–ç®—æ³•](./3.3.2-æŸ¥è¯¢ä¼˜åŒ–ç®—æ³•.md)
- [è·³è½¬åˆ°PostgreSQL MVCCåˆ†æ](../../1-æ•°æ®åº“ç³»ç»Ÿ/1.1-PostgreSQL/1.1.8-MVCCé«˜çº§åˆ†æä¸å½¢å¼è¯æ˜.md)
- [è·³è½¬åˆ°æ•°æ®æ¨¡å‹å½¢å¼åŒ–ç†è®º](../3.2-å½¢å¼åŒ–æ¨¡å‹/3.2.1-æ•°æ®æ¨¡å‹çš„å½¢å¼åŒ–ç†è®º.md)

---

**æœ€åæ›´æ–°**: 2024å¹´12æœˆ
**ç‰ˆæœ¬**: v1.0
**çŠ¶æ€**: âœ… å·²å®Œæˆ

## 11. å¤šè¡¨å¾

å¹¶å‘æ§åˆ¶ç®—æ³•æ”¯æŒå¤šç§è¡¨å¾æ–¹å¼ï¼ŒåŒ…æ‹¬ï¼š

- ç¬¦å·è¡¨å¾ï¼ˆå¹¶å‘åè®®ã€é”æœºåˆ¶ã€è°ƒåº¦ç®—æ³•ã€ä¼ªä»£ç ç­‰ï¼‰
- å›¾ç»“æ„ï¼ˆé”ä¾èµ–å›¾ã€è°ƒåº¦æµç¨‹å›¾ã€å†²çªå›¾ç­‰ï¼‰
- å‘é‡/å¼ é‡ï¼ˆçŠ¶æ€å‘é‡ã€å‚æ•°çŸ©é˜µã€ç‰¹å¾åµŒå…¥ï¼‰
- è‡ªç„¶è¯­è¨€ï¼ˆå®šä¹‰ã€æ³¨é‡Šã€æè¿°ï¼‰
- å›¾åƒ/å¯è§†åŒ–ï¼ˆæµç¨‹å›¾ã€ç»“æ„å›¾ã€å¹¶å‘å¯è§†åŒ–ç­‰ï¼‰
è¿™äº›è¡¨å¾å¯äº’æ˜ ï¼Œæå‡å¹¶å‘æ§åˆ¶ç®—æ³•çš„è¡¨è¾¾åŠ›ã€‚

## 12. å½¢å¼åŒ–è¯­ä¹‰

- è¯­ä¹‰åŸŸï¼š$D$ï¼Œå¦‚äº‹åŠ¡å¯¹è±¡é›†ã€é”ç©ºé—´ã€è°ƒåº¦æ¨¡å‹ç©ºé—´
- è§£é‡Šå‡½æ•°ï¼š$I: S \to D$ï¼Œå°†ç¬¦å·/ç»“æ„æ˜ å°„åˆ°å…·ä½“è¯­ä¹‰å¯¹è±¡
- è¯­ä¹‰ä¸€è‡´æ€§ï¼šæ¯ä¸ªåè®®/è°ƒåº¦/å…¬å¼åœ¨$D$ä¸­æœ‰æ˜ç¡®å®šä¹‰

## 13. å½¢å¼åŒ–è¯­æ³•ä¸è¯æ˜

- è¯­æ³•è§„åˆ™ï¼šå¦‚åè®®å®šä¹‰ã€è°ƒåº¦è§„åˆ™ã€æ¨ç†è§„åˆ™ã€çº¦æŸæ¡ä»¶
- **å®šç†**ï¼šå¹¶å‘æ§åˆ¶ç®—æ³•çš„è¯­æ³•ç³»ç»Ÿå…·ä¸€è‡´æ€§ä¸å¯æ‰©å±•æ€§ã€‚
- **è¯æ˜**ï¼šç”±åè®®å®šä¹‰ã€è°ƒåº¦è§„åˆ™ä¸æ¨ç†è§„åˆ™é€’å½’å®šä¹‰ï¼Œä¿è¯ç³»ç»Ÿä¸€è‡´ä¸å¯æ‰©å±•ã€‚
