# 算法实现实践案例

## 概述

本文档提供算法实现模块的实践案例，包括核心数据处理算法、查询优化算法和并发控制算法。

## 1. 核心数据处理算法

### 1.1 排序算法

```python
class SortingAlgorithms:
    @staticmethod
    def quick_sort(arr):
        if len(arr) <= 1:
            return arr
        pivot = arr[len(arr) // 2]
        left = [x for x in arr if x < pivot]
        middle = [x for x in arr if x == pivot]
        right = [x for x in arr if x > pivot]
        return SortingAlgorithms.quick_sort(left) + middle + SortingAlgorithms.quick_sort(right)
    
    @staticmethod
    def merge_sort(arr):
        if len(arr) <= 1:
            return arr
        mid = len(arr) // 2
        left = SortingAlgorithms.merge_sort(arr[:mid])
        right = SortingAlgorithms.merge_sort(arr[mid:])
        return SortingAlgorithms._merge(left, right)
    
    @staticmethod
    def _merge(left, right):
        result = []
        i = j = 0
        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                result.append(left[i])
                i += 1
            else:
                result.append(right[j])
                j += 1
        result.extend(left[i:])
        result.extend(right[j:])
        return result

# 使用示例
data = [64, 34, 25, 12, 22, 11, 90]
print("快速排序:", SortingAlgorithms.quick_sort(data.copy()))
print("归并排序:", SortingAlgorithms.merge_sort(data.copy()))
```

### 1.2 搜索算法

```python
class SearchAlgorithms:
    @staticmethod
    def binary_search(arr, target):
        left, right = 0, len(arr) - 1
        while left <= right:
            mid = (left + right) // 2
            if arr[mid] == target:
                return mid
            elif arr[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        return -1
    
    @staticmethod
    def linear_search(arr, target):
        for i, value in enumerate(arr):
            if value == target:
                return i
        return -1

# 使用示例
sorted_data = [1, 3, 5, 7, 9, 11, 13, 15]
target = 7
print("二分搜索:", SearchAlgorithms.binary_search(sorted_data, target))
print("线性搜索:", SearchAlgorithms.linear_search(sorted_data, target))
```

## 2. 查询优化算法

### 2.1 查询计划生成

```python
class QueryPlan:
    def __init__(self, operation, cost=0, children=None):
        self.operation = operation
        self.cost = cost
        self.children = children or []
    
    def __str__(self):
        return f"{self.operation} (cost: {self.cost})"

class QueryOptimizer:
    def __init__(self):
        self.table_stats = {}
    
    def set_table_stats(self, table_name, row_count):
        self.table_stats[table_name] = {'row_count': row_count}
    
    def generate_scan_plan(self, table_name):
        cost = self.table_stats.get(table_name, {}).get('row_count', 1000)
        return QueryPlan(f"Scan({table_name})", cost)
    
    def generate_join_plan(self, left_plan, right_plan, join_condition):
        cost = left_plan.cost + right_plan.cost + 1000
        return QueryPlan(f"Join({join_condition})", cost, [left_plan, right_plan])

# 使用示例
optimizer = QueryOptimizer()
optimizer.set_table_stats("users", 10000)
optimizer.set_table_stats("orders", 50000)

scan_plan = optimizer.generate_scan_plan("users")
join_plan = optimizer.generate_join_plan(scan_plan, scan_plan, "users.id = orders.user_id")
print("查询计划:", join_plan)
```

### 2.2 索引选择

```python
class Index:
    def __init__(self, name, table, columns, selectivity=0.1):
        self.name = name
        self.table = table
        self.columns = columns
        self.selectivity = selectivity

class IndexSelector:
    def __init__(self):
        self.indexes = []
    
    def add_index(self, index):
        self.indexes.append(index)
    
    def select_best_index(self, table, query_conditions):
        best_index = None
        best_cost = float('infinity')
        
        for index in self.indexes:
            if index.table == table:
                cost = 1000 * index.selectivity
                if cost < best_cost:
                    best_cost = cost
                    best_index = index
        
        return best_index

# 使用示例
selector = IndexSelector()
selector.add_index(Index("idx_users_id", "users", ["id"], 0.01))
selector.add_index(Index("idx_users_email", "users", ["email"], 0.05))

best_index = selector.select_best_index("users", ["users.id = 123"])
print("最佳索引:", best_index.name if best_index else "无")
```

## 3. 并发控制算法

### 3.1 锁管理器

```python
import threading
from enum import Enum

class LockType(Enum):
    SHARED = "SHARED"
    EXCLUSIVE = "EXCLUSIVE"

class Lock:
    def __init__(self, resource_id):
        self.resource_id = resource_id
        self.holders = set()
        self.lock = threading.Lock()
    
    def acquire(self, transaction_id, lock_type):
        with self.lock:
            if lock_type == LockType.SHARED:
                if not any(lt == LockType.EXCLUSIVE for _, lt in self.holders):
                    self.holders.add((transaction_id, lock_type))
                    return True
            else:
                if len(self.holders) == 0:
                    self.holders.add((transaction_id, lock_type))
                    return True
            return False
    
    def release(self, transaction_id):
        with self.lock:
            self.holders = {(tid, lt) for tid, lt in self.holders if tid != transaction_id}

class LockManager:
    def __init__(self):
        self.locks = {}
        self.lock = threading.Lock()
    
    def acquire_lock(self, transaction_id, resource_id, lock_type):
        with self.lock:
            if resource_id not in self.locks:
                self.locks[resource_id] = Lock(resource_id)
            return self.locks[resource_id].acquire(transaction_id, lock_type)
    
    def release_lock(self, transaction_id, resource_id):
        if resource_id in self.locks:
            self.locks[resource_id].release(transaction_id)

# 使用示例
lock_manager = LockManager()
print("获取共享锁:", lock_manager.acquire_lock(1, "A", LockType.SHARED))
print("获取排他锁:", lock_manager.acquire_lock(2, "A", LockType.EXCLUSIVE))
```

### 3.2 时间戳排序

```python
import time
from enum import Enum

class TransactionStatus(Enum):
    ACTIVE = "ACTIVE"
    COMMITTED = "COMMITTED"
    ABORTED = "ABORTED"

class TimestampOrdering:
    def __init__(self):
        self.transactions = {}
        self.resource_timestamps = {}
        self.lock = threading.Lock()
    
    def begin_transaction(self, transaction_id):
        with self.lock:
            transaction = {
                'id': transaction_id,
                'timestamp': time.time(),
                'status': TransactionStatus.ACTIVE
            }
            self.transactions[transaction_id] = transaction
            return transaction
    
    def read(self, transaction_id, resource_id):
        with self.lock:
            transaction = self.transactions.get(transaction_id)
            if not transaction or transaction['status'] != TransactionStatus.ACTIVE:
                raise ValueError("事务不存在或已结束")
            
            if resource_id in self.resource_timestamps:
                write_timestamp = self.resource_timestamps[resource_id].get('write', 0)
                if transaction['timestamp'] < write_timestamp:
                    transaction['status'] = TransactionStatus.ABORTED
                    raise ValueError("时间戳冲突")
            
            return f"读取资源 {resource_id}"
    
    def write(self, transaction_id, resource_id):
        with self.lock:
            transaction = self.transactions.get(transaction_id)
            if not transaction or transaction['status'] != TransactionStatus.ACTIVE:
                raise ValueError("事务不存在或已结束")
            
            if resource_id not in self.resource_timestamps:
                self.resource_timestamps[resource_id] = {}
            
            self.resource_timestamps[resource_id]['write'] = transaction['timestamp']
            return f"写入资源 {resource_id}"

# 使用示例
ts_ordering = TimestampOrdering()
transaction = ts_ordering.begin_transaction(1)
print("读取操作:", ts_ordering.read(1, "A"))
print("写入操作:", ts_ordering.write(1, "A"))
```

### 3.3 乐观并发控制

```python
class OptimisticConcurrencyControl:
    def __init__(self):
        self.resources = {}  # 资源 -> (值, 版本号)
        self.transactions = {}
        self.lock = threading.Lock()
    
    def initialize_resource(self, resource_id, initial_value):
        with self.lock:
            self.resources[resource_id] = (initial_value, 0)
    
    def begin_transaction(self, transaction_id):
        with self.lock:
            transaction = {
                'id': transaction_id,
                'read_set': {},
                'write_set': {},
                'status': TransactionStatus.ACTIVE
            }
            self.transactions[transaction_id] = transaction
            return transaction
    
    def read(self, transaction_id, resource_id):
        with self.lock:
            transaction = self.transactions.get(transaction_id)
            if not transaction or transaction['status'] != TransactionStatus.ACTIVE:
                raise ValueError("事务不存在或已结束")
            
            if resource_id not in self.resources:
                raise ValueError(f"资源 {resource_id} 不存在")
            
            value, version = self.resources[resource_id]
            transaction['read_set'][resource_id] = version
            return value
    
    def write(self, transaction_id, resource_id, new_value):
        with self.lock:
            transaction = self.transactions.get(transaction_id)
            if not transaction or transaction['status'] != TransactionStatus.ACTIVE:
                raise ValueError("事务不存在或已结束")
            
            transaction['write_set'][resource_id] = new_value
            return f"准备写入资源 {resource_id}"
    
    def commit(self, transaction_id):
        with self.lock:
            transaction = self.transactions.get(transaction_id)
            if not transaction or transaction['status'] != TransactionStatus.ACTIVE:
                return f"事务 {transaction_id} 提交失败"
            
            # 验证阶段
            for resource_id, read_version in transaction['read_set'].items():
                if resource_id in self.resources:
                    current_value, current_version = self.resources[resource_id]
                    if current_version != read_version:
                        transaction['status'] = TransactionStatus.ABORTED
                        return f"事务 {transaction_id} 被中止：版本冲突"
            
            # 写入阶段
            for resource_id, new_value in transaction['write_set'].items():
                if resource_id in self.resources:
                    current_value, current_version = self.resources[resource_id]
                    self.resources[resource_id] = (new_value, current_version + 1)
                else:
                    self.resources[resource_id] = (new_value, 0)
            
            transaction['status'] = TransactionStatus.COMMITTED
            return f"事务 {transaction_id} 提交成功"

# 使用示例
occ = OptimisticConcurrencyControl()
occ.initialize_resource("A", 100)
occ.initialize_resource("B", 200)

transaction = occ.begin_transaction(1)
print("读取:", occ.read(1, "A"))
print("写入:", occ.write(1, "B", 250))
print("提交:", occ.commit(1))
```

## 总结

本文档提供了算法实现模块的实践案例，包括：

1. **核心数据处理算法**：排序算法、搜索算法
2. **查询优化算法**：查询计划生成、索引选择
3. **并发控制算法**：锁管理器、时间戳排序、乐观并发控制

这些实践案例展示了如何将算法理论应用到实际的数据处理系统中。
