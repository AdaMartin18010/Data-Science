# ç®—æ³•å®ç°å®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [ç®—æ³•å®ç°å®è·µæ¡ˆä¾‹](#ç®—æ³•å®ç°å®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2. æ ¸å¿ƒæ•°æ®å¤„ç†ç®—æ³•](#2-æ ¸å¿ƒæ•°æ®å¤„ç†ç®—æ³•)
    - [2.1. æ’åºç®—æ³•](#21-æ’åºç®—æ³•)
  - [3. æœç´¢ç®—æ³•](#3-æœç´¢ç®—æ³•)
  - [4. æŸ¥è¯¢ä¼˜åŒ–ç®—æ³•](#4-æŸ¥è¯¢ä¼˜åŒ–ç®—æ³•)
    - [4.1. æŸ¥è¯¢è®¡åˆ’ç”Ÿæˆ](#41-æŸ¥è¯¢è®¡åˆ’ç”Ÿæˆ)
  - [5. ç´¢å¼•é€‰æ‹©](#5-ç´¢å¼•é€‰æ‹©)
  - [6. å¹¶å‘æ§åˆ¶ç®—æ³•](#6-å¹¶å‘æ§åˆ¶ç®—æ³•)
    - [6.1. é”ç®¡ç†å™¨](#61-é”ç®¡ç†å™¨)
  - [7. æ—¶é—´æˆ³æ’åº](#7-æ—¶é—´æˆ³æ’åº)
  - [8. ä¹è§‚å¹¶å‘æ§åˆ¶](#8-ä¹è§‚å¹¶å‘æ§åˆ¶)
  - [9. æ€»ç»“](#9-æ€»ç»“)

---


## 1. æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›ç®—æ³•å®ç°æ¨¡å—çš„å®è·µæ¡ˆä¾‹ï¼ŒåŒ…æ‹¬æ ¸å¿ƒæ•°æ®å¤„ç†ç®—æ³•ã€æŸ¥è¯¢ä¼˜åŒ–ç®—æ³•å’Œå¹¶å‘æ§åˆ¶ç®—æ³•ã€‚

## 2. æ ¸å¿ƒæ•°æ®å¤„ç†ç®—æ³•

### 2.1. æ’åºç®—æ³•

```python
class SortingAlgorithms:
    @staticmethod
    def quick_sort(arr):
        if len(arr) <= 1:
            return arr
        pivot = arr[len(arr) // 2]
        left = [x for x in arr if x < pivot]
        middle = [x for x in arr if x == pivot]
        right = [x for x in arr if x > pivot]
        return SortingAlgorithms.quick_sort(left) + middle + SortingAlgorithms.quick_sort(right)

    @staticmethod
    def merge_sort(arr):
        if len(arr) <= 1:
            return arr
        mid = len(arr) // 2
        left = SortingAlgorithms.merge_sort(arr[:mid])
        right = SortingAlgorithms.merge_sort(arr[mid:])
        return SortingAlgorithms._merge(left, right)

    @staticmethod
    def _merge(left, right):
        result = []
        i = j = 0
        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                result.append(left[i])
                i += 1
            else:
                result.append(right[j])
                j += 1
        result.extend(left[i:])
        result.extend(right[j:])
        return result

# ä½¿ç”¨ç¤ºä¾‹
data = [64, 34, 25, 12, 22, 11, 90]
print("å¿«é€Ÿæ’åº:", SortingAlgorithms.quick_sort(data.copy()))
print("å½’å¹¶æ’åº:", SortingAlgorithms.merge_sort(data.copy()))
```

## 3. æœç´¢ç®—æ³•

```python
class SearchAlgorithms:
    @staticmethod
    def binary_search(arr, target):
        left, right = 0, len(arr) - 1
        while left <= right:
            mid = (left + right) // 2
            if arr[mid] == target:
                return mid
            elif arr[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        return -1

    @staticmethod
    def linear_search(arr, target):
        for i, value in enumerate(arr):
            if value == target:
                return i
        return -1

# ä½¿ç”¨ç¤ºä¾‹
sorted_data = [1, 3, 5, 7, 9, 11, 13, 15]
target = 7
print("äºŒåˆ†æœç´¢:", SearchAlgorithms.binary_search(sorted_data, target))
print("çº¿æ€§æœç´¢:", SearchAlgorithms.linear_search(sorted_data, target))
```

## 4. æŸ¥è¯¢ä¼˜åŒ–ç®—æ³•

### 4.1. æŸ¥è¯¢è®¡åˆ’ç”Ÿæˆ

```python
class QueryPlan:
    def __init__(self, operation, cost=0, children=None):
        self.operation = operation
        self.cost = cost
        self.children = children or []

    def __str__(self):
        return f"{self.operation} (cost: {self.cost})"

class QueryOptimizer:
    def __init__(self):
        self.table_stats = {}

    def set_table_stats(self, table_name, row_count):
        self.table_stats[table_name] = {'row_count': row_count}

    def generate_scan_plan(self, table_name):
        cost = self.table_stats.get(table_name, {}).get('row_count', 1000)
        return QueryPlan(f"Scan({table_name})", cost)

    def generate_join_plan(self, left_plan, right_plan, join_condition):
        cost = left_plan.cost + right_plan.cost + 1000
        return QueryPlan(f"Join({join_condition})", cost, [left_plan, right_plan])

# ä½¿ç”¨ç¤ºä¾‹
optimizer = QueryOptimizer()
optimizer.set_table_stats("users", 10000)
optimizer.set_table_stats("orders", 50000)

scan_plan = optimizer.generate_scan_plan("users")
join_plan = optimizer.generate_join_plan(scan_plan, scan_plan, "users.id = orders.user_id")
print("æŸ¥è¯¢è®¡åˆ’:", join_plan)
```

## 5. ç´¢å¼•é€‰æ‹©

```python
class Index:
    def __init__(self, name, table, columns, selectivity=0.1):
        self.name = name
        self.table = table
        self.columns = columns
        self.selectivity = selectivity

class IndexSelector:
    def __init__(self):
        self.indexes = []

    def add_index(self, index):
        self.indexes.append(index)

    def select_best_index(self, table, query_conditions):
        best_index = None
        best_cost = float('infinity')

        for index in self.indexes:
            if index.table == table:
                cost = 1000 * index.selectivity
                if cost < best_cost:
                    best_cost = cost
                    best_index = index

        return best_index

# ä½¿ç”¨ç¤ºä¾‹
selector = IndexSelector()
selector.add_index(Index("idx_users_id", "users", ["id"], 0.01))
selector.add_index(Index("idx_users_email", "users", ["email"], 0.05))

best_index = selector.select_best_index("users", ["users.id = 123"])
print("æœ€ä½³ç´¢å¼•:", best_index.name if best_index else "æ— ")
```

## 6. å¹¶å‘æ§åˆ¶ç®—æ³•

### 6.1. é”ç®¡ç†å™¨

```python
import threading
from enum import Enum

class LockType(Enum):
    SHARED = "SHARED"
    EXCLUSIVE = "EXCLUSIVE"

class Lock:
    def __init__(self, resource_id):
        self.resource_id = resource_id
        self.holders = set()
        self.lock = threading.Lock()

    def acquire(self, transaction_id, lock_type):
        with self.lock:
            if lock_type == LockType.SHARED:
                if not any(lt == LockType.EXCLUSIVE for _, lt in self.holders):
                    self.holders.add((transaction_id, lock_type))
                    return True
            else:
                if len(self.holders) == 0:
                    self.holders.add((transaction_id, lock_type))
                    return True
            return False

    def release(self, transaction_id):
        with self.lock:
            self.holders = {(tid, lt) for tid, lt in self.holders if tid != transaction_id}

class LockManager:
    def __init__(self):
        self.locks = {}
        self.lock = threading.Lock()

    def acquire_lock(self, transaction_id, resource_id, lock_type):
        with self.lock:
            if resource_id not in self.locks:
                self.locks[resource_id] = Lock(resource_id)
            return self.locks[resource_id].acquire(transaction_id, lock_type)

    def release_lock(self, transaction_id, resource_id):
        if resource_id in self.locks:
            self.locks[resource_id].release(transaction_id)

# ä½¿ç”¨ç¤ºä¾‹
lock_manager = LockManager()
print("è·å–å…±äº«é”:", lock_manager.acquire_lock(1, "A", LockType.SHARED))
print("è·å–æ’ä»–é”:", lock_manager.acquire_lock(2, "A", LockType.EXCLUSIVE))
```

## 7. æ—¶é—´æˆ³æ’åº

```python
import time
from enum import Enum

class TransactionStatus(Enum):
    ACTIVE = "ACTIVE"
    COMMITTED = "COMMITTED"
    ABORTED = "ABORTED"

class TimestampOrdering:
    def __init__(self):
        self.transactions = {}
        self.resource_timestamps = {}
        self.lock = threading.Lock()

    def begin_transaction(self, transaction_id):
        with self.lock:
            transaction = {
                'id': transaction_id,
                'timestamp': time.time(),
                'status': TransactionStatus.ACTIVE
            }
            self.transactions[transaction_id] = transaction
            return transaction

    def read(self, transaction_id, resource_id):
        with self.lock:
            transaction = self.transactions.get(transaction_id)
            if not transaction or transaction['status'] != TransactionStatus.ACTIVE:
                raise ValueError("äº‹åŠ¡ä¸å­˜åœ¨æˆ–å·²ç»“æŸ")

            if resource_id in self.resource_timestamps:
                write_timestamp = self.resource_timestamps[resource_id].get('write', 0)
                if transaction['timestamp'] < write_timestamp:
                    transaction['status'] = TransactionStatus.ABORTED
                    raise ValueError("æ—¶é—´æˆ³å†²çª")

            return f"è¯»å–èµ„æº {resource_id}"

    def write(self, transaction_id, resource_id):
        with self.lock:
            transaction = self.transactions.get(transaction_id)
            if not transaction or transaction['status'] != TransactionStatus.ACTIVE:
                raise ValueError("äº‹åŠ¡ä¸å­˜åœ¨æˆ–å·²ç»“æŸ")

            if resource_id not in self.resource_timestamps:
                self.resource_timestamps[resource_id] = {}

            self.resource_timestamps[resource_id]['write'] = transaction['timestamp']
            return f"å†™å…¥èµ„æº {resource_id}"

# ä½¿ç”¨ç¤ºä¾‹
ts_ordering = TimestampOrdering()
transaction = ts_ordering.begin_transaction(1)
print("è¯»å–æ“ä½œ:", ts_ordering.read(1, "A"))
print("å†™å…¥æ“ä½œ:", ts_ordering.write(1, "A"))
```

## 8. ä¹è§‚å¹¶å‘æ§åˆ¶

```python
class OptimisticConcurrencyControl:
    def __init__(self):
        self.resources = {}  # èµ„æº -> (å€¼, ç‰ˆæœ¬å·)
        self.transactions = {}
        self.lock = threading.Lock()

    def initialize_resource(self, resource_id, initial_value):
        with self.lock:
            self.resources[resource_id] = (initial_value, 0)

    def begin_transaction(self, transaction_id):
        with self.lock:
            transaction = {
                'id': transaction_id,
                'read_set': {},
                'write_set': {},
                'status': TransactionStatus.ACTIVE
            }
            self.transactions[transaction_id] = transaction
            return transaction

    def read(self, transaction_id, resource_id):
        with self.lock:
            transaction = self.transactions.get(transaction_id)
            if not transaction or transaction['status'] != TransactionStatus.ACTIVE:
                raise ValueError("äº‹åŠ¡ä¸å­˜åœ¨æˆ–å·²ç»“æŸ")

            if resource_id not in self.resources:
                raise ValueError(f"èµ„æº {resource_id} ä¸å­˜åœ¨")

            value, version = self.resources[resource_id]
            transaction['read_set'][resource_id] = version
            return value

    def write(self, transaction_id, resource_id, new_value):
        with self.lock:
            transaction = self.transactions.get(transaction_id)
            if not transaction or transaction['status'] != TransactionStatus.ACTIVE:
                raise ValueError("äº‹åŠ¡ä¸å­˜åœ¨æˆ–å·²ç»“æŸ")

            transaction['write_set'][resource_id] = new_value
            return f"å‡†å¤‡å†™å…¥èµ„æº {resource_id}"

    def commit(self, transaction_id):
        with self.lock:
            transaction = self.transactions.get(transaction_id)
            if not transaction or transaction['status'] != TransactionStatus.ACTIVE:
                return f"äº‹åŠ¡ {transaction_id} æäº¤å¤±è´¥"

# éªŒè¯é˜¶æ®µ
            for resource_id, read_version in transaction['read_set'].items():
                if resource_id in self.resources:
                    current_value, current_version = self.resources[resource_id]
                    if current_version != read_version:
                        transaction['status'] = TransactionStatus.ABORTED
                        return f"äº‹åŠ¡ {transaction_id} è¢«ä¸­æ­¢ï¼šç‰ˆæœ¬å†²çª"

# å†™å…¥é˜¶æ®µ
            for resource_id, new_value in transaction['write_set'].items():
                if resource_id in self.resources:
                    current_value, current_version = self.resources[resource_id]
                    self.resources[resource_id] = (new_value, current_version + 1)
                else:
                    self.resources[resource_id] = (new_value, 0)

            transaction['status'] = TransactionStatus.COMMITTED
            return f"äº‹åŠ¡ {transaction_id} æäº¤æˆåŠŸ"

# ä½¿ç”¨ç¤ºä¾‹
occ = OptimisticConcurrencyControl()
occ.initialize_resource("A", 100)
occ.initialize_resource("B", 200)

transaction = occ.begin_transaction(1)
print("è¯»å–:", occ.read(1, "A"))
print("å†™å…¥:", occ.write(1, "B", 250))
print("æäº¤:", occ.commit(1))
```

## 9. æ€»ç»“

æœ¬æ–‡æ¡£æä¾›äº†ç®—æ³•å®ç°æ¨¡å—çš„å®è·µæ¡ˆä¾‹ï¼ŒåŒ…æ‹¬ï¼š

1. **æ ¸å¿ƒæ•°æ®å¤„ç†ç®—æ³•**ï¼šæ’åºç®—æ³•ã€æœç´¢ç®—æ³•
2. **æŸ¥è¯¢ä¼˜åŒ–ç®—æ³•**ï¼šæŸ¥è¯¢è®¡åˆ’ç”Ÿæˆã€ç´¢å¼•é€‰æ‹©
3. **å¹¶å‘æ§åˆ¶ç®—æ³•**ï¼šé”ç®¡ç†å™¨ã€æ—¶é—´æˆ³æ’åºã€ä¹è§‚å¹¶å‘æ§åˆ¶

è¿™äº›å®è·µæ¡ˆä¾‹å±•ç¤ºäº†å¦‚ä½•å°†ç®—æ³•ç†è®ºåº”ç”¨åˆ°å®é™…çš„æ•°æ®å¤„ç†ç³»ç»Ÿä¸­ã€‚
