# 3.3.2 查询优化算法

## 📑 目录

- [3.3.2 查询优化算法](#332-查询优化算法)
  - [📑 目录](#-目录)
  - [1. 摘要](#1-摘要)
  - [2. 目录](#2-目录)
  - [3. 查询优化概述](#3-查询优化概述)
  - [4. 查询重写算法](#4-查询重写算法)
    - [4.1. 谓词下推 (Predicate Pushdown)](#41-谓词下推-predicate-pushdown)
    - [4.2. 常量折叠 (Constant Folding)](#42-常量折叠-constant-folding)
    - [4.3. 子查询优化](#43-子查询优化)
  - [5. 成本估算模型](#5-成本估算模型)
    - [5.1. 表扫描成本](#51-表扫描成本)
    - [5.2. 连接成本](#52-连接成本)
  - [6. 执行计划生成](#6-执行计划生成)
    - [6.1. 动态规划算法](#61-动态规划算法)
  - [7. 遗传算法优化](#7-遗传算法优化)
  - [8. 动态规划优化](#8-动态规划优化)
    - [8.1. 多表连接优化](#81-多表连接优化)
    - [8.2. 并行查询优化](#82-并行查询优化)
  - [9. 本地跳转与交叉引用](#9-本地跳转与交叉引用)
  - [10. 多表征](#10-多表征)
  - [11. 形式化语义](#11-形式化语义)
  - [12. 形式化语法与证明](#12-形式化语法与证明)
  - [13. 索引优化策略](#13-索引优化策略)
    - [13.1. 索引选择](#131-索引选择)
    - [13.2. 覆盖索引](#132-覆盖索引)
    - [13.3. 复合索引优化](#133-复合索引优化)
  - [14. 统计信息与成本估算](#14-统计信息与成本估算)
    - [14.1. 统计信息收集](#141-统计信息收集)
    - [14.2. 选择性估算](#142-选择性估算)
    - [14.3. 成本模型](#143-成本模型)
  - [15. 查询计划缓存](#15-查询计划缓存)
    - [15.1. 计划缓存策略](#151-计划缓存策略)
    - [15.2. 参数化查询](#152-参数化查询)
  - [16. 自适应查询优化](#16-自适应查询优化)
    - [16.1. 运行时优化](#161-运行时优化)
    - [16.2. 学习型优化器](#162-学习型优化器)
  - [17. 分布式查询优化](#17-分布式查询优化)
    - [17.1. 查询分解](#171-查询分解)
    - [17.2. 数据本地性](#172-数据本地性)
    - [17.3. 分布式连接](#173-分布式连接)
  - [18. 实际应用案例](#18-实际应用案例)
    - [18.1. PostgreSQL查询优化](#181-postgresql查询优化)
    - [18.2. Spark SQL优化](#182-spark-sql优化)
    - [18.3. 大数据查询优化](#183-大数据查询优化)
  - [19. 性能调优最佳实践](#19-性能调优最佳实践)
    - [19.1. 查询编写](#191-查询编写)
    - [19.2. 索引设计](#192-索引设计)
    - [19.3. 统计信息维护](#193-统计信息维护)
  - [20. 总结](#20-总结)

---


## 1. 摘要

本文件系统梳理数据库查询优化的核心算法，以PostgreSQL为例，涵盖查询重写、成本估算、执行计划生成、动态规划优化等关键技术。

## 2. 目录

- [3.3.2 查询优化算法](#332-查询优化算法)
  - [📑 目录](#-目录)
  - [1. 摘要](#1-摘要)
  - [2. 目录](#2-目录)
  - [3. 查询优化概述](#3-查询优化概述)
  - [4. 查询重写算法](#4-查询重写算法)
    - [4.1. 谓词下推 (Predicate Pushdown)](#41-谓词下推-predicate-pushdown)
    - [4.2. 常量折叠 (Constant Folding)](#42-常量折叠-constant-folding)
    - [4.3. 子查询优化](#43-子查询优化)
  - [5. 成本估算模型](#5-成本估算模型)
    - [5.1. 表扫描成本](#51-表扫描成本)
    - [5.2. 连接成本](#52-连接成本)
  - [6. 执行计划生成](#6-执行计划生成)
    - [6.1. 动态规划算法](#61-动态规划算法)
  - [7. 遗传算法优化](#7-遗传算法优化)
  - [8. 动态规划优化](#8-动态规划优化)
    - [8.1. 多表连接优化](#81-多表连接优化)
    - [8.2. 并行查询优化](#82-并行查询优化)
  - [9. 本地跳转与交叉引用](#9-本地跳转与交叉引用)
  - [10. 多表征](#10-多表征)
  - [11. 形式化语义](#11-形式化语义)
  - [12. 形式化语法与证明](#12-形式化语法与证明)
  - [13. 索引优化策略](#13-索引优化策略)
    - [13.1. 索引选择](#131-索引选择)
    - [13.2. 覆盖索引](#132-覆盖索引)
    - [13.3. 复合索引优化](#133-复合索引优化)
  - [14. 统计信息与成本估算](#14-统计信息与成本估算)
    - [14.1. 统计信息收集](#141-统计信息收集)
    - [14.2. 选择性估算](#142-选择性估算)
    - [14.3. 成本模型](#143-成本模型)
  - [15. 查询计划缓存](#15-查询计划缓存)
    - [15.1. 计划缓存策略](#151-计划缓存策略)
    - [15.2. 参数化查询](#152-参数化查询)
  - [16. 自适应查询优化](#16-自适应查询优化)
    - [16.1. 运行时优化](#161-运行时优化)
    - [16.2. 学习型优化器](#162-学习型优化器)
  - [17. 分布式查询优化](#17-分布式查询优化)
    - [17.1. 查询分解](#171-查询分解)
    - [17.2. 数据本地性](#172-数据本地性)
    - [17.3. 分布式连接](#173-分布式连接)
  - [18. 实际应用案例](#18-实际应用案例)
    - [18.1. PostgreSQL查询优化](#181-postgresql查询优化)
    - [18.2. Spark SQL优化](#182-spark-sql优化)
    - [18.3. 大数据查询优化](#183-大数据查询优化)
  - [19. 性能调优最佳实践](#19-性能调优最佳实践)
    - [19.1. 查询编写](#191-查询编写)
    - [19.2. 索引设计](#192-索引设计)
    - [19.3. 统计信息维护](#193-统计信息维护)
  - [20. 总结](#20-总结)

---

## 3. 查询优化概述

查询优化是将逻辑查询计划转换为高效物理执行计划的过程。

**形式化定义**：

- 查询计划空间：$P(Q)$ 是所有可能执行计划的集合
- 成本函数：$C: P(Q) \rightarrow \mathbb{R}^+$
- 优化目标：$p^* = \arg\min_{p \in P(Q)} C(p)$

## 4. 查询重写算法

### 4.1. 谓词下推 (Predicate Pushdown)

将选择条件尽可能下推到数据源，减少数据传输量。

```sql
-- 原始查询
SELECT * FROM orders o JOIN customers c ON o.customer_id = c.id
WHERE o.amount > 1000;

-- 重写后
SELECT * FROM (SELECT * FROM orders WHERE amount > 1000) o
JOIN customers c ON o.customer_id = c.id;
```

### 4.2. 常量折叠 (Constant Folding)

在编译时计算常量表达式。

```sql
-- 原始查询
SELECT * FROM products WHERE price > 100 + 50;

-- 重写后
SELECT * FROM products WHERE price > 150;
```

### 4.3. 子查询优化

将相关子查询转换为连接操作。

```sql
-- 原始查询
SELECT * FROM orders o WHERE o.amount >
  (SELECT AVG(amount) FROM orders WHERE customer_id = o.customer_id);

-- 重写后
SELECT o.* FROM orders o
JOIN (SELECT customer_id, AVG(amount) as avg_amount
      FROM orders GROUP BY customer_id) avg_orders
ON o.customer_id = avg_orders.customer_id
WHERE o.amount > avg_orders.avg_amount;
```

## 5. 成本估算模型

### 5.1. 表扫描成本

**顺序扫描成本**：
$$C_{seq}(R) = \frac{|R|}{P} \times t_{page}$$

其中：

- $|R|$ 是关系 $R$ 的页数
- $P$ 是并行度
- $t_{page}$ 是读取一页的时间

**索引扫描成本**：
$$C_{index}(R, I) = \log_B(|I|) \times t_{page} + \frac{|R_{result}|}{P} \times t_{page}$$

其中：

- $|I|$ 是索引的页数
- $B$ 是B+树的扇出因子
- $|R_{result}|$ 是结果集的页数

### 5.2. 连接成本

**嵌套循环连接**：
$$C_{nested}(R, S) = |R| \times |S| \times t_{tuple}$$

**哈希连接**：
$$C_{hash}(R, S) = |R| \times t_{page} + |S| \times t_{page} + |R| \times |S| \times t_{hash}$$

**排序合并连接**：
$$C_{sort-merge}(R, S) = C_{sort}(R) + C_{sort}(S) + |R| \times t_{page} + |S| \times t_{page}$$

## 6. 执行计划生成

### 6.1. 动态规划算法

```python
def dynamic_programming_optimization(tables):
    """
    使用动态规划生成最优连接顺序
    """
    n = len(tables)
    dp = {}  # dp[subset] = (cost, plan)

# 初始化单表
    for i in range(n):
        subset = frozenset([i])
        dp[subset] = (estimate_table_cost(tables[i]), [i])

# 逐步构建更大的子集
    for size in range(2, n + 1):
        for subset in combinations(range(n), size):
            subset = frozenset(subset)
            min_cost = float('inf')
            best_plan = None

# 尝试所有可能的分割
            for left_size in range(1, size):
                for left_subset in combinations(subset, left_size):
                    left_subset = frozenset(left_subset)
                    right_subset = subset - left_subset

                    if left_subset in dp and right_subset in dp:
                        left_cost, left_plan = dp[left_subset]
                        right_cost, right_plan = dp[right_subset]
                        join_cost = estimate_join_cost(left_subset, right_subset)
                        total_cost = left_cost + right_cost + join_cost

                        if total_cost < min_cost:
                            min_cost = total_cost
                            best_plan = left_plan + right_plan

            dp[subset] = (min_cost, best_plan)

    return dp[frozenset(range(n))]
```

## 7. 遗传算法优化

```python
def genetic_algorithm_optimization(tables, population_size=100, generations=50):
    """
    使用遗传算法优化查询计划
    """
    def create_individual():
        return random.sample(range(len(tables)), len(tables))

    def fitness(individual):
        return -estimate_join_cost(individual)  # 负成本作为适应度

    def crossover(parent1, parent2):
# 顺序交叉
        start, end = sorted(random.sample(range(len(parent1)), 2))
        child = [-1] * len(parent1)
        child[start:end] = parent1[start:end]

        remaining = [x for x in parent2 if x not in child[start:end]]
        j = 0
        for i in range(len(child)):
            if child[i] == -1:
                child[i] = remaining[j]
                j += 1

        return child

    def mutate(individual):
# 随机交换两个位置
        i, j = random.sample(range(len(individual)), 2)
        individual[i], individual[j] = individual[j], individual[i]
        return individual

# 初始化种群
    population = [create_individual() for _ in range(population_size)]

    for generation in range(generations):
# 评估适应度
        fitness_scores = [(fitness(ind), ind) for ind in population]
        fitness_scores.sort(reverse=True)

# 选择精英
        elite = [ind for _, ind in fitness_scores[:10]]

# 生成新种群
        new_population = elite.copy()
        while len(new_population) < population_size:
            parent1, parent2 = random.sample(elite, 2)
            child = crossover(parent1, parent2)
            if random.random() < 0.1:  # 10% 变异率
                child = mutate(child)
            new_population.append(child)

        population = new_population

    return fitness_scores[0][1]  # 返回最优个体
```

## 8. 动态规划优化

### 8.1. 多表连接优化

PostgreSQL使用动态规划算法优化多表连接顺序：

```sql
-- 示例查询
SELECT * FROM orders o
JOIN customers c ON o.customer_id = c.id
JOIN products p ON o.product_id = p.id
JOIN categories cat ON p.category_id = cat.id
WHERE o.amount > 1000;
```

**优化过程**：

1. 计算所有单表的扫描成本
2. 计算所有两表连接的成本和最优顺序
3. 逐步扩展到三表、四表连接
4. 选择成本最低的执行计划

### 8.2. 并行查询优化

```python
def parallel_query_optimization(query_plan, num_workers):
    """
    将查询计划并行化
    """
    def can_parallelize(operator):
        return operator.type in ['scan', 'filter', 'aggregate']

    def split_data(data, num_parts):
# 数据分片策略
        return [data[i::num_parts] for i in range(num_parts)]

    parallel_plan = []
    for operator in query_plan:
        if can_parallelize(operator):
# 创建并行算子
            parallel_operator = {
                'type': f'parallel_{operator.type}',
                'workers': num_workers,
                'split_strategy': split_data,
                'merge_strategy': 'union'
            }
            parallel_plan.append(parallel_operator)
        else:
            parallel_plan.append(operator)

    return parallel_plan
```

## 9. 本地跳转与交叉引用

- [返回核心数据处理算法](./3.3.1-核心数据处理算法.md)
- [跳转到PostgreSQL查询优化](../../1-数据库系统/1.1-PostgreSQL/1.1.4-查询优化.md)
- [跳转到数据模型形式化理论](../3.2-形式化模型/3.2.1-数据模型的形式化理论.md)

---

**最后更新**: 2024年12月
**版本**: v1.0
**状态**: ✅ 已完成

## 10. 多表征

查询优化算法支持多种表征方式，包括：

- 符号表征（优化规则、代价模型、伪代码等）
- 图结构（查询计划树、优化流程图、依赖图等）
- 向量/张量（代价向量、参数矩阵、特征嵌入）
- 自然语言（定义、注释、描述）
- 图像/可视化（查询计划图、流程图、优化可视化等）
这些表征可互映，提升查询优化算法的表达力。

## 11. 形式化语义

- 语义域：$D$，如查询对象集、计划空间、代价模型空间
- 解释函数：$I: S \to D$，将符号/结构映射到具体语义对象
- 语义一致性：每个查询计划/优化规则/公式在$D$中有明确定义

## 12. 形式化语法与证明

- 语法规则：如优化规则定义、计划生成规则、推理规则、约束条件
- **定理**：查询优化算法的语法系统具一致性与可扩展性。
- **证明**：由优化规则、计划生成与推理规则递归定义，保证系统一致与可扩展。

---

## 13. 索引优化策略

### 13.1. 索引选择

**索引类型**：

- **B-tree索引**：适合范围查询和排序
- **Hash索引**：适合等值查询
- **位图索引**：适合低基数列
- **GIN索引**：适合全文搜索和数组查询
- **GiST索引**：适合空间数据和自定义数据类型

**索引选择算法**：

```python
def select_indexes(query, table_stats):
    """根据查询特征选择最优索引"""
    indexes = []

    # 分析WHERE子句
    for predicate in query.where_clauses:
        if predicate.is_equality:
            # 等值查询，考虑Hash索引
            indexes.append(HashIndex(predicate.column))
        elif predicate.is_range:
            # 范围查询，考虑B-tree索引
            indexes.append(BTreeIndex(predicate.column))

    # 分析JOIN条件
    for join in query.joins:
        if join.is_equality:
            indexes.append(BTreeIndex(join.column))

    # 分析ORDER BY
    if query.order_by:
        indexes.append(BTreeIndex(query.order_by.column))

    return optimize_index_set(indexes, table_stats)
```

### 13.2. 覆盖索引

**定义**：

覆盖索引包含查询所需的所有列，避免回表操作。

**优化效果**：

- 减少I/O操作
- 提高查询性能
- 降低内存使用

**示例**：

```sql
-- 查询
SELECT name, age FROM users WHERE city = 'Beijing';

-- 覆盖索引
CREATE INDEX idx_city_name_age ON users(city, name, age);
```

### 13.3. 复合索引优化

**列顺序选择**：

- 高选择性列在前
- 等值查询列在前
- 范围查询列在后

**示例**：

```sql
-- 查询模式
SELECT * FROM orders
WHERE customer_id = 123 AND order_date > '2024-01-01'
ORDER BY order_date;

-- 最优索引
CREATE INDEX idx_customer_date ON orders(customer_id, order_date);
```

---

## 14. 统计信息与成本估算

### 14.1. 统计信息收集

**统计信息类型**：

- **表统计**：行数、页数、大小
- **列统计**：唯一值数、NULL值数、最值、直方图
- **索引统计**：索引大小、页数、唯一值数
- **相关性统计**：列间相关性

**收集方法**：

```sql
-- PostgreSQL统计信息收集
ANALYZE table_name;

-- 查看统计信息
SELECT * FROM pg_stats WHERE tablename = 'table_name';
```

### 14.2. 选择性估算

**等值查询选择性**：

$$sel(A = v) = \frac{1}{distinct(A)}$$

**范围查询选择性**：

$$sel(A > v) = \frac{high(A) - v}{high(A) - low(A)}$$

**连接选择性**：

$$sel(R \bowtie S) = sel(R) \times sel(S) \times \min(\frac{1}{distinct(R.A)}, \frac{1}{distinct(S.B)})$$

### 14.3. 成本模型

**I/O成本**：

$$C_{IO} = pages \times C_{page\_io}$$

**CPU成本**：

$$C_{CPU} = tuples \times C_{tuple\_cpu}$$

**总成本**：

$$C_{total} = C_{IO} + C_{CPU}$$

---

## 15. 查询计划缓存

### 15.1. 计划缓存策略

**缓存键**：

- 查询文本（规范化后）
- 参数类型
- 统计信息版本

**缓存管理**：

- LRU淘汰策略
- 缓存大小限制
- 缓存失效机制

### 15.2. 参数化查询

**优势**：

- 计划重用
- SQL注入防护
- 性能提升

**实现**：

```python
class PlanCache:
    def __init__(self, max_size=1000):
        self.cache = {}
        self.max_size = max_size

    def get_plan(self, query, params):
        cache_key = self._generate_key(query, params)
        if cache_key in self.cache:
            return self.cache[cache_key]
        return None

    def put_plan(self, query, params, plan):
        cache_key = self._generate_key(query, params)
        if len(self.cache) >= self.max_size:
            self._evict_lru()
        self.cache[cache_key] = plan
```

---

## 16. 自适应查询优化

### 16.1. 运行时优化

**自适应执行**：

- 监控执行统计
- 动态调整执行策略
- 运行时重优化

**示例**：

```python
class AdaptiveExecutor:
    def execute(self, plan):
        # 初始执行
        stats = self._execute_initial(plan)

        # 检查是否需要重优化
        if self._needs_reoptimization(stats):
            new_plan = self._reoptimize(plan, stats)
            return self._execute(new_plan)

        return stats
```

### 16.2. 学习型优化器

**机器学习方法**：

- 使用历史查询性能数据
- 训练模型预测查询成本
- 优化器选择最优计划

**特征工程**：

- 查询特征：表数量、连接类型、谓词复杂度
- 数据特征：表大小、索引可用性
- 系统特征：CPU、内存、I/O

---

## 17. 分布式查询优化

### 17.1. 查询分解

**水平分片**：

将查询分解为多个子查询，在分片上并行执行。

**垂直分片**：

根据列分布，只访问需要的分片。

### 17.2. 数据本地性

**优化目标**：

- 最小化数据传输
- 最大化本地计算
- 平衡负载

**策略**：

- 数据本地性优先
- 网络传输最小化
- 并行度优化

### 17.3. 分布式连接

**连接策略**：

- **广播连接**：小表广播到所有节点
- **重分区连接**：按连接键重分区
- **本地连接**：利用数据本地性

---

## 18. 实际应用案例

### 18.1. PostgreSQL查询优化

**优化器架构**：

- 查询重写：规则系统、视图展开
- 计划生成：动态规划、遗传算法
- 成本估算：统计信息、选择性估算

**优化技巧**：

- 使用EXPLAIN分析计划
- 创建合适索引
- 更新统计信息
- 调整成本参数

### 18.2. Spark SQL优化

**Catalyst优化器**：

- 基于规则的优化
- 基于成本的优化
- 代码生成

**优化策略**：

- 谓词下推
- 列剪枝
- 常量折叠
- 分区裁剪

### 18.3. 大数据查询优化

**挑战**：

- 数据量大
- 计算资源有限
- 网络带宽限制

**解决方案**：

- 分区和分桶
- 列式存储
- 向量化执行
- 查询下推

---

## 19. 性能调优最佳实践

### 19.1. 查询编写

**最佳实践**：

- 避免SELECT *
- 使用LIMIT限制结果
- 合理使用索引
- 避免不必要的子查询

### 19.2. 索引设计

**设计原则**：

- 分析查询模式
- 选择合适索引类型
- 考虑索引维护成本
- 定期评估索引效果

### 19.3. 统计信息维护

**维护策略**：

- 定期更新统计信息
- 监控统计信息准确性
- 调整采样率
- 处理数据倾斜

---

## 20. 总结

查询优化是数据库系统的核心功能，通过查询重写、成本估算、执行计划生成等技术，将逻辑查询转换为高效的物理执行计划。随着数据规模的增大和查询复杂度的提高，查询优化技术也在不断发展，自适应优化、学习型优化器等新技术为查询优化提供了新的方向。

**核心价值**：

1. **性能提升**：显著提高查询性能
2. **资源优化**：合理利用系统资源
3. **用户体验**：提供快速响应
4. **系统扩展**：支持大规模数据

**未来展望**：

随着AI技术的发展，学习型优化器、自适应优化等技术将进一步提升查询优化的效果，特别是在复杂查询和大规模数据场景下。

---

[返回上级目录](../README.md)
