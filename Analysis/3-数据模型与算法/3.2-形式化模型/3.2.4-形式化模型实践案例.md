# å½¢å¼åŒ–æ¨¡å‹å®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [å½¢å¼åŒ–æ¨¡å‹å®è·µæ¡ˆä¾‹](#å½¢å¼åŒ–æ¨¡å‹å®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2. æ•°æ®æ¨¡å‹å½¢å¼åŒ–ç†è®ºå®è·µ](#2-æ•°æ®æ¨¡å‹å½¢å¼åŒ–ç†è®ºå®è·µ)
    - [2.1. å…³ç³»ä»£æ•°å®ç°](#21-å…³ç³»ä»£æ•°å®ç°)
  - [3. å‡½æ•°ä¾èµ–éªŒè¯](#3-å‡½æ•°ä¾èµ–éªŒè¯)
  - [4. æ¦‚å¿µå»ºæ¨¡å®è·µ](#4-æ¦‚å¿µå»ºæ¨¡å®è·µ)
    - [4.1. ERæ¨¡å‹å®ç°](#41-eræ¨¡å‹å®ç°)
  - [5. æ¦‚å¿µæ¨¡å‹éªŒè¯](#5-æ¦‚å¿µæ¨¡å‹éªŒè¯)
  - [6. è¯­ä¹‰æ¨¡å‹å®è·µ](#6-è¯­ä¹‰æ¨¡å‹å®è·µ)
    - [6.1. æœ¬ä½“æ¨¡å‹å®ç°](#61-æœ¬ä½“æ¨¡å‹å®ç°)
  - [7. è¯­ä¹‰æ¨ç†](#7-è¯­ä¹‰æ¨ç†)
  - [8. æ•°æ®èµ„æºæ¨¡å‹å®è·µ](#8-æ•°æ®èµ„æºæ¨¡å‹å®è·µ)
    - [8.1. æ•°æ®ç›®å½•ç®¡ç†](#81-æ•°æ®ç›®å½•ç®¡ç†)
  - [9. æ•°æ®è´¨é‡è¯„ä¼°](#9-æ•°æ®è´¨é‡è¯„ä¼°)
  - [10. æ€»ç»“](#10-æ€»ç»“)

---


## 1. æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›å½¢å¼åŒ–æ¨¡å‹åœ¨å®é™…åº”ç”¨ä¸­çš„å®è·µæ¡ˆä¾‹ï¼ŒåŒ…æ‹¬æ•°æ®æ¨¡å‹å½¢å¼åŒ–ç†è®ºã€æ¦‚å¿µå»ºæ¨¡ã€è¯­ä¹‰æ¨¡å‹å’Œæ•°æ®èµ„æºæ¨¡å‹çš„å…·ä½“åº”ç”¨ã€‚

## 2. æ•°æ®æ¨¡å‹å½¢å¼åŒ–ç†è®ºå®è·µ

### 2.1. å…³ç³»ä»£æ•°å®ç°

```python
class Relation:
    def __init__(self, name, attributes, tuples):
        self.name = name
        self.attributes = attributes  # å±æ€§åˆ—è¡¨
        self.tuples = tuples          # å…ƒç»„åˆ—è¡¨

    def selection(self, condition):
        """é€‰æ‹©æ“ä½œ"""
        filtered_tuples = []
        for tuple_data in self.tuples:
            if condition(tuple_data):
                filtered_tuples.append(tuple_data)
        return Relation(f"Ïƒ({self.name})", self.attributes, filtered_tuples)

    def projection(self, attributes):
        """æŠ•å½±æ“ä½œ"""
        attr_indices = [self.attributes.index(attr) for attr in attributes]
        projected_tuples = []
        for tuple_data in self.tuples:
            projected_tuple = [tuple_data[i] for i in attr_indices]
            projected_tuples.append(projected_tuple)
        return Relation(f"Ï€({self.name})", attributes, projected_tuples)

    def join(self, other, condition):
        """è¿æ¥æ“ä½œ"""
        joined_tuples = []
        for t1 in self.tuples:
            for t2 in other.tuples:
                if condition(t1, t2):
                    joined_tuple = t1 + t2
                    joined_tuples.append(joined_tuple)

        joined_attributes = self.attributes + other.attributes
        return Relation(f"{self.name}â‹ˆ{other.name}", joined_attributes, joined_tuples)

# ä½¿ç”¨ç¤ºä¾‹
employees = Relation("employees", ["id", "name", "dept"], [
    [1, "Alice", "IT"],
    [2, "Bob", "HR"],
    [3, "Charlie", "IT"]
])

departments = Relation("departments", ["dept", "location"], [
    ["IT", "Floor 3"],
    ["HR", "Floor 1"]
])

# é€‰æ‹©ITéƒ¨é—¨çš„å‘˜å·¥
it_employees = employees.selection(lambda t: t[2] == "IT")
print("ITéƒ¨é—¨å‘˜å·¥:", it_employees.tuples)

# æŠ•å½±å‘˜å·¥å§“å
names = employees.projection(["name"])
print("å‘˜å·¥å§“å:", names.tuples)

# è¿æ¥å‘˜å·¥å’Œéƒ¨é—¨ä¿¡æ¯
def join_condition(t1, t2):
    return t1[2] == t2[0]  # deptå­—æ®µåŒ¹é…

employee_dept = employees.join(departments, join_condition)
print("å‘˜å·¥éƒ¨é—¨ä¿¡æ¯:", employee_dept.tuples)
```

## 3. å‡½æ•°ä¾èµ–éªŒè¯

```python
class FunctionalDependency:
    def __init__(self, determinant, dependent):
        self.determinant = set(determinant)
        self.dependent = set(dependent)

    def __str__(self):
        return f"{self.determinant} â†’ {self.dependent}"

class RelationSchema:
    def __init__(self, attributes, functional_dependencies):
        self.attributes = set(attributes)
        self.fds = functional_dependencies

    def attribute_closure(self, attribute_set):
        """è®¡ç®—å±æ€§é›†çš„é—­åŒ…"""
        closure = set(attribute_set)
        changed = True

        while changed:
            changed = False
            for fd in self.fds:
                if fd.determinant.issubset(closure):
                    if not fd.dependent.issubset(closure):
                        closure.update(fd.dependent)
                        changed = True

        return closure

    def is_superkey(self, attribute_set):
        """åˆ¤æ–­æ˜¯å¦ä¸ºè¶…é”®"""
        closure = self.attribute_closure(attribute_set)
        return self.attributes.issubset(closure)

    def find_candidate_keys(self):
        """å¯»æ‰¾å€™é€‰é”®"""
        candidate_keys = []

# ç®€åŒ–ç‰ˆæœ¬ï¼šæ£€æŸ¥å•ä¸ªå±æ€§
        for attr in self.attributes:
            if self.is_superkey([attr]):
                candidate_keys.append([attr])

        return candidate_keys

# ä½¿ç”¨ç¤ºä¾‹
# å­¦ç”Ÿè¡¨ï¼šå­¦å· â†’ å§“åï¼Œå­¦å· â†’ ä¸“ä¸š
student_fds = [
    FunctionalDependency(["student_id"], ["name"]),
    FunctionalDependency(["student_id"], ["major"])
]

student_schema = RelationSchema(
    ["student_id", "name", "major", "grade"],
    student_fds
)

# æ£€æŸ¥å€™é€‰é”®
candidate_keys = student_schema.find_candidate_keys()
print("å€™é€‰é”®:", candidate_keys)

# è®¡ç®—å±æ€§é—­åŒ…
closure = student_schema.attribute_closure(["student_id"])
print("å­¦å·é—­åŒ…:", closure)
```

## 4. æ¦‚å¿µå»ºæ¨¡å®è·µ

### 4.1. ERæ¨¡å‹å®ç°

```python
class Entity:
    def __init__(self, name, attributes):
        self.name = name
        self.attributes = attributes
        self.instances = []

    def add_instance(self, **kwargs):
        """æ·»åŠ å®ä½“å®ä¾‹"""
        instance = {}
        for attr in self.attributes:
            instance[attr] = kwargs.get(attr)
        self.instances.append(instance)

    def query(self, **conditions):
        """æŸ¥è¯¢å®ä½“å®ä¾‹"""
        results = []
        for instance in self.instances:
            match = True
            for key, value in conditions.items():
                if instance.get(key) != value:
                    match = False
                    break
            if match:
                results.append(instance)
        return results

class Relationship:
    def __init__(self, name, entities, cardinality):
        self.name = name
        self.entities = entities  # å‚ä¸å…³ç³»çš„å®ä½“åˆ—è¡¨
        self.cardinality = cardinality  # åŸºæ•°çº¦æŸ
        self.instances = []

    def add_instance(self, **kwargs):
        """æ·»åŠ å…³ç³»å®ä¾‹"""
        instance = {}
        for entity in self.entities:
            for attr in entity.attributes:
                key = f"{entity.name}_{attr}"
                instance[key] = kwargs.get(key)
        self.instances.append(instance)

# ä½¿ç”¨ç¤ºä¾‹ï¼šå›¾ä¹¦ç®¡ç†ç³»ç»Ÿ
class Book(Entity):
    def __init__(self):
        super().__init__("Book", ["isbn", "title", "author", "publisher"])

class User(Entity):
    def __init__(self):
        super().__init__("User", ["user_id", "name", "email"])

class Borrow(Relationship):
    def __init__(self, book, user):
        super().__init__("Borrow", [book, user], "M:N")

# åˆ›å»ºå®ä½“å’Œå…³ç³»
book_entity = Book()
user_entity = User()
borrow_relationship = Borrow(book_entity, user_entity)

# æ·»åŠ å›¾ä¹¦å®ä¾‹
book_entity.add_instance(
    isbn="978-0-123456-47-2",
    title="æ•°æ®ç§‘å­¦å¯¼è®º",
    author="å¼ ä¸‰",
    publisher="ç§‘æŠ€å‡ºç‰ˆç¤¾"
)

# æ·»åŠ ç”¨æˆ·å®ä¾‹
user_entity.add_instance(
    user_id="U001",
    name="æå››",
    email="lisi@example.com"
)

# æŸ¥è¯¢å›¾ä¹¦
books = book_entity.query(author="å¼ ä¸‰")
print("å¼ ä¸‰çš„å›¾ä¹¦:", books)
```

## 5. æ¦‚å¿µæ¨¡å‹éªŒè¯

```python
class ConceptualModelValidator:
    def __init__(self):
        self.entities = []
        self.relationships = []

    def add_entity(self, entity):
        self.entities.append(entity)

    def add_relationship(self, relationship):
        self.relationships.append(relationship)

    def validate_consistency(self):
        """éªŒè¯æ¦‚å¿µæ¨¡å‹çš„ä¸€è‡´æ€§"""
        issues = []

# æ£€æŸ¥å®ä½“åç§°å”¯ä¸€æ€§
        entity_names = [e.name for e in self.entities]
        if len(entity_names) != len(set(entity_names)):
            issues.append("å®ä½“åç§°ä¸å”¯ä¸€")

# æ£€æŸ¥å…³ç³»ä¸­çš„å®ä½“æ˜¯å¦å­˜åœ¨
        for rel in self.relationships:
            for entity in rel.entities:
                if entity not in self.entities:
                    issues.append(f"å…³ç³» {rel.name} å¼•ç”¨äº†ä¸å­˜åœ¨çš„å®ä½“ {entity.name}")

        return issues

    def generate_sql_schema(self):
        """ç”ŸæˆSQLæ¨¡å¼"""
        sql_statements = []

        for entity in self.entities:
# ç”ŸæˆCREATE TABLEè¯­å¥
            columns = []
            for attr in entity.attributes:
                columns.append(f"{attr} VARCHAR(255)")

            sql = f"CREATE TABLE {entity.name} (\n"
            sql += ",\n".join(f"    {col}" for col in columns)
            sql += "\n);"
            sql_statements.append(sql)

        return sql_statements

# ä½¿ç”¨ç¤ºä¾‹
validator = ConceptualModelValidator()
validator.add_entity(book_entity)
validator.add_entity(user_entity)

# éªŒè¯æ¨¡å‹
issues = validator.validate_consistency()
if issues:
    print("æ¨¡å‹é—®é¢˜:", issues)
else:
    print("æ¨¡å‹éªŒè¯é€šè¿‡")

# ç”ŸæˆSQLæ¨¡å¼
sql_schema = validator.generate_sql_schema()
for sql in sql_schema:
    print(sql)
```

## 6. è¯­ä¹‰æ¨¡å‹å®è·µ

### 6.1. æœ¬ä½“æ¨¡å‹å®ç°

```python
class OntologyClass:
    def __init__(self, name, parent=None):
        self.name = name
        self.parent = parent
        self.properties = {}
        self.instances = []

    def add_property(self, name, property_type, domain=None, range=None):
        """æ·»åŠ å±æ€§"""
        self.properties[name] = {
            'type': property_type,
            'domain': domain,
            'range': range
        }

    def add_instance(self, **kwargs):
        """æ·»åŠ å®ä¾‹"""
        instance = {'class': self.name}
        for key, value in kwargs.items():
            if key in self.properties:
                instance[key] = value
        self.instances.append(instance)

    def is_subclass_of(self, other_class):
        """æ£€æŸ¥æ˜¯å¦ä¸ºå­ç±»"""
        current = self
        while current:
            if current == other_class:
                return True
            current = current.parent
        return False

class Ontology:
    def __init__(self):
        self.classes = {}
        self.relationships = []

    def add_class(self, class_name, parent_name=None):
        """æ·»åŠ ç±»"""
        parent = self.classes.get(parent_name) if parent_name else None
        ontology_class = OntologyClass(class_name, parent)
        self.classes[class_name] = ontology_class
        return ontology_class

    def add_relationship(self, source_class, target_class, relationship_type):
        """æ·»åŠ å…³ç³»"""
        self.relationships.append({
            'source': source_class,
            'target': target_class,
            'type': relationship_type
        })

    def query_instances(self, class_name, **conditions):
        """æŸ¥è¯¢å®ä¾‹"""
        if class_name not in self.classes:
            return []

        ontology_class = self.classes[class_name]
        results = []

        for instance in ontology_class.instances:
            match = True
            for key, value in conditions.items():
                if instance.get(key) != value:
                    match = False
                    break
            if match:
                results.append(instance)

        return results

# ä½¿ç”¨ç¤ºä¾‹ï¼šå­¦æœ¯é¢†åŸŸæœ¬ä½“
academic_ontology = Ontology()

# å®šä¹‰ç±»å±‚æ¬¡ç»“æ„
person = academic_ontology.add_class("Person")
student = academic_ontology.add_class("Student", "Person")
professor = academic_ontology.add_class("Professor", "Person")

# æ·»åŠ å±æ€§
person.add_property("name", "string")
person.add_property("email", "string")
student.add_property("student_id", "string")
student.add_property("major", "string")
professor.add_property("department", "string")
professor.add_property("title", "string")

# æ·»åŠ å…³ç³»
academic_ontology.add_relationship("Student", "Professor", "supervised_by")

# æ·»åŠ å®ä¾‹
student.add_instance(
    name="å¼ ä¸‰",
    email="zhangsan@university.edu",
    student_id="2021001",
    major="è®¡ç®—æœºç§‘å­¦"
)

professor.add_instance(
    name="ææ•™æˆ",
    email="li@university.edu",
    department="è®¡ç®—æœºç³»",
    title="å‰¯æ•™æˆ"
)

# æŸ¥è¯¢å®ä¾‹
students = academic_ontology.query_instances("Student", major="è®¡ç®—æœºç§‘å­¦")
print("è®¡ç®—æœºç§‘å­¦ä¸“ä¸šå­¦ç”Ÿ:", students)
```

## 7. è¯­ä¹‰æ¨ç†

```python
class SemanticReasoner:
    def __init__(self, ontology):
        self.ontology = ontology

    def infer_subclasses(self, class_name):
        """æ¨ç†å­ç±»"""
        subclasses = []
        for name, cls in self.ontology.classes.items():
            if cls.is_subclass_of(self.ontology.classes[class_name]):
                subclasses.append(name)
        return subclasses

    def find_related_instances(self, instance, relationship_type):
        """æŸ¥æ‰¾ç›¸å…³å®ä¾‹"""
        related = []

# æŸ¥æ‰¾å…³ç³»
        for rel in self.ontology.relationships:
            if rel['type'] == relationship_type:
                if rel['source'] == instance['class']:
# æŸ¥æ‰¾ç›®æ ‡ç±»çš„å®ä¾‹
                    target_class = self.ontology.classes[rel['target']]
                    related.extend(target_class.instances)

        return related

    def semantic_search(self, query, class_name=None):
        """è¯­ä¹‰æœç´¢"""
        results = []

        if class_name:
            instances = self.ontology.query_instances(class_name)
        else:
            instances = []
            for cls in self.ontology.classes.values():
                instances.extend(cls.instances)

# ç®€å•çš„å…³é”®è¯åŒ¹é…
        query_terms = query.lower().split()

        for instance in instances:
            score = 0
            for term in query_terms:
                for value in instance.values():
                    if isinstance(value, str) and term in value.lower():
                        score += 1

            if score > 0:
                results.append((instance, score))

# æŒ‰ç›¸å…³æ€§æ’åº
        results.sort(key=lambda x: x[1], reverse=True)
        return [instance for instance, score in results]

# ä½¿ç”¨ç¤ºä¾‹
reasoner = SemanticReasoner(academic_ontology)

# æ¨ç†å­ç±»
person_subclasses = reasoner.infer_subclasses("Person")
print("Personçš„å­ç±»:", person_subclasses)

# è¯­ä¹‰æœç´¢
search_results = reasoner.semantic_search("è®¡ç®—æœº", "Student")
print("æœç´¢'è®¡ç®—æœº'çš„ç»“æœ:", search_results)
```

## 8. æ•°æ®èµ„æºæ¨¡å‹å®è·µ

### 8.1. æ•°æ®ç›®å½•ç®¡ç†

```python
class DataCatalog:
    def __init__(self):
        self.datasets = {}
        self.metadata = {}

    def register_dataset(self, dataset_id, name, description, schema, source):
        """æ³¨å†Œæ•°æ®é›†"""
        self.datasets[dataset_id] = {
            'name': name,
            'description': description,
            'schema': schema,
            'source': source,
            'created_at': datetime.now(),
            'tags': [],
            'quality_score': None
        }

    def add_metadata(self, dataset_id, metadata):
        """æ·»åŠ å…ƒæ•°æ®"""
        if dataset_id in self.datasets:
            self.datasets[dataset_id].update(metadata)

    def search_datasets(self, query, tags=None):
        """æœç´¢æ•°æ®é›†"""
        results = []
        query_terms = query.lower().split()

        for dataset_id, dataset in self.datasets.items():
            score = 0

# æœç´¢åç§°å’Œæè¿°
            text = f"{dataset['name']} {dataset['description']}".lower()
            for term in query_terms:
                if term in text:
                    score += 1

# æ ‡ç­¾åŒ¹é…
            if tags:
                for tag in tags:
                    if tag in dataset.get('tags', []):
                        score += 2

            if score > 0:
                results.append((dataset_id, dataset, score))

        results.sort(key=lambda x: x[2], reverse=True)
        return results

    def get_data_lineage(self, dataset_id):
        """è·å–æ•°æ®è¡€ç¼˜"""
        lineage = {
            'dataset_id': dataset_id,
            'source': self.datasets[dataset_id]['source'],
            'dependencies': [],
            'derived_datasets': []
        }

# æŸ¥æ‰¾ä¾èµ–å…³ç³»ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
        for other_id, other_dataset in self.datasets.items():
            if other_id != dataset_id:
                if other_dataset['source'] == self.datasets[dataset_id]['source']:
                    lineage['dependencies'].append(other_id)

        return lineage

# ä½¿ç”¨ç¤ºä¾‹
catalog = DataCatalog()

# æ³¨å†Œæ•°æ®é›†
catalog.register_dataset(
    "sales_2023",
    "2023å¹´é”€å”®æ•°æ®",
    "åŒ…å«2023å¹´å…¨å¹´çš„é”€å”®äº¤æ˜“è®°å½•",
    ["date", "product_id", "amount", "customer_id"],
    "sales_system"
)

catalog.add_metadata("sales_2023", {
    'tags': ['sales', 'transaction', '2023'],
    'quality_score': 0.95,
    'update_frequency': 'daily'
})

# æœç´¢æ•°æ®é›†
results = catalog.search_datasets("é”€å”®", tags=['transaction'])
print("æœç´¢ç»“æœ:", results)

# è·å–æ•°æ®è¡€ç¼˜
lineage = catalog.get_data_lineage("sales_2023")
print("æ•°æ®è¡€ç¼˜:", lineage)
```

## 9. æ•°æ®è´¨é‡è¯„ä¼°

```python
class DataQualityAssessor:
    def __init__(self):
        self.quality_metrics = {}

    def assess_completeness(self, data, required_fields):
        """è¯„ä¼°å®Œæ•´æ€§"""
        total_records = len(data)
        if total_records == 0:
            return 0.0

        complete_records = 0
        for record in data:
            if all(field in record and record[field] is not None
                   for field in required_fields):
                complete_records += 1

        return complete_records / total_records

    def assess_consistency(self, data, field, expected_values=None):
        """è¯„ä¼°ä¸€è‡´æ€§"""
        if not data:
            return 0.0

        values = [record.get(field) for record in data if field in record]
        if not values:
            return 0.0

        if expected_values:
# æ£€æŸ¥æ˜¯å¦ç¬¦åˆé¢„æœŸå€¼
            valid_values = sum(1 for v in values if v in expected_values)
            return valid_values / len(values)
        else:
# æ£€æŸ¥å”¯ä¸€æ€§
            unique_values = len(set(values))
            return unique_values / len(values)

    def assess_accuracy(self, data, field, validation_rule):
        """è¯„ä¼°å‡†ç¡®æ€§"""
        if not data:
            return 0.0

        valid_records = 0
        total_records = 0

        for record in data:
            if field in record:
                total_records += 1
                if validation_rule(record[field]):
                    valid_records += 1

        return valid_records / total_records if total_records > 0 else 0.0

    def calculate_overall_quality(self, dataset_id, data):
        """è®¡ç®—æ•´ä½“è´¨é‡åˆ†æ•°"""
        quality_scores = {}

# å®Œæ•´æ€§è¯„ä¼°
        required_fields = ['id', 'name', 'value']
        quality_scores['completeness'] = self.assess_completeness(data, required_fields)

# ä¸€è‡´æ€§è¯„ä¼°
        quality_scores['consistency'] = self.assess_consistency(data, 'status', ['active', 'inactive'])

# å‡†ç¡®æ€§è¯„ä¼°
        def is_positive_number(value):
            try:
                return float(value) > 0
            except:
                return False

        quality_scores['accuracy'] = self.assess_accuracy(data, 'value', is_positive_number)

# è®¡ç®—åŠ æƒå¹³å‡
        weights = {'completeness': 0.4, 'consistency': 0.3, 'accuracy': 0.3}
        overall_score = sum(score * weights[metric]
                           for metric, score in quality_scores.items())

        self.quality_metrics[dataset_id] = {
            'overall_score': overall_score,
            'detailed_scores': quality_scores
        }

        return overall_score

# ä½¿ç”¨ç¤ºä¾‹
assessor = DataQualityAssessor()

# ç¤ºä¾‹æ•°æ®
sample_data = [
    {'id': 1, 'name': 'Product A', 'value': 100, 'status': 'active'},
    {'id': 2, 'name': 'Product B', 'value': 200, 'status': 'active'},
    {'id': 3, 'name': None, 'value': 150, 'status': 'inactive'},
    {'id': 4, 'name': 'Product D', 'value': -50, 'status': 'active'}
]

# è¯„ä¼°æ•°æ®è´¨é‡
quality_score = assessor.calculate_overall_quality("sample_dataset", sample_data)
print("æ•°æ®è´¨é‡åˆ†æ•°:", quality_score)
print("è¯¦ç»†åˆ†æ•°:", assessor.quality_metrics["sample_dataset"])
```

## 10. æ€»ç»“

æœ¬æ–‡æ¡£æä¾›äº†å½¢å¼åŒ–æ¨¡å‹åœ¨å®é™…åº”ç”¨ä¸­çš„å®Œæ•´å®è·µæ¡ˆä¾‹ï¼ŒåŒ…æ‹¬ï¼š

1. **æ•°æ®æ¨¡å‹å½¢å¼åŒ–ç†è®º**ï¼šå…³ç³»ä»£æ•°å®ç°ã€å‡½æ•°ä¾èµ–éªŒè¯
2. **æ¦‚å¿µå»ºæ¨¡**ï¼šERæ¨¡å‹å®ç°ã€æ¦‚å¿µæ¨¡å‹éªŒè¯
3. **è¯­ä¹‰æ¨¡å‹**ï¼šæœ¬ä½“æ¨¡å‹å®ç°ã€è¯­ä¹‰æ¨ç†
4. **æ•°æ®èµ„æºæ¨¡å‹**ï¼šæ•°æ®ç›®å½•ç®¡ç†ã€æ•°æ®è´¨é‡è¯„ä¼°

è¿™äº›å®è·µæ¡ˆä¾‹å±•ç¤ºäº†å¦‚ä½•å°†å½¢å¼åŒ–ç†è®ºåº”ç”¨åˆ°å®é™…çš„æ•°æ®å»ºæ¨¡å’Œç®¡ç†å·¥ä½œä¸­ï¼Œä¸ºæ„å»ºé«˜è´¨é‡çš„æ•°æ®ç³»ç»Ÿæä¾›äº†å®ç”¨çš„å·¥å…·å’Œæ–¹æ³•ã€‚
