# 形式化模型实践案例

## 概述

本文档提供形式化模型在实际应用中的实践案例，包括数据模型形式化理论、概念建模、语义模型和数据资源模型的具体应用。

## 1. 数据模型形式化理论实践

### 1.1 关系代数实现

```python
class Relation:
    def __init__(self, name, attributes, tuples):
        self.name = name
        self.attributes = attributes  # 属性列表
        self.tuples = tuples          # 元组列表
    
    def selection(self, condition):
        """选择操作"""
        filtered_tuples = []
        for tuple_data in self.tuples:
            if condition(tuple_data):
                filtered_tuples.append(tuple_data)
        return Relation(f"σ({self.name})", self.attributes, filtered_tuples)
    
    def projection(self, attributes):
        """投影操作"""
        attr_indices = [self.attributes.index(attr) for attr in attributes]
        projected_tuples = []
        for tuple_data in self.tuples:
            projected_tuple = [tuple_data[i] for i in attr_indices]
            projected_tuples.append(projected_tuple)
        return Relation(f"π({self.name})", attributes, projected_tuples)
    
    def join(self, other, condition):
        """连接操作"""
        joined_tuples = []
        for t1 in self.tuples:
            for t2 in other.tuples:
                if condition(t1, t2):
                    joined_tuple = t1 + t2
                    joined_tuples.append(joined_tuple)
        
        joined_attributes = self.attributes + other.attributes
        return Relation(f"{self.name}⋈{other.name}", joined_attributes, joined_tuples)

# 使用示例
employees = Relation("employees", ["id", "name", "dept"], [
    [1, "Alice", "IT"],
    [2, "Bob", "HR"],
    [3, "Charlie", "IT"]
])

departments = Relation("departments", ["dept", "location"], [
    ["IT", "Floor 3"],
    ["HR", "Floor 1"]
])

# 选择IT部门的员工
it_employees = employees.selection(lambda t: t[2] == "IT")
print("IT部门员工:", it_employees.tuples)

# 投影员工姓名
names = employees.projection(["name"])
print("员工姓名:", names.tuples)

# 连接员工和部门信息
def join_condition(t1, t2):
    return t1[2] == t2[0]  # dept字段匹配

employee_dept = employees.join(departments, join_condition)
print("员工部门信息:", employee_dept.tuples)
```

### 1.2 函数依赖验证

```python
class FunctionalDependency:
    def __init__(self, determinant, dependent):
        self.determinant = set(determinant)
        self.dependent = set(dependent)
    
    def __str__(self):
        return f"{self.determinant} → {self.dependent}"

class RelationSchema:
    def __init__(self, attributes, functional_dependencies):
        self.attributes = set(attributes)
        self.fds = functional_dependencies
    
    def attribute_closure(self, attribute_set):
        """计算属性集的闭包"""
        closure = set(attribute_set)
        changed = True
        
        while changed:
            changed = False
            for fd in self.fds:
                if fd.determinant.issubset(closure):
                    if not fd.dependent.issubset(closure):
                        closure.update(fd.dependent)
                        changed = True
        
        return closure
    
    def is_superkey(self, attribute_set):
        """判断是否为超键"""
        closure = self.attribute_closure(attribute_set)
        return self.attributes.issubset(closure)
    
    def find_candidate_keys(self):
        """寻找候选键"""
        candidate_keys = []
        
        # 简化版本：检查单个属性
        for attr in self.attributes:
            if self.is_superkey([attr]):
                candidate_keys.append([attr])
        
        return candidate_keys

# 使用示例
# 学生表：学号 → 姓名，学号 → 专业
student_fds = [
    FunctionalDependency(["student_id"], ["name"]),
    FunctionalDependency(["student_id"], ["major"])
]

student_schema = RelationSchema(
    ["student_id", "name", "major", "grade"],
    student_fds
)

# 检查候选键
candidate_keys = student_schema.find_candidate_keys()
print("候选键:", candidate_keys)

# 计算属性闭包
closure = student_schema.attribute_closure(["student_id"])
print("学号闭包:", closure)
```

## 2. 概念建模实践

### 2.1 ER模型实现

```python
class Entity:
    def __init__(self, name, attributes):
        self.name = name
        self.attributes = attributes
        self.instances = []
    
    def add_instance(self, **kwargs):
        """添加实体实例"""
        instance = {}
        for attr in self.attributes:
            instance[attr] = kwargs.get(attr)
        self.instances.append(instance)
    
    def query(self, **conditions):
        """查询实体实例"""
        results = []
        for instance in self.instances:
            match = True
            for key, value in conditions.items():
                if instance.get(key) != value:
                    match = False
                    break
            if match:
                results.append(instance)
        return results

class Relationship:
    def __init__(self, name, entities, cardinality):
        self.name = name
        self.entities = entities  # 参与关系的实体列表
        self.cardinality = cardinality  # 基数约束
        self.instances = []
    
    def add_instance(self, **kwargs):
        """添加关系实例"""
        instance = {}
        for entity in self.entities:
            for attr in entity.attributes:
                key = f"{entity.name}_{attr}"
                instance[key] = kwargs.get(key)
        self.instances.append(instance)

# 使用示例：图书管理系统
class Book(Entity):
    def __init__(self):
        super().__init__("Book", ["isbn", "title", "author", "publisher"])

class User(Entity):
    def __init__(self):
        super().__init__("User", ["user_id", "name", "email"])

class Borrow(Relationship):
    def __init__(self, book, user):
        super().__init__("Borrow", [book, user], "M:N")

# 创建实体和关系
book_entity = Book()
user_entity = User()
borrow_relationship = Borrow(book_entity, user_entity)

# 添加图书实例
book_entity.add_instance(
    isbn="978-0-123456-47-2",
    title="数据科学导论",
    author="张三",
    publisher="科技出版社"
)

# 添加用户实例
user_entity.add_instance(
    user_id="U001",
    name="李四",
    email="lisi@example.com"
)

# 查询图书
books = book_entity.query(author="张三")
print("张三的图书:", books)
```

### 2.2 概念模型验证

```python
class ConceptualModelValidator:
    def __init__(self):
        self.entities = []
        self.relationships = []
    
    def add_entity(self, entity):
        self.entities.append(entity)
    
    def add_relationship(self, relationship):
        self.relationships.append(relationship)
    
    def validate_consistency(self):
        """验证概念模型的一致性"""
        issues = []
        
        # 检查实体名称唯一性
        entity_names = [e.name for e in self.entities]
        if len(entity_names) != len(set(entity_names)):
            issues.append("实体名称不唯一")
        
        # 检查关系中的实体是否存在
        for rel in self.relationships:
            for entity in rel.entities:
                if entity not in self.entities:
                    issues.append(f"关系 {rel.name} 引用了不存在的实体 {entity.name}")
        
        return issues
    
    def generate_sql_schema(self):
        """生成SQL模式"""
        sql_statements = []
        
        for entity in self.entities:
            # 生成CREATE TABLE语句
            columns = []
            for attr in entity.attributes:
                columns.append(f"{attr} VARCHAR(255)")
            
            sql = f"CREATE TABLE {entity.name} (\n"
            sql += ",\n".join(f"    {col}" for col in columns)
            sql += "\n);"
            sql_statements.append(sql)
        
        return sql_statements

# 使用示例
validator = ConceptualModelValidator()
validator.add_entity(book_entity)
validator.add_entity(user_entity)

# 验证模型
issues = validator.validate_consistency()
if issues:
    print("模型问题:", issues)
else:
    print("模型验证通过")

# 生成SQL模式
sql_schema = validator.generate_sql_schema()
for sql in sql_schema:
    print(sql)
```

## 3. 语义模型实践

### 3.1 本体模型实现

```python
class OntologyClass:
    def __init__(self, name, parent=None):
        self.name = name
        self.parent = parent
        self.properties = {}
        self.instances = []
    
    def add_property(self, name, property_type, domain=None, range=None):
        """添加属性"""
        self.properties[name] = {
            'type': property_type,
            'domain': domain,
            'range': range
        }
    
    def add_instance(self, **kwargs):
        """添加实例"""
        instance = {'class': self.name}
        for key, value in kwargs.items():
            if key in self.properties:
                instance[key] = value
        self.instances.append(instance)
    
    def is_subclass_of(self, other_class):
        """检查是否为子类"""
        current = self
        while current:
            if current == other_class:
                return True
            current = current.parent
        return False

class Ontology:
    def __init__(self):
        self.classes = {}
        self.relationships = []
    
    def add_class(self, class_name, parent_name=None):
        """添加类"""
        parent = self.classes.get(parent_name) if parent_name else None
        ontology_class = OntologyClass(class_name, parent)
        self.classes[class_name] = ontology_class
        return ontology_class
    
    def add_relationship(self, source_class, target_class, relationship_type):
        """添加关系"""
        self.relationships.append({
            'source': source_class,
            'target': target_class,
            'type': relationship_type
        })
    
    def query_instances(self, class_name, **conditions):
        """查询实例"""
        if class_name not in self.classes:
            return []
        
        ontology_class = self.classes[class_name]
        results = []
        
        for instance in ontology_class.instances:
            match = True
            for key, value in conditions.items():
                if instance.get(key) != value:
                    match = False
                    break
            if match:
                results.append(instance)
        
        return results

# 使用示例：学术领域本体
academic_ontology = Ontology()

# 定义类层次结构
person = academic_ontology.add_class("Person")
student = academic_ontology.add_class("Student", "Person")
professor = academic_ontology.add_class("Professor", "Person")

# 添加属性
person.add_property("name", "string")
person.add_property("email", "string")
student.add_property("student_id", "string")
student.add_property("major", "string")
professor.add_property("department", "string")
professor.add_property("title", "string")

# 添加关系
academic_ontology.add_relationship("Student", "Professor", "supervised_by")

# 添加实例
student.add_instance(
    name="张三",
    email="zhangsan@university.edu",
    student_id="2021001",
    major="计算机科学"
)

professor.add_instance(
    name="李教授",
    email="li@university.edu",
    department="计算机系",
    title="副教授"
)

# 查询实例
students = academic_ontology.query_instances("Student", major="计算机科学")
print("计算机科学专业学生:", students)
```

### 3.2 语义推理

```python
class SemanticReasoner:
    def __init__(self, ontology):
        self.ontology = ontology
    
    def infer_subclasses(self, class_name):
        """推理子类"""
        subclasses = []
        for name, cls in self.ontology.classes.items():
            if cls.is_subclass_of(self.ontology.classes[class_name]):
                subclasses.append(name)
        return subclasses
    
    def find_related_instances(self, instance, relationship_type):
        """查找相关实例"""
        related = []
        
        # 查找关系
        for rel in self.ontology.relationships:
            if rel['type'] == relationship_type:
                if rel['source'] == instance['class']:
                    # 查找目标类的实例
                    target_class = self.ontology.classes[rel['target']]
                    related.extend(target_class.instances)
        
        return related
    
    def semantic_search(self, query, class_name=None):
        """语义搜索"""
        results = []
        
        if class_name:
            instances = self.ontology.query_instances(class_name)
        else:
            instances = []
            for cls in self.ontology.classes.values():
                instances.extend(cls.instances)
        
        # 简单的关键词匹配
        query_terms = query.lower().split()
        
        for instance in instances:
            score = 0
            for term in query_terms:
                for value in instance.values():
                    if isinstance(value, str) and term in value.lower():
                        score += 1
            
            if score > 0:
                results.append((instance, score))
        
        # 按相关性排序
        results.sort(key=lambda x: x[1], reverse=True)
        return [instance for instance, score in results]

# 使用示例
reasoner = SemanticReasoner(academic_ontology)

# 推理子类
person_subclasses = reasoner.infer_subclasses("Person")
print("Person的子类:", person_subclasses)

# 语义搜索
search_results = reasoner.semantic_search("计算机", "Student")
print("搜索'计算机'的结果:", search_results)
```

## 4. 数据资源模型实践

### 4.1 数据目录管理

```python
class DataCatalog:
    def __init__(self):
        self.datasets = {}
        self.metadata = {}
    
    def register_dataset(self, dataset_id, name, description, schema, source):
        """注册数据集"""
        self.datasets[dataset_id] = {
            'name': name,
            'description': description,
            'schema': schema,
            'source': source,
            'created_at': datetime.now(),
            'tags': [],
            'quality_score': None
        }
    
    def add_metadata(self, dataset_id, metadata):
        """添加元数据"""
        if dataset_id in self.datasets:
            self.datasets[dataset_id].update(metadata)
    
    def search_datasets(self, query, tags=None):
        """搜索数据集"""
        results = []
        query_terms = query.lower().split()
        
        for dataset_id, dataset in self.datasets.items():
            score = 0
            
            # 搜索名称和描述
            text = f"{dataset['name']} {dataset['description']}".lower()
            for term in query_terms:
                if term in text:
                    score += 1
            
            # 标签匹配
            if tags:
                for tag in tags:
                    if tag in dataset.get('tags', []):
                        score += 2
            
            if score > 0:
                results.append((dataset_id, dataset, score))
        
        results.sort(key=lambda x: x[2], reverse=True)
        return results
    
    def get_data_lineage(self, dataset_id):
        """获取数据血缘"""
        lineage = {
            'dataset_id': dataset_id,
            'source': self.datasets[dataset_id]['source'],
            'dependencies': [],
            'derived_datasets': []
        }
        
        # 查找依赖关系（简化版本）
        for other_id, other_dataset in self.datasets.items():
            if other_id != dataset_id:
                if other_dataset['source'] == self.datasets[dataset_id]['source']:
                    lineage['dependencies'].append(other_id)
        
        return lineage

# 使用示例
catalog = DataCatalog()

# 注册数据集
catalog.register_dataset(
    "sales_2023",
    "2023年销售数据",
    "包含2023年全年的销售交易记录",
    ["date", "product_id", "amount", "customer_id"],
    "sales_system"
)

catalog.add_metadata("sales_2023", {
    'tags': ['sales', 'transaction', '2023'],
    'quality_score': 0.95,
    'update_frequency': 'daily'
})

# 搜索数据集
results = catalog.search_datasets("销售", tags=['transaction'])
print("搜索结果:", results)

# 获取数据血缘
lineage = catalog.get_data_lineage("sales_2023")
print("数据血缘:", lineage)
```

### 4.2 数据质量评估

```python
class DataQualityAssessor:
    def __init__(self):
        self.quality_metrics = {}
    
    def assess_completeness(self, data, required_fields):
        """评估完整性"""
        total_records = len(data)
        if total_records == 0:
            return 0.0
        
        complete_records = 0
        for record in data:
            if all(field in record and record[field] is not None 
                   for field in required_fields):
                complete_records += 1
        
        return complete_records / total_records
    
    def assess_consistency(self, data, field, expected_values=None):
        """评估一致性"""
        if not data:
            return 0.0
        
        values = [record.get(field) for record in data if field in record]
        if not values:
            return 0.0
        
        if expected_values:
            # 检查是否符合预期值
            valid_values = sum(1 for v in values if v in expected_values)
            return valid_values / len(values)
        else:
            # 检查唯一性
            unique_values = len(set(values))
            return unique_values / len(values)
    
    def assess_accuracy(self, data, field, validation_rule):
        """评估准确性"""
        if not data:
            return 0.0
        
        valid_records = 0
        total_records = 0
        
        for record in data:
            if field in record:
                total_records += 1
                if validation_rule(record[field]):
                    valid_records += 1
        
        return valid_records / total_records if total_records > 0 else 0.0
    
    def calculate_overall_quality(self, dataset_id, data):
        """计算整体质量分数"""
        quality_scores = {}
        
        # 完整性评估
        required_fields = ['id', 'name', 'value']
        quality_scores['completeness'] = self.assess_completeness(data, required_fields)
        
        # 一致性评估
        quality_scores['consistency'] = self.assess_consistency(data, 'status', ['active', 'inactive'])
        
        # 准确性评估
        def is_positive_number(value):
            try:
                return float(value) > 0
            except:
                return False
        
        quality_scores['accuracy'] = self.assess_accuracy(data, 'value', is_positive_number)
        
        # 计算加权平均
        weights = {'completeness': 0.4, 'consistency': 0.3, 'accuracy': 0.3}
        overall_score = sum(score * weights[metric] 
                           for metric, score in quality_scores.items())
        
        self.quality_metrics[dataset_id] = {
            'overall_score': overall_score,
            'detailed_scores': quality_scores
        }
        
        return overall_score

# 使用示例
assessor = DataQualityAssessor()

# 示例数据
sample_data = [
    {'id': 1, 'name': 'Product A', 'value': 100, 'status': 'active'},
    {'id': 2, 'name': 'Product B', 'value': 200, 'status': 'active'},
    {'id': 3, 'name': None, 'value': 150, 'status': 'inactive'},
    {'id': 4, 'name': 'Product D', 'value': -50, 'status': 'active'}
]

# 评估数据质量
quality_score = assessor.calculate_overall_quality("sample_dataset", sample_data)
print("数据质量分数:", quality_score)
print("详细分数:", assessor.quality_metrics["sample_dataset"])
```

## 总结

本文档提供了形式化模型在实际应用中的完整实践案例，包括：

1. **数据模型形式化理论**：关系代数实现、函数依赖验证
2. **概念建模**：ER模型实现、概念模型验证
3. **语义模型**：本体模型实现、语义推理
4. **数据资源模型**：数据目录管理、数据质量评估

这些实践案例展示了如何将形式化理论应用到实际的数据建模和管理工作中，为构建高质量的数据系统提供了实用的工具和方法。
