# 3.4.3 æ— ç›‘ç£å­¦ä¹ ç®—æ³•

## ğŸ“‘ ç›®å½•

- [3.4.3 æ— ç›‘ç£å­¦ä¹ ç®—æ³•](#343-æ— ç›‘ç£å­¦ä¹ ç®—æ³•)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2. ç›®å½•](#2-ç›®å½•)
  - [3. èšç±»ç®—æ³•](#3-èšç±»ç®—æ³•)
    - [3.1. K-Meansèšç±»](#31-k-meansèšç±»)
    - [3.2. å±‚æ¬¡èšç±»](#32-å±‚æ¬¡èšç±»)
    - [3.3. DBSCANå¯†åº¦èšç±»](#33-dbscanå¯†åº¦èšç±»)
  - [4. é™ç»´ç®—æ³•](#4-é™ç»´ç®—æ³•)
    - [4.1. ä¸»æˆåˆ†åˆ†æï¼ˆPCAï¼‰](#41-ä¸»æˆåˆ†åˆ†æpca)
    - [4.2. t-SNE](#42-t-sne)
    - [4.3. çº¿æ€§åˆ¤åˆ«åˆ†æï¼ˆLDAï¼‰](#43-çº¿æ€§åˆ¤åˆ«åˆ†ælda)
  - [5. å¯†åº¦ä¼°è®¡](#5-å¯†åº¦ä¼°è®¡)
    - [5.1. é«˜æ–¯æ··åˆæ¨¡å‹ï¼ˆGMMï¼‰](#51-é«˜æ–¯æ··åˆæ¨¡å‹gmm)
    - [5.2. æ ¸å¯†åº¦ä¼°è®¡](#52-æ ¸å¯†åº¦ä¼°è®¡)
  - [6. å¼‚å¸¸æ£€æµ‹](#6-å¼‚å¸¸æ£€æµ‹)
    - [6.1. å­¤ç«‹æ£®æ—](#61-å­¤ç«‹æ£®æ—)
    - [6.2. One-Class SVM](#62-one-class-svm)
  - [7. å…³è”è§„åˆ™å­¦ä¹ ](#7-å…³è”è§„åˆ™å­¦ä¹ )
    - [7.1. Aprioriç®—æ³•](#71-aprioriç®—æ³•)
  - [8. çŸ©é˜µåˆ†è§£](#8-çŸ©é˜µåˆ†è§£)
    - [8.1. éè´ŸçŸ©é˜µåˆ†è§£ï¼ˆNMFï¼‰](#81-éè´ŸçŸ©é˜µåˆ†è§£nmf)
    - [8.2. ç‹¬ç«‹æˆåˆ†åˆ†æï¼ˆICAï¼‰](#82-ç‹¬ç«‹æˆåˆ†åˆ†æica)
  - [9. Rustå®ç°ç¤ºä¾‹](#9-rustå®ç°ç¤ºä¾‹)
    - [9.1. K-Meanså®ç°](#91-k-meanså®ç°)
    - [9.2. PCAå®ç°](#92-pcaå®ç°)
    - [9.3. DBSCANå®ç°](#93-dbscanå®ç°)
  - [10. æœ¬åœ°è·³è½¬é“¾æ¥](#10-æœ¬åœ°è·³è½¬é“¾æ¥)
  - [11. å‚è€ƒæ–‡çŒ®](#11-å‚è€ƒæ–‡çŒ®)
  - [12. å¤šè¡¨å¾](#12-å¤šè¡¨å¾)
  - [13. å½¢å¼åŒ–è¯­ä¹‰](#13-å½¢å¼åŒ–è¯­ä¹‰)
  - [14. å½¢å¼åŒ–è¯­æ³•ä¸è¯æ˜](#14-å½¢å¼åŒ–è¯­æ³•ä¸è¯æ˜)

---


## 1. æ¦‚è¿°

æ— ç›‘ç£å­¦ä¹ æ˜¯æœºå™¨å­¦ä¹ çš„é‡è¦åˆ†æ”¯ï¼Œåœ¨æ²¡æœ‰æ ‡æ³¨æ•°æ®çš„æƒ…å†µä¸‹å‘ç°æ•°æ®çš„å†…åœ¨ç»“æ„å’Œæ¨¡å¼ã€‚æœ¬æ–‡æ¡£ç³»ç»Ÿé˜è¿°æ— ç›‘ç£å­¦ä¹ çš„æ ¸å¿ƒç®—æ³•ã€ç†è®ºåŸºç¡€å’Œå®é™…åº”ç”¨ã€‚

## 2. ç›®å½•

- [3.4.3 æ— ç›‘ç£å­¦ä¹ ç®—æ³•](#343-æ— ç›‘ç£å­¦ä¹ ç®—æ³•)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2. ç›®å½•](#2-ç›®å½•)
  - [3. èšç±»ç®—æ³•](#3-èšç±»ç®—æ³•)
    - [3.1. K-Meansèšç±»](#31-k-meansèšç±»)
    - [3.2. å±‚æ¬¡èšç±»](#32-å±‚æ¬¡èšç±»)
    - [3.3. DBSCANå¯†åº¦èšç±»](#33-dbscanå¯†åº¦èšç±»)
  - [4. é™ç»´ç®—æ³•](#4-é™ç»´ç®—æ³•)
    - [4.1. ä¸»æˆåˆ†åˆ†æï¼ˆPCAï¼‰](#41-ä¸»æˆåˆ†åˆ†æpca)
    - [4.2. t-SNE](#42-t-sne)
    - [4.3. çº¿æ€§åˆ¤åˆ«åˆ†æï¼ˆLDAï¼‰](#43-çº¿æ€§åˆ¤åˆ«åˆ†ælda)
  - [5. å¯†åº¦ä¼°è®¡](#5-å¯†åº¦ä¼°è®¡)
    - [5.1. é«˜æ–¯æ··åˆæ¨¡å‹ï¼ˆGMMï¼‰](#51-é«˜æ–¯æ··åˆæ¨¡å‹gmm)
    - [5.2. æ ¸å¯†åº¦ä¼°è®¡](#52-æ ¸å¯†åº¦ä¼°è®¡)
  - [6. å¼‚å¸¸æ£€æµ‹](#6-å¼‚å¸¸æ£€æµ‹)
    - [6.1. å­¤ç«‹æ£®æ—](#61-å­¤ç«‹æ£®æ—)
    - [6.2. One-Class SVM](#62-one-class-svm)
  - [7. å…³è”è§„åˆ™å­¦ä¹ ](#7-å…³è”è§„åˆ™å­¦ä¹ )
    - [7.1. Aprioriç®—æ³•](#71-aprioriç®—æ³•)
  - [8. çŸ©é˜µåˆ†è§£](#8-çŸ©é˜µåˆ†è§£)
    - [8.1. éè´ŸçŸ©é˜µåˆ†è§£ï¼ˆNMFï¼‰](#81-éè´ŸçŸ©é˜µåˆ†è§£nmf)
    - [8.2. ç‹¬ç«‹æˆåˆ†åˆ†æï¼ˆICAï¼‰](#82-ç‹¬ç«‹æˆåˆ†åˆ†æica)
  - [9. Rustå®ç°ç¤ºä¾‹](#9-rustå®ç°ç¤ºä¾‹)
    - [9.1. K-Meanså®ç°](#91-k-meanså®ç°)
    - [9.2. PCAå®ç°](#92-pcaå®ç°)
    - [9.3. DBSCANå®ç°](#93-dbscanå®ç°)
  - [10. æœ¬åœ°è·³è½¬é“¾æ¥](#10-æœ¬åœ°è·³è½¬é“¾æ¥)
  - [11. å‚è€ƒæ–‡çŒ®](#11-å‚è€ƒæ–‡çŒ®)
  - [12. å¤šè¡¨å¾](#12-å¤šè¡¨å¾)
  - [13. å½¢å¼åŒ–è¯­ä¹‰](#13-å½¢å¼åŒ–è¯­ä¹‰)
  - [14. å½¢å¼åŒ–è¯­æ³•ä¸è¯æ˜](#14-å½¢å¼åŒ–è¯­æ³•ä¸è¯æ˜)

## 3. èšç±»ç®—æ³•

### 3.1. K-Meansèšç±»

**ç®—æ³•åŸç†**ï¼š

ç›®æ ‡å‡½æ•°ï¼ˆæœ€å°åŒ–ç°‡å†…å¹³æ–¹å’Œï¼‰ï¼š
$$J = \sum_{i=1}^k \sum_{x \in C_i} ||x - \mu_i||^2$$

å…¶ä¸­ $\mu_i$ æ˜¯ç¬¬ $i$ ä¸ªç°‡çš„è´¨å¿ƒï¼š
$$\mu_i = \frac{1}{|C_i|} \sum_{x \in C_i} x$$

**ç®—æ³•æ­¥éª¤**ï¼š

1. éšæœºåˆå§‹åŒ– $k$ ä¸ªè´¨å¿ƒ
2. åˆ†é…æ ·æœ¬åˆ°æœ€è¿‘çš„è´¨å¿ƒ
3. æ›´æ–°è´¨å¿ƒä½ç½®
4. é‡å¤æ­¥éª¤2-3ç›´åˆ°æ”¶æ•›

**æ”¶æ•›æ€§è¯æ˜**ï¼š

Lloydç®—æ³•ä¿è¯ç›®æ ‡å‡½æ•°å•è°ƒé€’å‡ï¼š
$$J^{(t+1)} \leq J^{(t)}$$

### 3.2. å±‚æ¬¡èšç±»

**å‡èšå±‚æ¬¡èšç±»**ï¼š

è·ç¦»çŸ©é˜µæ›´æ–°å…¬å¼ï¼ˆWardè¿æ¥ï¼‰ï¼š
$$d(C_i \cup C_j, C_k) = \sqrt{\frac{|C_i| + |C_k|}{|C_i| + |C_j| + |C_k|} d(C_i, C_k)^2 + \frac{|C_j| + |C_k|}{|C_i| + |C_j| + |C_k|} d(C_j, C_k)^2 - \frac{|C_k|}{|C_i| + |C_j| + |C_k|} d(C_i, C_j)^2}$$

### 3.3. DBSCANå¯†åº¦èšç±»

**æ ¸å¿ƒæ¦‚å¿µ**ï¼š

- $\epsilon$-é‚»åŸŸï¼š$N_\epsilon(p) = \{q \in D | \text{dist}(p,q) \leq \epsilon\}$
- æ ¸å¿ƒç‚¹ï¼š$|N_\epsilon(p)| \geq \text{MinPts}$
- å¯†åº¦ç›´è¾¾ï¼š$q$ åœ¨ $p$ çš„ $\epsilon$-é‚»åŸŸå†…ä¸” $p$ æ˜¯æ ¸å¿ƒç‚¹

**èšç±»è´¨é‡**ï¼š

è½®å»“ç³»æ•°ï¼š
$$s(i) = \frac{b(i) - a(i)}{\max(a(i), b(i))}$$

å…¶ä¸­ï¼š

- $a(i)$ï¼šæ ·æœ¬ $i$ åˆ°åŒç°‡å…¶ä»–ç‚¹çš„å¹³å‡è·ç¦»
- $b(i)$ï¼šæ ·æœ¬ $i$ åˆ°æœ€è¿‘å…¶ä»–ç°‡çš„å¹³å‡è·ç¦»

## 4. é™ç»´ç®—æ³•

### 4.1. ä¸»æˆåˆ†åˆ†æï¼ˆPCAï¼‰

**æ•°å­¦åŸç†**ï¼š

åæ–¹å·®çŸ©é˜µï¼š
$$\Sigma = \frac{1}{n-1} \sum_{i=1}^n (x_i - \bar{x})(x_i - \bar{x})^T$$

ç‰¹å¾å€¼åˆ†è§£ï¼š
$$\Sigma = V\Lambda V^T$$

å…¶ä¸­ $V$ æ˜¯ç‰¹å¾å‘é‡çŸ©é˜µï¼Œ$\Lambda$ æ˜¯ç‰¹å¾å€¼å¯¹è§’çŸ©é˜µã€‚

**é™ç»´å˜æ¢**ï¼š
$$y = V_k^T (x - \bar{x})$$

**é‡æ„è¯¯å·®**ï¼š
$$\text{Error} = \sum_{i=k+1}^d \lambda_i$$

### 4.2. t-SNE

**æ¦‚ç‡åˆ†å¸ƒå®šä¹‰**ï¼š

é«˜ç»´ç©ºé—´ä¸­çš„æ¡ä»¶æ¦‚ç‡ï¼š
$$p_{j|i} = \frac{\exp(-||x_i - x_j||^2 / 2\sigma_i^2)}{\sum_{k \neq i} \exp(-||x_i - x_k||^2 / 2\sigma_i^2)}$$

å¯¹ç§°åŒ–ï¼š
$$p_{ij} = \frac{p_{j|i} + p_{i|j}}{2n}$$

ä½ç»´ç©ºé—´ä¸­çš„æ¦‚ç‡ï¼š
$$q_{ij} = \frac{(1 + ||y_i - y_j||^2)^{-1}}{\sum_{k \neq l} (1 + ||y_k - y_l||^2)^{-1}}$$

**ç›®æ ‡å‡½æ•°**ï¼ˆKLæ•£åº¦ï¼‰ï¼š
$$C = \sum_i \text{KL}(P_i || Q_i) = \sum_i \sum_j p_{ij} \log \frac{p_{ij}}{q_{ij}}$$

### 4.3. çº¿æ€§åˆ¤åˆ«åˆ†æï¼ˆLDAï¼‰

**ç›®æ ‡å‡½æ•°**ï¼š

æœ€å¤§åŒ–ç±»é—´æ•£åº¦ä¸ç±»å†…æ•£åº¦çš„æ¯”å€¼ï¼š
$$J(w) = \frac{w^T S_B w}{w^T S_W w}$$

å…¶ä¸­ï¼š

- ç±»é—´æ•£åº¦çŸ©é˜µï¼š$S_B = \sum_{i=1}^c n_i (\mu_i - \mu)(\mu_i - \mu)^T$
- ç±»å†…æ•£åº¦çŸ©é˜µï¼š$S_W = \sum_{i=1}^c \sum_{x \in C_i} (x - \mu_i)(x - \mu_i)^T$

**è§£æè§£**ï¼š
$$S_W^{-1} S_B w = \lambda w$$

## 5. å¯†åº¦ä¼°è®¡

### 5.1. é«˜æ–¯æ··åˆæ¨¡å‹ï¼ˆGMMï¼‰

**æ¨¡å‹å®šä¹‰**ï¼š
$$p(x) = \sum_{k=1}^K \pi_k \mathcal{N}(x | \mu_k, \Sigma_k)$$

**EMç®—æ³•**ï¼š

Eæ­¥ï¼ˆæœŸæœ›ï¼‰ï¼š
$$\gamma_{nk} = \frac{\pi_k \mathcal{N}(x_n | \mu_k, \Sigma_k)}{\sum_{j=1}^K \pi_j \mathcal{N}(x_n | \mu_j, \Sigma_j)}$$

Mæ­¥ï¼ˆæœ€å¤§åŒ–ï¼‰ï¼š
$$
\begin{align}
N_k &= \sum_{n=1}^N \gamma_{nk} \\
\mu_k^{new} &= \frac{1}{N_k} \sum_{n=1}^N \gamma_{nk} x_n \\
\Sigma_k^{new} &= \frac{1}{N_k} \sum_{n=1}^N \gamma_{nk} (x_n - \mu_k^{new})(x_n - \mu_k^{new})^T \\
\pi_k^{new} &= \frac{N_k}{N}
\end{align}
$$

### 5.2. æ ¸å¯†åº¦ä¼°è®¡

**Parzençª—æ–¹æ³•**ï¼š
$$\hat{p}(x) = \frac{1}{n} \sum_{i=1}^n \frac{1}{h^d} K\left(\frac{x - x_i}{h}\right)$$

å…¶ä¸­ $K$ æ˜¯æ ¸å‡½æ•°ï¼Œ$h$ æ˜¯å¸¦å®½å‚æ•°ã€‚

**é«˜æ–¯æ ¸**ï¼š
$$K(u) = \frac{1}{\sqrt{2\pi}} \exp\left(-\frac{u^2}{2}\right)$$

## 6. å¼‚å¸¸æ£€æµ‹

### 6.1. å­¤ç«‹æ£®æ—

**å¼‚å¸¸åˆ†æ•°**ï¼š
$$s(x,n) = 2^{-\frac{E(h(x))}{c(n)}}$$

å…¶ä¸­ï¼š

- $E(h(x))$ï¼šè·¯å¾„é•¿åº¦çš„æœŸæœ›
- $c(n) = 2H(n-1) - \frac{2(n-1)}{n}$ï¼šå½’ä¸€åŒ–å¸¸æ•°

### 6.2. One-Class SVM

**å¯¹å¶é—®é¢˜**ï¼š
$$\min_\alpha \frac{1}{2} \sum_{i,j} \alpha_i \alpha_j K(x_i, x_j)$$

çº¦æŸæ¡ä»¶ï¼š
$$0 \leq \alpha_i \leq \frac{1}{\nu n}, \quad \sum_{i=1}^n \alpha_i = 1$$

**å†³ç­–å‡½æ•°**ï¼š
$$f(x) = \sum_{i=1}^n \alpha_i K(x_i, x) - \rho$$

## 7. å…³è”è§„åˆ™å­¦ä¹ 

### 7.1. Aprioriç®—æ³•

**æ”¯æŒåº¦**ï¼š
$$\text{support}(X) = \frac{|\{T \in D | X \subseteq T\}|}{|D|}$$

**ç½®ä¿¡åº¦**ï¼š
$$\text{confidence}(X \Rightarrow Y) = \frac{\text{support}(X \cup Y)}{\text{support}(X)}$$

**æå‡åº¦**ï¼š
$$\text{lift}(X \Rightarrow Y) = \frac{\text{confidence}(X \Rightarrow Y)}{\text{support}(Y)}$$

## 8. çŸ©é˜µåˆ†è§£

### 8.1. éè´ŸçŸ©é˜µåˆ†è§£ï¼ˆNMFï¼‰

**ä¼˜åŒ–é—®é¢˜**ï¼š
$$\min_{W,H} ||V - WH||_F^2$$

çº¦æŸæ¡ä»¶ï¼š$W_{ik} \geq 0, H_{kj} \geq 0$

**ä¹˜æ€§æ›´æ–°è§„åˆ™**ï¼š
$$W_{ik} \leftarrow W_{ik} \frac{(VH^T)_{ik}}{(WHH^T)_{ik}}$$
$$H_{kj} \leftarrow H_{kj} \frac{(W^TV)_{kj}}{(W^TWH)_{kj}}$$

### 8.2. ç‹¬ç«‹æˆåˆ†åˆ†æï¼ˆICAï¼‰

**ä¿¡å·åˆ†ç¦»æ¨¡å‹**ï¼š
$$x = As$$

å…¶ä¸­ $s$ æ˜¯ç»Ÿè®¡ç‹¬ç«‹çš„æºä¿¡å·ã€‚

**FastICAç®—æ³•**ï¼š

ç›®æ ‡å‡½æ•°ï¼ˆè´Ÿç†µæœ€å¤§åŒ–ï¼‰ï¼š
$$J(w) = E[G(w^Tx)] - E[G(\nu)]$$

å…¶ä¸­ $\nu \sim \mathcal{N}(0,1)$ï¼Œ$G$ æ˜¯éçº¿æ€§å‡½æ•°ã€‚

## 9. Rustå®ç°ç¤ºä¾‹

### 9.1. K-Meanså®ç°

```rust
use ndarray::{Array1, Array2, Axis};
use rand::Rng;
use std::collections::HashMap;

pub struct KMeans {
    k: usize,
    max_iters: usize,
    tolerance: f64,
    centroids: Option<Array2<f64>>,
}

impl KMeans {
    pub fn new(k: usize, max_iters: usize, tolerance: f64) -> Self {
        Self {
            k,
            max_iters,
            tolerance,
            centroids: None,
        }
    }

    pub fn fit(&mut self, data: &Array2<f64>) -> Vec<usize> {
        let (n_samples, n_features) = data.dim();

        // éšæœºåˆå§‹åŒ–è´¨å¿ƒ
        let mut centroids = self.initialize_centroids(data);
        let mut labels = vec![0; n_samples];

        for _ in 0..self.max_iters {
            let old_centroids = centroids.clone();

            // åˆ†é…æ ·æœ¬åˆ°æœ€è¿‘çš„è´¨å¿ƒ
            for i in 0..n_samples {
                let sample = data.row(i);
                labels[i] = self.closest_centroid(&sample, &centroids);
            }

            // æ›´æ–°è´¨å¿ƒ
            centroids = self.update_centroids(data, &labels);

            // æ£€æŸ¥æ”¶æ•›
            if self.converged(&old_centroids, &centroids) {
                break;
            }
        }

        self.centroids = Some(centroids);
        labels
    }

    fn initialize_centroids(&self, data: &Array2<f64>) -> Array2<f64> {
        let (_, n_features) = data.dim();
        let mut rng = rand::thread_rng();
        let mut centroids = Array2::zeros((self.k, n_features));

        for i in 0..self.k {
            for j in 0..n_features {
                // åœ¨æ•°æ®èŒƒå›´å†…éšæœºåˆå§‹åŒ–
                let min_val = data.column(j).fold(f64::INFINITY, |a, &b| a.min(b));
                let max_val = data.column(j).fold(f64::NEG_INFINITY, |a, &b| a.max(b));
                centroids[[i, j]] = rng.gen_range(min_val..max_val);
            }
        }

        centroids
    }

    fn closest_centroid(&self, sample: ndarray::ArrayView1<f64>, centroids: &Array2<f64>) -> usize {
        let mut min_dist = f64::INFINITY;
        let mut closest = 0;

        for i in 0..self.k {
            let centroid = centroids.row(i);
            let dist = self.euclidean_distance(&sample, &centroid);

            if dist < min_dist {
                min_dist = dist;
                closest = i;
            }
        }

        closest
    }

    fn euclidean_distance(&self, a: &ndarray::ArrayView1<f64>, b: &ndarray::ArrayView1<f64>) -> f64 {
        a.iter().zip(b.iter())
            .map(|(x, y)| (x - y).powi(2))
            .sum::<f64>()
            .sqrt()
    }

    fn update_centroids(&self, data: &Array2<f64>, labels: &[usize]) -> Array2<f64> {
        let (_, n_features) = data.dim();
        let mut centroids = Array2::zeros((self.k, n_features));
        let mut counts = vec![0; self.k];

        // ç´¯åŠ æ¯ä¸ªç°‡çš„æ ·æœ¬
        for (i, &label) in labels.iter().enumerate() {
            let sample = data.row(i);
            for j in 0..n_features {
                centroids[[label, j]] += sample[j];
            }
            counts[label] += 1;
        }

        // è®¡ç®—å¹³å‡å€¼
        for i in 0..self.k {
            if counts[i] > 0 {
                for j in 0..n_features {
                    centroids[[i, j]] /= counts[i] as f64;
                }
            }
        }

        centroids
    }

    fn converged(&self, old_centroids: &Array2<f64>, new_centroids: &Array2<f64>) -> bool {
        for i in 0..self.k {
            let old_centroid = old_centroids.row(i);
            let new_centroid = new_centroids.row(i);

            if self.euclidean_distance(&old_centroid, &new_centroid) > self.tolerance {
                return false;
            }
        }
        true
    }

    pub fn predict(&self, data: &Array2<f64>) -> Vec<usize> {
        let centroids = self.centroids.as_ref().expect("Model not fitted");
        let mut labels = Vec::new();

        for row in data.outer_iter() {
            labels.push(self.closest_centroid(row, centroids));
        }

        labels
    }
}
```

### 9.2. PCAå®ç°

```rust
use ndarray::{Array1, Array2, Axis};
use ndarray_linalg::{Eig, UPLO};

pub struct PCA {
    n_components: usize,
    components: Option<Array2<f64>>,
    explained_variance: Option<Array1<f64>>,
    mean: Option<Array1<f64>>,
}

impl PCA {
    pub fn new(n_components: usize) -> Self {
        Self {
            n_components,
            components: None,
            explained_variance: None,
            mean: None,
        }
    }

    pub fn fit(&mut self, data: &Array2<f64>) {
        let (n_samples, n_features) = data.dim();

        // è®¡ç®—å‡å€¼
        let mean = data.mean_axis(Axis(0)).unwrap();

        // ä¸­å¿ƒåŒ–æ•°æ®
        let centered_data = data - &mean.view().insert_axis(Axis(0));

        // è®¡ç®—åæ–¹å·®çŸ©é˜µ
        let cov_matrix = centered_data.t().dot(&centered_data) / (n_samples - 1) as f64;

        // ç‰¹å¾å€¼åˆ†è§£
        let (eigenvalues, eigenvectors) = cov_matrix.eig(UPLO::Upper).unwrap();

        // æŒ‰ç‰¹å¾å€¼é™åºæ’åº
        let mut indices: Vec<usize> = (0..eigenvalues.len()).collect();
        indices.sort_by(|&i, &j| eigenvalues[j].partial_cmp(&eigenvalues[i]).unwrap());

        // é€‰æ‹©å‰n_componentsä¸ªä¸»æˆåˆ†
        let mut components = Array2::zeros((self.n_components, n_features));
        let mut explained_variance = Array1::zeros(self.n_components);

        for (i, &idx) in indices.iter().take(self.n_components).enumerate() {
            components.row_mut(i).assign(&eigenvectors.column(idx));
            explained_variance[i] = eigenvalues[idx].re;
        }

        self.components = Some(components);
        self.explained_variance = Some(explained_variance);
        self.mean = Some(mean);
    }

    pub fn transform(&self, data: &Array2<f64>) -> Array2<f64> {
        let components = self.components.as_ref().expect("PCA not fitted");
        let mean = self.mean.as_ref().expect("PCA not fitted");

        // ä¸­å¿ƒåŒ–æ•°æ®
        let centered_data = data - &mean.view().insert_axis(Axis(0));

        // æŠ•å½±åˆ°ä¸»æˆåˆ†ç©ºé—´
        centered_data.dot(&components.t())
    }

    pub fn inverse_transform(&self, transformed_data: &Array2<f64>) -> Array2<f64> {
        let components = self.components.as_ref().expect("PCA not fitted");
        let mean = self.mean.as_ref().expect("PCA not fitted");

        // ä»ä¸»æˆåˆ†ç©ºé—´é‡æ„
        let reconstructed = transformed_data.dot(components);

        // æ·»åŠ å‡å€¼
        reconstructed + &mean.view().insert_axis(Axis(0))
    }

    pub fn explained_variance_ratio(&self) -> Array1<f64> {
        let explained_variance = self.explained_variance.as_ref().expect("PCA not fitted");
        let total_variance = explained_variance.sum();
        explained_variance / total_variance
    }
}
```

### 9.3. DBSCANå®ç°

```rust
use std::collections::{HashSet, VecDeque};

# [derive(Debug, Clone, PartialEq)]
enum PointType {
    Core,
    Border,
    Noise,
}

pub struct DBSCAN {
    eps: f64,
    min_pts: usize,
}

impl DBSCAN {
    pub fn new(eps: f64, min_pts: usize) -> Self {
        Self { eps, min_pts }
    }

    pub fn fit_predict(&self, data: &Array2<f64>) -> Vec<i32> {
        let n_samples = data.nrows();
        let mut labels = vec![-1; n_samples]; // -1 è¡¨ç¤ºå™ªå£°ç‚¹
        let mut visited = vec![false; n_samples];
        let mut cluster_id = 0;

        for i in 0..n_samples {
            if visited[i] {
                continue;
            }

            visited[i] = true;
            let neighbors = self.get_neighbors(data, i);

            if neighbors.len() < self.min_pts {
                // å™ªå£°ç‚¹
                continue;
            }

            // å¼€å§‹æ–°ç°‡
            self.expand_cluster(data, i, neighbors, cluster_id, &mut labels, &mut visited);
            cluster_id += 1;
        }

        labels
    }

    fn get_neighbors(&self, data: &Array2<f64>, point_idx: usize) -> Vec<usize> {
        let mut neighbors = Vec::new();
        let point = data.row(point_idx);

        for i in 0..data.nrows() {
            if i == point_idx {
                continue;
            }

            let other_point = data.row(i);
            let distance = self.euclidean_distance(&point, &other_point);

            if distance <= self.eps {
                neighbors.push(i);
            }
        }

        neighbors
    }

    fn expand_cluster(
        &self,
        data: &Array2<f64>,
        point_idx: usize,
        mut neighbors: Vec<usize>,
        cluster_id: i32,
        labels: &mut Vec<i32>,
        visited: &mut Vec<bool>,
    ) {
        labels[point_idx] = cluster_id;
        let mut queue = VecDeque::from(neighbors);

        while let Some(neighbor_idx) = queue.pop_front() {
            if !visited[neighbor_idx] {
                visited[neighbor_idx] = true;
                let neighbor_neighbors = self.get_neighbors(data, neighbor_idx);

                if neighbor_neighbors.len() >= self.min_pts {
                    queue.extend(neighbor_neighbors);
                }
            }

            if labels[neighbor_idx] == -1 {
                labels[neighbor_idx] = cluster_id;
            }
        }
    }

    fn euclidean_distance(&self, a: &ndarray::ArrayView1<f64>, b: &ndarray::ArrayView1<f64>) -> f64 {
        a.iter().zip(b.iter())
            .map(|(x, y)| (x - y).powi(2))
            .sum::<f64>()
            .sqrt()
    }
}
```

## 10. æœ¬åœ°è·³è½¬é“¾æ¥

- [æœºå™¨å­¦ä¹ åŸºç¡€ç†è®º](./3.4.1-æœºå™¨å­¦ä¹ åŸºç¡€ç†è®º.md)
- [ç›‘ç£å­¦ä¹ ç®—æ³•](./3.4.2-ç›‘ç£å­¦ä¹ ç®—æ³•.md)
- [å¼ºåŒ–å­¦ä¹ ç†è®º](./3.4.4-å¼ºåŒ–å­¦ä¹ ç†è®º.md)
- [æ·±åº¦å­¦ä¹ æ¶æ„](./3.4.5-æ·±åº¦å­¦ä¹ æ¶æ„.md)
- [ç±»å‹ç†è®ºåŸºç¡€](../../2-å½¢å¼ç§‘å­¦ç†è®º/2.1-ç±»å‹ç†è®º/2.1.1-ç±»å‹ç†è®ºåŸºç¡€.md)

## 11. å‚è€ƒæ–‡çŒ®

1. Hastie, T., Tibshirani, R., & Friedman, J. (2009). The elements of statistical learning.
2. MacKay, D. J. (2003). Information theory, inference and learning algorithms.
3. Bishop, C. M. (2006). Pattern recognition and machine learning.
4. Duda, R. O., Hart, P. E., & Stork, D. G. (2001). Pattern classification.

## 12. å¤šè¡¨å¾

æ— ç›‘ç£å­¦ä¹ ç®—æ³•æ”¯æŒå¤šç§è¡¨å¾æ–¹å¼ï¼ŒåŒ…æ‹¬ï¼š

- ç¬¦å·è¡¨å¾ï¼ˆç®—æ³•ä¼ªä»£ç ã€ç›®æ ‡å‡½æ•°ã€æ¨¡å‹å…¬å¼ç­‰ï¼‰
- å›¾ç»“æ„ï¼ˆèšç±»å›¾ã€é™ç»´æµç¨‹å›¾ã€æ•°æ®æµå›¾ç­‰ï¼‰
- å‘é‡/å¼ é‡ï¼ˆç‰¹å¾å‘é‡ã€å‚æ•°çŸ©é˜µã€åµŒå…¥ï¼‰
- è‡ªç„¶è¯­è¨€ï¼ˆå®šä¹‰ã€æ³¨é‡Šã€æè¿°ï¼‰
- å›¾åƒ/å¯è§†åŒ–ï¼ˆèšç±»ç»“æ„å›¾ã€æµç¨‹å›¾ã€æ¨¡å‹å¯è§†åŒ–ç­‰ï¼‰
è¿™äº›è¡¨å¾å¯äº’æ˜ ï¼Œæå‡æ— ç›‘ç£å­¦ä¹ ç®—æ³•çš„è¡¨è¾¾åŠ›ã€‚

## 13. å½¢å¼åŒ–è¯­ä¹‰

- è¯­ä¹‰åŸŸï¼š$D$ï¼Œå¦‚è¾“å…¥ç©ºé—´ã€æ¨¡å‹ç©ºé—´ã€ç›®æ ‡å‡½æ•°ç©ºé—´
- è§£é‡Šå‡½æ•°ï¼š$I: S \to D$ï¼Œå°†ç¬¦å·/ç»“æ„æ˜ å°„åˆ°å…·ä½“è¯­ä¹‰å¯¹è±¡
- è¯­ä¹‰ä¸€è‡´æ€§ï¼šæ¯ä¸ªæ¨¡å‹/ç®—æ³•/ç›®æ ‡å‡½æ•°/å…¬å¼åœ¨$D$ä¸­æœ‰æ˜ç¡®å®šä¹‰

## 14. å½¢å¼åŒ–è¯­æ³•ä¸è¯æ˜

- è¯­æ³•è§„åˆ™ï¼šå¦‚æ¨¡å‹å®šä¹‰ã€ç›®æ ‡å‡½æ•°ã€è®­ç»ƒè§„åˆ™ã€æ¨ç†è§„åˆ™ã€çº¦æŸæ¡ä»¶
- **å®šç†**ï¼šæ— ç›‘ç£å­¦ä¹ ç®—æ³•çš„è¯­æ³•ç³»ç»Ÿå…·ä¸€è‡´æ€§ä¸å¯æ‰©å±•æ€§ã€‚
- **è¯æ˜**ï¼šç”±æ¨¡å‹å®šä¹‰ã€ç›®æ ‡å‡½æ•°ä¸æ¨ç†è§„åˆ™é€’å½’å®šä¹‰ï¼Œä¿è¯ç³»ç»Ÿä¸€è‡´ä¸å¯æ‰©å±•ã€‚
