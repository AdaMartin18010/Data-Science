# 5.1.13 é‡‘èè¡Œä¸šå®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [5.1.13 é‡‘èè¡Œä¸šå®è·µæ¡ˆä¾‹](#5113-é‡‘èè¡Œä¸šå®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [2. æ¦‚è¿°](#2-æ¦‚è¿°)
  - [3. é£é™©ç®¡ç†å®è·µæ¡ˆä¾‹](#3-é£é™©ç®¡ç†å®è·µæ¡ˆä¾‹)
    - [3.1. ä¿¡ç”¨é£é™©è¯„ä¼°æ¨¡å‹](#31-ä¿¡ç”¨é£é™©è¯„ä¼°æ¨¡å‹)
  - [4. å¸‚åœºé£é™©VaRæ¨¡å‹](#4-å¸‚åœºé£é™©varæ¨¡å‹)
  - [5. é‡åŒ–äº¤æ˜“å®è·µæ¡ˆä¾‹](#5-é‡åŒ–äº¤æ˜“å®è·µæ¡ˆä¾‹)
    - [5.1. ç§»åŠ¨å¹³å‡çº¿ç­–ç•¥](#51-ç§»åŠ¨å¹³å‡çº¿ç­–ç•¥)
  - [6. æŠ•èµ„ç»„åˆä¼˜åŒ–](#6-æŠ•èµ„ç»„åˆä¼˜åŒ–)
  - [7. æ€»ç»“](#7-æ€»ç»“)

---

## 2. æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›é‡‘èè¡Œä¸šåœ¨å®é™…åº”ç”¨ä¸­çš„å…·ä½“æ¡ˆä¾‹ï¼Œæ¶µç›–é£é™©ç®¡ç†ã€é‡åŒ–äº¤æ˜“ã€æŠ•èµ„ç»„åˆä¼˜åŒ–ç­‰å„ä¸ªæ–¹é¢çš„å®é™…åº”ç”¨ã€‚

## 3. é£é™©ç®¡ç†å®è·µæ¡ˆä¾‹

### 3.1. ä¿¡ç”¨é£é™©è¯„ä¼°æ¨¡å‹

```python
import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, roc_auc_score
import matplotlib.pyplot as plt

class CreditRiskModel:
    def __init__(self):
        self.model = None
        self.feature_importance = None

    def prepare_data(self, data):
        """å‡†å¤‡ä¿¡ç”¨é£é™©æ•°æ®"""
# é€‰æ‹©ç‰¹å¾
        features = [
            'age', 'income', 'credit_score', 'debt_ratio',
            'payment_history', 'employment_length', 'loan_amount',
            'loan_term', 'interest_rate', 'collateral_value'
        ]

        X = data[features].copy()
        y = data['default_risk']

# å¤„ç†ç¼ºå¤±å€¼
        X = X.fillna(X.mean())

        return X, y

    def train_model(self, X, y):
        """è®­ç»ƒä¿¡ç”¨é£é™©æ¨¡å‹"""
        X_train, X_test, y_train, y_test = train_test_split(
            X, y, test_size=0.2, random_state=42, stratify=y
        )

# è®­ç»ƒéšæœºæ£®æ—æ¨¡å‹
        self.model = RandomForestClassifier(n_estimators=100, random_state=42)
        self.model.fit(X_train, y_train)

# é¢„æµ‹
        y_pred = self.model.predict(X_test)
        y_pred_proba = self.model.predict_proba(X_test)[:, 1]

# è¯„ä¼°æ¨¡å‹
        print("ä¿¡ç”¨é£é™©æ¨¡å‹è¯„ä¼°:")
        print(classification_report(y_test, y_pred))
        print(f"AUCåˆ†æ•°: {roc_auc_score(y_test, y_pred_proba):.3f}")

# ç‰¹å¾é‡è¦æ€§
        self.feature_importance = pd.DataFrame({
            'feature': X.columns,
            'importance': self.model.feature_importances_
        }).sort_values('importance', ascending=False)

        return X_test, y_test, y_pred, y_pred_proba

    def assess_credit_risk(self, customer_data):
        """è¯„ä¼°å®¢æˆ·ä¿¡ç”¨é£é™©"""
        if self.model is None:
            print("è¯·å…ˆè®­ç»ƒæ¨¡å‹")
            return None

# é¢„æµ‹é£é™©æ¦‚ç‡
        risk_prob = self.model.predict_proba(customer_data)[0, 1]

# é£é™©ç­‰çº§
        if risk_prob < 0.2:
            risk_level = "ä½é£é™©"
            recommendation = "å¯ä»¥æ‰¹å‡†è´·æ¬¾ï¼Œåˆ©ç‡ä¼˜æƒ "
        elif risk_prob < 0.5:
            risk_level = "ä¸­ç­‰é£é™©"
            recommendation = "å¯ä»¥æ‰¹å‡†è´·æ¬¾ï¼Œæ ‡å‡†åˆ©ç‡"
        elif risk_prob < 0.8:
            risk_level = "é«˜é£é™©"
            recommendation = "éœ€è¦æ‹…ä¿æˆ–æé«˜åˆ©ç‡"
        else:
            risk_level = "æé«˜é£é™©"
            recommendation = "å»ºè®®æ‹’ç»è´·æ¬¾"

        return {
            'risk_probability': risk_prob,
            'risk_level': risk_level,
            'recommendation': recommendation
        }

    def plot_feature_importance(self):
        """ç»˜åˆ¶ç‰¹å¾é‡è¦æ€§"""
        if self.feature_importance is None:
            print("è¯·å…ˆè®­ç»ƒæ¨¡å‹")
            return

        plt.figure(figsize=(10, 6))
        top_features = self.feature_importance.head(10)
        plt.barh(range(len(top_features)), top_features['importance'])
        plt.yticks(range(len(top_features)), top_features['feature'])
        plt.xlabel('é‡è¦æ€§å¾—åˆ†')
        plt.title('ä¿¡ç”¨é£é™©æ¨¡å‹ç‰¹å¾é‡è¦æ€§')
        plt.gca().invert_yaxis()
        plt.tight_layout()
        plt.show()

# ä½¿ç”¨ç¤ºä¾‹
def credit_risk_example():
    """ä¿¡ç”¨é£é™©è¯„ä¼°ç¤ºä¾‹"""
# åˆ›å»ºç¤ºä¾‹æ•°æ®
    np.random.seed(42)
    n_customers = 5000

    data = pd.DataFrame({
        'age': np.random.normal(40, 12, n_customers).clip(18, 80),
        'income': np.random.exponential(50000, n_customers),
        'credit_score': np.random.normal(650, 100, n_customers).clip(300, 850),
        'debt_ratio': np.random.beta(2, 5, n_customers),
        'payment_history': np.random.normal(0.8, 0.2, n_customers).clip(0, 1),
        'employment_length': np.random.exponential(5, n_customers),
        'loan_amount': np.random.exponential(100000, n_customers),
        'loan_term': np.random.randint(12, 360, n_customers),
        'interest_rate': np.random.normal(0.05, 0.02, n_customers).clip(0.02, 0.15),
        'collateral_value': np.random.exponential(150000, n_customers)
    })

# ç”Ÿæˆé£é™©æ ‡ç­¾
    risk_score = (
        (data['age'] < 30) * 0.3 +
        (data['income'] < 30000) * 0.4 +
        (data['credit_score'] < 600) * 0.5 +
        (data['debt_ratio'] > 0.5) * 0.6 +
        (data['payment_history'] < 0.7) * 0.7 +
        np.random.normal(0, 0.1, n_customers)
    )
    data['default_risk'] = (risk_score > 0.5).astype(int)

# è®­ç»ƒæ¨¡å‹
    model = CreditRiskModel()
    X, y = model.prepare_data(data)
    X_test, y_test, y_pred, y_pred_proba = model.train_model(X, y)

# è¯„ä¼°å®¢æˆ·
    sample_customer = pd.DataFrame([{
        'age': 35,
        'income': 60000,
        'credit_score': 720,
        'debt_ratio': 0.3,
        'payment_history': 0.9,
        'employment_length': 8,
        'loan_amount': 150000,
        'loan_term': 240,
        'interest_rate': 0.045,
        'collateral_value': 200000
    }])

    risk_assessment = model.assess_credit_risk(sample_customer)
    print(f"\nå®¢æˆ·é£é™©è¯„ä¼°:")
    print(f"é£é™©æ¦‚ç‡: {risk_assessment['risk_probability']:.3f}")
    print(f"é£é™©ç­‰çº§: {risk_assessment['risk_level']}")
    print(f"å»ºè®®: {risk_assessment['recommendation']}")

# ç»˜åˆ¶ç‰¹å¾é‡è¦æ€§
    model.plot_feature_importance()

    return model, risk_assessment
```

## 4. å¸‚åœºé£é™©VaRæ¨¡å‹

```python
import numpy as np
import pandas as pd
from scipy import stats
import matplotlib.pyplot as plt

class VaRModel:
    def __init__(self, confidence_level=0.95):
        self.confidence_level = confidence_level

    def calculate_historical_var(self, returns, portfolio_value=1000000):
        """è®¡ç®—å†å²VaR"""
# è®¡ç®—å†å²åˆ†ä½æ•°
        var_percentile = np.percentile(returns, (1 - self.confidence_level) * 100)
        var_amount = abs(var_percentile) * portfolio_value

        return {
            'var_percentile': var_percentile,
            'var_amount': var_amount,
            'confidence_level': self.confidence_level
        }

    def calculate_parametric_var(self, returns, portfolio_value=1000000):
        """è®¡ç®—å‚æ•°åŒ–VaRï¼ˆæ­£æ€åˆ†å¸ƒå‡è®¾ï¼‰"""
        mean_return = np.mean(returns)
        std_return = np.std(returns)

# è®¡ç®—VaR
        z_score = stats.norm.ppf(1 - self.confidence_level)
        var_percentile = mean_return - z_score * std_return
        var_amount = abs(var_percentile) * portfolio_value

        return {
            'var_percentile': var_percentile,
            'var_amount': var_amount,
            'mean_return': mean_return,
            'std_return': std_return,
            'confidence_level': self.confidence_level
        }

    def calculate_monte_carlo_var(self, returns, portfolio_value=1000000, n_simulations=10000):
        """è®¡ç®—è’™ç‰¹å¡æ´›VaR"""
        mean_return = np.mean(returns)
        std_return = np.std(returns)

# ç”Ÿæˆéšæœºæ”¶ç›Š
        simulated_returns = np.random.normal(mean_return, std_return, n_simulations)

# è®¡ç®—VaR
        var_percentile = np.percentile(simulated_returns, (1 - self.confidence_level) * 100)
        var_amount = abs(var_percentile) * portfolio_value

        return {
            'var_percentile': var_percentile,
            'var_amount': var_amount,
            'simulated_returns': simulated_returns,
            'confidence_level': self.confidence_level
        }

    def calculate_expected_shortfall(self, returns, portfolio_value=1000000):
        """è®¡ç®—æœŸæœ›æŸå¤±ï¼ˆESï¼‰"""
        var_result = self.calculate_historical_var(returns, portfolio_value)
        var_threshold = var_result['var_percentile']

# è®¡ç®—è¶…è¿‡VaRçš„æŸå¤±æœŸæœ›
        tail_returns = returns[returns <= var_threshold]
        expected_shortfall = np.mean(tail_returns) * portfolio_value

        return {
            'expected_shortfall': abs(expected_shortfall),
            'var_threshold': var_threshold,
            'confidence_level': self.confidence_level
        }

    def plot_var_analysis(self, returns, portfolio_value=1000000):
        """ç»˜åˆ¶VaRåˆ†æå›¾"""
        fig, axes = plt.subplots(2, 2, figsize=(15, 10))

# æ”¶ç›Šåˆ†å¸ƒ
        axes[0, 0].hist(returns, bins=50, alpha=0.7, density=True)
        axes[0, 0].axvline(x=0, color='red', linestyle='--', label='é›¶æ”¶ç›Šçº¿')
        axes[0, 0].set_title('æ”¶ç›Šåˆ†å¸ƒ')
        axes[0, 0].set_xlabel('æ”¶ç›Šç‡')
        axes[0, 0].set_ylabel('å¯†åº¦')
        axes[0, 0].legend()

# ç´¯ç§¯åˆ†å¸ƒ
        sorted_returns = np.sort(returns)
        cumulative_prob = np.arange(1, len(sorted_returns) + 1) / len(sorted_returns)
        axes[0, 1].plot(sorted_returns, cumulative_prob)
        axes[0, 1].axhline(y=self.confidence_level, color='red', linestyle='--',
                          label=f'{self.confidence_level*100}%ç½®ä¿¡æ°´å¹³')
        axes[0, 1].set_title('ç´¯ç§¯åˆ†å¸ƒå‡½æ•°')
        axes[0, 1].set_xlabel('æ”¶ç›Šç‡')
        axes[0, 1].set_ylabel('ç´¯ç§¯æ¦‚ç‡')
        axes[0, 1].legend()

# VaRæ¯”è¾ƒ
        historical_var = self.calculate_historical_var(returns, portfolio_value)
        parametric_var = self.calculate_parametric_var(returns, portfolio_value)
        monte_carlo_var = self.calculate_monte_carlo_var(returns, portfolio_value)

        var_methods = ['å†å²VaR', 'å‚æ•°åŒ–VaR', 'è’™ç‰¹å¡æ´›VaR']
        var_values = [
            historical_var['var_amount'],
            parametric_var['var_amount'],
            monte_carlo_var['var_amount']
        ]

        axes[1, 0].bar(var_methods, var_values)
        axes[1, 0].set_title('VaRæ–¹æ³•æ¯”è¾ƒ')
        axes[1, 0].set_ylabel('VaRé‡‘é¢')
        axes[1, 0].tick_params(axis='x', rotation=45)

# æ—¶é—´åºåˆ—VaR
        window_size = 252  # ä¸€å¹´äº¤æ˜“æ—¥
        rolling_var = []

        for i in range(window_size, len(returns)):
            window_returns = returns[i-window_size:i]
            var_result = self.calculate_historical_var(window_returns, portfolio_value)
            rolling_var.append(var_result['var_amount'])

        axes[1, 1].plot(rolling_var)
        axes[1, 1].set_title('æ»šåŠ¨VaR')
        axes[1, 1].set_xlabel('æ—¶é—´')
        axes[1, 1].set_ylabel('VaRé‡‘é¢')

        plt.tight_layout()
        plt.show()

# ä½¿ç”¨ç¤ºä¾‹
def var_analysis_example():
    """VaRåˆ†æç¤ºä¾‹"""
# åˆ›å»ºç¤ºä¾‹è‚¡ç¥¨æ”¶ç›Šæ•°æ®
    np.random.seed(42)
    n_days = 1000

# æ¨¡æ‹Ÿè‚¡ç¥¨æ”¶ç›Šï¼ˆæ—¥æ”¶ç›Šç‡ï¼‰
    returns = np.random.normal(0.0005, 0.02, n_days)  # å¹´åŒ–æ”¶ç›Šç‡çº¦12%ï¼Œæ³¢åŠ¨ç‡çº¦32%

# åˆ›å»ºVaRæ¨¡å‹
    var_model = VaRModel(confidence_level=0.95)

# è®¡ç®—ä¸åŒæ–¹æ³•çš„VaR
    historical_var = var_model.calculate_historical_var(returns)
    parametric_var = var_model.calculate_parametric_var(returns)
    monte_carlo_var = var_model.calculate_monte_carlo_var(returns)
    expected_shortfall = var_model.calculate_expected_shortfall(returns)

    print("VaRåˆ†æç»“æœ:")
    print(f"å†å²VaR: ${historical_var['var_amount']:,.2f}")
    print(f"å‚æ•°åŒ–VaR: ${parametric_var['var_amount']:,.2f}")
    print(f"è’™ç‰¹å¡æ´›VaR: ${monte_carlo_var['var_amount']:,.2f}")
    print(f"æœŸæœ›æŸå¤±(ES): ${expected_shortfall['expected_shortfall']:,.2f}")

# ç»˜åˆ¶åˆ†æå›¾
    var_model.plot_var_analysis(returns)

    return var_model, {
        'historical_var': historical_var,
        'parametric_var': parametric_var,
        'monte_carlo_var': monte_carlo_var,
        'expected_shortfall': expected_shortfall
    }
```

## 5. é‡åŒ–äº¤æ˜“å®è·µæ¡ˆä¾‹

### 5.1. ç§»åŠ¨å¹³å‡çº¿ç­–ç•¥

```python
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

class MovingAverageStrategy:
    def __init__(self, short_window=20, long_window=50):
        self.short_window = short_window
        self.long_window = long_window
        self.positions = None
        self.returns = None

    def generate_signals(self, prices):
        """ç”Ÿæˆäº¤æ˜“ä¿¡å·"""
        signals = pd.DataFrame(index=prices.index)
        signals['price'] = prices

# è®¡ç®—ç§»åŠ¨å¹³å‡çº¿
        signals['short_ma'] = prices.rolling(window=self.short_window).mean()
        signals['long_ma'] = prices.rolling(window=self.long_window).mean()

# ç”Ÿæˆä¿¡å·
        signals['signal'] = 0
        signals.loc[signals['short_ma'] > signals['long_ma'], 'signal'] = 1  # ä¹°å…¥ä¿¡å·
        signals.loc[signals['short_ma'] < signals['long_ma'], 'signal'] = -1  # å–å‡ºä¿¡å·

# è®¡ç®—æŒä»“
        signals['position'] = signals['signal'].shift(1)

        return signals

    def calculate_returns(self, signals):
        """è®¡ç®—ç­–ç•¥æ”¶ç›Š"""
# è®¡ç®—ä»·æ ¼å˜åŒ–
        signals['price_change'] = signals['price'].pct_change()

# è®¡ç®—ç­–ç•¥æ”¶ç›Š
        signals['strategy_returns'] = signals['position'] * signals['price_change']

# è®¡ç®—ç´¯ç§¯æ”¶ç›Š
        signals['cumulative_returns'] = (1 + signals['strategy_returns']).cumprod()
        signals['benchmark_returns'] = (1 + signals['price_change']).cumprod()

        return signals

    def calculate_performance_metrics(self, signals):
        """è®¡ç®—æ€§èƒ½æŒ‡æ ‡"""
        strategy_returns = signals['strategy_returns'].dropna()
        benchmark_returns = signals['price_change'].dropna()

# å¹´åŒ–æ”¶ç›Šç‡
        total_days = len(strategy_returns)
        annual_return = (signals['cumulative_returns'].iloc[-1] ** (252/total_days)) - 1

# å¹´åŒ–æ³¢åŠ¨ç‡
        annual_volatility = strategy_returns.std() * np.sqrt(252)

# å¤æ™®æ¯”ç‡
        risk_free_rate = 0.02  # å‡è®¾æ— é£é™©åˆ©ç‡ä¸º2%
        sharpe_ratio = (annual_return - risk_free_rate) / annual_volatility

# æœ€å¤§å›æ’¤
        cumulative_returns = signals['cumulative_returns']
        running_max = cumulative_returns.expanding().max()
        drawdown = (cumulative_returns - running_max) / running_max
        max_drawdown = drawdown.min()

# èƒœç‡
        winning_trades = (strategy_returns > 0).sum()
        total_trades = len(strategy_returns)
        win_rate = winning_trades / total_trades if total_trades > 0 else 0

        return {
            'annual_return': annual_return,
            'annual_volatility': annual_volatility,
            'sharpe_ratio': sharpe_ratio,
            'max_drawdown': max_drawdown,
            'win_rate': win_rate,
            'total_trades': total_trades
        }

    def plot_strategy(self, signals):
        """ç»˜åˆ¶ç­–ç•¥å›¾è¡¨"""
        fig, axes = plt.subplots(2, 1, figsize=(15, 10))

# ä»·æ ¼å’Œç§»åŠ¨å¹³å‡çº¿
        axes[0].plot(signals.index, signals['price'], label='ä»·æ ¼', alpha=0.7)
        axes[0].plot(signals.index, signals['short_ma'], label=f'{self.short_window}æ—¥ç§»åŠ¨å¹³å‡', alpha=0.7)
        axes[0].plot(signals.index, signals['long_ma'], label=f'{self.long_window}æ—¥ç§»åŠ¨å¹³å‡', alpha=0.7)

# æ ‡è®°ä¹°å–ç‚¹
        buy_signals = signals[signals['signal'] == 1]
        sell_signals = signals[signals['signal'] == -1]

        axes[0].scatter(buy_signals.index, buy_signals['price'],
                       color='green', marker='^', s=100, label='ä¹°å…¥ä¿¡å·')
        axes[0].scatter(sell_signals.index, sell_signals['price'],
                       color='red', marker='v', s=100, label='å–å‡ºä¿¡å·')

        axes[0].set_title('ç§»åŠ¨å¹³å‡çº¿ç­–ç•¥')
        axes[0].set_ylabel('ä»·æ ¼')
        axes[0].legend()
        axes[0].grid(True)

# ç´¯ç§¯æ”¶ç›Š
        axes[1].plot(signals.index, signals['cumulative_returns'], label='ç­–ç•¥æ”¶ç›Š')
        axes[1].plot(signals.index, signals['benchmark_returns'], label='åŸºå‡†æ”¶ç›Š')
        axes[1].set_title('ç´¯ç§¯æ”¶ç›Šå¯¹æ¯”')
        axes[1].set_xlabel('æ—¥æœŸ')
        axes[1].set_ylabel('ç´¯ç§¯æ”¶ç›Š')
        axes[1].legend()
        axes[1].grid(True)

        plt.tight_layout()
        plt.show()

# ä½¿ç”¨ç¤ºä¾‹
def moving_average_strategy_example():
    """ç§»åŠ¨å¹³å‡çº¿ç­–ç•¥ç¤ºä¾‹"""
# åˆ›å»ºç¤ºä¾‹è‚¡ç¥¨ä»·æ ¼æ•°æ®
    np.random.seed(42)
    n_days = 500

# æ¨¡æ‹Ÿè‚¡ç¥¨ä»·æ ¼ï¼ˆå¸¦è¶‹åŠ¿å’Œæ³¢åŠ¨ï¼‰
    initial_price = 100
    returns = np.random.normal(0.0005, 0.02, n_days)  # æ—¥æ”¶ç›Šç‡
    prices = [initial_price]

    for ret in returns:
        prices.append(prices[-1] * (1 + ret))

    price_series = pd.Series(prices[1:], index=pd.date_range('2020-01-01', periods=n_days, freq='D'))

# åˆ›å»ºç­–ç•¥
    strategy = MovingAverageStrategy(short_window=20, long_window=50)

# ç”Ÿæˆä¿¡å·
    signals = strategy.generate_signals(price_series)

# è®¡ç®—æ”¶ç›Š
    signals = strategy.calculate_returns(signals)

# è®¡ç®—æ€§èƒ½æŒ‡æ ‡
    performance = strategy.calculate_performance_metrics(signals)

    print("ç­–ç•¥æ€§èƒ½æŒ‡æ ‡:")
    print(f"å¹´åŒ–æ”¶ç›Šç‡: {performance['annual_return']:.2%}")
    print(f"å¹´åŒ–æ³¢åŠ¨ç‡: {performance['annual_volatility']:.2%}")
    print(f"å¤æ™®æ¯”ç‡: {performance['sharpe_ratio']:.2f}")
    print(f"æœ€å¤§å›æ’¤: {performance['max_drawdown']:.2%}")
    print(f"èƒœç‡: {performance['win_rate']:.2%}")
    print(f"æ€»äº¤æ˜“æ¬¡æ•°: {performance['total_trades']}")

# ç»˜åˆ¶ç­–ç•¥å›¾è¡¨
    strategy.plot_strategy(signals)

    return strategy, signals, performance
```

## 6. æŠ•èµ„ç»„åˆä¼˜åŒ–

```python
import numpy as np
import pandas as pd
from scipy.optimize import minimize
import matplotlib.pyplot as plt

class PortfolioOptimizer:
    def __init__(self, returns_data):
        self.returns = returns_data
        self.mean_returns = returns_data.mean()
        self.cov_matrix = returns_data.cov()
        self.n_assets = len(returns_data.columns)

    def calculate_portfolio_stats(self, weights):
        """è®¡ç®—æŠ•èµ„ç»„åˆç»Ÿè®¡æŒ‡æ ‡"""
        portfolio_return = np.sum(self.mean_returns * weights)
        portfolio_volatility = np.sqrt(np.dot(weights.T, np.dot(self.cov_matrix, weights)))
        sharpe_ratio = portfolio_return / portfolio_volatility if portfolio_volatility > 0 else 0

        return {
            'return': portfolio_return,
            'volatility': portfolio_volatility,
            'sharpe_ratio': sharpe_ratio
        }

    def minimize_volatility(self, target_return=None):
        """æœ€å°åŒ–æ³¢åŠ¨ç‡"""
        def objective(weights):
            return np.sqrt(np.dot(weights.T, np.dot(self.cov_matrix, weights)))

        constraints = [
            {'type': 'eq', 'fun': lambda x: np.sum(x) - 1}  # æƒé‡å’Œä¸º1
        ]

        if target_return is not None:
            constraints.append({
                'type': 'eq',
                'fun': lambda x: np.sum(self.mean_returns * x) - target_return
            })

        bounds = [(0, 1) for _ in range(self.n_assets)]  # æƒé‡åœ¨0-1ä¹‹é—´

        result = minimize(objective,
                         x0=np.array([1/self.n_assets] * self.n_assets),
                         method='SLSQP',
                         bounds=bounds,
                         constraints=constraints)

        return result.x, result.fun

    def maximize_sharpe_ratio(self, risk_free_rate=0.02):
        """æœ€å¤§åŒ–å¤æ™®æ¯”ç‡"""
        def objective(weights):
            portfolio_return = np.sum(self.mean_returns * weights)
            portfolio_volatility = np.sqrt(np.dot(weights.T, np.dot(self.cov_matrix, weights)))
            sharpe_ratio = (portfolio_return - risk_free_rate) / portfolio_volatility
            return -sharpe_ratio  # æœ€å°åŒ–è´Ÿå¤æ™®æ¯”ç‡

        constraints = [
            {'type': 'eq', 'fun': lambda x: np.sum(x) - 1}
        ]

        bounds = [(0, 1) for _ in range(self.n_assets)]

        result = minimize(objective,
                         x0=np.array([1/self.n_assets] * self.n_assets),
                         method='SLSQP',
                         bounds=bounds,
                         constraints=constraints)

        return result.x, -result.fun

    def efficient_frontier(self, n_points=50):
        """è®¡ç®—æœ‰æ•ˆå‰æ²¿"""
        min_return = self.mean_returns.min()
        max_return = self.mean_returns.max()
        target_returns = np.linspace(min_return, max_return, n_points)

        efficient_portfolios = []

        for target_return in target_returns:
            try:
                weights, volatility = self.minimize_volatility(target_return)
                portfolio_stats = self.calculate_portfolio_stats(weights)
                efficient_portfolios.append({
                    'weights': weights,
                    'return': portfolio_stats['return'],
                    'volatility': portfolio_stats['volatility'],
                    'sharpe_ratio': portfolio_stats['sharpe_ratio']
                })
            except:
                continue

        return efficient_portfolios

    def plot_efficient_frontier(self, efficient_portfolios):
        """ç»˜åˆ¶æœ‰æ•ˆå‰æ²¿"""
        returns = [p['return'] for p in efficient_portfolios]
        volatilities = [p['volatility'] for p in efficient_portfolios]
        sharpe_ratios = [p['sharpe_ratio'] for p in efficient_portfolios]

        fig, axes = plt.subplots(1, 2, figsize=(15, 6))

# æœ‰æ•ˆå‰æ²¿
        axes[0].scatter(volatilities, returns, c=sharpe_ratios, cmap='viridis', alpha=0.7)
        axes[0].set_xlabel('æ³¢åŠ¨ç‡')
        axes[0].set_ylabel('æ”¶ç›Šç‡')
        axes[0].set_title('æœ‰æ•ˆå‰æ²¿')
        axes[0].colorbar(label='å¤æ™®æ¯”ç‡')
        axes[0].grid(True)

# æƒé‡åˆ†å¸ƒ
        max_sharpe_idx = np.argmax(sharpe_ratios)
        optimal_weights = efficient_portfolios[max_sharpe_idx]['weights']

        axes[1].bar(range(self.n_assets), optimal_weights)
        axes[1].set_xlabel('èµ„äº§')
        axes[1].set_ylabel('æƒé‡')
        axes[1].set_title('æœ€ä¼˜æŠ•èµ„ç»„åˆæƒé‡')
        axes[1].set_xticks(range(self.n_assets))
        axes[1].set_xticklabels(self.returns.columns, rotation=45)
        axes[1].grid(True)

        plt.tight_layout()
        plt.show()

# ä½¿ç”¨ç¤ºä¾‹
def portfolio_optimization_example():
    """æŠ•èµ„ç»„åˆä¼˜åŒ–ç¤ºä¾‹"""
# åˆ›å»ºç¤ºä¾‹èµ„äº§æ”¶ç›Šæ•°æ®
    np.random.seed(42)
    n_days = 252
    n_assets = 5

# æ¨¡æ‹Ÿä¸åŒèµ„äº§çš„æ”¶ç›Š
    asset_names = ['è‚¡ç¥¨A', 'è‚¡ç¥¨B', 'è‚¡ç¥¨C', 'å€ºåˆ¸', 'å•†å“']
    returns_data = pd.DataFrame()

    for i, name in enumerate(asset_names):
        if 'è‚¡ç¥¨' in name:
# è‚¡ç¥¨ï¼šé«˜æ”¶ç›Šé«˜æ³¢åŠ¨
            returns_data[name] = np.random.normal(0.001, 0.025, n_days)
        elif 'å€ºåˆ¸' in name:
# å€ºåˆ¸ï¼šä½æ”¶ç›Šä½æ³¢åŠ¨
            returns_data[name] = np.random.normal(0.0003, 0.008, n_days)
        else:
# å•†å“ï¼šä¸­ç­‰æ”¶ç›Šä¸­ç­‰æ³¢åŠ¨
            returns_data[name] = np.random.normal(0.0005, 0.015, n_days)

    returns_data.index = pd.date_range('2020-01-01', periods=n_days, freq='D')

# åˆ›å»ºæŠ•èµ„ç»„åˆä¼˜åŒ–å™¨
    optimizer = PortfolioOptimizer(returns_data)

# æœ€å°æ³¢åŠ¨ç‡æŠ•èµ„ç»„åˆ
    min_vol_weights, min_vol_volatility = optimizer.minimize_volatility()
    min_vol_stats = optimizer.calculate_portfolio_stats(min_vol_weights)

    print("æœ€å°æ³¢åŠ¨ç‡æŠ•èµ„ç»„åˆ:")
    print(f"æ”¶ç›Šç‡: {min_vol_stats['return']:.2%}")
    print(f"æ³¢åŠ¨ç‡: {min_vol_stats['volatility']:.2%}")
    print(f"å¤æ™®æ¯”ç‡: {min_vol_stats['sharpe_ratio']:.2f}")
    print("æƒé‡åˆ†é…:")
    for i, name in enumerate(asset_names):
        print(f"  {name}: {min_vol_weights[i]:.2%}")

# æœ€å¤§å¤æ™®æ¯”ç‡æŠ•èµ„ç»„åˆ
    max_sharpe_weights, max_sharpe_ratio = optimizer.maximize_sharpe_ratio()
    max_sharpe_stats = optimizer.calculate_portfolio_stats(max_sharpe_weights)

    print(f"\næœ€å¤§å¤æ™®æ¯”ç‡æŠ•èµ„ç»„åˆ:")
    print(f"æ”¶ç›Šç‡: {max_sharpe_stats['return']:.2%}")
    print(f"æ³¢åŠ¨ç‡: {max_sharpe_stats['volatility']:.2%}")
    print(f"å¤æ™®æ¯”ç‡: {max_sharpe_stats['sharpe_ratio']:.2f}")
    print("æƒé‡åˆ†é…:")
    for i, name in enumerate(asset_names):
        print(f"  {name}: {max_sharpe_weights[i]:.2%}")

# è®¡ç®—æœ‰æ•ˆå‰æ²¿
    efficient_portfolios = optimizer.efficient_frontier()

# ç»˜åˆ¶æœ‰æ•ˆå‰æ²¿
    optimizer.plot_efficient_frontier(efficient_portfolios)

    return optimizer, {
        'min_volatility': {'weights': min_vol_weights, 'stats': min_vol_stats},
        'max_sharpe': {'weights': max_sharpe_weights, 'stats': max_sharpe_stats},
        'efficient_frontier': efficient_portfolios
    }
```

## 7. æ€»ç»“

æœ¬æ–‡æ¡£æä¾›äº†é‡‘èè¡Œä¸šåœ¨å®é™…åº”ç”¨ä¸­çš„å…·ä½“æ¡ˆä¾‹ï¼ŒåŒ…æ‹¬ï¼š

1. **é£é™©ç®¡ç†å®è·µ**ï¼šä¿¡ç”¨é£é™©è¯„ä¼°æ¨¡å‹å’Œå¸‚åœºé£é™©VaRæ¨¡å‹
2. **é‡åŒ–äº¤æ˜“å®è·µ**ï¼šç§»åŠ¨å¹³å‡çº¿ç­–ç•¥å’ŒæŠ•èµ„ç»„åˆä¼˜åŒ–

è¿™äº›æ¡ˆä¾‹å±•ç¤ºäº†é‡‘èæ•°æ®ç§‘å­¦åœ¨å„ä¸ªé¢†åŸŸçš„å®é™…åº”ç”¨ï¼Œä¸ºé‡‘èåˆ†æé¡¹ç›®æä¾›äº†å®ç”¨çš„å‚è€ƒå’ŒæŒ‡å¯¼ã€‚
