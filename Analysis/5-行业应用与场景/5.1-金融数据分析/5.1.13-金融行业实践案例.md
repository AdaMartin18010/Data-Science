# 5.1.13 金融行业实践案例

## 1. 概述

本文档提供金融行业在实际应用中的具体案例，涵盖风险管理、量化交易、投资组合优化等各个方面的实际应用。

## 2. 风险管理实践案例

### 2.1 信用风险评估模型

```python
import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, roc_auc_score
import matplotlib.pyplot as plt

class CreditRiskModel:
    def __init__(self):
        self.model = None
        self.feature_importance = None
        
    def prepare_data(self, data):
        """准备信用风险数据"""
        # 选择特征
        features = [
            'age', 'income', 'credit_score', 'debt_ratio',
            'payment_history', 'employment_length', 'loan_amount',
            'loan_term', 'interest_rate', 'collateral_value'
        ]
        
        X = data[features].copy()
        y = data['default_risk']
        
        # 处理缺失值
        X = X.fillna(X.mean())
        
        return X, y
    
    def train_model(self, X, y):
        """训练信用风险模型"""
        X_train, X_test, y_train, y_test = train_test_split(
            X, y, test_size=0.2, random_state=42, stratify=y
        )
        
        # 训练随机森林模型
        self.model = RandomForestClassifier(n_estimators=100, random_state=42)
        self.model.fit(X_train, y_train)
        
        # 预测
        y_pred = self.model.predict(X_test)
        y_pred_proba = self.model.predict_proba(X_test)[:, 1]
        
        # 评估模型
        print("信用风险模型评估:")
        print(classification_report(y_test, y_pred))
        print(f"AUC分数: {roc_auc_score(y_test, y_pred_proba):.3f}")
        
        # 特征重要性
        self.feature_importance = pd.DataFrame({
            'feature': X.columns,
            'importance': self.model.feature_importances_
        }).sort_values('importance', ascending=False)
        
        return X_test, y_test, y_pred, y_pred_proba
    
    def assess_credit_risk(self, customer_data):
        """评估客户信用风险"""
        if self.model is None:
            print("请先训练模型")
            return None
        
        # 预测风险概率
        risk_prob = self.model.predict_proba(customer_data)[0, 1]
        
        # 风险等级
        if risk_prob < 0.2:
            risk_level = "低风险"
            recommendation = "可以批准贷款，利率优惠"
        elif risk_prob < 0.5:
            risk_level = "中等风险"
            recommendation = "可以批准贷款，标准利率"
        elif risk_prob < 0.8:
            risk_level = "高风险"
            recommendation = "需要担保或提高利率"
        else:
            risk_level = "极高风险"
            recommendation = "建议拒绝贷款"
        
        return {
            'risk_probability': risk_prob,
            'risk_level': risk_level,
            'recommendation': recommendation
        }
    
    def plot_feature_importance(self):
        """绘制特征重要性"""
        if self.feature_importance is None:
            print("请先训练模型")
            return
        
        plt.figure(figsize=(10, 6))
        top_features = self.feature_importance.head(10)
        plt.barh(range(len(top_features)), top_features['importance'])
        plt.yticks(range(len(top_features)), top_features['feature'])
        plt.xlabel('重要性得分')
        plt.title('信用风险模型特征重要性')
        plt.gca().invert_yaxis()
        plt.tight_layout()
        plt.show()

# 使用示例
def credit_risk_example():
    """信用风险评估示例"""
    # 创建示例数据
    np.random.seed(42)
    n_customers = 5000
    
    data = pd.DataFrame({
        'age': np.random.normal(40, 12, n_customers).clip(18, 80),
        'income': np.random.exponential(50000, n_customers),
        'credit_score': np.random.normal(650, 100, n_customers).clip(300, 850),
        'debt_ratio': np.random.beta(2, 5, n_customers),
        'payment_history': np.random.normal(0.8, 0.2, n_customers).clip(0, 1),
        'employment_length': np.random.exponential(5, n_customers),
        'loan_amount': np.random.exponential(100000, n_customers),
        'loan_term': np.random.randint(12, 360, n_customers),
        'interest_rate': np.random.normal(0.05, 0.02, n_customers).clip(0.02, 0.15),
        'collateral_value': np.random.exponential(150000, n_customers)
    })
    
    # 生成风险标签
    risk_score = (
        (data['age'] < 30) * 0.3 +
        (data['income'] < 30000) * 0.4 +
        (data['credit_score'] < 600) * 0.5 +
        (data['debt_ratio'] > 0.5) * 0.6 +
        (data['payment_history'] < 0.7) * 0.7 +
        np.random.normal(0, 0.1, n_customers)
    )
    data['default_risk'] = (risk_score > 0.5).astype(int)
    
    # 训练模型
    model = CreditRiskModel()
    X, y = model.prepare_data(data)
    X_test, y_test, y_pred, y_pred_proba = model.train_model(X, y)
    
    # 评估客户
    sample_customer = pd.DataFrame([{
        'age': 35,
        'income': 60000,
        'credit_score': 720,
        'debt_ratio': 0.3,
        'payment_history': 0.9,
        'employment_length': 8,
        'loan_amount': 150000,
        'loan_term': 240,
        'interest_rate': 0.045,
        'collateral_value': 200000
    }])
    
    risk_assessment = model.assess_credit_risk(sample_customer)
    print(f"\n客户风险评估:")
    print(f"风险概率: {risk_assessment['risk_probability']:.3f}")
    print(f"风险等级: {risk_assessment['risk_level']}")
    print(f"建议: {risk_assessment['recommendation']}")
    
    # 绘制特征重要性
    model.plot_feature_importance()
    
    return model, risk_assessment
```

### 2.2 市场风险VaR模型

```python
import numpy as np
import pandas as pd
from scipy import stats
import matplotlib.pyplot as plt

class VaRModel:
    def __init__(self, confidence_level=0.95):
        self.confidence_level = confidence_level
        
    def calculate_historical_var(self, returns, portfolio_value=1000000):
        """计算历史VaR"""
        # 计算历史分位数
        var_percentile = np.percentile(returns, (1 - self.confidence_level) * 100)
        var_amount = abs(var_percentile) * portfolio_value
        
        return {
            'var_percentile': var_percentile,
            'var_amount': var_amount,
            'confidence_level': self.confidence_level
        }
    
    def calculate_parametric_var(self, returns, portfolio_value=1000000):
        """计算参数化VaR（正态分布假设）"""
        mean_return = np.mean(returns)
        std_return = np.std(returns)
        
        # 计算VaR
        z_score = stats.norm.ppf(1 - self.confidence_level)
        var_percentile = mean_return - z_score * std_return
        var_amount = abs(var_percentile) * portfolio_value
        
        return {
            'var_percentile': var_percentile,
            'var_amount': var_amount,
            'mean_return': mean_return,
            'std_return': std_return,
            'confidence_level': self.confidence_level
        }
    
    def calculate_monte_carlo_var(self, returns, portfolio_value=1000000, n_simulations=10000):
        """计算蒙特卡洛VaR"""
        mean_return = np.mean(returns)
        std_return = np.std(returns)
        
        # 生成随机收益
        simulated_returns = np.random.normal(mean_return, std_return, n_simulations)
        
        # 计算VaR
        var_percentile = np.percentile(simulated_returns, (1 - self.confidence_level) * 100)
        var_amount = abs(var_percentile) * portfolio_value
        
        return {
            'var_percentile': var_percentile,
            'var_amount': var_amount,
            'simulated_returns': simulated_returns,
            'confidence_level': self.confidence_level
        }
    
    def calculate_expected_shortfall(self, returns, portfolio_value=1000000):
        """计算期望损失（ES）"""
        var_result = self.calculate_historical_var(returns, portfolio_value)
        var_threshold = var_result['var_percentile']
        
        # 计算超过VaR的损失期望
        tail_returns = returns[returns <= var_threshold]
        expected_shortfall = np.mean(tail_returns) * portfolio_value
        
        return {
            'expected_shortfall': abs(expected_shortfall),
            'var_threshold': var_threshold,
            'confidence_level': self.confidence_level
        }
    
    def plot_var_analysis(self, returns, portfolio_value=1000000):
        """绘制VaR分析图"""
        fig, axes = plt.subplots(2, 2, figsize=(15, 10))
        
        # 收益分布
        axes[0, 0].hist(returns, bins=50, alpha=0.7, density=True)
        axes[0, 0].axvline(x=0, color='red', linestyle='--', label='零收益线')
        axes[0, 0].set_title('收益分布')
        axes[0, 0].set_xlabel('收益率')
        axes[0, 0].set_ylabel('密度')
        axes[0, 0].legend()
        
        # 累积分布
        sorted_returns = np.sort(returns)
        cumulative_prob = np.arange(1, len(sorted_returns) + 1) / len(sorted_returns)
        axes[0, 1].plot(sorted_returns, cumulative_prob)
        axes[0, 1].axhline(y=self.confidence_level, color='red', linestyle='--', 
                          label=f'{self.confidence_level*100}%置信水平')
        axes[0, 1].set_title('累积分布函数')
        axes[0, 1].set_xlabel('收益率')
        axes[0, 1].set_ylabel('累积概率')
        axes[0, 1].legend()
        
        # VaR比较
        historical_var = self.calculate_historical_var(returns, portfolio_value)
        parametric_var = self.calculate_parametric_var(returns, portfolio_value)
        monte_carlo_var = self.calculate_monte_carlo_var(returns, portfolio_value)
        
        var_methods = ['历史VaR', '参数化VaR', '蒙特卡洛VaR']
        var_values = [
            historical_var['var_amount'],
            parametric_var['var_amount'],
            monte_carlo_var['var_amount']
        ]
        
        axes[1, 0].bar(var_methods, var_values)
        axes[1, 0].set_title('VaR方法比较')
        axes[1, 0].set_ylabel('VaR金额')
        axes[1, 0].tick_params(axis='x', rotation=45)
        
        # 时间序列VaR
        window_size = 252  # 一年交易日
        rolling_var = []
        
        for i in range(window_size, len(returns)):
            window_returns = returns[i-window_size:i]
            var_result = self.calculate_historical_var(window_returns, portfolio_value)
            rolling_var.append(var_result['var_amount'])
        
        axes[1, 1].plot(rolling_var)
        axes[1, 1].set_title('滚动VaR')
        axes[1, 1].set_xlabel('时间')
        axes[1, 1].set_ylabel('VaR金额')
        
        plt.tight_layout()
        plt.show()

# 使用示例
def var_analysis_example():
    """VaR分析示例"""
    # 创建示例股票收益数据
    np.random.seed(42)
    n_days = 1000
    
    # 模拟股票收益（日收益率）
    returns = np.random.normal(0.0005, 0.02, n_days)  # 年化收益率约12%，波动率约32%
    
    # 创建VaR模型
    var_model = VaRModel(confidence_level=0.95)
    
    # 计算不同方法的VaR
    historical_var = var_model.calculate_historical_var(returns)
    parametric_var = var_model.calculate_parametric_var(returns)
    monte_carlo_var = var_model.calculate_monte_carlo_var(returns)
    expected_shortfall = var_model.calculate_expected_shortfall(returns)
    
    print("VaR分析结果:")
    print(f"历史VaR: ${historical_var['var_amount']:,.2f}")
    print(f"参数化VaR: ${parametric_var['var_amount']:,.2f}")
    print(f"蒙特卡洛VaR: ${monte_carlo_var['var_amount']:,.2f}")
    print(f"期望损失(ES): ${expected_shortfall['expected_shortfall']:,.2f}")
    
    # 绘制分析图
    var_model.plot_var_analysis(returns)
    
    return var_model, {
        'historical_var': historical_var,
        'parametric_var': parametric_var,
        'monte_carlo_var': monte_carlo_var,
        'expected_shortfall': expected_shortfall
    }
```

## 3. 量化交易实践案例

### 3.1 移动平均线策略

```python
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

class MovingAverageStrategy:
    def __init__(self, short_window=20, long_window=50):
        self.short_window = short_window
        self.long_window = long_window
        self.positions = None
        self.returns = None
        
    def generate_signals(self, prices):
        """生成交易信号"""
        signals = pd.DataFrame(index=prices.index)
        signals['price'] = prices
        
        # 计算移动平均线
        signals['short_ma'] = prices.rolling(window=self.short_window).mean()
        signals['long_ma'] = prices.rolling(window=self.long_window).mean()
        
        # 生成信号
        signals['signal'] = 0
        signals.loc[signals['short_ma'] > signals['long_ma'], 'signal'] = 1  # 买入信号
        signals.loc[signals['short_ma'] < signals['long_ma'], 'signal'] = -1  # 卖出信号
        
        # 计算持仓
        signals['position'] = signals['signal'].shift(1)
        
        return signals
    
    def calculate_returns(self, signals):
        """计算策略收益"""
        # 计算价格变化
        signals['price_change'] = signals['price'].pct_change()
        
        # 计算策略收益
        signals['strategy_returns'] = signals['position'] * signals['price_change']
        
        # 计算累积收益
        signals['cumulative_returns'] = (1 + signals['strategy_returns']).cumprod()
        signals['benchmark_returns'] = (1 + signals['price_change']).cumprod()
        
        return signals
    
    def calculate_performance_metrics(self, signals):
        """计算性能指标"""
        strategy_returns = signals['strategy_returns'].dropna()
        benchmark_returns = signals['price_change'].dropna()
        
        # 年化收益率
        total_days = len(strategy_returns)
        annual_return = (signals['cumulative_returns'].iloc[-1] ** (252/total_days)) - 1
        
        # 年化波动率
        annual_volatility = strategy_returns.std() * np.sqrt(252)
        
        # 夏普比率
        risk_free_rate = 0.02  # 假设无风险利率为2%
        sharpe_ratio = (annual_return - risk_free_rate) / annual_volatility
        
        # 最大回撤
        cumulative_returns = signals['cumulative_returns']
        running_max = cumulative_returns.expanding().max()
        drawdown = (cumulative_returns - running_max) / running_max
        max_drawdown = drawdown.min()
        
        # 胜率
        winning_trades = (strategy_returns > 0).sum()
        total_trades = len(strategy_returns)
        win_rate = winning_trades / total_trades if total_trades > 0 else 0
        
        return {
            'annual_return': annual_return,
            'annual_volatility': annual_volatility,
            'sharpe_ratio': sharpe_ratio,
            'max_drawdown': max_drawdown,
            'win_rate': win_rate,
            'total_trades': total_trades
        }
    
    def plot_strategy(self, signals):
        """绘制策略图表"""
        fig, axes = plt.subplots(2, 1, figsize=(15, 10))
        
        # 价格和移动平均线
        axes[0].plot(signals.index, signals['price'], label='价格', alpha=0.7)
        axes[0].plot(signals.index, signals['short_ma'], label=f'{self.short_window}日移动平均', alpha=0.7)
        axes[0].plot(signals.index, signals['long_ma'], label=f'{self.long_window}日移动平均', alpha=0.7)
        
        # 标记买卖点
        buy_signals = signals[signals['signal'] == 1]
        sell_signals = signals[signals['signal'] == -1]
        
        axes[0].scatter(buy_signals.index, buy_signals['price'], 
                       color='green', marker='^', s=100, label='买入信号')
        axes[0].scatter(sell_signals.index, sell_signals['price'], 
                       color='red', marker='v', s=100, label='卖出信号')
        
        axes[0].set_title('移动平均线策略')
        axes[0].set_ylabel('价格')
        axes[0].legend()
        axes[0].grid(True)
        
        # 累积收益
        axes[1].plot(signals.index, signals['cumulative_returns'], label='策略收益')
        axes[1].plot(signals.index, signals['benchmark_returns'], label='基准收益')
        axes[1].set_title('累积收益对比')
        axes[1].set_xlabel('日期')
        axes[1].set_ylabel('累积收益')
        axes[1].legend()
        axes[1].grid(True)
        
        plt.tight_layout()
        plt.show()

# 使用示例
def moving_average_strategy_example():
    """移动平均线策略示例"""
    # 创建示例股票价格数据
    np.random.seed(42)
    n_days = 500
    
    # 模拟股票价格（带趋势和波动）
    initial_price = 100
    returns = np.random.normal(0.0005, 0.02, n_days)  # 日收益率
    prices = [initial_price]
    
    for ret in returns:
        prices.append(prices[-1] * (1 + ret))
    
    price_series = pd.Series(prices[1:], index=pd.date_range('2020-01-01', periods=n_days, freq='D'))
    
    # 创建策略
    strategy = MovingAverageStrategy(short_window=20, long_window=50)
    
    # 生成信号
    signals = strategy.generate_signals(price_series)
    
    # 计算收益
    signals = strategy.calculate_returns(signals)
    
    # 计算性能指标
    performance = strategy.calculate_performance_metrics(signals)
    
    print("策略性能指标:")
    print(f"年化收益率: {performance['annual_return']:.2%}")
    print(f"年化波动率: {performance['annual_volatility']:.2%}")
    print(f"夏普比率: {performance['sharpe_ratio']:.2f}")
    print(f"最大回撤: {performance['max_drawdown']:.2%}")
    print(f"胜率: {performance['win_rate']:.2%}")
    print(f"总交易次数: {performance['total_trades']}")
    
    # 绘制策略图表
    strategy.plot_strategy(signals)
    
    return strategy, signals, performance
```

### 3.2 投资组合优化

```python
import numpy as np
import pandas as pd
from scipy.optimize import minimize
import matplotlib.pyplot as plt

class PortfolioOptimizer:
    def __init__(self, returns_data):
        self.returns = returns_data
        self.mean_returns = returns_data.mean()
        self.cov_matrix = returns_data.cov()
        self.n_assets = len(returns_data.columns)
        
    def calculate_portfolio_stats(self, weights):
        """计算投资组合统计指标"""
        portfolio_return = np.sum(self.mean_returns * weights)
        portfolio_volatility = np.sqrt(np.dot(weights.T, np.dot(self.cov_matrix, weights)))
        sharpe_ratio = portfolio_return / portfolio_volatility if portfolio_volatility > 0 else 0
        
        return {
            'return': portfolio_return,
            'volatility': portfolio_volatility,
            'sharpe_ratio': sharpe_ratio
        }
    
    def minimize_volatility(self, target_return=None):
        """最小化波动率"""
        def objective(weights):
            return np.sqrt(np.dot(weights.T, np.dot(self.cov_matrix, weights)))
        
        constraints = [
            {'type': 'eq', 'fun': lambda x: np.sum(x) - 1}  # 权重和为1
        ]
        
        if target_return is not None:
            constraints.append({
                'type': 'eq', 
                'fun': lambda x: np.sum(self.mean_returns * x) - target_return
            })
        
        bounds = [(0, 1) for _ in range(self.n_assets)]  # 权重在0-1之间
        
        result = minimize(objective, 
                         x0=np.array([1/self.n_assets] * self.n_assets),
                         method='SLSQP',
                         bounds=bounds,
                         constraints=constraints)
        
        return result.x, result.fun
    
    def maximize_sharpe_ratio(self, risk_free_rate=0.02):
        """最大化夏普比率"""
        def objective(weights):
            portfolio_return = np.sum(self.mean_returns * weights)
            portfolio_volatility = np.sqrt(np.dot(weights.T, np.dot(self.cov_matrix, weights)))
            sharpe_ratio = (portfolio_return - risk_free_rate) / portfolio_volatility
            return -sharpe_ratio  # 最小化负夏普比率
        
        constraints = [
            {'type': 'eq', 'fun': lambda x: np.sum(x) - 1}
        ]
        
        bounds = [(0, 1) for _ in range(self.n_assets)]
        
        result = minimize(objective,
                         x0=np.array([1/self.n_assets] * self.n_assets),
                         method='SLSQP',
                         bounds=bounds,
                         constraints=constraints)
        
        return result.x, -result.fun
    
    def efficient_frontier(self, n_points=50):
        """计算有效前沿"""
        min_return = self.mean_returns.min()
        max_return = self.mean_returns.max()
        target_returns = np.linspace(min_return, max_return, n_points)
        
        efficient_portfolios = []
        
        for target_return in target_returns:
            try:
                weights, volatility = self.minimize_volatility(target_return)
                portfolio_stats = self.calculate_portfolio_stats(weights)
                efficient_portfolios.append({
                    'weights': weights,
                    'return': portfolio_stats['return'],
                    'volatility': portfolio_stats['volatility'],
                    'sharpe_ratio': portfolio_stats['sharpe_ratio']
                })
            except:
                continue
        
        return efficient_portfolios
    
    def plot_efficient_frontier(self, efficient_portfolios):
        """绘制有效前沿"""
        returns = [p['return'] for p in efficient_portfolios]
        volatilities = [p['volatility'] for p in efficient_portfolios]
        sharpe_ratios = [p['sharpe_ratio'] for p in efficient_portfolios]
        
        fig, axes = plt.subplots(1, 2, figsize=(15, 6))
        
        # 有效前沿
        axes[0].scatter(volatilities, returns, c=sharpe_ratios, cmap='viridis', alpha=0.7)
        axes[0].set_xlabel('波动率')
        axes[0].set_ylabel('收益率')
        axes[0].set_title('有效前沿')
        axes[0].colorbar(label='夏普比率')
        axes[0].grid(True)
        
        # 权重分布
        max_sharpe_idx = np.argmax(sharpe_ratios)
        optimal_weights = efficient_portfolios[max_sharpe_idx]['weights']
        
        axes[1].bar(range(self.n_assets), optimal_weights)
        axes[1].set_xlabel('资产')
        axes[1].set_ylabel('权重')
        axes[1].set_title('最优投资组合权重')
        axes[1].set_xticks(range(self.n_assets))
        axes[1].set_xticklabels(self.returns.columns, rotation=45)
        axes[1].grid(True)
        
        plt.tight_layout()
        plt.show()

# 使用示例
def portfolio_optimization_example():
    """投资组合优化示例"""
    # 创建示例资产收益数据
    np.random.seed(42)
    n_days = 252
    n_assets = 5
    
    # 模拟不同资产的收益
    asset_names = ['股票A', '股票B', '股票C', '债券', '商品']
    returns_data = pd.DataFrame()
    
    for i, name in enumerate(asset_names):
        if '股票' in name:
            # 股票：高收益高波动
            returns_data[name] = np.random.normal(0.001, 0.025, n_days)
        elif '债券' in name:
            # 债券：低收益低波动
            returns_data[name] = np.random.normal(0.0003, 0.008, n_days)
        else:
            # 商品：中等收益中等波动
            returns_data[name] = np.random.normal(0.0005, 0.015, n_days)
    
    returns_data.index = pd.date_range('2020-01-01', periods=n_days, freq='D')
    
    # 创建投资组合优化器
    optimizer = PortfolioOptimizer(returns_data)
    
    # 最小波动率投资组合
    min_vol_weights, min_vol_volatility = optimizer.minimize_volatility()
    min_vol_stats = optimizer.calculate_portfolio_stats(min_vol_weights)
    
    print("最小波动率投资组合:")
    print(f"收益率: {min_vol_stats['return']:.2%}")
    print(f"波动率: {min_vol_stats['volatility']:.2%}")
    print(f"夏普比率: {min_vol_stats['sharpe_ratio']:.2f}")
    print("权重分配:")
    for i, name in enumerate(asset_names):
        print(f"  {name}: {min_vol_weights[i]:.2%}")
    
    # 最大夏普比率投资组合
    max_sharpe_weights, max_sharpe_ratio = optimizer.maximize_sharpe_ratio()
    max_sharpe_stats = optimizer.calculate_portfolio_stats(max_sharpe_weights)
    
    print(f"\n最大夏普比率投资组合:")
    print(f"收益率: {max_sharpe_stats['return']:.2%}")
    print(f"波动率: {max_sharpe_stats['volatility']:.2%}")
    print(f"夏普比率: {max_sharpe_stats['sharpe_ratio']:.2f}")
    print("权重分配:")
    for i, name in enumerate(asset_names):
        print(f"  {name}: {max_sharpe_weights[i]:.2%}")
    
    # 计算有效前沿
    efficient_portfolios = optimizer.efficient_frontier()
    
    # 绘制有效前沿
    optimizer.plot_efficient_frontier(efficient_portfolios)
    
    return optimizer, {
        'min_volatility': {'weights': min_vol_weights, 'stats': min_vol_stats},
        'max_sharpe': {'weights': max_sharpe_weights, 'stats': max_sharpe_stats},
        'efficient_frontier': efficient_portfolios
    }
```

## 4. 总结

本文档提供了金融行业在实际应用中的具体案例，包括：

1. **风险管理实践**：信用风险评估模型和市场风险VaR模型
2. **量化交易实践**：移动平均线策略和投资组合优化

这些案例展示了金融数据科学在各个领域的实际应用，为金融分析项目提供了实用的参考和指导。
