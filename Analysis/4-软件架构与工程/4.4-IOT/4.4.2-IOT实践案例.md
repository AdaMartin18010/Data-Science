# IOT实践案例

## 概述

本文档提供物联网（IoT）技术的实践案例，包括设备管理、数据采集、边缘计算、安全防护等实际应用场景。

## 1. 物联网设备管理

### 1.1 设备注册与发现

```python
class IoTDevice:
    def __init__(self, device_id: str, device_type: str, location: str):
        self.device_id = device_id
        self.device_type = device_type
        self.location = location
        self.status = "offline"
        self.capabilities = []
    
    def to_dict(self):
        return {
            "device_id": self.device_id,
            "device_type": self.device_type,
            "location": self.location,
            "status": self.status,
            "capabilities": self.capabilities
        }

class IoTDeviceManager:
    def __init__(self):
        self.devices = {}
    
    def register_device(self, device: IoTDevice) -> bool:
        if device.device_id in self.devices:
            return False
        self.devices[device.device_id] = device
        device.status = "online"
        return True
    
    def discover_devices(self, device_type: str = None) -> list:
        if device_type:
            return [device for device in self.devices.values() 
                   if device.device_type == device_type]
        return list(self.devices.values())

# 使用示例
device_manager = IoTDeviceManager()
sensor1 = IoTDevice("sensor_001", "temperature", "room_101")
sensor1.capabilities = ["temperature_reading"]
device_manager.register_device(sensor1)
```

### 1.2 设备监控与告警

```python
class DeviceMonitor:
    def __init__(self):
        self.alerts = []
        self.monitoring_rules = {}
    
    def add_monitoring_rule(self, device_id: str, rule: dict):
        if device_id not in self.monitoring_rules:
            self.monitoring_rules[device_id] = []
        self.monitoring_rules[device_id].append(rule)
    
    def check_device_health(self, device_id: str, metrics: dict) -> list:
        alerts = []
        rules = self.monitoring_rules.get(device_id, [])
        
        for rule in rules:
            metric_name = rule.get("metric")
            threshold = rule.get("threshold")
            
            if metric_name in metrics:
                value = metrics[metric_name]
                if value > threshold:
                    alerts.append({
                        "device_id": device_id,
                        "level": "warning",
                        "message": f"{metric_name} 超出阈值: {value} > {threshold}"
                    })
        
        return alerts

# 使用示例
monitor = DeviceMonitor()
monitor.add_monitoring_rule("sensor_001", {
    "metric": "temperature",
    "threshold": 30.0
})

alerts = monitor.check_device_health("sensor_001", {"temperature": 35.0})
print("告警:", alerts)
```

## 2. 数据采集与处理

### 2.1 传感器数据采集

```python
import random
from datetime import datetime

class SensorReading:
    def __init__(self, device_id: str, sensor_type: str, value: float, unit: str):
        self.device_id = device_id
        self.timestamp = datetime.now()
        self.sensor_type = sensor_type
        self.value = value
        self.unit = unit

class DataCollector:
    def __init__(self):
        self.sensors = {}
        self.data_buffer = []
    
    def add_sensor(self, device_id: str, sensor_type: str, unit: str):
        self.sensors[device_id] = {"type": sensor_type, "unit": unit}
    
    def collect_data(self, device_id: str) -> SensorReading:
        sensor = self.sensors[device_id]
        
        # 模拟传感器读数
        if sensor["type"] == "temperature":
            value = random.uniform(20.0, 30.0)
        elif sensor["type"] == "humidity":
            value = random.uniform(40.0, 80.0)
        else:
            value = random.uniform(0.0, 100.0)
        
        reading = SensorReading(device_id, sensor["type"], value, sensor["unit"])
        self.data_buffer.append(reading)
        return reading

# 使用示例
collector = DataCollector()
collector.add_sensor("sensor_001", "temperature", "°C")
reading = collector.collect_data("sensor_001")
print(f"采集数据: {reading.value} {reading.unit}")
```

### 2.2 数据预处理与清洗

```python
import numpy as np

class DataPreprocessor:
    def __init__(self):
        self.quality_threshold = 0.8
    
    def detect_outliers(self, data: list) -> list:
        q1 = np.percentile(data, 25)
        q3 = np.percentile(data, 75)
        iqr = q3 - q1
        lower_bound = q1 - 1.5 * iqr
        upper_bound = q3 + 1.5 * iqr
        
        return [(x < lower_bound) or (x > upper_bound) for x in data]
    
    def fill_missing_values(self, data: list) -> list:
        mean_val = np.mean([x for x in data if not np.isnan(x)])
        return [mean_val if np.isnan(x) else x for x in data]
    
    def smooth_data(self, data: list, window_size: int = 3) -> list:
        if len(data) < window_size:
            return data
        
        smoothed = []
        for i in range(len(data)):
            start = max(0, i - window_size // 2)
            end = min(len(data), i + window_size // 2 + 1)
            window = data[start:end]
            smoothed.append(np.mean(window))
        
        return smoothed

# 使用示例
preprocessor = DataPreprocessor()
data = [25.0, 26.0, 25.8, 100.0, 25.9]  # 包含异常值
outliers = preprocessor.detect_outliers(data)
smoothed = preprocessor.smooth_data(data)
print(f"异常值检测: {outliers}")
print(f"数据平滑: {smoothed}")
```

## 3. 边缘计算

### 3.1 边缘节点管理

```python
class EdgeNode:
    def __init__(self, node_id: str, location: str, capabilities: list):
        self.node_id = node_id
        self.location = location
        self.capabilities = capabilities
        self.status = "offline"
        self.resources = {"cpu": 4.0, "memory": 8.0}

class EdgeComputingManager:
    def __init__(self):
        self.edge_nodes = {}
        self.task_queue = []
    
    def register_edge_node(self, node: EdgeNode) -> bool:
        if node.node_id in self.edge_nodes:
            return False
        self.edge_nodes[node.node_id] = node
        node.status = "online"
        return True
    
    def submit_task(self, task: dict) -> str:
        task_id = f"task_{len(self.task_queue)}_{int(time.time())}"
        task["id"] = task_id
        task["status"] = "pending"
        self.task_queue.append(task)
        return task_id
    
    def allocate_task(self, task: dict) -> str:
        required_capabilities = task.get("required_capabilities", [])
        
        for node_id, node in self.edge_nodes.items():
            if node.status != "online":
                continue
            
            if all(cap in node.capabilities for cap in required_capabilities):
                return node_id
        
        return None

# 使用示例
edge_manager = EdgeComputingManager()
node1 = EdgeNode("edge_001", "factory_floor_1", ["data_processing", "model_inference"])
edge_manager.register_edge_node(node1)

task = {
    "type": "data_processing",
    "required_capabilities": ["data_processing"]
}

task_id = edge_manager.submit_task(task)
node_id = edge_manager.allocate_task(task)
print(f"任务 {task_id} 分配到节点 {node_id}")
```

### 3.2 本地决策与响应

```python
class LocalDecisionEngine:
    def __init__(self):
        self.rules = []
        self.decision_history = []
    
    def add_rule(self, rule: dict):
        self.rules.append(rule)
    
    def make_decision(self, context: dict) -> dict:
        for rule in self.rules:
            conditions = rule.get("conditions", [])
            if self._evaluate_conditions(conditions, context):
                decision = {
                    "rule_id": rule.get("id"),
                    "action": rule.get("action"),
                    "timestamp": datetime.now()
                }
                self.decision_history.append(decision)
                return decision
        
        return {"action": "no_action"}
    
    def _evaluate_conditions(self, conditions: list, context: dict) -> bool:
        for condition in conditions:
            field = condition.get("field")
            operator = condition.get("operator")
            value = condition.get("value")
            
            context_value = context.get(field)
            
            if operator == "gt" and context_value <= value:
                return False
            elif operator == "lt" and context_value >= value:
                return False
        
        return True

# 使用示例
decision_engine = LocalDecisionEngine()
decision_engine.add_rule({
    "id": "temp_high_alert",
    "conditions": [{"field": "temperature", "operator": "gt", "value": 30.0}],
    "action": "send_alert"
})

context = {"temperature": 35.0}
decision = decision_engine.make_decision(context)
print(f"决策: {decision['action']}")
```

## 4. 安全防护

### 4.1 设备认证与授权

```python
import jwt
import time

class DeviceAuthenticator:
    def __init__(self, secret_key: str):
        self.secret_key = secret_key
        self.device_tokens = {}
    
    def generate_device_token(self, device_id: str, capabilities: list) -> str:
        payload = {
            "device_id": device_id,
            "capabilities": capabilities,
            "exp": time.time() + 3600
        }
        token = jwt.encode(payload, self.secret_key, algorithm="HS256")
        self.device_tokens[device_id] = token
        return token
    
    def verify_token(self, token: str) -> dict:
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=["HS256"])
            return payload
        except jwt.InvalidTokenError:
            return None
    
    def check_permission(self, token: str, required_capability: str) -> bool:
        payload = self.verify_token(token)
        if not payload:
            return False
        capabilities = payload.get("capabilities", [])
        return required_capability in capabilities

# 使用示例
authenticator = DeviceAuthenticator("your-secret-key")
token = authenticator.generate_device_token("sensor_001", ["read", "write"])
has_permission = authenticator.check_permission(token, "read")
print(f"读取权限: {'有' if has_permission else '无'}")
```

### 4.2 数据加密与传输安全

```python
from cryptography.fernet import Fernet
import base64

class DataEncryption:
    def __init__(self):
        self.key = Fernet.generate_key()
        self.cipher = Fernet(self.key)
    
    def encrypt_data(self, data: str) -> str:
        encrypted_data = self.cipher.encrypt(data.encode())
        return base64.b64encode(encrypted_data).decode()
    
    def decrypt_data(self, encrypted_data: str) -> str:
        encrypted_bytes = base64.b64decode(encrypted_data.encode())
        decrypted_data = self.cipher.decrypt(encrypted_bytes)
        return decrypted_data.decode()

class SecureDataTransmission:
    def __init__(self):
        self.encryption = DataEncryption()
    
    def send_secure_data(self, data: str, destination: str) -> bool:
        try:
            encrypted_data = self.encryption.encrypt_data(data)
            # 模拟网络传输
            print(f"发送加密数据到 {destination}: {encrypted_data[:20]}...")
            return True
        except Exception as e:
            print(f"传输失败: {e}")
            return False
    
    def receive_secure_data(self, encrypted_data: str) -> str:
        try:
            return self.encryption.decrypt_data(encrypted_data)
        except Exception as e:
            print(f"解密失败: {e}")
            return None

# 使用示例
secure_transmission = SecureDataTransmission()
success = secure_transmission.send_secure_data("敏感数据", "cloud_server")
print(f"数据发送: {'成功' if success else '失败'}")
```

## 总结

本文档提供了物联网技术的实践案例，包括：

1. **设备管理**：设备注册、发现、监控与告警
2. **数据采集**：传感器数据采集、预处理与清洗
3. **边缘计算**：边缘节点管理、本地决策与响应
4. **安全防护**：设备认证授权、数据加密传输

这些实践案例展示了如何将物联网理论应用到实际的智能设备管理和数据处理场景中。
