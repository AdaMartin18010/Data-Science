# 4.3.2 微服务架构实践案例

## 概述

本文档提供微服务架构的实际应用案例，涵盖服务拆分、服务治理、API网关、服务发现、配置管理等核心主题。

## 目录

- [1. 服务拆分实践案例](#1-服务拆分实践案例)
- [2. API网关实践案例](#2-api网关实践案例)
- [3. 服务发现与注册实践案例](#3-服务发现与注册实践案例)
- [4. 服务治理实践案例](#4-服务治理实践案例)
- [5. 配置管理实践案例](#5-配置管理实践案例)

## 1. 服务拆分实践案例

### 1.1 电商系统服务拆分

```python
# 用户服务 (user-service)
class UserService:
    def __init__(self):
        self.db = Database()
    
    def create_user(self, user_data):
        return self.db.users.insert(user_data)
    
    def get_user(self, user_id):
        return self.db.users.find_one({'_id': user_id})
    
    def update_user(self, user_id, user_data):
        return self.db.users.update({'_id': user_id}, user_data)
    
    def delete_user(self, user_id):
        return self.db.users.delete({'_id': user_id})

# 商品服务 (product-service)
class ProductService:
    def __init__(self):
        self.db = Database()
    
    def create_product(self, product_data):
        return self.db.products.insert(product_data)
    
    def get_product(self, product_id):
        return self.db.products.find_one({'_id': product_id})
    
    def search_products(self, query):
        return self.db.products.find({'name': {'$regex': query}})
    
    def update_stock(self, product_id, quantity):
        return self.db.products.update(
            {'_id': product_id},
            {'$inc': {'stock': -quantity}}
        )

# 订单服务 (order-service)
class OrderService:
    def __init__(self):
        self.db = Database()
        self.user_client = UserClient()
        self.product_client = ProductClient()
    
    def create_order(self, user_id, items):
        # 验证用户
        user = self.user_client.get_user(user_id)
        if not user:
            raise Exception("用户不存在")
        
        # 验证商品和库存
        total_amount = 0
        for item in items:
            product = self.product_client.get_product(item['product_id'])
            if not product:
                raise Exception(f"商品 {item['product_id']} 不存在")
            if product['stock'] < item['quantity']:
                raise Exception(f"商品 {item['product_id']} 库存不足")
            total_amount += product['price'] * item['quantity']
        
        # 创建订单
        order = {
            'user_id': user_id,
            'items': items,
            'total_amount': total_amount,
            'status': 'pending',
            'created_at': datetime.now()
        }
        
        order_id = self.db.orders.insert(order)
        
        # 更新库存
        for item in items:
            self.product_client.update_stock(item['product_id'], item['quantity'])
        
        return order_id
    
    def get_order(self, order_id):
        return self.db.orders.find_one({'_id': order_id})
    
    def update_order_status(self, order_id, status):
        return self.db.orders.update(
            {'_id': order_id},
            {'$set': {'status': status}}
        )

# 支付服务 (payment-service)
class PaymentService:
    def __init__(self):
        self.db = Database()
    
    def process_payment(self, order_id, payment_method, amount):
        payment = {
            'order_id': order_id,
            'payment_method': payment_method,
            'amount': amount,
            'status': 'processing',
            'created_at': datetime.now()
        }
        
        payment_id = self.db.payments.insert(payment)
        
        # 模拟支付处理
        if self._process_payment_logic(payment_method, amount):
            self.db.payments.update(
                {'_id': payment_id},
                {'$set': {'status': 'completed'}}
            )
            return payment_id
        else:
            self.db.payments.update(
                {'_id': payment_id},
                {'$set': {'status': 'failed'}}
            )
            raise Exception("支付失败")
    
    def _process_payment_logic(self, payment_method, amount):
        # 模拟支付处理逻辑
        import random
        return random.random() > 0.1  # 90%成功率
```

### 1.2 服务间通信

```python
import requests
import json
from typing import Dict, Any

class ServiceClient:
    def __init__(self, service_name, base_url):
        self.service_name = service_name
        self.base_url = base_url
        self.session = requests.Session()
    
    def _make_request(self, method, endpoint, data=None, params=None):
        url = f"{self.base_url}{endpoint}"
        headers = {'Content-Type': 'application/json'}
        
        try:
            if method.upper() == 'GET':
                response = self.session.get(url, params=params, headers=headers)
            elif method.upper() == 'POST':
                response = self.session.post(url, json=data, headers=headers)
            elif method.upper() == 'PUT':
                response = self.session.put(url, json=data, headers=headers)
            elif method.upper() == 'DELETE':
                response = self.session.delete(url, headers=headers)
            
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as e:
            raise Exception(f"服务 {self.service_name} 调用失败: {e}")

class UserClient(ServiceClient):
    def __init__(self):
        super().__init__('user-service', 'http://user-service:8080')
    
    def get_user(self, user_id):
        return self._make_request('GET', f'/users/{user_id}')
    
    def create_user(self, user_data):
        return self._make_request('POST', '/users', data=user_data)
    
    def update_user(self, user_id, user_data):
        return self._make_request('PUT', f'/users/{user_id}', data=user_data)

class ProductClient(ServiceClient):
    def __init__(self):
        super().__init__('product-service', 'http://product-service:8080')
    
    def get_product(self, product_id):
        return self._make_request('GET', f'/products/{product_id}')
    
    def search_products(self, query):
        return self._make_request('GET', '/products/search', params={'q': query})
    
    def update_stock(self, product_id, quantity):
        return self._make_request('PUT', f'/products/{product_id}/stock', 
                                data={'quantity': quantity})

class PaymentClient(ServiceClient):
    def __init__(self):
        super().__init__('payment-service', 'http://payment-service:8080')
    
    def process_payment(self, order_id, payment_method, amount):
        return self._make_request('POST', '/payments', 
                                data={'order_id': order_id, 
                                     'payment_method': payment_method, 
                                     'amount': amount})
```

## 2. API网关实践案例

### 2.1 基于Flask的API网关

```python
from flask import Flask, request, jsonify
import requests
import jwt
import time
from functools import wraps

app = Flask(__name__)
app.config['SECRET_KEY'] = 'your-secret-key'

# 服务路由配置
SERVICE_ROUTES = {
    'user-service': 'http://user-service:8080',
    'product-service': 'http://product-service:8080',
    'order-service': 'http://order-service:8080',
    'payment-service': 'http://payment-service:8080'
}

def require_auth(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        token = request.headers.get('Authorization')
        if not token:
            return jsonify({'error': '缺少认证令牌'}), 401
        
        try:
            token = token.split(' ')[1]  # Bearer token
            payload = jwt.decode(token, app.config['SECRET_KEY'], algorithms=['HS256'])
            request.user = payload
        except jwt.ExpiredSignatureError:
            return jsonify({'error': '令牌已过期'}), 401
        except jwt.InvalidTokenError:
            return jsonify({'error': '无效令牌'}), 401
        
        return f(*args, **kwargs)
    return decorated

def rate_limit(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        client_ip = request.remote_addr
        # 简单的内存限流（生产环境应使用Redis）
        if hasattr(app, 'rate_limit') and client_ip in app.rate_limit:
            last_request = app.rate_limit[client_ip]
            if time.time() - last_request < 1:  # 1秒内限制1次请求
                return jsonify({'error': '请求过于频繁'}), 429
        
        if not hasattr(app, 'rate_limit'):
            app.rate_limit = {}
        app.rate_limit[client_ip] = time.time()
        
        return f(*args, **kwargs)
    return decorated

@app.route('/api/<service>/<path:path>', methods=['GET', 'POST', 'PUT', 'DELETE'])
@require_auth
@rate_limit
def proxy_request(service, path):
    if service not in SERVICE_ROUTES:
        return jsonify({'error': '服务不存在'}), 404
    
    target_url = f"{SERVICE_ROUTES[service]}/{path}"
    
    # 转发请求
    try:
        headers = dict(request.headers)
        headers.pop('Host', None)  # 移除Host头
        
        response = requests.request(
            method=request.method,
            url=target_url,
            headers=headers,
            params=request.args,
            json=request.get_json() if request.is_json else None,
            data=request.get_data() if not request.is_json else None,
            timeout=30
        )
        
        return response.content, response.status_code, response.headers.items()
    
    except requests.exceptions.RequestException as e:
        return jsonify({'error': f'服务调用失败: {str(e)}'}), 503

@app.route('/api/auth/login', methods=['POST'])
@rate_limit
def login():
    data = request.get_json()
    username = data.get('username')
    password = data.get('password')
    
    # 验证用户（调用用户服务）
    try:
        response = requests.post(
            f"{SERVICE_ROUTES['user-service']}/auth/login",
            json={'username': username, 'password': password}
        )
        
        if response.status_code == 200:
            user_data = response.json()
            # 生成JWT令牌
            token = jwt.encode(
                {
                    'user_id': user_data['user_id'],
                    'username': user_data['username'],
                    'exp': time.time() + 3600  # 1小时过期
                },
                app.config['SECRET_KEY'],
                algorithm='HS256'
            )
            
            return jsonify({
                'token': token,
                'user': user_data
            })
        else:
            return jsonify({'error': '用户名或密码错误'}), 401
    
    except requests.exceptions.RequestException:
        return jsonify({'error': '认证服务不可用'}), 503

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8000)
```

### 2.2 网关配置管理

```yaml
# gateway-config.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: api-gateway-config
data:
  routes.yaml: |
    routes:
      - name: user-service
        path: /api/users/*
        target: http://user-service:8080
        methods: [GET, POST, PUT, DELETE]
        auth: required
        rate_limit: 100/minute
        
      - name: product-service
        path: /api/products/*
        target: http://product-service:8080
        methods: [GET, POST, PUT, DELETE]
        auth: required
        rate_limit: 200/minute
        
      - name: order-service
        path: /api/orders/*
        target: http://order-service:8080
        methods: [GET, POST, PUT, DELETE]
        auth: required
        rate_limit: 50/minute
        
      - name: payment-service
        path: /api/payments/*
        target: http://payment-service:8080
        methods: [GET, POST, PUT, DELETE]
        auth: required
        rate_limit: 30/minute
    
    auth:
      jwt_secret: your-secret-key
      token_expiry: 3600
    
    rate_limiting:
      default_limit: 100/minute
      burst_limit: 200
    
    cors:
      allowed_origins: ["http://localhost:3000", "https://example.com"]
      allowed_methods: [GET, POST, PUT, DELETE, OPTIONS]
      allowed_headers: [Content-Type, Authorization]
```

## 3. 服务发现与注册实践案例

### 3.1 基于Consul的服务注册

```python
import consul
import socket
import time
import threading
from flask import Flask

class ServiceRegistry:
    def __init__(self, consul_host='localhost', consul_port=8500):
        self.consul = consul.Consul(host=consul_host, port=consul_port)
        self.service_name = None
        self.service_id = None
        self.service_address = None
        self.service_port = None
    
    def register_service(self, service_name, service_port, tags=None):
        self.service_name = service_name
        self.service_address = socket.gethostbyname(socket.gethostname())
        self.service_port = service_port
        self.service_id = f"{service_name}-{self.service_address}-{service_port}"
        
        # 注册服务
        self.consul.agent.service.register(
            name=service_name,
            service_id=self.service_id,
            address=self.service_address,
            port=service_port,
            tags=tags or [],
            check=consul.Check.http(
                f"http://{self.service_address}:{service_port}/health",
                interval="10s",
                timeout="5s"
            )
        )
        print(f"服务 {service_name} 已注册到Consul")
    
    def deregister_service(self):
        if self.service_id:
            self.consul.agent.service.deregister(self.service_id)
            print(f"服务 {self.service_name} 已从Consul注销")
    
    def discover_service(self, service_name):
        """服务发现"""
        _, services = self.consul.health.service(service_name, passing=True)
        if services:
            # 简单的负载均衡：轮询
            service = services[0]['Service']
            return f"http://{service['Address']}:{service['Port']}"
        return None
    
    def get_all_services(self):
        """获取所有服务"""
        _, services = self.consul.agent.services()
        return services

# 服务注册示例
class UserServiceApp:
    def __init__(self):
        self.app = Flask(__name__)
        self.registry = ServiceRegistry()
        self.setup_routes()
    
    def setup_routes(self):
        @self.app.route('/health')
        def health_check():
            return {'status': 'healthy'}, 200
        
        @self.app.route('/users/<user_id>')
        def get_user(user_id):
            # 业务逻辑
            return {'user_id': user_id, 'name': 'Test User'}, 200
    
    def start(self, port=8080):
        # 注册服务
        self.registry.register_service('user-service', port, ['api', 'user'])
        
        # 启动服务
        try:
            self.app.run(host='0.0.0.0', port=port)
        finally:
            # 服务关闭时注销
            self.registry.deregister_service()

# 服务发现客户端
class ServiceDiscoveryClient:
    def __init__(self):
        self.registry = ServiceRegistry()
    
    def get_service_url(self, service_name):
        return self.registry.discover_service(service_name)
    
    def call_service(self, service_name, endpoint, method='GET', data=None):
        service_url = self.get_service_url(service_name)
        if not service_url:
            raise Exception(f"服务 {service_name} 不可用")
        
        url = f"{service_url}{endpoint}"
        response = requests.request(method, url, json=data)
        return response.json()

# 使用示例
if __name__ == '__main__':
    user_service = UserServiceApp()
    user_service.start(8080)
```

### 3.2 基于Eureka的服务注册

```python
import requests
import json
import time
import threading

class EurekaClient:
    def __init__(self, eureka_url, app_name, instance_id, host, port):
        self.eureka_url = eureka_url
        self.app_name = app_name
        self.instance_id = instance_id
        self.host = host
        self.port = port
        self.heartbeat_thread = None
        self.running = False
    
    def register(self):
        """注册服务到Eureka"""
        registration_data = {
            "instance": {
                "instanceId": self.instance_id,
                "hostName": self.host,
                "app": self.app_name,
                "ipAddr": self.host,
                "status": "UP",
                "overriddenstatus": "UNKNOWN",
                "port": {
                    "$": self.port,
                    "@enabled": "true"
                },
                "securePort": {
                    "$": 443,
                    "@enabled": "false"
                },
                "countryId": 1,
                "dataCenterInfo": {
                    "@class": "com.netflix.appinfo.InstanceInfo$DefaultDataCenterInfo",
                    "name": "MyOwn"
                },
                "leaseInfo": {
                    "renewalIntervalInSecs": 30,
                    "durationInSecs": 90,
                    "registrationTimestamp": 0,
                    "lastRenewalTimestamp": 0,
                    "evictionTimestamp": 0,
                    "serviceUpTimestamp": 0
                },
                "metadata": {
                    "@class": "java.util.Collections$EmptyMap"
                },
                "homePageUrl": f"http://{self.host}:{self.port}/",
                "statusPageUrl": f"http://{self.host}:{self.port}/health",
                "healthCheckUrl": f"http://{self.host}:{self.port}/health",
                "vipAddress": self.app_name,
                "secureVipAddress": self.app_name,
                "isCoordinatingDiscoveryServer": "false",
                "lastUpdatedTimestamp": "0",
                "lastDirtyTimestamp": "0",
                "actionType": "ADDED"
            }
        }
        
        response = requests.post(
            f"{self.eureka_url}/eureka/apps/{self.app_name}",
            json=registration_data,
            headers={'Content-Type': 'application/json'}
        )
        
        if response.status_code == 204:
            print(f"服务 {self.app_name} 已注册到Eureka")
            self.start_heartbeat()
        else:
            raise Exception(f"服务注册失败: {response.status_code}")
    
    def deregister(self):
        """从Eureka注销服务"""
        self.running = False
        if self.heartbeat_thread:
            self.heartbeat_thread.join()
        
        response = requests.delete(
            f"{self.eureka_url}/eureka/apps/{self.app_name}/{self.instance_id}"
        )
        
        if response.status_code == 200:
            print(f"服务 {self.app_name} 已从Eureka注销")
    
    def start_heartbeat(self):
        """开始心跳"""
        self.running = True
        self.heartbeat_thread = threading.Thread(target=self._heartbeat_loop)
        self.heartbeat_thread.daemon = True
        self.heartbeat_thread.start()
    
    def _heartbeat_loop(self):
        """心跳循环"""
        while self.running:
            try:
                response = requests.put(
                    f"{self.eureka_url}/eureka/apps/{self.app_name}/{self.instance_id}"
                )
                if response.status_code != 200:
                    print(f"心跳失败: {response.status_code}")
            except Exception as e:
                print(f"心跳异常: {e}")
            
            time.sleep(30)  # 30秒心跳一次

# 使用示例
eureka_client = EurekaClient(
    eureka_url='http://eureka-server:8761',
    app_name='user-service',
    instance_id='user-service-1',
    host='localhost',
    port=8080
)

try:
    eureka_client.register()
    # 启动服务...
    time.sleep(3600)  # 运行1小时
finally:
    eureka_client.deregister()
```

## 4. 服务治理实践案例

### 4.1 熔断器实现

```python
import time
import threading
from enum import Enum
from functools import wraps

class CircuitBreakerState(Enum):
    CLOSED = "CLOSED"      # 正常状态
    OPEN = "OPEN"          # 熔断状态
    HALF_OPEN = "HALF_OPEN"  # 半开状态

class CircuitBreaker:
    def __init__(self, failure_threshold=5, recovery_timeout=60, expected_exception=Exception):
        self.failure_threshold = failure_threshold
        self.recovery_timeout = recovery_timeout
        self.expected_exception = expected_exception
        
        self.state = CircuitBreakerState.CLOSED
        self.failure_count = 0
        self.last_failure_time = None
        self.lock = threading.Lock()
    
    def call(self, func, *args, **kwargs):
        with self.lock:
            if self.state == CircuitBreakerState.OPEN:
                if time.time() - self.last_failure_time > self.recovery_timeout:
                    self.state = CircuitBreakerState.HALF_OPEN
                else:
                    raise Exception("熔断器开启，服务不可用")
        
        try:
            result = func(*args, **kwargs)
            self._on_success()
            return result
        except self.expected_exception as e:
            self._on_failure()
            raise e
    
    def _on_success(self):
        with self.lock:
            self.failure_count = 0
            self.state = CircuitBreakerState.CLOSED
    
    def _on_failure(self):
        with self.lock:
            self.failure_count += 1
            self.last_failure_time = time.time()
            
            if self.state == CircuitBreakerState.HALF_OPEN:
                self.state = CircuitBreakerState.OPEN
            elif self.state == CircuitBreakerState.CLOSED and self.failure_count >= self.failure_threshold:
                self.state = CircuitBreakerState.OPEN

def circuit_breaker(failure_threshold=5, recovery_timeout=60):
    def decorator(func):
        breaker = CircuitBreaker(failure_threshold, recovery_timeout)
        
        @wraps(func)
        def wrapper(*args, **kwargs):
            return breaker.call(func, *args, **kwargs)
        
        return wrapper
    return decorator

# 使用示例
@circuit_breaker(failure_threshold=3, recovery_timeout=30)
def call_external_service():
    import random
    if random.random() < 0.3:  # 30%概率失败
        raise Exception("外部服务调用失败")
    return "服务调用成功"

# 测试熔断器
for i in range(10):
    try:
        result = call_external_service()
        print(f"调用 {i+1}: {result}")
    except Exception as e:
        print(f"调用 {i+1}: {e}")
    time.sleep(1)
```

### 4.2 重试机制

```python
import time
import random
from functools import wraps

class RetryPolicy:
    def __init__(self, max_retries=3, base_delay=1, max_delay=60, backoff_factor=2):
        self.max_retries = max_retries
        self.base_delay = base_delay
        self.max_delay = max_delay
        self.backoff_factor = backoff_factor
    
    def get_delay(self, attempt):
        """计算延迟时间（指数退避）"""
        delay = self.base_delay * (self.backoff_factor ** attempt)
        return min(delay, self.max_delay)

def retry(max_retries=3, base_delay=1, max_delay=60, backoff_factor=2, exceptions=(Exception,)):
    def decorator(func):
        policy = RetryPolicy(max_retries, base_delay, max_delay, backoff_factor)
        
        @wraps(func)
        def wrapper(*args, **kwargs):
            last_exception = None
            
            for attempt in range(max_retries + 1):
                try:
                    return func(*args, **kwargs)
                except exceptions as e:
                    last_exception = e
                    
                    if attempt == max_retries:
                        raise last_exception
                    
                    delay = policy.get_delay(attempt)
                    # 添加随机抖动
                    jitter = random.uniform(0, 0.1 * delay)
                    time.sleep(delay + jitter)
            
            raise last_exception
        
        return wrapper
    return decorator

# 使用示例
@retry(max_retries=3, base_delay=1, exceptions=(ConnectionError, TimeoutError))
def unreliable_service_call():
    import random
    if random.random() < 0.7:  # 70%概率失败
        raise ConnectionError("网络连接失败")
    return "服务调用成功"

# 测试重试机制
for i in range(5):
    try:
        result = unreliable_service_call()
        print(f"调用 {i+1}: {result}")
    except Exception as e:
        print(f"调用 {i+1}: 最终失败 - {e}")
```

## 5. 配置管理实践案例

### 5.1 基于ConfigMap的配置管理

```python
import os
import yaml
import json
from typing import Dict, Any

class ConfigManager:
    def __init__(self, config_path='/etc/config'):
        self.config_path = config_path
        self.config_cache = {}
        self.load_config()
    
    def load_config(self):
        """加载配置文件"""
        # 从环境变量加载
        self._load_from_env()
        
        # 从文件加载
        self._load_from_files()
    
    def _load_from_env(self):
        """从环境变量加载配置"""
        for key, value in os.environ.items():
            if key.startswith('APP_'):
                config_key = key[4:].lower()  # 移除APP_前缀
                self.config_cache[config_key] = self._parse_value(value)
    
    def _load_from_files(self):
        """从文件加载配置"""
        if os.path.exists(f"{self.config_path}/config.yaml"):
            with open(f"{self.config_path}/config.yaml", 'r') as f:
                yaml_config = yaml.safe_load(f)
                self.config_cache.update(yaml_config)
        
        if os.path.exists(f"{self.config_path}/config.json"):
            with open(f"{self.config_path}/config.json", 'r') as f:
                json_config = json.load(f)
                self.config_cache.update(json_config)
    
    def _parse_value(self, value):
        """解析配置值"""
        # 尝试解析为JSON
        try:
            return json.loads(value)
        except (json.JSONDecodeError, TypeError):
            pass
        
        # 尝试解析为布尔值
        if value.lower() in ('true', 'false'):
            return value.lower() == 'true'
        
        # 尝试解析为数字
        try:
            if '.' in value:
                return float(value)
            else:
                return int(value)
        except ValueError:
            pass
        
        return value
    
    def get(self, key, default=None):
        """获取配置值"""
        return self.config_cache.get(key, default)
    
    def get_int(self, key, default=0):
        """获取整数配置"""
        value = self.get(key, default)
        try:
            return int(value)
        except (ValueError, TypeError):
            return default
    
    def get_bool(self, key, default=False):
        """获取布尔配置"""
        value = self.get(key, default)
        if isinstance(value, bool):
            return value
        return str(value).lower() in ('true', '1', 'yes', 'on')
    
    def reload(self):
        """重新加载配置"""
        self.config_cache.clear()
        self.load_config()

# 使用示例
config = ConfigManager()

# 数据库配置
db_config = {
    'host': config.get('database.host', 'localhost'),
    'port': config.get_int('database.port', 3306),
    'name': config.get('database.name', 'test'),
    'user': config.get('database.user', 'root'),
    'password': config.get('database.password', '')
}

# 服务配置
service_config = {
    'port': config.get_int('service.port', 8080),
    'debug': config.get_bool('service.debug', False),
    'log_level': config.get('service.log_level', 'INFO')
}

# Redis配置
redis_config = {
    'host': config.get('redis.host', 'localhost'),
    'port': config.get_int('redis.port', 6379),
    'db': config.get_int('redis.db', 0)
}

print("数据库配置:", db_config)
print("服务配置:", service_config)
print("Redis配置:", redis_config)
```

### 5.2 配置热更新

```python
import threading
import time
import os
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

class ConfigWatcher(FileSystemEventHandler):
    def __init__(self, config_manager):
        self.config_manager = config_manager
    
    def on_modified(self, event):
        if not event.is_directory and event.src_path.endswith(('.yaml', '.json')):
            print(f"配置文件 {event.src_path} 已修改，重新加载配置")
            self.config_manager.reload()

class HotReloadConfigManager(ConfigManager):
    def __init__(self, config_path='/etc/config'):
        super().__init__(config_path)
        self.watcher = ConfigWatcher(self)
        self.observer = Observer()
        self.observer.schedule(self.watcher, config_path, recursive=False)
        self.observer.start()
    
    def stop_watching(self):
        """停止文件监控"""
        self.observer.stop()
        self.observer.join()

# 使用示例
config = HotReloadConfigManager('/tmp/config')

try:
    # 服务运行期间配置会自动热更新
    while True:
        print(f"当前端口配置: {config.get_int('service.port', 8080)}")
        time.sleep(10)
except KeyboardInterrupt:
    config.stop_watching()
    print("配置监控已停止")
```

## 总结

这些实践案例展示了微服务架构的核心应用场景，包括：

1. **服务拆分**：按业务领域拆分服务，实现松耦合
2. **API网关**：统一入口、认证、限流、路由
3. **服务发现**：自动注册和发现服务实例
4. **服务治理**：熔断器、重试机制、负载均衡
5. **配置管理**：集中配置、热更新、环境隔离

每个案例都提供了完整的代码示例和最佳实践，可以直接应用于实际项目中。

**相关链接：**
- [4.3.1-微服务架构基础理论](4.3.1-微服务架构基础理论.md)
- [4.1.16-软件架构实践案例](../4.1-架构设计/4.1.16-软件架构实践案例.md)
- [4.2.2-设计模式实践案例](../4.2-设计模式/4.2.2-设计模式实践案例.md)
