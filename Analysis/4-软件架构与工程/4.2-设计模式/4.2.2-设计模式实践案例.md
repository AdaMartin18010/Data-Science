# 4.2.2 è®¾è®¡æ¨¡å¼å®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [4.2.2 è®¾è®¡æ¨¡å¼å®è·µæ¡ˆä¾‹](#422-è®¾è®¡æ¨¡å¼å®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2. ç›®å½•](#2-ç›®å½•)
  - [3. åˆ›å»ºå‹æ¨¡å¼å®è·µæ¡ˆä¾‹](#3-åˆ›å»ºå‹æ¨¡å¼å®è·µæ¡ˆä¾‹)
    - [3.1. å·¥å‚æ¨¡å¼ - æ•°æ®åº“è¿æ¥å·¥å‚](#31-å·¥å‚æ¨¡å¼---æ•°æ®åº“è¿æ¥å·¥å‚)
  - [4. å•ä¾‹æ¨¡å¼ - é…ç½®ç®¡ç†å™¨](#4-å•ä¾‹æ¨¡å¼---é…ç½®ç®¡ç†å™¨)
  - [5. ç»“æ„å‹æ¨¡å¼å®è·µæ¡ˆä¾‹](#5-ç»“æ„å‹æ¨¡å¼å®è·µæ¡ˆä¾‹)
    - [5.1. é€‚é…å™¨æ¨¡å¼ - æ”¯ä»˜ç³»ç»Ÿé€‚é…](#51-é€‚é…å™¨æ¨¡å¼---æ”¯ä»˜ç³»ç»Ÿé€‚é…)
  - [6. è£…é¥°å™¨æ¨¡å¼ - æ—¥å¿—å’Œç¼“å­˜è£…é¥°å™¨](#6-è£…é¥°å™¨æ¨¡å¼---æ—¥å¿—å’Œç¼“å­˜è£…é¥°å™¨)
  - [7. è¡Œä¸ºå‹æ¨¡å¼å®è·µæ¡ˆä¾‹](#7-è¡Œä¸ºå‹æ¨¡å¼å®è·µæ¡ˆä¾‹)
    - [7.1. è§‚å¯Ÿè€…æ¨¡å¼ - äº‹ä»¶é€šçŸ¥ç³»ç»Ÿ](#71-è§‚å¯Ÿè€…æ¨¡å¼---äº‹ä»¶é€šçŸ¥ç³»ç»Ÿ)
  - [8. ç­–ç•¥æ¨¡å¼ - æ’åºç®—æ³•é€‰æ‹©](#8-ç­–ç•¥æ¨¡å¼---æ’åºç®—æ³•é€‰æ‹©)
  - [9. æ¨¡å¼ç»„åˆåº”ç”¨æ¡ˆä¾‹](#9-æ¨¡å¼ç»„åˆåº”ç”¨æ¡ˆä¾‹)
    - [9.1. ç”µå•†ç³»ç»Ÿè®¾è®¡æ¨¡å¼ç»„åˆ](#91-ç”µå•†ç³»ç»Ÿè®¾è®¡æ¨¡å¼ç»„åˆ)
  - [10. æ€»ç»“](#10-æ€»ç»“)

---


## 1. æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›å¸¸ç”¨è®¾è®¡æ¨¡å¼çš„å®é™…åº”ç”¨æ¡ˆä¾‹ï¼Œæ¶µç›–åˆ›å»ºå‹ã€ç»“æ„å‹å’Œè¡Œä¸ºå‹è®¾è®¡æ¨¡å¼ã€‚æ¯ä¸ªæ¡ˆä¾‹éƒ½åŒ…å«å®Œæ•´çš„ä»£ç ç¤ºä¾‹å’Œå®é™…åº”ç”¨åœºæ™¯ã€‚

## 2. ç›®å½•

- [4.2.2 è®¾è®¡æ¨¡å¼å®è·µæ¡ˆä¾‹](#422-è®¾è®¡æ¨¡å¼å®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2. ç›®å½•](#2-ç›®å½•)
  - [3. åˆ›å»ºå‹æ¨¡å¼å®è·µæ¡ˆä¾‹](#3-åˆ›å»ºå‹æ¨¡å¼å®è·µæ¡ˆä¾‹)
    - [3.1. å·¥å‚æ¨¡å¼ - æ•°æ®åº“è¿æ¥å·¥å‚](#31-å·¥å‚æ¨¡å¼---æ•°æ®åº“è¿æ¥å·¥å‚)
  - [4. å•ä¾‹æ¨¡å¼ - é…ç½®ç®¡ç†å™¨](#4-å•ä¾‹æ¨¡å¼---é…ç½®ç®¡ç†å™¨)
  - [5. ç»“æ„å‹æ¨¡å¼å®è·µæ¡ˆä¾‹](#5-ç»“æ„å‹æ¨¡å¼å®è·µæ¡ˆä¾‹)
    - [5.1. é€‚é…å™¨æ¨¡å¼ - æ”¯ä»˜ç³»ç»Ÿé€‚é…](#51-é€‚é…å™¨æ¨¡å¼---æ”¯ä»˜ç³»ç»Ÿé€‚é…)
  - [6. è£…é¥°å™¨æ¨¡å¼ - æ—¥å¿—å’Œç¼“å­˜è£…é¥°å™¨](#6-è£…é¥°å™¨æ¨¡å¼---æ—¥å¿—å’Œç¼“å­˜è£…é¥°å™¨)
  - [7. è¡Œä¸ºå‹æ¨¡å¼å®è·µæ¡ˆä¾‹](#7-è¡Œä¸ºå‹æ¨¡å¼å®è·µæ¡ˆä¾‹)
    - [7.1. è§‚å¯Ÿè€…æ¨¡å¼ - äº‹ä»¶é€šçŸ¥ç³»ç»Ÿ](#71-è§‚å¯Ÿè€…æ¨¡å¼---äº‹ä»¶é€šçŸ¥ç³»ç»Ÿ)
  - [8. ç­–ç•¥æ¨¡å¼ - æ’åºç®—æ³•é€‰æ‹©](#8-ç­–ç•¥æ¨¡å¼---æ’åºç®—æ³•é€‰æ‹©)
  - [9. æ¨¡å¼ç»„åˆåº”ç”¨æ¡ˆä¾‹](#9-æ¨¡å¼ç»„åˆåº”ç”¨æ¡ˆä¾‹)
    - [9.1. ç”µå•†ç³»ç»Ÿè®¾è®¡æ¨¡å¼ç»„åˆ](#91-ç”µå•†ç³»ç»Ÿè®¾è®¡æ¨¡å¼ç»„åˆ)
  - [10. æ€»ç»“](#10-æ€»ç»“)

## 3. åˆ›å»ºå‹æ¨¡å¼å®è·µæ¡ˆä¾‹

### 3.1. å·¥å‚æ¨¡å¼ - æ•°æ®åº“è¿æ¥å·¥å‚

```python
from abc import ABC, abstractmethod
import mysql.connector
import psycopg2
import sqlite3

class DatabaseConnection(ABC):
    @abstractmethod
    def connect(self):
        pass

    @abstractmethod
    def execute(self, query):
        pass

class MySQLConnection(DatabaseConnection):
    def __init__(self, host, port, database, username, password):
        self.host = host
        self.port = port
        self.database = database
        self.username = username
        self.password = password
        self.connection = None

    def connect(self):
        self.connection = mysql.connector.connect(
            host=self.host,
            port=self.port,
            database=self.database,
            user=self.username,
            password=self.password
        )
        return self.connection

    def execute(self, query):
        if not self.connection:
            self.connect()
        cursor = self.connection.cursor()
        cursor.execute(query)
        return cursor.fetchall()

class PostgreSQLConnection(DatabaseConnection):
    def __init__(self, host, port, database, username, password):
        self.host = host
        self.port = port
        self.database = database
        self.username = username
        self.password = password
        self.connection = None

    def connect(self):
        self.connection = psycopg2.connect(
            host=self.host,
            port=self.port,
            database=self.database,
            user=self.username,
            password=self.password
        )
        return self.connection

    def execute(self, query):
        if not self.connection:
            self.connect()
        cursor = self.connection.cursor()
        cursor.execute(query)
        return cursor.fetchall()

class DatabaseConnectionFactory:
    @staticmethod
    def create_connection(db_type, **kwargs):
        if db_type.lower() == 'mysql':
            return MySQLConnection(**kwargs)
        elif db_type.lower() == 'postgresql':
            return PostgreSQLConnection(**kwargs)
        elif db_type.lower() == 'sqlite':
            return SQLiteConnection(**kwargs)
        else:
            raise ValueError(f"ä¸æ”¯æŒçš„æ•°æ®åº“ç±»å‹: {db_type}")

# ä½¿ç”¨ç¤ºä¾‹
factory = DatabaseConnectionFactory()
mysql_conn = factory.create_connection(
    'mysql',
    host='localhost',
    port=3306,
    database='test',
    username='root',
    password='password'
)
```

## 4. å•ä¾‹æ¨¡å¼ - é…ç½®ç®¡ç†å™¨

```python
import json
import os
from typing import Dict, Any

class ConfigurationManager:
    _instance = None
    _config = {}

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

    def __init__(self):
        if not self._config:
            self._load_config()

    def _load_config(self):
        """åŠ è½½é…ç½®æ–‡ä»¶"""
        config_file = os.getenv('CONFIG_FILE', 'config.json')
        if os.path.exists(config_file):
            with open(config_file, 'r', encoding='utf-8') as f:
                self._config = json.load(f)
        else:
            self._config = {
                'database': {
                    'host': 'localhost',
                    'port': 3306,
                    'name': 'default'
                },
                'redis': {
                    'host': 'localhost',
                    'port': 6379
                },
                'logging': {
                    'level': 'INFO',
                    'file': 'app.log'
                }
            }

    def get(self, key: str, default=None) -> Any:
        """è·å–é…ç½®å€¼"""
        keys = key.split('.')
        value = self._config
        for k in keys:
            if isinstance(value, dict) and k in value:
                value = value[k]
            else:
                return default
        return value

    def set(self, key: str, value: Any):
        """è®¾ç½®é…ç½®å€¼"""
        keys = key.split('.')
        config = self._config
        for k in keys[:-1]:
            if k not in config:
                config[k] = {}
            config = config[k]
        config[keys[-1]] = value

    def save(self):
        """ä¿å­˜é…ç½®åˆ°æ–‡ä»¶"""
        config_file = os.getenv('CONFIG_FILE', 'config.json')
        with open(config_file, 'w', encoding='utf-8') as f:
            json.dump(self._config, f, indent=2, ensure_ascii=False)

# ä½¿ç”¨ç¤ºä¾‹
config1 = ConfigurationManager()
config2 = ConfigurationManager()
print(config1 is config2)  # True

config1.set('database.host', '192.168.1.100')
print(config2.get('database.host'))  # 192.168.1.100
```

## 5. ç»“æ„å‹æ¨¡å¼å®è·µæ¡ˆä¾‹

### 5.1. é€‚é…å™¨æ¨¡å¼ - æ”¯ä»˜ç³»ç»Ÿé€‚é…

```python
from abc import ABC, abstractmethod
from typing import Dict, Any

class PaymentProcessor(ABC):
    @abstractmethod
    def process_payment(self, amount: float, currency: str, **kwargs) -> Dict[str, Any]:
        pass

class StripePaymentProcessor:
    def __init__(self, api_key: str):
        self.api_key = api_key

    def charge(self, amount: float, currency: str, token: str) -> Dict[str, Any]:
# æ¨¡æ‹ŸStripe APIè°ƒç”¨
        return {
            'success': True,
            'transaction_id': f'stripe_{hash(token)}',
            'amount': amount,
            'currency': currency
        }

class PayPalPaymentProcessor:
    def __init__(self, client_id: str, client_secret: str):
        self.client_id = client_id
        self.client_secret = client_secret

    def make_payment(self, amount: float, currency: str, payer_id: str) -> Dict[str, Any]:
# æ¨¡æ‹ŸPayPal APIè°ƒç”¨
        return {
            'success': True,
            'payment_id': f'paypal_{hash(payer_id)}',
            'amount': amount,
            'currency': currency
        }

class StripeAdapter(PaymentProcessor):
    def __init__(self, stripe_processor: StripePaymentProcessor):
        self.stripe_processor = stripe_processor

    def process_payment(self, amount: float, currency: str, **kwargs) -> Dict[str, Any]:
        token = kwargs.get('token')
        if not token:
            raise ValueError("Stripeæ”¯ä»˜éœ€è¦tokenå‚æ•°")

        result = self.stripe_processor.charge(amount, currency, token)
        return {
            'success': result['success'],
            'transaction_id': result['transaction_id'],
            'amount': result['amount'],
            'currency': result['currency'],
            'provider': 'stripe'
        }

class PayPalAdapter(PaymentProcessor):
    def __init__(self, paypal_processor: PayPalPaymentProcessor):
        self.paypal_processor = paypal_processor

    def process_payment(self, amount: float, currency: str, **kwargs) -> Dict[str, Any]:
        payer_id = kwargs.get('payer_id')
        if not payer_id:
            raise ValueError("PayPalæ”¯ä»˜éœ€è¦payer_idå‚æ•°")

        result = self.paypal_processor.make_payment(amount, currency, payer_id)
        return {
            'success': result['success'],
            'transaction_id': result['payment_id'],
            'amount': result['amount'],
            'currency': result['currency'],
            'provider': 'paypal'
        }

# ä½¿ç”¨ç¤ºä¾‹
class PaymentService:
    def __init__(self):
        self.stripe = StripeAdapter(StripePaymentProcessor('sk_test_123'))
        self.paypal = PayPalAdapter(PayPalPaymentProcessor('client_id', 'secret'))

    def process_payment(self, provider: str, amount: float, currency: str, **kwargs):
        if provider == 'stripe':
            return self.stripe.process_payment(amount, currency, **kwargs)
        elif provider == 'paypal':
            return self.paypal.process_payment(amount, currency, **kwargs)
        else:
            raise ValueError(f"ä¸æ”¯æŒçš„æ”¯ä»˜æä¾›å•†: {provider}")

# ä½¿ç”¨
payment_service = PaymentService()
result1 = payment_service.process_payment('stripe', 100.0, 'USD', token='tok_123')
result2 = payment_service.process_payment('paypal', 100.0, 'USD', payer_id='payer_456')
```

## 6. è£…é¥°å™¨æ¨¡å¼ - æ—¥å¿—å’Œç¼“å­˜è£…é¥°å™¨

```python
import time
import functools
import json
from typing import Any, Callable
import redis

class Logger:
    def __init__(self, name: str):
        self.name = name

    def info(self, message: str):
        print(f"[INFO] {self.name}: {message}")

    def error(self, message: str):
        print(f"[ERROR] {self.name}: {message}")

def log_execution_time(func: Callable) -> Callable:
    """è®°å½•å‡½æ•°æ‰§è¡Œæ—¶é—´çš„è£…é¥°å™¨"""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        logger = Logger(func.__name__)
        start_time = time.time()

        try:
            result = func(*args, **kwargs)
            execution_time = time.time() - start_time
            logger.info(f"æ‰§è¡ŒæˆåŠŸï¼Œè€—æ—¶: {execution_time:.4f}ç§’")
            return result
        except Exception as e:
            execution_time = time.time() - start_time
            logger.error(f"æ‰§è¡Œå¤±è´¥ï¼Œè€—æ—¶: {execution_time:.4f}ç§’ï¼Œé”™è¯¯: {str(e)}")
            raise

    return wrapper

def cache_result(ttl: int = 3600):
    """ç¼“å­˜å‡½æ•°ç»“æœçš„è£…é¥°å™¨"""
    def decorator(func: Callable) -> Callable:
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
# ç”Ÿæˆç¼“å­˜é”®
            cache_key = f"{func.__name__}:{hash(str(args) + str(sorted(kwargs.items())))}"

# å°è¯•ä»ç¼“å­˜è·å–
            try:
                redis_client = redis.Redis(host='localhost', port=6379, db=0)
                cached_result = redis_client.get(cache_key)
                if cached_result:
                    return json.loads(cached_result)
            except:
                pass

# æ‰§è¡Œå‡½æ•°å¹¶ç¼“å­˜ç»“æœ
            result = func(*args, **kwargs)
            try:
                redis_client.setex(cache_key, ttl, json.dumps(result))
            except:
                pass

            return result
        return wrapper
    return decorator

def retry_on_failure(max_retries: int = 3, delay: float = 1.0):
    """å¤±è´¥é‡è¯•è£…é¥°å™¨"""
    def decorator(func: Callable) -> Callable:
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            logger = Logger(func.__name__)

            for attempt in range(max_retries):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    if attempt == max_retries - 1:
                        logger.error(f"æœ€ç»ˆå¤±è´¥: {str(e)}")
                        raise
                    else:
                        logger.info(f"ç¬¬{attempt + 1}æ¬¡å°è¯•å¤±è´¥ï¼Œ{delay}ç§’åé‡è¯•: {str(e)}")
                        time.sleep(delay)

        return wrapper
    return decorator

# ä½¿ç”¨ç¤ºä¾‹
@log_execution_time
@cache_result(ttl=1800)
@retry_on_failure(max_retries=3, delay=1.0)
def fetch_user_data(user_id: int) -> dict:
    """è·å–ç”¨æˆ·æ•°æ®ï¼ˆæ¨¡æ‹Ÿç½‘ç»œè¯·æ±‚ï¼‰"""
    import random
    if random.random() < 0.3:  # 30%æ¦‚ç‡å¤±è´¥
        raise Exception("ç½‘ç»œè¯·æ±‚å¤±è´¥")

    time.sleep(0.5)  # æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
    return {
        'user_id': user_id,
        'name': f'User_{user_id}',
        'email': f'user{user_id}@example.com',
        'created_at': '2024-01-01T00:00:00Z'
    }

# æµ‹è¯•
try:
    result = fetch_user_data(123)
    print(f"è·å–ç»“æœ: {result}")
except Exception as e:
    print(f"æœ€ç»ˆé”™è¯¯: {e}")
```

## 7. è¡Œä¸ºå‹æ¨¡å¼å®è·µæ¡ˆä¾‹

### 7.1. è§‚å¯Ÿè€…æ¨¡å¼ - äº‹ä»¶é€šçŸ¥ç³»ç»Ÿ

```python
from abc import ABC, abstractmethod
from typing import List, Dict, Any
from datetime import datetime

class EventObserver(ABC):
    @abstractmethod
    def update(self, event_type: str, data: Dict[str, Any]):
        pass

class EmailNotifier(EventObserver):
    def __init__(self, email_service):
        self.email_service = email_service

    def update(self, event_type: str, data: Dict[str, Any]):
        if event_type == 'order_created':
            self._send_order_confirmation(data)
        elif event_type == 'payment_failed':
            self._send_payment_failure_notification(data)

    def _send_order_confirmation(self, data: Dict[str, Any]):
        subject = f"è®¢å•ç¡®è®¤ - è®¢å•å·: {data['order_id']}"
        body = f"""
        å°Šæ•¬çš„ {data['customer_name']}ï¼Œ

        æ‚¨çš„è®¢å•å·²æˆåŠŸåˆ›å»ºï¼
        è®¢å•å·: {data['order_id']}
        æ€»é‡‘é¢: {data['total_amount']}
        é¢„è®¡å‘è´§æ—¶é—´: {data['estimated_shipping_date']}

        æ„Ÿè°¢æ‚¨çš„è´­ä¹°ï¼
        """
        self.email_service.send_email(data['customer_email'], subject, body)

    def _send_payment_failure_notification(self, data: Dict[str, Any]):
        subject = "æ”¯ä»˜å¤±è´¥é€šçŸ¥"
        body = f"""
        å°Šæ•¬çš„ {data['customer_name']}ï¼Œ

        å¾ˆæŠ±æ­‰ï¼Œæ‚¨çš„è®¢å•æ”¯ä»˜å¤±è´¥äº†ã€‚
        è®¢å•å·: {data['order_id']}
        å¤±è´¥åŸå› : {data['failure_reason']}

        è¯·é‡æ–°å°è¯•æ”¯ä»˜æˆ–è”ç³»å®¢æœã€‚
        """
        self.email_service.send_email(data['customer_email'], subject, body)

class SMSNotifier(EventObserver):
    def __init__(self, sms_service):
        self.sms_service = sms_service

    def update(self, event_type: str, data: Dict[str, Any]):
        if event_type == 'order_shipped':
            message = f"æ‚¨çš„è®¢å• {data['order_id']} å·²å‘è´§ï¼Œè·Ÿè¸ªå·: {data['tracking_number']}"
            self.sms_service.send_sms(data['customer_phone'], message)

class EventManager:
    def __init__(self):
        self._observers: Dict[str, List[EventObserver]] = {}

    def subscribe(self, event_type: str, observer: EventObserver):
        """è®¢é˜…äº‹ä»¶"""
        if event_type not in self._observers:
            self._observers[event_type] = []
        self._observers[event_type].append(observer)

    def unsubscribe(self, event_type: str, observer: EventObserver):
        """å–æ¶ˆè®¢é˜…"""
        if event_type in self._observers:
            self._observers[event_type].remove(observer)

    def notify(self, event_type: str, data: Dict[str, Any]):
        """é€šçŸ¥æ‰€æœ‰è§‚å¯Ÿè€…"""
        if event_type in self._observers:
            for observer in self._observers[event_type]:
                observer.update(event_type, data)

# ä½¿ç”¨ç¤ºä¾‹
class OrderService:
    def __init__(self, event_manager: EventManager):
        self.event_manager = event_manager

    def create_order(self, customer_data: Dict[str, Any], items: List[Dict[str, Any]]) -> str:
# åˆ›å»ºè®¢å•é€»è¾‘
        order_id = f"ORD_{int(datetime.now().timestamp())}"
        total_amount = sum(item['price'] * item['quantity'] for item in items)

# å‘å¸ƒè®¢å•åˆ›å»ºäº‹ä»¶
        self.event_manager.notify('order_created', {
            'order_id': order_id,
            'customer_name': customer_data['name'],
            'customer_email': customer_data['email'],
            'total_amount': total_amount,
            'estimated_shipping_date': '2024-01-15'
        })

        return order_id

    def process_payment(self, order_id: str, payment_data: Dict[str, Any]) -> bool:
# æ”¯ä»˜å¤„ç†é€»è¾‘
        payment_success = self._process_payment_logic(payment_data)

        if payment_success:
            self.event_manager.notify('payment_success', {
                'order_id': order_id,
                'payment_method': payment_data['method']
            })
        else:
            self.event_manager.notify('payment_failed', {
                'order_id': order_id,
                'failure_reason': 'ä¿¡ç”¨å¡ä½™é¢ä¸è¶³'
            })

        return payment_success

    def _process_payment_logic(self, payment_data: Dict[str, Any]) -> bool:
# æ¨¡æ‹Ÿæ”¯ä»˜å¤„ç†
        import random
        return random.random() > 0.2  # 80%æˆåŠŸç‡

# ä½¿ç”¨
event_manager = EventManager()
email_notifier = EmailNotifier(EmailService())
sms_notifier = SMSNotifier(SMSService())

event_manager.subscribe('order_created', email_notifier)
event_manager.subscribe('payment_failed', email_notifier)
event_manager.subscribe('order_shipped', sms_notifier)

order_service = OrderService(event_manager)
order_id = order_service.create_order({
    'name': 'å¼ ä¸‰',
    'email': 'zhangsan@example.com',
    'phone': '13800138000'
}, [
    {'name': 'å•†å“1', 'price': 100, 'quantity': 2},
    {'name': 'å•†å“2', 'price': 50, 'quantity': 1}
])
```

## 8. ç­–ç•¥æ¨¡å¼ - æ’åºç®—æ³•é€‰æ‹©

```python
from abc import ABC, abstractmethod
from typing import List, TypeVar, Generic

T = TypeVar('T')

class SortStrategy(ABC, Generic[T]):
    @abstractmethod
    def sort(self, data: List[T]) -> List[T]:
        pass

class BubbleSortStrategy(SortStrategy[T]):
    def sort(self, data: List[T]) -> List[T]:
        """å†’æ³¡æ’åº"""
        result = data.copy()
        n = len(result)
        for i in range(n):
            for j in range(0, n - i - 1):
                if result[j] > result[j + 1]:
                    result[j], result[j + 1] = result[j + 1], result[j]
        return result

class QuickSortStrategy(SortStrategy[T]):
    def sort(self, data: List[T]) -> List[T]:
        """å¿«é€Ÿæ’åº"""
        if len(data) <= 1:
            return data

        pivot = data[len(data) // 2]
        left = [x for x in data if x < pivot]
        middle = [x for x in data if x == pivot]
        right = [x for x in data if x > pivot]

        return self.sort(left) + middle + self.sort(right)

class MergeSortStrategy(SortStrategy[T]):
    def sort(self, data: List[T]) -> List[T]:
        """å½’å¹¶æ’åº"""
        if len(data) <= 1:
            return data

        mid = len(data) // 2
        left = self.sort(data[:mid])
        right = self.sort(data[mid:])

        return self._merge(left, right)

    def _merge(self, left: List[T], right: List[T]) -> List[T]:
        result = []
        i = j = 0

        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                result.append(left[i])
                i += 1
            else:
                result.append(right[j])
                j += 1

        result.extend(left[i:])
        result.extend(right[j:])
        return result

class Sorter:
    def __init__(self, strategy: SortStrategy[T] = None):
        self.strategy = strategy or QuickSortStrategy()

    def set_strategy(self, strategy: SortStrategy[T]):
        """è®¾ç½®æ’åºç­–ç•¥"""
        self.strategy = strategy

    def sort(self, data: List[T]) -> List[T]:
        """æ‰§è¡Œæ’åº"""
        return self.strategy.sort(data)

# ä½¿ç”¨ç¤ºä¾‹
def benchmark_sort(data: List[int], strategy: SortStrategy, name: str):
    """æ€§èƒ½æµ‹è¯•"""
    import time
    sorter = Sorter(strategy)

    start_time = time.time()
    result = sorter.sort(data)
    end_time = time.time()

    print(f"{name}: è€—æ—¶ {end_time - start_time:.6f}ç§’")
    return result

# æµ‹è¯•ä¸åŒæ’åºç®—æ³•
test_data = [64, 34, 25, 12, 22, 11, 90, 88, 76, 54, 43, 32, 21, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]

print("æ’åºç®—æ³•æ€§èƒ½æ¯”è¾ƒ:")
bubble_result = benchmark_sort(test_data.copy(), BubbleSortStrategy(), "å†’æ³¡æ’åº")
quick_result = benchmark_sort(test_data.copy(), QuickSortStrategy(), "å¿«é€Ÿæ’åº")
merge_result = benchmark_sort(test_data.copy(), MergeSortStrategy(), "å½’å¹¶æ’åº")

print(f"\næ’åºç»“æœéªŒè¯:")
print(f"å†’æ³¡æ’åº: {bubble_result[:5]}...")
print(f"å¿«é€Ÿæ’åº: {quick_result[:5]}...")
print(f"å½’å¹¶æ’åº: {merge_result[:5]}...")
```

## 9. æ¨¡å¼ç»„åˆåº”ç”¨æ¡ˆä¾‹

### 9.1. ç”µå•†ç³»ç»Ÿè®¾è®¡æ¨¡å¼ç»„åˆ

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Any
import json
import time

# å·¥å‚æ¨¡å¼ + ç­–ç•¥æ¨¡å¼
class PaymentMethod(ABC):
    @abstractmethod
    def process(self, amount: float) -> Dict[str, Any]:
        pass

class CreditCardPayment(PaymentMethod):
    def process(self, amount: float) -> Dict[str, Any]:
        return {'method': 'credit_card', 'amount': amount, 'status': 'success'}

class PayPalPayment(PaymentMethod):
    def process(self, amount: float) -> Dict[str, Any]:
        return {'method': 'paypal', 'amount': amount, 'status': 'success'}

class PaymentFactory:
    @staticmethod
    def create_payment(method: str) -> PaymentMethod:
        if method == 'credit_card':
            return CreditCardPayment()
        elif method == 'paypal':
            return PayPalPayment()
        else:
            raise ValueError(f"ä¸æ”¯æŒçš„æ”¯ä»˜æ–¹å¼: {method}")

# å•ä¾‹æ¨¡å¼ + è§‚å¯Ÿè€…æ¨¡å¼
class OrderEventManager:
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance.observers = []
        return cls._instance

    def add_observer(self, observer):
        self.observers.append(observer)

    def notify(self, event_type: str, data: Dict[str, Any]):
        for observer in self.observers:
            observer.update(event_type, data)

# è£…é¥°å™¨æ¨¡å¼
def log_operation(func):
    def wrapper(*args, **kwargs):
        print(f"æ‰§è¡Œæ“ä½œ: {func.__name__}")
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"æ“ä½œå®Œæˆï¼Œè€—æ—¶: {end_time - start_time:.4f}ç§’")
        return result
    return wrapper

# ç»„åˆä½¿ç”¨
class OrderService:
    def __init__(self):
        self.event_manager = OrderEventManager()
        self.payment_factory = PaymentFactory()

    @log_operation
    def create_order(self, items: List[Dict[str, Any]], payment_method: str) -> Dict[str, Any]:
# è®¡ç®—æ€»é‡‘é¢
        total_amount = sum(item['price'] * item['quantity'] for item in items)

# ä½¿ç”¨å·¥å‚æ¨¡å¼åˆ›å»ºæ”¯ä»˜æ–¹å¼
        payment = self.payment_factory.create_payment(payment_method)
        payment_result = payment.process(total_amount)

# åˆ›å»ºè®¢å•
        order = {
            'order_id': f"ORD_{int(time.time())}",
            'items': items,
            'total_amount': total_amount,
            'payment_result': payment_result,
            'status': 'created'
        }

# ä½¿ç”¨è§‚å¯Ÿè€…æ¨¡å¼é€šçŸ¥äº‹ä»¶
        self.event_manager.notify('order_created', order)

        return order

# ä½¿ç”¨ç¤ºä¾‹
class EmailNotifier:
    def update(self, event_type: str, data: Dict[str, Any]):
        if event_type == 'order_created':
            print(f"å‘é€é‚®ä»¶é€šçŸ¥: è®¢å• {data['order_id']} å·²åˆ›å»º")

class SMSNotifier:
    def update(self, event_type: str, data: Dict[str, Any]):
        if event_type == 'order_created':
            print(f"å‘é€çŸ­ä¿¡é€šçŸ¥: è®¢å• {data['order_id']} å·²åˆ›å»º")

# ç»„åˆä½¿ç”¨æ‰€æœ‰æ¨¡å¼
order_service = OrderService()
order_service.event_manager.add_observer(EmailNotifier())
order_service.event_manager.add_observer(SMSNotifier())

# åˆ›å»ºè®¢å•
order = order_service.create_order([
    {'name': 'å•†å“1', 'price': 100, 'quantity': 2},
    {'name': 'å•†å“2', 'price': 50, 'quantity': 1}
], 'credit_card')

print(f"è®¢å•åˆ›å»ºæˆåŠŸ: {order['order_id']}")
```

## 10. æ€»ç»“

è¿™äº›å®è·µæ¡ˆä¾‹å±•ç¤ºäº†è®¾è®¡æ¨¡å¼åœ¨å®é™…é¡¹ç›®ä¸­çš„åº”ç”¨ï¼ŒåŒ…æ‹¬ï¼š

1. **åˆ›å»ºå‹æ¨¡å¼**ï¼šå·¥å‚æ¨¡å¼ã€å•ä¾‹æ¨¡å¼
2. **ç»“æ„å‹æ¨¡å¼**ï¼šé€‚é…å™¨æ¨¡å¼ã€è£…é¥°å™¨æ¨¡å¼
3. **è¡Œä¸ºå‹æ¨¡å¼**ï¼šè§‚å¯Ÿè€…æ¨¡å¼ã€ç­–ç•¥æ¨¡å¼
4. **æ¨¡å¼ç»„åˆ**ï¼šå¤šç§æ¨¡å¼ååŒå·¥ä½œ

æ¯ä¸ªæ¡ˆä¾‹éƒ½æä¾›äº†å®Œæ•´çš„ä»£ç ç¤ºä¾‹å’Œå®é™…åº”ç”¨åœºæ™¯ï¼Œå¯ä»¥ç›´æ¥åº”ç”¨äºå®é™…é¡¹ç›®ä¸­ã€‚

**ç›¸å…³é“¾æ¥ï¼š**

- [4.2.1-è®¾è®¡æ¨¡å¼åŸºç¡€ç†è®º](4.2.1-è®¾è®¡æ¨¡å¼åŸºç¡€ç†è®º.md)
- [4.1.16-è½¯ä»¶æ¶æ„å®è·µæ¡ˆä¾‹](../4.1-æ¶æ„è®¾è®¡/4.1.16-è½¯ä»¶æ¶æ„å®è·µæ¡ˆä¾‹.md)
- [4.3.1-å¾®æœåŠ¡æ¶æ„åŸºç¡€ç†è®º](../4.3-å¾®æœåŠ¡æ¶æ„/4.3.1-å¾®æœåŠ¡æ¶æ„åŸºç¡€ç†è®º.md)
