# 4.2.2 设计模式实践案例

## 概述

本文档提供常用设计模式的实际应用案例，涵盖创建型、结构型和行为型设计模式。每个案例都包含完整的代码示例和实际应用场景。

## 目录

- [1. 创建型模式实践案例](#1-创建型模式实践案例)
- [2. 结构型模式实践案例](#2-结构型模式实践案例)
- [3. 行为型模式实践案例](#3-行为型模式实践案例)
- [4. 模式组合应用案例](#4-模式组合应用案例)

## 1. 创建型模式实践案例

### 1.1 工厂模式 - 数据库连接工厂

```python
from abc import ABC, abstractmethod
import mysql.connector
import psycopg2
import sqlite3

class DatabaseConnection(ABC):
    @abstractmethod
    def connect(self):
        pass
    
    @abstractmethod
    def execute(self, query):
        pass

class MySQLConnection(DatabaseConnection):
    def __init__(self, host, port, database, username, password):
        self.host = host
        self.port = port
        self.database = database
        self.username = username
        self.password = password
        self.connection = None
    
    def connect(self):
        self.connection = mysql.connector.connect(
            host=self.host,
            port=self.port,
            database=self.database,
            user=self.username,
            password=self.password
        )
        return self.connection
    
    def execute(self, query):
        if not self.connection:
            self.connect()
        cursor = self.connection.cursor()
        cursor.execute(query)
        return cursor.fetchall()

class PostgreSQLConnection(DatabaseConnection):
    def __init__(self, host, port, database, username, password):
        self.host = host
        self.port = port
        self.database = database
        self.username = username
        self.password = password
        self.connection = None
    
    def connect(self):
        self.connection = psycopg2.connect(
            host=self.host,
            port=self.port,
            database=self.database,
            user=self.username,
            password=self.password
        )
        return self.connection
    
    def execute(self, query):
        if not self.connection:
            self.connect()
        cursor = self.connection.cursor()
        cursor.execute(query)
        return cursor.fetchall()

class DatabaseConnectionFactory:
    @staticmethod
    def create_connection(db_type, **kwargs):
        if db_type.lower() == 'mysql':
            return MySQLConnection(**kwargs)
        elif db_type.lower() == 'postgresql':
            return PostgreSQLConnection(**kwargs)
        elif db_type.lower() == 'sqlite':
            return SQLiteConnection(**kwargs)
        else:
            raise ValueError(f"不支持的数据库类型: {db_type}")

# 使用示例
factory = DatabaseConnectionFactory()
mysql_conn = factory.create_connection(
    'mysql',
    host='localhost',
    port=3306,
    database='test',
    username='root',
    password='password'
)
```

### 1.2 单例模式 - 配置管理器

```python
import json
import os
from typing import Dict, Any

class ConfigurationManager:
    _instance = None
    _config = {}
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        if not self._config:
            self._load_config()
    
    def _load_config(self):
        """加载配置文件"""
        config_file = os.getenv('CONFIG_FILE', 'config.json')
        if os.path.exists(config_file):
            with open(config_file, 'r', encoding='utf-8') as f:
                self._config = json.load(f)
        else:
            self._config = {
                'database': {
                    'host': 'localhost',
                    'port': 3306,
                    'name': 'default'
                },
                'redis': {
                    'host': 'localhost',
                    'port': 6379
                },
                'logging': {
                    'level': 'INFO',
                    'file': 'app.log'
                }
            }
    
    def get(self, key: str, default=None) -> Any:
        """获取配置值"""
        keys = key.split('.')
        value = self._config
        for k in keys:
            if isinstance(value, dict) and k in value:
                value = value[k]
            else:
                return default
        return value
    
    def set(self, key: str, value: Any):
        """设置配置值"""
        keys = key.split('.')
        config = self._config
        for k in keys[:-1]:
            if k not in config:
                config[k] = {}
            config = config[k]
        config[keys[-1]] = value
    
    def save(self):
        """保存配置到文件"""
        config_file = os.getenv('CONFIG_FILE', 'config.json')
        with open(config_file, 'w', encoding='utf-8') as f:
            json.dump(self._config, f, indent=2, ensure_ascii=False)

# 使用示例
config1 = ConfigurationManager()
config2 = ConfigurationManager()
print(config1 is config2)  # True

config1.set('database.host', '192.168.1.100')
print(config2.get('database.host'))  # 192.168.1.100
```

## 2. 结构型模式实践案例

### 2.1 适配器模式 - 支付系统适配

```python
from abc import ABC, abstractmethod
from typing import Dict, Any

class PaymentProcessor(ABC):
    @abstractmethod
    def process_payment(self, amount: float, currency: str, **kwargs) -> Dict[str, Any]:
        pass

class StripePaymentProcessor:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    def charge(self, amount: float, currency: str, token: str) -> Dict[str, Any]:
        # 模拟Stripe API调用
        return {
            'success': True,
            'transaction_id': f'stripe_{hash(token)}',
            'amount': amount,
            'currency': currency
        }

class PayPalPaymentProcessor:
    def __init__(self, client_id: str, client_secret: str):
        self.client_id = client_id
        self.client_secret = client_secret
    
    def make_payment(self, amount: float, currency: str, payer_id: str) -> Dict[str, Any]:
        # 模拟PayPal API调用
        return {
            'success': True,
            'payment_id': f'paypal_{hash(payer_id)}',
            'amount': amount,
            'currency': currency
        }

class StripeAdapter(PaymentProcessor):
    def __init__(self, stripe_processor: StripePaymentProcessor):
        self.stripe_processor = stripe_processor
    
    def process_payment(self, amount: float, currency: str, **kwargs) -> Dict[str, Any]:
        token = kwargs.get('token')
        if not token:
            raise ValueError("Stripe支付需要token参数")
        
        result = self.stripe_processor.charge(amount, currency, token)
        return {
            'success': result['success'],
            'transaction_id': result['transaction_id'],
            'amount': result['amount'],
            'currency': result['currency'],
            'provider': 'stripe'
        }

class PayPalAdapter(PaymentProcessor):
    def __init__(self, paypal_processor: PayPalPaymentProcessor):
        self.paypal_processor = paypal_processor
    
    def process_payment(self, amount: float, currency: str, **kwargs) -> Dict[str, Any]:
        payer_id = kwargs.get('payer_id')
        if not payer_id:
            raise ValueError("PayPal支付需要payer_id参数")
        
        result = self.paypal_processor.make_payment(amount, currency, payer_id)
        return {
            'success': result['success'],
            'transaction_id': result['payment_id'],
            'amount': result['amount'],
            'currency': result['currency'],
            'provider': 'paypal'
        }

# 使用示例
class PaymentService:
    def __init__(self):
        self.stripe = StripeAdapter(StripePaymentProcessor('sk_test_123'))
        self.paypal = PayPalAdapter(PayPalPaymentProcessor('client_id', 'secret'))
    
    def process_payment(self, provider: str, amount: float, currency: str, **kwargs):
        if provider == 'stripe':
            return self.stripe.process_payment(amount, currency, **kwargs)
        elif provider == 'paypal':
            return self.paypal.process_payment(amount, currency, **kwargs)
        else:
            raise ValueError(f"不支持的支付提供商: {provider}")

# 使用
payment_service = PaymentService()
result1 = payment_service.process_payment('stripe', 100.0, 'USD', token='tok_123')
result2 = payment_service.process_payment('paypal', 100.0, 'USD', payer_id='payer_456')
```

### 2.2 装饰器模式 - 日志和缓存装饰器

```python
import time
import functools
import json
from typing import Any, Callable
import redis

class Logger:
    def __init__(self, name: str):
        self.name = name
    
    def info(self, message: str):
        print(f"[INFO] {self.name}: {message}")
    
    def error(self, message: str):
        print(f"[ERROR] {self.name}: {message}")

def log_execution_time(func: Callable) -> Callable:
    """记录函数执行时间的装饰器"""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        logger = Logger(func.__name__)
        start_time = time.time()
        
        try:
            result = func(*args, **kwargs)
            execution_time = time.time() - start_time
            logger.info(f"执行成功，耗时: {execution_time:.4f}秒")
            return result
        except Exception as e:
            execution_time = time.time() - start_time
            logger.error(f"执行失败，耗时: {execution_time:.4f}秒，错误: {str(e)}")
            raise
    
    return wrapper

def cache_result(ttl: int = 3600):
    """缓存函数结果的装饰器"""
    def decorator(func: Callable) -> Callable:
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # 生成缓存键
            cache_key = f"{func.__name__}:{hash(str(args) + str(sorted(kwargs.items())))}"
            
            # 尝试从缓存获取
            try:
                redis_client = redis.Redis(host='localhost', port=6379, db=0)
                cached_result = redis_client.get(cache_key)
                if cached_result:
                    return json.loads(cached_result)
            except:
                pass
            
            # 执行函数并缓存结果
            result = func(*args, **kwargs)
            try:
                redis_client.setex(cache_key, ttl, json.dumps(result))
            except:
                pass
            
            return result
        return wrapper
    return decorator

def retry_on_failure(max_retries: int = 3, delay: float = 1.0):
    """失败重试装饰器"""
    def decorator(func: Callable) -> Callable:
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            logger = Logger(func.__name__)
            
            for attempt in range(max_retries):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    if attempt == max_retries - 1:
                        logger.error(f"最终失败: {str(e)}")
                        raise
                    else:
                        logger.info(f"第{attempt + 1}次尝试失败，{delay}秒后重试: {str(e)}")
                        time.sleep(delay)
            
        return wrapper
    return decorator

# 使用示例
@log_execution_time
@cache_result(ttl=1800)
@retry_on_failure(max_retries=3, delay=1.0)
def fetch_user_data(user_id: int) -> dict:
    """获取用户数据（模拟网络请求）"""
    import random
    if random.random() < 0.3:  # 30%概率失败
        raise Exception("网络请求失败")
    
    time.sleep(0.5)  # 模拟网络延迟
    return {
        'user_id': user_id,
        'name': f'User_{user_id}',
        'email': f'user{user_id}@example.com',
        'created_at': '2024-01-01T00:00:00Z'
    }

# 测试
try:
    result = fetch_user_data(123)
    print(f"获取结果: {result}")
except Exception as e:
    print(f"最终错误: {e}")
```

## 3. 行为型模式实践案例

### 3.1 观察者模式 - 事件通知系统

```python
from abc import ABC, abstractmethod
from typing import List, Dict, Any
from datetime import datetime

class EventObserver(ABC):
    @abstractmethod
    def update(self, event_type: str, data: Dict[str, Any]):
        pass

class EmailNotifier(EventObserver):
    def __init__(self, email_service):
        self.email_service = email_service
    
    def update(self, event_type: str, data: Dict[str, Any]):
        if event_type == 'order_created':
            self._send_order_confirmation(data)
        elif event_type == 'payment_failed':
            self._send_payment_failure_notification(data)
    
    def _send_order_confirmation(self, data: Dict[str, Any]):
        subject = f"订单确认 - 订单号: {data['order_id']}"
        body = f"""
        尊敬的 {data['customer_name']}，
        
        您的订单已成功创建！
        订单号: {data['order_id']}
        总金额: {data['total_amount']}
        预计发货时间: {data['estimated_shipping_date']}
        
        感谢您的购买！
        """
        self.email_service.send_email(data['customer_email'], subject, body)
    
    def _send_payment_failure_notification(self, data: Dict[str, Any]):
        subject = "支付失败通知"
        body = f"""
        尊敬的 {data['customer_name']}，
        
        很抱歉，您的订单支付失败了。
        订单号: {data['order_id']}
        失败原因: {data['failure_reason']}
        
        请重新尝试支付或联系客服。
        """
        self.email_service.send_email(data['customer_email'], subject, body)

class SMSNotifier(EventObserver):
    def __init__(self, sms_service):
        self.sms_service = sms_service
    
    def update(self, event_type: str, data: Dict[str, Any]):
        if event_type == 'order_shipped':
            message = f"您的订单 {data['order_id']} 已发货，跟踪号: {data['tracking_number']}"
            self.sms_service.send_sms(data['customer_phone'], message)

class EventManager:
    def __init__(self):
        self._observers: Dict[str, List[EventObserver]] = {}
    
    def subscribe(self, event_type: str, observer: EventObserver):
        """订阅事件"""
        if event_type not in self._observers:
            self._observers[event_type] = []
        self._observers[event_type].append(observer)
    
    def unsubscribe(self, event_type: str, observer: EventObserver):
        """取消订阅"""
        if event_type in self._observers:
            self._observers[event_type].remove(observer)
    
    def notify(self, event_type: str, data: Dict[str, Any]):
        """通知所有观察者"""
        if event_type in self._observers:
            for observer in self._observers[event_type]:
                observer.update(event_type, data)

# 使用示例
class OrderService:
    def __init__(self, event_manager: EventManager):
        self.event_manager = event_manager
    
    def create_order(self, customer_data: Dict[str, Any], items: List[Dict[str, Any]]) -> str:
        # 创建订单逻辑
        order_id = f"ORD_{int(datetime.now().timestamp())}"
        total_amount = sum(item['price'] * item['quantity'] for item in items)
        
        # 发布订单创建事件
        self.event_manager.notify('order_created', {
            'order_id': order_id,
            'customer_name': customer_data['name'],
            'customer_email': customer_data['email'],
            'total_amount': total_amount,
            'estimated_shipping_date': '2024-01-15'
        })
        
        return order_id
    
    def process_payment(self, order_id: str, payment_data: Dict[str, Any]) -> bool:
        # 支付处理逻辑
        payment_success = self._process_payment_logic(payment_data)
        
        if payment_success:
            self.event_manager.notify('payment_success', {
                'order_id': order_id,
                'payment_method': payment_data['method']
            })
        else:
            self.event_manager.notify('payment_failed', {
                'order_id': order_id,
                'failure_reason': '信用卡余额不足'
            })
        
        return payment_success
    
    def _process_payment_logic(self, payment_data: Dict[str, Any]) -> bool:
        # 模拟支付处理
        import random
        return random.random() > 0.2  # 80%成功率

# 使用
event_manager = EventManager()
email_notifier = EmailNotifier(EmailService())
sms_notifier = SMSNotifier(SMSService())

event_manager.subscribe('order_created', email_notifier)
event_manager.subscribe('payment_failed', email_notifier)
event_manager.subscribe('order_shipped', sms_notifier)

order_service = OrderService(event_manager)
order_id = order_service.create_order({
    'name': '张三',
    'email': 'zhangsan@example.com',
    'phone': '13800138000'
}, [
    {'name': '商品1', 'price': 100, 'quantity': 2},
    {'name': '商品2', 'price': 50, 'quantity': 1}
])
```

### 3.2 策略模式 - 排序算法选择

```python
from abc import ABC, abstractmethod
from typing import List, TypeVar, Generic

T = TypeVar('T')

class SortStrategy(ABC, Generic[T]):
    @abstractmethod
    def sort(self, data: List[T]) -> List[T]:
        pass

class BubbleSortStrategy(SortStrategy[T]):
    def sort(self, data: List[T]) -> List[T]:
        """冒泡排序"""
        result = data.copy()
        n = len(result)
        for i in range(n):
            for j in range(0, n - i - 1):
                if result[j] > result[j + 1]:
                    result[j], result[j + 1] = result[j + 1], result[j]
        return result

class QuickSortStrategy(SortStrategy[T]):
    def sort(self, data: List[T]) -> List[T]:
        """快速排序"""
        if len(data) <= 1:
            return data
        
        pivot = data[len(data) // 2]
        left = [x for x in data if x < pivot]
        middle = [x for x in data if x == pivot]
        right = [x for x in data if x > pivot]
        
        return self.sort(left) + middle + self.sort(right)

class MergeSortStrategy(SortStrategy[T]):
    def sort(self, data: List[T]) -> List[T]:
        """归并排序"""
        if len(data) <= 1:
            return data
        
        mid = len(data) // 2
        left = self.sort(data[:mid])
        right = self.sort(data[mid:])
        
        return self._merge(left, right)
    
    def _merge(self, left: List[T], right: List[T]) -> List[T]:
        result = []
        i = j = 0
        
        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                result.append(left[i])
                i += 1
            else:
                result.append(right[j])
                j += 1
        
        result.extend(left[i:])
        result.extend(right[j:])
        return result

class Sorter:
    def __init__(self, strategy: SortStrategy[T] = None):
        self.strategy = strategy or QuickSortStrategy()
    
    def set_strategy(self, strategy: SortStrategy[T]):
        """设置排序策略"""
        self.strategy = strategy
    
    def sort(self, data: List[T]) -> List[T]:
        """执行排序"""
        return self.strategy.sort(data)

# 使用示例
def benchmark_sort(data: List[int], strategy: SortStrategy, name: str):
    """性能测试"""
    import time
    sorter = Sorter(strategy)
    
    start_time = time.time()
    result = sorter.sort(data)
    end_time = time.time()
    
    print(f"{name}: 耗时 {end_time - start_time:.6f}秒")
    return result

# 测试不同排序算法
test_data = [64, 34, 25, 12, 22, 11, 90, 88, 76, 54, 43, 32, 21, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]

print("排序算法性能比较:")
bubble_result = benchmark_sort(test_data.copy(), BubbleSortStrategy(), "冒泡排序")
quick_result = benchmark_sort(test_data.copy(), QuickSortStrategy(), "快速排序")
merge_result = benchmark_sort(test_data.copy(), MergeSortStrategy(), "归并排序")

print(f"\n排序结果验证:")
print(f"冒泡排序: {bubble_result[:5]}...")
print(f"快速排序: {quick_result[:5]}...")
print(f"归并排序: {merge_result[:5]}...")
```

## 4. 模式组合应用案例

### 4.1 电商系统设计模式组合

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Any
import json
import time

# 工厂模式 + 策略模式
class PaymentMethod(ABC):
    @abstractmethod
    def process(self, amount: float) -> Dict[str, Any]:
        pass

class CreditCardPayment(PaymentMethod):
    def process(self, amount: float) -> Dict[str, Any]:
        return {'method': 'credit_card', 'amount': amount, 'status': 'success'}

class PayPalPayment(PaymentMethod):
    def process(self, amount: float) -> Dict[str, Any]:
        return {'method': 'paypal', 'amount': amount, 'status': 'success'}

class PaymentFactory:
    @staticmethod
    def create_payment(method: str) -> PaymentMethod:
        if method == 'credit_card':
            return CreditCardPayment()
        elif method == 'paypal':
            return PayPalPayment()
        else:
            raise ValueError(f"不支持的支付方式: {method}")

# 单例模式 + 观察者模式
class OrderEventManager:
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance.observers = []
        return cls._instance
    
    def add_observer(self, observer):
        self.observers.append(observer)
    
    def notify(self, event_type: str, data: Dict[str, Any]):
        for observer in self.observers:
            observer.update(event_type, data)

# 装饰器模式
def log_operation(func):
    def wrapper(*args, **kwargs):
        print(f"执行操作: {func.__name__}")
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"操作完成，耗时: {end_time - start_time:.4f}秒")
        return result
    return wrapper

# 组合使用
class OrderService:
    def __init__(self):
        self.event_manager = OrderEventManager()
        self.payment_factory = PaymentFactory()
    
    @log_operation
    def create_order(self, items: List[Dict[str, Any]], payment_method: str) -> Dict[str, Any]:
        # 计算总金额
        total_amount = sum(item['price'] * item['quantity'] for item in items)
        
        # 使用工厂模式创建支付方式
        payment = self.payment_factory.create_payment(payment_method)
        payment_result = payment.process(total_amount)
        
        # 创建订单
        order = {
            'order_id': f"ORD_{int(time.time())}",
            'items': items,
            'total_amount': total_amount,
            'payment_result': payment_result,
            'status': 'created'
        }
        
        # 使用观察者模式通知事件
        self.event_manager.notify('order_created', order)
        
        return order

# 使用示例
class EmailNotifier:
    def update(self, event_type: str, data: Dict[str, Any]):
        if event_type == 'order_created':
            print(f"发送邮件通知: 订单 {data['order_id']} 已创建")

class SMSNotifier:
    def update(self, event_type: str, data: Dict[str, Any]):
        if event_type == 'order_created':
            print(f"发送短信通知: 订单 {data['order_id']} 已创建")

# 组合使用所有模式
order_service = OrderService()
order_service.event_manager.add_observer(EmailNotifier())
order_service.event_manager.add_observer(SMSNotifier())

# 创建订单
order = order_service.create_order([
    {'name': '商品1', 'price': 100, 'quantity': 2},
    {'name': '商品2', 'price': 50, 'quantity': 1}
], 'credit_card')

print(f"订单创建成功: {order['order_id']}")
```

## 总结

这些实践案例展示了设计模式在实际项目中的应用，包括：

1. **创建型模式**：工厂模式、单例模式
2. **结构型模式**：适配器模式、装饰器模式
3. **行为型模式**：观察者模式、策略模式
4. **模式组合**：多种模式协同工作

每个案例都提供了完整的代码示例和实际应用场景，可以直接应用于实际项目中。

**相关链接：**

- [4.2.1-设计模式基础理论](4.2.1-设计模式基础理论.md)
- [4.1.16-软件架构实践案例](../4.1-架构设计/4.1.16-软件架构实践案例.md)
- [4.3.1-微服务架构基础理论](../4.3-微服务架构/4.3.1-微服务架构基础理论.md)
