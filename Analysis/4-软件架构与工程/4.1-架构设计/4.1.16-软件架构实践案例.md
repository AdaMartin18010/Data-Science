# 4.1.16 软件架构实践案例

## 1. 概述

本文档提供软件架构在实际项目中的具体应用案例，涵盖微服务架构、云原生架构、DevOps实践等各个方面的实际应用。

## 2. 微服务架构实践案例

### 2.1 电商微服务架构设计

```python
# 用户服务
class UserService:
    def __init__(self):
        self.users = {}
        
    def create_user(self, user_data):
        """创建用户"""
        user_id = str(uuid.uuid4())
        user = {
            'id': user_id,
            'username': user_data['username'],
            'email': user_data['email'],
            'created_at': datetime.now()
        }
        self.users[user_id] = user
        return user
    
    def get_user(self, user_id):
        """获取用户信息"""
        return self.users.get(user_id)
    
    def update_user(self, user_id, user_data):
        """更新用户信息"""
        if user_id in self.users:
            self.users[user_id].update(user_data)
            return self.users[user_id]
        return None

# 订单服务
class OrderService:
    def __init__(self):
        self.orders = {}
        
    def create_order(self, order_data):
        """创建订单"""
        order_id = str(uuid.uuid4())
        order = {
            'id': order_id,
            'user_id': order_data['user_id'],
            'items': order_data['items'],
            'total_amount': order_data['total_amount'],
            'status': 'pending',
            'created_at': datetime.now()
        }
        self.orders[order_id] = order
        return order
    
    def get_order(self, order_id):
        """获取订单信息"""
        return self.orders.get(order_id)
    
    def update_order_status(self, order_id, status):
        """更新订单状态"""
        if order_id in self.orders:
            self.orders[order_id]['status'] = status
            return self.orders[order_id]
        return None

# 商品服务
class ProductService:
    def __init__(self):
        self.products = {}
        
    def create_product(self, product_data):
        """创建商品"""
        product_id = str(uuid.uuid4())
        product = {
            'id': product_id,
            'name': product_data['name'],
            'price': product_data['price'],
            'description': product_data['description'],
            'stock': product_data['stock']
        }
        self.products[product_id] = product
        return product
    
    def get_product(self, product_id):
        """获取商品信息"""
        return self.products.get(product_id)
    
    def update_stock(self, product_id, quantity):
        """更新库存"""
        if product_id in self.products:
            self.products[product_id]['stock'] -= quantity
            return self.products[product_id]
        return None

# API网关
class APIGateway:
    def __init__(self):
        self.user_service = UserService()
        self.order_service = OrderService()
        self.product_service = ProductService()
        
    def handle_request(self, method, path, data=None):
        """处理API请求"""
        if method == 'POST' and path == '/users':
            return self.user_service.create_user(data)
        elif method == 'GET' and path.startswith('/users/'):
            user_id = path.split('/')[-1]
            return self.user_service.get_user(user_id)
        elif method == 'POST' and path == '/orders':
            return self.order_service.create_order(data)
        elif method == 'GET' and path.startswith('/orders/'):
            order_id = path.split('/')[-1]
            return self.order_service.get_order(order_id)
        elif method == 'POST' and path == '/products':
            return self.product_service.create_product(data)
        elif method == 'GET' and path.startswith('/products/'):
            product_id = path.split('/')[-1]
            return self.product_service.get_product(product_id)
        else:
            return {'error': 'Not found'}, 404

# 使用示例
def microservice_example():
    """微服务架构示例"""
    # 创建API网关
    gateway = APIGateway()
    
    # 创建用户
    user_data = {
        'username': 'john_doe',
        'email': 'john@example.com'
    }
    user = gateway.handle_request('POST', '/users', user_data)
    print(f"创建用户: {user}")
    
    # 创建商品
    product_data = {
        'name': 'iPhone 15',
        'price': 999.99,
        'description': '最新款iPhone',
        'stock': 100
    }
    product = gateway.handle_request('POST', '/products', product_data)
    print(f"创建商品: {product}")
    
    # 创建订单
    order_data = {
        'user_id': user['id'],
        'items': [{'product_id': product['id'], 'quantity': 1}],
        'total_amount': 999.99
    }
    order = gateway.handle_request('POST', '/orders', order_data)
    print(f"创建订单: {order}")
    
    return gateway, user, product, order
```

### 2.2 服务发现与负载均衡

```python
import random
import time
from threading import Thread

class ServiceRegistry:
    def __init__(self):
        self.services = {}
        
    def register_service(self, service_name, service_instance):
        """注册服务"""
        if service_name not in self.services:
            self.services[service_name] = []
        self.services[service_name].append(service_instance)
        
    def get_service_instances(self, service_name):
        """获取服务实例"""
        return self.services.get(service_name, [])
    
    def deregister_service(self, service_name, service_instance):
        """注销服务"""
        if service_name in self.services:
            self.services[service_name].remove(service_instance)

class LoadBalancer:
    def __init__(self, registry):
        self.registry = registry
        
    def round_robin(self, service_name):
        """轮询负载均衡"""
        instances = self.registry.get_service_instances(service_name)
        if not instances:
            return None
        
        # 简单的轮询实现
        current_index = getattr(self, f'{service_name}_index', 0)
        instance = instances[current_index % len(instances)]
        setattr(self, f'{service_name}_index', current_index + 1)
        return instance
    
    def random_selection(self, service_name):
        """随机选择负载均衡"""
        instances = self.registry.get_service_instances(service_name)
        if not instances:
            return None
        return random.choice(instances)
    
    def least_connections(self, service_name):
        """最少连接负载均衡"""
        instances = self.registry.get_service_instances(service_name)
        if not instances:
            return None
        
        # 选择连接数最少的实例
        return min(instances, key=lambda x: x.get_connection_count())

class ServiceInstance:
    def __init__(self, service_name, host, port):
        self.service_name = service_name
        self.host = host
        self.port = port
        self.connection_count = 0
        self.health_status = 'healthy'
        
    def get_connection_count(self):
        return self.connection_count
    
    def increment_connections(self):
        self.connection_count += 1
    
    def decrement_connections(self):
        self.connection_count = max(0, self.connection_count - 1)
    
    def health_check(self):
        """健康检查"""
        # 模拟健康检查
        if random.random() < 0.95:  # 95%的健康率
            self.health_status = 'healthy'
        else:
            self.health_status = 'unhealthy'
        return self.health_status

# 使用示例
def service_discovery_example():
    """服务发现与负载均衡示例"""
    # 创建服务注册中心
    registry = ServiceRegistry()
    
    # 创建服务实例
    user_service_1 = ServiceInstance('user-service', '192.168.1.10', 8080)
    user_service_2 = ServiceInstance('user-service', '192.168.1.11', 8080)
    user_service_3 = ServiceInstance('user-service', '192.168.1.12', 8080)
    
    # 注册服务
    registry.register_service('user-service', user_service_1)
    registry.register_service('user-service', user_service_2)
    registry.register_service('user-service', user_service_3)
    
    # 创建负载均衡器
    load_balancer = LoadBalancer(registry)
    
    # 测试负载均衡
    print("轮询负载均衡:")
    for i in range(5):
        instance = load_balancer.round_robin('user-service')
        print(f"请求 {i+1}: {instance.host}")
    
    print("\n随机负载均衡:")
    for i in range(5):
        instance = load_balancer.random_selection('user-service')
        print(f"请求 {i+1}: {instance.host}")
    
    return registry, load_balancer
```

## 3. 云原生架构实践案例

### 3.1 容器化应用部署

```python
import docker
import yaml
import json

class ContainerOrchestrator:
    def __init__(self):
        self.client = docker.from_env()
        self.containers = {}
        
    def create_container(self, image_name, container_name, ports=None, environment=None):
        """创建容器"""
        try:
            container = self.client.containers.run(
                image=image_name,
                name=container_name,
                ports=ports or {},
                environment=environment or {},
                detach=True
            )
            self.containers[container_name] = container
            return container
        except Exception as e:
            print(f"创建容器失败: {e}")
            return None
    
    def start_container(self, container_name):
        """启动容器"""
        if container_name in self.containers:
            container = self.containers[container_name]
            container.start()
            return True
        return False
    
    def stop_container(self, container_name):
        """停止容器"""
        if container_name in self.containers:
            container = self.containers[container_name]
            container.stop()
            return True
        return False
    
    def get_container_status(self, container_name):
        """获取容器状态"""
        if container_name in self.containers:
            container = self.containers[container_name]
            return container.status
        return None
    
    def get_container_logs(self, container_name):
        """获取容器日志"""
        if container_name in self.containers:
            container = self.containers[container_name]
            return container.logs().decode('utf-8')
        return None

class KubernetesDeployment:
    def __init__(self):
        self.deployments = {}
        
    def create_deployment_yaml(self, name, image, replicas=3, ports=None):
        """创建Kubernetes部署YAML"""
        deployment = {
            'apiVersion': 'apps/v1',
            'kind': 'Deployment',
            'metadata': {
                'name': name
            },
            'spec': {
                'replicas': replicas,
                'selector': {
                    'matchLabels': {
                        'app': name
                    }
                },
                'template': {
                    'metadata': {
                        'labels': {
                            'app': name
                        }
                    },
                    'spec': {
                        'containers': [{
                            'name': name,
                            'image': image,
                            'ports': ports or []
                        }]
                    }
                }
            }
        }
        
        self.deployments[name] = deployment
        return deployment
    
    def create_service_yaml(self, name, selector, ports):
        """创建Kubernetes服务YAML"""
        service = {
            'apiVersion': 'v1',
            'kind': 'Service',
            'metadata': {
                'name': name
            },
            'spec': {
                'selector': selector,
                'ports': ports,
                'type': 'ClusterIP'
            }
        }
        return service
    
    def save_yaml(self, deployment, filename):
        """保存YAML文件"""
        with open(filename, 'w') as f:
            yaml.dump(deployment, f, default_flow_style=False)

# 使用示例
def cloud_native_example():
    """云原生架构示例"""
    # 容器编排
    orchestrator = ContainerOrchestrator()
    
    # 创建用户服务容器
    user_container = orchestrator.create_container(
        image_name='user-service:latest',
        container_name='user-service-1',
        ports={'8080/tcp': 8080},
        environment={'DB_HOST': 'postgres', 'DB_PORT': '5432'}
    )
    
    if user_container:
        print(f"用户服务容器已创建: {user_container.id}")
        orchestrator.start_container('user-service-1')
        print(f"容器状态: {orchestrator.get_container_status('user-service-1')}")
    
    # Kubernetes部署
    k8s = KubernetesDeployment()
    
    # 创建用户服务部署
    user_deployment = k8s.create_deployment_yaml(
        name='user-service',
        image='user-service:latest',
        replicas=3,
        ports=[{'containerPort': 8080}]
    )
    
    # 创建用户服务
    user_service = k8s.create_service_yaml(
        name='user-service',
        selector={'app': 'user-service'},
        ports=[{'port': 80, 'targetPort': 8080}]
    )
    
    # 保存YAML文件
    k8s.save_yaml(user_deployment, 'user-service-deployment.yaml')
    
    print("Kubernetes部署文件已创建")
    
    return orchestrator, k8s
```

### 3.2 服务网格实现

```python
import time
import random
from collections import defaultdict

class ServiceMesh:
    def __init__(self):
        self.services = {}
        self.routes = {}
        self.policies = {}
        self.metrics = defaultdict(list)
        
    def register_service(self, service_name, service_instance):
        """注册服务到网格"""
        if service_name not in self.services:
            self.services[service_name] = []
        self.services[service_name].append(service_instance)
        
    def add_route(self, source_service, target_service, route_config):
        """添加路由规则"""
        route_key = f"{source_service}->{target_service}"
        self.routes[route_key] = route_config
        
    def add_policy(self, service_name, policy_type, policy_config):
        """添加策略"""
        if service_name not in self.policies:
            self.policies[service_name] = {}
        self.policies[service_name][policy_type] = policy_config
        
    def route_request(self, source_service, target_service, request_data):
        """路由请求"""
        route_key = f"{source_service}->{target_service}"
        
        # 应用路由策略
        if route_key in self.routes:
            route_config = self.routes[route_key]
            
            # 负载均衡
            if route_config.get('load_balancer') == 'round_robin':
                target_instances = self.services.get(target_service, [])
                if target_instances:
                    instance = target_instances[len(self.metrics[route_key]) % len(target_instances)]
                else:
                    return {'error': 'No available instances'}
            else:
                # 默认随机选择
                target_instances = self.services.get(target_service, [])
                if target_instances:
                    instance = random.choice(target_instances)
                else:
                    return {'error': 'No available instances'}
        else:
            return {'error': 'Route not found'}
        
        # 应用策略
        if target_service in self.policies:
            policies = self.policies[target_service]
            
            # 重试策略
            if 'retry' in policies:
                retry_config = policies['retry']
                max_retries = retry_config.get('max_retries', 3)
                
                for attempt in range(max_retries):
                    try:
                        result = self.execute_request(instance, request_data)
                        self.record_metrics(route_key, 'success', time.time())
                        return result
                    except Exception as e:
                        if attempt == max_retries - 1:
                            self.record_metrics(route_key, 'error', time.time())
                            raise e
                        time.sleep(retry_config.get('delay', 1))
            
            # 熔断器策略
            if 'circuit_breaker' in policies:
                circuit_config = policies['circuit_breaker']
                error_threshold = circuit_config.get('error_threshold', 0.5)
                
                recent_metrics = self.metrics[route_key][-10:]  # 最近10次请求
                if recent_metrics:
                    error_rate = sum(1 for m in recent_metrics if m['status'] == 'error') / len(recent_metrics)
                    if error_rate > error_threshold:
                        return {'error': 'Circuit breaker open'}
        
        # 执行请求
        result = self.execute_request(instance, request_data)
        self.record_metrics(route_key, 'success', time.time())
        return result
    
    def execute_request(self, instance, request_data):
        """执行请求"""
        # 模拟请求执行
        if random.random() < 0.9:  # 90%成功率
            return {'result': 'success', 'instance': instance.id}
        else:
            raise Exception('Request failed')
    
    def record_metrics(self, route_key, status, timestamp):
        """记录指标"""
        self.metrics[route_key].append({
            'status': status,
            'timestamp': timestamp
        })
    
    def get_metrics(self, route_key):
        """获取指标"""
        return self.metrics[route_key]

# 使用示例
def service_mesh_example():
    """服务网格示例"""
    # 创建服务网格
    mesh = ServiceMesh()
    
    # 注册服务实例
    class ServiceInstance:
        def __init__(self, id):
            self.id = id
    
    user_service_1 = ServiceInstance('user-service-1')
    user_service_2 = ServiceInstance('user-service-2')
    order_service_1 = ServiceInstance('order-service-1')
    
    mesh.register_service('user-service', user_service_1)
    mesh.register_service('user-service', user_service_2)
    mesh.register_service('order-service', order_service_1)
    
    # 添加路由规则
    mesh.add_route('order-service', 'user-service', {
        'load_balancer': 'round_robin'
    })
    
    # 添加策略
    mesh.add_policy('user-service', 'retry', {
        'max_retries': 3,
        'delay': 1
    })
    
    mesh.add_policy('user-service', 'circuit_breaker', {
        'error_threshold': 0.5
    })
    
    # 测试请求路由
    for i in range(5):
        try:
            result = mesh.route_request('order-service', 'user-service', {'user_id': i})
            print(f"请求 {i+1}: {result}")
        except Exception as e:
            print(f"请求 {i+1} 失败: {e}")
    
    # 查看指标
    metrics = mesh.get_metrics('order-service->user-service')
    print(f"路由指标: {metrics}")
    
    return mesh
```

## 4. DevOps实践案例

### 4.1 持续集成流水线

```python
import subprocess
import os
import json
import time

class CICDPipeline:
    def __init__(self):
        self.stages = []
        self.results = {}
        
    def add_stage(self, stage_name, stage_function):
        """添加流水线阶段"""
        self.stages.append({
            'name': stage_name,
            'function': stage_function
        })
    
    def run_pipeline(self):
        """运行流水线"""
        print("开始运行CI/CD流水线...")
        
        for stage in self.stages:
            stage_name = stage['name']
            stage_function = stage['function']
            
            print(f"\n执行阶段: {stage_name}")
            start_time = time.time()
            
            try:
                result = stage_function()
                self.results[stage_name] = {
                    'status': 'success',
                    'result': result,
                    'duration': time.time() - start_time
                }
                print(f"✓ {stage_name} 成功完成")
            except Exception as e:
                self.results[stage_name] = {
                    'status': 'failed',
                    'error': str(e),
                    'duration': time.time() - start_time
                }
                print(f"✗ {stage_name} 失败: {e}")
                break
        
        self.print_summary()
        return self.results
    
    def print_summary(self):
        """打印流水线摘要"""
        print("\n" + "="*50)
        print("流水线执行摘要")
        print("="*50)
        
        for stage_name, result in self.results.items():
            status = "✓" if result['status'] == 'success' else "✗"
            duration = f"{result['duration']:.2f}s"
            print(f"{status} {stage_name}: {duration}")
            
            if result['status'] == 'failed':
                print(f"   错误: {result['error']}")

class CodeQualityChecker:
    def __init__(self):
        self.quality_metrics = {}
    
    def run_linting(self, code_path):
        """运行代码检查"""
        print("运行代码检查...")
        
        # 模拟代码检查
        issues = []
        
        # 检查Python文件
        for root, dirs, files in os.walk(code_path):
            for file in files:
                if file.endswith('.py'):
                    file_path = os.path.join(root, file)
                    
                    # 模拟检查结果
                    if 'TODO' in open(file_path, 'r').read():
                        issues.append(f"{file_path}: 发现TODO注释")
        
        if issues:
            print(f"发现 {len(issues)} 个问题:")
            for issue in issues:
                print(f"  - {issue}")
            return {'issues': issues, 'count': len(issues)}
        else:
            print("代码检查通过")
            return {'issues': [], 'count': 0}
    
    def run_tests(self, test_path):
        """运行测试"""
        print("运行单元测试...")
        
        # 模拟测试执行
        test_results = {
            'total': 10,
            'passed': 9,
            'failed': 1,
            'coverage': 85.5
        }
        
        print(f"测试结果: {test_results['passed']}/{test_results['total']} 通过")
        print(f"代码覆盖率: {test_results['coverage']}%")
        
        return test_results
    
    def run_security_scan(self, code_path):
        """运行安全扫描"""
        print("运行安全扫描...")
        
        # 模拟安全扫描
        vulnerabilities = []
        
        # 检查常见安全问题
        for root, dirs, files in os.walk(code_path):
            for file in files:
                if file.endswith('.py'):
                    file_path = os.path.join(root, file)
                    content = open(file_path, 'r').read()
                    
                    if 'password' in content and '=' in content:
                        vulnerabilities.append(f"{file_path}: 发现硬编码密码")
                    if 'eval(' in content:
                        vulnerabilities.append(f"{file_path}: 发现eval函数使用")
        
        if vulnerabilities:
            print(f"发现 {len(vulnerabilities)} 个安全漏洞:")
            for vuln in vulnerabilities:
                print(f"  - {vuln}")
            return {'vulnerabilities': vulnerabilities, 'count': len(vulnerabilities)}
        else:
            print("安全扫描通过")
            return {'vulnerabilities': [], 'count': 0}

class DockerBuilder:
    def __init__(self):
        self.images = {}
    
    def build_image(self, dockerfile_path, image_name, tag='latest'):
        """构建Docker镜像"""
        print(f"构建Docker镜像: {image_name}:{tag}")
        
        # 模拟Docker构建
        build_result = {
            'image_name': f"{image_name}:{tag}",
            'size': '156MB',
            'layers': 12,
            'status': 'success'
        }
        
        self.images[build_result['image_name']] = build_result
        print(f"镜像构建成功: {build_result['image_name']}")
        
        return build_result
    
    def push_image(self, image_name, registry):
        """推送镜像到仓库"""
        print(f"推送镜像到仓库: {registry}/{image_name}")
        
        # 模拟推送
        push_result = {
            'registry': registry,
            'image_name': image_name,
            'status': 'success'
        }
        
        print(f"镜像推送成功: {registry}/{image_name}")
        return push_result

# 使用示例
def cicd_pipeline_example():
    """CI/CD流水线示例"""
    # 创建流水线
    pipeline = CICDPipeline()
    quality_checker = CodeQualityChecker()
    docker_builder = DockerBuilder()
    
    # 添加流水线阶段
    def code_check_stage():
        return quality_checker.run_linting('./src')
    
    def test_stage():
        return quality_checker.run_tests('./tests')
    
    def security_stage():
        return quality_checker.run_security_scan('./src')
    
    def build_stage():
        return docker_builder.build_image('./Dockerfile', 'myapp')
    
    def deploy_stage():
        print("部署到生产环境...")
        # 模拟部署
        time.sleep(2)
        return {'status': 'deployed', 'environment': 'production'}
    
    # 添加阶段到流水线
    pipeline.add_stage('代码检查', code_check_stage)
    pipeline.add_stage('单元测试', test_stage)
    pipeline.add_stage('安全扫描', security_stage)
    pipeline.add_stage('构建镜像', build_stage)
    pipeline.add_stage('部署', deploy_stage)
    
    # 运行流水线
    results = pipeline.run_pipeline()
    
    return pipeline, results
```

## 5. 总结

本文档提供了软件架构在实际项目中的具体应用案例，包括：

1. **微服务架构实践**：电商微服务架构设计和服务发现与负载均衡
2. **云原生架构实践**：容器化应用部署和服务网格实现
3. **DevOps实践**：持续集成流水线

这些案例展示了软件架构在各个领域的实际应用，为软件架构项目提供了实用的参考和指导。
