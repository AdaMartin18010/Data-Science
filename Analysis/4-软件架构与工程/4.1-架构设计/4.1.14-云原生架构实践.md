# 4.1.14 äº‘åŸç”Ÿæ¶æ„å®è·µ

## ğŸ“‘ ç›®å½•

- [4.1.14 äº‘åŸç”Ÿæ¶æ„å®è·µ](#4114-äº‘åŸç”Ÿæ¶æ„å®è·µ)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2. ç†è®ºåŸºç¡€](#2-ç†è®ºåŸºç¡€)
    - [2.1. äº‘åŸç”Ÿå®šä¹‰](#21-äº‘åŸç”Ÿå®šä¹‰)
    - [2.2. äº‘åŸç”ŸåŸåˆ™](#22-äº‘åŸç”ŸåŸåˆ™)
      - [2.2.1. -Factoråº”ç”¨åŸåˆ™](#221--factoråº”ç”¨åŸåˆ™)
  - [3. æ ¸å¿ƒæŠ€æœ¯æ ˆ](#3-æ ¸å¿ƒæŠ€æœ¯æ ˆ)
    - [3.1. å®¹å™¨æŠ€æœ¯](#31-å®¹å™¨æŠ€æœ¯)
      - [3.1.1. Dockeræ·±åº¦å®è·µ](#311-dockeræ·±åº¦å®è·µ)
  - [4. å¤šé˜¶æ®µæ„å»ºä¼˜åŒ–](#4-å¤šé˜¶æ®µæ„å»ºä¼˜åŒ–)
  - [5. Kubernetesæ·±åº¦é›†æˆ](#5-kubernetesæ·±åº¦é›†æˆ)
    - [5.1. Kubernetes APIå®¢æˆ·ç«¯](#51-kubernetes-apiå®¢æˆ·ç«¯)
  - [6. è‡ªå®šä¹‰èµ„æºå®šä¹‰ (CRD)](#6-è‡ªå®šä¹‰èµ„æºå®šä¹‰-crd)
  - [7. æœåŠ¡ç½‘æ ¼ (Service Mesh)](#7-æœåŠ¡ç½‘æ ¼-service-mesh)
    - [7.1. Istioé›†æˆ](#71-istioé›†æˆ)
  - [8. é…ç½®ç®¡ç†](#8-é…ç½®ç®¡ç†)
    - [8.1. ConfigMapå’ŒSecretç®¡ç†](#81-configmapå’Œsecretç®¡ç†)
  - [9. DevOpså®è·µ](#9-devopså®è·µ)
    - [9.1. CI/CDæµæ°´çº¿](#91-cicdæµæ°´çº¿)
      - [9.1.1. GitHub Actionsé›†æˆ](#911-github-actionsé›†æˆ)
  - [10. ArgoCDé›†æˆ](#10-argocdé›†æˆ)
  - [11. ç›‘æ§ä¸å¯è§‚æµ‹æ€§](#11-ç›‘æ§ä¸å¯è§‚æµ‹æ€§)
    - [11.1. Prometheusé›†æˆ](#111-prometheusé›†æˆ)
  - [12. Grafanaä»ªè¡¨æ¿](#12-grafanaä»ªè¡¨æ¿)
    - [12.1. æ—¥å¿—ç®¡ç†](#121-æ—¥å¿—ç®¡ç†)
      - [12.1.1. ç»“æ„åŒ–æ—¥å¿—](#1211-ç»“æ„åŒ–æ—¥å¿—)
  - [13. å®‰å…¨å®è·µ](#13-å®‰å…¨å®è·µ)
    - [13.1. å®¹å™¨å®‰å…¨](#131-å®¹å™¨å®‰å…¨)
      - [13.1.1. é•œåƒæ‰«æ](#1311-é•œåƒæ‰«æ)
  - [14. è¿è¡Œæ—¶å®‰å…¨](#14-è¿è¡Œæ—¶å®‰å…¨)
  - [15. ç½‘ç»œå®‰å…¨](#15-ç½‘ç»œå®‰å…¨)
    - [15.1. ç½‘ç»œç­–ç•¥](#151-ç½‘ç»œç­–ç•¥)
  - [16. æ€§èƒ½ä¼˜åŒ–](#16-æ€§èƒ½ä¼˜åŒ–)
    - [16.1. èµ„æºç®¡ç†](#161-èµ„æºç®¡ç†)
      - [16.1.1. èµ„æºé™åˆ¶å’Œè¯·æ±‚](#1611-èµ„æºé™åˆ¶å’Œè¯·æ±‚)
  - [17. æ°´å¹³Podè‡ªåŠ¨æ‰©ç¼©å®¹ (HPA)](#17-æ°´å¹³podè‡ªåŠ¨æ‰©ç¼©å®¹-hpa)
  - [18. ç¼“å­˜ç­–ç•¥](#18-ç¼“å­˜ç­–ç•¥)
    - [18.1. Redisé›†ç¾¤é…ç½®](#181-redisé›†ç¾¤é…ç½®)
  - [19. æ€»ç»“ä¸å±•æœ›](#19-æ€»ç»“ä¸å±•æœ›)
  - [20. å‚è€ƒæ–‡çŒ®](#20-å‚è€ƒæ–‡çŒ®)

---

## 1. æ¦‚è¿°

äº‘åŸç”Ÿæ¶æ„æ˜¯ä¸€ç§å……åˆ†åˆ©ç”¨äº‘è®¡ç®—ä¼˜åŠ¿çš„è½¯ä»¶æ¶æ„æ–¹æ³•ï¼Œå¼ºè°ƒå®¹å™¨åŒ–ã€å¾®æœåŠ¡ã€DevOpså’ŒæŒç»­äº¤ä»˜ã€‚æœ¬æ–‡æ¡£ä»ç†è®ºåŸºç¡€ã€æŠ€æœ¯æ ˆã€å®è·µæ¨¡å¼å’Œå·¥ç¨‹å®ç°å››ä¸ªç»´åº¦æ·±å…¥åˆ†æäº‘åŸç”Ÿæ¶æ„ã€‚

## 2. ç†è®ºåŸºç¡€

### 2.1. äº‘åŸç”Ÿå®šä¹‰

**å®šä¹‰ 2.1.1** (äº‘åŸç”Ÿ)
äº‘åŸç”Ÿæ˜¯ä¸€ç§æ„å»ºå’Œè¿è¡Œåº”ç”¨ç¨‹åºçš„æ–¹æ³•ï¼Œå……åˆ†åˆ©ç”¨äº‘è®¡ç®—æ¨¡å‹çš„ä¼˜åŠ¿ï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹å¾ï¼š

- å®¹å™¨åŒ–ï¼šåº”ç”¨ç¨‹åºæ‰“åŒ…åœ¨å®¹å™¨ä¸­è¿è¡Œ
- å¾®æœåŠ¡ï¼šåº”ç”¨ç¨‹åºåˆ†è§£ä¸ºå°å‹ã€æ¾è€¦åˆçš„æœåŠ¡
- ä¸å¯å˜åŸºç¡€è®¾æ–½ï¼šé€šè¿‡å£°æ˜å¼é…ç½®ç®¡ç†åŸºç¡€è®¾æ–½
- å£°æ˜å¼APIï¼šé€šè¿‡APIå£°æ˜æœŸæœ›çŠ¶æ€

**å®šç† 2.1.1** (äº‘åŸç”Ÿå¼¹æ€§å®šç†)
å¯¹äºäº‘åŸç”Ÿåº”ç”¨ $A$ï¼Œå…¶å¼¹æ€§èƒ½åŠ› $E(A)$ æ»¡è¶³ï¼š
$$E(A) = \frac{\text{Scale}(A) \times \text{Resilience}(A) \times \text{Observability}(A)}{\text{Complexity}(A)}$$

å…¶ä¸­ $\text{Scale}$ è¡¨ç¤ºå¯æ‰©å±•æ€§ï¼Œ$\text{Resilience}$ è¡¨ç¤ºå¼¹æ€§ï¼Œ$\text{Observability}$ è¡¨ç¤ºå¯è§‚æµ‹æ€§ï¼Œ$\text{Complexity}$ è¡¨ç¤ºå¤æ‚åº¦ã€‚

### 2.2. äº‘åŸç”ŸåŸåˆ™

#### 2.2.1. -Factoråº”ç”¨åŸåˆ™

1. **ä»£ç åº“**ï¼šä¸€ä¸ªä»£ç åº“ï¼Œå¤šä¸ªéƒ¨ç½²
2. **ä¾èµ–**ï¼šæ˜¾å¼å£°æ˜å’Œéš”ç¦»ä¾èµ–
3. **é…ç½®**ï¼šåœ¨ç¯å¢ƒä¸­å­˜å‚¨é…ç½®
4. **åç«¯æœåŠ¡**ï¼šå°†åç«¯æœåŠ¡è§†ä¸ºé™„åŠ èµ„æº
5. **æ„å»ºã€å‘å¸ƒã€è¿è¡Œ**ï¼šä¸¥æ ¼åˆ†ç¦»æ„å»ºå’Œè¿è¡Œé˜¶æ®µ
6. **è¿›ç¨‹**ï¼šä»¥ä¸€ä¸ªæˆ–å¤šä¸ªæ— çŠ¶æ€è¿›ç¨‹è¿è¡Œåº”ç”¨
7. **ç«¯å£ç»‘å®š**ï¼šé€šè¿‡ç«¯å£ç»‘å®šæä¾›æœåŠ¡
8. **å¹¶å‘**ï¼šé€šè¿‡è¿›ç¨‹æ¨¡å‹è¿›è¡Œæ‰©å±•
9. **æ˜“å¤„ç†**ï¼šå¿«é€Ÿå¯åŠ¨å’Œä¼˜é›…å…³é—­
10. **å¼€å‘/ç”Ÿäº§ç¯å¢ƒç­‰ä»·**ï¼šä¿æŒå¼€å‘ã€é¢„å‘å¸ƒã€ç”Ÿäº§ç¯å¢ƒç›¸ä¼¼
11. **æ—¥å¿—**ï¼šå°†æ—¥å¿—è§†ä¸ºäº‹ä»¶æµ
12. **ç®¡ç†è¿›ç¨‹**ï¼šå°†ç®¡ç†/ç®¡ç†ä»»åŠ¡ä½œä¸ºä¸€æ¬¡æ€§è¿›ç¨‹è¿è¡Œ

## 3. æ ¸å¿ƒæŠ€æœ¯æ ˆ

### 3.1. å®¹å™¨æŠ€æœ¯

#### 3.1.1. Dockeræ·±åº¦å®è·µ

```python
import docker
import yaml
from typing import Dict, List

class DockerManager:
    def __init__(self):
        self.client = docker.from_env()

    def build_image(self, dockerfile_path: str, tag: str, build_args: Dict = None):
        """æ„å»ºDockeré•œåƒ"""
        try:
            image, logs = self.client.images.build(
                path=dockerfile_path,
                tag=tag,
                buildargs=build_args or {},
                rm=True
            )
            return image
        except Exception as e:
            print(f"æ„å»ºå¤±è´¥: {e}")
            return None

    def run_container(self, image_name: str, container_name: str,
                     ports: Dict = None, environment: Dict = None,
                     volumes: Dict = None, network: str = None):
        """è¿è¡Œå®¹å™¨"""
        try:
            container = self.client.containers.run(
                image_name,
                name=container_name,
                ports=ports or {},
                environment=environment or {},
                volumes=volumes or {},
                network=network,
                detach=True,
                restart_policy={"Name": "unless-stopped"}
            )
            return container
        except Exception as e:
            print(f"è¿è¡Œå®¹å™¨å¤±è´¥: {e}")
            return None

    def create_network(self, name: str, driver: str = "bridge"):
        """åˆ›å»ºç½‘ç»œ"""
        try:
            network = self.client.networks.create(name, driver=driver)
            return network
        except Exception as e:
            print(f"åˆ›å»ºç½‘ç»œå¤±è´¥: {e}")
            return None

    def cleanup_containers(self, filters: Dict = None):
        """æ¸…ç†å®¹å™¨"""
        containers = self.client.containers.list(filters=filters or {})
        for container in containers:
            try:
                container.remove(force=True)
            except Exception as e:
                print(f"æ¸…ç†å®¹å™¨å¤±è´¥: {e}")

# ä½¿ç”¨ç¤ºä¾‹
docker_manager = DockerManager()

# æ„å»ºé•œåƒ
image = docker_manager.build_image(
    dockerfile_path="./app",
    tag="myapp:v1.0",
    build_args={"VERSION": "1.0.0"}
)

# è¿è¡Œå®¹å™¨
container = docker_manager.run_container(
    image_name="myapp:v1.0",
    container_name="myapp-container",
    ports={"8080/tcp": 8080},
    environment={"NODE_ENV": "production"},
    volumes={"/host/path": {"bind": "/container/path", "mode": "rw"}}
)
```

## 4. å¤šé˜¶æ®µæ„å»ºä¼˜åŒ–

```dockerfile
# å¤šé˜¶æ®µæ„å»ºç¤ºä¾‹
FROM golang:1.21-alpine AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download

COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main .

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/

COPY --from=builder /app/main .
COPY --from=builder /app/config ./config

EXPOSE 8080
CMD ["./main"]
```

## 5. Kubernetesæ·±åº¦é›†æˆ

### 5.1. Kubernetes APIå®¢æˆ·ç«¯

```python
from kubernetes import client, config, watch
from kubernetes.client.rest import ApiException
import yaml
from typing import Dict, List, Optional

class KubernetesManager:
    def __init__(self, config_file: str = None):
        if config_file:
            config.load_kube_config(config_file)
        else:
            config.load_incluster_config()

        self.v1 = client.CoreV1Api()
        self.apps_v1 = client.AppsV1Api()
        self.networking_v1 = client.NetworkingV1Api()

    def create_namespace(self, name: str, labels: Dict = None):
        """åˆ›å»ºå‘½åç©ºé—´"""
        try:
            namespace = client.V1Namespace(
                metadata=client.V1ObjectMeta(
                    name=name,
                    labels=labels or {}
                )
            )
            result = self.v1.create_namespace(namespace)
            return result
        except ApiException as e:
            print(f"åˆ›å»ºå‘½åç©ºé—´å¤±è´¥: {e}")
            return None

    def create_deployment(self, name: str, namespace: str,
                         image: str, replicas: int = 3,
                         ports: List[int] = None):
        """åˆ›å»ºDeployment"""
        try:
            containers = []
            for i, port in enumerate(ports or [8080]):
                containers.append(client.V1Container(
                    name=f"{name}-container-{i}",
                    image=image,
                    ports=[client.V1ContainerPort(container_port=port)]
                ))

            deployment = client.V1Deployment(
                metadata=client.V1ObjectMeta(name=name),
                spec=client.V1DeploymentSpec(
                    replicas=replicas,
                    selector=client.V1LabelSelector(
                        match_labels={"app": name}
                    ),
                    template=client.V1PodTemplateSpec(
                        metadata=client.V1ObjectMeta(
                            labels={"app": name}
                        ),
                        spec=client.V1PodSpec(containers=containers)
                    )
                )
            )

            result = self.apps_v1.create_namespaced_deployment(
                namespace=namespace,
                body=deployment
            )
            return result
        except ApiException as e:
            print(f"åˆ›å»ºDeploymentå¤±è´¥: {e}")
            return None

    def create_service(self, name: str, namespace: str,
                      selector: Dict, ports: List[Dict]):
        """åˆ›å»ºService"""
        try:
            service_ports = []
            for port in ports:
                service_ports.append(client.V1ServicePort(
                    port=port["port"],
                    target_port=port["target_port"],
                    protocol=port.get("protocol", "TCP")
                ))

            service = client.V1Service(
                metadata=client.V1ObjectMeta(name=name),
                spec=client.V1ServiceSpec(
                    selector=selector,
                    ports=service_ports,
                    type="ClusterIP"
                )
            )

            result = self.v1.create_namespaced_service(
                namespace=namespace,
                body=service
            )
            return result
        except ApiException as e:
            print(f"åˆ›å»ºServiceå¤±è´¥: {e}")
            return None

    def create_ingress(self, name: str, namespace: str,
                      rules: List[Dict], annotations: Dict = None):
        """åˆ›å»ºIngress"""
        try:
            ingress_rules = []
            for rule in rules:
                ingress_rules.append(client.V1IngressRule(
                    host=rule["host"],
                    http=client.V1HTTPIngressRuleValue(
                        paths=[
                            client.V1HTTPIngressPath(
                                path=path["path"],
                                path_type=path.get("path_type", "Prefix"),
                                backend=client.V1IngressBackend(
                                    service=client.V1IngressServiceBackend(
                                        name=path["service_name"],
                                        port=client.V1ServiceBackendPort(
                                            number=path["service_port"]
                                        )
                                    )
                                )
                            ) for path in rule["paths"]
                        ]
                    )
                ))

            ingress = client.V1Ingress(
                metadata=client.V1ObjectMeta(
                    name=name,
                    annotations=annotations or {}
                ),
                spec=client.V1IngressSpec(rules=ingress_rules)
            )

            result = self.networking_v1.create_namespaced_ingress(
                namespace=namespace,
                body=ingress
            )
            return result
        except ApiException as e:
            print(f"åˆ›å»ºIngresså¤±è´¥: {e}")
            return None

    def scale_deployment(self, name: str, namespace: str, replicas: int):
        """æ‰©ç¼©å®¹Deployment"""
        try:
            self.apps_v1.patch_namespaced_deployment_scale(
                name=name,
                namespace=namespace,
                body={"spec": {"replicas": replicas}}
            )
            return True
        except ApiException as e:
            print(f"æ‰©ç¼©å®¹å¤±è´¥: {e}")
            return False

    def get_pod_logs(self, pod_name: str, namespace: str,
                    container: str = None, tail_lines: int = 100):
        """è·å–Podæ—¥å¿—"""
        try:
            logs = self.v1.read_namespaced_pod_log(
                name=pod_name,
                namespace=namespace,
                container=container,
                tail_lines=tail_lines
            )
            return logs
        except ApiException as e:
            print(f"è·å–æ—¥å¿—å¤±è´¥: {e}")
            return None

# ä½¿ç”¨ç¤ºä¾‹
k8s_manager = KubernetesManager()

# åˆ›å»ºåº”ç”¨
namespace = k8s_manager.create_namespace("myapp")
deployment = k8s_manager.create_deployment(
    name="myapp",
    namespace="myapp",
    image="myapp:v1.0",
    replicas=3,
    ports=[8080]
)
service = k8s_manager.create_service(
    name="myapp-service",
    namespace="myapp",
    selector={"app": "myapp"},
    ports=[{"port": 80, "target_port": 8080}]
)
```

## 6. è‡ªå®šä¹‰èµ„æºå®šä¹‰ (CRD)

```python
from kubernetes import client, config
from kubernetes.client import V1CustomResourceDefinition
from kubernetes.client import V1CustomResourceDefinitionSpec
from kubernetes.client import V1CustomResourceDefinitionNames
from kubernetes.client import V1CustomResourceDefinitionVersion

class CustomResourceManager:
    def __init__(self):
        config.load_incluster_config()
        self.apiextensions_v1 = client.ApiextensionsV1Api()

    def create_crd(self, group: str, version: str, plural: str,
                   singular: str, kind: str, scope: str = "Namespaced"):
        """åˆ›å»ºè‡ªå®šä¹‰èµ„æºå®šä¹‰"""
        try:
            crd = V1CustomResourceDefinition(
                metadata=client.V1ObjectMeta(name=f"{plural}.{group}"),
                spec=V1CustomResourceDefinitionSpec(
                    group=group,
                    names=V1CustomResourceDefinitionNames(
                        plural=plural,
                        singular=singular,
                        kind=kind,
                        short_names=[plural]
                    ),
                    scope=scope,
                    versions=[
                        V1CustomResourceDefinitionVersion(
                            name=version,
                            served=True,
                            storage=True,
                            schema=client.V1JSONSchemaProps(
                                type="object",
                                properties={
                                    "spec": client.V1JSONSchemaProps(
                                        type="object",
                                        properties={
                                            "replicas": client.V1JSONSchemaProps(
                                                type="integer",
                                                minimum=1
                                            ),
                                            "image": client.V1JSONSchemaProps(
                                                type="string"
                                            )
                                        }
                                    )
                                }
                            )
                        )
                    ]
                )
            )

            result = self.apiextensions_v1.create_custom_resource_definition(crd)
            return result
        except Exception as e:
            print(f"åˆ›å»ºCRDå¤±è´¥: {e}")
            return None

# ä½¿ç”¨ç¤ºä¾‹
crd_manager = CustomResourceManager()
crd = crd_manager.create_crd(
    group="example.com",
    version="v1",
    plural="applications",
    singular="application",
    kind="Application"
)
```

## 7. æœåŠ¡ç½‘æ ¼ (Service Mesh)

### 7.1. Istioé›†æˆ

```python
import yaml
from kubernetes import client, config
from typing import Dict, List

class IstioManager:
    def __init__(self):
        config.load_incluster_config()
        self.networking_v1beta1 = client.NetworkingV1beta1Api()
        self.security_v1beta1 = client.SecurityV1beta1Api()

    def create_virtual_service(self, name: str, namespace: str,
                              hosts: List[str], gateways: List[str],
                              routes: List[Dict]):
        """åˆ›å»ºVirtualService"""
        try:
            http_routes = []
            for route in routes:
                http_routes.append({
                    "match": route.get("match", []),
                    "route": route.get("route", []),
                    "retries": route.get("retries"),
                    "timeout": route.get("timeout")
                })

            virtual_service = {
                "apiVersion": "networking.istio.io/v1beta1",
                "kind": "VirtualService",
                "metadata": {
                    "name": name,
                    "namespace": namespace
                },
                "spec": {
                    "hosts": hosts,
                    "gateways": gateways,
                    "http": http_routes
                }
            }

# ä½¿ç”¨åŠ¨æ€å®¢æˆ·ç«¯åˆ›å»ºèµ„æº
            dynamic_client = client.CustomObjectsApi()
            result = dynamic_client.create_namespaced_custom_object(
                group="networking.istio.io",
                version="v1beta1",
                namespace=namespace,
                plural="virtualservices",
                body=virtual_service
            )
            return result
        except Exception as e:
            print(f"åˆ›å»ºVirtualServiceå¤±è´¥: {e}")
            return None

    def create_destination_rule(self, name: str, namespace: str,
                               host: str, subsets: List[Dict]):
        """åˆ›å»ºDestinationRule"""
        try:
            destination_rule = {
                "apiVersion": "networking.istio.io/v1beta1",
                "kind": "DestinationRule",
                "metadata": {
                    "name": name,
                    "namespace": namespace
                },
                "spec": {
                    "host": host,
                    "subsets": subsets
                }
            }

            dynamic_client = client.CustomObjectsApi()
            result = dynamic_client.create_namespaced_custom_object(
                group="networking.istio.io",
                version="v1beta1",
                namespace=namespace,
                plural="destinationrules",
                body=destination_rule
            )
            return result
        except Exception as e:
            print(f"åˆ›å»ºDestinationRuleå¤±è´¥: {e}")
            return None

    def create_authorization_policy(self, name: str, namespace: str,
                                   selector: Dict, rules: List[Dict]):
        """åˆ›å»ºAuthorizationPolicy"""
        try:
            auth_policy = {
                "apiVersion": "security.istio.io/v1beta1",
                "kind": "AuthorizationPolicy",
                "metadata": {
                    "name": name,
                    "namespace": namespace
                },
                "spec": {
                    "selector": selector,
                    "rules": rules
                }
            }

            dynamic_client = client.CustomObjectsApi()
            result = dynamic_client.create_namespaced_custom_object(
                group="security.istio.io",
                version="v1beta1",
                namespace=namespace,
                plural="authorizationpolicies",
                body=auth_policy
            )
            return result
        except Exception as e:
            print(f"åˆ›å»ºAuthorizationPolicyå¤±è´¥: {e}")
            return None

# ä½¿ç”¨ç¤ºä¾‹
istio_manager = IstioManager()

# åˆ›å»ºé‡‘ä¸é›€å‘å¸ƒé…ç½®
virtual_service = istio_manager.create_virtual_service(
    name="myapp-vs",
    namespace="myapp",
    hosts=["myapp.example.com"],
    gateways=["myapp-gateway"],
    routes=[
        {
            "route": [
                {"destination": {"host": "myapp", "subset": "v1"}, "weight": 90},
                {"destination": {"host": "myapp", "subset": "v2"}, "weight": 10}
            ]
        }
    ]
)

destination_rule = istio_manager.create_destination_rule(
    name="myapp-dr",
    namespace="myapp",
    host="myapp",
    subsets=[
        {"name": "v1", "labels": {"version": "v1"}},
        {"name": "v2", "labels": {"version": "v2"}}
    ]
)
```

## 8. é…ç½®ç®¡ç†

### 8.1. ConfigMapå’ŒSecretç®¡ç†

```python
class ConfigManager:
    def __init__(self):
        config.load_incluster_config()
        self.v1 = client.CoreV1Api()

    def create_configmap(self, name: str, namespace: str, data: Dict):
        """åˆ›å»ºConfigMap"""
        try:
            configmap = client.V1ConfigMap(
                metadata=client.V1ObjectMeta(name=name),
                data=data
            )

            result = self.v1.create_namespaced_config_map(
                namespace=namespace,
                body=configmap
            )
            return result
        except ApiException as e:
            print(f"åˆ›å»ºConfigMapå¤±è´¥: {e}")
            return None

    def create_secret(self, name: str, namespace: str,
                     data: Dict, secret_type: str = "Opaque"):
        """åˆ›å»ºSecret"""
        try:
            secret = client.V1Secret(
                metadata=client.V1ObjectMeta(name=name),
                type=secret_type,
                data=data
            )

            result = self.v1.create_namespaced_secret(
                namespace=namespace,
                body=secret
            )
            return result
        except ApiException as e:
            print(f"åˆ›å»ºSecretå¤±è´¥: {e}")
            return None

    def update_configmap(self, name: str, namespace: str, data: Dict):
        """æ›´æ–°ConfigMap"""
        try:
            configmap = self.v1.read_namespaced_config_map(
                name=name,
                namespace=namespace
            )
            configmap.data.update(data)

            result = self.v1.replace_namespaced_config_map(
                name=name,
                namespace=namespace,
                body=configmap
            )
            return result
        except ApiException as e:
            print(f"æ›´æ–°ConfigMapå¤±è´¥: {e}")
            return None

# ä½¿ç”¨ç¤ºä¾‹
config_manager = ConfigManager()

# åˆ›å»ºåº”ç”¨é…ç½®
configmap = config_manager.create_configmap(
    name="myapp-config",
    namespace="myapp",
    data={
        "database_url": "postgresql://user:pass@db:5432/myapp",
        "redis_url": "redis://redis:6379",
        "log_level": "INFO"
    }
)

# åˆ›å»ºæ•æ„Ÿä¿¡æ¯
secret = config_manager.create_secret(
    name="myapp-secret",
    namespace="myapp",
    data={
        "database_password": "cGFzc3dvcmQ=",  # base64ç¼–ç 
        "api_key": "YXBpLWtleQ=="
    }
)
```

## 9. DevOpså®è·µ

### 9.1. CI/CDæµæ°´çº¿

#### 9.1.1. GitHub Actionsé›†æˆ

```yaml
# .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-cov

    - name: Run tests
      run: |
        pytest --cov=./ --cov-report=xml

    - name: Upload coverage
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml

  build:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
    - uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
    - uses: actions/checkout@v4

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'

    - name: Configure kubectl
      run: |
        echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > kubeconfig
        export KUBECONFIG=kubeconfig

    - name: Deploy to Kubernetes
      run: |
        kubectl set image deployment/myapp myapp=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
        kubectl rollout status deployment/myapp
```

## 10. ArgoCDé›†æˆ

```yaml
# argocd-app.yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: myapp
  namespace: argocd
spec:
  project: default
  source:
    repoURL: https://github.com/username/repo
    targetRevision: HEAD
    path: k8s
  destination:
    server: https://kubernetes.default.svc
    namespace: myapp
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
    - CreateNamespace=true
    retry:
      limit: 5
      backoff:
        duration: 5s
        factor: 2
        maxDuration: 3m
```

## 11. ç›‘æ§ä¸å¯è§‚æµ‹æ€§

### 11.1. Prometheusé›†æˆ

```python
from prometheus_client import Counter, Histogram, Gauge, start_http_server
import time
from functools import wraps

class MetricsCollector:
    def __init__(self):
        self.request_count = Counter('http_requests_total', 'Total HTTP requests', ['method', 'endpoint', 'status'])
        self.request_duration = Histogram('http_request_duration_seconds', 'HTTP request duration')
        self.active_connections = Gauge('active_connections', 'Number of active connections')
        self.memory_usage = Gauge('memory_usage_bytes', 'Memory usage in bytes')

    def track_request(self, method: str, endpoint: str, status: int):
        """è®°å½•è¯·æ±‚æŒ‡æ ‡"""
        self.request_count.labels(method=method, endpoint=endpoint, status=status).inc()

    def track_duration(self, duration: float):
        """è®°å½•è¯·æ±‚æŒç»­æ—¶é—´"""
        self.request_duration.observe(duration)

    def set_active_connections(self, count: int):
        """è®¾ç½®æ´»è·ƒè¿æ¥æ•°"""
        self.active_connections.set(count)

    def set_memory_usage(self, bytes_used: int):
        """è®¾ç½®å†…å­˜ä½¿ç”¨é‡"""
        self.memory_usage.set(bytes_used)

# å…¨å±€æŒ‡æ ‡æ”¶é›†å™¨
metrics = MetricsCollector()

def monitor_request(f):
    """è¯·æ±‚ç›‘æ§è£…é¥°å™¨"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        start_time = time.time()

        try:
            result = f(*args, **kwargs)
            status = 200
        except Exception as e:
            status = 500
            raise e
        finally:
            duration = time.time() - start_time
            metrics.track_duration(duration)
            metrics.track_request('GET', f.__name__, status)

        return result
    return decorated_function

# å¯åŠ¨PrometheusæŒ‡æ ‡æœåŠ¡å™¨
start_http_server(8000)
```

## 12. Grafanaä»ªè¡¨æ¿

```json
{
  "dashboard": {
    "id": null,
    "title": "Application Metrics",
    "tags": ["application", "monitoring"],
    "timezone": "browser",
    "panels": [
      {
        "id": 1,
        "title": "Request Rate",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(http_requests_total[5m])",
            "legendFormat": "{{method}} {{endpoint}}"
          }
        ]
      },
      {
        "id": 2,
        "title": "Response Time",
        "type": "graph",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))",
            "legendFormat": "95th percentile"
          }
        ]
      },
      {
        "id": 3,
        "title": "Memory Usage",
        "type": "graph",
        "targets": [
          {
            "expr": "memory_usage_bytes",
            "legendFormat": "Memory Usage"
          }
        ]
      }
    ]
  }
}
```

### 12.1. æ—¥å¿—ç®¡ç†

#### 12.1.1. ç»“æ„åŒ–æ—¥å¿—

```python
import logging
import json
from datetime import datetime
from typing import Dict, Any

class StructuredLogger:
    def __init__(self, name: str, level: int = logging.INFO):
        self.logger = logging.getLogger(name)
        self.logger.setLevel(level)

# é…ç½®JSONæ ¼å¼åŒ–å™¨
        formatter = logging.Formatter(
            '{"timestamp": "%(asctime)s", "level": "%(levelname)s", "message": "%(message)s"}'
        )

        handler = logging.StreamHandler()
        handler.setFormatter(formatter)
        self.logger.addHandler(handler)

    def log(self, level: str, message: str, **kwargs):
        """è®°å½•ç»“æ„åŒ–æ—¥å¿—"""
        log_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "level": level.upper(),
            "message": message,
            **kwargs
        }

        log_message = json.dumps(log_entry)

        if level.upper() == "DEBUG":
            self.logger.debug(log_message)
        elif level.upper() == "INFO":
            self.logger.info(log_message)
        elif level.upper() == "WARNING":
            self.logger.warning(log_message)
        elif level.upper() == "ERROR":
            self.logger.error(log_message)
        elif level.upper() == "CRITICAL":
            self.logger.critical(log_message)

    def log_request(self, method: str, path: str, status_code: int,
                   duration: float, user_id: str = None):
        """è®°å½•HTTPè¯·æ±‚æ—¥å¿—"""
        self.log("INFO", "HTTP Request",
                method=method,
                path=path,
                status_code=status_code,
                duration=duration,
                user_id=user_id)

    def log_error(self, error: Exception, context: Dict = None):
        """è®°å½•é”™è¯¯æ—¥å¿—"""
        self.log("ERROR", str(error),
                error_type=type(error).__name__,
                context=context or {})

# ä½¿ç”¨ç¤ºä¾‹
logger = StructuredLogger("myapp")

def handle_request(method: str, path: str, user_id: str = None):
    start_time = time.time()

    try:
# å¤„ç†è¯·æ±‚
        result = process_request(method, path)
        status_code = 200

        logger.log_request(method, path, status_code,
                          time.time() - start_time, user_id)
        return result

    except Exception as e:
        status_code = 500
        logger.log_error(e, {"method": method, "path": path})
        raise
```

## 13. å®‰å…¨å®è·µ

### 13.1. å®¹å™¨å®‰å…¨

#### 13.1.1. é•œåƒæ‰«æ

```python
import subprocess
import json
from typing import List, Dict

class ImageScanner:
    def __init__(self, scanner_path: str = "trivy"):
        self.scanner_path = scanner_path

    def scan_image(self, image_name: str) -> Dict:
        """æ‰«æDockeré•œåƒ"""
        try:
            result = subprocess.run([
                self.scanner_path, "image", "--format", "json", image_name
            ], capture_output=True, text=True)

            if result.returncode == 0:
                return json.loads(result.stdout)
            else:
                return {"error": result.stderr}
        except Exception as e:
            return {"error": str(e)}

    def scan_vulnerabilities(self, image_name: str) -> List[Dict]:
        """æ‰«ææ¼æ´"""
        scan_result = self.scan_image(image_name)

        if "error" in scan_result:
            return []

        vulnerabilities = []
        for result in scan_result.get("Results", []):
            for vuln in result.get("Vulnerabilities", []):
                vulnerabilities.append({
                    "vulnerability_id": vuln.get("VulnerabilityID"),
                    "package_name": vuln.get("PkgName"),
                    "severity": vuln.get("Severity"),
                    "description": vuln.get("Description"),
                    "fixed_version": vuln.get("FixedVersion")
                })

        return vulnerabilities

    def check_compliance(self, image_name: str) -> Dict:
        """æ£€æŸ¥åˆè§„æ€§"""
        try:
            result = subprocess.run([
                self.scanner_path, "image", "--security-checks", "config",
                "--format", "json", image_name
            ], capture_output=True, text=True)

            if result.returncode == 0:
                return json.loads(result.stdout)
            else:
                return {"error": result.stderr}
        except Exception as e:
            return {"error": str(e)}

# ä½¿ç”¨ç¤ºä¾‹
scanner = ImageScanner()

# æ‰«æé•œåƒæ¼æ´
vulnerabilities = scanner.scan_vulnerabilities("myapp:v1.0")
for vuln in vulnerabilities:
    print(f"å‘ç°æ¼æ´: {vuln['vulnerability_id']} - {vuln['severity']}")

# æ£€æŸ¥åˆè§„æ€§
compliance = scanner.check_compliance("myapp:v1.0")
print(f"åˆè§„æ€§æ£€æŸ¥ç»“æœ: {compliance}")
```

## 14. è¿è¡Œæ—¶å®‰å…¨

```python
import psutil
import os
from typing import List, Dict

class RuntimeSecurityMonitor:
    def __init__(self):
        self.suspicious_processes = [
            "nc", "netcat", "telnet", "ssh", "scp", "wget", "curl"
        ]

    def check_suspicious_processes(self) -> List[Dict]:
        """æ£€æŸ¥å¯ç–‘è¿›ç¨‹"""
        suspicious = []

        for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
            try:
                if proc.info['name'] in self.suspicious_processes:
                    suspicious.append({
                        "pid": proc.info['pid'],
                        "name": proc.info['name'],
                        "cmdline": proc.info['cmdline']
                    })
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue

        return suspicious

    def check_network_connections(self) -> List[Dict]:
        """æ£€æŸ¥ç½‘ç»œè¿æ¥"""
        connections = []

        for conn in psutil.net_connections():
            if conn.status == 'ESTABLISHED':
                connections.append({
                    "local_address": f"{conn.laddr.ip}:{conn.laddr.port}",
                    "remote_address": f"{conn.raddr.ip}:{conn.raddr.port}",
                    "pid": conn.pid
                })

        return connections

    def check_file_permissions(self, path: str) -> Dict:
        """æ£€æŸ¥æ–‡ä»¶æƒé™"""
        try:
            stat = os.stat(path)
            return {
                "path": path,
                "mode": oct(stat.st_mode),
                "uid": stat.st_uid,
                "gid": stat.st_gid,
                "is_world_writable": bool(stat.st_mode & 0o002)
            }
        except Exception as e:
            return {"error": str(e)}

    def monitor_container_resources(self) -> Dict:
        """ç›‘æ§å®¹å™¨èµ„æºä½¿ç”¨"""
        return {
            "cpu_percent": psutil.cpu_percent(interval=1),
            "memory_percent": psutil.virtual_memory().percent,
            "disk_percent": psutil.disk_usage('/').percent,
            "network_io": psutil.net_io_counters()._asdict()
        }

# ä½¿ç”¨ç¤ºä¾‹
security_monitor = RuntimeSecurityMonitor()

# æ£€æŸ¥å¯ç–‘è¿›ç¨‹
suspicious = security_monitor.check_suspicious_processes()
if suspicious:
    print(f"å‘ç°å¯ç–‘è¿›ç¨‹: {suspicious}")

# ç›‘æ§èµ„æºä½¿ç”¨
resources = security_monitor.monitor_container_resources()
print(f"èµ„æºä½¿ç”¨æƒ…å†µ: {resources}")
```

## 15. ç½‘ç»œå®‰å…¨

### 15.1. ç½‘ç»œç­–ç•¥

```yaml
# network-policy.yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: myapp-network-policy
  namespace: myapp
spec:
  podSelector:
    matchLabels:
      app: myapp
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          name: ingress-nginx
    ports:
    - protocol: TCP
      port: 8080
  egress:
  - to:
    - namespaceSelector:
        matchLabels:
          name: database
    ports:
    - protocol: TCP
      port: 5432
  - to:
    - namespaceSelector:
        matchLabels:
          name: redis
    ports:
    - protocol: TCP
      port: 6379
```

## 16. æ€§èƒ½ä¼˜åŒ–

### 16.1. èµ„æºç®¡ç†

#### 16.1.1. èµ„æºé™åˆ¶å’Œè¯·æ±‚

```yaml
# resource-limits.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  template:
    spec:
      containers:
      - name: myapp
        image: myapp:v1.0
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
```

## 17. æ°´å¹³Podè‡ªåŠ¨æ‰©ç¼©å®¹ (HPA)

```yaml
# hpa.yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: myapp-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: myapp
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
```

## 18. ç¼“å­˜ç­–ç•¥

### 18.1. Redisé›†ç¾¤é…ç½®

```python
import redis
from redis.cluster import RedisCluster
from typing import Optional, Any

class RedisClusterManager:
    def __init__(self, startup_nodes: List[Dict]):
        self.cluster = RedisCluster(startup_nodes=startup_nodes)

    def set(self, key: str, value: Any, ttl: int = 3600):
        """è®¾ç½®ç¼“å­˜"""
        try:
            self.cluster.set(key, value, ex=ttl)
            return True
        except Exception as e:
            print(f"è®¾ç½®ç¼“å­˜å¤±è´¥: {e}")
            return False

    def get(self, key: str) -> Optional[Any]:
        """è·å–ç¼“å­˜"""
        try:
            return self.cluster.get(key)
        except Exception as e:
            print(f"è·å–ç¼“å­˜å¤±è´¥: {e}")
            return None

    def delete(self, key: str) -> bool:
        """åˆ é™¤ç¼“å­˜"""
        try:
            self.cluster.delete(key)
            return True
        except Exception as e:
            print(f"åˆ é™¤ç¼“å­˜å¤±è´¥: {e}")
            return False

    def get_cluster_info(self) -> Dict:
        """è·å–é›†ç¾¤ä¿¡æ¯"""
        try:
            return self.cluster.cluster_info()
        except Exception as e:
            return {"error": str(e)}

# ä½¿ç”¨ç¤ºä¾‹
startup_nodes = [
    {"host": "redis-node-1", "port": 6379},
    {"host": "redis-node-2", "port": 6379},
    {"host": "redis-node-3", "port": 6379}
]

redis_manager = RedisClusterManager(startup_nodes)
redis_manager.set("user:123", "user_data", ttl=3600)
user_data = redis_manager.get("user:123")
```

## 19. æ€»ç»“ä¸å±•æœ›

äº‘åŸç”Ÿæ¶æ„ä½œä¸ºç°ä»£è½¯ä»¶å¼€å‘çš„æ ¸å¿ƒç†å¿µï¼Œåœ¨æé«˜ç³»ç»Ÿå¯æ‰©å±•æ€§ã€å¯é æ€§å’Œå¼€å‘æ•ˆç‡æ–¹é¢å‘æŒ¥ç€é‡è¦ä½œç”¨ã€‚æœªæ¥çš„å‘å±•æ–¹å‘åŒ…æ‹¬ï¼š

1. **æœåŠ¡ç½‘æ ¼æˆç†Ÿ**ï¼šIstioã€Linkerdç­‰æœåŠ¡ç½‘æ ¼æŠ€æœ¯çš„å¹¿æ³›åº”ç”¨
2. **æ— æœåŠ¡å™¨æ¶æ„**ï¼šServerlessä¸äº‘åŸç”Ÿçš„æ·±åº¦èåˆ
3. **è¾¹ç¼˜è®¡ç®—**ï¼šäº‘åŸç”ŸæŠ€æœ¯åœ¨è¾¹ç¼˜è®¡ç®—åœºæ™¯çš„åº”ç”¨
4. **AI/MLé›†æˆ**ï¼šäº‘åŸç”Ÿå¹³å°å¯¹AI/MLå·¥ä½œè´Ÿè½½çš„ä¼˜åŒ–
5. **å®‰å…¨å¢å¼º**ï¼šé›¶ä¿¡ä»»æ¶æ„ã€æœºå¯†è®¡ç®—ç­‰å®‰å…¨æŠ€æœ¯çš„é›†æˆ

## 20. å‚è€ƒæ–‡çŒ®

1. Burns, B., & Beda, J. "Kubernetes: Up and Running." O'Reilly Media, 2019.
2. Hightower, K., et al. "Kubernetes in Action." Manning Publications, 2018.
3. Richardson, C. "Microservices Patterns: With Examples in Java." Manning Publications, 2018.
4. Istio Documentation. "Service Mesh for Microservices." <https://istio.io/>
5. Cloud Native Computing Foundation. "Cloud Native Landscape." <https://landscape.cncf.io/>
