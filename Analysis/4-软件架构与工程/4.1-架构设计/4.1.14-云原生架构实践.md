# 4.1.14 云原生架构实践

## 1. 概述

云原生架构是一种充分利用云计算优势的软件架构方法，强调容器化、微服务、DevOps和持续交付。本文档从理论基础、技术栈、实践模式和工程实现四个维度深入分析云原生架构。

## 2. 理论基础

### 2.1. 云原生定义

**定义 2.1.1** (云原生)
云原生是一种构建和运行应用程序的方法，充分利用云计算模型的优势，具有以下特征：

- 容器化：应用程序打包在容器中运行
- 微服务：应用程序分解为小型、松耦合的服务
- 不可变基础设施：通过声明式配置管理基础设施
- 声明式API：通过API声明期望状态

**定理 2.1.1** (云原生弹性定理)
对于云原生应用 $A$，其弹性能力 $E(A)$ 满足：
$$E(A) = \frac{\text{Scale}(A) \times \text{Resilience}(A) \times \text{Observability}(A)}{\text{Complexity}(A)}$$

其中 $\text{Scale}$ 表示可扩展性，$\text{Resilience}$ 表示弹性，$\text{Observability}$ 表示可观测性，$\text{Complexity}$ 表示复杂度。

### 2.2. 云原生原则

#### 2.2.1. -Factor应用原则

1. **代码库**：一个代码库，多个部署
2. **依赖**：显式声明和隔离依赖
3. **配置**：在环境中存储配置
4. **后端服务**：将后端服务视为附加资源
5. **构建、发布、运行**：严格分离构建和运行阶段
6. **进程**：以一个或多个无状态进程运行应用
7. **端口绑定**：通过端口绑定提供服务
8. **并发**：通过进程模型进行扩展
9. **易处理**：快速启动和优雅关闭
10. **开发/生产环境等价**：保持开发、预发布、生产环境相似
11. **日志**：将日志视为事件流
12. **管理进程**：将管理/管理任务作为一次性进程运行

## 3. 核心技术栈

### 3.1. 容器技术

#### 3.1.1. Docker深度实践

```python
import docker
import yaml
from typing import Dict, List

class DockerManager:
    def __init__(self):
        self.client = docker.from_env()

    def build_image(self, dockerfile_path: str, tag: str, build_args: Dict = None):
        """构建Docker镜像"""
        try:
            image, logs = self.client.images.build(
                path=dockerfile_path,
                tag=tag,
                buildargs=build_args or {},
                rm=True
            )
            return image
        except Exception as e:
            print(f"构建失败: {e}")
            return None

    def run_container(self, image_name: str, container_name: str,
                     ports: Dict = None, environment: Dict = None,
                     volumes: Dict = None, network: str = None):
        """运行容器"""
        try:
            container = self.client.containers.run(
                image_name,
                name=container_name,
                ports=ports or {},
                environment=environment or {},
                volumes=volumes or {},
                network=network,
                detach=True,
                restart_policy={"Name": "unless-stopped"}
            )
            return container
        except Exception as e:
            print(f"运行容器失败: {e}")
            return None

    def create_network(self, name: str, driver: str = "bridge"):
        """创建网络"""
        try:
            network = self.client.networks.create(name, driver=driver)
            return network
        except Exception as e:
            print(f"创建网络失败: {e}")
            return None

    def cleanup_containers(self, filters: Dict = None):
        """清理容器"""
        containers = self.client.containers.list(filters=filters or {})
        for container in containers:
            try:
                container.remove(force=True)
            except Exception as e:
                print(f"清理容器失败: {e}")

# 使用示例
docker_manager = DockerManager()

# 构建镜像
image = docker_manager.build_image(
    dockerfile_path="./app",
    tag="myapp:v1.0",
    build_args={"VERSION": "1.0.0"}
)

# 运行容器
container = docker_manager.run_container(
    image_name="myapp:v1.0",
    container_name="myapp-container",
    ports={"8080/tcp": 8080},
    environment={"NODE_ENV": "production"},
    volumes={"/host/path": {"bind": "/container/path", "mode": "rw"}}
)
```

## 4. 多阶段构建优化

```dockerfile
# 多阶段构建示例
FROM golang:1.21-alpine AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download

COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main .

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/

COPY --from=builder /app/main .
COPY --from=builder /app/config ./config

EXPOSE 8080
CMD ["./main"]
```

## 5. Kubernetes深度集成

### 5.1. Kubernetes API客户端

```python
from kubernetes import client, config, watch
from kubernetes.client.rest import ApiException
import yaml
from typing import Dict, List, Optional

class KubernetesManager:
    def __init__(self, config_file: str = None):
        if config_file:
            config.load_kube_config(config_file)
        else:
            config.load_incluster_config()

        self.v1 = client.CoreV1Api()
        self.apps_v1 = client.AppsV1Api()
        self.networking_v1 = client.NetworkingV1Api()

    def create_namespace(self, name: str, labels: Dict = None):
        """创建命名空间"""
        try:
            namespace = client.V1Namespace(
                metadata=client.V1ObjectMeta(
                    name=name,
                    labels=labels or {}
                )
            )
            result = self.v1.create_namespace(namespace)
            return result
        except ApiException as e:
            print(f"创建命名空间失败: {e}")
            return None

    def create_deployment(self, name: str, namespace: str,
                         image: str, replicas: int = 3,
                         ports: List[int] = None):
        """创建Deployment"""
        try:
            containers = []
            for i, port in enumerate(ports or [8080]):
                containers.append(client.V1Container(
                    name=f"{name}-container-{i}",
                    image=image,
                    ports=[client.V1ContainerPort(container_port=port)]
                ))

            deployment = client.V1Deployment(
                metadata=client.V1ObjectMeta(name=name),
                spec=client.V1DeploymentSpec(
                    replicas=replicas,
                    selector=client.V1LabelSelector(
                        match_labels={"app": name}
                    ),
                    template=client.V1PodTemplateSpec(
                        metadata=client.V1ObjectMeta(
                            labels={"app": name}
                        ),
                        spec=client.V1PodSpec(containers=containers)
                    )
                )
            )

            result = self.apps_v1.create_namespaced_deployment(
                namespace=namespace,
                body=deployment
            )
            return result
        except ApiException as e:
            print(f"创建Deployment失败: {e}")
            return None

    def create_service(self, name: str, namespace: str,
                      selector: Dict, ports: List[Dict]):
        """创建Service"""
        try:
            service_ports = []
            for port in ports:
                service_ports.append(client.V1ServicePort(
                    port=port["port"],
                    target_port=port["target_port"],
                    protocol=port.get("protocol", "TCP")
                ))

            service = client.V1Service(
                metadata=client.V1ObjectMeta(name=name),
                spec=client.V1ServiceSpec(
                    selector=selector,
                    ports=service_ports,
                    type="ClusterIP"
                )
            )

            result = self.v1.create_namespaced_service(
                namespace=namespace,
                body=service
            )
            return result
        except ApiException as e:
            print(f"创建Service失败: {e}")
            return None

    def create_ingress(self, name: str, namespace: str,
                      rules: List[Dict], annotations: Dict = None):
        """创建Ingress"""
        try:
            ingress_rules = []
            for rule in rules:
                ingress_rules.append(client.V1IngressRule(
                    host=rule["host"],
                    http=client.V1HTTPIngressRuleValue(
                        paths=[
                            client.V1HTTPIngressPath(
                                path=path["path"],
                                path_type=path.get("path_type", "Prefix"),
                                backend=client.V1IngressBackend(
                                    service=client.V1IngressServiceBackend(
                                        name=path["service_name"],
                                        port=client.V1ServiceBackendPort(
                                            number=path["service_port"]
                                        )
                                    )
                                )
                            ) for path in rule["paths"]
                        ]
                    )
                ))

            ingress = client.V1Ingress(
                metadata=client.V1ObjectMeta(
                    name=name,
                    annotations=annotations or {}
                ),
                spec=client.V1IngressSpec(rules=ingress_rules)
            )

            result = self.networking_v1.create_namespaced_ingress(
                namespace=namespace,
                body=ingress
            )
            return result
        except ApiException as e:
            print(f"创建Ingress失败: {e}")
            return None

    def scale_deployment(self, name: str, namespace: str, replicas: int):
        """扩缩容Deployment"""
        try:
            self.apps_v1.patch_namespaced_deployment_scale(
                name=name,
                namespace=namespace,
                body={"spec": {"replicas": replicas}}
            )
            return True
        except ApiException as e:
            print(f"扩缩容失败: {e}")
            return False

    def get_pod_logs(self, pod_name: str, namespace: str,
                    container: str = None, tail_lines: int = 100):
        """获取Pod日志"""
        try:
            logs = self.v1.read_namespaced_pod_log(
                name=pod_name,
                namespace=namespace,
                container=container,
                tail_lines=tail_lines
            )
            return logs
        except ApiException as e:
            print(f"获取日志失败: {e}")
            return None

# 使用示例
k8s_manager = KubernetesManager()

# 创建应用
namespace = k8s_manager.create_namespace("myapp")
deployment = k8s_manager.create_deployment(
    name="myapp",
    namespace="myapp",
    image="myapp:v1.0",
    replicas=3,
    ports=[8080]
)
service = k8s_manager.create_service(
    name="myapp-service",
    namespace="myapp",
    selector={"app": "myapp"},
    ports=[{"port": 80, "target_port": 8080}]
)
```

## 6. 自定义资源定义 (CRD)

```python
from kubernetes import client, config
from kubernetes.client import V1CustomResourceDefinition
from kubernetes.client import V1CustomResourceDefinitionSpec
from kubernetes.client import V1CustomResourceDefinitionNames
from kubernetes.client import V1CustomResourceDefinitionVersion

class CustomResourceManager:
    def __init__(self):
        config.load_incluster_config()
        self.apiextensions_v1 = client.ApiextensionsV1Api()

    def create_crd(self, group: str, version: str, plural: str,
                   singular: str, kind: str, scope: str = "Namespaced"):
        """创建自定义资源定义"""
        try:
            crd = V1CustomResourceDefinition(
                metadata=client.V1ObjectMeta(name=f"{plural}.{group}"),
                spec=V1CustomResourceDefinitionSpec(
                    group=group,
                    names=V1CustomResourceDefinitionNames(
                        plural=plural,
                        singular=singular,
                        kind=kind,
                        short_names=[plural]
                    ),
                    scope=scope,
                    versions=[
                        V1CustomResourceDefinitionVersion(
                            name=version,
                            served=True,
                            storage=True,
                            schema=client.V1JSONSchemaProps(
                                type="object",
                                properties={
                                    "spec": client.V1JSONSchemaProps(
                                        type="object",
                                        properties={
                                            "replicas": client.V1JSONSchemaProps(
                                                type="integer",
                                                minimum=1
                                            ),
                                            "image": client.V1JSONSchemaProps(
                                                type="string"
                                            )
                                        }
                                    )
                                }
                            )
                        )
                    ]
                )
            )

            result = self.apiextensions_v1.create_custom_resource_definition(crd)
            return result
        except Exception as e:
            print(f"创建CRD失败: {e}")
            return None

# 使用示例
crd_manager = CustomResourceManager()
crd = crd_manager.create_crd(
    group="example.com",
    version="v1",
    plural="applications",
    singular="application",
    kind="Application"
)
```

## 7. 服务网格 (Service Mesh)

### 7.1. Istio集成

```python
import yaml
from kubernetes import client, config
from typing import Dict, List

class IstioManager:
    def __init__(self):
        config.load_incluster_config()
        self.networking_v1beta1 = client.NetworkingV1beta1Api()
        self.security_v1beta1 = client.SecurityV1beta1Api()

    def create_virtual_service(self, name: str, namespace: str,
                              hosts: List[str], gateways: List[str],
                              routes: List[Dict]):
        """创建VirtualService"""
        try:
            http_routes = []
            for route in routes:
                http_routes.append({
                    "match": route.get("match", []),
                    "route": route.get("route", []),
                    "retries": route.get("retries"),
                    "timeout": route.get("timeout")
                })

            virtual_service = {
                "apiVersion": "networking.istio.io/v1beta1",
                "kind": "VirtualService",
                "metadata": {
                    "name": name,
                    "namespace": namespace
                },
                "spec": {
                    "hosts": hosts,
                    "gateways": gateways,
                    "http": http_routes
                }
            }

# 使用动态客户端创建资源
            dynamic_client = client.CustomObjectsApi()
            result = dynamic_client.create_namespaced_custom_object(
                group="networking.istio.io",
                version="v1beta1",
                namespace=namespace,
                plural="virtualservices",
                body=virtual_service
            )
            return result
        except Exception as e:
            print(f"创建VirtualService失败: {e}")
            return None

    def create_destination_rule(self, name: str, namespace: str,
                               host: str, subsets: List[Dict]):
        """创建DestinationRule"""
        try:
            destination_rule = {
                "apiVersion": "networking.istio.io/v1beta1",
                "kind": "DestinationRule",
                "metadata": {
                    "name": name,
                    "namespace": namespace
                },
                "spec": {
                    "host": host,
                    "subsets": subsets
                }
            }

            dynamic_client = client.CustomObjectsApi()
            result = dynamic_client.create_namespaced_custom_object(
                group="networking.istio.io",
                version="v1beta1",
                namespace=namespace,
                plural="destinationrules",
                body=destination_rule
            )
            return result
        except Exception as e:
            print(f"创建DestinationRule失败: {e}")
            return None

    def create_authorization_policy(self, name: str, namespace: str,
                                   selector: Dict, rules: List[Dict]):
        """创建AuthorizationPolicy"""
        try:
            auth_policy = {
                "apiVersion": "security.istio.io/v1beta1",
                "kind": "AuthorizationPolicy",
                "metadata": {
                    "name": name,
                    "namespace": namespace
                },
                "spec": {
                    "selector": selector,
                    "rules": rules
                }
            }

            dynamic_client = client.CustomObjectsApi()
            result = dynamic_client.create_namespaced_custom_object(
                group="security.istio.io",
                version="v1beta1",
                namespace=namespace,
                plural="authorizationpolicies",
                body=auth_policy
            )
            return result
        except Exception as e:
            print(f"创建AuthorizationPolicy失败: {e}")
            return None

# 使用示例
istio_manager = IstioManager()

# 创建金丝雀发布配置
virtual_service = istio_manager.create_virtual_service(
    name="myapp-vs",
    namespace="myapp",
    hosts=["myapp.example.com"],
    gateways=["myapp-gateway"],
    routes=[
        {
            "route": [
                {"destination": {"host": "myapp", "subset": "v1"}, "weight": 90},
                {"destination": {"host": "myapp", "subset": "v2"}, "weight": 10}
            ]
        }
    ]
)

destination_rule = istio_manager.create_destination_rule(
    name="myapp-dr",
    namespace="myapp",
    host="myapp",
    subsets=[
        {"name": "v1", "labels": {"version": "v1"}},
        {"name": "v2", "labels": {"version": "v2"}}
    ]
)
```

## 8. 配置管理

### 8.1. ConfigMap和Secret管理

```python
class ConfigManager:
    def __init__(self):
        config.load_incluster_config()
        self.v1 = client.CoreV1Api()

    def create_configmap(self, name: str, namespace: str, data: Dict):
        """创建ConfigMap"""
        try:
            configmap = client.V1ConfigMap(
                metadata=client.V1ObjectMeta(name=name),
                data=data
            )

            result = self.v1.create_namespaced_config_map(
                namespace=namespace,
                body=configmap
            )
            return result
        except ApiException as e:
            print(f"创建ConfigMap失败: {e}")
            return None

    def create_secret(self, name: str, namespace: str,
                     data: Dict, secret_type: str = "Opaque"):
        """创建Secret"""
        try:
            secret = client.V1Secret(
                metadata=client.V1ObjectMeta(name=name),
                type=secret_type,
                data=data
            )

            result = self.v1.create_namespaced_secret(
                namespace=namespace,
                body=secret
            )
            return result
        except ApiException as e:
            print(f"创建Secret失败: {e}")
            return None

    def update_configmap(self, name: str, namespace: str, data: Dict):
        """更新ConfigMap"""
        try:
            configmap = self.v1.read_namespaced_config_map(
                name=name,
                namespace=namespace
            )
            configmap.data.update(data)

            result = self.v1.replace_namespaced_config_map(
                name=name,
                namespace=namespace,
                body=configmap
            )
            return result
        except ApiException as e:
            print(f"更新ConfigMap失败: {e}")
            return None

# 使用示例
config_manager = ConfigManager()

# 创建应用配置
configmap = config_manager.create_configmap(
    name="myapp-config",
    namespace="myapp",
    data={
        "database_url": "postgresql://user:pass@db:5432/myapp",
        "redis_url": "redis://redis:6379",
        "log_level": "INFO"
    }
)

# 创建敏感信息
secret = config_manager.create_secret(
    name="myapp-secret",
    namespace="myapp",
    data={
        "database_password": "cGFzc3dvcmQ=",  # base64编码
        "api_key": "YXBpLWtleQ=="
    }
)
```

## 9. DevOps实践

### 9.1. CI/CD流水线

#### 9.1.1. GitHub Actions集成

```yaml
# .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-cov

    - name: Run tests
      run: |
        pytest --cov=./ --cov-report=xml

    - name: Upload coverage
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml

  build:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
    - uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
    - uses: actions/checkout@v4

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'

    - name: Configure kubectl
      run: |
        echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > kubeconfig
        export KUBECONFIG=kubeconfig

    - name: Deploy to Kubernetes
      run: |
        kubectl set image deployment/myapp myapp=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
        kubectl rollout status deployment/myapp
```

## 10. ArgoCD集成

```yaml
# argocd-app.yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: myapp
  namespace: argocd
spec:
  project: default
  source:
    repoURL: https://github.com/username/repo
    targetRevision: HEAD
    path: k8s
  destination:
    server: https://kubernetes.default.svc
    namespace: myapp
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
    - CreateNamespace=true
    retry:
      limit: 5
      backoff:
        duration: 5s
        factor: 2
        maxDuration: 3m
```

## 11. 监控与可观测性

### 11.1. Prometheus集成

```python
from prometheus_client import Counter, Histogram, Gauge, start_http_server
import time
from functools import wraps

class MetricsCollector:
    def __init__(self):
        self.request_count = Counter('http_requests_total', 'Total HTTP requests', ['method', 'endpoint', 'status'])
        self.request_duration = Histogram('http_request_duration_seconds', 'HTTP request duration')
        self.active_connections = Gauge('active_connections', 'Number of active connections')
        self.memory_usage = Gauge('memory_usage_bytes', 'Memory usage in bytes')

    def track_request(self, method: str, endpoint: str, status: int):
        """记录请求指标"""
        self.request_count.labels(method=method, endpoint=endpoint, status=status).inc()

    def track_duration(self, duration: float):
        """记录请求持续时间"""
        self.request_duration.observe(duration)

    def set_active_connections(self, count: int):
        """设置活跃连接数"""
        self.active_connections.set(count)

    def set_memory_usage(self, bytes_used: int):
        """设置内存使用量"""
        self.memory_usage.set(bytes_used)

# 全局指标收集器
metrics = MetricsCollector()

def monitor_request(f):
    """请求监控装饰器"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        start_time = time.time()

        try:
            result = f(*args, **kwargs)
            status = 200
        except Exception as e:
            status = 500
            raise e
        finally:
            duration = time.time() - start_time
            metrics.track_duration(duration)
            metrics.track_request('GET', f.__name__, status)

        return result
    return decorated_function

# 启动Prometheus指标服务器
start_http_server(8000)
```

## 12. Grafana仪表板

```json
{
  "dashboard": {
    "id": null,
    "title": "Application Metrics",
    "tags": ["application", "monitoring"],
    "timezone": "browser",
    "panels": [
      {
        "id": 1,
        "title": "Request Rate",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(http_requests_total[5m])",
            "legendFormat": "{{method}} {{endpoint}}"
          }
        ]
      },
      {
        "id": 2,
        "title": "Response Time",
        "type": "graph",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))",
            "legendFormat": "95th percentile"
          }
        ]
      },
      {
        "id": 3,
        "title": "Memory Usage",
        "type": "graph",
        "targets": [
          {
            "expr": "memory_usage_bytes",
            "legendFormat": "Memory Usage"
          }
        ]
      }
    ]
  }
}
```

### 12.1. 日志管理

#### 12.1.1. 结构化日志

```python
import logging
import json
from datetime import datetime
from typing import Dict, Any

class StructuredLogger:
    def __init__(self, name: str, level: int = logging.INFO):
        self.logger = logging.getLogger(name)
        self.logger.setLevel(level)

# 配置JSON格式化器
        formatter = logging.Formatter(
            '{"timestamp": "%(asctime)s", "level": "%(levelname)s", "message": "%(message)s"}'
        )

        handler = logging.StreamHandler()
        handler.setFormatter(formatter)
        self.logger.addHandler(handler)

    def log(self, level: str, message: str, **kwargs):
        """记录结构化日志"""
        log_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "level": level.upper(),
            "message": message,
            **kwargs
        }

        log_message = json.dumps(log_entry)

        if level.upper() == "DEBUG":
            self.logger.debug(log_message)
        elif level.upper() == "INFO":
            self.logger.info(log_message)
        elif level.upper() == "WARNING":
            self.logger.warning(log_message)
        elif level.upper() == "ERROR":
            self.logger.error(log_message)
        elif level.upper() == "CRITICAL":
            self.logger.critical(log_message)

    def log_request(self, method: str, path: str, status_code: int,
                   duration: float, user_id: str = None):
        """记录HTTP请求日志"""
        self.log("INFO", "HTTP Request",
                method=method,
                path=path,
                status_code=status_code,
                duration=duration,
                user_id=user_id)

    def log_error(self, error: Exception, context: Dict = None):
        """记录错误日志"""
        self.log("ERROR", str(error),
                error_type=type(error).__name__,
                context=context or {})

# 使用示例
logger = StructuredLogger("myapp")

def handle_request(method: str, path: str, user_id: str = None):
    start_time = time.time()

    try:
# 处理请求
        result = process_request(method, path)
        status_code = 200

        logger.log_request(method, path, status_code,
                          time.time() - start_time, user_id)
        return result

    except Exception as e:
        status_code = 500
        logger.log_error(e, {"method": method, "path": path})
        raise
```

## 13. 安全实践

### 13.1. 容器安全

#### 13.1.1. 镜像扫描

```python
import subprocess
import json
from typing import List, Dict

class ImageScanner:
    def __init__(self, scanner_path: str = "trivy"):
        self.scanner_path = scanner_path

    def scan_image(self, image_name: str) -> Dict:
        """扫描Docker镜像"""
        try:
            result = subprocess.run([
                self.scanner_path, "image", "--format", "json", image_name
            ], capture_output=True, text=True)

            if result.returncode == 0:
                return json.loads(result.stdout)
            else:
                return {"error": result.stderr}
        except Exception as e:
            return {"error": str(e)}

    def scan_vulnerabilities(self, image_name: str) -> List[Dict]:
        """扫描漏洞"""
        scan_result = self.scan_image(image_name)

        if "error" in scan_result:
            return []

        vulnerabilities = []
        for result in scan_result.get("Results", []):
            for vuln in result.get("Vulnerabilities", []):
                vulnerabilities.append({
                    "vulnerability_id": vuln.get("VulnerabilityID"),
                    "package_name": vuln.get("PkgName"),
                    "severity": vuln.get("Severity"),
                    "description": vuln.get("Description"),
                    "fixed_version": vuln.get("FixedVersion")
                })

        return vulnerabilities

    def check_compliance(self, image_name: str) -> Dict:
        """检查合规性"""
        try:
            result = subprocess.run([
                self.scanner_path, "image", "--security-checks", "config",
                "--format", "json", image_name
            ], capture_output=True, text=True)

            if result.returncode == 0:
                return json.loads(result.stdout)
            else:
                return {"error": result.stderr}
        except Exception as e:
            return {"error": str(e)}

# 使用示例
scanner = ImageScanner()

# 扫描镜像漏洞
vulnerabilities = scanner.scan_vulnerabilities("myapp:v1.0")
for vuln in vulnerabilities:
    print(f"发现漏洞: {vuln['vulnerability_id']} - {vuln['severity']}")

# 检查合规性
compliance = scanner.check_compliance("myapp:v1.0")
print(f"合规性检查结果: {compliance}")
```

## 14. 运行时安全

```python
import psutil
import os
from typing import List, Dict

class RuntimeSecurityMonitor:
    def __init__(self):
        self.suspicious_processes = [
            "nc", "netcat", "telnet", "ssh", "scp", "wget", "curl"
        ]

    def check_suspicious_processes(self) -> List[Dict]:
        """检查可疑进程"""
        suspicious = []

        for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
            try:
                if proc.info['name'] in self.suspicious_processes:
                    suspicious.append({
                        "pid": proc.info['pid'],
                        "name": proc.info['name'],
                        "cmdline": proc.info['cmdline']
                    })
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue

        return suspicious

    def check_network_connections(self) -> List[Dict]:
        """检查网络连接"""
        connections = []

        for conn in psutil.net_connections():
            if conn.status == 'ESTABLISHED':
                connections.append({
                    "local_address": f"{conn.laddr.ip}:{conn.laddr.port}",
                    "remote_address": f"{conn.raddr.ip}:{conn.raddr.port}",
                    "pid": conn.pid
                })

        return connections

    def check_file_permissions(self, path: str) -> Dict:
        """检查文件权限"""
        try:
            stat = os.stat(path)
            return {
                "path": path,
                "mode": oct(stat.st_mode),
                "uid": stat.st_uid,
                "gid": stat.st_gid,
                "is_world_writable": bool(stat.st_mode & 0o002)
            }
        except Exception as e:
            return {"error": str(e)}

    def monitor_container_resources(self) -> Dict:
        """监控容器资源使用"""
        return {
            "cpu_percent": psutil.cpu_percent(interval=1),
            "memory_percent": psutil.virtual_memory().percent,
            "disk_percent": psutil.disk_usage('/').percent,
            "network_io": psutil.net_io_counters()._asdict()
        }

# 使用示例
security_monitor = RuntimeSecurityMonitor()

# 检查可疑进程
suspicious = security_monitor.check_suspicious_processes()
if suspicious:
    print(f"发现可疑进程: {suspicious}")

# 监控资源使用
resources = security_monitor.monitor_container_resources()
print(f"资源使用情况: {resources}")
```

## 15. 网络安全

### 15.1. 网络策略

```yaml
# network-policy.yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: myapp-network-policy
  namespace: myapp
spec:
  podSelector:
    matchLabels:
      app: myapp
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          name: ingress-nginx
    ports:
    - protocol: TCP
      port: 8080
  egress:
  - to:
    - namespaceSelector:
        matchLabels:
          name: database
    ports:
    - protocol: TCP
      port: 5432
  - to:
    - namespaceSelector:
        matchLabels:
          name: redis
    ports:
    - protocol: TCP
      port: 6379
```

## 16. 性能优化

### 16.1. 资源管理

#### 16.1.1. 资源限制和请求

```yaml
# resource-limits.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  template:
    spec:
      containers:
      - name: myapp
        image: myapp:v1.0
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
```

## 17. 水平Pod自动扩缩容 (HPA)

```yaml
# hpa.yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: myapp-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: myapp
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
```

## 18. 缓存策略

### 18.1. Redis集群配置

```python
import redis
from redis.cluster import RedisCluster
from typing import Optional, Any

class RedisClusterManager:
    def __init__(self, startup_nodes: List[Dict]):
        self.cluster = RedisCluster(startup_nodes=startup_nodes)

    def set(self, key: str, value: Any, ttl: int = 3600):
        """设置缓存"""
        try:
            self.cluster.set(key, value, ex=ttl)
            return True
        except Exception as e:
            print(f"设置缓存失败: {e}")
            return False

    def get(self, key: str) -> Optional[Any]:
        """获取缓存"""
        try:
            return self.cluster.get(key)
        except Exception as e:
            print(f"获取缓存失败: {e}")
            return None

    def delete(self, key: str) -> bool:
        """删除缓存"""
        try:
            self.cluster.delete(key)
            return True
        except Exception as e:
            print(f"删除缓存失败: {e}")
            return False

    def get_cluster_info(self) -> Dict:
        """获取集群信息"""
        try:
            return self.cluster.cluster_info()
        except Exception as e:
            return {"error": str(e)}

# 使用示例
startup_nodes = [
    {"host": "redis-node-1", "port": 6379},
    {"host": "redis-node-2", "port": 6379},
    {"host": "redis-node-3", "port": 6379}
]

redis_manager = RedisClusterManager(startup_nodes)
redis_manager.set("user:123", "user_data", ttl=3600)
user_data = redis_manager.get("user:123")
```

## 19. 总结与展望

云原生架构作为现代软件开发的核心理念，在提高系统可扩展性、可靠性和开发效率方面发挥着重要作用。未来的发展方向包括：

1. **服务网格成熟**：Istio、Linkerd等服务网格技术的广泛应用
2. **无服务器架构**：Serverless与云原生的深度融合
3. **边缘计算**：云原生技术在边缘计算场景的应用
4. **AI/ML集成**：云原生平台对AI/ML工作负载的优化
5. **安全增强**：零信任架构、机密计算等安全技术的集成

## 20. 参考文献

1. Burns, B., & Beda, J. "Kubernetes: Up and Running." O'Reilly Media, 2019.
2. Hightower, K., et al. "Kubernetes in Action." Manning Publications, 2018.
3. Richardson, C. "Microservices Patterns: With Examples in Java." Manning Publications, 2018.
4. Istio Documentation. "Service Mesh for Microservices." <https://istio.io/>
5. Cloud Native Computing Foundation. "Cloud Native Landscape." <https://landscape.cncf.io/>
