# 4.1.13 å¾®æœåŠ¡æ¶æ„è®¾è®¡

## ğŸ“‘ ç›®å½•

- [4.1.13 å¾®æœåŠ¡æ¶æ„è®¾è®¡](#4113-å¾®æœåŠ¡æ¶æ„è®¾è®¡)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2. ç†è®ºåŸºç¡€](#2-ç†è®ºåŸºç¡€)
    - [2.1. å¾®æœåŠ¡å®šä¹‰](#21-å¾®æœåŠ¡å®šä¹‰)
    - [2.2. æ¶æ„åŸåˆ™](#22-æ¶æ„åŸåˆ™)
      - [2.2.1. å•ä¸€èŒè´£åŸåˆ™](#221-å•ä¸€èŒè´£åŸåˆ™)
      - [2.2.2. è‡ªæ²»æ€§åŸåˆ™](#222-è‡ªæ²»æ€§åŸåˆ™)
      - [2.2.3. æ•°æ®ä¸€è‡´æ€§åŸåˆ™](#223-æ•°æ®ä¸€è‡´æ€§åŸåˆ™)
  - [3. æ ¸å¿ƒè®¾è®¡æ¨¡å¼](#3-æ ¸å¿ƒè®¾è®¡æ¨¡å¼)
    - [3.1. æœåŠ¡å‘ç°æ¨¡å¼](#31-æœåŠ¡å‘ç°æ¨¡å¼)
      - [3.1.1. å®¢æˆ·ç«¯æœåŠ¡å‘ç°](#311-å®¢æˆ·ç«¯æœåŠ¡å‘ç°)
  - [4. æœåŠ¡ç«¯æœåŠ¡å‘ç°](#4-æœåŠ¡ç«¯æœåŠ¡å‘ç°)
  - [5. é…ç½®ç®¡ç†æ¨¡å¼](#5-é…ç½®ç®¡ç†æ¨¡å¼)
    - [5.1. å¤–éƒ¨åŒ–é…ç½®](#51-å¤–éƒ¨åŒ–é…ç½®)
  - [6. é…ç½®ä¸­å¿ƒé›†æˆ](#6-é…ç½®ä¸­å¿ƒé›†æˆ)
    - [6.1. æ–­è·¯å™¨æ¨¡å¼](#61-æ–­è·¯å™¨æ¨¡å¼)
      - [6.1.1. æ–­è·¯å™¨å®ç°](#611-æ–­è·¯å™¨å®ç°)
  - [7. äº‹ä»¶é©±åŠ¨æ¨¡å¼](#7-äº‹ä»¶é©±åŠ¨æ¨¡å¼)
    - [7.1. äº‹ä»¶æ€»çº¿å®ç°](#71-äº‹ä»¶æ€»çº¿å®ç°)
  - [8. æŠ€æœ¯å®ç°](#8-æŠ€æœ¯å®ç°)
    - [8.1. æœåŠ¡é—´é€šä¿¡](#81-æœåŠ¡é—´é€šä¿¡)
      - [8.1.1. RESTful API](#811-restful-api)
  - [9. gRPCé€šä¿¡](#9-grpcé€šä¿¡)
  - [10. æ•°æ®ç®¡ç†](#10-æ•°æ®ç®¡ç†)
    - [10.1. æ•°æ®åº“ per Service](#101-æ•°æ®åº“-per-service)
      - [10.1.1. äº‹ä»¶æº¯æº](#1011-äº‹ä»¶æº¯æº)
    - [10.2. ç›‘æ§ä¸å¯è§‚æµ‹æ€§](#102-ç›‘æ§ä¸å¯è§‚æµ‹æ€§)
      - [10.2.1. åˆ†å¸ƒå¼è¿½è¸ª](#1021-åˆ†å¸ƒå¼è¿½è¸ª)
  - [11. å¥åº·æ£€æŸ¥](#11-å¥åº·æ£€æŸ¥)
  - [12. éƒ¨ç½²ä¸è¿ç»´](#12-éƒ¨ç½²ä¸è¿ç»´)
    - [12.1. å®¹å™¨åŒ–éƒ¨ç½²](#121-å®¹å™¨åŒ–éƒ¨ç½²)
      - [12.1.1. Dockeré…ç½®](#1211-dockeré…ç½®)
  - [13. Kuberneteséƒ¨ç½²](#13-kuberneteséƒ¨ç½²)
    - [13.1. éƒ¨ç½²é…ç½®](#131-éƒ¨ç½²é…ç½®)
  - [14. æœåŠ¡ç½‘æ ¼é…ç½®](#14-æœåŠ¡ç½‘æ ¼é…ç½®)
  - [15. æ€§èƒ½ä¼˜åŒ–](#15-æ€§èƒ½ä¼˜åŒ–)
    - [15.1. ç¼“å­˜ç­–ç•¥](#151-ç¼“å­˜ç­–ç•¥)
      - [15.1.1. åˆ†å¸ƒå¼ç¼“å­˜](#1511-åˆ†å¸ƒå¼ç¼“å­˜)
  - [16. è´Ÿè½½å‡è¡¡](#16-è´Ÿè½½å‡è¡¡)
    - [16.1. å®¢æˆ·ç«¯è´Ÿè½½å‡è¡¡](#161-å®¢æˆ·ç«¯è´Ÿè½½å‡è¡¡)
  - [17. å®‰å…¨è€ƒè™‘](#17-å®‰å…¨è€ƒè™‘)
    - [17.1. è®¤è¯ä¸æˆæƒ](#171-è®¤è¯ä¸æˆæƒ)
      - [17.1.1. JWTè®¤è¯](#1711-jwtè®¤è¯)
  - [18. APIç½‘å…³å®‰å…¨](#18-apiç½‘å…³å®‰å…¨)
    - [18.1. é€Ÿç‡é™åˆ¶](#181-é€Ÿç‡é™åˆ¶)
  - [19. æ€»ç»“ä¸å±•æœ›](#19-æ€»ç»“ä¸å±•æœ›)
  - [20. å‚è€ƒæ–‡çŒ®](#20-å‚è€ƒæ–‡çŒ®)

---

## 1. æ¦‚è¿°

å¾®æœåŠ¡æ¶æ„æ˜¯ä¸€ç§å°†åº”ç”¨ç¨‹åºæ„å»ºä¸ºä¸€ç»„å°å‹ã€ç‹¬ç«‹æœåŠ¡çš„è½¯ä»¶æ¶æ„é£æ ¼ã€‚æœ¬æ–‡æ¡£ä»ç†è®ºåŸºç¡€ã€è®¾è®¡åŸåˆ™ã€æ¶æ„æ¨¡å¼ã€æŠ€æœ¯å®ç°å’Œå·¥ç¨‹å®è·µäº”ä¸ªç»´åº¦æ·±å…¥åˆ†æå¾®æœåŠ¡æ¶æ„è®¾è®¡ã€‚

## 2. ç†è®ºåŸºç¡€

### 2.1. å¾®æœåŠ¡å®šä¹‰

**å®šä¹‰ 2.1.1** (å¾®æœåŠ¡)
å¾®æœåŠ¡æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„ã€å¯éƒ¨ç½²çš„è½¯ä»¶å•å…ƒï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹å¾ï¼š

- å•ä¸€èŒè´£ï¼šæ¯ä¸ªæœåŠ¡ä¸“æ³¨äºä¸€ä¸ªä¸šåŠ¡èƒ½åŠ›
- ç‹¬ç«‹éƒ¨ç½²ï¼šæœåŠ¡å¯ä»¥ç‹¬ç«‹å¼€å‘å’Œéƒ¨ç½²
- æŠ€æœ¯å¤šæ ·æ€§ï¼šä¸åŒæœåŠ¡å¯ä»¥ä½¿ç”¨ä¸åŒçš„æŠ€æœ¯æ ˆ
- æ•°æ®è‡ªæ²»ï¼šæ¯ä¸ªæœåŠ¡ç®¡ç†è‡ªå·±çš„æ•°æ®

**å®šç† 2.1.1** (å¾®æœåŠ¡åˆ†è§£å®šç†)
å¯¹äºä»»æ„å•ä½“åº”ç”¨ $A$ï¼Œå­˜åœ¨ä¸€ä¸ªå¾®æœåŠ¡åˆ†è§£ $S = \{s_1, s_2, \ldots, s_n\}$ï¼Œä½¿å¾—ï¼š
$$\text{Cohesion}(s_i) > \text{Coupling}(s_i, s_j) \quad \forall i, j \in [1,n], i \neq j$$

å…¶ä¸­ $\text{Cohesion}$ è¡¨ç¤ºå†…èšåº¦ï¼Œ$\text{Coupling}$ è¡¨ç¤ºè€¦åˆåº¦ã€‚

### 2.2. æ¶æ„åŸåˆ™

#### 2.2.1. å•ä¸€èŒè´£åŸåˆ™

æ¯ä¸ªå¾®æœåŠ¡åº”è¯¥åªè´Ÿè´£ä¸€ä¸ªä¸šåŠ¡é¢†åŸŸçš„åŠŸèƒ½ã€‚

#### 2.2.2. è‡ªæ²»æ€§åŸåˆ™

å¾®æœåŠ¡åº”è¯¥èƒ½å¤Ÿç‹¬ç«‹è¿è¡Œï¼Œä¸ä¾èµ–å…¶ä»–æœåŠ¡çš„çŠ¶æ€ã€‚

#### 2.2.3. æ•°æ®ä¸€è‡´æ€§åŸåˆ™

åœ¨åˆ†å¸ƒå¼ç¯å¢ƒä¸­ä¿è¯æ•°æ®æœ€ç»ˆä¸€è‡´æ€§ã€‚

## 3. æ ¸å¿ƒè®¾è®¡æ¨¡å¼

### 3.1. æœåŠ¡å‘ç°æ¨¡å¼

#### 3.1.1. å®¢æˆ·ç«¯æœåŠ¡å‘ç°

```python
import consul
import requests
import random

class ClientSideServiceDiscovery:
    def __init__(self, consul_host='localhost', consul_port=8500):
        self.consul = consul.Consul(host=consul_host, port=consul_port)

    def register_service(self, service_name, service_id, address, port, tags=None):
        """æ³¨å†ŒæœåŠ¡"""
        self.consul.agent.service.register(
            name=service_name,
            service_id=service_id,
            address=address,
            port=port,
            tags=tags or [],
            check=consul.Check().tcp(address, port, "10s", "30s")
        )

    def discover_service(self, service_name):
        """å‘ç°æœåŠ¡"""
        _, services = self.consul.health.service(service_name, passing=True)
        if services:
# éšæœºé€‰æ‹©ä¸€ä¸ªå¥åº·å®ä¾‹
            service = random.choice(services)
            return f"http://{service['Service']['Address']}:{service['Service']['Port']}"
        return None

    def deregister_service(self, service_id):
        """æ³¨é”€æœåŠ¡"""
        self.consul.agent.service.deregister(service_id)
```

## 4. æœåŠ¡ç«¯æœåŠ¡å‘ç°

```python
from flask import Flask, request, jsonify
import requests

app = Flask(__name__)

class ServerSideServiceDiscovery:
    def __init__(self, load_balancer_url):
        self.load_balancer_url = load_balancer_url

    def route_request(self, service_name, path, method='GET', data=None):
        """é€šè¿‡è´Ÿè½½å‡è¡¡å™¨è·¯ç”±è¯·æ±‚"""
        url = f"{self.load_balancer_url}/{service_name}{path}"

        if method == 'GET':
            response = requests.get(url)
        elif method == 'POST':
            response = requests.post(url, json=data)
        elif method == 'PUT':
            response = requests.put(url, json=data)
        elif method == 'DELETE':
            response = requests.delete(url)

        return response.json()

# ä½¿ç”¨ç¤ºä¾‹
discovery = ServerSideServiceDiscovery('http://load-balancer:8080')
result = discovery.route_request('user-service', '/users/123')
```

## 5. é…ç½®ç®¡ç†æ¨¡å¼

### 5.1. å¤–éƒ¨åŒ–é…ç½®

```python
import os
import yaml
from typing import Dict, Any

class ConfigurationManager:
    def __init__(self, config_path: str = None):
        self.config = {}
        self.config_path = config_path or os.getenv('CONFIG_PATH', '/etc/app/config.yaml')
        self.load_config()

    def load_config(self):
        """åŠ è½½é…ç½®æ–‡ä»¶"""
        if os.path.exists(self.config_path):
            with open(self.config_path, 'r') as f:
                self.config = yaml.safe_load(f)

# ç¯å¢ƒå˜é‡è¦†ç›–
        self.override_with_env_vars()

    def override_with_env_vars(self):
        """ç”¨ç¯å¢ƒå˜é‡è¦†ç›–é…ç½®"""
        for key in self.config:
            env_key = key.upper()
            if env_key in os.environ:
                self.config[key] = os.environ[env_key]

    def get(self, key: str, default: Any = None) -> Any:
        """è·å–é…ç½®å€¼"""
        return self.config.get(key, default)

    def get_database_url(self) -> str:
        """è·å–æ•°æ®åº“è¿æ¥URL"""
        host = self.get('database.host', 'localhost')
        port = self.get('database.port', 5432)
        name = self.get('database.name', 'app')
        user = self.get('database.user', 'postgres')
        password = self.get('database.password', '')

        return f"postgresql://{user}:{password}@{host}:{port}/{name}"

    def get_redis_url(self) -> str:
        """è·å–Redisè¿æ¥URL"""
        host = self.get('redis.host', 'localhost')
        port = self.get('redis.port', 6379)
        return f"redis://{host}:{port}"
```

## 6. é…ç½®ä¸­å¿ƒé›†æˆ

```python
import etcd3
import json

class EtcdConfigManager:
    def __init__(self, host='localhost', port=2379):
        self.client = etcd3.client(host=host, port=port)
        self.watchers = {}

    def set_config(self, key: str, value: str):
        """è®¾ç½®é…ç½®"""
        self.client.put(key, value.encode())

    def get_config(self, key: str) -> str:
        """è·å–é…ç½®"""
        value, _ = self.client.get(key)
        return value.decode() if value else None

    def watch_config(self, key: str, callback):
        """ç›‘å¬é…ç½®å˜åŒ–"""
        def watch_callback(event):
            if event.event_type == 'PUT':
                callback(event.key.decode(), event.value.decode())

        self.watchers[key] = self.client.watch(key, callback=watch_callback)

    def stop_watch(self, key: str):
        """åœæ­¢ç›‘å¬"""
        if key in self.watchers:
            self.watchers[key].cancel()
            del self.watchers[key]
```

### 6.1. æ–­è·¯å™¨æ¨¡å¼

#### 6.1.1. æ–­è·¯å™¨å®ç°

```python
import time
import threading
from enum import Enum
from typing import Callable, Any

class CircuitState(Enum):
    CLOSED = "CLOSED"
    OPEN = "OPEN"
    HALF_OPEN = "HALF_OPEN"

class CircuitBreaker:
    def __init__(self, failure_threshold=5, recovery_timeout=60, expected_exception=Exception):
        self.failure_threshold = failure_threshold
        self.recovery_timeout = recovery_timeout
        self.expected_exception = expected_exception

        self.failure_count = 0
        self.last_failure_time = None
        self.state = CircuitState.CLOSED
        self.lock = threading.Lock()

    def call(self, func: Callable, *args, **kwargs) -> Any:
        """æ‰§è¡Œå‡½æ•°ï¼Œåº”ç”¨æ–­è·¯å™¨é€»è¾‘"""
        if self.state == CircuitState.OPEN:
            if self._should_attempt_reset():
                self._set_state(CircuitState.HALF_OPEN)
            else:
                raise Exception("Circuit breaker is OPEN")

        try:
            result = func(*args, **kwargs)
            self._on_success()
            return result
        except self.expected_exception as e:
            self._on_failure()
            raise e

    def _on_success(self):
        """æˆåŠŸæ—¶çš„å¤„ç†"""
        with self.lock:
            self.failure_count = 0
            self._set_state(CircuitState.CLOSED)

    def _on_failure(self):
        """å¤±è´¥æ—¶çš„å¤„ç†"""
        with self.lock:
            self.failure_count += 1
            self.last_failure_time = time.time()

            if self.failure_count >= self.failure_threshold:
                self._set_state(CircuitState.OPEN)

    def _should_attempt_reset(self) -> bool:
        """æ˜¯å¦åº”è¯¥å°è¯•é‡ç½®"""
        if self.last_failure_time is None:
            return True

        return time.time() - self.last_failure_time >= self.recovery_timeout

    def _set_state(self, state: CircuitState):
        """è®¾ç½®æ–­è·¯å™¨çŠ¶æ€"""
        self.state = state
        print(f"Circuit breaker state changed to: {state.value}")

# ä½¿ç”¨ç¤ºä¾‹
def unreliable_service():
    import random
    if random.random() < 0.7:  # 70% å¤±è´¥ç‡
        raise Exception("Service unavailable")
    return "Success"

breaker = CircuitBreaker(failure_threshold=3, recovery_timeout=30)

try:
    result = breaker.call(unreliable_service)
    print(result)
except Exception as e:
    print(f"Error: {e}")
```

## 7. äº‹ä»¶é©±åŠ¨æ¨¡å¼

### 7.1. äº‹ä»¶æ€»çº¿å®ç°

```python
import asyncio
from typing import Dict, List, Callable, Any
import json
import uuid

class Event:
    def __init__(self, event_type: str, data: Any, source: str = None):
        self.id = str(uuid.uuid4())
        self.event_type = event_type
        self.data = data
        self.source = source
        self.timestamp = time.time()

class EventBus:
    def __init__(self):
        self.subscribers: Dict[str, List[Callable]] = {}
        self.event_history: List[Event] = []

    def subscribe(self, event_type: str, handler: Callable):
        """è®¢é˜…äº‹ä»¶"""
        if event_type not in self.subscribers:
            self.subscribers[event_type] = []
        self.subscribers[event_type].append(handler)

    def unsubscribe(self, event_type: str, handler: Callable):
        """å–æ¶ˆè®¢é˜…"""
        if event_type in self.subscribers:
            self.subscribers[event_type].remove(handler)

    def publish(self, event: Event):
        """å‘å¸ƒäº‹ä»¶"""
        self.event_history.append(event)

        if event.event_type in self.subscribers:
            for handler in self.subscribers[event.event_type]:
                try:
                    handler(event)
                except Exception as e:
                    print(f"Error in event handler: {e}")

    def get_event_history(self, event_type: str = None) -> List[Event]:
        """è·å–äº‹ä»¶å†å²"""
        if event_type:
            return [e for e in self.event_history if e.event_type == event_type]
        return self.event_history

# ä½¿ç”¨ç¤ºä¾‹
event_bus = EventBus()

def user_created_handler(event):
    print(f"User created: {event.data}")

def order_placed_handler(event):
    print(f"Order placed: {event.data}")

event_bus.subscribe("user.created", user_created_handler)
event_bus.subscribe("order.placed", order_placed_handler)

# å‘å¸ƒäº‹ä»¶
user_event = Event("user.created", {"user_id": 123, "email": "user@example.com"})
order_event = Event("order.placed", {"order_id": 456, "amount": 99.99})

event_bus.publish(user_event)
event_bus.publish(order_event)
```

## 8. æŠ€æœ¯å®ç°

### 8.1. æœåŠ¡é—´é€šä¿¡

#### 8.1.1. RESTful API

```python
from flask import Flask, request, jsonify
import requests
from functools import wraps

app = Flask(__name__)

def service_discovery(f):
    """æœåŠ¡å‘ç°è£…é¥°å™¨"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
# ä»æœåŠ¡æ³¨å†Œä¸­å¿ƒè·å–ç›®æ ‡æœåŠ¡åœ°å€
        target_service = get_service_url(request.endpoint)
        if target_service:
# è½¬å‘è¯·æ±‚åˆ°ç›®æ ‡æœåŠ¡
            return forward_request(target_service, request)
        return f(*args, **kwargs)
    return decorated_function

def get_service_url(endpoint):
    """è·å–æœåŠ¡URL"""
    service_mapping = {
        'user_service': 'http://user-service:8080',
        'order_service': 'http://order-service:8081',
        'payment_service': 'http://payment-service:8082'
    }
    return service_mapping.get(endpoint)

def forward_request(target_url, request):
    """è½¬å‘è¯·æ±‚"""
    method = request.method
    url = f"{target_url}{request.path}"
    headers = dict(request.headers)

    if method == 'GET':
        response = requests.get(url, headers=headers, params=request.args)
    elif method == 'POST':
        response = requests.post(url, headers=headers, json=request.get_json())
    elif method == 'PUT':
        response = requests.put(url, headers=headers, json=request.get_json())
    elif method == 'DELETE':
        response = requests.delete(url, headers=headers)

    return response.json(), response.status_code

@app.route('/users/<int:user_id>', methods=['GET'])
@service_discovery
def get_user(user_id):
    return jsonify({"user_id": user_id, "name": "John Doe"})

@app.route('/orders', methods=['POST'])
@service_discovery
def create_order():
    data = request.get_json()
    return jsonify({"order_id": 123, "status": "created"})
```

## 9. gRPCé€šä¿¡

```python
# user_service.proto
"""
syntax = "proto3";

package userservice;

service UserService {
  rpc GetUser(GetUserRequest) returns (GetUserResponse);
  rpc CreateUser(CreateUserRequest) returns (CreateUserResponse);
}

message GetUserRequest {
  int32 user_id = 1;
}

message GetUserResponse {
  int32 user_id = 1;
  string name = 2;
  string email = 3;
}

message CreateUserRequest {
  string name = 1;
  string email = 2;
}

message CreateUserResponse {
  int32 user_id = 1;
  string status = 2;
}
"""

import grpc
from concurrent import futures
import user_service_pb2
import user_service_pb2_grpc

class UserServiceServicer(user_service_pb2_grpc.UserServiceServicer):
    def GetUser(self, request, context):
        user_id = request.user_id
# ä»æ•°æ®åº“è·å–ç”¨æˆ·ä¿¡æ¯
        return user_service_pb2.GetUserResponse(
            user_id=user_id,
            name="John Doe",
            email="john@example.com"
        )

    def CreateUser(self, request, context):
        name = request.name
        email = request.email
# åˆ›å»ºç”¨æˆ·é€»è¾‘
        return user_service_pb2.CreateUserResponse(
            user_id=123,
            status="created"
        )

def serve():
    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
    user_service_pb2_grpc.add_UserServiceServicer_to_server(
        UserServiceServicer(), server
    )
    server.add_insecure_port('[::]:50051')
    server.start()
    server.wait_for_termination()

if __name__ == '__main__':
    serve()
```

## 10. æ•°æ®ç®¡ç†

### 10.1. æ•°æ®åº“ per Service

```python
from sqlalchemy import create_engine, Column, Integer, String, DateTime
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
import datetime

Base = declarative_base()

class User(Base):
    __tablename__ = 'users'

    id = Column(Integer, primary_key=True)
    name = Column(String(100), nullable=False)
    email = Column(String(100), unique=True, nullable=False)
    created_at = Column(DateTime, default=datetime.datetime.utcnow)

class UserRepository:
    def __init__(self, database_url):
        self.engine = create_engine(database_url)
        Base.metadata.create_all(self.engine)
        Session = sessionmaker(bind=self.engine)
        self.session = Session()

    def create_user(self, name: str, email: str) -> User:
        user = User(name=name, email=email)
        self.session.add(user)
        self.session.commit()
        return user

    def get_user(self, user_id: int) -> User:
        return self.session.query(User).filter(User.id == user_id).first()

    def update_user(self, user_id: int, **kwargs) -> User:
        user = self.get_user(user_id)
        if user:
            for key, value in kwargs.items():
                setattr(user, key, value)
            self.session.commit()
        return user

    def delete_user(self, user_id: int) -> bool:
        user = self.get_user(user_id)
        if user:
            self.session.delete(user)
            self.session.commit()
            return True
        return False
```

#### 10.1.1. äº‹ä»¶æº¯æº

```python
from typing import List, Dict, Any
import json
import uuid
from datetime import datetime

class EventStore:
    def __init__(self, storage_backend):
        self.storage = storage_backend
        self.event_handlers = {}

    def append_event(self, aggregate_id: str, event_type: str, event_data: Dict[str, Any]):
        """è¿½åŠ äº‹ä»¶"""
        event = {
            'id': str(uuid.uuid4()),
            'aggregate_id': aggregate_id,
            'event_type': event_type,
            'event_data': event_data,
            'timestamp': datetime.utcnow().isoformat(),
            'version': self.get_next_version(aggregate_id)
        }

        self.storage.store_event(event)
        self.publish_event(event)

    def get_events(self, aggregate_id: str) -> List[Dict]:
        """è·å–èšåˆæ ¹çš„æ‰€æœ‰äº‹ä»¶"""
        return self.storage.get_events(aggregate_id)

    def get_next_version(self, aggregate_id: str) -> int:
        """è·å–ä¸‹ä¸€ä¸ªç‰ˆæœ¬å·"""
        events = self.get_events(aggregate_id)
        return len(events) + 1

    def register_handler(self, event_type: str, handler):
        """æ³¨å†Œäº‹ä»¶å¤„ç†å™¨"""
        if event_type not in self.event_handlers:
            self.event_handlers[event_type] = []
        self.event_handlers[event_type].append(handler)

    def publish_event(self, event: Dict):
        """å‘å¸ƒäº‹ä»¶"""
        event_type = event['event_type']
        if event_type in self.event_handlers:
            for handler in self.event_handlers[event_type]:
                handler(event)

class UserAggregate:
    def __init__(self, event_store: EventStore):
        self.event_store = event_store
        self.state = {}

    def create_user(self, name: str, email: str):
        """åˆ›å»ºç”¨æˆ·"""
        event_data = {
            'name': name,
            'email': email
        }
        self.event_store.append_event('user', 'UserCreated', event_data)

    def update_user(self, user_id: str, **kwargs):
        """æ›´æ–°ç”¨æˆ·"""
        event_data = {
            'user_id': user_id,
            **kwargs
        }
        self.event_store.append_event('user', 'UserUpdated', event_data)

    def apply_event(self, event: Dict):
        """åº”ç”¨äº‹ä»¶åˆ°çŠ¶æ€"""
        event_type = event['event_type']
        event_data = event['event_data']

        if event_type == 'UserCreated':
            self.state.update(event_data)
        elif event_type == 'UserUpdated':
            self.state.update(event_data)
```

### 10.2. ç›‘æ§ä¸å¯è§‚æµ‹æ€§

#### 10.2.1. åˆ†å¸ƒå¼è¿½è¸ª

```python
import opentracing
import jaeger_client
from flask import Flask, request
from functools import wraps

# åˆå§‹åŒ–Jaeger tracer
config = jaeger_client.Config(
    config={
        'sampler': {'type': 'const', 'param': 1},
        'logging': True,
    },
    service_name='user-service'
)
tracer = config.initialize_tracer()

app = Flask(__name__)

def trace_request(f):
    """è¯·æ±‚è¿½è¸ªè£…é¥°å™¨"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        with tracer.start_span(f.__name__) as span:
            span.set_tag('http.method', request.method)
            span.set_tag('http.url', request.url)

# æ³¨å…¥è¿½è¸ªä¸Šä¸‹æ–‡åˆ°è¯·æ±‚å¤´
            headers = {}
            tracer.inject(span, opentracing.Format.HTTP_HEADERS, headers)

            result = f(*args, **kwargs)
            span.set_tag('http.status_code', 200)
            return result
    return decorated_function

@app.route('/users/<int:user_id>', methods=['GET'])
@trace_request
def get_user(user_id):
    with tracer.start_span('database_query') as span:
        span.set_tag('db.type', 'postgresql')
        span.set_tag('db.statement', f'SELECT * FROM users WHERE id = {user_id}')

# æ¨¡æ‹Ÿæ•°æ®åº“æŸ¥è¯¢
        user = {'id': user_id, 'name': 'John Doe', 'email': 'john@example.com'}

        span.set_tag('db.result', str(user))
        return user
```

## 11. å¥åº·æ£€æŸ¥

```python
from flask import Flask, jsonify
import psutil
import requests
from datetime import datetime

app = Flask(__name__)

class HealthChecker:
    def __init__(self):
        self.dependencies = {
            'database': 'http://database:5432',
            'redis': 'http://redis:6379',
            'external_api': 'http://api.external.com/health'
        }

    def check_system_health(self):
        """æ£€æŸ¥ç³»ç»Ÿå¥åº·çŠ¶æ€"""
        health_status = {
            'status': 'healthy',
            'timestamp': datetime.utcnow().isoformat(),
            'system': self.check_system_metrics(),
            'dependencies': self.check_dependencies(),
            'version': '1.0.0'
        }

# å¦‚æœä»»ä½•ä¾èµ–é¡¹ä¸å¥åº·ï¼Œæ•´ä½“çŠ¶æ€ä¸ºä¸å¥åº·
        if any(dep['status'] != 'healthy' for dep in health_status['dependencies'].values()):
            health_status['status'] = 'unhealthy'

        return health_status

    def check_system_metrics(self):
        """æ£€æŸ¥ç³»ç»ŸæŒ‡æ ‡"""
        return {
            'cpu_usage': psutil.cpu_percent(),
            'memory_usage': psutil.virtual_memory().percent,
            'disk_usage': psutil.disk_usage('/').percent
        }

    def check_dependencies(self):
        """æ£€æŸ¥ä¾èµ–é¡¹å¥åº·çŠ¶æ€"""
        dependency_status = {}

        for name, url in self.dependencies.items():
            try:
                response = requests.get(url, timeout=5)
                dependency_status[name] = {
                    'status': 'healthy' if response.status_code == 200 else 'unhealthy',
                    'response_time': response.elapsed.total_seconds(),
                    'status_code': response.status_code
                }
            except Exception as e:
                dependency_status[name] = {
                    'status': 'unhealthy',
                    'error': str(e)
                }

        return dependency_status

health_checker = HealthChecker()

@app.route('/health', methods=['GET'])
def health_check():
    return jsonify(health_checker.check_system_health())

@app.route('/health/ready', methods=['GET'])
def readiness_check():
    """å°±ç»ªæ£€æŸ¥"""
    health_status = health_checker.check_system_health()
    if health_status['status'] == 'healthy':
        return jsonify({'status': 'ready'}), 200
    else:
        return jsonify({'status': 'not ready'}), 503

@app.route('/health/live', methods=['GET'])
def liveness_check():
    """å­˜æ´»æ£€æŸ¥"""
    return jsonify({'status': 'alive'}), 200
```

## 12. éƒ¨ç½²ä¸è¿ç»´

### 12.1. å®¹å™¨åŒ–éƒ¨ç½²

#### 12.1.1. Dockeré…ç½®

```dockerfile
# Dockerfile
FROM python:3.9-slim

WORKDIR /app

# å®‰è£…ä¾èµ–
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# å¤åˆ¶åº”ç”¨ä»£ç 
COPY . .

# åˆ›å»ºérootç”¨æˆ·
RUN useradd -m -u 1000 appuser && chown -R appuser:appuser /app
USER appuser

# æš´éœ²ç«¯å£
EXPOSE 8080

# å¥åº·æ£€æŸ¥
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8080/health || exit 1

# å¯åŠ¨åº”ç”¨
CMD ["python", "app.py"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  user-service:
    build: ./user-service
    ports:
      - "8080:8080"
    environment:
      - DATABASE_URL=postgresql://user:password@postgres:5432/users
      - REDIS_URL=redis://redis:6379
    depends_on:
      - postgres
      - redis
    networks:
      - microservices

  order-service:
    build: ./order-service
    ports:
      - "8081:8080"
    environment:
      - DATABASE_URL=postgresql://user:password@postgres:5432/orders
      - USER_SERVICE_URL=http://user-service:8080
    depends_on:
      - postgres
      - user-service
    networks:
      - microservices

  postgres:
    image: postgres:13
    environment:
      - POSTGRES_DB=users
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - microservices

  redis:
    image: redis:6-alpine
    networks:
      - microservices

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
    depends_on:
      - user-service
      - order-service
    networks:
      - microservices

volumes:
  postgres_data:

networks:
  microservices:
    driver: bridge
```

## 13. Kuberneteséƒ¨ç½²

### 13.1. éƒ¨ç½²é…ç½®

```yaml
# user-service-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: user-service
  labels:
    app: user-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: user-service
  template:
    metadata:
      labels:
        app: user-service
    spec:
      containers:
      - name: user-service
        image: user-service:latest
        ports:
        - containerPort: 8080
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: database-url
        - name: REDIS_URL
          value: "redis://redis-service:6379"
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /health/live
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health/ready
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: user-service
spec:
  selector:
    app: user-service
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8080
  type: ClusterIP
```

## 14. æœåŠ¡ç½‘æ ¼é…ç½®

```yaml
# istio-virtual-service.yaml
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: user-service
spec:
  hosts:
  - user-service
  http:
  - route:
    - destination:
        host: user-service
        subset: v1
      weight: 90
    - destination:
        host: user-service
        subset: v2
      weight: 10
---
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: user-service
spec:
  host: user-service
  subsets:
  - name: v1
    labels:
      version: v1
  - name: v2
    labels:
      version: v2
```

## 15. æ€§èƒ½ä¼˜åŒ–

### 15.1. ç¼“å­˜ç­–ç•¥

#### 15.1.1. åˆ†å¸ƒå¼ç¼“å­˜

```python
import redis
import json
from typing import Any, Optional

class DistributedCache:
    def __init__(self, redis_url: str):
        self.redis = redis.from_url(redis_url)

    def get(self, key: str) -> Optional[Any]:
        """è·å–ç¼“å­˜å€¼"""
        value = self.redis.get(key)
        return json.loads(value) if value else None

    def set(self, key: str, value: Any, ttl: int = 3600):
        """è®¾ç½®ç¼“å­˜å€¼"""
        self.redis.setex(key, ttl, json.dumps(value))

    def delete(self, key: str):
        """åˆ é™¤ç¼“å­˜"""
        self.redis.delete(key)

    def invalidate_pattern(self, pattern: str):
        """æŒ‰æ¨¡å¼åˆ é™¤ç¼“å­˜"""
        keys = self.redis.keys(pattern)
        if keys:
            self.redis.delete(*keys)

class CachedUserService:
    def __init__(self, cache: DistributedCache, user_repository):
        self.cache = cache
        self.user_repository = user_repository

    def get_user(self, user_id: int):
        """è·å–ç”¨æˆ·ï¼ˆå¸¦ç¼“å­˜ï¼‰"""
        cache_key = f"user:{user_id}"

# å°è¯•ä»ç¼“å­˜è·å–
        cached_user = self.cache.get(cache_key)
        if cached_user:
            return cached_user

# ä»æ•°æ®åº“è·å–
        user = self.user_repository.get_user(user_id)
        if user:
            user_dict = {
                'id': user.id,
                'name': user.name,
                'email': user.email
            }
# ç¼“å­˜ç»“æœ
            self.cache.set(cache_key, user_dict, ttl=3600)
            return user_dict

        return None

    def update_user(self, user_id: int, **kwargs):
        """æ›´æ–°ç”¨æˆ·ï¼ˆæ¸…é™¤ç¼“å­˜ï¼‰"""
        user = self.user_repository.update_user(user_id, **kwargs)
        if user:
# æ¸…é™¤ç›¸å…³ç¼“å­˜
            self.cache.delete(f"user:{user_id}")
            self.cache.invalidate_pattern("user:*")
        return user
```

## 16. è´Ÿè½½å‡è¡¡

### 16.1. å®¢æˆ·ç«¯è´Ÿè½½å‡è¡¡

```python
import random
import time
from typing import List, Dict

class LoadBalancer:
    def __init__(self, strategy: str = 'round_robin'):
        self.strategy = strategy
        self.servers = []
        self.current_index = 0
        self.server_weights = {}

    def add_server(self, server: str, weight: int = 1):
        """æ·»åŠ æœåŠ¡å™¨"""
        self.servers.append(server)
        self.server_weights[server] = weight

    def remove_server(self, server: str):
        """ç§»é™¤æœåŠ¡å™¨"""
        if server in self.servers:
            self.servers.remove(server)
            del self.server_weights[server]

    def get_server(self) -> str:
        """è·å–æœåŠ¡å™¨"""
        if not self.servers:
            raise Exception("No servers available")

        if self.strategy == 'round_robin':
            return self._round_robin()
        elif self.strategy == 'random':
            return self._random()
        elif self.strategy == 'weighted':
            return self._weighted()
        else:
            return self._round_robin()

    def _round_robin(self) -> str:
        """è½®è¯¢ç­–ç•¥"""
        server = self.servers[self.current_index]
        self.current_index = (self.current_index + 1) % len(self.servers)
        return server

    def _random(self) -> str:
        """éšæœºç­–ç•¥"""
        return random.choice(self.servers)

    def _weighted(self) -> str:
        """åŠ æƒç­–ç•¥"""
        total_weight = sum(self.server_weights.values())
        rand = random.uniform(0, total_weight)

        current_weight = 0
        for server, weight in self.server_weights.items():
            current_weight += weight
            if rand <= current_weight:
                return server

        return self.servers[0]

class ServiceClient:
    def __init__(self, service_name: str, load_balancer: LoadBalancer):
        self.service_name = service_name
        self.load_balancer = load_balancer
        self.circuit_breaker = CircuitBreaker()

    def call_service(self, endpoint: str, method: str = 'GET', data: Dict = None):
        """è°ƒç”¨æœåŠ¡"""
        max_retries = 3
        for attempt in range(max_retries):
            try:
                server = self.load_balancer.get_server()
                url = f"http://{server}{endpoint}"

                return self.circuit_breaker.call(
                    lambda: self._make_request(url, method, data)
                )
            except Exception as e:
                if attempt == max_retries - 1:
                    raise e
                time.sleep(2 ** attempt)  # æŒ‡æ•°é€€é¿

    def _make_request(self, url: str, method: str, data: Dict):
        """å‘é€HTTPè¯·æ±‚"""
        import requests

        if method == 'GET':
            response = requests.get(url)
        elif method == 'POST':
            response = requests.post(url, json=data)
        elif method == 'PUT':
            response = requests.put(url, json=data)
        elif method == 'DELETE':
            response = requests.delete(url)

        response.raise_for_status()
        return response.json()
```

## 17. å®‰å…¨è€ƒè™‘

### 17.1. è®¤è¯ä¸æˆæƒ

#### 17.1.1. JWTè®¤è¯

```python
import jwt
from datetime import datetime, timedelta
from functools import wraps
from flask import request, jsonify

class JWTAuth:
    def __init__(self, secret_key: str):
        self.secret_key = secret_key

    def generate_token(self, user_id: int, roles: List[str] = None) -> str:
        """ç”ŸæˆJWTä»¤ç‰Œ"""
        payload = {
            'user_id': user_id,
            'roles': roles or [],
            'exp': datetime.utcnow() + timedelta(hours=24),
            'iat': datetime.utcnow()
        }
        return jwt.encode(payload, self.secret_key, algorithm='HS256')

    def verify_token(self, token: str) -> Dict:
        """éªŒè¯JWTä»¤ç‰Œ"""
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=['HS256'])
            return payload
        except jwt.ExpiredSignatureError:
            raise Exception("Token expired")
        except jwt.InvalidTokenError:
            raise Exception("Invalid token")

    def require_auth(self, f):
        """è®¤è¯è£…é¥°å™¨"""
        @wraps(f)
        def decorated_function(*args, **kwargs):
            token = request.headers.get('Authorization')
            if not token or not token.startswith('Bearer '):
                return jsonify({'error': 'Missing or invalid token'}), 401

            try:
                token = token.split(' ')[1]
                payload = self.verify_token(token)
                request.user = payload
                return f(*args, **kwargs)
            except Exception as e:
                return jsonify({'error': str(e)}), 401

        return decorated_function

    def require_role(self, required_role: str):
        """è§’è‰²æˆæƒè£…é¥°å™¨"""
        def decorator(f):
            @wraps(f)
            def decorated_function(*args, **kwargs):
                if not hasattr(request, 'user'):
                    return jsonify({'error': 'Authentication required'}), 401

                user_roles = request.user.get('roles', [])
                if required_role not in user_roles:
                    return jsonify({'error': 'Insufficient permissions'}), 403

                return f(*args, **kwargs)
            return decorated_function
        return decorator

# ä½¿ç”¨ç¤ºä¾‹
auth = JWTAuth('your-secret-key')

@app.route('/users/<int:user_id>', methods=['GET'])
@auth.require_auth
@auth.require_role('user')
def get_user(user_id):
    return jsonify({'user_id': user_id, 'name': 'John Doe'})

@app.route('/admin/users', methods=['GET'])
@auth.require_auth
@auth.require_role('admin')
def get_all_users():
    return jsonify({'users': []})
```

## 18. APIç½‘å…³å®‰å…¨

### 18.1. é€Ÿç‡é™åˆ¶

```python
import time
from collections import defaultdict
from flask import request, jsonify

class RateLimiter:
    def __init__(self, requests_per_minute: int = 60):
        self.requests_per_minute = requests_per_minute
        self.requests = defaultdict(list)

    def is_allowed(self, client_id: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦å…è®¸è¯·æ±‚"""
        now = time.time()
        minute_ago = now - 60

# æ¸…ç†è¿‡æœŸçš„è¯·æ±‚è®°å½•
        self.requests[client_id] = [
            req_time for req_time in self.requests[client_id]
            if req_time > minute_ago
        ]

# æ£€æŸ¥è¯·æ±‚æ•°é‡
        if len(self.requests[client_id]) >= self.requests_per_minute:
            return False

# è®°å½•å½“å‰è¯·æ±‚
        self.requests[client_id].append(now)
        return True

    def get_remaining_requests(self, client_id: str) -> int:
        """è·å–å‰©ä½™è¯·æ±‚æ•°é‡"""
        now = time.time()
        minute_ago = now - 60

        self.requests[client_id] = [
            req_time for req_time in self.requests[client_id]
            if req_time > minute_ago
        ]

        return max(0, self.requests_per_minute - len(self.requests[client_id]))

rate_limiter = RateLimiter(requests_per_minute=60)

def rate_limit(f):
    """é€Ÿç‡é™åˆ¶è£…é¥°å™¨"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        client_id = request.headers.get('X-Client-ID', request.remote_addr)

        if not rate_limiter.is_allowed(client_id):
            return jsonify({
                'error': 'Rate limit exceeded',
                'retry_after': 60
            }), 429

        response = f(*args, **kwargs)

# æ·»åŠ é€Ÿç‡é™åˆ¶å¤´
        remaining = rate_limiter.get_remaining_requests(client_id)
        response.headers['X-RateLimit-Remaining'] = str(remaining)
        response.headers['X-RateLimit-Limit'] = str(rate_limiter.requests_per_minute)

        return response

    return decorated_function

@app.route('/api/users', methods=['GET'])
@rate_limit
def get_users():
    return jsonify({'users': []})
```

## 19. æ€»ç»“ä¸å±•æœ›

å¾®æœåŠ¡æ¶æ„ä½œä¸ºä¸€ç§ç°ä»£åŒ–çš„è½¯ä»¶æ¶æ„æ¨¡å¼ï¼Œåœ¨æé«˜ç³»ç»Ÿå¯æ‰©å±•æ€§ã€å¯ç»´æŠ¤æ€§å’Œå¼€å‘æ•ˆç‡æ–¹é¢å‘æŒ¥ç€é‡è¦ä½œç”¨ã€‚æœªæ¥çš„å‘å±•æ–¹å‘åŒ…æ‹¬ï¼š

1. **æœåŠ¡ç½‘æ ¼**ï¼šIstioã€Linkerdç­‰æœåŠ¡ç½‘æ ¼æŠ€æœ¯çš„å¹¿æ³›åº”ç”¨
2. **æ— æœåŠ¡å™¨æ¶æ„**ï¼šServerlessä¸å¾®æœåŠ¡çš„ç»“åˆ
3. **äº‹ä»¶é©±åŠ¨æ¶æ„**ï¼šåŸºäºäº‹ä»¶çš„æ¾è€¦åˆæœåŠ¡é€šä¿¡
4. **äº‘åŸç”ŸæŠ€æœ¯**ï¼šKubernetesã€Dockerç­‰å®¹å™¨æŠ€æœ¯çš„æ·±åº¦é›†æˆ
5. **æ™ºèƒ½åŒ–è¿ç»´**ï¼šAIé©±åŠ¨çš„è‡ªåŠ¨åŒ–è¿ç»´å’Œæ•…éšœè¯Šæ–­

## 20. å‚è€ƒæ–‡çŒ®

1. Newman, S. "Building Microservices: Designing Fine-Grained Systems." O'Reilly Media, 2021.
2. Richardson, C. "Microservices Patterns: With Examples in Java." Manning Publications, 2018.
3. Fowler, M. "Microservices." Martin Fowler's Blog, 2014.
4. Evans, E. "Domain-Driven Design: Tackling Complexity in the Heart of Software." Addison-Wesley, 2003.
5. Hohpe, G., & Woolf, B. "Enterprise Integration Patterns: Designing, Building, and Deploying Messaging Solutions." Addison-Wesley, 2003.
