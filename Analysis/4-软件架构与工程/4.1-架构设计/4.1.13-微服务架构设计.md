# 微服务架构设计

## 1. 概述

### 1.1 理论基础

微服务架构是一种将应用程序构建为一组小型、独立服务的软件架构风格。每个服务运行在自己的进程中，通过轻量级机制（通常是HTTP API）进行通信。微服务架构强调服务的独立性、可扩展性和技术多样性。

### 1.2 核心原则

- **单一职责**：每个服务专注于一个业务功能
- **松耦合**：服务间通过标准接口通信
- **高内聚**：服务内部功能紧密相关
- **独立部署**：服务可以独立开发和部署
- **技术多样性**：不同服务可以使用不同技术栈

### 1.3 架构模式

```mermaid
graph TB
    A[API网关] --> B[用户服务]
    A --> C[订单服务]
    A --> D[支付服务]
    A --> E[库存服务]
    A --> F[通知服务]
    
    B --> G[用户数据库]
    C --> H[订单数据库]
    D --> I[支付数据库]
    E --> J[库存数据库]
    F --> K[消息队列]
    
    L[服务注册中心] --> A
    L --> B
    L --> C
    L --> D
    L --> E
    L --> F
    
    M[配置中心] --> A
    M --> B
    M --> C
    M --> D
    M --> E
    M --> F
```

## 2. 服务拆分策略

### 2.1 业务领域驱动设计

**领域边界识别**：
- 根据业务领域划分服务
- 识别领域内的聚合根
- 定义领域间的契约

**示例**：电商系统的服务拆分

```python
# 用户服务
class UserService:
    def __init__(self):
        self.user_repository = UserRepository()
    
    def create_user(self, user_data):
        """创建用户"""
        user = User(**user_data)
        return self.user_repository.save(user)
    
    def get_user(self, user_id):
        """获取用户信息"""
        return self.user_repository.find_by_id(user_id)
    
    def update_user(self, user_id, user_data):
        """更新用户信息"""
        user = self.user_repository.find_by_id(user_id)
        user.update(user_data)
        return self.user_repository.save(user)

# 订单服务
class OrderService:
    def __init__(self):
        self.order_repository = OrderRepository()
        self.user_client = UserClient()
    
    def create_order(self, user_id, items):
        """创建订单"""
        # 验证用户
        user = self.user_client.get_user(user_id)
        if not user:
            raise ValueError("用户不存在")
        
        order = Order(user_id=user_id, items=items)
        return self.order_repository.save(order)
    
    def get_order(self, order_id):
        """获取订单信息"""
        return self.order_repository.find_by_id(order_id)
```

### 2.2 数据驱动拆分

**数据所有权原则**：
- 每个服务拥有自己的数据
- 服务间通过API共享数据
- 避免跨服务的数据查询

**实现示例**：

```python
# 用户数据模型
class User:
    def __init__(self, id, name, email, phone):
        self.id = id
        self.name = name
        self.email = email
        self.phone = phone

# 订单数据模型（只包含用户ID引用）
class Order:
    def __init__(self, id, user_id, items, total_amount):
        self.id = id
        self.user_id = user_id  # 引用用户ID
        self.items = items
        self.total_amount = total_amount

# 用户客户端（用于跨服务调用）
class UserClient:
    def __init__(self, user_service_url):
        self.user_service_url = user_service_url
    
    def get_user(self, user_id):
        """从用户服务获取用户信息"""
        response = requests.get(f"{self.user_service_url}/users/{user_id}")
        if response.status_code == 200:
            return response.json()
        return None
```

## 3. 服务通信模式

### 3.1 同步通信

**RESTful API**：

```python
from flask import Flask, request, jsonify
import requests

app = Flask(__name__)

class OrderController:
    def __init__(self, user_service_url, payment_service_url):
        self.user_service_url = user_service_url
        self.payment_service_url = payment_service_url
    
    @app.route('/orders', methods=['POST'])
    def create_order(self):
        """创建订单"""
        data = request.get_json()
        user_id = data.get('user_id')
        items = data.get('items')
        
        # 调用用户服务验证用户
        user_response = requests.get(f"{self.user_service_url}/users/{user_id}")
        if user_response.status_code != 200:
            return jsonify({'error': '用户不存在'}), 400
        
        # 调用支付服务处理支付
        payment_data = {
            'user_id': user_id,
            'amount': self.calculate_total(items)
        }
        payment_response = requests.post(f"{self.payment_service_url}/payments", json=payment_data)
        if payment_response.status_code != 200:
            return jsonify({'error': '支付失败'}), 400
        
        # 创建订单
        order = Order(user_id=user_id, items=items)
        order_id = self.order_repository.save(order)
        
        return jsonify({'order_id': order_id}), 201
    
    def calculate_total(self, items):
        """计算订单总额"""
        return sum(item['price'] * item['quantity'] for item in items)
```

**gRPC通信**：

```python
import grpc
from concurrent import futures
import user_pb2
import user_pb2_grpc

class UserService(user_pb2_grpc.UserServiceServicer):
    def GetUser(self, request, context):
        """获取用户信息"""
        user_id = request.user_id
        user = self.user_repository.find_by_id(user_id)
        
        if user:
            return user_pb2.User(
                id=user.id,
                name=user.name,
                email=user.email
            )
        else:
            context.abort(grpc.StatusCode.NOT_FOUND, '用户不存在')

def serve():
    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
    user_pb2_grpc.add_UserServiceServicer_to_server(UserService(), server)
    server.add_insecure_port('[::]:50051')
    server.start()
    server.wait_for_termination()

if __name__ == '__main__':
    serve()
```

### 3.2 异步通信

**消息队列**：

```python
import pika
import json

class MessageBroker:
    def __init__(self, host='localhost'):
        self.connection = pika.BlockingConnection(pika.ConnectionParameters(host=host))
        self.channel = self.connection.channel()
        
        # 声明交换机
        self.channel.exchange_declare(exchange='order_events', exchange_type='topic')
        
        # 声明队列
        self.channel.queue_declare(queue='order_created')
        self.channel.queue_declare(queue='payment_processed')
        
        # 绑定队列到交换机
        self.channel.queue_bind(exchange='order_events', queue='order_created', routing_key='order.created')
        self.channel.queue_bind(exchange='order_events', queue='payment_processed', routing_key='payment.processed')
    
    def publish_event(self, event_type, data):
        """发布事件"""
        message = {
            'event_type': event_type,
            'data': data,
            'timestamp': datetime.now().isoformat()
        }
        
        self.channel.basic_publish(
            exchange='order_events',
            routing_key=f'{event_type}',
            body=json.dumps(message)
        )
    
    def consume_events(self, queue_name, callback):
        """消费事件"""
        def on_message(ch, method, properties, body):
            event = json.loads(body)
            callback(event)
            ch.basic_ack(delivery_tag=method.delivery_tag)
        
        self.channel.basic_consume(queue=queue_name, on_message_callback=on_message)
        self.channel.start_consuming()

# 订单服务发布事件
class OrderService:
    def __init__(self):
        self.message_broker = MessageBroker()
    
    def create_order(self, user_id, items):
        """创建订单"""
        order = Order(user_id=user_id, items=items)
        order_id = self.order_repository.save(order)
        
        # 发布订单创建事件
        self.message_broker.publish_event('order.created', {
            'order_id': order_id,
            'user_id': user_id,
            'items': items
        })
        
        return order_id

# 通知服务消费事件
class NotificationService:
    def __init__(self):
        self.message_broker = MessageBroker()
    
    def start_consuming(self):
        """开始消费事件"""
        self.message_broker.consume_events('order_created', self.handle_order_created)
    
    def handle_order_created(self, event):
        """处理订单创建事件"""
        order_data = event['data']
        user_id = order_data['user_id']
        
        # 发送通知
        self.send_notification(user_id, f"订单 {order_data['order_id']} 已创建")
    
    def send_notification(self, user_id, message):
        """发送通知"""
        # 实现通知逻辑
        pass
```

## 4. 服务发现与注册

### 4.1 服务注册

```python
import consul
import socket

class ServiceRegistry:
    def __init__(self, consul_host='localhost', consul_port=8500):
        self.consul = consul.Consul(host=consul_host, port=consul_port)
    
    def register_service(self, service_name, service_id, port, tags=None):
        """注册服务"""
        service_address = socket.gethostbyname(socket.gethostname())
        
        self.consul.agent.service.register(
            name=service_name,
            service_id=service_id,
            address=service_address,
            port=port,
            tags=tags or [],
            check=consul.Check.http(f'http://{service_address}:{port}/health', interval='10s')
        )
    
    def deregister_service(self, service_id):
        """注销服务"""
        self.consul.agent.service.deregister(service_id)
    
    def get_service(self, service_name):
        """获取服务信息"""
        _, services = self.consul.health.service(service_name, passing=True)
        if services:
            service = services[0]['Service']
            return {
                'id': service['ID'],
                'address': service['Address'],
                'port': service['Port']
            }
        return None

# 服务启动时注册
class UserService:
    def __init__(self):
        self.registry = ServiceRegistry()
        self.app = Flask(__name__)
        
        # 注册服务
        self.registry.register_service(
            service_name='user-service',
            service_id='user-service-1',
            port=5001,
            tags=['user', 'api']
        )
    
    def __del__(self):
        # 服务关闭时注销
        self.registry.deregister_service('user-service-1')
```

### 4.2 服务发现

```python
class ServiceDiscovery:
    def __init__(self, consul_host='localhost', consul_port=8500):
        self.consul = consul.Consul(host=consul_host, port=consul_port)
        self.service_cache = {}
        self.cache_ttl = 30  # 缓存30秒
    
    def get_service_url(self, service_name):
        """获取服务URL"""
        # 检查缓存
        if service_name in self.service_cache:
            cached_service, timestamp = self.service_cache[service_name]
            if (datetime.now() - timestamp).seconds < self.cache_ttl:
                return f"http://{cached_service['address']}:{cached_service['port']}"
        
        # 从注册中心获取服务信息
        service = self.get_service(service_name)
        if service:
            url = f"http://{service['address']}:{service['port']}"
            # 更新缓存
            self.service_cache[service_name] = (service, datetime.now())
            return url
        
        raise Exception(f"服务 {service_name} 不可用")
    
    def get_service(self, service_name):
        """获取服务信息"""
        _, services = self.consul.health.service(service_name, passing=True)
        if services:
            service = services[0]['Service']
            return {
                'id': service['ID'],
                'address': service['Address'],
                'port': service['Port']
            }
        return None

# 使用服务发现
class OrderService:
    def __init__(self):
        self.service_discovery = ServiceDiscovery()
    
    def create_order(self, user_id, items):
        """创建订单"""
        # 通过服务发现获取用户服务URL
        user_service_url = self.service_discovery.get_service_url('user-service')
        
        # 调用用户服务
        response = requests.get(f"{user_service_url}/users/{user_id}")
        if response.status_code != 200:
            raise Exception("用户不存在")
        
        # 创建订单逻辑
        pass
```

## 5. API网关

### 5.1 网关功能

```python
from flask import Flask, request, jsonify
import requests
import jwt
from functools import wraps

app = Flask(__name__)

class APIGateway:
    def __init__(self):
        self.service_discovery = ServiceDiscovery()
        self.secret_key = 'your-secret-key'
    
    def authenticate(self, f):
        """认证装饰器"""
        @wraps(f)
        def decorated_function(*args, **kwargs):
            token = request.headers.get('Authorization')
            if not token:
                return jsonify({'error': '缺少认证令牌'}), 401
            
            try:
                # 验证JWT令牌
                payload = jwt.decode(token.split(' ')[1], self.secret_key, algorithms=['HS256'])
                request.user_id = payload['user_id']
            except jwt.ExpiredSignatureError:
                return jsonify({'error': '令牌已过期'}), 401
            except jwt.InvalidTokenError:
                return jsonify({'error': '无效令牌'}), 401
            
            return f(*args, **kwargs)
        return decorated_function
    
    def rate_limit(self, f):
        """限流装饰器"""
        @wraps(f)
        def decorated_function(*args, **kwargs):
            # 实现限流逻辑
            return f(*args, **kwargs)
        return decorated_function
    
    @app.route('/api/users/<user_id>', methods=['GET'])
    @authenticate
    @rate_limit
    def get_user(self, user_id):
        """获取用户信息"""
        user_service_url = self.service_discovery.get_service_url('user-service')
        response = requests.get(f"{user_service_url}/users/{user_id}")
        return response.json(), response.status_code
    
    @app.route('/api/orders', methods=['POST'])
    @authenticate
    @rate_limit
    def create_order(self):
        """创建订单"""
        order_service_url = self.service_discovery.get_service_url('order-service')
        response = requests.post(f"{order_service_url}/orders", json=request.get_json())
        return response.json(), response.status_code
    
    @app.route('/api/payments', methods=['POST'])
    @authenticate
    @rate_limit
    def process_payment(self):
        """处理支付"""
        payment_service_url = self.service_discovery.get_service_url('payment-service')
        response = requests.post(f"{payment_service_url}/payments", json=request.get_json())
        return response.json(), response.status_code

if __name__ == '__main__':
    gateway = APIGateway()
    app.run(host='0.0.0.0', port=8080)
```

### 5.2 路由配置

```python
class GatewayConfig:
    def __init__(self):
        self.routes = {
            '/api/users': {
                'service': 'user-service',
                'methods': ['GET', 'POST', 'PUT', 'DELETE'],
                'timeout': 5,
                'retries': 3
            },
            '/api/orders': {
                'service': 'order-service',
                'methods': ['GET', 'POST', 'PUT'],
                'timeout': 10,
                'retries': 2
            },
            '/api/payments': {
                'service': 'payment-service',
                'methods': ['POST'],
                'timeout': 15,
                'retries': 1
            }
        }
    
    def get_route_config(self, path):
        """获取路由配置"""
        for route_path, config in self.routes.items():
            if path.startswith(route_path):
                return config
        return None
```

## 6. 配置管理

### 6.1 配置中心

```python
import etcd3
import json

class ConfigCenter:
    def __init__(self, host='localhost', port=2379):
        self.client = etcd3.client(host=host, port=port)
    
    def set_config(self, key, value):
        """设置配置"""
        self.client.put(key, json.dumps(value))
    
    def get_config(self, key):
        """获取配置"""
        value, _ = self.client.get(key)
        if value:
            return json.loads(value.decode())
        return None
    
    def watch_config(self, key, callback):
        """监听配置变化"""
        def on_change(event):
            if event.events:
                for change in event.events:
                    if change.key.decode() == key:
                        new_value = json.loads(change.value.decode())
                        callback(new_value)
        
        self.client.watch(key, callback=on_change)

# 使用配置中心
class UserService:
    def __init__(self):
        self.config_center = ConfigCenter()
        self.load_config()
        
        # 监听配置变化
        self.config_center.watch_config('/config/user-service', self.on_config_change)
    
    def load_config(self):
        """加载配置"""
        config = self.config_center.get_config('/config/user-service')
        if config:
            self.database_url = config.get('database_url')
            self.redis_url = config.get('redis_url')
            self.log_level = config.get('log_level', 'INFO')
    
    def on_config_change(self, new_config):
        """配置变化回调"""
        self.load_config()
        # 重新初始化相关组件
        self.initialize_components()
    
    def initialize_components(self):
        """初始化组件"""
        # 根据新配置重新初始化数据库连接等
        pass
```

### 6.2 环境配置

```python
import os
from dotenv import load_dotenv

class EnvironmentConfig:
    def __init__(self):
        load_dotenv()
        
        self.database_url = os.getenv('DATABASE_URL', 'postgresql://localhost/userdb')
        self.redis_url = os.getenv('REDIS_URL', 'redis://localhost:6379')
        self.service_port = int(os.getenv('SERVICE_PORT', 5001))
        self.log_level = os.getenv('LOG_LEVEL', 'INFO')
        self.consul_host = os.getenv('CONSUL_HOST', 'localhost')
        self.consul_port = int(os.getenv('CONSUL_PORT', 8500))
```

## 7. 监控与日志

### 7.1 健康检查

```python
from flask import Flask, jsonify
import psutil
import time

app = Flask(__name__)

class HealthCheck:
    def __init__(self):
        self.start_time = time.time()
    
    @app.route('/health', methods=['GET'])
    def health_check(self):
        """健康检查"""
        health_status = {
            'status': 'healthy',
            'timestamp': time.time(),
            'uptime': time.time() - self.start_time,
            'memory_usage': psutil.virtual_memory().percent,
            'cpu_usage': psutil.cpu_percent(),
            'services': self.check_dependencies()
        }
        
        # 检查所有依赖服务是否健康
        if not all(health_status['services'].values()):
            health_status['status'] = 'unhealthy'
            return jsonify(health_status), 503
        
        return jsonify(health_status), 200
    
    def check_dependencies(self):
        """检查依赖服务"""
        return {
            'database': self.check_database(),
            'redis': self.check_redis(),
            'external_api': self.check_external_api()
        }
    
    def check_database(self):
        """检查数据库连接"""
        try:
            # 执行简单查询
            self.db.execute("SELECT 1")
            return True
        except:
            return False
    
    def check_redis(self):
        """检查Redis连接"""
        try:
            self.redis.ping()
            return True
        except:
            return False
    
    def check_external_api(self):
        """检查外部API"""
        try:
            response = requests.get('http://external-api/health', timeout=5)
            return response.status_code == 200
        except:
            return False
```

### 7.2 分布式追踪

```python
import opentracing
import jaeger_client
from flask import request

class TracingMiddleware:
    def __init__(self):
        config = jaeger_client.Config(
            config={
                'sampler': {'type': 'const', 'param': 1},
                'local_agent': {'reporting_host': 'localhost', 'reporting_port': 6831},
                'logging': True,
            },
            service_name='user-service'
        )
        self.tracer = config.initialize_tracer()
    
    def trace_request(self, f):
        """追踪请求装饰器"""
        def decorated_function(*args, **kwargs):
            span_context = self.tracer.extract(
                opentracing.Format.HTTP_HEADERS,
                dict(request.headers)
            )
            
            with self.tracer.start_span(
                operation_name=f.__name__,
                child_of=span_context
            ) as span:
                span.set_tag('http.method', request.method)
                span.set_tag('http.url', request.url)
                
                result = f(*args, **kwargs)
                
                span.set_tag('http.status_code', result[1] if isinstance(result, tuple) else 200)
                return result
        
        return decorated_function

# 使用追踪
@app.route('/users/<user_id>', methods=['GET'])
@tracing.trace_request
def get_user(user_id):
    with tracer.start_span('database_query') as span:
        span.set_tag('user_id', user_id)
        user = user_repository.find_by_id(user_id)
    
    return jsonify(user), 200
```

## 8. 容错与熔断

### 8.1 熔断器模式

```python
import time
from enum import Enum

class CircuitState(Enum):
    CLOSED = "CLOSED"
    OPEN = "OPEN"
    HALF_OPEN = "HALF_OPEN"

class CircuitBreaker:
    def __init__(self, failure_threshold=5, recovery_timeout=60, expected_exception=Exception):
        self.failure_threshold = failure_threshold
        self.recovery_timeout = recovery_timeout
        self.expected_exception = expected_exception
        
        self.failure_count = 0
        self.last_failure_time = None
        self.state = CircuitState.CLOSED
    
    def call(self, func, *args, **kwargs):
        """执行函数调用"""
        if self.state == CircuitState.OPEN:
            if time.time() - self.last_failure_time > self.recovery_timeout:
                self.state = CircuitState.HALF_OPEN
            else:
                raise Exception("熔断器开启，拒绝请求")
        
        try:
            result = func(*args, **kwargs)
            self.on_success()
            return result
        except self.expected_exception as e:
            self.on_failure()
            raise e
    
    def on_success(self):
        """成功回调"""
        self.failure_count = 0
        self.state = CircuitState.CLOSED
    
    def on_failure(self):
        """失败回调"""
        self.failure_count += 1
        self.last_failure_time = time.time()
        
        if self.failure_count >= self.failure_threshold:
            self.state = CircuitState.OPEN

# 使用熔断器
class UserService:
    def __init__(self):
        self.circuit_breaker = CircuitBreaker()
    
    def get_user_from_external_service(self, user_id):
        """从外部服务获取用户信息"""
        def external_call():
            response = requests.get(f"http://external-service/users/{user_id}", timeout=5)
            response.raise_for_status()
            return response.json()
        
        return self.circuit_breaker.call(external_call)
```

### 8.2 重试机制

```python
import time
import random

class RetryMechanism:
    def __init__(self, max_retries=3, base_delay=1, max_delay=60, backoff_factor=2):
        self.max_retries = max_retries
        self.base_delay = base_delay
        self.max_delay = max_delay
        self.backoff_factor = backoff_factor
    
    def call_with_retry(self, func, *args, **kwargs):
        """带重试的函数调用"""
        last_exception = None
        
        for attempt in range(self.max_retries + 1):
            try:
                return func(*args, **kwargs)
            except Exception as e:
                last_exception = e
                
                if attempt == self.max_retries:
                    raise last_exception
                
                # 计算延迟时间（指数退避）
                delay = min(
                    self.base_delay * (self.backoff_factor ** attempt),
                    self.max_delay
                )
                
                # 添加随机抖动
                delay += random.uniform(0, 0.1 * delay)
                
                time.sleep(delay)
        
        raise last_exception

# 使用重试机制
class OrderService:
    def __init__(self):
        self.retry_mechanism = RetryMechanism()
    
    def create_order(self, user_id, items):
        """创建订单"""
        def create_order_call():
            # 调用用户服务
            user_response = requests.get(f"http://user-service/users/{user_id}")
            user_response.raise_for_status()
            
            # 调用支付服务
            payment_response = requests.post("http://payment-service/payments", json={
                'user_id': user_id,
                'amount': self.calculate_total(items)
            })
            payment_response.raise_for_status()
            
            # 创建订单
            return self.order_repository.save(Order(user_id=user_id, items=items))
        
        return self.retry_mechanism.call_with_retry(create_order_call)
```

## 9. 数据一致性

### 9.1 Saga模式

```python
from enum import Enum

class SagaStepStatus(Enum):
    PENDING = "PENDING"
    COMPLETED = "COMPLETED"
    FAILED = "FAILED"

class SagaStep:
    def __init__(self, name, action, compensation):
        self.name = name
        self.action = action
        self.compensation = compensation
        self.status = SagaStepStatus.PENDING

class SagaOrchestrator:
    def __init__(self):
        self.steps = []
        self.executed_steps = []
    
    def add_step(self, step):
        """添加Saga步骤"""
        self.steps.append(step)
    
    def execute(self):
        """执行Saga"""
        try:
            for step in self.steps:
                step.action()
                step.status = SagaStepStatus.COMPLETED
                self.executed_steps.append(step)
        except Exception as e:
            self.compensate()
            raise e
    
    def compensate(self):
        """补偿操作"""
        for step in reversed(self.executed_steps):
            try:
                step.compensation()
                step.status = SagaStepStatus.FAILED
            except Exception as e:
                # 记录补偿失败，但继续执行其他补偿
                print(f"补偿步骤 {step.name} 失败: {e}")

# 使用Saga模式
class OrderSaga:
    def __init__(self, user_id, items):
        self.user_id = user_id
        self.items = items
        self.orchestrator = SagaOrchestrator()
        
        # 定义Saga步骤
        self.orchestrator.add_step(SagaStep(
            name="reserve_inventory",
            action=self.reserve_inventory,
            compensation=self.release_inventory
        ))
        
        self.orchestrator.add_step(SagaStep(
            name="process_payment",
            action=self.process_payment,
            compensation=self.refund_payment
        ))
        
        self.orchestrator.add_step(SagaStep(
            name="create_order",
            action=self.create_order,
            compensation=self.cancel_order
        ))
    
    def execute(self):
        """执行订单创建Saga"""
        return self.orchestrator.execute()
    
    def reserve_inventory(self):
        """预留库存"""
        # 实现库存预留逻辑
        pass
    
    def release_inventory(self):
        """释放库存"""
        # 实现库存释放逻辑
        pass
    
    def process_payment(self):
        """处理支付"""
        # 实现支付处理逻辑
        pass
    
    def refund_payment(self):
        """退款"""
        # 实现退款逻辑
        pass
    
    def create_order(self):
        """创建订单"""
        # 实现订单创建逻辑
        pass
    
    def cancel_order(self):
        """取消订单"""
        # 实现订单取消逻辑
        pass
```

### 9.2 事件溯源

```python
from datetime import datetime
import uuid

class Event:
    def __init__(self, event_type, data, aggregate_id):
        self.id = str(uuid.uuid4())
        self.event_type = event_type
        self.data = data
        self.aggregate_id = aggregate_id
        self.timestamp = datetime.now()
        self.version = 1

class EventStore:
    def __init__(self):
        self.events = []
    
    def append_event(self, event):
        """添加事件"""
        self.events.append(event)
    
    def get_events(self, aggregate_id):
        """获取聚合根的所有事件"""
        return [event for event in self.events if event.aggregate_id == aggregate_id]

class OrderAggregate:
    def __init__(self, order_id):
        self.order_id = order_id
        self.user_id = None
        self.items = []
        self.status = 'created'
        self.version = 0
    
    def apply_event(self, event):
        """应用事件"""
        if event.event_type == 'OrderCreated':
            self.user_id = event.data['user_id']
            self.items = event.data['items']
        elif event.event_type == 'OrderConfirmed':
            self.status = 'confirmed'
        elif event.event_type == 'OrderCancelled':
            self.status = 'cancelled'
        
        self.version += 1
    
    def create_order(self, user_id, items):
        """创建订单"""
        event = Event('OrderCreated', {
            'user_id': user_id,
            'items': items
        }, self.order_id)
        
        self.apply_event(event)
        return event
    
    def confirm_order(self):
        """确认订单"""
        event = Event('OrderConfirmed', {}, self.order_id)
        self.apply_event(event)
        return event
    
    def cancel_order(self):
        """取消订单"""
        event = Event('OrderCancelled', {}, self.order_id)
        self.apply_event(event)
        return event

class OrderService:
    def __init__(self):
        self.event_store = EventStore()
    
    def create_order(self, user_id, items):
        """创建订单"""
        order_id = str(uuid.uuid4())
        aggregate = OrderAggregate(order_id)
        
        # 创建订单事件
        event = aggregate.create_order(user_id, items)
        self.event_store.append_event(event)
        
        return order_id
    
    def get_order(self, order_id):
        """获取订单"""
        events = self.event_store.get_events(order_id)
        aggregate = OrderAggregate(order_id)
        
        # 重放所有事件
        for event in events:
            aggregate.apply_event(event)
        
        return aggregate
```

## 10. 部署与运维

### 10.1 容器化部署

```dockerfile
# Dockerfile
FROM python:3.9-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .

EXPOSE 5001

CMD ["python", "app.py"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  user-service:
    build: ./user-service
    ports:
      - "5001:5001"
    environment:
      - DATABASE_URL=postgresql://user:password@postgres:5432/userdb
      - REDIS_URL=redis://redis:6379
    depends_on:
      - postgres
      - redis
    networks:
      - microservices

  order-service:
    build: ./order-service
    ports:
      - "5002:5002"
    environment:
      - DATABASE_URL=postgresql://user:password@postgres:5432/orderdb
      - REDIS_URL=redis://redis:6379
    depends_on:
      - postgres
      - redis
    networks:
      - microservices

  payment-service:
    build: ./payment-service
    ports:
      - "5003:5003"
    environment:
      - DATABASE_URL=postgresql://user:password@postgres:5432/paymentdb
      - REDIS_URL=redis://redis:6379
    depends_on:
      - postgres
      - redis
    networks:
      - microservices

  api-gateway:
    build: ./api-gateway
    ports:
      - "8080:8080"
    environment:
      - CONSUL_HOST=consul
    depends_on:
      - consul
    networks:
      - microservices

  postgres:
    image: postgres:13
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=userdb
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - microservices

  redis:
    image: redis:6
    networks:
      - microservices

  consul:
    image: consul:1.10
    ports:
      - "8500:8500"
    networks:
      - microservices

networks:
  microservices:
    driver: bridge

volumes:
  postgres_data:
```

### 10.2 Kubernetes部署

```yaml
# user-service-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: user-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: user-service
  template:
    metadata:
      labels:
        app: user-service
    spec:
      containers:
      - name: user-service
        image: user-service:latest
        ports:
        - containerPort: 5001
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: url
        - name: REDIS_URL
          valueFrom:
            configMapKeyRef:
              name: app-config
              key: redis_url
        livenessProbe:
          httpGet:
            path: /health
            port: 5001
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 5001
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: user-service
spec:
  selector:
    app: user-service
  ports:
  - port: 80
    targetPort: 5001
  type: ClusterIP
```

## 11. 最佳实践

### 11.1 设计原则

1. **单一职责**：每个服务只负责一个业务功能
2. **松耦合**：服务间通过标准接口通信
3. **高内聚**：服务内部功能紧密相关
4. **独立部署**：服务可以独立开发和部署
5. **技术多样性**：不同服务可以使用不同技术栈

### 11.2 开发实践

1. **API设计**：遵循RESTful设计原则
2. **错误处理**：统一的错误处理机制
3. **日志记录**：结构化日志记录
4. **监控指标**：关键业务指标监控
5. **安全防护**：认证、授权、加密

### 11.3 运维实践

1. **自动化部署**：CI/CD流水线
2. **配置管理**：集中化配置管理
3. **监控告警**：实时监控和告警
4. **日志聚合**：集中化日志管理
5. **故障恢复**：快速故障恢复机制

## 12. 未来发展方向

### 12.1 服务网格

- **Istio**：服务间通信管理
- **Linkerd**：轻量级服务网格
- **Envoy**：高性能代理

### 12.2 无服务器架构

- **AWS Lambda**：事件驱动计算
- **Azure Functions**：云函数服务
- **Google Cloud Functions**：无服务器计算

### 12.3 事件驱动架构

- **Apache Kafka**：分布式流处理
- **Apache Pulsar**：云原生消息系统
- **EventStore**：事件存储数据库

---

**相关链接**：
- [云原生架构实践](./4.1.14-云原生架构实践.md)
- [DevOps与CI/CD](./4.1.15-DevOps与CI/CD.md)

**最后更新时间**：2024年12月
**文档状态**：完成 