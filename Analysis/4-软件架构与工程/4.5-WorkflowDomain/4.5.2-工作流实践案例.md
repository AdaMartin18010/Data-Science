# å·¥ä½œæµå®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [å·¥ä½œæµå®è·µæ¡ˆä¾‹](#å·¥ä½œæµå®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2. å·¥ä½œæµå¼•æ“](#2-å·¥ä½œæµå¼•æ“)
    - [2.1. åŸºç¡€å·¥ä½œæµå¼•æ“](#21-åŸºç¡€å·¥ä½œæµå¼•æ“)
  - [3. çŠ¶æ€æœºå·¥ä½œæµ](#3-çŠ¶æ€æœºå·¥ä½œæµ)
  - [4. ä»»åŠ¡è°ƒåº¦](#4-ä»»åŠ¡è°ƒåº¦)
    - [4.1. ä»»åŠ¡è°ƒåº¦å™¨](#41-ä»»åŠ¡è°ƒåº¦å™¨)
  - [5. åˆ†å¸ƒå¼ä»»åŠ¡è°ƒåº¦](#5-åˆ†å¸ƒå¼ä»»åŠ¡è°ƒåº¦)
  - [6. æµç¨‹ç®¡ç†](#6-æµç¨‹ç®¡ç†)
    - [6.1. æµç¨‹å®šä¹‰ä¸æ‰§è¡Œ](#61-æµç¨‹å®šä¹‰ä¸æ‰§è¡Œ)
  - [7. æ€»ç»“](#7-æ€»ç»“)

---


## 1. æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›å·¥ä½œæµæŠ€æœ¯çš„å®è·µæ¡ˆä¾‹ï¼ŒåŒ…æ‹¬å·¥ä½œæµå¼•æ“ã€ä»»åŠ¡è°ƒåº¦ã€æµç¨‹ç®¡ç†ã€çŠ¶æ€æœºç­‰å®é™…åº”ç”¨åœºæ™¯ã€‚

## 2. å·¥ä½œæµå¼•æ“

### 2.1. åŸºç¡€å·¥ä½œæµå¼•æ“

```python
from enum import Enum
from typing import Dict, List, Any
from datetime import datetime

class TaskStatus(Enum):
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"

class WorkflowStatus(Enum):
    CREATED = "created"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    PAUSED = "paused"

class Task:
    def __init__(self, task_id: str, name: str, task_type: str):
        self.task_id = task_id
        self.name = name
        self.task_type = task_type
        self.status = TaskStatus.PENDING
        self.input_data = {}
        self.output_data = {}
        self.dependencies = []
        self.created_at = datetime.now()
        self.started_at = None
        self.completed_at = None
        self.error_message = None

    def can_start(self, completed_tasks: List[str]) -> bool:
        """æ£€æŸ¥ä»»åŠ¡æ˜¯å¦å¯ä»¥å¼€å§‹"""
        return all(dep in completed_tasks for dep in self.dependencies)

    def start(self):
        """å¼€å§‹ä»»åŠ¡"""
        self.status = TaskStatus.RUNNING
        self.started_at = datetime.now()

    def complete(self, output_data: Dict = None):
        """å®Œæˆä»»åŠ¡"""
        self.status = TaskStatus.COMPLETED
        self.completed_at = datetime.now()
        if output_data:
            self.output_data = output_data

    def fail(self, error_message: str):
        """ä»»åŠ¡å¤±è´¥"""
        self.status = TaskStatus.FAILED
        self.completed_at = datetime.now()
        self.error_message = error_message

class Workflow:
    def __init__(self, workflow_id: str, name: str):
        self.workflow_id = workflow_id
        self.name = name
        self.status = WorkflowStatus.CREATED
        self.tasks: Dict[str, Task] = {}
        self.task_execution_order = []
        self.created_at = datetime.now()
        self.started_at = None
        self.completed_at = None

    def add_task(self, task: Task):
        """æ·»åŠ ä»»åŠ¡"""
        self.tasks[task.task_id] = task

    def add_dependency(self, task_id: str, depends_on: str):
        """æ·»åŠ ä»»åŠ¡ä¾èµ–"""
        if task_id in self.tasks and depends_on in self.tasks:
            self.tasks[task_id].dependencies.append(depends_on)

    def get_ready_tasks(self, completed_tasks: List[str]) -> List[Task]:
        """è·å–å¯ä»¥æ‰§è¡Œçš„ä»»åŠ¡"""
        ready_tasks = []
        for task in self.tasks.values():
            if (task.status == TaskStatus.PENDING and
                task.can_start(completed_tasks)):
                ready_tasks.append(task)
        return ready_tasks

    def start(self):
        """å¼€å§‹å·¥ä½œæµ"""
        self.status = WorkflowStatus.RUNNING
        self.started_at = datetime.now()

    def complete(self):
        """å®Œæˆå·¥ä½œæµ"""
        self.status = WorkflowStatus.COMPLETED
        self.completed_at = datetime.now()

    def fail(self):
        """å·¥ä½œæµå¤±è´¥"""
        self.status = WorkflowStatus.FAILED
        self.completed_at = datetime.now()

class WorkflowEngine:
    def __init__(self):
        self.workflows: Dict[str, Workflow] = {}
        self.task_handlers: Dict[str, callable] = {}
        self.execution_history = []

    def register_task_handler(self, task_type: str, handler: callable):
        """æ³¨å†Œä»»åŠ¡å¤„ç†å™¨"""
        self.task_handlers[task_type] = handler

    def create_workflow(self, workflow_id: str, name: str) -> Workflow:
        """åˆ›å»ºå·¥ä½œæµ"""
        workflow = Workflow(workflow_id, name)
        self.workflows[workflow_id] = workflow
        return workflow

    def execute_workflow(self, workflow_id: str) -> bool:
        """æ‰§è¡Œå·¥ä½œæµ"""
        if workflow_id not in self.workflows:
            return False

        workflow = self.workflows[workflow_id]
        workflow.start()

        completed_tasks = []
        failed_tasks = []

        while True:
# è·å–å¯ä»¥æ‰§è¡Œçš„ä»»åŠ¡
            ready_tasks = workflow.get_ready_tasks(completed_tasks)

            if not ready_tasks and len(completed_tasks) == len(workflow.tasks):
# æ‰€æœ‰ä»»åŠ¡å®Œæˆ
                workflow.complete()
                break

            if not ready_tasks and len(failed_tasks) > 0:
# æœ‰ä»»åŠ¡å¤±è´¥ï¼Œå·¥ä½œæµå¤±è´¥
                workflow.fail()
                break

# æ‰§è¡Œå°±ç»ªä»»åŠ¡
            for task in ready_tasks:
                try:
                    self._execute_task(task)
                    completed_tasks.append(task.task_id)
                except Exception as e:
                    task.fail(str(e))
                    failed_tasks.append(task.task_id)

        return workflow.status == WorkflowStatus.COMPLETED

    def _execute_task(self, task: Task):
        """æ‰§è¡Œå•ä¸ªä»»åŠ¡"""
        task.start()

        if task.task_type in self.task_handlers:
            handler = self.task_handlers[task.task_type]
            output_data = handler(task.input_data)
            task.complete(output_data)
        else:
            raise Exception(f"æœªæ‰¾åˆ°ä»»åŠ¡ç±»å‹ {task.task_type} çš„å¤„ç†å™¨")

# ä½¿ç”¨ç¤ºä¾‹
def data_processing_handler(input_data: Dict) -> Dict:
    """æ•°æ®å¤„ç†ä»»åŠ¡å¤„ç†å™¨"""
    print(f"å¤„ç†æ•°æ®: {input_data}")
    return {"processed_data": "result", "status": "success"}

def notification_handler(input_data: Dict) -> Dict:
    """é€šçŸ¥ä»»åŠ¡å¤„ç†å™¨"""
    print(f"å‘é€é€šçŸ¥: {input_data}")
    return {"notification_sent": True}

# åˆ›å»ºå·¥ä½œæµå¼•æ“
engine = WorkflowEngine()
engine.register_task_handler("data_processing", data_processing_handler)
engine.register_task_handler("notification", notification_handler)

# åˆ›å»ºå·¥ä½œæµ
workflow = engine.create_workflow("wf_001", "æ•°æ®å¤„ç†å·¥ä½œæµ")

# æ·»åŠ ä»»åŠ¡
task1 = Task("task_1", "æ•°æ®é¢„å¤„ç†", "data_processing")
task2 = Task("task_2", "æ•°æ®éªŒè¯", "data_processing")
task3 = Task("task_3", "å‘é€é€šçŸ¥", "notification")

workflow.add_task(task1)
workflow.add_task(task2)
workflow.add_task(task3)

# è®¾ç½®ä¾èµ–å…³ç³»
workflow.add_dependency("task_2", "task_1")
workflow.add_dependency("task_3", "task_2")

# æ‰§è¡Œå·¥ä½œæµ
success = engine.execute_workflow("wf_001")
print(f"å·¥ä½œæµæ‰§è¡Œ: {'æˆåŠŸ' if success else 'å¤±è´¥'}")
```

## 3. çŠ¶æ€æœºå·¥ä½œæµ

```python
from enum import Enum
from typing import Dict, List, Callable

class State(Enum):
    INIT = "init"
    PROCESSING = "processing"
    REVIEW = "review"
    APPROVED = "approved"
    REJECTED = "rejected"
    COMPLETED = "completed"

class StateMachine:
    def __init__(self, name: str):
        self.name = name
        self.current_state = State.INIT
        self.transitions = {}
        self.state_handlers = {}
        self.history = []

    def add_transition(self, from_state: State, to_state: State,
                      condition: Callable = None, action: Callable = None):
        """æ·»åŠ çŠ¶æ€è½¬æ¢"""
        if from_state not in self.transitions:
            self.transitions[from_state] = []

        self.transitions[from_state].append({
            "to_state": to_state,
            "condition": condition,
            "action": action
        })

    def add_state_handler(self, state: State, handler: Callable):
        """æ·»åŠ çŠ¶æ€å¤„ç†å™¨"""
        self.state_handlers[state] = handler

    def can_transition_to(self, to_state: State, context: Dict = None) -> bool:
        """æ£€æŸ¥æ˜¯å¦å¯ä»¥è½¬æ¢åˆ°æŒ‡å®šçŠ¶æ€"""
        if self.current_state not in self.transitions:
            return False

        for transition in self.transitions[self.current_state]:
            if transition["to_state"] == to_state:
                condition = transition.get("condition")
                if condition is None or condition(context):
                    return True

        return False

    def transition_to(self, to_state: State, context: Dict = None):
        """è½¬æ¢åˆ°æŒ‡å®šçŠ¶æ€"""
        if not self.can_transition_to(to_state, context):
            raise Exception(f"æ— æ³•ä» {self.current_state} è½¬æ¢åˆ° {to_state}")

# æ‰§è¡Œè½¬æ¢åŠ¨ä½œ
        for transition in self.transitions[self.current_state]:
            if transition["to_state"] == to_state:
                action = transition.get("action")
                if action:
                    action(context)
                break

# è®°å½•å†å²
        self.history.append({
            "from_state": self.current_state,
            "to_state": to_state,
            "timestamp": datetime.now(),
            "context": context
        })

# æ›´æ–°çŠ¶æ€
        self.current_state = to_state

# æ‰§è¡ŒçŠ¶æ€å¤„ç†å™¨
        if to_state in self.state_handlers:
            self.state_handlers[to_state](context)

    def get_available_transitions(self, context: Dict = None) -> List[State]:
        """è·å–å¯ç”¨çš„çŠ¶æ€è½¬æ¢"""
        available = []
        if self.current_state in self.transitions:
            for transition in self.transitions[self.current_state]:
                condition = transition.get("condition")
                if condition is None or condition(context):
                    available.append(transition["to_state"])
        return available

# ä½¿ç”¨ç¤ºä¾‹ï¼šå®¡æ‰¹å·¥ä½œæµ
def processing_handler(context: Dict):
    print(f"è¿›å…¥å¤„ç†çŠ¶æ€: {context}")

def review_handler(context: Dict):
    print(f"è¿›å…¥å®¡æ ¸çŠ¶æ€: {context}")

def approval_handler(context: Dict):
    print(f"è¿›å…¥æ‰¹å‡†çŠ¶æ€: {context}")

# åˆ›å»ºçŠ¶æ€æœº
approval_workflow = StateMachine("å®¡æ‰¹å·¥ä½œæµ")

# æ·»åŠ çŠ¶æ€å¤„ç†å™¨
approval_workflow.add_state_handler(State.PROCESSING, processing_handler)
approval_workflow.add_state_handler(State.REVIEW, review_handler)
approval_workflow.add_state_handler(State.APPROVED, approval_handler)

# å®šä¹‰è½¬æ¢æ¡ä»¶
def can_process(context: Dict) -> bool:
    return context.get("data_ready", False)

def can_review(context: Dict) -> bool:
    return context.get("processing_complete", False)

def can_approve(context: Dict) -> bool:
    return context.get("review_passed", False)

# æ·»åŠ çŠ¶æ€è½¬æ¢
approval_workflow.add_transition(State.INIT, State.PROCESSING, can_process)
approval_workflow.add_transition(State.PROCESSING, State.REVIEW, can_review)
approval_workflow.add_transition(State.REVIEW, State.APPROVED, can_approve)
approval_workflow.add_transition(State.REVIEW, State.REJECTED)
approval_workflow.add_transition(State.APPROVED, State.COMPLETED)
approval_workflow.add_transition(State.REJECTED, State.COMPLETED)

# æ‰§è¡Œå·¥ä½œæµ
context = {"data_ready": True}
print(f"å½“å‰çŠ¶æ€: {approval_workflow.current_state}")

# è½¬æ¢åˆ°å¤„ç†çŠ¶æ€
approval_workflow.transition_to(State.PROCESSING, context)
print(f"å½“å‰çŠ¶æ€: {approval_workflow.current_state}")

# æ›´æ–°ä¸Šä¸‹æ–‡å¹¶è½¬æ¢åˆ°å®¡æ ¸çŠ¶æ€
context["processing_complete"] = True
approval_workflow.transition_to(State.REVIEW, context)
print(f"å½“å‰çŠ¶æ€: {approval_workflow.current_state}")

# è·å–å¯ç”¨è½¬æ¢
available = approval_workflow.get_available_transitions(context)
print(f"å¯ç”¨è½¬æ¢: {available}")
```

## 4. ä»»åŠ¡è°ƒåº¦

### 4.1. ä»»åŠ¡è°ƒåº¦å™¨

```python
import time
import threading
from queue import Queue, PriorityQueue
from datetime import datetime, timedelta

class ScheduledTask:
    def __init__(self, task_id: str, task_func: callable,
                 schedule_time: datetime, priority: int = 0):
        self.task_id = task_id
        self.task_func = task_func
        self.schedule_time = schedule_time
        self.priority = priority
        self.status = "pending"
        self.created_at = datetime.now()

    def __lt__(self, other):
# ä¼˜å…ˆçº§é˜Ÿåˆ—æ¯”è¾ƒæ–¹æ³•
        if self.schedule_time != other.schedule_time:
            return self.schedule_time < other.schedule_time
        return self.priority > other.priority

class TaskScheduler:
    def __init__(self):
        self.task_queue = PriorityQueue()
        self.running = False
        self.worker_thread = None
        self.completed_tasks = []
        self.failed_tasks = []

    def schedule_task(self, task_id: str, task_func: callable,
                     schedule_time: datetime, priority: int = 0):
        """è°ƒåº¦ä»»åŠ¡"""
        task = ScheduledTask(task_id, task_func, schedule_time, priority)
        self.task_queue.put(task)
        print(f"ä»»åŠ¡ {task_id} å·²è°ƒåº¦ï¼Œæ‰§è¡Œæ—¶é—´: {schedule_time}")

    def schedule_recurring_task(self, task_id: str, task_func: callable,
                              interval_seconds: int, priority: int = 0):
        """è°ƒåº¦é‡å¤ä»»åŠ¡"""
        def recurring_wrapper():
            task_func()
# é‡æ–°è°ƒåº¦ä¸‹ä¸€æ¬¡æ‰§è¡Œ
            next_time = datetime.now() + timedelta(seconds=interval_seconds)
            self.schedule_task(f"{task_id}_recurring", task_func, next_time, priority)

        self.schedule_task(task_id, recurring_wrapper, datetime.now(), priority)

    def start(self):
        """å¯åŠ¨è°ƒåº¦å™¨"""
        self.running = True
        self.worker_thread = threading.Thread(target=self._worker_loop)
        self.worker_thread.start()
        print("ä»»åŠ¡è°ƒåº¦å™¨å·²å¯åŠ¨")

    def stop(self):
        """åœæ­¢è°ƒåº¦å™¨"""
        self.running = False
        if self.worker_thread:
            self.worker_thread.join()
        print("ä»»åŠ¡è°ƒåº¦å™¨å·²åœæ­¢")

    def _worker_loop(self):
        """å·¥ä½œå¾ªç¯"""
        while self.running:
            try:
                if not self.task_queue.empty():
                    task = self.task_queue.get_nowait()

                    if datetime.now() >= task.schedule_time:
# æ‰§è¡Œä»»åŠ¡
                        self._execute_task(task)
                    else:
# é‡æ–°æ”¾å›é˜Ÿåˆ—
                        self.task_queue.put(task)
                        time.sleep(1)
                else:
                    time.sleep(1)
            except Exception as e:
                print(f"è°ƒåº¦å™¨é”™è¯¯: {e}")
                time.sleep(1)

    def _execute_task(self, task: ScheduledTask):
        """æ‰§è¡Œä»»åŠ¡"""
        try:
            task.status = "running"
            print(f"æ‰§è¡Œä»»åŠ¡: {task.task_id}")

            task.task_func()

            task.status = "completed"
            self.completed_tasks.append(task)
            print(f"ä»»åŠ¡å®Œæˆ: {task.task_id}")

        except Exception as e:
            task.status = "failed"
            self.failed_tasks.append(task)
            print(f"ä»»åŠ¡å¤±è´¥: {task.task_id}, é”™è¯¯: {e}")

    def get_statistics(self) -> Dict:
        """è·å–ç»Ÿè®¡ä¿¡æ¯"""
        return {
            "pending_tasks": self.task_queue.qsize(),
            "completed_tasks": len(self.completed_tasks),
            "failed_tasks": len(self.failed_tasks),
            "total_tasks": self.task_queue.qsize() + len(self.completed_tasks) + len(self.failed_tasks)
        }

# ä½¿ç”¨ç¤ºä¾‹
def sample_task():
    print(f"æ‰§è¡Œç¤ºä¾‹ä»»åŠ¡ï¼Œæ—¶é—´: {datetime.now()}")

def data_backup_task():
    print(f"æ‰§è¡Œæ•°æ®å¤‡ä»½ï¼Œæ—¶é—´: {datetime.now()}")

# åˆ›å»ºè°ƒåº¦å™¨
scheduler = TaskScheduler()

# è°ƒåº¦ä¸€æ¬¡æ€§ä»»åŠ¡
future_time = datetime.now() + timedelta(seconds=5)
scheduler.schedule_task("sample_task", sample_task, future_time)

# è°ƒåº¦é‡å¤ä»»åŠ¡
scheduler.schedule_recurring_task("backup_task", data_backup_task, 10)

# å¯åŠ¨è°ƒåº¦å™¨
scheduler.start()

# è¿è¡Œä¸€æ®µæ—¶é—´
time.sleep(15)

# åœæ­¢è°ƒåº¦å™¨
scheduler.stop()

# æŸ¥çœ‹ç»Ÿè®¡ä¿¡æ¯
stats = scheduler.get_statistics()
print(f"è°ƒåº¦å™¨ç»Ÿè®¡: {stats}")
```

## 5. åˆ†å¸ƒå¼ä»»åŠ¡è°ƒåº¦

```python
import json
import uuid
from typing import Dict, List

class DistributedTask:
    def __init__(self, task_id: str, task_type: str, payload: Dict):
        self.task_id = task_id
        self.task_type = task_type
        self.payload = payload
        self.status = "pending"
        self.assigned_worker = None
        self.created_at = datetime.now()
        self.started_at = None
        self.completed_at = None
        self.result = None
        self.error = None

    def to_dict(self) -> Dict:
        return {
            "task_id": self.task_id,
            "task_type": self.task_type,
            "payload": self.payload,
            "status": self.status,
            "assigned_worker": self.assigned_worker,
            "created_at": self.created_at.isoformat(),
            "started_at": self.started_at.isoformat() if self.started_at else None,
            "completed_at": self.completed_at.isoformat() if self.completed_at else None,
            "result": self.result,
            "error": self.error
        }

class Worker:
    def __init__(self, worker_id: str, capabilities: List[str]):
        self.worker_id = worker_id
        self.capabilities = capabilities
        self.status = "idle"
        self.current_task = None
        self.completed_tasks = 0
        self.failed_tasks = 0
        self.last_heartbeat = datetime.now()

    def can_handle_task(self, task_type: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦å¯ä»¥å¤„ç†æŒ‡å®šç±»å‹çš„ä»»åŠ¡"""
        return task_type in self.capabilities

    def assign_task(self, task: DistributedTask):
        """åˆ†é…ä»»åŠ¡"""
        self.current_task = task
        self.status = "busy"
        task.assigned_worker = self.worker_id
        task.status = "running"
        task.started_at = datetime.now()

    def complete_task(self, result: Any = None):
        """å®Œæˆä»»åŠ¡"""
        if self.current_task:
            self.current_task.status = "completed"
            self.current_task.completed_at = datetime.now()
            self.current_task.result = result
            self.completed_tasks += 1
            self.current_task = None
            self.status = "idle"

    def fail_task(self, error: str):
        """ä»»åŠ¡å¤±è´¥"""
        if self.current_task:
            self.current_task.status = "failed"
            self.current_task.completed_at = datetime.now()
            self.current_task.error = error
            self.failed_tasks += 1
            self.current_task = None
            self.status = "idle"

class DistributedTaskScheduler:
    def __init__(self):
        self.tasks: Dict[str, DistributedTask] = {}
        self.workers: Dict[str, Worker] = {}
        self.task_queue = []
        self.completed_tasks = []
        self.failed_tasks = []

    def register_worker(self, worker: Worker):
        """æ³¨å†Œå·¥ä½œèŠ‚ç‚¹"""
        self.workers[worker.worker_id] = worker
        print(f"å·¥ä½œèŠ‚ç‚¹æ³¨å†Œ: {worker.worker_id}")

    def submit_task(self, task_type: str, payload: Dict) -> str:
        """æäº¤ä»»åŠ¡"""
        task_id = str(uuid.uuid4())
        task = DistributedTask(task_id, task_type, payload)
        self.tasks[task_id] = task
        self.task_queue.append(task_id)
        print(f"ä»»åŠ¡æäº¤: {task_id}, ç±»å‹: {task_type}")
        return task_id

    def assign_tasks(self):
        """åˆ†é…ä»»åŠ¡"""
        idle_workers = [w for w in self.workers.values() if w.status == "idle"]

        for task_id in self.task_queue[:]:
            task = self.tasks[task_id]

            if task.status != "pending":
                continue

# æ‰¾åˆ°å¯ä»¥å¤„ç†è¯¥ä»»åŠ¡çš„å·¥ä½œèŠ‚ç‚¹
            suitable_worker = None
            for worker in idle_workers:
                if worker.can_handle_task(task.task_type):
                    suitable_worker = worker
                    break

            if suitable_worker:
                suitable_worker.assign_task(task)
                self.task_queue.remove(task_id)
                idle_workers.remove(suitable_worker)
                print(f"ä»»åŠ¡ {task_id} åˆ†é…ç»™å·¥ä½œèŠ‚ç‚¹ {suitable_worker.worker_id}")

    def get_task_status(self, task_id: str) -> Dict:
        """è·å–ä»»åŠ¡çŠ¶æ€"""
        if task_id in self.tasks:
            return self.tasks[task_id].to_dict()
        return None

    def get_worker_status(self) -> Dict:
        """è·å–å·¥ä½œèŠ‚ç‚¹çŠ¶æ€"""
        return {
            worker_id: {
                "status": worker.status,
                "capabilities": worker.capabilities,
                "completed_tasks": worker.completed_tasks,
                "failed_tasks": worker.failed_tasks,
                "current_task": worker.current_task.task_id if worker.current_task else None
            }
            for worker_id, worker in self.workers.items()
        }

# ä½¿ç”¨ç¤ºä¾‹
def data_processing_task(payload: Dict):
    print(f"å¤„ç†æ•°æ®: {payload}")
    return {"processed": True, "result": "success"}

def notification_task(payload: Dict):
    print(f"å‘é€é€šçŸ¥: {payload}")
    return {"notification_sent": True}

# åˆ›å»ºåˆ†å¸ƒå¼è°ƒåº¦å™¨
distributed_scheduler = DistributedTaskScheduler()

# æ³¨å†Œå·¥ä½œèŠ‚ç‚¹
worker1 = Worker("worker_001", ["data_processing", "notification"])
worker2 = Worker("worker_002", ["data_processing"])
worker3 = Worker("worker_003", ["notification"])

distributed_scheduler.register_worker(worker1)
distributed_scheduler.register_worker(worker2)
distributed_scheduler.register_worker(worker3)

# æäº¤ä»»åŠ¡
task1_id = distributed_scheduler.submit_task("data_processing", {"data": "sample_data"})
task2_id = distributed_scheduler.submit_task("notification", {"message": "Hello"})
task3_id = distributed_scheduler.submit_task("data_processing", {"data": "another_data"})

# åˆ†é…ä»»åŠ¡
distributed_scheduler.assign_tasks()

# æ¨¡æ‹Ÿä»»åŠ¡æ‰§è¡Œ
for worker in distributed_scheduler.workers.values():
    if worker.current_task:
        if worker.current_task.task_type == "data_processing":
            worker.complete_task(data_processing_task(worker.current_task.payload))
        elif worker.current_task.task_type == "notification":
            worker.complete_task(notification_task(worker.current_task.payload))

# æŸ¥çœ‹çŠ¶æ€
print("ä»»åŠ¡çŠ¶æ€:")
for task_id in [task1_id, task2_id, task3_id]:
    status = distributed_scheduler.get_task_status(task_id)
    print(f"ä»»åŠ¡ {task_id}: {status['status']}")

print("å·¥ä½œèŠ‚ç‚¹çŠ¶æ€:")
worker_status = distributed_scheduler.get_worker_status()
for worker_id, status in worker_status.items():
    print(f"å·¥ä½œèŠ‚ç‚¹ {worker_id}: {status}")
```

## 6. æµç¨‹ç®¡ç†

### 6.1. æµç¨‹å®šä¹‰ä¸æ‰§è¡Œ

```python
from typing import Dict, List, Any

class ProcessDefinition:
    def __init__(self, process_id: str, name: str):
        self.process_id = process_id
        self.name = name
        self.steps = []
        self.variables = {}
        self.conditions = {}

    def add_step(self, step_id: str, step_type: str, config: Dict):
        """æ·»åŠ æµç¨‹æ­¥éª¤"""
        step = {
            "step_id": step_id,
            "step_type": step_type,
            "config": config,
            "next_steps": [],
            "conditions": []
        }
        self.steps.append(step)

    def add_connection(self, from_step: str, to_step: str, condition: str = None):
        """æ·»åŠ æ­¥éª¤è¿æ¥"""
        for step in self.steps:
            if step["step_id"] == from_step:
                step["next_steps"].append(to_step)
                if condition:
                    step["conditions"].append({"to_step": to_step, "condition": condition})
                break

    def get_next_steps(self, current_step: str, context: Dict) -> List[str]:
        """è·å–ä¸‹ä¸€æ­¥éª¤"""
        for step in self.steps:
            if step["step_id"] == current_step:
                if not step["conditions"]:
                    return step["next_steps"]

# è¯„ä¼°æ¡ä»¶
                next_steps = []
                for condition_info in step["conditions"]:
                    if self._evaluate_condition(condition_info["condition"], context):
                        next_steps.append(condition_info["to_step"])

                return next_steps
        return []

    def _evaluate_condition(self, condition: str, context: Dict) -> bool:
        """è¯„ä¼°æ¡ä»¶"""
        try:
# ç®€å•çš„æ¡ä»¶è¯„ä¼°ï¼Œå®é™…åº”ç”¨ä¸­å¯èƒ½éœ€è¦æ›´å¤æ‚çš„è¡¨è¾¾å¼è§£æ
            if condition == "approval_required":
                return context.get("approval_required", False)
            elif condition == "amount_exceeds_limit":
                return context.get("amount", 0) > context.get("limit", 1000)
            return True
        except:
            return True

class ProcessInstance:
    def __init__(self, instance_id: str, process_definition: ProcessDefinition):
        self.instance_id = instance_id
        self.process_definition = process_definition
        self.current_step = None
        self.completed_steps = []
        self.context = {}
        self.status = "created"
        self.created_at = datetime.now()
        self.started_at = None
        self.completed_at = None

    def start(self, initial_context: Dict = None):
        """å¯åŠ¨æµç¨‹å®ä¾‹"""
        self.status = "running"
        self.started_at = datetime.now()
        self.context = initial_context or {}

# æ‰¾åˆ°èµ·å§‹æ­¥éª¤
        if self.process_definition.steps:
            self.current_step = self.process_definition.steps[0]["step_id"]

    def execute_current_step(self, step_handler: callable):
        """æ‰§è¡Œå½“å‰æ­¥éª¤"""
        if not self.current_step:
            return False

# æ‰§è¡Œæ­¥éª¤
        step_config = self._get_step_config(self.current_step)
        result = step_handler(step_config, self.context)

# è®°å½•å®Œæˆçš„æ­¥éª¤
        self.completed_steps.append({
            "step_id": self.current_step,
            "result": result,
            "timestamp": datetime.now()
        })

# è·å–ä¸‹ä¸€æ­¥éª¤
        next_steps = self.process_definition.get_next_steps(self.current_step, self.context)

        if next_steps:
            self.current_step = next_steps[0]  # å–ç¬¬ä¸€ä¸ªä¸‹ä¸€æ­¥éª¤
        else:
# æµç¨‹å®Œæˆ
            self.current_step = None
            self.status = "completed"
            self.completed_at = datetime.now()

        return True

    def _get_step_config(self, step_id: str) -> Dict:
        """è·å–æ­¥éª¤é…ç½®"""
        for step in self.process_definition.steps:
            if step["step_id"] == step_id:
                return step["config"]
        return {}

class ProcessEngine:
    def __init__(self):
        self.process_definitions: Dict[str, ProcessDefinition] = {}
        self.process_instances: Dict[str, ProcessInstance] = {}
        self.step_handlers: Dict[str, callable] = {}

    def register_process_definition(self, process_def: ProcessDefinition):
        """æ³¨å†Œæµç¨‹å®šä¹‰"""
        self.process_definitions[process_def.process_id] = process_def

    def register_step_handler(self, step_type: str, handler: callable):
        """æ³¨å†Œæ­¥éª¤å¤„ç†å™¨"""
        self.step_handlers[step_type] = handler

    def start_process(self, process_id: str, initial_context: Dict = None) -> str:
        """å¯åŠ¨æµç¨‹å®ä¾‹"""
        if process_id not in self.process_definitions:
            raise Exception(f"æµç¨‹å®šä¹‰ä¸å­˜åœ¨: {process_id}")

        process_def = self.process_definitions[process_id]
        instance_id = f"{process_id}_{len(self.process_instances) + 1}"

        instance = ProcessInstance(instance_id, process_def)
        instance.start(initial_context)

        self.process_instances[instance_id] = instance
        return instance_id

    def execute_process(self, instance_id: str):
        """æ‰§è¡Œæµç¨‹å®ä¾‹"""
        if instance_id not in self.process_instances:
            raise Exception(f"æµç¨‹å®ä¾‹ä¸å­˜åœ¨: {instance_id}")

        instance = self.process_instances[instance_id]

        while instance.current_step:
            step_config = instance._get_step_config(instance.current_step)
            step_type = step_config.get("type")

            if step_type in self.step_handlers:
                handler = self.step_handlers[step_type]
                instance.execute_current_step(handler)
            else:
                print(f"æœªæ‰¾åˆ°æ­¥éª¤ç±»å‹ {step_type} çš„å¤„ç†å™¨")
                break

# ä½¿ç”¨ç¤ºä¾‹
def approval_step_handler(config: Dict, context: Dict) -> Dict:
    print(f"æ‰§è¡Œå®¡æ‰¹æ­¥éª¤: {config}")
    return {"approved": True, "approver": "manager"}

def notification_step_handler(config: Dict, context: Dict) -> Dict:
    print(f"æ‰§è¡Œé€šçŸ¥æ­¥éª¤: {config}")
    return {"notification_sent": True}

# åˆ›å»ºæµç¨‹å¼•æ“
engine = ProcessEngine()
engine.register_step_handler("approval", approval_step_handler)
engine.register_step_handler("notification", notification_step_handler)

# å®šä¹‰æµç¨‹
process_def = ProcessDefinition("approval_process", "å®¡æ‰¹æµç¨‹")
process_def.add_step("start", "start", {"type": "start"})
process_def.add_step("review", "review", {"type": "approval", "role": "reviewer"})
process_def.add_step("approve", "approve", {"type": "approval", "role": "approver"})
process_def.add_step("notify", "notify", {"type": "notification"})
process_def.add_step("end", "end", {"type": "end"})

process_def.add_connection("start", "review")
process_def.add_connection("review", "approve", "approval_required")
process_def.add_connection("approve", "notify")
process_def.add_connection("notify", "end")

engine.register_process_definition(process_def)

# å¯åŠ¨æµç¨‹å®ä¾‹
context = {"approval_required": True, "amount": 5000}
instance_id = engine.start_process("approval_process", context)

# æ‰§è¡Œæµç¨‹
engine.execute_process(instance_id)

# æŸ¥çœ‹æµç¨‹çŠ¶æ€
instance = engine.process_instances[instance_id]
print(f"æµç¨‹çŠ¶æ€: {instance.status}")
print(f"å®Œæˆæ­¥éª¤: {len(instance.completed_steps)}")
```

## 7. æ€»ç»“

æœ¬æ–‡æ¡£æä¾›äº†å·¥ä½œæµæŠ€æœ¯çš„å®è·µæ¡ˆä¾‹ï¼ŒåŒ…æ‹¬ï¼š

1. **å·¥ä½œæµå¼•æ“**ï¼šåŸºç¡€å·¥ä½œæµå¼•æ“ã€çŠ¶æ€æœºå·¥ä½œæµ
2. **ä»»åŠ¡è°ƒåº¦**ï¼šä»»åŠ¡è°ƒåº¦å™¨ã€åˆ†å¸ƒå¼ä»»åŠ¡è°ƒåº¦
3. **æµç¨‹ç®¡ç†**ï¼šæµç¨‹å®šä¹‰ä¸æ‰§è¡Œ

è¿™äº›å®è·µæ¡ˆä¾‹å±•ç¤ºäº†å¦‚ä½•å°†å·¥ä½œæµç†è®ºåº”ç”¨åˆ°å®é™…çš„ä¸šåŠ¡æµç¨‹ç®¡ç†å’Œä»»åŠ¡è°ƒåº¦åœºæ™¯ä¸­ã€‚
