# 工作流实践案例

## 概述

本文档提供工作流技术的实践案例，包括工作流引擎、任务调度、流程管理、状态机等实际应用场景。

## 1. 工作流引擎

### 1.1 基础工作流引擎

```python
from enum import Enum
from typing import Dict, List, Any
from datetime import datetime

class TaskStatus(Enum):
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"

class WorkflowStatus(Enum):
    CREATED = "created"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    PAUSED = "paused"

class Task:
    def __init__(self, task_id: str, name: str, task_type: str):
        self.task_id = task_id
        self.name = name
        self.task_type = task_type
        self.status = TaskStatus.PENDING
        self.input_data = {}
        self.output_data = {}
        self.dependencies = []
        self.created_at = datetime.now()
        self.started_at = None
        self.completed_at = None
        self.error_message = None
    
    def can_start(self, completed_tasks: List[str]) -> bool:
        """检查任务是否可以开始"""
        return all(dep in completed_tasks for dep in self.dependencies)
    
    def start(self):
        """开始任务"""
        self.status = TaskStatus.RUNNING
        self.started_at = datetime.now()
    
    def complete(self, output_data: Dict = None):
        """完成任务"""
        self.status = TaskStatus.COMPLETED
        self.completed_at = datetime.now()
        if output_data:
            self.output_data = output_data
    
    def fail(self, error_message: str):
        """任务失败"""
        self.status = TaskStatus.FAILED
        self.completed_at = datetime.now()
        self.error_message = error_message

class Workflow:
    def __init__(self, workflow_id: str, name: str):
        self.workflow_id = workflow_id
        self.name = name
        self.status = WorkflowStatus.CREATED
        self.tasks: Dict[str, Task] = {}
        self.task_execution_order = []
        self.created_at = datetime.now()
        self.started_at = None
        self.completed_at = None
    
    def add_task(self, task: Task):
        """添加任务"""
        self.tasks[task.task_id] = task
    
    def add_dependency(self, task_id: str, depends_on: str):
        """添加任务依赖"""
        if task_id in self.tasks and depends_on in self.tasks:
            self.tasks[task_id].dependencies.append(depends_on)
    
    def get_ready_tasks(self, completed_tasks: List[str]) -> List[Task]:
        """获取可以执行的任务"""
        ready_tasks = []
        for task in self.tasks.values():
            if (task.status == TaskStatus.PENDING and 
                task.can_start(completed_tasks)):
                ready_tasks.append(task)
        return ready_tasks
    
    def start(self):
        """开始工作流"""
        self.status = WorkflowStatus.RUNNING
        self.started_at = datetime.now()
    
    def complete(self):
        """完成工作流"""
        self.status = WorkflowStatus.COMPLETED
        self.completed_at = datetime.now()
    
    def fail(self):
        """工作流失败"""
        self.status = WorkflowStatus.FAILED
        self.completed_at = datetime.now()

class WorkflowEngine:
    def __init__(self):
        self.workflows: Dict[str, Workflow] = {}
        self.task_handlers: Dict[str, callable] = {}
        self.execution_history = []
    
    def register_task_handler(self, task_type: str, handler: callable):
        """注册任务处理器"""
        self.task_handlers[task_type] = handler
    
    def create_workflow(self, workflow_id: str, name: str) -> Workflow:
        """创建工作流"""
        workflow = Workflow(workflow_id, name)
        self.workflows[workflow_id] = workflow
        return workflow
    
    def execute_workflow(self, workflow_id: str) -> bool:
        """执行工作流"""
        if workflow_id not in self.workflows:
            return False
        
        workflow = self.workflows[workflow_id]
        workflow.start()
        
        completed_tasks = []
        failed_tasks = []
        
        while True:
            # 获取可以执行的任务
            ready_tasks = workflow.get_ready_tasks(completed_tasks)
            
            if not ready_tasks and len(completed_tasks) == len(workflow.tasks):
                # 所有任务完成
                workflow.complete()
                break
            
            if not ready_tasks and len(failed_tasks) > 0:
                # 有任务失败，工作流失败
                workflow.fail()
                break
            
            # 执行就绪任务
            for task in ready_tasks:
                try:
                    self._execute_task(task)
                    completed_tasks.append(task.task_id)
                except Exception as e:
                    task.fail(str(e))
                    failed_tasks.append(task.task_id)
        
        return workflow.status == WorkflowStatus.COMPLETED
    
    def _execute_task(self, task: Task):
        """执行单个任务"""
        task.start()
        
        if task.task_type in self.task_handlers:
            handler = self.task_handlers[task.task_type]
            output_data = handler(task.input_data)
            task.complete(output_data)
        else:
            raise Exception(f"未找到任务类型 {task.task_type} 的处理器")

# 使用示例
def data_processing_handler(input_data: Dict) -> Dict:
    """数据处理任务处理器"""
    print(f"处理数据: {input_data}")
    return {"processed_data": "result", "status": "success"}

def notification_handler(input_data: Dict) -> Dict:
    """通知任务处理器"""
    print(f"发送通知: {input_data}")
    return {"notification_sent": True}

# 创建工作流引擎
engine = WorkflowEngine()
engine.register_task_handler("data_processing", data_processing_handler)
engine.register_task_handler("notification", notification_handler)

# 创建工作流
workflow = engine.create_workflow("wf_001", "数据处理工作流")

# 添加任务
task1 = Task("task_1", "数据预处理", "data_processing")
task2 = Task("task_2", "数据验证", "data_processing")
task3 = Task("task_3", "发送通知", "notification")

workflow.add_task(task1)
workflow.add_task(task2)
workflow.add_task(task3)

# 设置依赖关系
workflow.add_dependency("task_2", "task_1")
workflow.add_dependency("task_3", "task_2")

# 执行工作流
success = engine.execute_workflow("wf_001")
print(f"工作流执行: {'成功' if success else '失败'}")
```

### 1.2 状态机工作流

```python
from enum import Enum
from typing import Dict, List, Callable

class State(Enum):
    INIT = "init"
    PROCESSING = "processing"
    REVIEW = "review"
    APPROVED = "approved"
    REJECTED = "rejected"
    COMPLETED = "completed"

class StateMachine:
    def __init__(self, name: str):
        self.name = name
        self.current_state = State.INIT
        self.transitions = {}
        self.state_handlers = {}
        self.history = []
    
    def add_transition(self, from_state: State, to_state: State, 
                      condition: Callable = None, action: Callable = None):
        """添加状态转换"""
        if from_state not in self.transitions:
            self.transitions[from_state] = []
        
        self.transitions[from_state].append({
            "to_state": to_state,
            "condition": condition,
            "action": action
        })
    
    def add_state_handler(self, state: State, handler: Callable):
        """添加状态处理器"""
        self.state_handlers[state] = handler
    
    def can_transition_to(self, to_state: State, context: Dict = None) -> bool:
        """检查是否可以转换到指定状态"""
        if self.current_state not in self.transitions:
            return False
        
        for transition in self.transitions[self.current_state]:
            if transition["to_state"] == to_state:
                condition = transition.get("condition")
                if condition is None or condition(context):
                    return True
        
        return False
    
    def transition_to(self, to_state: State, context: Dict = None):
        """转换到指定状态"""
        if not self.can_transition_to(to_state, context):
            raise Exception(f"无法从 {self.current_state} 转换到 {to_state}")
        
        # 执行转换动作
        for transition in self.transitions[self.current_state]:
            if transition["to_state"] == to_state:
                action = transition.get("action")
                if action:
                    action(context)
                break
        
        # 记录历史
        self.history.append({
            "from_state": self.current_state,
            "to_state": to_state,
            "timestamp": datetime.now(),
            "context": context
        })
        
        # 更新状态
        self.current_state = to_state
        
        # 执行状态处理器
        if to_state in self.state_handlers:
            self.state_handlers[to_state](context)
    
    def get_available_transitions(self, context: Dict = None) -> List[State]:
        """获取可用的状态转换"""
        available = []
        if self.current_state in self.transitions:
            for transition in self.transitions[self.current_state]:
                condition = transition.get("condition")
                if condition is None or condition(context):
                    available.append(transition["to_state"])
        return available

# 使用示例：审批工作流
def processing_handler(context: Dict):
    print(f"进入处理状态: {context}")

def review_handler(context: Dict):
    print(f"进入审核状态: {context}")

def approval_handler(context: Dict):
    print(f"进入批准状态: {context}")

# 创建状态机
approval_workflow = StateMachine("审批工作流")

# 添加状态处理器
approval_workflow.add_state_handler(State.PROCESSING, processing_handler)
approval_workflow.add_state_handler(State.REVIEW, review_handler)
approval_workflow.add_state_handler(State.APPROVED, approval_handler)

# 定义转换条件
def can_process(context: Dict) -> bool:
    return context.get("data_ready", False)

def can_review(context: Dict) -> bool:
    return context.get("processing_complete", False)

def can_approve(context: Dict) -> bool:
    return context.get("review_passed", False)

# 添加状态转换
approval_workflow.add_transition(State.INIT, State.PROCESSING, can_process)
approval_workflow.add_transition(State.PROCESSING, State.REVIEW, can_review)
approval_workflow.add_transition(State.REVIEW, State.APPROVED, can_approve)
approval_workflow.add_transition(State.REVIEW, State.REJECTED)
approval_workflow.add_transition(State.APPROVED, State.COMPLETED)
approval_workflow.add_transition(State.REJECTED, State.COMPLETED)

# 执行工作流
context = {"data_ready": True}
print(f"当前状态: {approval_workflow.current_state}")

# 转换到处理状态
approval_workflow.transition_to(State.PROCESSING, context)
print(f"当前状态: {approval_workflow.current_state}")

# 更新上下文并转换到审核状态
context["processing_complete"] = True
approval_workflow.transition_to(State.REVIEW, context)
print(f"当前状态: {approval_workflow.current_state}")

# 获取可用转换
available = approval_workflow.get_available_transitions(context)
print(f"可用转换: {available}")
```

## 2. 任务调度

### 2.1 任务调度器

```python
import time
import threading
from queue import Queue, PriorityQueue
from datetime import datetime, timedelta

class ScheduledTask:
    def __init__(self, task_id: str, task_func: callable, 
                 schedule_time: datetime, priority: int = 0):
        self.task_id = task_id
        self.task_func = task_func
        self.schedule_time = schedule_time
        self.priority = priority
        self.status = "pending"
        self.created_at = datetime.now()
    
    def __lt__(self, other):
        # 优先级队列比较方法
        if self.schedule_time != other.schedule_time:
            return self.schedule_time < other.schedule_time
        return self.priority > other.priority

class TaskScheduler:
    def __init__(self):
        self.task_queue = PriorityQueue()
        self.running = False
        self.worker_thread = None
        self.completed_tasks = []
        self.failed_tasks = []
    
    def schedule_task(self, task_id: str, task_func: callable, 
                     schedule_time: datetime, priority: int = 0):
        """调度任务"""
        task = ScheduledTask(task_id, task_func, schedule_time, priority)
        self.task_queue.put(task)
        print(f"任务 {task_id} 已调度，执行时间: {schedule_time}")
    
    def schedule_recurring_task(self, task_id: str, task_func: callable, 
                              interval_seconds: int, priority: int = 0):
        """调度重复任务"""
        def recurring_wrapper():
            task_func()
            # 重新调度下一次执行
            next_time = datetime.now() + timedelta(seconds=interval_seconds)
            self.schedule_task(f"{task_id}_recurring", task_func, next_time, priority)
        
        self.schedule_task(task_id, recurring_wrapper, datetime.now(), priority)
    
    def start(self):
        """启动调度器"""
        self.running = True
        self.worker_thread = threading.Thread(target=self._worker_loop)
        self.worker_thread.start()
        print("任务调度器已启动")
    
    def stop(self):
        """停止调度器"""
        self.running = False
        if self.worker_thread:
            self.worker_thread.join()
        print("任务调度器已停止")
    
    def _worker_loop(self):
        """工作循环"""
        while self.running:
            try:
                if not self.task_queue.empty():
                    task = self.task_queue.get_nowait()
                    
                    if datetime.now() >= task.schedule_time:
                        # 执行任务
                        self._execute_task(task)
                    else:
                        # 重新放回队列
                        self.task_queue.put(task)
                        time.sleep(1)
                else:
                    time.sleep(1)
            except Exception as e:
                print(f"调度器错误: {e}")
                time.sleep(1)
    
    def _execute_task(self, task: ScheduledTask):
        """执行任务"""
        try:
            task.status = "running"
            print(f"执行任务: {task.task_id}")
            
            task.task_func()
            
            task.status = "completed"
            self.completed_tasks.append(task)
            print(f"任务完成: {task.task_id}")
        
        except Exception as e:
            task.status = "failed"
            self.failed_tasks.append(task)
            print(f"任务失败: {task.task_id}, 错误: {e}")
    
    def get_statistics(self) -> Dict:
        """获取统计信息"""
        return {
            "pending_tasks": self.task_queue.qsize(),
            "completed_tasks": len(self.completed_tasks),
            "failed_tasks": len(self.failed_tasks),
            "total_tasks": self.task_queue.qsize() + len(self.completed_tasks) + len(self.failed_tasks)
        }

# 使用示例
def sample_task():
    print(f"执行示例任务，时间: {datetime.now()}")

def data_backup_task():
    print(f"执行数据备份，时间: {datetime.now()}")

# 创建调度器
scheduler = TaskScheduler()

# 调度一次性任务
future_time = datetime.now() + timedelta(seconds=5)
scheduler.schedule_task("sample_task", sample_task, future_time)

# 调度重复任务
scheduler.schedule_recurring_task("backup_task", data_backup_task, 10)

# 启动调度器
scheduler.start()

# 运行一段时间
time.sleep(15)

# 停止调度器
scheduler.stop()

# 查看统计信息
stats = scheduler.get_statistics()
print(f"调度器统计: {stats}")
```

### 2.2 分布式任务调度

```python
import json
import uuid
from typing import Dict, List

class DistributedTask:
    def __init__(self, task_id: str, task_type: str, payload: Dict):
        self.task_id = task_id
        self.task_type = task_type
        self.payload = payload
        self.status = "pending"
        self.assigned_worker = None
        self.created_at = datetime.now()
        self.started_at = None
        self.completed_at = None
        self.result = None
        self.error = None
    
    def to_dict(self) -> Dict:
        return {
            "task_id": self.task_id,
            "task_type": self.task_type,
            "payload": self.payload,
            "status": self.status,
            "assigned_worker": self.assigned_worker,
            "created_at": self.created_at.isoformat(),
            "started_at": self.started_at.isoformat() if self.started_at else None,
            "completed_at": self.completed_at.isoformat() if self.completed_at else None,
            "result": self.result,
            "error": self.error
        }

class Worker:
    def __init__(self, worker_id: str, capabilities: List[str]):
        self.worker_id = worker_id
        self.capabilities = capabilities
        self.status = "idle"
        self.current_task = None
        self.completed_tasks = 0
        self.failed_tasks = 0
        self.last_heartbeat = datetime.now()
    
    def can_handle_task(self, task_type: str) -> bool:
        """检查是否可以处理指定类型的任务"""
        return task_type in self.capabilities
    
    def assign_task(self, task: DistributedTask):
        """分配任务"""
        self.current_task = task
        self.status = "busy"
        task.assigned_worker = self.worker_id
        task.status = "running"
        task.started_at = datetime.now()
    
    def complete_task(self, result: Any = None):
        """完成任务"""
        if self.current_task:
            self.current_task.status = "completed"
            self.current_task.completed_at = datetime.now()
            self.current_task.result = result
            self.completed_tasks += 1
            self.current_task = None
            self.status = "idle"
    
    def fail_task(self, error: str):
        """任务失败"""
        if self.current_task:
            self.current_task.status = "failed"
            self.current_task.completed_at = datetime.now()
            self.current_task.error = error
            self.failed_tasks += 1
            self.current_task = None
            self.status = "idle"

class DistributedTaskScheduler:
    def __init__(self):
        self.tasks: Dict[str, DistributedTask] = {}
        self.workers: Dict[str, Worker] = {}
        self.task_queue = []
        self.completed_tasks = []
        self.failed_tasks = []
    
    def register_worker(self, worker: Worker):
        """注册工作节点"""
        self.workers[worker.worker_id] = worker
        print(f"工作节点注册: {worker.worker_id}")
    
    def submit_task(self, task_type: str, payload: Dict) -> str:
        """提交任务"""
        task_id = str(uuid.uuid4())
        task = DistributedTask(task_id, task_type, payload)
        self.tasks[task_id] = task
        self.task_queue.append(task_id)
        print(f"任务提交: {task_id}, 类型: {task_type}")
        return task_id
    
    def assign_tasks(self):
        """分配任务"""
        idle_workers = [w for w in self.workers.values() if w.status == "idle"]
        
        for task_id in self.task_queue[:]:
            task = self.tasks[task_id]
            
            if task.status != "pending":
                continue
            
            # 找到可以处理该任务的工作节点
            suitable_worker = None
            for worker in idle_workers:
                if worker.can_handle_task(task.task_type):
                    suitable_worker = worker
                    break
            
            if suitable_worker:
                suitable_worker.assign_task(task)
                self.task_queue.remove(task_id)
                idle_workers.remove(suitable_worker)
                print(f"任务 {task_id} 分配给工作节点 {suitable_worker.worker_id}")
    
    def get_task_status(self, task_id: str) -> Dict:
        """获取任务状态"""
        if task_id in self.tasks:
            return self.tasks[task_id].to_dict()
        return None
    
    def get_worker_status(self) -> Dict:
        """获取工作节点状态"""
        return {
            worker_id: {
                "status": worker.status,
                "capabilities": worker.capabilities,
                "completed_tasks": worker.completed_tasks,
                "failed_tasks": worker.failed_tasks,
                "current_task": worker.current_task.task_id if worker.current_task else None
            }
            for worker_id, worker in self.workers.items()
        }

# 使用示例
def data_processing_task(payload: Dict):
    print(f"处理数据: {payload}")
    return {"processed": True, "result": "success"}

def notification_task(payload: Dict):
    print(f"发送通知: {payload}")
    return {"notification_sent": True}

# 创建分布式调度器
distributed_scheduler = DistributedTaskScheduler()

# 注册工作节点
worker1 = Worker("worker_001", ["data_processing", "notification"])
worker2 = Worker("worker_002", ["data_processing"])
worker3 = Worker("worker_003", ["notification"])

distributed_scheduler.register_worker(worker1)
distributed_scheduler.register_worker(worker2)
distributed_scheduler.register_worker(worker3)

# 提交任务
task1_id = distributed_scheduler.submit_task("data_processing", {"data": "sample_data"})
task2_id = distributed_scheduler.submit_task("notification", {"message": "Hello"})
task3_id = distributed_scheduler.submit_task("data_processing", {"data": "another_data"})

# 分配任务
distributed_scheduler.assign_tasks()

# 模拟任务执行
for worker in distributed_scheduler.workers.values():
    if worker.current_task:
        if worker.current_task.task_type == "data_processing":
            worker.complete_task(data_processing_task(worker.current_task.payload))
        elif worker.current_task.task_type == "notification":
            worker.complete_task(notification_task(worker.current_task.payload))

# 查看状态
print("任务状态:")
for task_id in [task1_id, task2_id, task3_id]:
    status = distributed_scheduler.get_task_status(task_id)
    print(f"任务 {task_id}: {status['status']}")

print("工作节点状态:")
worker_status = distributed_scheduler.get_worker_status()
for worker_id, status in worker_status.items():
    print(f"工作节点 {worker_id}: {status}")
```

## 3. 流程管理

### 3.1 流程定义与执行

```python
from typing import Dict, List, Any

class ProcessDefinition:
    def __init__(self, process_id: str, name: str):
        self.process_id = process_id
        self.name = name
        self.steps = []
        self.variables = {}
        self.conditions = {}
    
    def add_step(self, step_id: str, step_type: str, config: Dict):
        """添加流程步骤"""
        step = {
            "step_id": step_id,
            "step_type": step_type,
            "config": config,
            "next_steps": [],
            "conditions": []
        }
        self.steps.append(step)
    
    def add_connection(self, from_step: str, to_step: str, condition: str = None):
        """添加步骤连接"""
        for step in self.steps:
            if step["step_id"] == from_step:
                step["next_steps"].append(to_step)
                if condition:
                    step["conditions"].append({"to_step": to_step, "condition": condition})
                break
    
    def get_next_steps(self, current_step: str, context: Dict) -> List[str]:
        """获取下一步骤"""
        for step in self.steps:
            if step["step_id"] == current_step:
                if not step["conditions"]:
                    return step["next_steps"]
                
                # 评估条件
                next_steps = []
                for condition_info in step["conditions"]:
                    if self._evaluate_condition(condition_info["condition"], context):
                        next_steps.append(condition_info["to_step"])
                
                return next_steps
        return []
    
    def _evaluate_condition(self, condition: str, context: Dict) -> bool:
        """评估条件"""
        try:
            # 简单的条件评估，实际应用中可能需要更复杂的表达式解析
            if condition == "approval_required":
                return context.get("approval_required", False)
            elif condition == "amount_exceeds_limit":
                return context.get("amount", 0) > context.get("limit", 1000)
            return True
        except:
            return True

class ProcessInstance:
    def __init__(self, instance_id: str, process_definition: ProcessDefinition):
        self.instance_id = instance_id
        self.process_definition = process_definition
        self.current_step = None
        self.completed_steps = []
        self.context = {}
        self.status = "created"
        self.created_at = datetime.now()
        self.started_at = None
        self.completed_at = None
    
    def start(self, initial_context: Dict = None):
        """启动流程实例"""
        self.status = "running"
        self.started_at = datetime.now()
        self.context = initial_context or {}
        
        # 找到起始步骤
        if self.process_definition.steps:
            self.current_step = self.process_definition.steps[0]["step_id"]
    
    def execute_current_step(self, step_handler: callable):
        """执行当前步骤"""
        if not self.current_step:
            return False
        
        # 执行步骤
        step_config = self._get_step_config(self.current_step)
        result = step_handler(step_config, self.context)
        
        # 记录完成的步骤
        self.completed_steps.append({
            "step_id": self.current_step,
            "result": result,
            "timestamp": datetime.now()
        })
        
        # 获取下一步骤
        next_steps = self.process_definition.get_next_steps(self.current_step, self.context)
        
        if next_steps:
            self.current_step = next_steps[0]  # 取第一个下一步骤
        else:
            # 流程完成
            self.current_step = None
            self.status = "completed"
            self.completed_at = datetime.now()
        
        return True
    
    def _get_step_config(self, step_id: str) -> Dict:
        """获取步骤配置"""
        for step in self.process_definition.steps:
            if step["step_id"] == step_id:
                return step["config"]
        return {}

class ProcessEngine:
    def __init__(self):
        self.process_definitions: Dict[str, ProcessDefinition] = {}
        self.process_instances: Dict[str, ProcessInstance] = {}
        self.step_handlers: Dict[str, callable] = {}
    
    def register_process_definition(self, process_def: ProcessDefinition):
        """注册流程定义"""
        self.process_definitions[process_def.process_id] = process_def
    
    def register_step_handler(self, step_type: str, handler: callable):
        """注册步骤处理器"""
        self.step_handlers[step_type] = handler
    
    def start_process(self, process_id: str, initial_context: Dict = None) -> str:
        """启动流程实例"""
        if process_id not in self.process_definitions:
            raise Exception(f"流程定义不存在: {process_id}")
        
        process_def = self.process_definitions[process_id]
        instance_id = f"{process_id}_{len(self.process_instances) + 1}"
        
        instance = ProcessInstance(instance_id, process_def)
        instance.start(initial_context)
        
        self.process_instances[instance_id] = instance
        return instance_id
    
    def execute_process(self, instance_id: str):
        """执行流程实例"""
        if instance_id not in self.process_instances:
            raise Exception(f"流程实例不存在: {instance_id}")
        
        instance = self.process_instances[instance_id]
        
        while instance.current_step:
            step_config = instance._get_step_config(instance.current_step)
            step_type = step_config.get("type")
            
            if step_type in self.step_handlers:
                handler = self.step_handlers[step_type]
                instance.execute_current_step(handler)
            else:
                print(f"未找到步骤类型 {step_type} 的处理器")
                break

# 使用示例
def approval_step_handler(config: Dict, context: Dict) -> Dict:
    print(f"执行审批步骤: {config}")
    return {"approved": True, "approver": "manager"}

def notification_step_handler(config: Dict, context: Dict) -> Dict:
    print(f"执行通知步骤: {config}")
    return {"notification_sent": True}

# 创建流程引擎
engine = ProcessEngine()
engine.register_step_handler("approval", approval_step_handler)
engine.register_step_handler("notification", notification_step_handler)

# 定义流程
process_def = ProcessDefinition("approval_process", "审批流程")
process_def.add_step("start", "start", {"type": "start"})
process_def.add_step("review", "review", {"type": "approval", "role": "reviewer"})
process_def.add_step("approve", "approve", {"type": "approval", "role": "approver"})
process_def.add_step("notify", "notify", {"type": "notification"})
process_def.add_step("end", "end", {"type": "end"})

process_def.add_connection("start", "review")
process_def.add_connection("review", "approve", "approval_required")
process_def.add_connection("approve", "notify")
process_def.add_connection("notify", "end")

engine.register_process_definition(process_def)

# 启动流程实例
context = {"approval_required": True, "amount": 5000}
instance_id = engine.start_process("approval_process", context)

# 执行流程
engine.execute_process(instance_id)

# 查看流程状态
instance = engine.process_instances[instance_id]
print(f"流程状态: {instance.status}")
print(f"完成步骤: {len(instance.completed_steps)}")
```

## 总结

本文档提供了工作流技术的实践案例，包括：

1. **工作流引擎**：基础工作流引擎、状态机工作流
2. **任务调度**：任务调度器、分布式任务调度
3. **流程管理**：流程定义与执行

这些实践案例展示了如何将工作流理论应用到实际的业务流程管理和任务调度场景中。
