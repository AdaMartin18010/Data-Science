# 2.10 å½¢å¼ç§‘å­¦ç†è®ºå®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [2.10 å½¢å¼ç§‘å­¦ç†è®ºå®è·µæ¡ˆä¾‹](#210-å½¢å¼ç§‘å­¦ç†è®ºå®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2. ç±»å‹ç†è®ºå®è·µæ¡ˆä¾‹](#2-ç±»å‹ç†è®ºå®è·µæ¡ˆä¾‹)
    - [2.1. å‡½æ•°å¼ç¼–ç¨‹ä¸­çš„ç±»å‹ç³»ç»Ÿ](#21-å‡½æ•°å¼ç¼–ç¨‹ä¸­çš„ç±»å‹ç³»ç»Ÿ)
    - [2.2. Rustè¯­è¨€ä¸­çš„ç±»å‹ç³»ç»Ÿ](#22-rustè¯­è¨€ä¸­çš„ç±»å‹ç³»ç»Ÿ)
  - [3. è‡ªåŠ¨æœºç†è®ºå®è·µæ¡ˆä¾‹](#3-è‡ªåŠ¨æœºç†è®ºå®è·µæ¡ˆä¾‹)
    - [3.1. æœ‰é™çŠ¶æ€æœºå®ç°](#31-æœ‰é™çŠ¶æ€æœºå®ç°)
  - [4. æ­£åˆ™è¡¨è¾¾å¼å¼•æ“](#4-æ­£åˆ™è¡¨è¾¾å¼å¼•æ“)
  - [5. Petriç½‘ç†è®ºå®è·µæ¡ˆä¾‹](#5-petriç½‘ç†è®ºå®è·µæ¡ˆä¾‹)
    - [5.1. å·¥ä½œæµPetriç½‘](#51-å·¥ä½œæµpetriç½‘)
  - [6. æ—¶æ€é€»è¾‘å®è·µæ¡ˆä¾‹](#6-æ—¶æ€é€»è¾‘å®è·µæ¡ˆä¾‹)
    - [6.1. çº¿æ€§æ—¶æ€é€»è¾‘(LTL)å®ç°](#61-çº¿æ€§æ—¶æ€é€»è¾‘ltlå®ç°)
  - [7. æ€»ç»“](#7-æ€»ç»“)

---


## 1. æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›å½¢å¼ç§‘å­¦ç†è®ºåœ¨å®é™…é¡¹ç›®ä¸­çš„å…·ä½“åº”ç”¨æ¡ˆä¾‹ï¼Œæ¶µç›–ç±»å‹ç†è®ºã€è‡ªåŠ¨æœºç†è®ºã€Petriç½‘ç†è®ºç­‰å„ä¸ªæ–¹é¢çš„å®é™…åº”ç”¨ã€‚

## 2. ç±»å‹ç†è®ºå®è·µæ¡ˆä¾‹

### 2.1. å‡½æ•°å¼ç¼–ç¨‹ä¸­çš„ç±»å‹ç³»ç»Ÿ

```haskell
-- Haskellç±»å‹ç³»ç»Ÿå®è·µ
data Shape = Circle Double | Rectangle Double Double
data Color = Red | Green | Blue

class Area a where
    area :: a -> Double

instance Area Shape where
    area (Circle r) = pi * r * r
    area (Rectangle w h) = w * h

-- æ³›å‹å‡½æ•°
processShapes :: (Area a) => [a] -> Double
processShapes shapes = sum $ map area shapes
```

### 2.2. Rustè¯­è¨€ä¸­çš„ç±»å‹ç³»ç»Ÿ

```rust
// Rustç±»å‹ç³»ç»Ÿå®è·µ
trait Area {
    fn area(&self) -> f64;
}

struct Circle { radius: f64 }
struct Rectangle { width: f64, height: f64 }

impl Area for Circle {
    fn area(&self) -> f64 {
        std::f64::consts::PI * self.radius * self.radius
    }
}

impl Area for Rectangle {
    fn area(&self) -> f64 {
        self.width * self.height
    }
}

fn process_shapes<T: Area>(shapes: &[T]) -> f64 {
    shapes.iter().map(|s| s.area()).sum()
}
```

## 3. è‡ªåŠ¨æœºç†è®ºå®è·µæ¡ˆä¾‹

### 3.1. æœ‰é™çŠ¶æ€æœºå®ç°

```python
# æœ‰é™çŠ¶æ€æœºå®ç°
from enum import Enum
from typing import Dict, List

class State(Enum):
    IDLE = "idle"
    PROCESSING = "processing"
    SUCCESS = "success"
    ERROR = "error"

class Event(Enum):
    START = "start"
    COMPLETE = "complete"
    FAIL = "fail"

class FiniteStateMachine:
    def __init__(self, initial_state: State):
        self.current_state = initial_state
        self.transitions = {}

    def add_transition(self, from_state: State, event: Event, to_state: State):
        self.transitions[(from_state, event)] = to_state

    def transition(self, event: Event) -> bool:
        key = (self.current_state, event)
        if key in self.transitions:
            self.current_state = self.transitions[key]
            return True
        return False

# ä½¿ç”¨ç¤ºä¾‹
fsm = FiniteStateMachine(State.IDLE)
fsm.add_transition(State.IDLE, Event.START, State.PROCESSING)
fsm.add_transition(State.PROCESSING, Event.COMPLETE, State.SUCCESS)
fsm.add_transition(State.PROCESSING, Event.FAIL, State.ERROR)
```

## 4. æ­£åˆ™è¡¨è¾¾å¼å¼•æ“

```python
# ç®€åŒ–ç‰ˆæ­£åˆ™è¡¨è¾¾å¼å¼•æ“
class RegexEngine:
    def __init__(self, pattern: str):
        self.pattern = pattern

    def match(self, text: str) -> bool:
# ç®€åŒ–å®ç°ï¼šåªæ”¯æŒåŸºæœ¬æ¨¡å¼
        if self.pattern == ".*":
            return True
        elif self.pattern.endswith("*"):
            char = self.pattern[0]
            return all(c == char for c in text)
        else:
            return text == self.pattern

# ä½¿ç”¨ç¤ºä¾‹
engine = RegexEngine("a*")
print(engine.match("aaa"))  # True
print(engine.match(""))     # True
```

## 5. Petriç½‘ç†è®ºå®è·µæ¡ˆä¾‹

### 5.1. å·¥ä½œæµPetriç½‘

```python
# Petriç½‘å·¥ä½œæµå®ç°
class Place:
    def __init__(self, name: str, tokens: int = 0):
        self.name = name
        self.tokens = tokens

class Transition:
    def __init__(self, name: str):
        self.name = name
        self.input_places = []
        self.output_places = []

class PetriNet:
    def __init__(self):
        self.places = {}
        self.transitions = {}

    def add_place(self, name: str, tokens: int = 0):
        self.places[name] = Place(name, tokens)

    def add_transition(self, name: str):
        self.transitions[name] = Transition(name)

    def add_arc(self, from_name: str, to_name: str):
        if from_name in self.places and to_name in self.transitions:
# Place to Transition
            self.transitions[to_name].input_places.append(self.places[from_name])
        elif from_name in self.transitions and to_name in self.places:
# Transition to Place
            self.transitions[from_name].output_places.append(self.places[to_name])

    def can_fire(self, transition_name: str) -> bool:
        if transition_name not in self.transitions:
            return False

        transition = self.transitions[transition_name]
        return all(place.tokens > 0 for place in transition.input_places)

    def fire(self, transition_name: str) -> bool:
        if not self.can_fire(transition_name):
            return False

        transition = self.transitions[transition_name]

# æ¶ˆè€—è¾“å…¥token
        for place in transition.input_places:
            place.tokens -= 1

# äº§ç”Ÿè¾“å‡ºtoken
        for place in transition.output_places:
            place.tokens += 1

        return True

# ä½¿ç”¨ç¤ºä¾‹
def workflow_example():
    net = PetriNet()

# æ·»åŠ åº“æ‰€
    net.add_place("start", 1)
    net.add_place("processing")
    net.add_place("review")
    net.add_place("approved")
    net.add_place("rejected")

# æ·»åŠ å˜è¿
    net.add_transition("start_processing")
    net.add_transition("submit_for_review")
    net.add_transition("approve")
    net.add_transition("reject")

# æ·»åŠ å¼§
    net.add_arc("start", "start_processing")
    net.add_arc("start_processing", "processing")
    net.add_arc("processing", "submit_for_review")
    net.add_arc("submit_for_review", "review")
    net.add_arc("review", "approve")
    net.add_arc("approve", "approved")
    net.add_arc("review", "reject")
    net.add_arc("reject", "rejected")

# æ‰§è¡Œå·¥ä½œæµ
    print("åˆå§‹çŠ¶æ€:", {name: place.tokens for name, place in net.places.items()})

    if net.can_fire("start_processing"):
        net.fire("start_processing")
        print("å¼€å§‹å¤„ç†")

    if net.can_fire("submit_for_review"):
        net.fire("submit_for_review")
        print("æäº¤å®¡æ ¸")

    if net.can_fire("approve"):
        net.fire("approve")
        print("å®¡æ ¸é€šè¿‡")

    print("æœ€ç»ˆçŠ¶æ€:", {name: place.tokens for name, place in net.places.items()})

workflow_example()
```

## 6. æ—¶æ€é€»è¾‘å®è·µæ¡ˆä¾‹

### 6.1. çº¿æ€§æ—¶æ€é€»è¾‘(LTL)å®ç°

```python
# çº¿æ€§æ—¶æ€é€»è¾‘å®ç°
from enum import Enum
from typing import List, Callable

class LTLOperator(Enum):
    NOT = "not"
    AND = "and"
    OR = "or"
    NEXT = "X"
    GLOBALLY = "G"
    FINALLY = "F"
    UNTIL = "U"

class LTLFormula:
    def __init__(self, operator: LTLOperator, *args):
        self.operator = operator
        self.args = args

    def evaluate(self, trace: List[dict], position: int = 0) -> bool:
        if self.operator == LTLOperator.NOT:
            return not self.args[0].evaluate(trace, position)
        elif self.operator == LTLOperator.AND:
            return all(arg.evaluate(trace, position) for arg in self.args)
        elif self.operator == LTLOperator.OR:
            return any(arg.evaluate(trace, position) for arg in self.args)
        elif self.operator == LTLOperator.NEXT:
            if position + 1 < len(trace):
                return self.args[0].evaluate(trace, position + 1)
            return False
        elif self.operator == LTLOperator.GLOBALLY:
            return all(self.args[0].evaluate(trace, i)
                      for i in range(position, len(trace)))
        elif self.operator == LTLOperator.FINALLY:
            return any(self.args[0].evaluate(trace, i)
                      for i in range(position, len(trace)))
        elif self.operator == LTLOperator.UNTIL:
            phi, psi = self.args
            for i in range(position, len(trace)):
                if psi.evaluate(trace, i):
                    return True
                if not phi.evaluate(trace, i):
                    return False
            return False

class AtomicProposition:
    def __init__(self, name: str, predicate: Callable[[dict], bool]):
        self.name = name
        self.predicate = predicate

    def evaluate(self, trace: List[dict], position: int = 0) -> bool:
        if position < len(trace):
            return self.predicate(trace[position])
        return False

# ä½¿ç”¨ç¤ºä¾‹
def ltl_example():
# å®šä¹‰åŸå­å‘½é¢˜
    is_processing = AtomicProposition("processing",
                                     lambda state: state.get("status") == "processing")
    is_completed = AtomicProposition("completed",
                                    lambda state: state.get("status") == "completed")
    is_error = AtomicProposition("error",
                                lambda state: state.get("status") == "error")

# å®šä¹‰LTLå…¬å¼
# G(processing -> F completed) - æ€»æ˜¯å¤„ç†æœ€ç»ˆä¼šå®Œæˆ
    always_completes = LTLFormula(LTLOperator.GLOBALLY,
        LTLFormula(LTLOperator.OR,
                   LTLFormula(LTLOperator.NOT, is_processing),
                   LTLFormula(LTLOperator.FINALLY, is_completed)))

# G(processing -> X !error) - å¤„ç†æ—¶ä¸‹ä¸€ä¸ªçŠ¶æ€ä¸æ˜¯é”™è¯¯
    no_error_after_processing = LTLFormula(LTLOperator.GLOBALLY,
        LTLFormula(LTLOperator.OR,
                   LTLFormula(LTLOperator.NOT, is_processing),
                   LTLFormula(LTLOperator.NEXT,
                              LTLFormula(LTLOperator.NOT, is_error))))

# æµ‹è¯•è½¨è¿¹
    trace1 = [
        {"status": "idle"},
        {"status": "processing"},
        {"status": "completed"}
    ]

    trace2 = [
        {"status": "idle"},
        {"status": "processing"},
        {"status": "error"}
    ]

    print("è½¨è¿¹1 - æ€»æ˜¯å®Œæˆ:", always_completes.evaluate(trace1))
    print("è½¨è¿¹1 - æ— é”™è¯¯:", no_error_after_processing.evaluate(trace1))
    print("è½¨è¿¹2 - æ€»æ˜¯å®Œæˆ:", always_completes.evaluate(trace2))
    print("è½¨è¿¹2 - æ— é”™è¯¯:", no_error_after_processing.evaluate(trace2))

ltl_example()
```

## 7. æ€»ç»“

æœ¬æ–‡æ¡£æä¾›äº†å½¢å¼ç§‘å­¦ç†è®ºåœ¨å®é™…é¡¹ç›®ä¸­çš„å…·ä½“åº”ç”¨æ¡ˆä¾‹ï¼ŒåŒ…æ‹¬ï¼š

1. **ç±»å‹ç†è®ºå®è·µ**ï¼šå‡½æ•°å¼ç¼–ç¨‹å’ŒRustè¯­è¨€ä¸­çš„ç±»å‹ç³»ç»Ÿåº”ç”¨
2. **è‡ªåŠ¨æœºç†è®ºå®è·µ**ï¼šæœ‰é™çŠ¶æ€æœºå’Œæ­£åˆ™è¡¨è¾¾å¼å¼•æ“å®ç°
3. **Petriç½‘ç†è®ºå®è·µ**ï¼šå·¥ä½œæµPetriç½‘å»ºæ¨¡
4. **æ—¶æ€é€»è¾‘å®è·µ**ï¼šçº¿æ€§æ—¶æ€é€»è¾‘(LTL)å®ç°

è¿™äº›æ¡ˆä¾‹å±•ç¤ºäº†å½¢å¼ç§‘å­¦ç†è®ºåœ¨è½¯ä»¶å¼€å‘ä¸­çš„å®é™…åº”ç”¨ï¼Œä¸ºç†è®ºå­¦ä¹ å’Œå®è·µæä¾›äº†å…·ä½“çš„å‚è€ƒå’ŒæŒ‡å¯¼ã€‚
