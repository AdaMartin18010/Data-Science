# 2.1.2 çº¿æ€§ç±»å‹ç†è®º

## ğŸ“‹ æ¦‚è¿°

çº¿æ€§ç±»å‹ç†è®ºæ˜¯ç°ä»£ç¼–ç¨‹è¯­è¨€ç†è®ºçš„æ ¸å¿ƒåˆ†æ”¯ï¼ŒåŸºäºçº¿æ€§é€»è¾‘ä¸ºèµ„æºç®¡ç†ã€å†…å­˜å®‰å…¨å’Œå¹¶å‘ç¼–ç¨‹æä¾›äº†ä¸¥æ ¼çš„å½¢å¼åŒ–åŸºç¡€ã€‚æœ¬æ–‡æ¡£ç³»ç»Ÿæ€§åœ°é˜è¿°çº¿æ€§ç±»å‹ç†è®ºçš„åŸºæœ¬æ¦‚å¿µã€å½¢å¼åŒ–å®šä¹‰ã€å®ç°æ–¹æ³•å’Œå·¥ç¨‹åº”ç”¨ï¼Œä¸ºç³»ç»Ÿç¼–ç¨‹å’Œèµ„æºç®¡ç†æä¾›ç†è®ºæŒ‡å¯¼ã€‚

## ğŸ—ï¸ ç†è®ºåŸºç¡€

### 1. çº¿æ€§é€»è¾‘åŸºç¡€

#### 1.1 çº¿æ€§é€»è¾‘æ¦‚è¿°

**å®šä¹‰ 1.1 (çº¿æ€§é€»è¾‘)**
çº¿æ€§é€»è¾‘æ˜¯ç”±Jean-Yves Girardåœ¨1987å¹´æå‡ºçš„é€»è¾‘ç³»ç»Ÿï¼Œå…¶æ ¸å¿ƒæ€æƒ³æ˜¯èµ„æºçš„ä¸€æ¬¡æ€§ä½¿ç”¨ï¼Œå³æ¯ä¸ªèµ„æºåªèƒ½è¢«ä½¿ç”¨ä¸€æ¬¡ã€‚

**çº¿æ€§é€»è¾‘è¿æ¥è¯**ï¼š

1. **ä¹˜æ³•è¿æ¥è¯**ï¼š
   - $\otimes$ (å¼ é‡ç§¯)ï¼š$A \otimes B$ è¡¨ç¤ºåŒæ—¶æ‹¥æœ‰ $A$ å’Œ $B$
   - $\multimap$ (çº¿æ€§è•´å«)ï¼š$A \multimap B$ è¡¨ç¤ºæ¶ˆè€— $A$ äº§ç”Ÿ $B$

2. **åŠ æ³•è¿æ¥è¯**ï¼š
   - $\oplus$ (é€‰æ‹©)ï¼š$A \oplus B$ è¡¨ç¤º $A$ æˆ– $B$ ä¸­çš„ä¸€ä¸ª
   - $\&$ (åˆå–)ï¼š$A \& B$ è¡¨ç¤ºå¯ä»¥é€‰æ‹© $A$ æˆ– $B$

3. **æŒ‡æ•°è¿æ¥è¯**ï¼š
   - $!$ (bang)ï¼š$!A$ è¡¨ç¤ºå¯ä»¥é‡å¤ä½¿ç”¨çš„ $A$
   - $?$ (why not)ï¼š$?A$ è¡¨ç¤ºå¯ä»¥é‡å¤æä¾›çš„ $A$

#### 1.2 çº¿æ€§ç±»å‹è¯­æ³•

**å®šä¹‰ 1.2 (çº¿æ€§ç±»å‹è¯­æ³•)**
çº¿æ€§ç±»å‹çš„è¯­æ³•å®šä¹‰å¦‚ä¸‹ï¼š

$$\tau ::= \text{Base} \mid \tau_1 \multimap \tau_2 \mid \tau_1 \otimes \tau_2 \mid \tau_1 \oplus \tau_2 \mid \tau_1 \& \tau_2 \mid !\tau \mid ?\tau$$

å…¶ä¸­ï¼š

- $\text{Base}$ æ˜¯åŸºæœ¬ç±»å‹ï¼ˆå¦‚ $\text{Int}$, $\text{Bool}$, $\text{Unit}$ï¼‰
- $\tau_1 \multimap \tau_2$ æ˜¯çº¿æ€§å‡½æ•°ç±»å‹
- $\tau_1 \otimes \tau_2$ æ˜¯ä¹˜ç§¯ç±»å‹
- $\tau_1 \oplus \tau_2$ æ˜¯æ±‚å’Œç±»å‹
- $\tau_1 \& \tau_2$ æ˜¯äº¤é›†ç±»å‹
- $!\tau$ æ˜¯é‡å¤ä½¿ç”¨ç±»å‹
- $?\tau$ æ˜¯é‡å¤æä¾›ç±»å‹

#### 1.3 çº¿æ€§ç±»å‹è§„åˆ™

**çº¿æ€§ç±»å‹æ¨ç†è§„åˆ™**ï¼š

```mermaid
graph TD
    A[çº¿æ€§ç±»å‹è§„åˆ™] --> B[å˜é‡è§„åˆ™]
    A --> C[åº”ç”¨è§„åˆ™]
    A --> D[æŠ½è±¡è§„åˆ™]
    A --> E[ä¹˜ç§¯è§„åˆ™]
    A --> F[æ±‚å’Œè§„åˆ™]
    
    B --> G[Î“, x:Ï„ âŠ¢ x:Ï„]
    C --> H[Î“ âŠ¢ f:Ï„â‚âŠ¸Ï„â‚‚ Î” âŠ¢ e:Ï„â‚ / Î“,Î” âŠ¢ f e:Ï„â‚‚]
    D --> I[Î“,x:Ï„â‚ âŠ¢ e:Ï„â‚‚ / Î“ âŠ¢ Î»x.e:Ï„â‚âŠ¸Ï„â‚‚]
    E --> J[Î“ âŠ¢ eâ‚:Ï„â‚ Î” âŠ¢ eâ‚‚:Ï„â‚‚ / Î“,Î” âŠ¢ eâ‚âŠ—eâ‚‚:Ï„â‚âŠ—Ï„â‚‚]
    F --> K[Î“ âŠ¢ e:Ï„â‚ / Î“ âŠ¢ inl e:Ï„â‚âŠ•Ï„â‚‚]
```

**æ ¸å¿ƒæ¨ç†è§„åˆ™**ï¼š

1. **å˜é‡è§„åˆ™**ï¼š
   $$\frac{}{\Gamma, x : \tau \vdash x : \tau}$$

2. **åº”ç”¨è§„åˆ™**ï¼š
   $$\frac{\Gamma \vdash f : \tau_1 \multimap \tau_2 \quad \Delta \vdash e : \tau_1}{\Gamma, \Delta \vdash f \, e : \tau_2}$$

3. **æŠ½è±¡è§„åˆ™**ï¼š
   $$\frac{\Gamma, x : \tau_1 \vdash e : \tau_2}{\Gamma \vdash \lambda x. e : \tau_1 \multimap \tau_2}$$

4. **ä¹˜ç§¯å¼•å…¥**ï¼š
   $$\frac{\Gamma \vdash e_1 : \tau_1 \quad \Delta \vdash e_2 : \tau_2}{\Gamma, \Delta \vdash (e_1, e_2) : \tau_1 \otimes \tau_2}$$

5. **ä¹˜ç§¯æ¶ˆé™¤**ï¼š
   $$\frac{\Gamma \vdash e : \tau_1 \otimes \tau_2 \quad \Delta, x : \tau_1, y : \tau_2 \vdash e' : \tau}{\Gamma, \Delta \vdash \text{let } (x, y) = e \text{ in } e' : \tau}$$

### 2. çº¿æ€§æ€§çº¦æŸ

#### 2.1 çº¿æ€§æ€§å®šä¹‰

**å®šä¹‰ 2.1 (çº¿æ€§æ€§)**
ä¸€ä¸ªè¡¨è¾¾å¼ $e$ æ˜¯çº¿æ€§çš„ï¼Œå½“ä¸”ä»…å½“å…¶ä¸­çš„æ¯ä¸ªå˜é‡æ°å¥½å‡ºç°ä¸€æ¬¡ã€‚

**çº¿æ€§æ€§æ£€æŸ¥ç®—æ³•**ï¼š

```haskell
-- Haskellå®ç°çš„çº¿æ€§æ€§æ£€æŸ¥
data LinearContext = LinearContext [(String, Int)] deriving Show

checkLinearity :: Expr -> LinearContext -> Bool
checkLinearity (Var x) ctx = 
    case lookup x (context ctx) of
        Just count -> count == 1
        Nothing -> False

checkLinearity (App e1 e2) ctx =
    checkLinearity e1 ctx && checkLinearity e2 ctx

checkLinearity (Lam x e) ctx =
    checkLinearity e (addVar x ctx)

checkLinearity (Pair e1 e2) ctx =
    checkLinearity e1 ctx && checkLinearity e2 ctx

addVar :: String -> LinearContext -> LinearContext
addVar x (LinearContext vars) = 
    LinearContext $ (x, 1) : vars

-- ä½¿ç”¨ç¤ºä¾‹
main :: IO ()
main = do
    let ctx = LinearContext []
    let expr = Lam "x" (Var "x")
    putStrLn $ "Expression is linear: " ++ show (checkLinearity expr ctx)
```

#### 2.2 çº¿æ€§æ€§ä¿æŒå®šç†

**å®šç† 2.1 (çº¿æ€§æ€§ä¿æŒ)**
å¦‚æœ $\Gamma \vdash e : \tau$ï¼Œåˆ™ $\Gamma$ ä¸­çš„æ¯ä¸ªå˜é‡åœ¨ $e$ ä¸­æ°å¥½å‡ºç°ä¸€æ¬¡ã€‚

**è¯æ˜**ï¼š
é€šè¿‡ç»“æ„å½’çº³æ³•è¯æ˜ï¼š

1. **åŸºç¡€æƒ…å†µ**ï¼šå¯¹äºå˜é‡ $x$ï¼Œå¦‚æœ $\Gamma, x : \tau \vdash x : \tau$ï¼Œåˆ™ $x$ åœ¨è¡¨è¾¾å¼ä¸­æ°å¥½å‡ºç°ä¸€æ¬¡ã€‚

2. **å½’çº³æ­¥éª¤**ï¼š
   - **åº”ç”¨**ï¼šå¦‚æœ $f : \tau_1 \multimap \tau_2$ å’Œ $e : \tau_1$ éƒ½æ˜¯çº¿æ€§çš„ï¼Œåˆ™ $f \, e$ ä¹Ÿæ˜¯çº¿æ€§çš„ã€‚
   - **æŠ½è±¡**ï¼šå¦‚æœ $e$ åœ¨ $\Gamma, x : \tau_1$ ä¸‹æ˜¯çº¿æ€§çš„ï¼Œåˆ™ $\lambda x. e$ åœ¨ $\Gamma$ ä¸‹æ˜¯çº¿æ€§çš„ã€‚
   - **ä¹˜ç§¯**ï¼šå¦‚æœ $e_1$ å’Œ $e_2$ åˆ†åˆ«åœ¨ä¸åŒçš„ä¸Šä¸‹æ–‡ä¸­æ˜¯çº¿æ€§çš„ï¼Œåˆ™ $(e_1, e_2)$ æ˜¯çº¿æ€§çš„ã€‚

#### 2.3 çº¿æ€§æ€§è¿åæ£€æµ‹

```rust
// Rustå®ç°çš„çº¿æ€§æ€§æ£€æŸ¥å™¨
use std::collections::HashMap;

#[derive(Debug, Clone)]
enum Expr {
    Var(String),
    App(Box<Expr>, Box<Expr>),
    Lam(String, Box<Expr>),
    Pair(Box<Expr>, Box<Expr>),
    Let(String, String, Box<Expr>, Box<Expr>),
}

struct LinearChecker {
    context: HashMap<String, i32>,
}

impl LinearChecker {
    fn new() -> Self {
        Self {
            context: HashMap::new(),
        }
    }
    
    fn check(&mut self, expr: &Expr) -> Result<(), String> {
        match expr {
            Expr::Var(x) => {
                let count = self.context.get(x).unwrap_or(&0);
                if *count != 1 {
                    return Err(format!("Variable {} used {} times", x, count));
                }
                Ok(())
            }
            Expr::App(e1, e2) => {
                self.check(e1)?;
                self.check(e2)?;
                Ok(())
            }
            Expr::Lam(x, e) => {
                self.context.insert(x.clone(), 1);
                let result = self.check(e);
                self.context.remove(x);
                result
            }
            Expr::Pair(e1, e2) => {
                self.check(e1)?;
                self.check(e2)?;
                Ok(())
            }
            Expr::Let(x, y, e1, e2) => {
                self.check(e1)?;
                self.context.insert(x.clone(), 1);
                self.context.insert(y.clone(), 1);
                let result = self.check(e2);
                self.context.remove(x);
                self.context.remove(y);
                result
            }
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    let mut checker = LinearChecker::new();
    
    // çº¿æ€§è¡¨è¾¾å¼ï¼šÎ»x.x
    let linear_expr = Expr::Lam("x".to_string(), Box::new(Expr::Var("x".to_string())));
    println!("Linear expression: {:?}", checker.check(&linear_expr));
    
    // éçº¿æ€§è¡¨è¾¾å¼ï¼šÎ»x.(x, x)
    let non_linear_expr = Expr::Lam(
        "x".to_string(), 
        Box::new(Expr::Pair(
            Box::new(Expr::Var("x".to_string())),
            Box::new(Expr::Var("x".to_string()))
        ))
    );
    println!("Non-linear expression: {:?}", checker.check(&non_linear_expr));
}
```

### 3. èµ„æºç®¡ç†ç†è®º

#### 3.1 èµ„æºå®‰å…¨å®šä¹‰

**å®šä¹‰ 3.1 (èµ„æºå®‰å…¨)**
åœ¨çº¿æ€§ç±»å‹ç³»ç»Ÿä¸­ï¼Œèµ„æºå®‰å…¨æ˜¯æŒ‡ï¼š

1. æ¯ä¸ªèµ„æºåªèƒ½è¢«ä½¿ç”¨ä¸€æ¬¡
2. æ¯ä¸ªèµ„æºæœ€ç»ˆéƒ½ä¼šè¢«é‡Šæ”¾
3. ä¸ä¼šå‡ºç°æ‚¬ç©ºæŒ‡é’ˆæˆ–é‡å¤é‡Šæ”¾

**èµ„æºå®‰å…¨å®šç†**ï¼š

**å®šç† 3.1 (èµ„æºå®‰å…¨)**
åœ¨çº¿æ€§ç±»å‹ç³»ç»Ÿä¸­ï¼Œå¦‚æœ $\Gamma \vdash e : \tau$ï¼Œåˆ™ $e$ çš„æ‰§è¡Œä¸ä¼šå¯¼è‡´èµ„æºå®‰å…¨é—®é¢˜ã€‚

**è¯æ˜**ï¼š
é€šè¿‡çº¿æ€§æ€§çº¦æŸå’Œç±»å‹å®‰å…¨ä¿è¯ï¼š

1. çº¿æ€§æ€§ç¡®ä¿æ¯ä¸ªèµ„æºåªè¢«ä½¿ç”¨ä¸€æ¬¡
2. ç±»å‹ç³»ç»Ÿç¡®ä¿èµ„æºåœ¨æ­£ç¡®çš„æ—¶é—´è¢«é‡Šæ”¾
3. ç¼–è¯‘æ—¶æ£€æŸ¥é˜²æ­¢æ‚¬ç©ºæŒ‡é’ˆ

#### 3.2 èµ„æºç”Ÿå‘½å‘¨æœŸç®¡ç†

```rust
// Rustèµ„æºç”Ÿå‘½å‘¨æœŸç®¡ç†ç¤ºä¾‹
use std::rc::Rc;
use std::cell::RefCell;

// çº¿æ€§èµ„æºç±»å‹
struct LinearResource {
    data: Vec<u8>,
    used: bool,
}

impl LinearResource {
    fn new(data: Vec<u8>) -> Self {
        Self {
            data,
            used: false,
        }
    }
    
    fn use_once(&mut self) -> Result<(), String> {
        if self.used {
            return Err("Resource already used".to_string());
        }
        self.used = true;
        println!("Using resource with {} bytes", self.data.len());
        Ok(())
    }
    
    fn consume(self) -> Vec<u8> {
        self.data
    }
}

// çº¿æ€§å‡½æ•°ç±»å‹
fn process_resource(mut resource: LinearResource) -> Vec<u8> {
    resource.use_once().expect("Resource should be usable");
    resource.consume()
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    let resource = LinearResource::new(vec![1, 2, 3, 4, 5]);
    let result = process_resource(resource);
    println!("Processed data: {:?}", result);
    
    // ä»¥ä¸‹ä»£ç æ— æ³•ç¼–è¯‘ï¼Œå› ä¸ºresourceå·²ç»è¢«æ¶ˆè´¹
    // let result2 = process_resource(resource);
}
```

## ğŸ”§ å·¥ç¨‹å®ç°

### 1. Rustæ‰€æœ‰æƒç³»ç»Ÿ

#### 1.1 æ‰€æœ‰æƒæ¦‚å¿µ

**å®šä¹‰ 4.1 (Rustæ‰€æœ‰æƒ)**
Rustçš„æ‰€æœ‰æƒç³»ç»Ÿæ˜¯çº¿æ€§ç±»å‹ç†è®ºåœ¨ç³»ç»Ÿç¼–ç¨‹ä¸­çš„å®é™…åº”ç”¨ï¼Œç¡®ä¿å†…å­˜å®‰å…¨å’Œå¹¶å‘å®‰å…¨ã€‚

**æ‰€æœ‰æƒè§„åˆ™**ï¼š

1. æ¯ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…
2. åŒä¸€æ—¶é—´åªèƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…
3. å½“æ‰€æœ‰è€…ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œå€¼è¢«ä¸¢å¼ƒ

```rust
// Rustæ‰€æœ‰æƒç¤ºä¾‹
fn main() {
    // åˆ›å»ºå­—ç¬¦ä¸²
    let s1 = String::from("hello");
    
    // æ‰€æœ‰æƒè½¬ç§»
    let s2 = s1; // s1çš„æ‰€æœ‰æƒç§»åŠ¨åˆ°s2
    
    // println!("{}", s1); // ç¼–è¯‘é”™è¯¯ï¼šs1å·²è¢«ç§»åŠ¨
    
    // å…‹éš†ï¼ˆæ·±æ‹·è´ï¼‰
    let s3 = s2.clone();
    println!("s2: {}, s3: {}", s2, s3);
    
    // å€Ÿç”¨ï¼ˆå¼•ç”¨ï¼‰
    let len = calculate_length(&s3);
    println!("Length of '{}' is {}", s3, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}

// å¯å˜å€Ÿç”¨
fn change_string(s: &mut String) {
    s.push_str(" world");
}

fn main() {
    let mut s = String::from("hello");
    change_string(&mut s);
    println!("{}", s);
}
```

#### 1.2 ç”Ÿå‘½å‘¨æœŸæ³¨è§£

```rust
// ç”Ÿå‘½å‘¨æœŸæ³¨è§£ç¤ºä¾‹
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

// ç»“æ„ä½“ç”Ÿå‘½å‘¨æœŸ
struct ImportantExcerpt<'a> {
    part: &'a str,
}

impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }
    
    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("Attention please: {}", announcement);
        self.part
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().unwrap();
    let i = ImportantExcerpt {
        part: first_sentence,
    };
    
    let result = longest("hello", "world");
    println!("Longest: {}", result);
}
```

#### 1.3 æ™ºèƒ½æŒ‡é’ˆ

```rust
// æ™ºèƒ½æŒ‡é’ˆç¤ºä¾‹
use std::rc::Rc;
use std::cell::RefCell;
use std::sync::{Arc, Mutex};

// Rc<T> - å¼•ç”¨è®¡æ•°æ™ºèƒ½æŒ‡é’ˆ
fn rc_example() {
    let data = Rc::new(vec![1, 2, 3, 4, 5]);
    
    let data1 = Rc::clone(&data);
    let data2 = Rc::clone(&data);
    
    println!("Reference count: {}", Rc::strong_count(&data));
    println!("Data: {:?}", *data);
}

// RefCell<T> - å†…éƒ¨å¯å˜æ€§
fn refcell_example() {
    let data = RefCell::new(vec![1, 2, 3]);
    
    {
        let mut borrow = data.borrow_mut();
        borrow.push(4);
    }
    
    println!("Data: {:?}", data.borrow());
}

// Arc<T> - åŸå­å¼•ç”¨è®¡æ•°ï¼ˆçº¿ç¨‹å®‰å…¨ï¼‰
fn arc_example() {
    let data = Arc::new(vec![1, 2, 3, 4, 5]);
    let mut handles = vec![];
    
    for i in 0..3 {
        let data_clone = Arc::clone(&data);
        let handle = std::thread::spawn(move || {
            println!("Thread {}: {:?}", i, *data_clone);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
}

// Mutex<T> - äº’æ–¥é”
fn mutex_example() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    
    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = std::thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("Final count: {}", *counter.lock().unwrap());
}

fn main() {
    rc_example();
    refcell_example();
    arc_example();
    mutex_example();
}
```

### 2. çº¿æ€§ç±»å‹ç³»ç»Ÿå®ç°

#### 2.1 ç±»å‹æ£€æŸ¥å™¨

```haskell
-- Haskellçº¿æ€§ç±»å‹æ£€æŸ¥å™¨
module LinearTypeChecker where

import Data.Map (Map)
import qualified Data.Map as Map

-- çº¿æ€§ç±»å‹
data LinearType = 
    Base String
    | LinearArrow LinearType LinearType
    | Tensor LinearType LinearType
    | Sum LinearType LinearType
    | Bang LinearType
    deriving (Eq, Show)

-- è¡¨è¾¾å¼
data Expr = 
    Var String
    | App Expr Expr
    | Lam String Expr
    | Pair Expr Expr
    | Let String String Expr Expr
    | Bang Expr
    | LetBang String Expr Expr
    deriving Show

-- çº¿æ€§ä¸Šä¸‹æ–‡
type LinearContext = Map String Int

-- ç±»å‹æ£€æŸ¥
typeCheck :: Expr -> LinearContext -> LinearType -> Bool
typeCheck (Var x) ctx typ = 
    case Map.lookup x ctx of
        Just 1 -> True
        _ -> False

typeCheck (App e1 e2) ctx typ =
    case inferType e1 ctx of
        Just (LinearArrow t1 t2) -> 
            typeCheck e2 ctx t1 && t2 == typ
        _ -> False

typeCheck (Lam x e) ctx typ =
    case typ of
        LinearArrow t1 t2 ->
            let newCtx = Map.insert x 1 ctx
            in typeCheck e newCtx t2
        _ -> False

typeCheck (Pair e1 e2) ctx typ =
    case typ of
        Tensor t1 t2 ->
            typeCheck e1 ctx t1 && typeCheck e2 ctx t2
        _ -> False

typeCheck (Let x y e1 e2) ctx typ =
    case inferType e1 ctx of
        Just (Tensor t1 t2) ->
            let newCtx = Map.insert x 1 (Map.insert y 1 ctx)
            in typeCheck e2 newCtx typ
        _ -> False

typeCheck (Bang e) ctx typ =
    case typ of
        Bang t -> typeCheck e ctx t
        _ -> False

typeCheck (LetBang x e1 e2) ctx typ =
    case inferType e1 ctx of
        Just (Bang t) ->
            let newCtx = Map.insert x 0 ctx  -- å¯ä»¥å¤šæ¬¡ä½¿ç”¨
            in typeCheck e2 newCtx typ
        _ -> False

-- ç±»å‹æ¨æ–­
inferType :: Expr -> LinearContext -> Maybe LinearType
inferType (Var x) ctx = 
    case Map.lookup x ctx of
        Just 1 -> Just (Base "Unknown")
        _ -> Nothing

inferType (App e1 e2) ctx =
    case inferType e1 ctx of
        Just (LinearArrow t1 t2) ->
            if typeCheck e2 ctx t1
            then Just t2
            else Nothing
        _ -> Nothing

inferType (Lam x e) ctx =
    let newCtx = Map.insert x 1 ctx
    in case inferType e newCtx of
        Just t -> Just (LinearArrow (Base "Unknown") t)
        Nothing -> Nothing

inferType (Pair e1 e2) ctx =
    case (inferType e1 ctx, inferType e2 ctx) of
        (Just t1, Just t2) -> Just (Tensor t1 t2)
        _ -> Nothing

-- ä½¿ç”¨ç¤ºä¾‹
main :: IO ()
main = do
    let ctx = Map.empty
    let expr = Lam "x" (Var "x")
    putStrLn $ "Expression type: " ++ show (inferType expr ctx)
```

#### 2.2 çº¿æ€§ç±»å‹ç¼–è¯‘å™¨

```rust
// Rustçº¿æ€§ç±»å‹ç¼–è¯‘å™¨
use std::collections::HashMap;

#[derive(Debug, Clone, PartialEq)]
enum LinearType {
    Base(String),
    LinearArrow(Box<LinearType>, Box<LinearType>),
    Tensor(Box<LinearType>, Box<LinearType>),
    Sum(Box<LinearType>, Box<LinearType>),
    Bang(Box<LinearType>),
}

#[derive(Debug, Clone)]
enum Expr {
    Var(String),
    App(Box<Expr>, Box<Expr>),
    Lam(String, Box<Expr>),
    Pair(Box<Expr>, Box<Expr>),
    Let(String, String, Box<Expr>, Box<Expr>),
    Bang(Box<Expr>),
    LetBang(String, Box<Expr>, Box<Expr>),
}

struct LinearCompiler {
    context: HashMap<String, LinearType>,
    var_count: HashMap<String, i32>,
}

impl LinearCompiler {
    fn new() -> Self {
        Self {
            context: HashMap::new(),
            var_count: HashMap::new(),
        }
    }
    
    fn type_check(&mut self, expr: &Expr) -> Result<LinearType, String> {
        match expr {
            Expr::Var(x) => {
                let count = self.var_count.get(x).unwrap_or(&0);
                if *count != 1 {
                    return Err(format!("Variable {} used {} times", x, count));
                }
                self.context.get(x)
                    .cloned()
                    .ok_or_else(|| format!("Variable {} not found", x))
            }
            Expr::App(e1, e2) => {
                let t1 = self.type_check(e1)?;
                let t2 = self.type_check(e2)?;
                
                match t1 {
                    LinearType::LinearArrow(arg_type, ret_type) => {
                        if *arg_type == t2 {
                            Ok(*ret_type)
                        } else {
                            Err("Type mismatch in application".to_string())
                        }
                    }
                    _ => Err("Expected function type".to_string()),
                }
            }
            Expr::Lam(x, e) => {
                let arg_type = LinearType::Base("Unknown".to_string());
                self.context.insert(x.clone(), arg_type.clone());
                self.var_count.insert(x.clone(), 1);
                
                let body_type = self.type_check(e)?;
                let result = LinearType::LinearArrow(Box::new(arg_type), Box::new(body_type));
                
                self.context.remove(x);
                self.var_count.remove(x);
                
                Ok(result)
            }
            Expr::Pair(e1, e2) => {
                let t1 = self.type_check(e1)?;
                let t2 = self.type_check(e2)?;
                Ok(LinearType::Tensor(Box::new(t1), Box::new(t2)))
            }
            Expr::Let(x, y, e1, e2) => {
                let t1 = self.type_check(e1)?;
                
                if let LinearType::Tensor(t1_inner, t2_inner) = t1 {
                    self.context.insert(x.clone(), *t1_inner);
                    self.context.insert(y.clone(), *t2_inner);
                    self.var_count.insert(x.clone(), 1);
                    self.var_count.insert(y.clone(), 1);
                    
                    let result = self.type_check(e2)?;
                    
                    self.context.remove(x);
                    self.context.remove(y);
                    self.var_count.remove(x);
                    self.var_count.remove(y);
                    
                    Ok(result)
                } else {
                    Err("Expected tensor type in let binding".to_string())
                }
            }
            Expr::Bang(e) => {
                let t = self.type_check(e)?;
                Ok(LinearType::Bang(Box::new(t)))
            }
            Expr::LetBang(x, e1, e2) => {
                let t1 = self.type_check(e1)?;
                
                if let LinearType::Bang(t_inner) = t1 {
                    self.context.insert(x.clone(), *t_inner);
                    self.var_count.insert(x.clone(), 0); // å¯ä»¥å¤šæ¬¡ä½¿ç”¨
                    
                    let result = self.type_check(e2)?;
                    
                    self.context.remove(x);
                    self.var_count.remove(x);
                    
                    Ok(result)
                } else {
                    Err("Expected bang type in let! binding".to_string())
                }
            }
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    let mut compiler = LinearCompiler::new();
    
    // çº¿æ€§å‡½æ•°ï¼šÎ»x.x
    let linear_expr = Expr::Lam(
        "x".to_string(),
        Box::new(Expr::Var("x".to_string()))
    );
    
    match compiler.type_check(&linear_expr) {
        Ok(typ) => println!("Type: {:?}", typ),
        Err(e) => println!("Error: {}", e),
    }
}
```

## ğŸ­ åº”ç”¨æ¡ˆä¾‹

### 1. å†…å­˜å®‰å…¨ç³»ç»Ÿ

#### 1.1 è‡ªåŠ¨å†…å­˜ç®¡ç†

```rust
// è‡ªåŠ¨å†…å­˜ç®¡ç†ç³»ç»Ÿ
use std::rc::Rc;
use std::cell::RefCell;

// çº¿æ€§èµ„æºç®¡ç†å™¨
struct LinearResourceManager<T> {
    resources: Vec<LinearResource<T>>,
}

struct LinearResource<T> {
    data: T,
    used: bool,
}

impl<T> LinearResource<T> {
    fn new(data: T) -> Self {
        Self {
            data,
            used: false,
        }
    }
    
    fn use_once(&mut self) -> Result<&T, String> {
        if self.used {
            return Err("Resource already used".to_string());
        }
        self.used = true;
        Ok(&self.data)
    }
    
    fn consume(self) -> T {
        self.data
    }
}

impl<T> LinearResourceManager<T> {
    fn new() -> Self {
        Self {
            resources: Vec::new(),
        }
    }
    
    fn add_resource(&mut self, data: T) {
        self.resources.push(LinearResource::new(data));
    }
    
    fn get_resource(&mut self, index: usize) -> Result<&T, String> {
        if index >= self.resources.len() {
            return Err("Resource index out of bounds".to_string());
        }
        self.resources[index].use_once()
    }
    
    fn consume_resource(&mut self, index: usize) -> Result<T, String> {
        if index >= self.resources.len() {
            return Err("Resource index out of bounds".to_string());
        }
        let resource = self.resources.remove(index);
        Ok(resource.consume())
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    let mut manager = LinearResourceManager::new();
    
    // æ·»åŠ èµ„æº
    manager.add_resource(String::from("Resource 1"));
    manager.add_resource(String::from("Resource 2"));
    
    // ä½¿ç”¨èµ„æº
    match manager.get_resource(0) {
        Ok(data) => println!("Used: {}", data),
        Err(e) => println!("Error: {}", e),
    }
    
    // æ¶ˆè´¹èµ„æº
    match manager.consume_resource(1) {
        Ok(data) => println!("Consumed: {}", data),
        Err(e) => println!("Error: {}", e),
    }
}
```

#### 1.2 å¹¶å‘å®‰å…¨ä¿è¯

```rust
// å¹¶å‘å®‰å…¨çš„çº¿æ€§ç±»å‹ç³»ç»Ÿ
use std::sync::{Arc, Mutex};
use std::thread;

// çº¿æ€§é€šé“
struct LinearChannel<T> {
    data: Arc<Mutex<Option<T>>>,
}

impl<T> LinearChannel<T> {
    fn new() -> Self {
        Self {
            data: Arc::new(Mutex::new(None)),
        }
    }
    
    fn send(&self, value: T) -> Result<(), String> {
        let mut data = self.data.lock().unwrap();
        if data.is_some() {
            return Err("Channel already has data".to_string());
        }
        *data = Some(value);
        Ok(())
    }
    
    fn receive(&self) -> Result<T, String> {
        let mut data = self.data.lock().unwrap();
        data.take().ok_or_else(|| "No data in channel".to_string())
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    let channel = LinearChannel::new();
    
    // å‘é€æ•°æ®
    channel.send(String::from("Hello, World!")).unwrap();
    
    // æ¥æ”¶æ•°æ®
    match channel.receive() {
        Ok(data) => println!("Received: {}", data),
        Err(e) => println!("Error: {}", e),
    }
    
    // å†æ¬¡æ¥æ”¶ä¼šå¤±è´¥
    match channel.receive() {
        Ok(data) => println!("Received: {}", data),
        Err(e) => println!("Error: {}", e),
    }
}
```

### 2. ç³»ç»Ÿç¼–ç¨‹åº”ç”¨

#### 2.1 æ–‡ä»¶å¥æŸ„ç®¡ç†

```rust
// çº¿æ€§æ–‡ä»¶å¥æŸ„ç®¡ç†
use std::fs::File;
use std::io::{Read, Write};

struct LinearFileHandle {
    file: Option<File>,
    used: bool,
}

impl LinearFileHandle {
    fn new(filename: &str) -> Result<Self, std::io::Error> {
        let file = File::open(filename)?;
        Ok(Self {
            file: Some(file),
            used: false,
        })
    }
    
    fn read_once(&mut self) -> Result<String, String> {
        if self.used {
            return Err("File handle already used".to_string());
        }
        
        if let Some(ref mut file) = self.file {
            let mut contents = String::new();
            file.read_to_string(&mut contents)
                .map_err(|e| e.to_string())?;
            self.used = true;
            Ok(contents)
        } else {
            Err("File handle is None".to_string())
        }
    }
    
    fn write_once(&mut self, content: &str) -> Result<(), String> {
        if self.used {
            return Err("File handle already used".to_string());
        }
        
        if let Some(ref mut file) = self.file {
            file.write_all(content.as_bytes())
                .map_err(|e| e.to_string())?;
            self.used = true;
            Ok(())
        } else {
            Err("File handle is None".to_string())
        }
    }
    
    fn consume(self) -> File {
        self.file.unwrap()
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() -> Result<(), Box<dyn std::error::Error>> {
    // åˆ›å»ºæµ‹è¯•æ–‡ä»¶
    std::fs::write("test.txt", "Hello, Linear Types!")?;
    
    // è¯»å–æ–‡ä»¶
    let mut handle = LinearFileHandle::new("test.txt")?;
    let content = handle.read_once()?;
    println!("Read: {}", content);
    
    // å°è¯•å†æ¬¡è¯»å–ä¼šå¤±è´¥
    match handle.read_once() {
        Ok(content) => println!("Read again: {}", content),
        Err(e) => println!("Error: {}", e),
    }
    
    // æ¸…ç†
    std::fs::remove_file("test.txt")?;
    Ok(())
}
```

#### 2.2 ç½‘ç»œè¿æ¥ç®¡ç†

```rust
// çº¿æ€§ç½‘ç»œè¿æ¥ç®¡ç†
use std::net::{TcpStream, TcpListener};
use std::io::{Read, Write};

struct LinearConnection {
    stream: Option<TcpStream>,
    used: bool,
}

impl LinearConnection {
    fn connect(addr: &str) -> Result<Self, std::io::Error> {
        let stream = TcpStream::connect(addr)?;
        Ok(Self {
            stream: Some(stream),
            used: false,
        })
    }
    
    fn send_once(&mut self, data: &[u8]) -> Result<(), String> {
        if self.used {
            return Err("Connection already used".to_string());
        }
        
        if let Some(ref mut stream) = self.stream {
            stream.write_all(data)
                .map_err(|e| e.to_string())?;
            self.used = true;
            Ok(())
        } else {
            Err("Connection is None".to_string())
        }
    }
    
    fn receive_once(&mut self, buffer: &mut [u8]) -> Result<usize, String> {
        if self.used {
            return Err("Connection already used".to_string());
        }
        
        if let Some(ref mut stream) = self.stream {
            let bytes_read = stream.read(buffer)
                .map_err(|e| e.to_string())?;
            self.used = true;
            Ok(bytes_read)
        } else {
            Err("Connection is None".to_string())
        }
    }
    
    fn consume(self) -> TcpStream {
        self.stream.unwrap()
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() -> Result<(), Box<dyn std::error::Error>> {
    // å¯åŠ¨æœåŠ¡å™¨
    let listener = TcpListener::bind("127.0.0.1:8080")?;
    
    // åœ¨å¦ä¸€ä¸ªçº¿ç¨‹ä¸­å¤„ç†è¿æ¥
    std::thread::spawn(move || {
        for stream in listener.incoming() {
            if let Ok(mut stream) = stream {
                let mut buffer = [0; 1024];
                if let Ok(bytes_read) = stream.read(&mut buffer) {
                    println!("Received: {}", String::from_utf8_lossy(&buffer[..bytes_read]));
                }
            }
        }
    });
    
    // å®¢æˆ·ç«¯è¿æ¥
    let mut connection = LinearConnection::connect("127.0.0.1:8080")?;
    
    // å‘é€æ•°æ®
    connection.send_once(b"Hello, Linear Network!")?;
    
    // å°è¯•å†æ¬¡å‘é€ä¼šå¤±è´¥
    match connection.send_once(b"Another message") {
        Ok(()) => println!("Sent another message"),
        Err(e) => println!("Error: {}", e),
    }
    
    Ok(())
}
```

## ğŸ“Š æ€§èƒ½åˆ†æä¸ä¼˜åŒ–

### 1. ç¼–è¯‘æ—¶ä¼˜åŒ–

#### 1.1 çº¿æ€§æ€§æ£€æŸ¥ä¼˜åŒ–

```rust
// ä¼˜åŒ–çš„çº¿æ€§æ€§æ£€æŸ¥å™¨
use std::collections::HashMap;

struct OptimizedLinearChecker {
    context: HashMap<String, UsageInfo>,
}

#[derive(Debug, Clone)]
struct UsageInfo {
    count: i32,
    linear: bool,
    last_used: Option<usize>,
}

impl OptimizedLinearChecker {
    fn new() -> Self {
        Self {
            context: HashMap::new(),
        }
    }
    
    fn check_expression(&mut self, expr: &Expr, position: usize) -> Result<(), String> {
        match expr {
            Expr::Var(x) => {
                let info = self.context.get_mut(x)
                    .ok_or_else(|| format!("Variable {} not found", x))?;
                
                if info.linear && info.count > 0 {
                    return Err(format!("Variable {} used multiple times", x));
                }
                
                info.count += 1;
                info.last_used = Some(position);
                Ok(())
            }
            Expr::App(e1, e2) => {
                self.check_expression(e1, position)?;
                self.check_expression(e2, position + 1)?;
                Ok(())
            }
            Expr::Lam(x, e) => {
                self.context.insert(x.clone(), UsageInfo {
                    count: 0,
                    linear: true,
                    last_used: None,
                });
                
                let result = self.check_expression(e, position + 1);
                self.context.remove(x);
                result
            }
            _ => Ok(()),
        }
    }
    
    fn optimize_context(&mut self) {
        // ç§»é™¤æœªä½¿ç”¨çš„å˜é‡
        self.context.retain(|_, info| info.count > 0);
        
        // æ ‡è®°éçº¿æ€§å˜é‡
        for info in self.context.values_mut() {
            if info.count > 1 {
                info.linear = false;
            }
        }
    }
}
```

#### 1.2 å†…å­˜å¸ƒå±€ä¼˜åŒ–

```rust
// ä¼˜åŒ–çš„å†…å­˜å¸ƒå±€
#[repr(C)]
struct OptimizedLinearStruct {
    data: [u8; 64],
    used: bool,
    _padding: [u8; 7], // ç¡®ä¿8å­—èŠ‚å¯¹é½
}

impl OptimizedLinearStruct {
    fn new(data: [u8; 64]) -> Self {
        Self {
            data,
            used: false,
            _padding: [0; 7],
        }
    }
    
    fn use_once(&mut self) -> Result<&[u8], String> {
        if self.used {
            return Err("Already used".to_string());
        }
        self.used = true;
        Ok(&self.data)
    }
    
    fn consume(self) -> [u8; 64] {
        self.data
    }
}

// æ‰¹é‡å¤„ç†ä¼˜åŒ–
struct BatchProcessor<T> {
    items: Vec<LinearResource<T>>,
    batch_size: usize,
}

impl<T> BatchProcessor<T> {
    fn new(batch_size: usize) -> Self {
        Self {
            items: Vec::new(),
            batch_size,
        }
    }
    
    fn add_item(&mut self, item: T) {
        self.items.push(LinearResource::new(item));
    }
    
    fn process_batch<F>(&mut self, processor: F) -> Result<Vec<T>, String>
    where
        F: Fn(T) -> T,
    {
        let mut results = Vec::new();
        
        for _ in 0..self.batch_size {
            if let Some(item) = self.items.pop() {
                let processed = processor(item.consume());
                results.push(processed);
            } else {
                break;
            }
        }
        
        Ok(results)
    }
}
```

### 2. è¿è¡Œæ—¶ä¼˜åŒ–

#### 2.1 é›¶æ‹·è´ä¼˜åŒ–

```rust
// é›¶æ‹·è´çº¿æ€§ç±»å‹
use std::borrow::Cow;

struct ZeroCopyLinearString<'a> {
    data: Cow<'a, str>,
    used: bool,
}

impl<'a> ZeroCopyLinearString<'a> {
    fn new(data: &'a str) -> Self {
        Self {
            data: Cow::Borrowed(data),
            used: false,
        }
    }
    
    fn use_once(&mut self) -> Result<&str, String> {
        if self.used {
            return Err("Already used".to_string());
        }
        self.used = true;
        Ok(&self.data)
    }
    
    fn to_owned(self) -> String {
        self.data.into_owned()
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    let original = "Hello, World!";
    let mut linear_str = ZeroCopyLinearString::new(original);
    
    // ä½¿ç”¨å­—ç¬¦ä¸²ï¼ˆé›¶æ‹·è´ï¼‰
    match linear_str.use_once() {
        Ok(s) => println!("Used: {}", s),
        Err(e) => println!("Error: {}", e),
    }
    
    // è½¬æ¢ä¸ºæ‹¥æœ‰æ‰€æœ‰æƒçš„å­—ç¬¦ä¸²
    let owned = linear_str.to_owned();
    println!("Owned: {}", owned);
}
```

#### 2.2 å¹¶å‘ä¼˜åŒ–

```rust
// å¹¶å‘ä¼˜åŒ–çš„çº¿æ€§ç±»å‹
use std::sync::{Arc, Mutex};
use std::thread;

struct ConcurrentLinearResource<T> {
    data: Arc<Mutex<Option<T>>>,
    used: Arc<Mutex<bool>>,
}

impl<T> ConcurrentLinearResource<T> {
    fn new(data: T) -> Self {
        Self {
            data: Arc::new(Mutex::new(Some(data))),
            used: Arc::new(Mutex::new(false)),
        }
    }
    
    fn use_once(&self) -> Result<T, String> {
        let mut used = self.used.lock().unwrap();
        if *used {
            return Err("Already used".to_string());
        }
        
        let mut data = self.data.lock().unwrap();
        if let Some(value) = data.take() {
            *used = true;
            Ok(value)
        } else {
            Err("No data available".to_string())
        }
    }
    
    fn clone(&self) -> Self {
        Self {
            data: Arc::clone(&self.data),
            used: Arc::clone(&self.used),
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    let resource = ConcurrentLinearResource::new(String::from("Shared Data"));
    
    let mut handles = vec![];
    
    for i in 0..3 {
        let resource_clone = resource.clone();
        let handle = thread::spawn(move || {
            match resource_clone.use_once() {
                Ok(data) => println!("Thread {} got: {}", i, data),
                Err(e) => println!("Thread {} error: {}", i, e),
            }
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
}
```

## ğŸ”— ç›¸å…³é“¾æ¥

- [2.1.1-åŸºç¡€ç±»å‹ç†è®º](2.1.1-åŸºç¡€ç±»å‹ç†è®º.md) - åŸºç¡€ç±»å‹ç†è®º
- [4.1.1-Rustè¯­è¨€ç³»ç»Ÿ](../../../4-ç¼–ç¨‹è¯­è¨€ä¸èŒƒå¼/4.1-Rustè¯­è¨€/4.1.1-Rustè¯­è¨€ç³»ç»Ÿ.md) - Rustè¯­è¨€ç³»ç»Ÿ
- [1.1.9-åˆ†å¸ƒå¼PostgreSQLæ¶æ„è®¾è®¡](../../../1-æ•°æ®åº“ç³»ç»Ÿ/1.1-PostgreSQL/1.1.9-åˆ†å¸ƒå¼PostgreSQLæ¶æ„è®¾è®¡.md) - åˆ†å¸ƒå¼æ¶æ„è®¾è®¡
- [3.1.1-æ•°æ®ç§‘å­¦åŸºç¡€ç†è®º](../../../3-æ•°æ®æ¨¡å‹ä¸ç®—æ³•/3.1-æ•°æ®ç§‘å­¦åŸºç¡€ç†è®º/3.1.1-æ•°æ®ç§‘å­¦åŸºç¡€ç†è®º.md) - æ•°æ®ç§‘å­¦åŸºç¡€

[è¿”å›ç±»å‹ç†è®ºå¯¼èˆª](../README.md)
