# 2.1.1 基础类型理论

## 📑 目录

- [2.1.1 基础类型理论](#211-基础类型理论)
  - [📑 目录](#-目录)
  - [1. 摘要](#1-摘要)
  - [2. 类型理论概述](#2-类型理论概述)
    - [2.1. 类型理论的定义](#21-类型理论的定义)
    - [2.2. 类型系统的作用](#22-类型系统的作用)
    - [2.3. 类型理论的发展历程](#23-类型理论的发展历程)
  - [3. 类型系统基础](#3-类型系统基础)
    - [3.1. 类型定义](#31-类型定义)
    - [3.2. 类型分类](#32-类型分类)
      - [3.2.1. 基本类型](#321-基本类型)
      - [3.2.2. 复合类型](#322-复合类型)
      - [3.2.3. 函数类型](#323-函数类型)
      - [3.2.4. 抽象类型](#324-抽象类型)
  - [4. λ演算](#4-λ演算)
    - [4.1. 无类型λ演算](#41-无类型λ演算)
      - [4.1.1. 语法定义](#411-语法定义)
      - [4.1.2. 归约规则](#412-归约规则)
      - [4.1.3. 实现示例](#413-实现示例)
    - [4.2. 简单类型λ演算 (STLC)](#42-简单类型λ演算-stlc)
      - [4.2.1. 类型语法](#421-类型语法)
      - [4.2.2. 类型规则](#422-类型规则)
      - [4.2.3. 类型检查实现](#423-类型检查实现)
  - [5. 类型安全性](#5-类型安全性)
    - [5.1. 进展和保持定理](#51-进展和保持定理)
      - [5.1.1. 进展定理](#511-进展定理)
      - [5.1.2. 保持定理](#512-保持定理)
    - [5.2. 类型推断](#52-类型推断)
      - [5.2.1. Hindley-Milner算法](#521-hindley-milner算法)
      - [5.2.2. 统一算法](#522-统一算法)
      - [5.2.3. 类型推断实现](#523-类型推断实现)
  - [6. 多态类型系统](#6-多态类型系统)
    - [6.1. 参数多态](#61-参数多态)
      - [6.1.1. 全称类型](#611-全称类型)
      - [6.1.2. 存在类型](#612-存在类型)
    - [6.2. 系统F (二阶λ演算)](#62-系统f-二阶λ演算)
      - [6.2.1. 系统F语法](#621-系统f语法)
      - [6.2.2. 系统F类型规则](#622-系统f类型规则)
  - [7. 依赖类型系统](#7-依赖类型系统)
    - [7.1. 依赖类型基础](#71-依赖类型基础)
      - [7.1.1. Π类型](#711-π类型)
      - [7.1.2. Σ类型](#712-σ类型)
      - [7.1.3. 相等类型](#713-相等类型)
    - [7.2. 构造演算 (CoC)](#72-构造演算-coc)
      - [7.2.1. 类型层次](#721-类型层次)
      - [7.2.2. Curry-Howard对应](#722-curry-howard对应)
  - [8. 类型系统实现](#8-类型系统实现)
    - [8.1. 类型检查器](#81-类型检查器)
      - [8.1.1. 简单类型检查器](#811-简单类型检查器)
      - [8.1.2. 多态类型检查器](#812-多态类型检查器)
    - [8.2. 类型推断器](#82-类型推断器)
      - [8.2.1. 约束生成](#821-约束生成)
      - [8.2.2. 约束求解](#822-约束求解)
  - [9. 高级特性](#9-高级特性)
    - [9.1. 类型类](#91-类型类)
      - [9.1.1. 类型类定义](#911-类型类定义)
      - [9.1.2. 类型类实例](#912-类型类实例)
    - [9.2. 高阶类型](#92-高阶类型)
      - [9.2.1. 类型构造子](#921-类型构造子)
      - [9.2.2. 函子与单子](#922-函子与单子)
  - [10. 应用领域](#10-应用领域)
    - [10.1. 函数式编程](#101-函数式编程)
      - [10.1.1. Haskell类型系统](#1011-haskell类型系统)
      - [10.1.2. OCaml类型系统](#1012-ocaml类型系统)
    - [10.2. 系统编程](#102-系统编程)
      - [10.2.1. Rust类型系统](#1021-rust类型系统)
      - [10.2.2. 所有权与借用](#1022-所有权与借用)
  - [11. 研究前沿](#11-研究前沿)
    - [11.1. 线性类型系统](#111-线性类型系统)
    - [11.2. 会话类型](#112-会话类型)
    - [11.3. 同伦类型论](#113-同伦类型论)
  - [12. 形式化定义与证明](#12-形式化定义与证明)
    - [12.1. 类型系统形式化](#121-类型系统形式化)
    - [12.2. 类型安全性形式化](#122-类型安全性形式化)
  - [13. 多表征](#13-多表征)
  - [14. 总结与展望](#14-总结与展望)
    - [14.1. 总结](#141-总结)
    - [14.2. 未来展望](#142-未来展望)
  - [15. 参考文献](#15-参考文献)

---

## 1. 摘要

基础类型理论研究类型系统的形式化定义、类型安全性和类型推断，是计算机科学和数学逻辑的重要分支。本文档系统梳理基础类型理论，涵盖λ演算、简单类型系统、多态类型系统、依赖类型系统等核心内容，为编程语言设计和程序验证提供理论基础。

---

## 2. 类型理论概述

### 2.1. 类型理论的定义

**类型理论（Type Theory）**是研究类型系统的数学理论，它提供了程序语言中类型的形式化基础。

**类型系统的核心概念**：

1. **类型（Type）**：值的集合，描述值的结构和可执行操作
2. **类型系统（Type System）**：检查类型正确性的规则集合
3. **类型安全（Type Safety）**：编译时捕获类型错误，防止运行时错误
4. **类型推断（Type Inference）**：自动推导表达式的类型

### 2.2. 类型系统的作用

**类型系统的主要作用**：

1. **错误检测**：在编译时捕获类型错误
2. **文档化**：类型作为程序行为的文档
3. **抽象**：提供抽象机制，隐藏实现细节
4. **优化**：类型信息用于编译器优化
5. **验证**：支持程序的形式化验证

### 2.3. 类型理论的发展历程

**类型理论发展时间线**：

1. **1940s**：简单类型λ演算（Church, 1940）
2. **1970s**：多态类型理论（Reynolds, 1974）
3. **1980s**：依赖类型理论（Martin-Löf, 1984）
4. **1990s**：线性类型理论（Girard, 1987）
5. **2000s**：同伦类型理论（Voevodsky, 2006）
6. **2010s**：量子类型理论（Selinger, 2004）

---

## 3. 类型系统基础

### 3.1. 类型定义

**类型的形式化定义**：

类型 $T$ 是值的集合：

$$T \subseteq \text{Value}$$

**类型系统定义**：

类型系统是一个三元组 $\mathcal{T} = (\text{Type}, \vdash, \text{Value})$，其中：

- $\text{Type}$：类型集合
- $\vdash$：类型判定关系
- $\text{Value}$：值集合

**类型判定**：

$$\Gamma \vdash e : T$$

表示在上下文 $\Gamma$ 中，表达式 $e$ 具有类型 $T$。

### 3.2. 类型分类

#### 3.2.1. 基本类型

**基本类型（Primitive Types）**：

1. **整数类型**：`Int`, `Int8`, `Int16`, `Int32`, `Int64`
2. **浮点类型**：`Float`, `Double`
3. **布尔类型**：`Bool`
4. **字符类型**：`Char`
5. **字符串类型**：`String`

**示例**：

```haskell
-- Haskell基本类型
x :: Int
x = 42

y :: Double
y = 3.14

b :: Bool
b = True

c :: Char
c = 'A'

s :: String
s = "Hello"
```

#### 3.2.2. 复合类型

**复合类型（Composite Types）**：

1. **数组类型**：`Array T`
2. **列表类型**：`List T`
3. **元组类型**：`(T1, T2, ..., Tn)`
4. **结构体类型**：`struct { f1: T1, f2: T2 }`
5. **联合体类型**：`union { f1: T1, f2: T2 }`

**示例**：

```rust
// Rust复合类型
let arr: [i32; 5] = [1, 2, 3, 4, 5];
let tuple: (i32, f64, bool) = (42, 3.14, true);

struct Point {
    x: f64,
    y: f64,
}

enum Option<T> {
    Some(T),
    None,
}
```

#### 3.2.3. 函数类型

**函数类型（Function Types）**：

$$T_1 \to T_2$$

表示从类型 $T_1$ 到类型 $T_2$ 的函数。

**高阶函数类型**：

$$(T_1 \to T_2) \to T_3$$

表示接受函数作为参数的函数。

**示例**：

```haskell
-- Haskell函数类型
add :: Int -> Int -> Int
add x y = x + y

map :: (a -> b) -> [a] -> [b]
map f [] = []
map f (x:xs) = f x : map f xs

compose :: (b -> c) -> (a -> b) -> a -> c
compose f g x = f (g x)
```

#### 3.2.4. 抽象类型

**抽象类型（Abstract Types）**：

1. **接口（Interface）**：定义类型的行为
2. **类型类（Type Class）**：定义类型的操作
3. **泛型（Generic）**：参数化类型

**示例**：

```rust
// Rust trait（接口）
trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;
}

// 泛型函数
fn identity<T>(x: T) -> T {
    x
}
```

---

## 4. λ演算

### 4.1. 无类型λ演算

#### 4.1.1. 语法定义

**无类型λ演算语法**：

$$M ::= x \mid \lambda x.M \mid M \; N$$

其中：

- $x$：变量
- $\lambda x.M$：抽象（函数定义）
- $M \; N$：应用（函数调用）

**语法BNF**：

```bnf
<term> ::= <variable>
         | λ <variable> . <term>
         | <term> <term>
         | ( <term> )
```

#### 4.1.2. 归约规则

**β归约（Beta Reduction）**：

$$(\lambda x.M) \; N \to_\beta M[x := N]$$

**α转换（Alpha Conversion）**：

$$\lambda x.M \to_\alpha \lambda y.M[x := y]$$

其中 $y$ 不在 $M$ 中自由出现。

**η转换（Eta Conversion）**：

$$\lambda x.(M \; x) \to_\eta M$$

其中 $x$ 不在 $M$ 中自由出现。

**示例**：β归约

$$(\lambda x.x + 1) \; 5 \to_\beta 5 + 1 = 6$$

$$(\lambda x.\lambda y.x + y) \; 3 \to_\beta \lambda y.3 + y$$

#### 4.1.3. 实现示例

**Python实现**：

```python
class LambdaTerm:
    """λ演算项"""
    pass

class Variable(LambdaTerm):
    def __init__(self, name):
        self.name = name

    def __repr__(self):
        return self.name

class Abstraction(LambdaTerm):
    def __init__(self, var, body):
        self.var = var
        self.body = body

    def __repr__(self):
        return f"λ{self.var}.{self.body}"

class Application(LambdaTerm):
    def __init__(self, func, arg):
        self.func = func
        self.arg = arg

    def __repr__(self):
        return f"({self.func} {self.arg})"

def beta_reduce(term, var, value):
    """β归约"""
    if isinstance(term, Variable):
        return value if term.name == var else term
    elif isinstance(term, Abstraction):
        if term.var.name == var:
            return term
        return Abstraction(term.var, beta_reduce(term.body, var, value))
    elif isinstance(term, Application):
        return Application(
            beta_reduce(term.func, var, value),
            beta_reduce(term.arg, var, value)
        )

# 示例：(\x.x) y -> y
x = Variable('x')
y = Variable('y')
id_func = Abstraction(x, x)
app = Application(id_func, y)
result = beta_reduce(app.func.body, 'x', app.arg)
print(f"{app} -> {result}")
```

### 4.2. 简单类型λ演算 (STLC)

#### 4.2.1. 类型语法

**简单类型λ演算类型语法**：

$$\tau ::= \text{Bool} \mid \text{Int} \mid \tau_1 \to \tau_2$$

其中：

- $\text{Bool}$：布尔类型
- $\text{Int}$：整数类型
- $\tau_1 \to \tau_2$：函数类型

**项语法**：

$$t ::= x \mid \lambda x:\tau.t \mid t_1 \; t_2 \mid \text{true} \mid \text{false} \mid \text{if } t_1 \text{ then } t_2 \text{ else } t_3$$

#### 4.2.2. 类型规则

**变量规则**：

$$\frac{x:\tau \in \Gamma}{\Gamma \vdash x:\tau}$$

**抽象规则**：

$$\frac{\Gamma, x:\tau_1 \vdash t:\tau_2}{\Gamma \vdash \lambda x:\tau_1.t:\tau_1 \to \tau_2}$$

**应用规则**：

$$\frac{\Gamma \vdash t_1:\tau_1 \to \tau_2 \quad \Gamma \vdash t_2:\tau_1}{\Gamma \vdash t_1 \; t_2:\tau_2}$$

**布尔规则**：

$$\frac{}{\Gamma \vdash \text{true}:\text{Bool}} \quad \frac{}{\Gamma \vdash \text{false}:\text{Bool}}$$

**条件规则**：

$$\frac{\Gamma \vdash t_1:\text{Bool} \quad \Gamma \vdash t_2:\tau \quad \Gamma \vdash t_3:\tau}{\Gamma \vdash \text{if } t_1 \text{ then } t_2 \text{ else } t_3:\tau}$$

#### 4.2.3. 类型检查实现

**Haskell实现**：

```haskell
-- 类型定义
data Type = TBool | TInt | TFun Type Type
    deriving (Eq, Show)

-- 项定义
data Term = Var String
          | Lam String Type Term
          | App Term Term
          | BoolLit Bool
          | If Term Term Term
    deriving (Show)

-- 上下文
type Context = [(String, Type)]

-- 类型检查
typeCheck :: Context -> Term -> Maybe Type
typeCheck ctx (Var x) = lookup x ctx

typeCheck ctx (Lam x t body) = do
    t' <- typeCheck ((x, t) : ctx) body
    return (TFun t t')

typeCheck ctx (App f arg) = do
    TFun t1 t2 <- typeCheck ctx f
    t1' <- typeCheck ctx arg
    guard (t1 == t1')
    return t2

typeCheck ctx (BoolLit _) = Just TBool

typeCheck ctx (If cond then_ else_) = do
    TBool <- typeCheck ctx cond
    t1 <- typeCheck ctx then_
    t2 <- typeCheck ctx else_
    guard (t1 == t2)
    return t1

-- 示例
example1 = Lam "x" TInt (Var "x")  -- λx:Int.x : Int -> Int
example2 = App (Lam "x" TInt (Var "x")) (BoolLit True)  -- 类型错误
```

---

## 5. 类型安全性

### 5.1. 进展和保持定理

#### 5.1.1. 进展定理

**进展定理（Progress Theorem）**：

如果 $\emptyset \vdash t:\tau$，则要么 $t$ 是值，要么存在 $t'$ 使得 $t \to t'$。

**形式化表述**：

$$\forall t, \tau: \emptyset \vdash t:\tau \Rightarrow (\text{isValue}(t) \lor \exists t': t \to t')$$

**证明思路**：

通过对类型推导的结构归纳：

1. 如果 $t$ 是值，则结论成立
2. 如果 $t$ 不是值，则根据类型规则，$t$ 可以归约

#### 5.1.2. 保持定理

**保持定理（Preservation Theorem）**：

如果 $\Gamma \vdash t:\tau$ 且 $t \to t'$，则 $\Gamma \vdash t':\tau$。

**形式化表述**：

$$\forall \Gamma, t, t', \tau: \Gamma \vdash t:\tau \land t \to t' \Rightarrow \Gamma \vdash t':\tau$$

**证明思路**：

通过对归约规则的结构归纳：

1. β归约：通过替换引理
2. 其他归约：直接应用类型规则

**替换引理（Substitution Lemma）**：

如果 $\Gamma, x:\tau_1 \vdash t:\tau_2$ 且 $\Gamma \vdash s:\tau_1$，则：

$$\Gamma \vdash t[x := s]:\tau_2$$

### 5.2. 类型推断

#### 5.2.1. Hindley-Milner算法

**Hindley-Milner类型推断算法**：

1. **分配类型变量**：为每个子表达式分配类型变量
2. **生成约束**：根据类型规则生成类型约束
3. **统一约束**：使用统一算法求解约束
4. **泛化类型**：将类型变量泛化为全称类型

**算法步骤**：

```python
def infer_type(ctx, expr):
    """类型推断"""
    constraints = []
    type_var = fresh_type_var()

    # 为表达式分配类型变量
    expr_type = assign_type_vars(expr, type_var)

    # 生成约束
    generate_constraints(ctx, expr, expr_type, constraints)

    # 统一约束
    substitution = unify(constraints)

    # 应用替换
    result_type = apply_substitution(expr_type, substitution)

    # 泛化
    return generalize(ctx, result_type)
```

#### 5.2.2. 统一算法

**统一算法（Unification Algorithm）**：

求解类型约束 $C = \{T_1 = T_2, \ldots\}$。

**统一规则**：

1. $T = T$：删除
2. $\alpha = T$ 且 $\alpha \notin \text{FTV}(T)$：替换 $\alpha \mapsto T$
3. $T = \alpha$ 且 $\alpha \notin \text{FTV}(T)$：替换 $\alpha \mapsto T$
4. $T_1 \to T_2 = T_3 \to T_4$：添加 $T_1 = T_3$ 和 $T_2 = T_4$

**实现**：

```python
def unify(constraints):
    """统一算法"""
    substitution = {}

    while constraints:
        c = constraints.pop()

        if isinstance(c, (TypeVar, TypeVar)):
            if c[0] == c[1]:
                continue
            substitution[c[0]] = c[1]
            apply_substitution_to_constraints(constraints, substitution)

        elif isinstance(c[0], TypeVar):
            if c[0] in free_type_vars(c[1]):
                raise UnificationError("Occurs check failed")
            substitution[c[0]] = c[1]
            apply_substitution_to_constraints(constraints, substitution)

        elif isinstance(c[1], TypeVar):
            if c[1] in free_type_vars(c[0]):
                raise UnificationError("Occurs check failed")
            substitution[c[1]] = c[0]
            apply_substitution_to_constraints(constraints, substitution)

        elif isinstance(c[0], FunctionType) and isinstance(c[1], FunctionType):
            constraints.append((c[0].domain, c[1].domain))
            constraints.append((c[0].codomain, c[1].codomain))

        else:
            raise UnificationError(f"Cannot unify {c[0]} and {c[1]}")

    return substitution
```

#### 5.2.3. 类型推断实现

**完整类型推断器**：

```haskell
-- 类型变量
data Type = TVar String
          | TBool
          | TInt
          | TFun Type Type
    deriving (Eq, Show)

-- 约束
type Constraint = (Type, Type)

-- 类型推断
infer :: Context -> Term -> (Type, [Constraint])
infer ctx (Var x) = case lookup x ctx of
    Just t -> (t, [])
    Nothing -> error $ "Unbound variable: " ++ x

infer ctx (Lam x body) =
    let alpha = TVar (freshVar ())
        (bodyType, constraints) = infer ((x, alpha) : ctx) body
    in (TFun alpha bodyType, constraints)

infer ctx (App f arg) =
    let (fType, fConstraints) = infer ctx f
        (argType, argConstraints) = infer ctx arg
        beta = TVar (freshVar ())
        constraints = (fType, TFun argType beta) : fConstraints ++ argConstraints
    in (beta, constraints)

-- 统一
unify :: [Constraint] -> Maybe Substitution
unify [] = Just []
unify ((t1, t2):cs)
    | t1 == t2 = unify cs
    | TVar v <- t1, v `notElem` freeVars t2 =
        let sub = [(v, t2)]
            cs' = applySubst sub cs
        in fmap (sub ++) (unify cs')
    | TVar v <- t2, v `notElem` freeVars t1 =
        let sub = [(v, t1)]
            cs' = applySubst sub cs
        in fmap (sub ++) (unify cs')
    | TFun d1 c1 <- t1, TFun d2 c2 <- t2 =
        unify ((d1, d2):(c1, c2):cs)
    | otherwise = Nothing
```

---

## 6. 多态类型系统

### 6.1. 参数多态

#### 6.1.1. 全称类型

**全称类型（Universal Type）**：

$$\forall \alpha.T$$

表示对于所有类型 $\alpha$，类型 $T$ 都成立。

**类型实例化**：

$$[\forall \alpha.T](S) = T[\alpha \mapsto S]$$

**类型抽象**：

$$\Lambda \alpha.M$$

表示类型抽象，$M$ 可以依赖于类型 $\alpha$。

**示例**：

```haskell
-- Haskell中的多态函数
id :: forall a. a -> a
id x = x

-- 类型实例化
idInt :: Int -> Int
idInt = id

idBool :: Bool -> Bool
idBool = id
```

#### 6.1.2. 存在类型

**存在类型（Existential Type）**：

$$\exists \alpha.T$$

表示存在某个类型 $\alpha$，使得类型 $T$ 成立。

**存在类型引入**：

$$\frac{\Gamma \vdash M : T[\alpha \mapsto S]}{\Gamma \vdash \text{pack}(S, M) : \exists \alpha.T}$$

**存在类型消除**：

$$\frac{\Gamma \vdash M : \exists \alpha.T \quad \Gamma, x:T \vdash N : U \quad \alpha \notin \text{FTV}(U)}{\Gamma \vdash \text{unpack}(M, x.N) : U}$$

**示例**：

```rust
// Rust中的存在类型（通过trait object）
trait Animal {
    fn speak(&self);
}

struct Dog;
impl Animal for Dog {
    fn speak(&self) { println!("Woof!"); }
}

// 存在类型：存在某个实现Animal的类型
fn get_animal() -> Box<dyn Animal> {
    Box::new(Dog)
}
```

### 6.2. 系统F (二阶λ演算)

#### 6.2.1. 系统F语法

**系统F扩展语法**：

$$T ::= \alpha \mid T \to T \mid \forall \alpha.T$$

$$M ::= x \mid \lambda x:T.M \mid M \; M \mid \Lambda \alpha.M \mid M[T]$$

其中：

- $\alpha$：类型变量
- $\forall \alpha.T$：全称类型
- $\Lambda \alpha.M$：类型抽象
- $M[T]$：类型应用

#### 6.2.2. 系统F类型规则

**类型抽象规则**：

$$\frac{\Gamma \vdash M : T \quad \alpha \notin \text{FTV}(\Gamma)}{\Gamma \vdash \Lambda \alpha.M : \forall \alpha.T}$$

**类型应用规则**：

$$\frac{\Gamma \vdash M : \forall \alpha.T \quad \Gamma \vdash S : \text{Type}}{\Gamma \vdash M[S] : T[\alpha \mapsto S]}$$

**示例**：

```haskell
-- 系统F中的多态恒等函数
polyId :: forall a. a -> a
polyId = \x -> x

-- 类型应用
intId = polyId @Int
boolId = polyId @Bool
```

---

## 7. 依赖类型系统

### 7.1. 依赖类型基础

#### 7.1.1. Π类型

**Π类型（依赖函数类型）**：

$$\Pi x:A.B(x)$$

表示对于每个 $x:A$，类型 $B(x)$ 都成立。

**Π类型引入**：

$$\frac{\Gamma, x:A \vdash M : B(x)}{\Gamma \vdash \lambda x:A.M : \Pi x:A.B(x)}$$

**Π类型消除**：

$$\frac{\Gamma \vdash M : \Pi x:A.B(x) \quad \Gamma \vdash N : A}{\Gamma \vdash M(N) : B(N)}$$

**示例**：

```agda
-- Agda中的依赖函数类型
Vec : Set → ℕ → Set
Vec A zero = ⊤
Vec A (suc n) = A × Vec A n

-- 依赖函数：向量长度是参数的一部分
head : {A : Set} → {n : ℕ} → Vec A (suc n) → A
head (x , xs) = x
```

#### 7.1.2. Σ类型

**Σ类型（依赖积类型）**：

$$\Sigma x:A.B(x)$$

表示存在 $x:A$，使得类型 $B(x)$ 成立。

**Σ类型引入**：

$$\frac{\Gamma \vdash M : A \quad \Gamma \vdash N : B(M)}{\Gamma \vdash (M, N) : \Sigma x:A.B(x)}$$

**Σ类型消除**：

$$\frac{\Gamma \vdash M : \Sigma x:A.B(x) \quad \Gamma, x:A, y:B(x) \vdash N : C}{\Gamma \vdash \text{let } (x, y) = M \text{ in } N : C}$$

**示例**：

```agda
-- Agda中的依赖对类型
Fin : ℕ → Set
Fin zero = ⊥
Fin (suc n) = ⊤ ⊎ Fin n

-- 依赖对：证明向量有元素
NonEmpty : {A : Set} → {n : ℕ} → Vec A n → Set
NonEmpty {n = zero} _ = ⊥
NonEmpty {n = suc _} _ = ⊤

-- 使用Σ类型表示非空向量
NonEmptyVec : Set → Set
NonEmptyVec A = Σ[ n ∈ ℕ ] Σ[ v ∈ Vec A n ] NonEmpty v
```

#### 7.1.3. 相等类型

**相等类型（Identity Type）**：

$$\text{Id}(A, a, b)$$

表示 $a$ 和 $b$ 在类型 $A$ 中相等。

**相等类型引入**：

$$\frac{\Gamma \vdash a : A}{\Gamma \vdash \text{refl}_a : \text{Id}(A, a, a)}$$

**相等类型消除（J规则）**：

$$\frac{\Gamma, x:A, y:A, p:\text{Id}(A, x, y) \vdash C : \text{Type} \quad \Gamma, x:A \vdash d : C[x/x, x/y, \text{refl}_x/p]}{\Gamma, x:A, y:A, p:\text{Id}(A, x, y) \vdash J_{x,y,p.C}(d) : C}$$

### 7.2. 构造演算 (CoC)

#### 7.2.1. 类型层次

**构造演算类型层次**：

1. **Prop**：命题类型
2. **Set**：集合类型
3. **Type**：类型类型

**类型层次规则**：

$$\text{Prop} : \text{Type}_0, \quad \text{Set} : \text{Type}_0, \quad \text{Type}_i : \text{Type}_{i+1}$$

#### 7.2.2. Curry-Howard对应

**Curry-Howard对应（Curry-Howard Correspondence）**：

| 逻辑 | 类型理论 |
|------|---------|
| 命题 | 类型 |
| 证明 | 项 |
| 蕴含 | 函数类型 |
| 合取 | 积类型 |
| 析取 | 和类型 |
| 全称量词 | 全称类型 |
| 存在量词 | 存在类型 |

**示例**：

- **命题**：$A \to B$ 对应 **类型**：$A \to B$
- **命题**：$A \land B$ 对应 **类型**：$A \times B$
- **命题**：$\forall x:A.P(x)$ 对应 **类型**：$\Pi x:A.P(x)$

---

## 8. 类型系统实现

### 8.1. 类型检查器

#### 8.1.1. 简单类型检查器

**简单类型检查器实现**：

```python
from typing import Dict, Optional, List

class Type:
    pass

class BoolType(Type):
    def __eq__(self, other):
        return isinstance(other, BoolType)

    def __repr__(self):
        return "Bool"

class IntType(Type):
    def __eq__(self, other):
        return isinstance(other, IntType)

    def __repr__(self):
        return "Int"

class FunType(Type):
    def __init__(self, domain: Type, codomain: Type):
        self.domain = domain
        self.codomain = codomain

    def __eq__(self, other):
        return (isinstance(other, FunType) and
                self.domain == other.domain and
                self.codomain == other.codomain)

    def __repr__(self):
        return f"({self.domain} -> {self.codomain})"

class TypeChecker:
    def __init__(self):
        self.context: Dict[str, Type] = {}

    def check(self, expr, expected_type: Optional[Type] = None) -> Type:
        """类型检查"""
        if isinstance(expr, Variable):
            if expr.name not in self.context:
                raise TypeError(f"Unbound variable: {expr.name}")
            actual_type = self.context[expr.name]
            if expected_type and actual_type != expected_type:
                raise TypeError(f"Type mismatch: expected {expected_type}, got {actual_type}")
            return actual_type

        elif isinstance(expr, Abstraction):
            if not expected_type or not isinstance(expected_type, FunType):
                raise TypeError("Abstraction requires function type")
            self.context[expr.var.name] = expected_type.domain
            body_type = self.check(expr.body, expected_type.codomain)
            del self.context[expr.var.name]
            return FunType(expected_type.domain, body_type)

        elif isinstance(expr, Application):
            func_type = self.check(expr.func)
            if not isinstance(func_type, FunType):
                raise TypeError("Application requires function type")
            arg_type = self.check(expr.arg, func_type.domain)
            return func_type.codomain

        # ... 其他情况
```

#### 8.1.2. 多态类型检查器

**多态类型检查器**：

```haskell
-- 多态类型
data PolyType = Mono Type
              | Forall String PolyType

-- 类型检查（带多态）
typeCheckPoly :: Context -> Term -> Maybe PolyType
typeCheckPoly ctx (Var x) = lookup x ctx

typeCheckPoly ctx (Lam x body) = do
    alpha <- freshTypeVar
    bodyType <- typeCheckPoly ((x, Mono alpha) : ctx) body
    return (Mono (TFun alpha (monoType bodyType)))

typeCheckPoly ctx (App f arg) = do
    fType <- typeCheckPoly ctx f
    argType <- typeCheckPoly ctx arg
    case (fType, argType) of
        (Mono (TFun d c), Mono a) | d == a -> Just (Mono c)
        (Forall alpha t, _) ->
            let instantiated = instantiate t alpha argType
            in typeCheckPoly ctx (App (instantiateTerm f alpha) arg)
        _ -> Nothing
```

### 8.2. 类型推断器

#### 8.2.1. 约束生成

**约束生成算法**：

```python
def generate_constraints(ctx, expr, type_var, constraints):
    """生成类型约束"""
    if isinstance(expr, Variable):
        if expr.name in ctx:
            constraints.append((type_var, ctx[expr.name]))
        else:
            raise TypeError(f"Unbound variable: {expr.name}")

    elif isinstance(expr, Abstraction):
        arg_type = fresh_type_var()
        body_type = fresh_type_var()
        constraints.append((type_var, FunType(arg_type, body_type)))
        generate_constraints(
            {**ctx, expr.var.name: arg_type},
            expr.body,
            body_type,
            constraints
        )

    elif isinstance(expr, Application):
        func_type = fresh_type_var()
        arg_type = fresh_type_var()
        result_type = fresh_type_var()
        constraints.append((type_var, result_type))
        constraints.append((func_type, FunType(arg_type, result_type)))
        generate_constraints(ctx, expr.func, func_type, constraints)
        generate_constraints(ctx, expr.arg, arg_type, constraints)
```

#### 8.2.2. 约束求解

**约束求解**：

```python
def solve_constraints(constraints):
    """求解类型约束"""
    substitution = {}

    while constraints:
        constraint = constraints.pop(0)
        t1, t2 = constraint

        if t1 == t2:
            continue

        if isinstance(t1, TypeVar):
            if occurs_check(t1, t2):
                raise UnificationError("Occurs check failed")
            substitution[t1.name] = t2
            constraints = [apply_subst(c, substitution) for c in constraints]

        elif isinstance(t2, TypeVar):
            if occurs_check(t2, t1):
                raise UnificationError("Occurs check failed")
            substitution[t2.name] = t1
            constraints = [apply_subst(c, substitution) for c in constraints]

        elif isinstance(t1, FunType) and isinstance(t2, FunType):
            constraints.append((t1.domain, t2.domain))
            constraints.append((t1.codomain, t2.codomain))

        else:
            raise UnificationError(f"Cannot unify {t1} and {t2}")

    return substitution
```

---

## 9. 高级特性

### 9.1. 类型类

#### 9.1.1. 类型类定义

**类型类（Type Class）**：定义类型的操作集合。

**Haskell类型类**：

```haskell
-- Eq类型类
class Eq a where
    (==) :: a -> a -> Bool
    (/=) :: a -> a -> Bool
    x /= y = not (x == y)

-- Ord类型类
class Eq a => Ord a where
    compare :: a -> a -> Ordering
    (<) :: a -> a -> Bool
    (<=) :: a -> a -> Bool
    (>) :: a -> a -> Bool
    (>=) :: a -> a -> Bool
```

#### 9.1.2. 类型类实例

**类型类实例**：

```haskell
-- Int的Eq实例
instance Eq Int where
    (==) = primEqInt

-- 列表的Eq实例
instance Eq a => Eq [a] where
    [] == [] = True
    (x:xs) == (y:ys) = x == y && xs == ys
    _ == _ = False

-- 元组的Eq实例
instance (Eq a, Eq b) => Eq (a, b) where
    (x1, y1) == (x2, y2) = x1 == x2 && y1 == y2
```

### 9.2. 高阶类型

#### 9.2.1. 类型构造子

**类型构造子（Type Constructor）**：接受类型参数，返回新类型。

**示例**：

```haskell
-- Maybe是类型构造子
data Maybe a = Nothing | Just a

-- List是类型构造子
data [] a = [] | a : [a]

-- Either是类型构造子
data Either a b = Left a | Right b
```

#### 9.2.2. 函子与单子

**函子（Functor）**：

```haskell
class Functor f where
    fmap :: (a -> b) -> f a -> f b

-- Maybe的Functor实例
instance Functor Maybe where
    fmap f Nothing = Nothing
    fmap f (Just x) = Just (f x)

-- List的Functor实例
instance Functor [] where
    fmap = map
```

**单子（Monad）**：

```haskell
class Functor m => Monad m where
    return :: a -> m a
    (>>=) :: m a -> (a -> m b) -> m b

-- Maybe的Monad实例
instance Monad Maybe where
    return = Just
    Nothing >>= f = Nothing
    Just x >>= f = f x

-- List的Monad实例
instance Monad [] where
    return x = [x]
    xs >>= f = concatMap f xs
```

---

## 10. 应用领域

### 10.1. 函数式编程

#### 10.1.1. Haskell类型系统

**Haskell类型系统特点**：

1. **强类型**：类型检查在编译时进行
2. **静态类型**：类型在编译时确定
3. **类型推断**：自动推导类型
4. **多态**：支持参数多态

**示例**：

```haskell
-- 多态函数
map :: (a -> b) -> [a] -> [b]
map f [] = []
map f (x:xs) = f x : map f xs

-- 类型类约束
sort :: Ord a => [a] -> [a]
sort [] = []
sort (x:xs) = sort [y | y <- xs, y <= x] ++ [x] ++ sort [y | y <- xs, y > x]
```

#### 10.1.2. OCaml类型系统

**OCaml类型系统特点**：

1. **结构类型**：基于结构而非名称
2. **多态变体**：灵活的变体类型
3. **模块系统**：强大的模块化支持

**示例**：

```ocaml
(* OCaml多态函数 *)
let rec map f = function
  | [] -> []
  | x :: xs -> f x :: map f xs

(* 类型推断 *)
let id x = x  (* 'a -> 'a *)

(* 多态变体 *)
type 'a tree =
  | Leaf of 'a
  | Node of 'a tree * 'a tree
```

### 10.2. 系统编程

#### 10.2.1. Rust类型系统

**Rust类型系统特点**：

1. **所有权系统**：内存安全保证
2. **借用检查**：防止数据竞争
3. **生命周期**：管理引用有效性
4. **零成本抽象**：编译时检查，运行时无开销

**示例**：

```rust
// Rust所有权
fn take_ownership(s: String) {
    println!("{}", s);
}  // s在这里被释放

// 借用
fn borrow(s: &String) {
    println!("{}", s);
}  // s不会被释放

// 可变借用
fn mutate(s: &mut String) {
    s.push_str(" world");
}

// 生命周期
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

#### 10.2.2. 所有权与借用

**所有权规则**：

1. 每个值都有一个所有者
2. 同一时间只能有一个所有者
3. 所有者离开作用域时，值被释放

**借用规则**：

1. 可以有多个不可变借用
2. 只能有一个可变借用
3. 借用和可变借用不能同时存在

**示例**：

```rust
// 所有权转移
let s1 = String::from("hello");
let s2 = s1;  // s1的所有权转移到s2
// println!("{}", s1);  // 错误：s1不再有效

// 借用
let s = String::from("hello");
let r1 = &s;
let r2 = &s;  // 可以有多个不可变借用
// let r3 = &mut s;  // 错误：不能同时有可变借用

// 可变借用
let mut s = String::from("hello");
let r1 = &mut s;
// let r2 = &mut s;  // 错误：只能有一个可变借用
```

---

## 11. 研究前沿

### 11.1. 线性类型系统

**线性类型系统**：确保每个值恰好被使用一次。

**应用**：

- **资源管理**：文件句柄、网络连接
- **并发编程**：防止数据竞争
- **内存安全**：防止内存泄漏

**示例**：

```rust
// Rust中的线性类型（通过所有权）
struct File {
    handle: i32,
}

impl File {
    fn close(self) {
        // 消费所有权，关闭文件
        close_file(self.handle);
    }
}

// 文件只能关闭一次
let file = File { handle: 1 };
file.close();
// file.close();  // 错误：file已经被消费
```

### 11.2. 会话类型

**会话类型（Session Types）**：类型安全的通信协议。

**应用**：

- **并发通信**：进程间通信
- **协议验证**：确保通信协议正确
- **死锁检测**：编译时检测死锁

**示例**：

```rust
// 会话类型示例（伪代码）
trait Session {
    type Send<T>;
    type Recv<T>;
    type End;
}

// 双向通信协议
type Protocol = Send<String, Recv<Int, End>>;
```

### 11.3. 同伦类型论

**同伦类型论（Homotopy Type Theory）**：将类型视为空间，将相等视为路径。

**核心概念**：

- **类型作为空间**：类型是拓扑空间
- **相等作为路径**：相等性是路径
- **单价性公理**：等价性和相等性等价

---

## 12. 形式化定义与证明

### 12.1. 类型系统形式化

**类型系统形式化定义**：

设类型系统 $\mathcal{T} = (E, T, \vdash, \to)$，其中：

- $E$：表达式集合
- $T$：类型集合
- $\vdash \subseteq \text{Context} \times E \times T$：类型判定关系
- $\to \subseteq E \times E$：归约关系

### 12.2. 类型安全性形式化

**类型安全性定理**：

$$\forall \Gamma, e, \tau: \Gamma \vdash e:\tau \Rightarrow (\text{Progress}(e) \land \text{Preservation}(e))$$

其中：

- $\text{Progress}(e)$：$e$ 是值或可以归约
- $\text{Preservation}(e)$：归约保持类型

---

## 13. 多表征

基础类型理论支持多种表征方式，包括：

- **符号表征**：类型、类型构造器、类型等式等
- **图结构**：类型依赖图、类型推导树
- **向量/张量**：类型嵌入、特征向量
- **自然语言**：定义、注释、描述
- **图像/可视化**：类型结构图、推导流程图等

这些表征可互映，提升类型理论表达力。

---

## 14. 总结与展望

### 14.1. 总结

基础类型理论为编程语言提供理论基础，通过形式化类型系统确保程序安全性和正确性，推动编程语言设计发展。

**核心贡献**：

1. **类型安全**：防止类型错误
2. **程序验证**：支持形式化验证
3. **语言设计**：指导编程语言设计
4. **理论统一**：统一逻辑和计算

### 14.2. 未来展望

1. **机器学习类型**：可微分类型、概率类型
2. **量子类型**：量子程序类型系统
3. **分布式类型**：时空类型、一致性类型
4. **同伦类型**：更强大的类型理论

---

## 15. 参考文献

1. Pierce, B. C. (2002). Types and Programming Languages. MIT Press.
2. Girard, J. Y., Lafont, Y., & Taylor, P. (1989). Proofs and Types. Cambridge University Press.
3. Martin-Löf, P. (1984). Intuitionistic Type Theory. Bibliopolis.
4. Reynolds, J. C. (1974). Towards a Theory of Type Structure. Programming Symposium.
5. Hindley, J. R. (1969). The Principal Type-Scheme of an Object in Combinatory Logic. Transactions of the American Mathematical Society.
6. Milner, R. (1978). A Theory of Type Polymorphism in Programming. Journal of Computer and System Sciences.
7. Voevodsky, V. (2006). A Very Short Note on the Homotopy λ-Calculus. Unpublished note.

---

[返回类型理论导航](README.md)
