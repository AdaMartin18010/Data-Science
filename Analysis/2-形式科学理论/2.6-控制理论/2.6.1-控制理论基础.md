# 2.6.1 æ§åˆ¶ç†è®ºåŸºç¡€

## ğŸ“‘ ç›®å½•

- [2.6.1 æ§åˆ¶ç†è®ºåŸºç¡€](#261-æ§åˆ¶ç†è®ºåŸºç¡€)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ‘˜è¦](#1-æ‘˜è¦)
  - [2. æ§åˆ¶è®ºæ¦‚è¿°](#2-æ§åˆ¶è®ºæ¦‚è¿°)
    - [2.1. æ§åˆ¶è®ºçš„å®šä¹‰](#21-æ§åˆ¶è®ºçš„å®šä¹‰)
    - [2.2. æ§åˆ¶ç³»ç»Ÿçš„åŸºæœ¬ç»„æˆ](#22-æ§åˆ¶ç³»ç»Ÿçš„åŸºæœ¬ç»„æˆ)
    - [2.3. æ§åˆ¶ç³»ç»Ÿçš„åˆ†ç±»](#23-æ§åˆ¶ç³»ç»Ÿçš„åˆ†ç±»)
  - [3. æ§åˆ¶è®ºä¸­çš„å½¢å¼æ¨¡å‹](#3-æ§åˆ¶è®ºä¸­çš„å½¢å¼æ¨¡å‹)
    - [3.1. çŠ¶æ€ç©ºé—´æ¨¡å‹](#31-çŠ¶æ€ç©ºé—´æ¨¡å‹)
      - [3.1.1. è¿ç»­æ—¶é—´ç³»ç»Ÿ](#311-è¿ç»­æ—¶é—´ç³»ç»Ÿ)
      - [3.1.2. ç¦»æ•£æ—¶é—´ç³»ç»Ÿ](#312-ç¦»æ•£æ—¶é—´ç³»ç»Ÿ)
      - [3.1.3. å¯æ§æ€§ä¸å¯è§‚æ€§](#313-å¯æ§æ€§ä¸å¯è§‚æ€§)
    - [3.2. äº‹ä»¶é©±åŠ¨ä¸æ··åˆæ¨¡å‹](#32-äº‹ä»¶é©±åŠ¨ä¸æ··åˆæ¨¡å‹)
      - [3.2.1. ç¦»æ•£äº‹ä»¶ç³»ç»Ÿ](#321-ç¦»æ•£äº‹ä»¶ç³»ç»Ÿ)
      - [3.2.2. æ··åˆè‡ªåŠ¨æœº](#322-æ··åˆè‡ªåŠ¨æœº)
      - [3.2.3. éšæœºæ¨¡å‹](#323-éšæœºæ¨¡å‹)
    - [3.3. é€»è¾‘ä¸è®¡ç®—æ¨¡å‹](#33-é€»è¾‘ä¸è®¡ç®—æ¨¡å‹)
      - [3.3.1. æ—¶åºé€»è¾‘](#331-æ—¶åºé€»è¾‘)
      - [3.3.2. è¿›ç¨‹ä»£æ•°](#332-è¿›ç¨‹ä»£æ•°)
      - [3.3.3. å½¢å¼è¯­è¨€](#333-å½¢å¼è¯­è¨€)
  - [4. æ§åˆ¶ç³»ç»Ÿè®¾è®¡ä¸åˆ†æ](#4-æ§åˆ¶ç³»ç»Ÿè®¾è®¡ä¸åˆ†æ)
    - [4.1. åŸºäºæ¨¡å‹çš„è®¾è®¡](#41-åŸºäºæ¨¡å‹çš„è®¾è®¡)
      - [4.1.1. çŠ¶æ€åé¦ˆæ§åˆ¶](#411-çŠ¶æ€åé¦ˆæ§åˆ¶)
      - [4.1.2. è§‚æµ‹å™¨è®¾è®¡](#412-è§‚æµ‹å™¨è®¾è®¡)
      - [4.1.3. ç›‘ç£æ§åˆ¶ç†è®º](#413-ç›‘ç£æ§åˆ¶ç†è®º)
      - [4.1.4. é²æ£’æ€§åˆ†æ](#414-é²æ£’æ€§åˆ†æ)
    - [4.2. æœ€ä¼˜ä¸é¢„æµ‹æ§åˆ¶](#42-æœ€ä¼˜ä¸é¢„æµ‹æ§åˆ¶)
      - [4.2.1. æœ€ä¼˜æ§åˆ¶é—®é¢˜](#421-æœ€ä¼˜æ§åˆ¶é—®é¢˜)
      - [4.2.2. Pontryaginæœ€å¤§åŸç†](#422-pontryaginæœ€å¤§åŸç†)
      - [4.2.3. åŠ¨æ€è§„åˆ’](#423-åŠ¨æ€è§„åˆ’)
      - [4.2.4. é¢„æµ‹æ§åˆ¶](#424-é¢„æµ‹æ§åˆ¶)
    - [4.3. åˆ†å¸ƒå¼ä¸å¹¶è¡Œç³»ç»Ÿ](#43-åˆ†å¸ƒå¼ä¸å¹¶è¡Œç³»ç»Ÿ)
      - [4.3.1. å¹¶å‘æ€§ç†è®º](#431-å¹¶å‘æ€§ç†è®º)
      - [4.3.2. åˆ†å¸ƒå¼ç®—æ³•éªŒè¯](#432-åˆ†å¸ƒå¼ç®—æ³•éªŒè¯)
      - [4.3.3. ä¸€è‡´æ€§æ¨¡å‹](#433-ä¸€è‡´æ€§æ¨¡å‹)
  - [5. é«˜çº§ä¸è·¨å­¦ç§‘æ¨¡å‹](#5-é«˜çº§ä¸è·¨å­¦ç§‘æ¨¡å‹)
    - [5.1. ä¸ç¡®å®šæ€§ä¸è¿‘ä¼¼æ¨¡å‹](#51-ä¸ç¡®å®šæ€§ä¸è¿‘ä¼¼æ¨¡å‹)
      - [5.1.1. éç¡®å®šæ€§è‡ªåŠ¨æœº](#511-éç¡®å®šæ€§è‡ªåŠ¨æœº)
      - [5.1.2. åŒºé—´æ¨¡å‹](#512-åŒºé—´æ¨¡å‹)
      - [5.1.3. æ¨¡ç³Šæ¨¡å‹](#513-æ¨¡ç³Šæ¨¡å‹)
    - [5.2. è®¤çŸ¥ä¸è¯­ä¹‰æ¨¡å‹](#52-è®¤çŸ¥ä¸è¯­ä¹‰æ¨¡å‹)
      - [5.2.1. ç¬¦å·è®¤çŸ¥æ¶æ„](#521-ç¬¦å·è®¤çŸ¥æ¶æ„)
      - [5.2.2. ç¥ç»ç½‘ç»œæ¨¡å‹](#522-ç¥ç»ç½‘ç»œæ¨¡å‹)
    - [5.3. ä¿¡æ¯è®ºä¸æ§åˆ¶](#53-ä¿¡æ¯è®ºä¸æ§åˆ¶)
      - [5.3.1. ä¿¡æ¯è®ºåŸºç¡€](#531-ä¿¡æ¯è®ºåŸºç¡€)
      - [5.3.2. ä¿¡æ¯ä¸æ§åˆ¶çš„å…³ç³»](#532-ä¿¡æ¯ä¸æ§åˆ¶çš„å…³ç³»)
  - [6. å½¢å¼æ¨¡å‹çš„éªŒè¯ä¸æ¼”åŒ–](#6-å½¢å¼æ¨¡å‹çš„éªŒè¯ä¸æ¼”åŒ–)
    - [6.1. æ¨¡å‹æ£€éªŒä¸å®šç†è¯æ˜](#61-æ¨¡å‹æ£€éªŒä¸å®šç†è¯æ˜)
      - [6.1.1. æ¨¡å‹æ£€éªŒæ–¹æ³•](#611-æ¨¡å‹æ£€éªŒæ–¹æ³•)
      - [6.1.2. å®šç†è¯æ˜å·¥å…·](#612-å®šç†è¯æ˜å·¥å…·)
    - [6.2. ä»¿çœŸä¸æµ‹è¯•](#62-ä»¿çœŸä¸æµ‹è¯•)
      - [6.2.1. ä»¿çœŸæ–¹æ³•](#621-ä»¿çœŸæ–¹æ³•)
      - [6.2.2. æµ‹è¯•ç­–ç•¥](#622-æµ‹è¯•ç­–ç•¥)
    - [6.3. æ¨¡å‹æ¼”åŒ–ä¸è‡ªé€‚åº”](#63-æ¨¡å‹æ¼”åŒ–ä¸è‡ªé€‚åº”)
      - [6.3.1. è‡ªé€‚åº”æ§åˆ¶](#631-è‡ªé€‚åº”æ§åˆ¶)
      - [6.3.2. åœ¨çº¿å­¦ä¹ ](#632-åœ¨çº¿å­¦ä¹ )
  - [7. å®é™…åº”ç”¨æ¡ˆä¾‹](#7-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [7.1. å·¥ä¸šæ§åˆ¶ç³»ç»Ÿ](#71-å·¥ä¸šæ§åˆ¶ç³»ç»Ÿ)
    - [7.2. æœºå™¨äººæ§åˆ¶ç³»ç»Ÿ](#72-æœºå™¨äººæ§åˆ¶ç³»ç»Ÿ)
    - [7.3. ç½‘ç»œæ§åˆ¶ç³»ç»Ÿ](#73-ç½‘ç»œæ§åˆ¶ç³»ç»Ÿ)
  - [8. å½¢å¼åŒ–å®šä¹‰ä¸è¯æ˜](#8-å½¢å¼åŒ–å®šä¹‰ä¸è¯æ˜)
    - [8.1. æ§åˆ¶ç³»ç»Ÿå½¢å¼åŒ–](#81-æ§åˆ¶ç³»ç»Ÿå½¢å¼åŒ–)
    - [8.2. ç¨³å®šæ€§ç†è®ºå½¢å¼åŒ–](#82-ç¨³å®šæ€§ç†è®ºå½¢å¼åŒ–)
  - [9. å¤šè¡¨å¾](#9-å¤šè¡¨å¾)
  - [10. æ€»ç»“ä¸å±•æœ›](#10-æ€»ç»“ä¸å±•æœ›)
    - [10.1. æ€»ç»“](#101-æ€»ç»“)
    - [10.2. æœªæ¥å±•æœ›](#102-æœªæ¥å±•æœ›)
  - [11. å‚è€ƒæ–‡çŒ®](#11-å‚è€ƒæ–‡çŒ®)

---

## 1. æ‘˜è¦

æ§åˆ¶ç†è®ºæ˜¯ç ”ç©¶åŠ¨æ€ç³»ç»Ÿè¡Œä¸ºè°ƒèŠ‚å’Œä¼˜åŒ–çš„æ•°å­¦ç†è®ºï¼Œå¹¿æ³›åº”ç”¨äºå·¥ç¨‹ã€ç”Ÿç‰©å­¦ã€ç»æµå­¦å’Œç¤¾ä¼šç§‘å­¦ç­‰é¢†åŸŸã€‚æœ¬æ–‡æ¡£ç³»ç»Ÿæ¢³ç†æ§åˆ¶ç†è®ºåŸºç¡€ï¼Œæ¶µç›–çŠ¶æ€ç©ºé—´æ¨¡å‹ã€æ§åˆ¶ç³»ç»Ÿè®¾è®¡ä¸åˆ†æã€æœ€ä¼˜æ§åˆ¶ã€é²æ£’æ§åˆ¶ã€è‡ªé€‚åº”æ§åˆ¶ç­‰æ ¸å¿ƒå†…å®¹ï¼Œä¸ºæ§åˆ¶ç³»ç»Ÿè®¾è®¡å’Œå®ç°æä¾›ç†è®ºåŸºç¡€ã€‚

---

## 2. æ§åˆ¶è®ºæ¦‚è¿°

### 2.1. æ§åˆ¶è®ºçš„å®šä¹‰

**æ§åˆ¶è®ºï¼ˆCyberneticsï¼‰**æ˜¯ç ”ç©¶ç³»ç»Ÿæ§åˆ¶å’Œé€šä¿¡çš„ç§‘å­¦ï¼Œç”±Norbert Wieneråœ¨1948å¹´æå‡ºã€‚

**æ§åˆ¶è®ºçš„æ ¸å¿ƒæ¦‚å¿µ**ï¼š

1. **åé¦ˆ**ï¼šç³»ç»Ÿè¾“å‡ºå¯¹è¾“å…¥çš„å½±å“
2. **ä¿¡æ¯**ï¼šç³»ç»ŸçŠ¶æ€å’Œè¡Œä¸ºçš„è¡¨ç¤º
3. **æ§åˆ¶**ï¼šé€šè¿‡è¾“å…¥è°ƒèŠ‚ç³»ç»Ÿè¡Œä¸º
4. **ç¨³å®šæ€§**ï¼šç³»ç»Ÿåœ¨æ‰°åŠ¨ä¸‹çš„è¡Œä¸ºç‰¹æ€§

**æ§åˆ¶è®ºçš„åº”ç”¨é¢†åŸŸ**ï¼š

- **å·¥ç¨‹æ§åˆ¶**ï¼šè‡ªåŠ¨æ§åˆ¶ç³»ç»Ÿã€æœºå™¨äººæ§åˆ¶
- **ç”Ÿç‰©æ§åˆ¶**ï¼šç”Ÿç‰©ç³»ç»Ÿè°ƒèŠ‚ã€ç¥ç»æ§åˆ¶
- **ç»æµæ§åˆ¶**ï¼šç»æµç³»ç»Ÿè°ƒèŠ‚ã€å¸‚åœºæ§åˆ¶
- **ç¤¾ä¼šæ§åˆ¶**ï¼šç¤¾ä¼šç³»ç»Ÿç®¡ç†ã€ç»„ç»‡æ§åˆ¶

### 2.2. æ§åˆ¶ç³»ç»Ÿçš„åŸºæœ¬ç»„æˆ

**æ§åˆ¶ç³»ç»Ÿçš„åŸºæœ¬ç»„æˆ**ï¼š

```mermaid
flowchart LR
    R[å‚è€ƒè¾“å…¥] --> C[æ§åˆ¶å™¨] --> P[è¢«æ§å¯¹è±¡] --> Y[è¾“å‡º]
    Y --> F[åé¦ˆ]
    F --> C
    D[æ‰°åŠ¨] --> P
```

**ç»„æˆéƒ¨åˆ†**ï¼š

1. **è¢«æ§å¯¹è±¡ï¼ˆPlantï¼‰**ï¼šéœ€è¦æ§åˆ¶çš„ç³»ç»Ÿ
2. **æ§åˆ¶å™¨ï¼ˆControllerï¼‰**ï¼šäº§ç”Ÿæ§åˆ¶ä¿¡å·çš„è£…ç½®
3. **ä¼ æ„Ÿå™¨ï¼ˆSensorï¼‰**ï¼šæµ‹é‡ç³»ç»Ÿè¾“å‡ºçš„è£…ç½®
4. **æ‰§è¡Œå™¨ï¼ˆActuatorï¼‰**ï¼šæ‰§è¡Œæ§åˆ¶ä¿¡å·çš„è£…ç½®
5. **åé¦ˆå›è·¯ï¼ˆFeedback Loopï¼‰**ï¼šå°†è¾“å‡ºåé¦ˆåˆ°è¾“å…¥

### 2.3. æ§åˆ¶ç³»ç»Ÿçš„åˆ†ç±»

**æŒ‰æ§åˆ¶æ–¹å¼åˆ†ç±»**ï¼š

1. **å¼€ç¯æ§åˆ¶**ï¼šæ§åˆ¶ä¿¡å·ä¸ä¾èµ–è¾“å‡º
2. **é—­ç¯æ§åˆ¶**ï¼šæ§åˆ¶ä¿¡å·ä¾èµ–è¾“å‡ºåé¦ˆ
3. **å‰é¦ˆæ§åˆ¶**ï¼šæ§åˆ¶ä¿¡å·ä¾èµ–æ‰°åŠ¨é¢„æµ‹

**æŒ‰ç³»ç»Ÿç‰¹æ€§åˆ†ç±»**ï¼š

1. **çº¿æ€§ç³»ç»Ÿ**ï¼šæ»¡è¶³å åŠ åŸç†
2. **éçº¿æ€§ç³»ç»Ÿ**ï¼šä¸æ»¡è¶³å åŠ åŸç†
3. **æ—¶å˜ç³»ç»Ÿ**ï¼šå‚æ•°éšæ—¶é—´å˜åŒ–
4. **æ—¶ä¸å˜ç³»ç»Ÿ**ï¼šå‚æ•°ä¸éšæ—¶é—´å˜åŒ–

**æŒ‰æ—¶é—´ç‰¹æ€§åˆ†ç±»**ï¼š

1. **è¿ç»­æ—¶é—´ç³»ç»Ÿ**ï¼šçŠ¶æ€è¿ç»­å˜åŒ–
2. **ç¦»æ•£æ—¶é—´ç³»ç»Ÿ**ï¼šçŠ¶æ€ç¦»æ•£å˜åŒ–
3. **æ··åˆç³»ç»Ÿ**ï¼šè¿ç»­å’Œç¦»æ•£æ··åˆ

---

## 3. æ§åˆ¶è®ºä¸­çš„å½¢å¼æ¨¡å‹

### 3.1. çŠ¶æ€ç©ºé—´æ¨¡å‹

#### 3.1.1. è¿ç»­æ—¶é—´ç³»ç»Ÿ

**è¿ç»­æ—¶é—´çº¿æ€§ç³»ç»Ÿ**ï¼š

$$\dot{x}(t) = Ax(t) + Bu(t)$$

$$y(t) = Cx(t) + Du(t)$$

å…¶ä¸­ï¼š

- $x(t) \in \mathbb{R}^n$ï¼šçŠ¶æ€å‘é‡
- $u(t) \in \mathbb{R}^m$ï¼šè¾“å…¥å‘é‡
- $y(t) \in \mathbb{R}^p$ï¼šè¾“å‡ºå‘é‡
- $A \in \mathbb{R}^{n \times n}$ï¼šçŠ¶æ€çŸ©é˜µ
- $B \in \mathbb{R}^{n \times m}$ï¼šè¾“å…¥çŸ©é˜µ
- $C \in \mathbb{R}^{p \times n}$ï¼šè¾“å‡ºçŸ©é˜µ
- $D \in \mathbb{R}^{p \times m}$ï¼šç›´é€šçŸ©é˜µ

**ç³»ç»Ÿè§£**ï¼š

$$x(t) = e^{At}x(0) + \int_0^t e^{A(t-\tau)}Bu(\tau)d\tau$$

**ç¤ºä¾‹**ï¼šäºŒé˜¶ç³»ç»Ÿ

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint

# äºŒé˜¶ç³»ç»Ÿï¼šè´¨é‡-å¼¹ç°§-é˜»å°¼å™¨
# m*x'' + c*x' + k*x = u
# çŠ¶æ€ç©ºé—´è¡¨ç¤ºï¼šx1 = x, x2 = x'
# x1' = x2
# x2' = -k/m*x1 - c/m*x2 + 1/m*u

m, c, k = 1.0, 0.5, 2.0  # è´¨é‡ã€é˜»å°¼ã€åˆšåº¦

A = np.array([[0, 1],
              [-k/m, -c/m]])
B = np.array([[0],
              [1/m]])
C = np.array([[1, 0]])
D = np.array([[0]])

def system_dynamics(x, t, u):
    """ç³»ç»ŸåŠ¨æ€æ–¹ç¨‹"""
    return A @ x + B @ u

# ä»¿çœŸ
t = np.linspace(0, 10, 1000)
x0 = [0, 0]  # åˆå§‹çŠ¶æ€
u = 1.0  # å•ä½é˜¶è·ƒè¾“å…¥

x = odeint(system_dynamics, x0, t, args=(u,))
y = (C @ x.T).T

plt.plot(t, y)
plt.xlabel('Time (s)')
plt.ylabel('Position')
plt.title('Second-Order System Response')
plt.grid(True)
plt.show()
```

#### 3.1.2. ç¦»æ•£æ—¶é—´ç³»ç»Ÿ

**ç¦»æ•£æ—¶é—´çº¿æ€§ç³»ç»Ÿ**ï¼š

$$x_{k+1} = Ax_k + Bu_k$$

$$y_k = Cx_k + Du_k$$

å…¶ä¸­ $k$ æ˜¯ç¦»æ•£æ—¶é—´ç´¢å¼•ã€‚

**ç³»ç»Ÿè§£**ï¼š

$$x_k = A^k x_0 + \sum_{i=0}^{k-1} A^{k-1-i}Bu_i$$

**ç¤ºä¾‹**ï¼šæ•°å­—æ§åˆ¶ç³»ç»Ÿ

```python
import numpy as np
import matplotlib.pyplot as plt

# ç¦»æ•£æ—¶é—´ç³»ç»Ÿ
A = np.array([[0.9, 0.1],
              [0, 0.8]])
B = np.array([[1],
              [0.5]])
C = np.array([[1, 0]])
D = np.array([[0]])

# åˆå§‹çŠ¶æ€
x0 = np.array([[0],
               [0]])

# ä»¿çœŸ
N = 100
x = np.zeros((2, N+1))
y = np.zeros((1, N+1))
u = np.ones((1, N))  # å•ä½é˜¶è·ƒè¾“å…¥

x[:, 0:1] = x0
for k in range(N):
    x[:, k+1:k+2] = A @ x[:, k:k+1] + B @ u[:, k:k+1]
    y[:, k] = (C @ x[:, k:k+1])[0, 0]

plt.plot(range(N), y[0, :N])
plt.xlabel('Time step')
plt.ylabel('Output')
plt.title('Discrete-Time System Response')
plt.grid(True)
plt.show()
```

#### 3.1.3. å¯æ§æ€§ä¸å¯è§‚æ€§

**å¯æ§æ€§ï¼ˆControllabilityï¼‰**ï¼š

ç³»ç»Ÿ $(A, B)$ æ˜¯å¯æ§çš„ï¼Œå½“ä¸”ä»…å½“å¯æ§æ€§çŸ©é˜µæ»¡ç§©ï¼š

$$\text{rank}[B, AB, A^2B, \ldots, A^{n-1}B] = n$$

**å¯è§‚æ€§ï¼ˆObservabilityï¼‰**ï¼š

ç³»ç»Ÿ $(A, C)$ æ˜¯å¯è§‚çš„ï¼Œå½“ä¸”ä»…å½“å¯è§‚æ€§çŸ©é˜µæ»¡ç§©ï¼š

$$\text{rank}\begin{bmatrix} C \\ CA \\ CA^2 \\ \vdots \\ CA^{n-1} \end{bmatrix} = n$$

**ç¤ºä¾‹**ï¼šå¯æ§æ€§æ£€æŸ¥

```python
import numpy as np
from scipy.linalg import matrix_rank

def is_controllable(A, B):
    """æ£€æŸ¥ç³»ç»Ÿæ˜¯å¦å¯æ§"""
    n = A.shape[0]
    controllability_matrix = B
    for i in range(1, n):
        controllability_matrix = np.hstack([controllability_matrix, A**i @ B])
    return matrix_rank(controllability_matrix) == n

# ç¤ºä¾‹ç³»ç»Ÿ
A = np.array([[0, 1],
              [-2, -3]])
B = np.array([[0],
              [1]])

print(f"ç³»ç»Ÿå¯æ§: {is_controllable(A, B)}")
```

### 3.2. äº‹ä»¶é©±åŠ¨ä¸æ··åˆæ¨¡å‹

#### 3.2.1. ç¦»æ•£äº‹ä»¶ç³»ç»Ÿ

**ç¦»æ•£äº‹ä»¶ç³»ç»Ÿï¼ˆDESï¼‰**æ˜¯çŠ¶æ€åœ¨ç¦»æ•£äº‹ä»¶å‘ç”Ÿæ—¶å‘ç”Ÿè·³å˜çš„ç³»ç»Ÿã€‚

**æœ‰é™çŠ¶æ€æœºï¼ˆFSMï¼‰**ï¼š

$$M = (Q, \Sigma, \delta, q_0, F)$$

å…¶ä¸­ï¼š

- $Q$ï¼šçŠ¶æ€é›†åˆ
- $\Sigma$ï¼šäº‹ä»¶é›†åˆ
- $\delta: Q \times \Sigma \to Q$ï¼šçŠ¶æ€è½¬ç§»å‡½æ•°
- $q_0$ï¼šåˆå§‹çŠ¶æ€
- $F$ï¼šæ¥å—çŠ¶æ€é›†åˆ

**ç¤ºä¾‹**ï¼šç®€å•çŠ¶æ€æœº

```python
from enum import Enum

class State(Enum):
    IDLE = "idle"
    RUNNING = "running"
    STOPPED = "stopped"

class Event(Enum):
    START = "start"
    STOP = "stop"
    RESET = "reset"

class StateMachine:
    def __init__(self):
        self.state = State.IDLE
        self.transitions = {
            (State.IDLE, Event.START): State.RUNNING,
            (State.RUNNING, Event.STOP): State.STOPPED,
            (State.STOPPED, Event.RESET): State.IDLE,
        }

    def transition(self, event):
        """çŠ¶æ€è½¬ç§»"""
        key = (self.state, event)
        if key in self.transitions:
            self.state = self.transitions[key]
            return True
        return False

# ä½¿ç”¨ç¤ºä¾‹
sm = StateMachine()
print(f"åˆå§‹çŠ¶æ€: {sm.state}")
sm.transition(Event.START)
print(f"å¯åŠ¨å: {sm.state}")
sm.transition(Event.STOP)
print(f"åœæ­¢å: {sm.state}")
```

#### 3.2.2. æ··åˆè‡ªåŠ¨æœº

**æ··åˆè‡ªåŠ¨æœºï¼ˆHybrid Automatonï¼‰**ï¼š

$$H = (Q, X, f, Init, Dom, E, G, R)$$

å…¶ä¸­ï¼š

- $Q$ï¼šç¦»æ•£çŠ¶æ€é›†åˆ
- $X$ï¼šè¿ç»­çŠ¶æ€ç©ºé—´
- $f: Q \times X \to \dot{X}$ï¼šè¿ç»­åŠ¨æ€
- $Init \subseteq Q \times X$ï¼šåˆå§‹çŠ¶æ€é›†åˆ
- $Dom: Q \to 2^X$ï¼šä¸å˜åŸŸ
- $E \subseteq Q \times Q$ï¼šè¾¹é›†åˆ
- $G: E \to 2^X$ï¼šå®ˆå«æ¡ä»¶
- $R: E \times X \to 2^X$ï¼šé‡ç½®æ˜ å°„

**ç¤ºä¾‹**ï¼šæ¸©åº¦æ§åˆ¶ç³»ç»Ÿ

```python
class HybridAutomaton:
    def __init__(self):
        self.q = "OFF"  # ç¦»æ•£çŠ¶æ€ï¼šOFF, ON
        self.x = 20.0   # è¿ç»­çŠ¶æ€ï¼šæ¸©åº¦
        self.target = 25.0
        self.hysteresis = 1.0

    def continuous_dynamics(self, dt):
        """è¿ç»­åŠ¨æ€"""
        if self.q == "ON":
            # åŠ çƒ­ï¼šæ¸©åº¦ä¸Šå‡
            self.x += 0.5 * dt
        else:
            # å†·å´ï¼šæ¸©åº¦ä¸‹é™
            self.x -= 0.2 * dt

    def check_guards(self):
        """æ£€æŸ¥å®ˆå«æ¡ä»¶"""
        if self.q == "OFF" and self.x < self.target - self.hysteresis:
            self.q = "ON"
        elif self.q == "ON" and self.x > self.target + self.hysteresis:
            self.q = "OFF"

    def simulate(self, T, dt):
        """ä»¿çœŸ"""
        times = []
        temps = []
        states = []

        for t in np.arange(0, T, dt):
            self.continuous_dynamics(dt)
            self.check_guards()
            times.append(t)
            temps.append(self.x)
            states.append(self.q)

        return times, temps, states
```

#### 3.2.3. éšæœºæ¨¡å‹

**é©¬å°”å¯å¤«é“¾ï¼ˆMarkov Chainï¼‰**ï¼š

$$P(X_{k+1} = j | X_k = i, X_{k-1}, \ldots, X_0) = P(X_{k+1} = j | X_k = i)$$

**è½¬ç§»æ¦‚ç‡çŸ©é˜µ**ï¼š

$$P = [p_{ij}]$$

å…¶ä¸­ $p_{ij} = P(X_{k+1} = j | X_k = i)$ã€‚

**ç¤ºä¾‹**ï¼šç®€å•é©¬å°”å¯å¤«é“¾

```python
import numpy as np

class MarkovChain:
    def __init__(self, transition_matrix, initial_state):
        self.P = transition_matrix
        self.state = initial_state
        self.n_states = len(transition_matrix)

    def step(self):
        """ä¸€æ­¥è½¬ç§»"""
        self.state = np.random.choice(
            self.n_states,
            p=self.P[self.state]
        )
        return self.state

    def simulate(self, n_steps):
        """ä»¿çœŸ"""
        states = [self.state]
        for _ in range(n_steps):
            states.append(self.step())
        return states

# ç¤ºä¾‹ï¼šå¤©æ°”æ¨¡å‹ï¼ˆæ™´ã€é›¨ã€é˜´ï¼‰
P = np.array([
    [0.7, 0.2, 0.1],  # ä»æ™´è½¬ç§»
    [0.3, 0.4, 0.3],  # ä»é›¨è½¬ç§»
    [0.2, 0.3, 0.5]   # ä»é˜´è½¬ç§»
])

mc = MarkovChain(P, initial_state=0)
states = mc.simulate(100)
print(f"çŠ¶æ€åºåˆ—: {states[:10]}")
```

### 3.3. é€»è¾‘ä¸è®¡ç®—æ¨¡å‹

#### 3.3.1. æ—¶åºé€»è¾‘

**çº¿æ€§æ—¶æ€é€»è¾‘ï¼ˆLTLï¼‰**ï¼š

- $\Box p$ï¼šæ€»æ˜¯ $p$ï¼ˆGloballyï¼‰
- $\Diamond p$ï¼šæœ€ç»ˆ $p$ï¼ˆEventuallyï¼‰
- $p \mathcal{U} q$ï¼š$p$ ç›´åˆ° $q$ï¼ˆUntilï¼‰
- $\bigcirc p$ï¼šä¸‹ä¸€ä¸ª $p$ï¼ˆNextï¼‰

**ç¤ºä¾‹**ï¼šLTLå…¬å¼

$$\Box(\text{request} \to \Diamond \text{response})$$

è¡¨ç¤ºï¼šæ€»æ˜¯ï¼Œå¦‚æœè¯·æ±‚å‘ç”Ÿï¼Œåˆ™æœ€ç»ˆä¼šæœ‰å“åº”ã€‚

**è®¡ç®—æ ‘é€»è¾‘ï¼ˆCTLï¼‰**ï¼š

- $EX p$ï¼šå­˜åœ¨è·¯å¾„ï¼Œä¸‹ä¸€æ­¥ $p$
- $AX p$ï¼šæ‰€æœ‰è·¯å¾„ï¼Œä¸‹ä¸€æ­¥ $p$
- $EF p$ï¼šå­˜åœ¨è·¯å¾„ï¼Œæœ€ç»ˆ $p$
- $AF p$ï¼šæ‰€æœ‰è·¯å¾„ï¼Œæœ€ç»ˆ $p$

#### 3.3.2. è¿›ç¨‹ä»£æ•°

**CCSï¼ˆCalculus of Communicating Systemsï¼‰**ï¼š

- $P ::= 0 | a.P | P + Q | P | Q | P \backslash L | A$
- $a.P$ï¼šæ‰§è¡ŒåŠ¨ä½œ $a$ åå˜æˆ $P$
- $P + Q$ï¼šé€‰æ‹© $P$ æˆ– $Q$
- $P | Q$ï¼š$P$ å’Œ $Q$ å¹¶è¡Œ

**CSPï¼ˆCommunicating Sequential Processesï¼‰**ï¼š

- $P ::= STOP | SKIP | a \to P | P \Box Q | P ||| Q$
- $a \to P$ï¼šæ‰§è¡ŒåŠ¨ä½œ $a$ åå˜æˆ $P$
- $P \Box Q$ï¼šå¤–éƒ¨é€‰æ‹©
- $P ||| Q$ï¼šäº¤é”™å¹¶è¡Œ

#### 3.3.3. å½¢å¼è¯­è¨€

**å½¢å¼è¯­è¨€åˆ†ç±»**ï¼š

1. **æ­£åˆ™è¯­è¨€**ï¼šæœ‰é™è‡ªåŠ¨æœº
2. **ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€**ï¼šä¸‹æ¨è‡ªåŠ¨æœº
3. **ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€**ï¼šçº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœº
4. **é€’å½’å¯æšä¸¾è¯­è¨€**ï¼šå›¾çµæœº

---

## 4. æ§åˆ¶ç³»ç»Ÿè®¾è®¡ä¸åˆ†æ

### 4.1. åŸºäºæ¨¡å‹çš„è®¾è®¡

#### 4.1.1. çŠ¶æ€åé¦ˆæ§åˆ¶

**çŠ¶æ€åé¦ˆæ§åˆ¶å¾‹**ï¼š

$$u = -Kx + r$$

å…¶ä¸­ $K$ æ˜¯åé¦ˆå¢ç›ŠçŸ©é˜µï¼Œ$r$ æ˜¯å‚è€ƒè¾“å…¥ã€‚

**é—­ç¯ç³»ç»Ÿ**ï¼š

$$\dot{x} = (A - BK)x + Br$$

**æç‚¹é…ç½®**ï¼šé€šè¿‡é€‰æ‹© $K$ ä½¿é—­ç¯ç³»ç»Ÿæç‚¹ä½äºæœŸæœ›ä½ç½®ã€‚

**ç¤ºä¾‹**ï¼šæç‚¹é…ç½®

```python
import numpy as np
from scipy.signal import place_poles

# ç³»ç»Ÿ
A = np.array([[0, 1],
              [-2, -3]])
B = np.array([[0],
              [1]])

# æœŸæœ›æç‚¹
desired_poles = [-1, -2]

# æç‚¹é…ç½®
K = place_poles(A, B, desired_poles).gain_matrix
print(f"åé¦ˆå¢ç›ŠçŸ©é˜µ K = \n{K}")

# é—­ç¯ç³»ç»Ÿ
A_cl = A - B @ K
eigenvalues = np.linalg.eigvals(A_cl)
print(f"é—­ç¯æç‚¹: {eigenvalues}")
```

#### 4.1.2. è§‚æµ‹å™¨è®¾è®¡

**Luenbergerè§‚æµ‹å™¨**ï¼š

$$\hat{\dot{x}} = A\hat{x} + Bu + L(y - C\hat{x})$$

å…¶ä¸­ $L$ æ˜¯è§‚æµ‹å™¨å¢ç›ŠçŸ©é˜µã€‚

**è§‚æµ‹å™¨è¯¯å·®åŠ¨æ€**ï¼š

$$\dot{e} = (A - LC)e$$

å…¶ä¸­ $e = x - \hat{x}$ æ˜¯ä¼°è®¡è¯¯å·®ã€‚

**ç¤ºä¾‹**ï¼šè§‚æµ‹å™¨è®¾è®¡

```python
import numpy as np
from scipy.signal import place_poles

# ç³»ç»Ÿ
A = np.array([[0, 1],
              [-2, -3]])
C = np.array([[1, 0]])

# æœŸæœ›è§‚æµ‹å™¨æç‚¹ï¼ˆé€šå¸¸æ¯”æ§åˆ¶å™¨æç‚¹å¿«3-5å€ï¼‰
desired_poles = [-5, -6]

# è§‚æµ‹å™¨å¢ç›Šè®¾è®¡
L = place_poles(A.T, C.T, desired_poles).gain_matrix.T
print(f"è§‚æµ‹å™¨å¢ç›ŠçŸ©é˜µ L = \n{L}")

# è§‚æµ‹å™¨è¯¯å·®åŠ¨æ€
A_obs = A - L @ C
eigenvalues = np.linalg.eigvals(A_obs)
print(f"è§‚æµ‹å™¨è¯¯å·®æç‚¹: {eigenvalues}")
```

#### 4.1.3. ç›‘ç£æ§åˆ¶ç†è®º

**ç›‘ç£æ§åˆ¶é—®é¢˜**ï¼š

ç»™å®šç³»ç»Ÿ $G$ å’Œè§„èŒƒ $K$ï¼Œè®¾è®¡ç›‘ç£å™¨ $S$ ä½¿å¾—ï¼š

$$L(S/G) \subseteq K \subseteq L(G)$$

å…¶ä¸­ $L(G)$ æ˜¯ç³»ç»Ÿ $G$ çš„è¯­è¨€ï¼Œ$L(S/G)$ æ˜¯å—æ§ç³»ç»Ÿçš„è¯­è¨€ã€‚

**å¯æ§æ€§æ¡ä»¶**ï¼š

$$\overline{K}\Sigma_u \cap L(G) \subseteq \overline{K}$$

å…¶ä¸­ $\Sigma_u$ æ˜¯ä¸å¯æ§äº‹ä»¶é›†åˆã€‚

#### 4.1.4. é²æ£’æ€§åˆ†æ

**Lyapunovç¨³å®šæ€§**ï¼š

ç³»ç»Ÿ $\dot{x} = f(x)$ åœ¨å¹³è¡¡ç‚¹ $x_e$ æ˜¯ç¨³å®šçš„ï¼Œå¦‚æœå­˜åœ¨Lyapunovå‡½æ•° $V(x)$ ä½¿å¾—ï¼š

1. $V(x_e) = 0$
2. $V(x) > 0$ å¯¹äº $x \neq x_e$
3. $\dot{V}(x) = \frac{\partial V}{\partial x}f(x) \leq 0$

**ç¤ºä¾‹**ï¼šLyapunovç¨³å®šæ€§åˆ†æ

```python
import numpy as np
import sympy as sp

# ç³»ç»Ÿï¼šx' = -x^3
x = sp.Symbol('x')
f = -x**3

# é€‰æ‹©Lyapunovå‡½æ•° V = x^2
V = x**2
dV_dx = sp.diff(V, x)
V_dot = dV_dx * f

print(f"V = {V}")
print(f"V_dot = {V_dot}")

# V_dot = 2x * (-x^3) = -2x^4 <= 0
# ç³»ç»Ÿæ˜¯ç¨³å®šçš„
```

### 4.2. æœ€ä¼˜ä¸é¢„æµ‹æ§åˆ¶

#### 4.2.1. æœ€ä¼˜æ§åˆ¶é—®é¢˜

**æœ€ä¼˜æ§åˆ¶é—®é¢˜**ï¼š

æœ€å°åŒ–ä»£ä»·å‡½æ•°ï¼š

$$J = \int_0^T L(x(t), u(t), t)dt + F(x(T))$$

å—çº¦æŸäºï¼š

$$\dot{x} = f(x, u, t), \quad x(0) = x_0$$

$$g(x, u, t) \leq 0, \quad h(x, u, t) = 0$$

#### 4.2.2. Pontryaginæœ€å¤§åŸç†

**Hamiltonianå‡½æ•°**ï¼š

$$H(x, u, \lambda, t) = L(x, u, t) + \lambda^T f(x, u, t)$$

**æœ€ä¼˜æ€§æ¡ä»¶**ï¼š

1. **çŠ¶æ€æ–¹ç¨‹**ï¼š$\dot{x} = \frac{\partial H}{\partial \lambda}$
2. **åæ€æ–¹ç¨‹**ï¼š$\dot{\lambda} = -\frac{\partial H}{\partial x}$
3. **æœ€ä¼˜æ§åˆ¶**ï¼š$u^* = \arg\min_u H(x, u, \lambda, t)$
4. **è¾¹ç•Œæ¡ä»¶**ï¼š$\lambda(T) = \frac{\partial F}{\partial x}(x(T))$

#### 4.2.3. åŠ¨æ€è§„åˆ’

**Bellmanæ–¹ç¨‹**ï¼š

$$V^*(x, t) = \min_u \left[ L(x, u, t) + V^*(f(x, u, t), t+1) \right]$$

**æœ€ä¼˜æ§åˆ¶å¾‹**ï¼š

$$u^*(x, t) = \arg\min_u \left[ L(x, u, t) + V^*(f(x, u, t), t+1) \right]$$

#### 4.2.4. é¢„æµ‹æ§åˆ¶

**æ¨¡å‹é¢„æµ‹æ§åˆ¶ï¼ˆMPCï¼‰**ï¼š

åœ¨æ¯ä¸ªæ—¶åˆ» $k$ï¼Œæ±‚è§£æœ‰é™æ—¶åŸŸä¼˜åŒ–é—®é¢˜ï¼š

$$\min_{u_{k|k}, \ldots, u_{k+N-1|k}} \sum_{i=0}^{N-1} \ell(x_{k+i|k}, u_{k+i|k}) + V_f(x_{k+N|k})$$

å—çº¦æŸäºï¼š

$$x_{k+i+1|k} = f(x_{k+i|k}, u_{k+i|k})$$

$$x_{k|k} = x_k$$

$$u_{k+i|k} \in \mathcal{U}, \quad x_{k+i|k} \in \mathcal{X}$$

**ç¤ºä¾‹**ï¼šMPCæ§åˆ¶å™¨

```python
import numpy as np
from scipy.optimize import minimize

class MPCController:
    def __init__(self, A, B, Q, R, N, umax, xmax):
        self.A = A
        self.B = B
        self.Q = Q
        self.R = R
        self.N = N  # é¢„æµ‹æ—¶åŸŸ
        self.umax = umax
        self.xmax = xmax

    def cost_function(self, u_sequence, x0):
        """ä»£ä»·å‡½æ•°"""
        cost = 0
        x = x0
        for i in range(self.N):
            u = u_sequence[i]
            cost += x.T @ self.Q @ x + u.T @ self.R @ u
            x = self.A @ x + self.B @ u
        cost += x.T @ self.Q @ x  # ç»ˆç«¯ä»£ä»·
        return cost[0, 0]

    def control(self, x0):
        """è®¡ç®—æ§åˆ¶è¾“å…¥"""
        u0 = np.zeros((self.N, 1))
        bounds = [(-self.umax, self.umax) for _ in range(self.N)]

        result = minimize(
            self.cost_function,
            u0,
            args=(x0,),
            bounds=bounds,
            method='SLSQP'
        )

        return result.x[0]  # è¿”å›ç¬¬ä¸€ä¸ªæ§åˆ¶è¾“å…¥
```

### 4.3. åˆ†å¸ƒå¼ä¸å¹¶è¡Œç³»ç»Ÿ

#### 4.3.1. å¹¶å‘æ€§ç†è®º

**è¿›ç¨‹ä»£æ•°**ï¼šç”¨äºæè¿°å¹¶å‘ç³»ç»Ÿçš„å½¢å¼åŒ–æ–¹æ³•ã€‚

**æ ‡è®°å›¾ï¼ˆMarked Graphï¼‰**ï¼šPetriç½‘çš„ç‰¹æ®Šå½¢å¼ï¼Œæ¯ä¸ªä½ç½®åªæœ‰ä¸€ä¸ªè¾“å…¥å’Œè¾“å‡ºã€‚

**æ—¶é—´è‡ªåŠ¨æœºç½‘ç»œ**ï¼šå¤šä¸ªæ—¶é—´è‡ªåŠ¨æœºçš„ç»„åˆã€‚

#### 4.3.2. åˆ†å¸ƒå¼ç®—æ³•éªŒè¯

**ä¸€è‡´æ€§ç®—æ³•**ï¼šPaxosã€Raftç­‰ã€‚

**å®¹é”™ç®—æ³•**ï¼šæ‹œå åº­å®¹é”™ã€å´©æºƒå®¹é”™ã€‚

#### 4.3.3. ä¸€è‡´æ€§æ¨¡å‹

**çº¿æ€§ä¸€è‡´æ€§**ï¼šæ‰€æœ‰æ“ä½œçœ‹èµ·æ¥æ˜¯åŸå­çš„ã€‚

**å› æœä¸€è‡´æ€§**ï¼šä¿æŒå› æœå…³ç³»ã€‚

**æœ€ç»ˆä¸€è‡´æ€§**ï¼šæœ€ç»ˆæ‰€æœ‰å‰¯æœ¬ä¸€è‡´ã€‚

---

## 5. é«˜çº§ä¸è·¨å­¦ç§‘æ¨¡å‹

### 5.1. ä¸ç¡®å®šæ€§ä¸è¿‘ä¼¼æ¨¡å‹

#### 5.1.1. éç¡®å®šæ€§è‡ªåŠ¨æœº

**éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœºï¼ˆNFAï¼‰**ï¼š

$$M = (Q, \Sigma, \delta, q_0, F)$$

å…¶ä¸­ $\delta: Q \times \Sigma \to 2^Q$ æ˜¯éç¡®å®šæ€§è½¬ç§»å‡½æ•°ã€‚

#### 5.1.2. åŒºé—´æ¨¡å‹

**åŒºé—´ç³»ç»Ÿ**ï¼š

$$\dot{x} \in [A]x + [B]u$$

å…¶ä¸­ $[A]$ å’Œ $[B]$ æ˜¯åŒºé—´çŸ©é˜µã€‚

#### 5.1.3. æ¨¡ç³Šæ¨¡å‹

**æ¨¡ç³Šæ§åˆ¶ç³»ç»Ÿ**ï¼šä½¿ç”¨æ¨¡ç³Šé€»è¾‘è¿›è¡Œæ§åˆ¶ã€‚

**æ¨¡ç³Šè§„åˆ™**ï¼š

IF $x_1$ is $A_1$ AND $x_2$ is $A_2$ THEN $u$ is $B$

### 5.2. è®¤çŸ¥ä¸è¯­ä¹‰æ¨¡å‹

#### 5.2.1. ç¬¦å·è®¤çŸ¥æ¶æ„

**ACT-R**ï¼šè‡ªé€‚åº”æ§åˆ¶æ€ç»´-ç†æ€§æ¶æ„ã€‚

**SOAR**ï¼šçŠ¶æ€ã€æ“ä½œå’Œç»“æœæ¶æ„ã€‚

#### 5.2.2. ç¥ç»ç½‘ç»œæ¨¡å‹

**ç¥ç»ç½‘ç»œæ§åˆ¶**ï¼šä½¿ç”¨ç¥ç»ç½‘ç»œä½œä¸ºæ§åˆ¶å™¨ã€‚

**å¼ºåŒ–å­¦ä¹ **ï¼šé€šè¿‡ä¸ç¯å¢ƒäº¤äº’å­¦ä¹ æœ€ä¼˜ç­–ç•¥ã€‚

### 5.3. ä¿¡æ¯è®ºä¸æ§åˆ¶

#### 5.3.1. ä¿¡æ¯è®ºåŸºç¡€

**ç†µï¼ˆEntropyï¼‰**ï¼š

$$H(X) = -\sum_{i} p(x_i) \log p(x_i)$$

**äº’ä¿¡æ¯ï¼ˆMutual Informationï¼‰**ï¼š

$$I(X; Y) = H(X) - H(X|Y)$$

#### 5.3.2. ä¿¡æ¯ä¸æ§åˆ¶çš„å…³ç³»

**ä¿¡æ¯è®ºæ§åˆ¶**ï¼šä½¿ç”¨ä¿¡æ¯è®ºæ–¹æ³•è®¾è®¡æ§åˆ¶å™¨ã€‚

**æœ€å°ä¿¡æ¯æ§åˆ¶**ï¼šæœ€å°åŒ–æ§åˆ¶æ‰€éœ€çš„ä¿¡æ¯é‡ã€‚

---

## 6. å½¢å¼æ¨¡å‹çš„éªŒè¯ä¸æ¼”åŒ–

### 6.1. æ¨¡å‹æ£€éªŒä¸å®šç†è¯æ˜

#### 6.1.1. æ¨¡å‹æ£€éªŒæ–¹æ³•

**çŠ¶æ€ç©ºé—´æ¢ç´¢**ï¼šç©·ä¸¾æ‰€æœ‰å¯èƒ½çŠ¶æ€ã€‚

**ç¬¦å·æ¨¡å‹æ£€éªŒ**ï¼šä½¿ç”¨BDDç­‰ç¬¦å·è¡¨ç¤ºã€‚

**æœ‰ç•Œæ¨¡å‹æ£€éªŒ**ï¼šé™åˆ¶æœç´¢æ·±åº¦ã€‚

#### 6.1.2. å®šç†è¯æ˜å·¥å…·

**Coq**ï¼šä¾èµ–ç±»å‹å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€ã€‚

**Isabelle/HOL**ï¼šé«˜é˜¶é€»è¾‘å®šç†è¯æ˜å™¨ã€‚

### 6.2. ä»¿çœŸä¸æµ‹è¯•

#### 6.2.1. ä»¿çœŸæ–¹æ³•

**ç¦»æ•£äº‹ä»¶ä»¿çœŸ**ï¼šäº‹ä»¶é©±åŠ¨çš„ä»¿çœŸã€‚

**è¿ç»­ä»¿çœŸ**ï¼šæ•°å€¼ç§¯åˆ†æ–¹æ³•ã€‚

**è’™ç‰¹å¡æ´›ä»¿çœŸ**ï¼šéšæœºé‡‡æ ·æ–¹æ³•ã€‚

#### 6.2.2. æµ‹è¯•ç­–ç•¥

**è¦†ç›–ç‡åˆ†æ**ï¼šä»£ç è¦†ç›–ç‡ã€åˆ†æ”¯è¦†ç›–ç‡ã€‚

**å½¢å¼åŒ–æµ‹è¯•**ï¼šåŸºäºè§„èŒƒçš„æµ‹è¯•ã€‚

### 6.3. æ¨¡å‹æ¼”åŒ–ä¸è‡ªé€‚åº”

#### 6.3.1. è‡ªé€‚åº”æ§åˆ¶

**æ¨¡å‹å‚è€ƒè‡ªé€‚åº”æ§åˆ¶ï¼ˆMRACï¼‰**ï¼š

ä½¿ç³»ç»Ÿè¾“å‡ºè·Ÿè¸ªå‚è€ƒæ¨¡å‹è¾“å‡ºã€‚

**è‡ªæ ¡æ­£æ§åˆ¶**ï¼šåœ¨çº¿ä¼°è®¡å‚æ•°å¹¶è°ƒæ•´æ§åˆ¶å™¨ã€‚

#### 6.3.2. åœ¨çº¿å­¦ä¹ 

**å¼ºåŒ–å­¦ä¹ **ï¼šé€šè¿‡è¯•é”™å­¦ä¹ æœ€ä¼˜ç­–ç•¥ã€‚

**åœ¨çº¿ä¼˜åŒ–**ï¼šå®æ—¶ä¼˜åŒ–æ§åˆ¶å‚æ•°ã€‚

---

## 7. å®é™…åº”ç”¨æ¡ˆä¾‹

### 7.1. å·¥ä¸šæ§åˆ¶ç³»ç»Ÿ

**PIDæ§åˆ¶å™¨**ï¼šæ¯”ä¾‹-ç§¯åˆ†-å¾®åˆ†æ§åˆ¶å™¨ã€‚

**åº”ç”¨**ï¼šæ¸©åº¦æ§åˆ¶ã€å‹åŠ›æ§åˆ¶ã€æµé‡æ§åˆ¶ã€‚

### 7.2. æœºå™¨äººæ§åˆ¶ç³»ç»Ÿ

**è¿åŠ¨æ§åˆ¶**ï¼šè½¨è¿¹è·Ÿè¸ªã€è·¯å¾„è§„åˆ’ã€‚

**åŠ›æ§åˆ¶**ï¼šåŠ›/åŠ›çŸ©æ§åˆ¶ã€‚

### 7.3. ç½‘ç»œæ§åˆ¶ç³»ç»Ÿ

**ç½‘ç»œåŒ–æ§åˆ¶**ï¼šé€šè¿‡ç½‘ç»œä¼ è¾“æ§åˆ¶ä¿¡å·ã€‚

**æ—¶å»¶è¡¥å¿**ï¼šè¡¥å¿ç½‘ç»œæ—¶å»¶ã€‚

---

## 8. å½¢å¼åŒ–å®šä¹‰ä¸è¯æ˜

### 8.1. æ§åˆ¶ç³»ç»Ÿå½¢å¼åŒ–

**æ§åˆ¶ç³»ç»Ÿå½¢å¼åŒ–å®šä¹‰**ï¼š

è®¾æ§åˆ¶ç³»ç»Ÿ $\Sigma = (X, U, Y, f, h)$ï¼Œå…¶ä¸­ï¼š

- $X$ï¼šçŠ¶æ€ç©ºé—´
- $U$ï¼šè¾“å…¥ç©ºé—´
- $Y$ï¼šè¾“å‡ºç©ºé—´
- $f: X \times U \to X$ï¼šçŠ¶æ€è½¬ç§»å‡½æ•°
- $h: X \to Y$ï¼šè¾“å‡ºå‡½æ•°

### 8.2. ç¨³å®šæ€§ç†è®ºå½¢å¼åŒ–

**Lyapunovç¨³å®šæ€§å½¢å¼åŒ–**ï¼š

å¹³è¡¡ç‚¹ $x_e$ æ˜¯ç¨³å®šçš„ï¼Œå¦‚æœï¼š

$$\forall \epsilon > 0, \exists \delta > 0: \|x(0) - x_e\| < \delta \Rightarrow \|x(t) - x_e\| < \epsilon$$

---

## 9. å¤šè¡¨å¾

æ§åˆ¶ç†è®ºåŸºç¡€æ”¯æŒå¤šç§è¡¨å¾æ–¹å¼ï¼ŒåŒ…æ‹¬ï¼š

- **ç¬¦å·è¡¨å¾**ï¼šæ§åˆ¶å˜é‡ã€çŠ¶æ€ã€åé¦ˆã€æ§åˆ¶å¾‹ç­‰
- **å›¾ç»“æ„**ï¼šæ§åˆ¶æµç¨‹å›¾ã€çŠ¶æ€å›¾ã€åé¦ˆç»“æ„å›¾ç­‰
- **å‘é‡/å¼ é‡**ï¼šçŠ¶æ€å‘é‡ã€æ§åˆ¶åµŒå…¥ã€å‚æ•°çŸ©é˜µ
- **è‡ªç„¶è¯­è¨€**ï¼šå®šä¹‰ã€æ³¨é‡Šã€æè¿°
- **å›¾åƒ/å¯è§†åŒ–**ï¼šæ§åˆ¶ç»“æ„å›¾ã€æµç¨‹å›¾ã€åé¦ˆå¯è§†åŒ–ç­‰

è¿™äº›è¡¨å¾å¯äº’æ˜ ï¼Œæå‡æ§åˆ¶ç†è®ºè¡¨è¾¾åŠ›ã€‚

---

## 10. æ€»ç»“ä¸å±•æœ›

### 10.1. æ€»ç»“

æ§åˆ¶ç†è®ºåŸºç¡€æä¾›äº†ï¼š

1. **å½¢å¼åŒ–æ¨¡å‹**ï¼šçŠ¶æ€ç©ºé—´æ¨¡å‹ã€äº‹ä»¶é©±åŠ¨æ¨¡å‹ã€æ··åˆæ¨¡å‹
2. **è®¾è®¡æ–¹æ³•**ï¼šçŠ¶æ€åé¦ˆã€è§‚æµ‹å™¨è®¾è®¡ã€æœ€ä¼˜æ§åˆ¶
3. **åˆ†ææ–¹æ³•**ï¼šç¨³å®šæ€§åˆ†æã€é²æ£’æ€§åˆ†æ
4. **éªŒè¯æ–¹æ³•**ï¼šæ¨¡å‹æ£€éªŒã€å®šç†è¯æ˜ã€ä»¿çœŸæµ‹è¯•

### 10.2. æœªæ¥å±•æœ›

1. **é‡å­æ§åˆ¶**ï¼šé‡å­ç³»ç»Ÿçš„æ§åˆ¶
2. **ç”Ÿç‰©å¯å‘æ§åˆ¶**ï¼šåŸºäºç”Ÿç‰©ç³»ç»Ÿçš„æ§åˆ¶æ–¹æ³•
3. **å¤æ‚ç½‘ç»œæ§åˆ¶**ï¼šç½‘ç»œåŒ–ç³»ç»Ÿçš„æ§åˆ¶
4. **æœºå™¨å­¦ä¹ æ§åˆ¶**ï¼šåŸºäºæœºå™¨å­¦ä¹ çš„æ§åˆ¶æ–¹æ³•

---

## 11. å‚è€ƒæ–‡çŒ®

1. Ogata, K. (2010). Modern Control Engineering. Prentice Hall.
2. Astrom, K. J., & Murray, R. M. (2010). Feedback Systems: An Introduction for Scientists and Engineers. Princeton University Press.
3. Baier, C., & Katoen, J.-P. (2008). Principles of Model Checking. MIT Press.
4. Alur, R. (2015). Principles of Cyber-Physical Systems. MIT Press.
5. Tabuada, P. (2009). Verification and Control of Hybrid Systems: A Symbolic Approach. Springer.
6. Ramadge, P. J., & Wonham, W. M. (1987). Supervisory control of a class of discrete event processes. SIAM Journal on Control and Optimization, 25(1), 206-230.
7. Lynch, N. (1996). Distributed Algorithms. Morgan Kaufmann.
8. Khalil, H. K. (2002). Nonlinear Systems. Prentice Hall.
9. Slotine, J. J. E., & Li, W. (1991). Applied Nonlinear Control. Prentice Hall.
10. Zhou, K., Doyle, J. C., & Glover, K. (1996). Robust and Optimal Control. Prentice Hall.

---

[è¿”å›æ§åˆ¶ç†è®ºå¯¼èˆª](../README.md)
