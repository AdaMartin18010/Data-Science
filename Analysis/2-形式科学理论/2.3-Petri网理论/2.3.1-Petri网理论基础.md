# 2.3.1 Petriç½‘ç†è®ºåŸºç¡€

## ğŸ“‘ ç›®å½•

- [2.3.1 Petriç½‘ç†è®ºåŸºç¡€](#231-petriç½‘ç†è®ºåŸºç¡€)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ‘˜è¦](#1-æ‘˜è¦)
  - [3. Petriç½‘æ¦‚è¿°](#3-petriç½‘æ¦‚è¿°)
    - [3.1. Petriç½‘çš„å®šä¹‰](#31-petriç½‘çš„å®šä¹‰)
    - [3.2. Petriç½‘çš„ç‰¹ç‚¹](#32-petriç½‘çš„ç‰¹ç‚¹)
  - [4. åŸºæœ¬Petriç½‘](#4-åŸºæœ¬petriç½‘)
    - [4.1. Petriç½‘çš„å½¢å¼åŒ–å®šä¹‰](#41-petriç½‘çš„å½¢å¼åŒ–å®šä¹‰)
    - [4.2. å˜è¿çš„ä½¿èƒ½æ¡ä»¶](#42-å˜è¿çš„ä½¿èƒ½æ¡ä»¶)
    - [4.3. å˜è¿çš„è§¦å‘](#43-å˜è¿çš„è§¦å‘)
    - [4.4. å¯è¾¾æ€§](#44-å¯è¾¾æ€§)
  - [5. é«˜çº§Petriç½‘](#5-é«˜çº§petriç½‘)
    - [5.1. æ—¶é—´Petriç½‘](#51-æ—¶é—´petriç½‘)
  - [6. ç€è‰²Petriç½‘](#6-ç€è‰²petriç½‘)
  - [7. å±‚æ¬¡Petriç½‘](#7-å±‚æ¬¡petriç½‘)
  - [8. å¹¶å‘è¯­ä¹‰](#8-å¹¶å‘è¯­ä¹‰)
    - [8.1. æ­¥è¯­ä¹‰](#81-æ­¥è¯­ä¹‰)
    - [8.2. éƒ¨åˆ†åºè¯­ä¹‰](#82-éƒ¨åˆ†åºè¯­ä¹‰)
    - [8.3. è¿›ç¨‹è¯­ä¹‰](#83-è¿›ç¨‹è¯­ä¹‰)
  - [9. åˆ†ææŠ€æœ¯](#9-åˆ†ææŠ€æœ¯)
    - [9.1. å¯è¾¾æ€§åˆ†æ](#91-å¯è¾¾æ€§åˆ†æ)
  - [10. ç»“æ„åˆ†æ](#10-ç»“æ„åˆ†æ)
    - [10.1. æ€§èƒ½åˆ†æ](#101-æ€§èƒ½åˆ†æ)
  - [11. åº”ç”¨é¢†åŸŸ](#11-åº”ç”¨é¢†åŸŸ)
    - [11.1. å¹¶å‘ç³»ç»Ÿ](#111-å¹¶å‘ç³»ç»Ÿ)
    - [11.2. å·¥ä½œæµç³»ç»Ÿ](#112-å·¥ä½œæµç³»ç»Ÿ)
    - [11.3. åˆ¶é€ ç³»ç»Ÿ](#113-åˆ¶é€ ç³»ç»Ÿ)
  - [12. æœ¬åœ°è·³è½¬ä¸äº¤å‰å¼•ç”¨](#12-æœ¬åœ°è·³è½¬ä¸äº¤å‰å¼•ç”¨)
  - [13. å¤šè¡¨å¾](#13-å¤šè¡¨å¾)
  - [14. å½¢å¼åŒ–è¯­ä¹‰](#14-å½¢å¼åŒ–è¯­ä¹‰)
  - [15. å½¢å¼åŒ–è¯­æ³•ä¸è¯æ˜](#15-å½¢å¼åŒ–è¯­æ³•ä¸è¯æ˜)

---


## 1. æ‘˜è¦

æœ¬æ–‡ä»¶ç³»ç»Ÿæ¢³ç†Petriç½‘ç†è®ºçš„åŸºç¡€æ¦‚å¿µï¼Œæ¶µç›–åŸºæœ¬Petriç½‘ã€é«˜çº§Petriç½‘ã€å¹¶å‘è¯­ä¹‰ç­‰æ ¸å¿ƒå†…å®¹ï¼Œä¸ºå¹¶å‘ç³»ç»Ÿå»ºæ¨¡å’Œåˆ†ææä¾›ç†è®ºåŸºç¡€ã€‚

---

## 3. Petriç½‘æ¦‚è¿°

### 3.1. Petriç½‘çš„å®šä¹‰

**å®šä¹‰ 1.1.1 (Petriç½‘)**
Petriç½‘æ˜¯ä¸€ä¸ªå››å…ƒç»„ $N = (P, T, F, M_0)$ï¼Œå…¶ä¸­ï¼š

- $P$ æ˜¯æœ‰é™ä½ç½®é›†åˆï¼ˆplacesï¼‰
- $T$ æ˜¯æœ‰é™å˜è¿é›†åˆï¼ˆtransitionsï¼‰ï¼Œä¸” $P \cap T = \emptyset$
- $F \subseteq (P \times T) \cup (T \times P)$ æ˜¯æµå…³ç³»ï¼ˆflow relationï¼‰
- $M_0: P \rightarrow \mathbb{N}$ æ˜¯åˆå§‹æ ‡è¯†ï¼ˆinitial markingï¼‰

**å›¾å½¢è¡¨ç¤º**ï¼š

- ä½ç½®ç”¨åœ†åœˆè¡¨ç¤º
- å˜è¿ç”¨çŸ©å½¢è¡¨ç¤º
- æµå…³ç³»ç”¨æœ‰å‘å¼§è¡¨ç¤º
- æ ‡è¯†ç”¨ä½ç½®ä¸­çš„ä»¤ç‰Œè¡¨ç¤º

### 3.2. Petriç½‘çš„ç‰¹ç‚¹

**ä¼˜åŠ¿**ï¼š

1. **ç›´è§‚æ€§**ï¼šå›¾å½¢åŒ–è¡¨ç¤ºæ¸…æ™°æ˜“æ‡‚
2. **æ•°å­¦ä¸¥æ ¼æ€§**ï¼šæœ‰ä¸¥æ ¼çš„æ•°å­¦åŸºç¡€
3. **å¹¶å‘å»ºæ¨¡**ï¼šè‡ªç„¶è¡¨è¾¾å¹¶å‘å’ŒåŒæ­¥
4. **åˆ†ææŠ€æœ¯**ï¼šæœ‰æˆç†Ÿçš„åˆ†ææ–¹æ³•

**å±€é™æ€§**ï¼š

1. **çŠ¶æ€çˆ†ç‚¸**ï¼šçŠ¶æ€ç©ºé—´å¯èƒ½æŒ‡æ•°å¢é•¿
2. **è¡¨è¾¾èƒ½åŠ›**ï¼šåŸºæœ¬Petriç½‘è¡¨è¾¾èƒ½åŠ›æœ‰é™
3. **å¤æ‚æ€§**ï¼šæŸäº›åˆ†æé—®é¢˜æ˜¯ä¸å¯åˆ¤å®šçš„

## 4. åŸºæœ¬Petriç½‘

### 4.1. Petriç½‘çš„å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 2.1.1 (é¢„ç½®å’Œåç½®)**
å¯¹äº $x \in P \cup T$ï¼š

- ${}^{\bullet}x = \{y \in P \cup T : (y, x) \in F\}$ (é¢„ç½®)
- $x^{\bullet} = \{y \in P \cup T : (x, y) \in F\}$ (åç½®)

**å®šä¹‰ 2.1.2 (æ ‡è¯†)**
æ ‡è¯† $M: P \rightarrow \mathbb{N}$ ç»™æ¯ä¸ªä½ç½®åˆ†é…ä»¤ç‰Œæ•°é‡ã€‚

**Rustå®ç°ç¤ºä¾‹**ï¼š

```rust
use std::collections::{HashMap, HashSet};

#[derive(Debug, Clone)]
struct PetriNet {
    places: HashSet<usize>,
    transitions: HashSet<usize>,
    flow_relation: HashSet<(usize, usize)>,
    initial_marking: HashMap<usize, usize>,
}

impl PetriNet {
    fn new(
        places: HashSet<usize>,
        transitions: HashSet<usize>,
        flow_relation: HashSet<(usize, usize)>,
        initial_marking: HashMap<usize, usize>,
    ) -> Self {
        PetriNet {
            places,
            transitions,
            flow_relation,
            initial_marking,
        }
    }

    // è®¡ç®—èŠ‚ç‚¹çš„é¢„ç½®
    fn preset(&self, node: usize) -> HashSet<usize> {
        self.flow_relation
            .iter()
            .filter(|(_, to)| *to == node)
            .map(|(from, _)| *from)
            .collect()
    }

    // è®¡ç®—èŠ‚ç‚¹çš„åç½®
    fn postset(&self, node: usize) -> HashSet<usize> {
        self.flow_relation
            .iter()
            .filter(|(from, _)| *from == node)
            .map(|(_, to)| *to)
            .collect()
    }
}

#[derive(Debug, Clone)]
struct Marking {
    tokens: HashMap<usize, usize>,
}

impl Marking {
    fn new(tokens: HashMap<usize, usize>) -> Self {
        Marking { tokens }
    }

    fn get_tokens(&self, place: usize) -> usize {
        *self.tokens.get(&place).unwrap_or(&0)
    }

    fn set_tokens(&mut self, place: usize, count: usize) {
        self.tokens.insert(place, count);
    }
}
```

### 4.2. å˜è¿çš„ä½¿èƒ½æ¡ä»¶

**å®šä¹‰ 2.2.1 (ä½¿èƒ½)**
å˜è¿ $t \in T$ åœ¨æ ‡è¯† $M$ ä¸‹ä½¿èƒ½ï¼Œå½“ä¸”ä»…å½“ï¼š
$$\forall p \in {}^{\bullet}t : M(p) \geq 1$$

**å®šç† 2.2.1 (ä½¿èƒ½çš„å•è°ƒæ€§)**
å¦‚æœå˜è¿ $t$ åœ¨æ ‡è¯† $M$ ä¸‹ä½¿èƒ½ï¼Œä¸” $M' \geq M$ï¼Œåˆ™ $t$ åœ¨ $M'$ ä¸‹ä¹Ÿä½¿èƒ½ã€‚

**Rustå®ç°**ï¼š

```rust
impl PetriNet {
    fn is_enabled(&self, transition: usize, marking: &Marking) -> bool {
        let preset = self.preset(transition);

        for place in preset {
            if self.places.contains(&place) {
                if marking.get_tokens(place) < 1 {
                    return false;
                }
            }
        }

        true
    }

    fn enabled_transitions(&self, marking: &Marking) -> Vec<usize> {
        self.transitions
            .iter()
            .filter(|&&t| self.is_enabled(t, marking))
            .copied()
            .collect()
    }
}
```

### 4.3. å˜è¿çš„è§¦å‘

**å®šä¹‰ 2.3.1 (è§¦å‘è§„åˆ™)**
å¦‚æœå˜è¿ $t$ åœ¨æ ‡è¯† $M$ ä¸‹ä½¿èƒ½ï¼Œåˆ™å¯ä»¥è§¦å‘ $t$ï¼Œå¾—åˆ°æ–°æ ‡è¯† $M'$ï¼š

$$
M'(p) = \begin{cases}
M(p) - 1 & \text{if } p \in {}^{\bullet}t \land p \notin t^{\bullet} \\
M(p) + 1 & \text{if } p \notin {}^{\bullet}t \land p \in t^{\bullet} \\
M(p) & \text{otherwise}
\end{cases}
$$

è®°ä½œï¼š$M \xrightarrow{t} M'$

**Rustå®ç°**ï¼š

```rust
impl PetriNet {
    fn fire_transition(&self, transition: usize, marking: &Marking) -> Option<Marking> {
        if !self.is_enabled(transition, marking) {
            return None;
        }

        let mut new_marking = marking.clone();

        // ä»é¢„ç½®ä½ç½®ç§»é™¤ä»¤ç‰Œ
        for place in self.preset(transition) {
            if self.places.contains(&place) {
                let current = new_marking.get_tokens(place);
                new_marking.set_tokens(place, current - 1);
            }
        }

        // å‘åç½®ä½ç½®æ·»åŠ ä»¤ç‰Œ
        for place in self.postset(transition) {
            if self.places.contains(&place) {
                let current = new_marking.get_tokens(place);
                new_marking.set_tokens(place, current + 1);
            }
        }

        Some(new_marking)
    }
}
```

### 4.4. å¯è¾¾æ€§

**å®šä¹‰ 2.4.1 (å¯è¾¾æ€§)**
æ ‡è¯† $M'$ ä»æ ‡è¯† $M$ å¯è¾¾ï¼Œè®°ä½œ $M \rightarrow^* M'$ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨å˜è¿åºåˆ— $\sigma = t_1 t_2 \cdots t_n$ ä½¿å¾—ï¼š
$$M \xrightarrow{t_1} M_1 \xrightarrow{t_2} M_2 \cdots \xrightarrow{t_n} M'$$

**å®šä¹‰ 2.4.2 (å¯è¾¾é›†)**
ä»æ ‡è¯† $M$ å‡ºå‘çš„å¯è¾¾é›†ï¼š
$$R(M) = \{M' : M \rightarrow^* M'\}$$

**å®šç† 2.4.1 (å¯è¾¾æ€§åˆ¤å®š)**
Petriç½‘çš„å¯è¾¾æ€§é—®é¢˜æ˜¯EXPSPACEå®Œå…¨çš„ã€‚

**Rustå®ç°ï¼ˆå¹¿åº¦ä¼˜å…ˆæœç´¢ï¼‰**ï¼š

```rust
use std::collections::{VecDeque, HashSet};

impl PetriNet {
    fn reachable_markings(&self, initial: &Marking) -> HashSet<Marking> {
        let mut reachable = HashSet::new();
        let mut queue = VecDeque::new();

        queue.push_back(initial.clone());
        reachable.insert(initial.clone());

        while let Some(current_marking) = queue.pop_front() {
            let enabled = self.enabled_transitions(&current_marking);

            for transition in enabled {
                if let Some(new_marking) = self.fire_transition(transition, &current_marking) {
                    if !reachable.contains(&new_marking) {
                        reachable.insert(new_marking.clone());
                        queue.push_back(new_marking.clone());
                    }
                }
            }
        }

        reachable
    }

    fn is_reachable(&self, initial: &Marking, target: &Marking) -> bool {
        let reachable = self.reachable_markings(initial);
        reachable.contains(target)
    }
}

// ä¸ºMarkingå®ç°å¿…è¦çš„traitä»¥æ”¯æŒHashSet
impl PartialEq for Marking {
    fn eq(&self, other: &Self) -> bool {
        self.tokens == other.tokens
    }
}

impl Eq for Marking {}

impl std::hash::Hash for Marking {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        for (&place, &tokens) in &self.tokens {
            place.hash(state);
            tokens.hash(state);
        }
    }
}
```

## 5. é«˜çº§Petriç½‘

### 5.1. æ—¶é—´Petriç½‘

**å®šä¹‰ 3.1.1 (æ—¶é—´Petriç½‘)**
æ—¶é—´Petriç½‘åœ¨åŸºæœ¬Petriç½‘åŸºç¡€ä¸Šä¸ºæ¯ä¸ªå˜è¿ $t$ åˆ†é…æ—¶é—´åŒºé—´ $I(t) = [a, b]$ï¼Œå…¶ä¸­ $0 \leq a \leq b$ã€‚

**è¯­ä¹‰**ï¼š

- å˜è¿ $t$ åœ¨æ—¶åˆ» $Ï„$ ä½¿èƒ½åï¼Œå¿…é¡»åœ¨åŒºé—´ $[Ï„ + a, Ï„ + b]$ å†…è§¦å‘
- å¦‚æœåœ¨ $Ï„ + b$ æ—¶åˆ»ä»æœªè§¦å‘ï¼Œåˆ™å¿…é¡»ç«‹å³è§¦å‘

**Rustå®ç°**ï¼š

```rust
# [derive(Debug, Clone)]
struct TimeInterval {
    min: f64,
    max: f64,
}

# [derive(Debug, Clone)]
struct TimedPetriNet {
    petri_net: PetriNet,
    timing_constraints: HashMap<usize, TimeInterval>,
}

# [derive(Debug, Clone)]
struct TimedState {
    marking: Marking,
    enabled_times: HashMap<usize, f64>, // å˜è¿ä½¿èƒ½çš„æ—¶é—´
    current_time: f64,
}

impl TimedPetriNet {
    fn is_firable(&self, transition: usize, state: &TimedState) -> bool {
        if !self.petri_net.is_enabled(transition, &state.marking) {
            return false;
        }

        if let Some(enabled_time) = state.enabled_times.get(&transition) {
            if let Some(interval) = self.timing_constraints.get(&transition) {
                let elapsed = state.current_time - enabled_time;
                return elapsed >= interval.min && elapsed <= interval.max;
            }
        }

        false
    }

    fn get_urgent_transitions(&self, state: &TimedState) -> Vec<usize> {
        let mut urgent = Vec::new();

        for (&transition, &enabled_time) in &state.enabled_times {
            if let Some(interval) = self.timing_constraints.get(&transition) {
                let elapsed = state.current_time - enabled_time;
                if elapsed >= interval.max {
                    urgent.push(transition);
                }
            }
        }

        urgent
    }
}
```

## 6. ç€è‰²Petriç½‘

**å®šä¹‰ 3.2.1 (ç€è‰²Petriç½‘)**
ç€è‰²Petriç½‘ $CPN = (P, T, A, \Sigma, V, C, G, E, I)$ï¼Œå…¶ä¸­ï¼š

- $\Sigma$ æ˜¯é¢œè‰²é›†åˆçš„æœ‰é™é›†
- $V$ æ˜¯å˜é‡çš„æœ‰é™é›†
- $C: P \rightarrow \Sigma$ æ˜¯é¢œè‰²å‡½æ•°
- $G$ æ˜¯å®ˆæŠ¤å‡½æ•°
- $E$ æ˜¯å¼§è¡¨è¾¾å¼å‡½æ•°
- $I$ æ˜¯åˆå§‹åŒ–å‡½æ•°

**Rustå®ç°**ï¼š

```rust
# [derive(Debug, Clone, PartialEq, Eq, Hash)]
enum Color {
    Int(i32),
    String(String),
    Bool(bool),
    Tuple(Vec<Color>),
}

# [derive(Debug, Clone)]
struct ColoredToken {
    color: Color,
    count: usize,
}

# [derive(Debug, Clone)]
struct ColoredMarking {
    place_tokens: HashMap<usize, Vec<ColoredToken>>,
}

# [derive(Debug, Clone)]
struct ColoredPetriNet {
    places: HashSet<usize>,
    transitions: HashSet<usize>,
    flow_relation: HashSet<(usize, usize)>,
    color_sets: HashMap<usize, HashSet<Color>>,
    arc_expressions: HashMap<(usize, usize), Box<dyn Fn(&HashMap<String, Color>) -> Vec<ColoredToken>>>,
    guards: HashMap<usize, Box<dyn Fn(&HashMap<String, Color>) -> bool>>,
}

impl ColoredPetriNet {
    fn is_enabled(&self, transition: usize, marking: &ColoredMarking, binding: &HashMap<String, Color>) -> bool {
        // æ£€æŸ¥å®ˆæŠ¤æ¡ä»¶
        if let Some(guard) = self.guards.get(&transition) {
            if !guard(binding) {
                return false;
            }
        }

        // æ£€æŸ¥æ‰€æœ‰è¾“å…¥å¼§çš„ä»¤ç‰Œ
        for place in self.preset(transition) {
            if let Some(arc_expr) = self.arc_expressions.get(&(place, transition)) {
                let required_tokens = arc_expr(binding);
                let available_tokens = marking.place_tokens.get(&place).unwrap_or(&vec![]);

                if !self.has_sufficient_tokens(available_tokens, &required_tokens) {
                    return false;
                }
            }
        }

        true
    }

    fn has_sufficient_tokens(&self, available: &[ColoredToken], required: &[ColoredToken]) -> bool {
        for req_token in required {
            let mut found_count = 0;
            for avail_token in available {
                if avail_token.color == req_token.color {
                    found_count += avail_token.count;
                }
            }
            if found_count < req_token.count {
                return false;
            }
        }
        true
    }

    fn preset(&self, node: usize) -> HashSet<usize> {
        self.flow_relation
            .iter()
            .filter(|(_, to)| *to == node)
            .map(|(from, _)| *from)
            .collect()
    }
}
```

## 7. å±‚æ¬¡Petriç½‘

**å®šä¹‰ 3.3.1 (å±‚æ¬¡Petriç½‘)**
å±‚æ¬¡Petriç½‘å…è®¸å°†å¤æ‚ç½‘ç»œåˆ†è§£ä¸ºå¤šä¸ªå±‚æ¬¡ï¼Œæ¯ä¸ªæ›¿æ¢å˜è¿å¯¹åº”ä¸€ä¸ªå­ç½‘ã€‚

**ç»„åˆè§„åˆ™**ï¼š

1. **æ¥å£å®šä¹‰**ï¼šæ¯ä¸ªå­ç½‘æœ‰è¾“å…¥å’Œè¾“å‡ºæ¥å£
2. **ç«¯å£æ˜ å°„**ï¼šçˆ¶ç½‘çš„ä½ç½®æ˜ å°„åˆ°å­ç½‘çš„ç«¯å£
3. **è¯­ä¹‰ä¿æŒ**ï¼šå±•å¼€åçš„å¹³å¦ç½‘ä¸åŸå±‚æ¬¡ç½‘è¯­ä¹‰ç­‰ä»·

## 8. å¹¶å‘è¯­ä¹‰

### 8.1. æ­¥è¯­ä¹‰

**å®šä¹‰ 4.1.1 (æ­¥)**
æ­¥æ˜¯ä¸€ç»„å¯ä»¥å¹¶å‘æ‰§è¡Œçš„å˜è¿é›†åˆ $U \subseteq T$ï¼Œæ»¡è¶³ï¼š
$$\forall t_1, t_2 \in U, t_1 \neq t_2 : {}^{\bullet}t_1 \cap {}^{\bullet}t_2 = \emptyset$$

**æ­¥è¯­ä¹‰**ï¼šæ ‡è¯† $M$ é€šè¿‡æ­¥ $U$ è½¬ç§»åˆ° $M'$ï¼Œè®°ä½œ $M \xrightarrow{U} M'$ã€‚

**Rustå®ç°**ï¼š

```rust
impl PetriNet {
    fn is_valid_step(&self, transitions: &HashSet<usize>, marking: &Marking) -> bool {
        // æ£€æŸ¥æ¯ä¸ªå˜è¿æ˜¯å¦ä½¿èƒ½
        for &transition in transitions {
            if !self.is_enabled(transition, marking) {
                return false;
            }
        }

        // æ£€æŸ¥å˜è¿ä¹‹é—´æ˜¯å¦æœ‰å†²çªï¼ˆå…±äº«è¾“å…¥ä½ç½®ï¼‰
        for &t1 in transitions {
            for &t2 in transitions {
                if t1 != t2 {
                    let preset1 = self.preset(t1);
                    let preset2 = self.preset(t2);
                    let intersection: HashSet<_> = preset1.intersection(&preset2).collect();

                    // æ£€æŸ¥å…±äº«çš„ä½ç½®æ˜¯å¦æœ‰è¶³å¤Ÿçš„ä»¤ç‰Œ
                    for &shared_place in &intersection {
                        if self.places.contains(shared_place) {
                            let required = transitions.iter()
                                .filter(|&&t| self.preset(t).contains(shared_place))
                                .count();
                            if marking.get_tokens(*shared_place) < required {
                                return false;
                            }
                        }
                    }
                }
            }
        }

        true
    }

    fn fire_step(&self, transitions: &HashSet<usize>, marking: &Marking) -> Option<Marking> {
        if !self.is_valid_step(transitions, marking) {
            return None;
        }

        let mut new_marking = marking.clone();

        // ç§»é™¤æ‰€æœ‰è¾“å…¥ä»¤ç‰Œ
        for &transition in transitions {
            for place in self.preset(transition) {
                if self.places.contains(&place) {
                    let current = new_marking.get_tokens(place);
                    new_marking.set_tokens(place, current - 1);
                }
            }
        }

        // æ·»åŠ æ‰€æœ‰è¾“å‡ºä»¤ç‰Œ
        for &transition in transitions {
            for place in self.postset(transition) {
                if self.places.contains(&place) {
                    let current = new_marking.get_tokens(place);
                    new_marking.set_tokens(place, current + 1);
                }
            }
        }

        Some(new_marking)
    }
}
```

### 8.2. éƒ¨åˆ†åºè¯­ä¹‰

**å®šä¹‰ 4.2.1 (å› æœå…³ç³»)**
äº‹ä»¶ $e_1$ å› æœå…ˆäºäº‹ä»¶ $e_2$ï¼Œè®°ä½œ $e_1 < e_2$ï¼Œå½“ä¸”ä»…å½“ $e_1$ çš„å‘ç”Ÿæ˜¯ $e_2$ ä½¿èƒ½çš„å¿…è¦æ¡ä»¶ã€‚

**å®šä¹‰ 4.2.2 (å¹¶å‘å…³ç³»)**
äº‹ä»¶ $e_1$ å’Œ $e_2$ å¹¶å‘ï¼Œè®°ä½œ $e_1 \parallel e_2$ï¼Œå½“ä¸”ä»…å½“ $\neg(e_1 < e_2) \land \neg(e_2 < e_1)$ã€‚

### 8.3. è¿›ç¨‹è¯­ä¹‰

**å®šä¹‰ 4.3.1 (Petriç½‘è¿›ç¨‹)**
Petriç½‘ $N$ çš„è¿›ç¨‹æ˜¯ä¸€ä¸ªæ— ç¯ç½‘ $\pi = (B, E, F')$ï¼Œå…¶ä¸­ï¼š

- $B$ æ˜¯æ¡ä»¶é›†åˆ
- $E$ æ˜¯äº‹ä»¶é›†åˆ
- $F' \subseteq (B \times E) \cup (E \times B)$ æ˜¯æµå…³ç³»

**è¿›ç¨‹çš„æ€§è´¨**ï¼š

1. **æ— ç¯æ€§**ï¼šä¸å­˜åœ¨æœ‰å‘ç¯
2. **å®‰å…¨æ€§**ï¼šæ¯ä¸ªæ¡ä»¶æœ€å¤šæœ‰ä¸€ä¸ªä»¤ç‰Œ
3. **ä¸€è‡´æ€§**ï¼šè¿›ç¨‹å¯¹åº”ç½‘çš„ä¸€æ¬¡æ‰§è¡Œ

## 9. åˆ†ææŠ€æœ¯

### 9.1. å¯è¾¾æ€§åˆ†æ

**å¯è¾¾å›¾æ„é€ **ï¼š

```rust
# [derive(Debug, Clone)]
struct ReachabilityGraph {
    nodes: HashMap<Marking, usize>,
    edges: Vec<(usize, usize, usize)>, // (from, to, transition)
    node_count: usize,
}

impl PetriNet {
    fn build_reachability_graph(&self, initial: &Marking) -> ReachabilityGraph {
        let mut graph = ReachabilityGraph {
            nodes: HashMap::new(),
            edges: Vec::new(),
            node_count: 0,
        };

        let mut queue = VecDeque::new();

        // æ·»åŠ åˆå§‹æ ‡è¯†
        graph.nodes.insert(initial.clone(), 0);
        graph.node_count = 1;
        queue.push_back(initial.clone());

        while let Some(current_marking) = queue.pop_front() {
            let current_id = *graph.nodes.get(&current_marking).unwrap();
            let enabled = self.enabled_transitions(&current_marking);

            for transition in enabled {
                if let Some(new_marking) = self.fire_transition(transition, &current_marking) {
                    let new_id = if let Some(&id) = graph.nodes.get(&new_marking) {
                        id
                    } else {
                        let id = graph.node_count;
                        graph.nodes.insert(new_marking.clone(), id);
                        graph.node_count += 1;
                        queue.push_back(new_marking.clone());
                        id
                    };

                    graph.edges.push((current_id, new_id, transition));
                }
            }
        }

        graph
    }
}
```

## 10. ç»“æ„åˆ†æ

**ä¸å˜å¼åˆ†æ**ï¼š

```rust
impl PetriNet {
    fn compute_place_invariants(&self) -> Vec<Vec<i32>> {
        // æ„é€ å…³è”çŸ©é˜µ
        let places: Vec<_> = self.places.iter().cloned().collect();
        let transitions: Vec<_> = self.transitions.iter().cloned().collect();

        let mut matrix = vec![vec![0i32; transitions.len()]; places.len()];

        for (i, &place) in places.iter().enumerate() {
            for (j, &transition) in transitions.iter().enumerate() {
                // è¾“å…¥å¼§ï¼š-1
                if self.flow_relation.contains(&(place, transition)) {
                    matrix[i][j] -= 1;
                }
                // è¾“å‡ºå¼§ï¼š+1
                if self.flow_relation.contains(&(transition, place)) {
                    matrix[i][j] += 1;
                }
            }
        }

        // æ±‚è§£é½æ¬¡çº¿æ€§æ–¹ç¨‹ç»„ A^T * x = 0
        self.solve_homogeneous_system(&matrix)
    }

    fn solve_homogeneous_system(&self, matrix: &[Vec<i32>]) -> Vec<Vec<i32>> {
        // ç®€åŒ–çš„é«˜æ–¯æ¶ˆå…ƒæ³•å®ç°
        // è¿™é‡Œè¿”å›ç©ºå‘é‡ï¼Œå®é™…å®ç°éœ€è¦å®Œæ•´çš„çº¿æ€§ä»£æ•°ç®—æ³•
        vec![]
    }

    fn check_invariant(&self, invariant: &[i32], marking: &Marking) -> i32 {
        let places: Vec<_> = self.places.iter().cloned().collect();
        invariant.iter().enumerate()
            .map(|(i, &coeff)| coeff * marking.get_tokens(places[i]) as i32)
            .sum()
    }
}
```

### 10.1. æ€§èƒ½åˆ†æ

**å¹³å‡æ ‡è¯†è®¡ç®—**ï¼š

```rust
impl PetriNet {
    fn compute_steady_state_probabilities(&self, initial: &Marking) -> HashMap<Marking, f64> {
        let reachable = self.reachable_markings(initial);
        let n = reachable.len();

        if n == 0 {
            return HashMap::new();
        }

        // æ„é€ è½¬ç§»æ¦‚ç‡çŸ©é˜µ
        let markings: Vec<_> = reachable.iter().cloned().collect();
        let mut transition_matrix = vec![vec![0.0; n]; n];

        for (i, marking) in markings.iter().enumerate() {
            let enabled = self.enabled_transitions(marking);
            let num_enabled = enabled.len() as f64;

            if num_enabled > 0.0 {
                for transition in enabled {
                    if let Some(next_marking) = self.fire_transition(transition, marking) {
                        if let Some(j) = markings.iter().position(|m| m == &next_marking) {
                            transition_matrix[i][j] += 1.0 / num_enabled;
                        }
                    }
                }
            }
        }

        // æ±‚è§£ç¨³æ€æ¦‚ç‡æ–¹ç¨‹ Ï€ = Ï€ * P
        let probabilities = self.solve_steady_state(&transition_matrix);

        markings.into_iter()
            .zip(probabilities.into_iter())
            .collect()
    }

    fn solve_steady_state(&self, matrix: &[Vec<f64>]) -> Vec<f64> {
        let n = matrix.len();
        if n == 0 {
            return vec![];
        }

        // ç®€åŒ–å®ç°ï¼šå‡åŒ€åˆ†å¸ƒ
        vec![1.0 / n as f64; n]
    }
}
```

## 11. åº”ç”¨é¢†åŸŸ

### 11.1. å¹¶å‘ç³»ç»Ÿ

**ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å‹**ï¼š

```rust
fn create_producer_consumer_petri_net() -> PetriNet {
    let mut places = HashSet::new();
    let mut transitions = HashSet::new();
    let mut flow_relation = HashSet::new();
    let mut initial_marking = HashMap::new();

    // ä½ç½®ï¼š0=ç¼“å†²åŒºç©ºé—², 1=ç¼“å†²åŒºæ»¡, 2=ç”Ÿäº§è€…å°±ç»ª, 3=æ¶ˆè´¹è€…å°±ç»ª
    places.insert(0);
    places.insert(1);
    places.insert(2);
    places.insert(3);

    // å˜è¿ï¼š0=ç”Ÿäº§, 1=æ¶ˆè´¹
    transitions.insert(0);
    transitions.insert(1);

    // æµå…³ç³»
    flow_relation.insert((2, 0)); // ç”Ÿäº§è€…å°±ç»ª -> ç”Ÿäº§
    flow_relation.insert((0, 0)); // ç¼“å†²åŒºç©ºé—² -> ç”Ÿäº§
    flow_relation.insert((0, 1)); // ç”Ÿäº§ -> ç¼“å†²åŒºæ»¡
    flow_relation.insert((0, 2)); // ç”Ÿäº§ -> ç”Ÿäº§è€…å°±ç»ª

    flow_relation.insert((3, 1)); // æ¶ˆè´¹è€…å°±ç»ª -> æ¶ˆè´¹
    flow_relation.insert((1, 1)); // ç¼“å†²åŒºæ»¡ -> æ¶ˆè´¹
    flow_relation.insert((1, 0)); // æ¶ˆè´¹ -> ç¼“å†²åŒºç©ºé—²
    flow_relation.insert((1, 3)); // æ¶ˆè´¹ -> æ¶ˆè´¹è€…å°±ç»ª

    // åˆå§‹æ ‡è¯†
    initial_marking.insert(0, 3); // 3ä¸ªç¼“å†²åŒºæ§½ä½
    initial_marking.insert(1, 0);
    initial_marking.insert(2, 1); // 1ä¸ªç”Ÿäº§è€…
    initial_marking.insert(3, 1); // 1ä¸ªæ¶ˆè´¹è€…

    PetriNet::new(places, transitions, flow_relation, initial_marking)
}
```

### 11.2. å·¥ä½œæµç³»ç»Ÿ

**ä¸šåŠ¡æµç¨‹å»ºæ¨¡**ï¼š

```rust
fn create_workflow_petri_net() -> PetriNet {
    let mut places = HashSet::new();
    let mut transitions = HashSet::new();
    let mut flow_relation = HashSet::new();
    let mut initial_marking = HashMap::new();

    // ä½ç½®ï¼š0=å¼€å§‹, 1=ä»»åŠ¡Aå®Œæˆ, 2=ä»»åŠ¡Bå®Œæˆ, 3=ç»“æŸ
    places.insert(0);
    places.insert(1);
    places.insert(2);
    places.insert(3);

    // å˜è¿ï¼š0=ä»»åŠ¡A, 1=ä»»åŠ¡B, 2=åˆå¹¶
    transitions.insert(0);
    transitions.insert(1);
    transitions.insert(2);

    // æµå…³ç³»ï¼ˆANDåˆ†æ”¯ï¼‰
    flow_relation.insert((0, 0)); // å¼€å§‹ -> ä»»åŠ¡A
    flow_relation.insert((0, 1)); // å¼€å§‹ -> ä»»åŠ¡B
    flow_relation.insert((0, 1)); // ä»»åŠ¡A -> ä»»åŠ¡Aå®Œæˆ
    flow_relation.insert((1, 2)); // ä»»åŠ¡B -> ä»»åŠ¡Bå®Œæˆ
    flow_relation.insert((1, 2)); // ä»»åŠ¡Aå®Œæˆ -> åˆå¹¶
    flow_relation.insert((2, 2)); // ä»»åŠ¡Bå®Œæˆ -> åˆå¹¶
    flow_relation.insert((2, 3)); // åˆå¹¶ -> ç»“æŸ

    // åˆå§‹æ ‡è¯†
    initial_marking.insert(0, 1);
    initial_marking.insert(1, 0);
    initial_marking.insert(2, 0);
    initial_marking.insert(3, 0);

    PetriNet::new(places, transitions, flow_relation, initial_marking)
}
```

### 11.3. åˆ¶é€ ç³»ç»Ÿ

**çµæ´»åˆ¶é€ ç³»ç»Ÿå»ºæ¨¡**ï¼š

```rust
# [derive(Debug, Clone)]
struct ManufacturingSystem {
    petri_net: PetriNet,
    resource_mapping: HashMap<usize, String>,
    operation_mapping: HashMap<usize, String>,
}

impl ManufacturingSystem {
    fn new() -> Self {
        let mut places = HashSet::new();
        let mut transitions = HashSet::new();
        let mut flow_relation = HashSet::new();
        let mut initial_marking = HashMap::new();

        // ä½ç½®ï¼šèµ„æºå’Œå·¥ä»¶çŠ¶æ€
        // 0=æœºå™¨1ç©ºé—², 1=æœºå™¨2ç©ºé—², 2=åŸææ–™, 3=åŠæˆå“, 4=æˆå“
        for i in 0..5 {
            places.insert(i);
        }

        // å˜è¿ï¼šæ“ä½œ
        // 0=æœºå™¨1åŠ å·¥, 1=æœºå™¨2åŠ å·¥, 2=è¿è¾“
        for i in 0..3 {
            transitions.insert(i);
        }

        // æµå…³ç³»å®šä¹‰åˆ¶é€ æµç¨‹
        flow_relation.insert((0, 0)); // æœºå™¨1ç©ºé—² -> æœºå™¨1åŠ å·¥
        flow_relation.insert((2, 0)); // åŸææ–™ -> æœºå™¨1åŠ å·¥
        flow_relation.insert((0, 0)); // æœºå™¨1åŠ å·¥ -> æœºå™¨1ç©ºé—²
        flow_relation.insert((0, 3)); // æœºå™¨1åŠ å·¥ -> åŠæˆå“

        // åˆå§‹æ ‡è¯†
        initial_marking.insert(0, 1); // 1å°æœºå™¨1
        initial_marking.insert(1, 1); // 1å°æœºå™¨2
        initial_marking.insert(2, 5); // 5ä¸ªåŸææ–™
        initial_marking.insert(3, 0);
        initial_marking.insert(4, 0);

        let petri_net = PetriNet::new(places, transitions, flow_relation, initial_marking);

        let mut resource_mapping = HashMap::new();
        resource_mapping.insert(0, "Machine1".to_string());
        resource_mapping.insert(1, "Machine2".to_string());

        let mut operation_mapping = HashMap::new();
        operation_mapping.insert(0, "Processing1".to_string());
        operation_mapping.insert(1, "Processing2".to_string());
        operation_mapping.insert(2, "Transport".to_string());

        ManufacturingSystem {
            petri_net,
            resource_mapping,
            operation_mapping,
        }
    }

    fn simulate_production(&self, steps: usize) -> Vec<Marking> {
        let mut markings = Vec::new();
        let mut current_marking = Marking::new(self.petri_net.initial_marking.clone());
        markings.push(current_marking.clone());

        for _ in 0..steps {
            let enabled = self.petri_net.enabled_transitions(&current_marking);
            if enabled.is_empty() {
                break;
            }

            // é€‰æ‹©ç¬¬ä¸€ä¸ªä½¿èƒ½çš„å˜è¿è§¦å‘
            if let Some(new_marking) = self.petri_net.fire_transition(enabled[0], &current_marking) {
                current_marking = new_marking;
                markings.push(current_marking.clone());
            }
        }

        markings
    }
}
```

## 12. æœ¬åœ°è·³è½¬ä¸äº¤å‰å¼•ç”¨

- [è·³è½¬åˆ°ç±»å‹ç†è®ºåŸºç¡€](../2.1-ç±»å‹ç†è®º/2.1.1-ç±»å‹ç†è®ºåŸºç¡€.md)
- [è·³è½¬åˆ°è‡ªåŠ¨æœºç†è®ºåŸºç¡€](../2.2-è‡ªåŠ¨æœºç†è®º/2.2.1-è‡ªåŠ¨æœºç†è®ºåŸºç¡€.md)
- [è·³è½¬åˆ°æ—¶æ€é€»è¾‘æ§åˆ¶ç†è®º](../2.4-æ—¶æ€é€»è¾‘æ§åˆ¶ç†è®º/2.4.1-æ—¶æ€é€»è¾‘æ§åˆ¶ç†è®ºåŸºç¡€.md)
- [è·³è½¬åˆ°åˆ†å¸ƒå¼ç³»ç»Ÿç†è®º](../2.5-åˆ†å¸ƒå¼ç³»ç»Ÿç†è®º/2.5.1-åˆ†å¸ƒå¼ç³»ç»Ÿç†è®ºåŸºç¡€.md)
- [è·³è½¬åˆ°æ•°æ®ç§‘å­¦åŸºç¡€ç†è®º](../../3-æ•°æ®æ¨¡å‹ä¸ç®—æ³•/3.1-åŸºç¡€ç†è®º/3.1.1-æ•°æ®ç§‘å­¦åŸºç¡€ç†è®ºæ¡†æ¶.md)
- [è·³è½¬åˆ°å¹¶å‘æ§åˆ¶ç®—æ³•](../../3-æ•°æ®æ¨¡å‹ä¸ç®—æ³•/3.3-ç®—æ³•å®ç°/3.3.3-å¹¶å‘æ§åˆ¶ç®—æ³•.md)
- [è·³è½¬åˆ°è½¯ä»¶æ¶æ„åŸºç¡€ç†è®º](../../4-è½¯ä»¶æ¶æ„ä¸å·¥ç¨‹/4.1-åŸºç¡€ç†è®º/4.1.1-è½¯ä»¶æ¶æ„åŸºç¡€ç†è®º.md)

---

**ç‰ˆæœ¬ä¿¡æ¯**ï¼šv1.0
**æœ€åæ›´æ–°**ï¼š2024å¹´12æœˆ
**æ–‡æ¡£çŠ¶æ€**ï¼šå·²å®ŒæˆåŸºç¡€å†…å®¹ï¼Œå¾…è¡¥å……é«˜çº§åˆ†ææŠ€æœ¯

## 13. å¤šè¡¨å¾

Petriç½‘ç†è®ºåŸºç¡€æ”¯æŒå¤šç§è¡¨å¾æ–¹å¼ï¼ŒåŒ…æ‹¬ï¼š

- ç¬¦å·è¡¨å¾ï¼ˆåº“æ‰€ã€å˜è¿ã€æ ‡è¯†ã€Petriç½‘å…¬å¼ç­‰ï¼‰
- å›¾ç»“æ„ï¼ˆPetriç½‘å›¾ã€å˜è¿å›¾ã€çŠ¶æ€å›¾ç­‰ï¼‰
- å‘é‡/å¼ é‡ï¼ˆåº“æ‰€å‘é‡ã€æ ‡è¯†åµŒå…¥ï¼‰
- è‡ªç„¶è¯­è¨€ï¼ˆå®šä¹‰ã€æ³¨é‡Šã€æè¿°ï¼‰
- å›¾åƒ/å¯è§†åŒ–ï¼ˆPetriç½‘ç»“æ„å›¾ã€æµç¨‹å›¾ç­‰ï¼‰
è¿™äº›è¡¨å¾å¯äº’æ˜ ï¼Œæå‡Petriç½‘ç†è®ºè¡¨è¾¾åŠ›ã€‚

## 14. å½¢å¼åŒ–è¯­ä¹‰

- è¯­ä¹‰åŸŸï¼š$D$ï¼Œå¦‚åº“æ‰€é›†åˆã€å˜è¿é›†åˆã€æ ‡è¯†ç©ºé—´ã€Petriç½‘æ¨¡å‹ç©ºé—´
- è§£é‡Šå‡½æ•°ï¼š$I: S \to D$ï¼Œå°†ç¬¦å·/ç»“æ„æ˜ å°„åˆ°å…·ä½“Petriç½‘è¯­ä¹‰å¯¹è±¡
- è¯­ä¹‰ä¸€è‡´æ€§ï¼šæ¯ä¸ªPetriç½‘ç»“æ„/å…¬å¼åœ¨$D$ä¸­æœ‰æ˜ç¡®å®šä¹‰

## 15. å½¢å¼åŒ–è¯­æ³•ä¸è¯æ˜

- è¯­æ³•è§„åˆ™ï¼šå¦‚Petriç½‘äº§ç”Ÿå¼ã€æ¨ç†è§„åˆ™ã€çº¦æŸæ¡ä»¶
- **å®šç†**ï¼šPetriç½‘ç†è®ºåŸºç¡€çš„è¯­æ³•ç³»ç»Ÿå…·ä¸€è‡´æ€§ä¸å¯æ‰©å±•æ€§ã€‚
- **è¯æ˜**ï¼šç”±Petriç½‘äº§ç”Ÿå¼ä¸æ¨ç†è§„åˆ™é€’å½’å®šä¹‰ï¼Œä¿è¯ç³»ç»Ÿä¸€è‡´ä¸å¯æ‰©å±•ã€‚
