# åˆ†å¸ƒå¼ç³»ç»Ÿç†è®ºå®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [åˆ†å¸ƒå¼ç³»ç»Ÿç†è®ºå®è·µæ¡ˆä¾‹](#åˆ†å¸ƒå¼ç³»ç»Ÿç†è®ºå®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. ç›®å½•](#1-ç›®å½•)
  - [2. åˆ†å¸ƒå¼ä¸€è‡´æ€§åè®®å®è·µæ¡ˆä¾‹](#2-åˆ†å¸ƒå¼ä¸€è‡´æ€§åè®®å®è·µæ¡ˆä¾‹)
    - [2.1. Raftå…±è¯†ç®—æ³•å®ç°](#21-raftå…±è¯†ç®—æ³•å®ç°)
  - [3. Paxosç®—æ³•å®ç°](#3-paxosç®—æ³•å®ç°)
  - [4. åˆ†å¸ƒå¼ç®—æ³•å®è·µæ¡ˆä¾‹](#4-åˆ†å¸ƒå¼ç®—æ³•å®è·µæ¡ˆä¾‹)
    - [4.1. åˆ†å¸ƒå¼å“ˆå¸Œè¡¨(DHT)](#41-åˆ†å¸ƒå¼å“ˆå¸Œè¡¨dht)
  - [5. åˆ†å¸ƒå¼é”](#5-åˆ†å¸ƒå¼é”)
  - [6. å®¹é”™æœºåˆ¶å®è·µæ¡ˆä¾‹](#6-å®¹é”™æœºåˆ¶å®è·µæ¡ˆä¾‹)
    - [6.1. æ•…éšœæ£€æµ‹å™¨](#61-æ•…éšœæ£€æµ‹å™¨)
  - [7. æ•…éšœæ¢å¤æœºåˆ¶](#7-æ•…éšœæ¢å¤æœºåˆ¶)
  - [8. åˆ†å¸ƒå¼åè°ƒå®è·µæ¡ˆä¾‹](#8-åˆ†å¸ƒå¼åè°ƒå®è·µæ¡ˆä¾‹)
    - [8.1. åˆ†å¸ƒå¼ä»»åŠ¡è°ƒåº¦å™¨](#81-åˆ†å¸ƒå¼ä»»åŠ¡è°ƒåº¦å™¨)
  - [9. æ€»ç»“](#9-æ€»ç»“)

---


æœ¬æ–‡æ¡£æä¾›åˆ†å¸ƒå¼ç³»ç»Ÿç†è®ºçš„å®è·µæ¡ˆä¾‹ï¼Œæ¶µç›–åˆ†å¸ƒå¼ç®—æ³•ã€ä¸€è‡´æ€§åè®®ã€å®¹é”™æœºåˆ¶ç­‰æ ¸å¿ƒæ¦‚å¿µçš„å®é™…åº”ç”¨ã€‚

## 1. ç›®å½•

- [åˆ†å¸ƒå¼ç³»ç»Ÿç†è®ºå®è·µæ¡ˆä¾‹](#åˆ†å¸ƒå¼ç³»ç»Ÿç†è®ºå®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. ç›®å½•](#1-ç›®å½•)
  - [2. åˆ†å¸ƒå¼ä¸€è‡´æ€§åè®®å®è·µæ¡ˆä¾‹](#2-åˆ†å¸ƒå¼ä¸€è‡´æ€§åè®®å®è·µæ¡ˆä¾‹)
    - [2.1. Raftå…±è¯†ç®—æ³•å®ç°](#21-raftå…±è¯†ç®—æ³•å®ç°)
  - [3. Paxosç®—æ³•å®ç°](#3-paxosç®—æ³•å®ç°)
  - [4. åˆ†å¸ƒå¼ç®—æ³•å®è·µæ¡ˆä¾‹](#4-åˆ†å¸ƒå¼ç®—æ³•å®è·µæ¡ˆä¾‹)
    - [4.1. åˆ†å¸ƒå¼å“ˆå¸Œè¡¨(DHT)](#41-åˆ†å¸ƒå¼å“ˆå¸Œè¡¨dht)
  - [5. åˆ†å¸ƒå¼é”](#5-åˆ†å¸ƒå¼é”)
  - [6. å®¹é”™æœºåˆ¶å®è·µæ¡ˆä¾‹](#6-å®¹é”™æœºåˆ¶å®è·µæ¡ˆä¾‹)
    - [6.1. æ•…éšœæ£€æµ‹å™¨](#61-æ•…éšœæ£€æµ‹å™¨)
  - [7. æ•…éšœæ¢å¤æœºåˆ¶](#7-æ•…éšœæ¢å¤æœºåˆ¶)
  - [8. åˆ†å¸ƒå¼åè°ƒå®è·µæ¡ˆä¾‹](#8-åˆ†å¸ƒå¼åè°ƒå®è·µæ¡ˆä¾‹)
    - [8.1. åˆ†å¸ƒå¼ä»»åŠ¡è°ƒåº¦å™¨](#81-åˆ†å¸ƒå¼ä»»åŠ¡è°ƒåº¦å™¨)
  - [9. æ€»ç»“](#9-æ€»ç»“)

## 2. åˆ†å¸ƒå¼ä¸€è‡´æ€§åè®®å®è·µæ¡ˆä¾‹

### 2.1. Raftå…±è¯†ç®—æ³•å®ç°

```python
import random
import time
from enum import Enum

class State(Enum):
    FOLLOWER = "follower"
    CANDIDATE = "candidate"
    LEADER = "leader"

class RaftNode:
    """Raftå…±è¯†ç®—æ³•èŠ‚ç‚¹"""

    def __init__(self, node_id: int, nodes: list):
        self.node_id = node_id
        self.nodes = nodes
        self.state = State.FOLLOWER
        self.current_term = 0
        self.voted_for = None
        self.log = []
        self.commit_index = 0

    def start_election(self):
        """å¼€å§‹é€‰ä¸¾"""
        self.state = State.CANDIDATE
        self.current_term += 1
        self.voted_for = self.node_id

        votes_received = 1
        for node in self.nodes:
            if node != self.node_id and self.request_vote(node):
                votes_received += 1

        if votes_received > len(self.nodes) // 2:
            self.become_leader()

    def become_leader(self):
        """æˆä¸ºé¢†å¯¼è€…"""
        self.state = State.LEADER
        print(f"èŠ‚ç‚¹ {self.node_id} æˆä¸ºé¢†å¯¼è€…")

    def request_vote(self, target_node: int) -> bool:
        """è¯·æ±‚æŠ•ç¥¨"""
        return random.choice([True, False])

    def apply_command(self, command: str):
        """åº”ç”¨å‘½ä»¤"""
        if self.state == State.LEADER:
            self.log.append({"term": self.current_term, "command": command})
            print(f"é¢†å¯¼è€… {self.node_id} æ·»åŠ æ—¥å¿—: {command}")

# ä½¿ç”¨ç¤ºä¾‹
def simulate_raft():
    nodes = [1, 2, 3, 4, 5]
    raft_nodes = {node_id: RaftNode(node_id, nodes) for node_id in nodes}

    for node in raft_nodes.values():
        node.start_election()

    leader = next(node for node in raft_nodes.values() if node.state == State.LEADER)
    leader.apply_command("SET key1 value1")
```

## 3. Paxosç®—æ³•å®ç°

```python
class PaxosProposer:
    """Paxosæè®®è€…"""

    def __init__(self, proposer_id: int):
        self.proposer_id = proposer_id
        self.proposal_number = 0

    def propose(self, acceptors: list, value: str) -> bool:
        """æè®®å€¼"""
        self.proposal_number += 1

# å‡†å¤‡é˜¶æ®µ
        promises = []
        for acceptor in acceptors:
            if self.send_prepare(acceptor):
                promises.append({"accepted": True})

        if len(promises) > len(acceptors) // 2:
# æ¥å—é˜¶æ®µ
            accepts = []
            for acceptor in acceptors:
                if self.send_accept(acceptor, value):
                    accepts.append({"accepted": True})

            return len(accepts) > len(acceptors) // 2
        return False

    def send_prepare(self, acceptor: int) -> bool:
        """å‘é€å‡†å¤‡è¯·æ±‚"""
        return random.random() > 0.3

    def send_accept(self, acceptor: int, value: str) -> bool:
        """å‘é€æ¥å—è¯·æ±‚"""
        return random.random() > 0.3

# ä½¿ç”¨ç¤ºä¾‹
def simulate_paxos():
    acceptors = [1, 2, 3, 4, 5]
    proposer = PaxosProposer(1)

    success = proposer.propose(acceptors, "SET key value")
    print(f"Paxosæè®®ç»“æœ: {success}")
```

## 4. åˆ†å¸ƒå¼ç®—æ³•å®è·µæ¡ˆä¾‹

### 4.1. åˆ†å¸ƒå¼å“ˆå¸Œè¡¨(DHT)

```python
import hashlib

class DHTNode:
    """åˆ†å¸ƒå¼å“ˆå¸Œè¡¨èŠ‚ç‚¹"""

    def __init__(self, node_id: str):
        self.node_id = node_id
        self.hash_id = self.hash_key(node_id)
        self.data = {}
        self.successor = None
        self.predecessor = None

    def hash_key(self, key: str) -> int:
        """è®¡ç®—å“ˆå¸Œå€¼"""
        return int(hashlib.md5(key.encode()).hexdigest(), 16) % (2**160)

    def store(self, key: str, value: str):
        """å­˜å‚¨é”®å€¼å¯¹"""
        key_hash = self.hash_key(key)

        if self.is_responsible_for(key_hash):
            self.data[key] = value
            print(f"èŠ‚ç‚¹ {self.node_id} å­˜å‚¨: {key} -> {value}")
            return True
        elif self.successor:
            return self.successor.store(key, value)
        return False

    def lookup(self, key: str):
        """æŸ¥æ‰¾é”®å€¼å¯¹"""
        key_hash = self.hash_key(key)

        if self.is_responsible_for(key_hash):
            value = self.data.get(key)
            print(f"èŠ‚ç‚¹ {self.node_id} æŸ¥æ‰¾: {key} -> {value}")
            return value
        elif self.successor:
            return self.successor.lookup(key)
        return None

    def is_responsible_for(self, key_hash: int) -> bool:
        """æ£€æŸ¥æ˜¯å¦è´Ÿè´£è¯¥é”®"""
        if self.predecessor is None:
            return True
        pred_hash = self.predecessor.hash_id
        if pred_hash < self.hash_id:
            return key_hash > pred_hash and key_hash <= self.hash_id
        else:
            return key_hash > pred_hash or key_hash <= self.hash_id

# ä½¿ç”¨ç¤ºä¾‹
def simulate_dht():
    nodes = [DHTNode(f"node{i}") for i in range(1, 4)]

# æ„å»ºç¯å½¢ç½‘ç»œ
    for i in range(len(nodes)):
        nodes[i].successor = nodes[(i + 1) % len(nodes)]
        nodes[i].predecessor = nodes[(i - 1) % len(nodes)]

    nodes[0].store("key1", "value1")
    nodes[1].lookup("key1")
```

## 5. åˆ†å¸ƒå¼é”

```python
class DistributedLock:
    """åˆ†å¸ƒå¼é”"""

    def __init__(self, lock_name: str, nodes: list):
        self.lock_name = lock_name
        self.nodes = nodes
        self.owner = None
        self.lock_id = None

    def acquire(self, timeout: int = 10) -> bool:
        """è·å–é”"""
        self.lock_id = f"{self.lock_name}_{int(time.time() * 1000)}"

        for _ in range(timeout * 10):
            if self.try_acquire():
                return True
            time.sleep(0.1)
        return False

    def try_acquire(self) -> bool:
        """å°è¯•è·å–é”"""
        if self.owner is None:
            success_count = 0
            for node in self.nodes:
                if self.request_lock(node):
                    success_count += 1

            if success_count > len(self.nodes) // 2:
                self.owner = self.lock_id
                print(f"é” {self.lock_name} è¢« {self.lock_id} è·å–")
                return True
        return False

    def release(self) -> bool:
        """é‡Šæ”¾é”"""
        if self.owner == self.lock_id:
            success_count = 0
            for node in self.nodes:
                if self.release_lock(node):
                    success_count += 1

            if success_count > len(self.nodes) // 2:
                self.owner = None
                print(f"é” {self.lock_name} è¢«é‡Šæ”¾")
                return True
        return False

    def request_lock(self, node: str) -> bool:
        """è¯·æ±‚é”"""
        return random.random() > 0.2

    def release_lock(self, node: str) -> bool:
        """é‡Šæ”¾é”"""
        return random.random() > 0.2

# ä½¿ç”¨ç¤ºä¾‹
def simulate_distributed_lock():
    nodes = ["node1", "node2", "node3", "node4", "node5"]
    lock = DistributedLock("shared_resource", nodes)

    if lock.acquire(timeout=5):
        print("è·å–é”æˆåŠŸ")
        time.sleep(1)
        lock.release()
    else:
        print("è·å–é”å¤±è´¥")
```

## 6. å®¹é”™æœºåˆ¶å®è·µæ¡ˆä¾‹

### 6.1. æ•…éšœæ£€æµ‹å™¨

```python
class FailureDetector:
    """æ•…éšœæ£€æµ‹å™¨"""

    def __init__(self, node_id: str, nodes: list):
        self.node_id = node_id
        self.nodes = nodes
        self.suspected_nodes = set()
        self.last_heartbeat = {node: time.time() for node in nodes if node != node_id}
        self.timeout = 5.0

    def check_failures(self):
        """æ£€æŸ¥æ•…éšœ"""
        current_time = time.time()

        for node in self.nodes:
            if node != self.node_id:
                if current_time - self.last_heartbeat[node] > self.timeout:
                    if node not in self.suspected_nodes:
                        self.suspected_nodes.add(node)
                        print(f"èŠ‚ç‚¹ {node} è¢«æ€€ç–‘æ•…éšœ")
                else:
                    if node in self.suspected_nodes:
                        self.suspected_nodes.remove(node)
                        print(f"èŠ‚ç‚¹ {node} æ¢å¤è¿æ¥")

    def receive_heartbeat(self, from_node: str):
        """æ¥æ”¶å¿ƒè·³"""
        self.last_heartbeat[from_node] = time.time()
        self.suspected_nodes.discard(from_node)

    def get_suspected_nodes(self):
        """è·å–è¢«æ€€ç–‘æ•…éšœçš„èŠ‚ç‚¹"""
        return self.suspected_nodes.copy()

# ä½¿ç”¨ç¤ºä¾‹
def simulate_failure_detection():
    nodes = ["node1", "node2", "node3", "node4"]
    detector = FailureDetector("node1", nodes)

# æ¨¡æ‹Ÿå¿ƒè·³
    for i in range(10):
        for node in nodes[1:]:
            if random.random() > 0.3:
                detector.receive_heartbeat(node)
        detector.check_failures()
        time.sleep(1)

    print(f"è¢«æ€€ç–‘æ•…éšœçš„èŠ‚ç‚¹: {detector.get_suspected_nodes()}")
```

## 7. æ•…éšœæ¢å¤æœºåˆ¶

```python
class FaultTolerantSystem:
    """å®¹é”™ç³»ç»Ÿ"""

    def __init__(self, nodes: list):
        self.nodes = nodes
        self.primary_node = nodes[0]
        self.backup_nodes = nodes[1:]
        self.data = {}
        self.operation_log = []

    def write_data(self, key: str, value: str) -> bool:
        """å†™å…¥æ•°æ®"""
        if self.write_to_node(self.primary_node, key, value):
            sync_success = 0
            for backup in self.backup_nodes:
                if self.write_to_node(backup, key, value):
                    sync_success += 1

            self.operation_log.append({
                'operation': 'write',
                'key': key,
                'value': value,
                'timestamp': time.time()
            })

            return sync_success >= len(self.backup_nodes) // 2
        return False

    def read_data(self, key: str):
        """è¯»å–æ•°æ®"""
        value = self.read_from_node(self.primary_node, key)
        if value is not None:
            return value

        for backup in self.backup_nodes:
            value = self.read_from_node(backup, key)
            if value is not None:
                return value
        return None

    def handle_primary_failure(self):
        """å¤„ç†ä¸»èŠ‚ç‚¹æ•…éšœ"""
        print(f"ä¸»èŠ‚ç‚¹ {self.primary_node} æ•…éšœï¼Œå¼€å§‹æ•…éšœè½¬ç§»")

        if self.backup_nodes:
            new_primary = self.backup_nodes[0]
            self.primary_node = new_primary
            self.backup_nodes = self.backup_nodes[1:]

# æ¢å¤æ•°æ®
            for operation in self.operation_log:
                if operation['operation'] == 'write':
                    self.write_to_node(new_primary, operation['key'], operation['value'])

            print(f"æ•…éšœè½¬ç§»å®Œæˆï¼Œæ–°ä¸»èŠ‚ç‚¹: {new_primary}")

    def write_to_node(self, node: str, key: str, value: str) -> bool:
        """å‘æŒ‡å®šèŠ‚ç‚¹å†™å…¥æ•°æ®"""
        if random.random() > 0.1:
            self.data[f"{node}_{key}"] = value
            return True
        return False

    def read_from_node(self, node: str, key: str):
        """ä»æŒ‡å®šèŠ‚ç‚¹è¯»å–æ•°æ®"""
        if random.random() > 0.1:
            return self.data.get(f"{node}_{key}")
        return None

# ä½¿ç”¨ç¤ºä¾‹
def simulate_fault_tolerance():
    nodes = ["primary", "backup1", "backup2", "backup3"]
    system = FaultTolerantSystem(nodes)

    system.write_data("key1", "value1")
    system.write_data("key2", "value2")

    print(f"key1: {system.read_data('key1')}")
    print(f"key2: {system.read_data('key2')}")

    system.handle_primary_failure()

    print(f"æ•…éšœå key1: {system.read_data('key1')}")
    print(f"æ•…éšœå key2: {system.read_data('key2')}")
```

## 8. åˆ†å¸ƒå¼åè°ƒå®è·µæ¡ˆä¾‹

### 8.1. åˆ†å¸ƒå¼ä»»åŠ¡è°ƒåº¦å™¨

```python
class DistributedTaskScheduler:
    """åˆ†å¸ƒå¼ä»»åŠ¡è°ƒåº¦å™¨"""

    def __init__(self, nodes: list):
        self.nodes = nodes
        self.task_queue = []
        self.running_tasks = {}
        self.node_loads = {node: 0 for node in nodes}

    def submit_task(self, task_id: str, task_type: str, priority: int = 0):
        """æäº¤ä»»åŠ¡"""
        task = {
            'id': task_id,
            'type': task_type,
            'priority': priority,
            'status': 'pending',
            'submit_time': time.time()
        }

        self.task_queue.append(task)
        self.task_queue.sort(key=lambda x: x['priority'], reverse=True)
        print(f"ä»»åŠ¡ {task_id} å·²æäº¤")

    def schedule_tasks(self):
        """è°ƒåº¦ä»»åŠ¡"""
        while self.task_queue:
            task = self.task_queue[0]
            best_node = min(self.node_loads.items(), key=lambda x: x[1])[0]

            if self.assign_task_to_node(task, best_node):
                self.task_queue.pop(0)
                task['status'] = 'running'
                self.running_tasks[task['id']] = task
                self.node_loads[best_node] += 1
                print(f"ä»»åŠ¡ {task['id']} åˆ†é…ç»™èŠ‚ç‚¹ {best_node}")
            else:
                break

    def assign_task_to_node(self, task: dict, node: str) -> bool:
        """å°†ä»»åŠ¡åˆ†é…ç»™èŠ‚ç‚¹"""
        return random.random() > 0.2

    def complete_task(self, task_id: str, result: str):
        """å®Œæˆä»»åŠ¡"""
        if task_id in self.running_tasks:
            task = self.running_tasks[task_id]
            task['status'] = 'completed'
            task['result'] = result

# æ›´æ–°èŠ‚ç‚¹è´Ÿè½½
            for node, load in self.node_loads.items():
                if load > 0:
                    self.node_loads[node] -= 1
                    break

            print(f"ä»»åŠ¡ {task_id} å®Œæˆï¼Œç»“æœ: {result}")

    def get_system_status(self):
        """è·å–ç³»ç»ŸçŠ¶æ€"""
        return {
            'pending_tasks': len(self.task_queue),
            'running_tasks': len(self.running_tasks),
            'node_loads': self.node_loads.copy()
        }

# ä½¿ç”¨ç¤ºä¾‹
def simulate_task_scheduling():
    nodes = ["worker1", "worker2", "worker3", "worker4"]
    scheduler = DistributedTaskScheduler(nodes)

# æäº¤ä»»åŠ¡
    for i in range(5):
        scheduler.submit_task(f"task_{i}", "computation", priority=random.randint(1, 5))

# è°ƒåº¦ä»»åŠ¡
    scheduler.schedule_tasks()

# æ¨¡æ‹Ÿä»»åŠ¡å®Œæˆ
    for task_id in list(scheduler.running_tasks.keys()):
        if random.random() > 0.5:
            scheduler.complete_task(task_id, f"result_{task_id}")

    status = scheduler.get_system_status()
    print(f"ç³»ç»ŸçŠ¶æ€: {status}")
```

## 9. æ€»ç»“

æœ¬æ–‡æ¡£æä¾›äº†åˆ†å¸ƒå¼ç³»ç»Ÿç†è®ºçš„å®è·µæ¡ˆä¾‹ï¼Œæ¶µç›–ï¼š

1. **åˆ†å¸ƒå¼ä¸€è‡´æ€§åè®®**ï¼šRaftã€Paxosç®—æ³•å®ç°
2. **åˆ†å¸ƒå¼ç®—æ³•**ï¼šDHTã€åˆ†å¸ƒå¼é”å®ç°
3. **å®¹é”™æœºåˆ¶**ï¼šæ•…éšœæ£€æµ‹ã€æ•…éšœæ¢å¤
4. **åˆ†å¸ƒå¼åè°ƒ**ï¼šä»»åŠ¡è°ƒåº¦ã€è´Ÿè½½å‡è¡¡

è¿™äº›å®è·µæ¡ˆä¾‹å±•ç¤ºäº†åˆ†å¸ƒå¼ç³»ç»Ÿæ ¸å¿ƒæ¦‚å¿µçš„å®é™…åº”ç”¨ï¼Œå¸®åŠ©ç†è§£åˆ†å¸ƒå¼ç³»ç»Ÿçš„è®¾è®¡åŸç†å’Œå®ç°æ–¹æ³•ã€‚
