# 分布式系统理论实践案例

本文档提供分布式系统理论的实践案例，涵盖分布式算法、一致性协议、容错机制等核心概念的实际应用。

## 目录

- [1. 分布式一致性协议实践案例](#1-分布式一致性协议实践案例)
- [2. 分布式算法实践案例](#2-分布式算法实践案例)
- [3. 容错机制实践案例](#3-容错机制实践案例)
- [4. 分布式协调实践案例](#4-分布式协调实践案例)

## 1. 分布式一致性协议实践案例

### 1.1 Raft共识算法实现

```python
import random
import time
from enum import Enum

class State(Enum):
    FOLLOWER = "follower"
    CANDIDATE = "candidate"
    LEADER = "leader"

class RaftNode:
    """Raft共识算法节点"""
    
    def __init__(self, node_id: int, nodes: list):
        self.node_id = node_id
        self.nodes = nodes
        self.state = State.FOLLOWER
        self.current_term = 0
        self.voted_for = None
        self.log = []
        self.commit_index = 0
        
    def start_election(self):
        """开始选举"""
        self.state = State.CANDIDATE
        self.current_term += 1
        self.voted_for = self.node_id
        
        votes_received = 1
        for node in self.nodes:
            if node != self.node_id and self.request_vote(node):
                votes_received += 1
                
        if votes_received > len(self.nodes) // 2:
            self.become_leader()
            
    def become_leader(self):
        """成为领导者"""
        self.state = State.LEADER
        print(f"节点 {self.node_id} 成为领导者")
        
    def request_vote(self, target_node: int) -> bool:
        """请求投票"""
        return random.choice([True, False])
        
    def apply_command(self, command: str):
        """应用命令"""
        if self.state == State.LEADER:
            self.log.append({"term": self.current_term, "command": command})
            print(f"领导者 {self.node_id} 添加日志: {command}")

# 使用示例
def simulate_raft():
    nodes = [1, 2, 3, 4, 5]
    raft_nodes = {node_id: RaftNode(node_id, nodes) for node_id in nodes}
    
    for node in raft_nodes.values():
        node.start_election()
    
    leader = next(node for node in raft_nodes.values() if node.state == State.LEADER)
    leader.apply_command("SET key1 value1")
```

### 1.2 Paxos算法实现

```python
class PaxosProposer:
    """Paxos提议者"""
    
    def __init__(self, proposer_id: int):
        self.proposer_id = proposer_id
        self.proposal_number = 0
        
    def propose(self, acceptors: list, value: str) -> bool:
        """提议值"""
        self.proposal_number += 1
        
        # 准备阶段
        promises = []
        for acceptor in acceptors:
            if self.send_prepare(acceptor):
                promises.append({"accepted": True})
                
        if len(promises) > len(acceptors) // 2:
            # 接受阶段
            accepts = []
            for acceptor in acceptors:
                if self.send_accept(acceptor, value):
                    accepts.append({"accepted": True})
                    
            return len(accepts) > len(acceptors) // 2
        return False
        
    def send_prepare(self, acceptor: int) -> bool:
        """发送准备请求"""
        return random.random() > 0.3
        
    def send_accept(self, acceptor: int, value: str) -> bool:
        """发送接受请求"""
        return random.random() > 0.3

# 使用示例
def simulate_paxos():
    acceptors = [1, 2, 3, 4, 5]
    proposer = PaxosProposer(1)
    
    success = proposer.propose(acceptors, "SET key value")
    print(f"Paxos提议结果: {success}")
```

## 2. 分布式算法实践案例

### 2.1 分布式哈希表(DHT)

```python
import hashlib

class DHTNode:
    """分布式哈希表节点"""
    
    def __init__(self, node_id: str):
        self.node_id = node_id
        self.hash_id = self.hash_key(node_id)
        self.data = {}
        self.successor = None
        self.predecessor = None
        
    def hash_key(self, key: str) -> int:
        """计算哈希值"""
        return int(hashlib.md5(key.encode()).hexdigest(), 16) % (2**160)
        
    def store(self, key: str, value: str):
        """存储键值对"""
        key_hash = self.hash_key(key)
        
        if self.is_responsible_for(key_hash):
            self.data[key] = value
            print(f"节点 {self.node_id} 存储: {key} -> {value}")
            return True
        elif self.successor:
            return self.successor.store(key, value)
        return False
        
    def lookup(self, key: str):
        """查找键值对"""
        key_hash = self.hash_key(key)
        
        if self.is_responsible_for(key_hash):
            value = self.data.get(key)
            print(f"节点 {self.node_id} 查找: {key} -> {value}")
            return value
        elif self.successor:
            return self.successor.lookup(key)
        return None
        
    def is_responsible_for(self, key_hash: int) -> bool:
        """检查是否负责该键"""
        if self.predecessor is None:
            return True
        pred_hash = self.predecessor.hash_id
        if pred_hash < self.hash_id:
            return key_hash > pred_hash and key_hash <= self.hash_id
        else:
            return key_hash > pred_hash or key_hash <= self.hash_id

# 使用示例
def simulate_dht():
    nodes = [DHTNode(f"node{i}") for i in range(1, 4)]
    
    # 构建环形网络
    for i in range(len(nodes)):
        nodes[i].successor = nodes[(i + 1) % len(nodes)]
        nodes[i].predecessor = nodes[(i - 1) % len(nodes)]
    
    nodes[0].store("key1", "value1")
    nodes[1].lookup("key1")
```

### 2.2 分布式锁

```python
class DistributedLock:
    """分布式锁"""
    
    def __init__(self, lock_name: str, nodes: list):
        self.lock_name = lock_name
        self.nodes = nodes
        self.owner = None
        self.lock_id = None
        
    def acquire(self, timeout: int = 10) -> bool:
        """获取锁"""
        self.lock_id = f"{self.lock_name}_{int(time.time() * 1000)}"
        
        for _ in range(timeout * 10):
            if self.try_acquire():
                return True
            time.sleep(0.1)
        return False
        
    def try_acquire(self) -> bool:
        """尝试获取锁"""
        if self.owner is None:
            success_count = 0
            for node in self.nodes:
                if self.request_lock(node):
                    success_count += 1
                    
            if success_count > len(self.nodes) // 2:
                self.owner = self.lock_id
                print(f"锁 {self.lock_name} 被 {self.lock_id} 获取")
                return True
        return False
        
    def release(self) -> bool:
        """释放锁"""
        if self.owner == self.lock_id:
            success_count = 0
            for node in self.nodes:
                if self.release_lock(node):
                    success_count += 1
                    
            if success_count > len(self.nodes) // 2:
                self.owner = None
                print(f"锁 {self.lock_name} 被释放")
                return True
        return False
        
    def request_lock(self, node: str) -> bool:
        """请求锁"""
        return random.random() > 0.2
        
    def release_lock(self, node: str) -> bool:
        """释放锁"""
        return random.random() > 0.2

# 使用示例
def simulate_distributed_lock():
    nodes = ["node1", "node2", "node3", "node4", "node5"]
    lock = DistributedLock("shared_resource", nodes)
    
    if lock.acquire(timeout=5):
        print("获取锁成功")
        time.sleep(1)
        lock.release()
    else:
        print("获取锁失败")
```

## 3. 容错机制实践案例

### 3.1 故障检测器

```python
class FailureDetector:
    """故障检测器"""
    
    def __init__(self, node_id: str, nodes: list):
        self.node_id = node_id
        self.nodes = nodes
        self.suspected_nodes = set()
        self.last_heartbeat = {node: time.time() for node in nodes if node != node_id}
        self.timeout = 5.0
        
    def check_failures(self):
        """检查故障"""
        current_time = time.time()
        
        for node in self.nodes:
            if node != self.node_id:
                if current_time - self.last_heartbeat[node] > self.timeout:
                    if node not in self.suspected_nodes:
                        self.suspected_nodes.add(node)
                        print(f"节点 {node} 被怀疑故障")
                else:
                    if node in self.suspected_nodes:
                        self.suspected_nodes.remove(node)
                        print(f"节点 {node} 恢复连接")
                        
    def receive_heartbeat(self, from_node: str):
        """接收心跳"""
        self.last_heartbeat[from_node] = time.time()
        self.suspected_nodes.discard(from_node)
        
    def get_suspected_nodes(self):
        """获取被怀疑故障的节点"""
        return self.suspected_nodes.copy()

# 使用示例
def simulate_failure_detection():
    nodes = ["node1", "node2", "node3", "node4"]
    detector = FailureDetector("node1", nodes)
    
    # 模拟心跳
    for i in range(10):
        for node in nodes[1:]:
            if random.random() > 0.3:
                detector.receive_heartbeat(node)
        detector.check_failures()
        time.sleep(1)
        
    print(f"被怀疑故障的节点: {detector.get_suspected_nodes()}")
```

### 3.2 故障恢复机制

```python
class FaultTolerantSystem:
    """容错系统"""
    
    def __init__(self, nodes: list):
        self.nodes = nodes
        self.primary_node = nodes[0]
        self.backup_nodes = nodes[1:]
        self.data = {}
        self.operation_log = []
        
    def write_data(self, key: str, value: str) -> bool:
        """写入数据"""
        if self.write_to_node(self.primary_node, key, value):
            sync_success = 0
            for backup in self.backup_nodes:
                if self.write_to_node(backup, key, value):
                    sync_success += 1
                    
            self.operation_log.append({
                'operation': 'write',
                'key': key,
                'value': value,
                'timestamp': time.time()
            })
            
            return sync_success >= len(self.backup_nodes) // 2
        return False
        
    def read_data(self, key: str):
        """读取数据"""
        value = self.read_from_node(self.primary_node, key)
        if value is not None:
            return value
            
        for backup in self.backup_nodes:
            value = self.read_from_node(backup, key)
            if value is not None:
                return value
        return None
        
    def handle_primary_failure(self):
        """处理主节点故障"""
        print(f"主节点 {self.primary_node} 故障，开始故障转移")
        
        if self.backup_nodes:
            new_primary = self.backup_nodes[0]
            self.primary_node = new_primary
            self.backup_nodes = self.backup_nodes[1:]
            
            # 恢复数据
            for operation in self.operation_log:
                if operation['operation'] == 'write':
                    self.write_to_node(new_primary, operation['key'], operation['value'])
                    
            print(f"故障转移完成，新主节点: {new_primary}")
            
    def write_to_node(self, node: str, key: str, value: str) -> bool:
        """向指定节点写入数据"""
        if random.random() > 0.1:
            self.data[f"{node}_{key}"] = value
            return True
        return False
        
    def read_from_node(self, node: str, key: str):
        """从指定节点读取数据"""
        if random.random() > 0.1:
            return self.data.get(f"{node}_{key}")
        return None

# 使用示例
def simulate_fault_tolerance():
    nodes = ["primary", "backup1", "backup2", "backup3"]
    system = FaultTolerantSystem(nodes)
    
    system.write_data("key1", "value1")
    system.write_data("key2", "value2")
    
    print(f"key1: {system.read_data('key1')}")
    print(f"key2: {system.read_data('key2')}")
    
    system.handle_primary_failure()
    
    print(f"故障后 key1: {system.read_data('key1')}")
    print(f"故障后 key2: {system.read_data('key2')}")
```

## 4. 分布式协调实践案例

### 4.1 分布式任务调度器

```python
class DistributedTaskScheduler:
    """分布式任务调度器"""
    
    def __init__(self, nodes: list):
        self.nodes = nodes
        self.task_queue = []
        self.running_tasks = {}
        self.node_loads = {node: 0 for node in nodes}
        
    def submit_task(self, task_id: str, task_type: str, priority: int = 0):
        """提交任务"""
        task = {
            'id': task_id,
            'type': task_type,
            'priority': priority,
            'status': 'pending',
            'submit_time': time.time()
        }
        
        self.task_queue.append(task)
        self.task_queue.sort(key=lambda x: x['priority'], reverse=True)
        print(f"任务 {task_id} 已提交")
        
    def schedule_tasks(self):
        """调度任务"""
        while self.task_queue:
            task = self.task_queue[0]
            best_node = min(self.node_loads.items(), key=lambda x: x[1])[0]
            
            if self.assign_task_to_node(task, best_node):
                self.task_queue.pop(0)
                task['status'] = 'running'
                self.running_tasks[task['id']] = task
                self.node_loads[best_node] += 1
                print(f"任务 {task['id']} 分配给节点 {best_node}")
            else:
                break
                
    def assign_task_to_node(self, task: dict, node: str) -> bool:
        """将任务分配给节点"""
        return random.random() > 0.2
        
    def complete_task(self, task_id: str, result: str):
        """完成任务"""
        if task_id in self.running_tasks:
            task = self.running_tasks[task_id]
            task['status'] = 'completed'
            task['result'] = result
            
            # 更新节点负载
            for node, load in self.node_loads.items():
                if load > 0:
                    self.node_loads[node] -= 1
                    break
                    
            print(f"任务 {task_id} 完成，结果: {result}")
            
    def get_system_status(self):
        """获取系统状态"""
        return {
            'pending_tasks': len(self.task_queue),
            'running_tasks': len(self.running_tasks),
            'node_loads': self.node_loads.copy()
        }

# 使用示例
def simulate_task_scheduling():
    nodes = ["worker1", "worker2", "worker3", "worker4"]
    scheduler = DistributedTaskScheduler(nodes)
    
    # 提交任务
    for i in range(5):
        scheduler.submit_task(f"task_{i}", "computation", priority=random.randint(1, 5))
        
    # 调度任务
    scheduler.schedule_tasks()
    
    # 模拟任务完成
    for task_id in list(scheduler.running_tasks.keys()):
        if random.random() > 0.5:
            scheduler.complete_task(task_id, f"result_{task_id}")
            
    status = scheduler.get_system_status()
    print(f"系统状态: {status}")
```

## 总结

本文档提供了分布式系统理论的实践案例，涵盖：

1. **分布式一致性协议**：Raft、Paxos算法实现
2. **分布式算法**：DHT、分布式锁实现
3. **容错机制**：故障检测、故障恢复
4. **分布式协调**：任务调度、负载均衡

这些实践案例展示了分布式系统核心概念的实际应用，帮助理解分布式系统的设计原理和实现方法。
