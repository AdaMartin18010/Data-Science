# 时态逻辑控制理论实践案例

本文档提供时态逻辑控制理论的实践案例，涵盖线性时态逻辑(LTL)、计算树逻辑(CTL)、CTL*等时态逻辑的实际应用。

## 目录

- [1. 线性时态逻辑(LTL)实践案例](#1-线性时态逻辑ltl实践案例)
- [2. 计算树逻辑(CTL)实践案例](#2-计算树逻辑ctl实践案例)
- [3. CTL*综合实践案例](#3-ctl综合实践案例)
- [4. 模型检测实践案例](#4-模型检测实践案例)
- [5. 实时系统验证实践案例](#5-实时系统验证实践案例)

## 1. 线性时态逻辑(LTL)实践案例

### 1.1 交通信号灯系统建模

```python
import spot
from spot import formula

class TrafficLightSystem:
    """交通信号灯系统LTL建模"""
    
    def __init__(self):
        self.automaton = None
        
    def create_traffic_light_model(self):
        """创建交通信号灯系统模型"""
        # LTL公式：红灯和绿灯不能同时亮
        ltl_formula = "G(!(red & green))"
        
        # 创建自动机
        self.automaton = spot.translate(ltl_formula, 'BA', 'complete')
        
        return self.automaton
    
    def verify_safety_property(self):
        """验证安全性属性"""
        # 安全性属性：总是最终会变绿
        safety_formula = "G(F green)"
        
        # 检查属性是否满足
        result = spot.translate(safety_formula, 'BA', 'complete')
        
        return result.is_empty()
    
    def check_mutual_exclusion(self):
        """检查互斥性"""
        # 互斥性：红灯、黄灯、绿灯不能同时亮
        mutex_formula = "G(!(red & yellow) & !(red & green) & !(yellow & green))"
        
        result = spot.translate(mutex_formula, 'BA', 'complete')
        
        return not result.is_empty()

# 使用示例
traffic_system = TrafficLightSystem()
automaton = traffic_system.create_traffic_light_model()
print("交通信号灯模型创建完成")
print(f"安全性验证: {traffic_system.verify_safety_property()}")
print(f"互斥性检查: {traffic_system.check_mutual_exclusion()}")
```

### 1.2 电梯系统LTL建模

```python
class ElevatorSystem:
    """电梯系统LTL建模"""
    
    def __init__(self):
        self.floor_count = 5
        self.current_floor = 1
        
    def create_elevator_model(self):
        """创建电梯系统模型"""
        # LTL公式集合
        formulas = [
            # 电梯不能同时向上和向下
            "G(!(going_up & going_down))",
            # 电梯总是最终会到达请求的楼层
            "G(request_floor -> F at_floor)",
            # 电梯门在移动时必须关闭
            "G((going_up | going_down) -> door_closed)",
            # 电梯不能超出楼层范围
            "G(at_floor -> (floor >= 1 & floor <= 5))"
        ]
        
        return formulas
    
    def verify_elevator_properties(self):
        """验证电梯系统属性"""
        properties = {
            "safety": "G(!(going_up & going_down))",
            "liveness": "G(request_floor -> F at_floor)",
            "safety_door": "G((going_up | going_down) -> door_closed)",
            "bounds": "G(at_floor -> (floor >= 1 & floor <= 5))"
        }
        
        results = {}
        for name, formula in properties.items():
            result = spot.translate(formula, 'BA', 'complete')
            results[name] = not result.is_empty()
            
        return results

# 使用示例
elevator = ElevatorSystem()
formulas = elevator.create_elevator_model()
results = elevator.verify_elevator_properties()

print("电梯系统LTL模型:")
for i, formula in enumerate(formulas, 1):
    print(f"{i}. {formula}")

print("\n属性验证结果:")
for prop, result in results.items():
    print(f"{prop}: {result}")
```

## 2. 计算树逻辑(CTL)实践案例

### 2.1 并发系统CTL建模

```python
class ConcurrentSystem:
    """并发系统CTL建模"""
    
    def __init__(self):
        self.processes = 2
        self.states = {}
        
    def create_concurrent_model(self):
        """创建并发系统模型"""
        # CTL公式集合
        ctl_formulas = [
            # 互斥性：两个进程不能同时进入临界区
            "AG(!(in_critical_1 & in_critical_2))",
            # 无饥饿性：每个进程最终都能进入临界区
            "AG(trying_1 -> AF in_critical_1)",
            "AG(trying_2 -> AF in_critical_2)",
            # 安全性：进程不能无限期等待
            "AG(trying_1 -> EF in_critical_1)",
            "AG(trying_2 -> EF in_critical_2)"
        ]
        
        return ctl_formulas
    
    def verify_mutual_exclusion(self):
        """验证互斥性"""
        # 互斥性CTL公式
        mutex_formula = "AG(!(in_critical_1 & in_critical_2))"
        
        # 这里应该使用CTL模型检测器
        # 简化示例，返回布尔值
        return True
    
    def verify_no_starvation(self):
        """验证无饥饿性"""
        # 无饥饿性CTL公式
        no_starvation_1 = "AG(trying_1 -> AF in_critical_1)"
        no_starvation_2 = "AG(trying_2 -> AF in_critical_2)"
        
        return True, True

# 使用示例
concurrent_system = ConcurrentSystem()
ctl_formulas = concurrent_system.create_concurrent_model()

print("并发系统CTL模型:")
for i, formula in enumerate(ctl_formulas, 1):
    print(f"{i}. {formula}")

mutex = concurrent_system.verify_mutual_exclusion()
no_starvation = concurrent_system.verify_no_starvation()

print(f"\n互斥性验证: {mutex}")
print(f"无饥饿性验证: {no_starvation}")
```

### 2.2 协议验证CTL建模

```python
class ProtocolVerification:
    """协议验证CTL建模"""
    
    def __init__(self):
        self.protocol_states = ['idle', 'sending', 'waiting', 'received']
        
    def create_protocol_model(self):
        """创建协议模型"""
        # CTL公式集合
        protocol_formulas = [
            # 协议总是能回到空闲状态
            "AG(EF idle)",
            # 发送后总是等待响应
            "AG(sending -> AX waiting)",
            # 不会永远等待
            "AG(waiting -> AF (received | idle))",
            # 接收后总是回到空闲
            "AG(received -> AX idle)"
        ]
        
        return protocol_formulas
    
    def verify_protocol_properties(self):
        """验证协议属性"""
        properties = {
            "liveness": "AG(EF idle)",
            "safety": "AG(sending -> AX waiting)",
            "progress": "AG(waiting -> AF (received | idle))",
            "termination": "AG(received -> AX idle)"
        }
        
        results = {}
        for name, formula in properties.items():
            # 简化验证，实际应使用CTL模型检测器
            results[name] = True
            
        return results

# 使用示例
protocol = ProtocolVerification()
formulas = protocol.create_protocol_model()
results = protocol.verify_protocol_properties()

print("协议CTL模型:")
for i, formula in enumerate(formulas, 1):
    print(f"{i}. {formula}")

print("\n协议属性验证:")
for prop, result in results.items():
    print(f"{prop}: {result}")
```

## 3. CTL*综合实践案例

### 3.1 分布式系统CTL*建模

```python
class DistributedSystem:
    """分布式系统CTL*建模"""
    
    def __init__(self):
        self.nodes = 3
        self.consensus_states = ['propose', 'prepare', 'commit', 'decide']
        
    def create_distributed_model(self):
        """创建分布式系统模型"""
        # CTL*公式集合
        ctl_star_formulas = [
            # 一致性：所有节点最终达成相同决定
            "AG(EF (decide_1 & decide_2 & decide_3 & (value_1 = value_2 = value_3)))",
            # 有效性：如果所有节点提议相同值，则决定该值
            "AG((propose_1 = propose_2 = propose_3) -> AF (decide_1 = decide_2 = decide_3 = propose_1))",
            # 终止性：每个节点最终都会做出决定
            "AG(AF (decide_1 | decide_2 | decide_3))"
        ]
        
        return ctl_star_formulas
    
    def verify_consensus_properties(self):
        """验证共识属性"""
        properties = {
            "agreement": "AG(EF (decide_1 & decide_2 & decide_3 & (value_1 = value_2 = value_3)))",
            "validity": "AG((propose_1 = propose_2 = propose_3) -> AF (decide_1 = decide_2 = decide_3 = propose_1))",
            "termination": "AG(AF (decide_1 | decide_2 | decide_3))"
        }
        
        return properties

# 使用示例
distributed = DistributedSystem()
formulas = distributed.create_distributed_model()
properties = distributed.verify_consensus_properties()

print("分布式系统CTL*模型:")
for i, formula in enumerate(formulas, 1):
    print(f"{i}. {formula}")

print("\n共识属性:")
for prop, formula in properties.items():
    print(f"{prop}: {formula}")
```

## 4. 模型检测实践案例

### 4.1 状态空间探索

```python
class ModelChecker:
    """模型检测器"""
    
    def __init__(self):
        self.states = set()
        self.transitions = {}
        
    def add_state(self, state):
        """添加状态"""
        self.states.add(state)
        
    def add_transition(self, from_state, to_state, action):
        """添加转换"""
        if from_state not in self.transitions:
            self.transitions[from_state] = []
        self.transitions[from_state].append((to_state, action))
        
    def explore_state_space(self, initial_state):
        """探索状态空间"""
        visited = set()
        queue = [initial_state]
        
        while queue:
            current_state = queue.pop(0)
            if current_state not in visited:
                visited.add(current_state)
                
                if current_state in self.transitions:
                    for next_state, action in self.transitions[current_state]:
                        if next_state not in visited:
                            queue.append(next_state)
                            
        return visited
    
    def check_reachability(self, initial_state, target_state):
        """检查可达性"""
        reachable_states = self.explore_state_space(initial_state)
        return target_state in reachable_states

# 使用示例
checker = ModelChecker()

# 添加状态
checker.add_state("idle")
checker.add_state("running")
checker.add_state("finished")
checker.add_state("error")

# 添加转换
checker.add_transition("idle", "running", "start")
checker.add_transition("running", "finished", "complete")
checker.add_transition("running", "error", "fail")
checker.add_transition("error", "idle", "reset")

# 探索状态空间
reachable = checker.explore_state_space("idle")
print(f"可达状态: {reachable}")

# 检查可达性
can_reach_finished = checker.check_reachability("idle", "finished")
print(f"能否到达finished状态: {can_reach_finished}")
```

## 5. 实时系统验证实践案例

### 5.1 实时任务调度验证

```python
import time
from datetime import datetime, timedelta

class RealTimeScheduler:
    """实时任务调度器"""
    
    def __init__(self):
        self.tasks = []
        self.current_time = 0
        
    def add_task(self, task_id, deadline, execution_time, priority):
        """添加任务"""
        task = {
            'id': task_id,
            'deadline': deadline,
            'execution_time': execution_time,
            'priority': priority,
            'start_time': None,
            'completion_time': None
        }
        self.tasks.append(task)
        
    def schedule_edf(self):
        """最早截止时间优先调度"""
        # 按截止时间排序
        sorted_tasks = sorted(self.tasks, key=lambda x: x['deadline'])
        
        current_time = 0
        for task in sorted_tasks:
            if current_time + task['execution_time'] <= task['deadline']:
                task['start_time'] = current_time
                task['completion_time'] = current_time + task['execution_time']
                current_time = task['completion_time']
            else:
                # 任务无法按时完成
                return False
                
        return True
    
    def verify_timing_constraints(self):
        """验证时间约束"""
        violations = []
        
        for task in self.tasks:
            if task['completion_time'] and task['completion_time'] > task['deadline']:
                violations.append({
                    'task_id': task['id'],
                    'deadline': task['deadline'],
                    'completion': task['completion_time'],
                    'violation': task['completion_time'] - task['deadline']
                })
                
        return violations

# 使用示例
scheduler = RealTimeScheduler()

# 添加实时任务
scheduler.add_task("T1", deadline=10, execution_time=3, priority=1)
scheduler.add_task("T2", deadline=8, execution_time=2, priority=2)
scheduler.add_task("T3", deadline=15, execution_time=5, priority=3)

# 执行调度
success = scheduler.schedule_edf()
print(f"EDF调度成功: {success}")

# 验证时间约束
violations = scheduler.verify_timing_constraints()
if violations:
    print("时间约束违反:")
    for violation in violations:
        print(f"任务 {violation['task_id']}: 超时 {violation['violation']} 单位时间")
else:
    print("所有任务都满足时间约束")

# 显示调度结果
print("\n调度结果:")
for task in scheduler.tasks:
    if task['start_time'] is not None:
        print(f"任务 {task['id']}: {task['start_time']} -> {task['completion_time']}")
```

### 5.2 实时系统LTL验证

```python
class RealTimeLTLVerifier:
    """实时系统LTL验证器"""
    
    def __init__(self):
        self.time_units = 0
        self.events = []
        
    def add_event(self, event, timestamp):
        """添加事件"""
        self.events.append((event, timestamp))
        self.events.sort(key=lambda x: x[1])
        
    def verify_response_time(self, trigger_event, response_event, max_delay):
        """验证响应时间约束"""
        # LTL公式: G(trigger -> F[<=max_delay] response)
        
        violations = []
        for i, (event, timestamp) in enumerate(self.events):
            if event == trigger_event:
                # 查找后续的响应事件
                response_found = False
                for j in range(i + 1, len(self.events)):
                    next_event, next_timestamp = self.events[j]
                    if next_event == response_event:
                        delay = next_timestamp - timestamp
                        if delay > max_delay:
                            violations.append({
                                'trigger_time': timestamp,
                                'response_time': next_timestamp,
                                'delay': delay,
                                'max_delay': max_delay
                            })
                        response_found = True
                        break
                        
                if not response_found:
                    violations.append({
                        'trigger_time': timestamp,
                        'response_time': None,
                        'delay': float('inf'),
                        'max_delay': max_delay
                    })
                    
        return violations
    
    def verify_periodicity(self, event, period, tolerance=0.1):
        """验证周期性约束"""
        # LTL公式: G(F[=period] event)
        
        event_times = [timestamp for event_name, timestamp in self.events if event_name == event]
        
        if len(event_times) < 2:
            return []
            
        violations = []
        for i in range(1, len(event_times)):
            actual_period = event_times[i] - event_times[i-1]
            if abs(actual_period - period) > tolerance:
                violations.append({
                    'expected_period': period,
                    'actual_period': actual_period,
                    'violation': abs(actual_period - period)
                })
                
        return violations

# 使用示例
verifier = RealTimeLTLVerifier()

# 添加事件序列
verifier.add_event("button_press", 1.0)
verifier.add_event("led_on", 1.05)
verifier.add_event("button_press", 3.0)
verifier.add_event("led_on", 3.08)
verifier.add_event("button_press", 5.0)
verifier.add_event("led_on", 5.12)

# 验证响应时间约束
response_violations = verifier.verify_response_time("button_press", "led_on", 0.1)
if response_violations:
    print("响应时间约束违反:")
    for violation in response_violations:
        print(f"延迟: {violation['delay']:.3f}s (最大允许: {violation['max_delay']}s)")
else:
    print("所有响应时间约束都满足")

# 验证周期性约束
periodicity_violations = verifier.verify_periodicity("button_press", 2.0, 0.1)
if periodicity_violations:
    print("周期性约束违反:")
    for violation in periodicity_violations:
        print(f"实际周期: {violation['actual_period']:.3f}s (期望: {violation['expected_period']}s)")
else:
    print("所有周期性约束都满足")
```

## 总结

本文档提供了时态逻辑控制理论的实践案例，涵盖：

1. **线性时态逻辑(LTL)应用**：交通信号灯系统、电梯系统建模
2. **计算树逻辑(CTL)应用**：并发系统、协议验证
3. **CTL*综合应用**：分布式系统建模
4. **模型检测技术**：状态空间探索、可达性分析
5. **实时系统验证**：任务调度、时间约束验证

这些实践案例展示了时态逻辑在系统验证中的实际应用，帮助理解如何将形式化理论转化为具体的验证工具和方法。
