# ç¼–ç¨‹è¯­è¨€åŸºç¡€ç†è®º

## ğŸ“‘ ç›®å½•

- [ç¼–ç¨‹è¯­è¨€åŸºç¡€ç†è®º](#ç¼–ç¨‹è¯­è¨€åŸºç¡€ç†è®º)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. ç¼–ç¨‹è¯­è¨€çš„èŒƒç•´è®ºåŸºç¡€](#1-ç¼–ç¨‹è¯­è¨€çš„èŒƒç•´è®ºåŸºç¡€)
    - [1.1. ç¼–ç¨‹è¯­è¨€ä¸èŒƒç•´è®ºçš„æœ¬è´¨è”ç³»](#11-ç¼–ç¨‹è¯­è¨€ä¸èŒƒç•´è®ºçš„æœ¬è´¨è”ç³»)
    - [1.2. èŒƒç•´è®ºç»“æ„åœ¨ç¼–ç¨‹è¯­è¨€ä¸­çš„ä½“ç°](#12-èŒƒç•´è®ºç»“æ„åœ¨ç¼–ç¨‹è¯­è¨€ä¸­çš„ä½“ç°)
  - [2. ç±»å‹ç³»ç»Ÿçš„ç†è®ºåŸºç¡€](#2-ç±»å‹ç³»ç»Ÿçš„ç†è®ºåŸºç¡€)
    - [2.1. ç±»å‹ç³»ç»Ÿçš„åŸºæœ¬æ¦‚å¿µ](#21-ç±»å‹ç³»ç»Ÿçš„åŸºæœ¬æ¦‚å¿µ)
    - [2.2. ç±»å‹ç³»ç»Ÿçš„åˆ†ç±»](#22-ç±»å‹ç³»ç»Ÿçš„åˆ†ç±»)
      - [2.2.1. æŒ‰ç±»å‹æ£€æŸ¥æ—¶æœºåˆ†ç±»](#221-æŒ‰ç±»å‹æ£€æŸ¥æ—¶æœºåˆ†ç±»)
      - [2.2.2. æŒ‰ç±»å‹æ¨å¯¼èƒ½åŠ›åˆ†ç±»](#222-æŒ‰ç±»å‹æ¨å¯¼èƒ½åŠ›åˆ†ç±»)
    - [2.3. å¤šæ€æ€§ç†è®º](#23-å¤šæ€æ€§ç†è®º)
      - [2.3.1. å‚æ•°å¤šæ€ (Parametric Polymorphism)](#231-å‚æ•°å¤šæ€-parametric-polymorphism)
      - [2.3.2. ç‰¹è®¾å¤šæ€ (Ad-hoc Polymorphism)](#232-ç‰¹è®¾å¤šæ€-ad-hoc-polymorphism)
      - [2.3.3. å­ç±»å‹å¤šæ€ (Subtype Polymorphism)](#233-å­ç±»å‹å¤šæ€-subtype-polymorphism)
  - [3. å‡½æ•°å¼ç¼–ç¨‹ç†è®º](#3-å‡½æ•°å¼ç¼–ç¨‹ç†è®º)
    - [3.1. çº¯å‡½æ•°ä¸å‰¯ä½œç”¨](#31-çº¯å‡½æ•°ä¸å‰¯ä½œç”¨)
    - [3.2. é«˜é˜¶å‡½æ•°](#32-é«˜é˜¶å‡½æ•°)
    - [3.3. å‡½å­ (Functor)](#33-å‡½å­-functor)
    - [3.4. å•å­ (Monad)](#34-å•å­-monad)
  - [4. ç±»å‹ç³»ç»Ÿçš„é«˜çº§ç‰¹æ€§](#4-ç±»å‹ç³»ç»Ÿçš„é«˜çº§ç‰¹æ€§)
    - [4.1. ä»£æ•°æ•°æ®ç±»å‹ (Algebraic Data Types)](#41-ä»£æ•°æ•°æ®ç±»å‹-algebraic-data-types)
    - [4.2. ä¾èµ–ç±»å‹ (Dependent Types)](#42-ä¾èµ–ç±»å‹-dependent-types)
    - [4.3. çº¿æ€§ç±»å‹ (Linear Types)](#43-çº¿æ€§ç±»å‹-linear-types)
  - [5. ç±»å‹æ¨å¯¼ç†è®º](#5-ç±»å‹æ¨å¯¼ç†è®º)
    - [5.1. Hindley-Milnerç±»å‹ç³»ç»Ÿ](#51-hindley-milnerç±»å‹ç³»ç»Ÿ)
    - [5.2. ç±»å‹æ¨å¯¼ç®—æ³•](#52-ç±»å‹æ¨å¯¼ç®—æ³•)
  - [6. ç¨‹åºéªŒè¯ç†è®º](#6-ç¨‹åºéªŒè¯ç†è®º)
    - [6.1. ç±»å‹çº§ç¼–ç¨‹](#61-ç±»å‹çº§ç¼–ç¨‹)
    - [6.2. å¥‘çº¦ç¼–ç¨‹](#62-å¥‘çº¦ç¼–ç¨‹)
  - [7. å¹¶å‘ä¸å¹¶è¡Œç¼–ç¨‹ç†è®º](#7-å¹¶å‘ä¸å¹¶è¡Œç¼–ç¨‹ç†è®º)
    - [7.1. å¹¶å‘æ¨¡å‹](#71-å¹¶å‘æ¨¡å‹)
    - [7.2. å‡½æ•°å¼å¹¶å‘](#72-å‡½æ•°å¼å¹¶å‘)
  - [8. ç¨‹åºè¯­è¨€è¯­ä¹‰ç†è®º](#8-ç¨‹åºè¯­è¨€è¯­ä¹‰ç†è®º)
    - [8.1. æ“ä½œè¯­ä¹‰](#81-æ“ä½œè¯­ä¹‰)
    - [8.2. æŒ‡ç§°è¯­ä¹‰](#82-æŒ‡ç§°è¯­ä¹‰)
    - [8.3. å…¬ç†è¯­ä¹‰](#83-å…¬ç†è¯­ä¹‰)
  - [9. ç¨‹åºè¯­è¨€è®¾è®¡åŸåˆ™](#9-ç¨‹åºè¯­è¨€è®¾è®¡åŸåˆ™)
    - [9.1. æ­£äº¤æ€§](#91-æ­£äº¤æ€§)
    - [9.2. ä¸€è‡´æ€§](#92-ä¸€è‡´æ€§)
    - [9.3. ç®€æ´æ€§](#93-ç®€æ´æ€§)
    - [9.4. è¡¨è¾¾èƒ½åŠ›](#94-è¡¨è¾¾èƒ½åŠ›)
  - [10. æœªæ¥å‘å±•è¶‹åŠ¿](#10-æœªæ¥å‘å±•è¶‹åŠ¿)
    - [10.1. ç±»å‹ç³»ç»Ÿå‘å±•](#101-ç±»å‹ç³»ç»Ÿå‘å±•)
    - [10.2. å¹¶å‘ç¼–ç¨‹](#102-å¹¶å‘ç¼–ç¨‹)
    - [10.3. ç¨‹åºéªŒè¯](#103-ç¨‹åºéªŒè¯)
  - [11. å‚è€ƒæ–‡çŒ®](#11-å‚è€ƒæ–‡çŒ®)
  - [12. å¤šè¡¨å¾](#12-å¤šè¡¨å¾)
  - [13. å½¢å¼åŒ–è¯­ä¹‰](#13-å½¢å¼åŒ–è¯­ä¹‰)
  - [14. å½¢å¼åŒ–è¯­æ³•ä¸è¯æ˜](#14-å½¢å¼åŒ–è¯­æ³•ä¸è¯æ˜)

---


## 1. ç¼–ç¨‹è¯­è¨€çš„èŒƒç•´è®ºåŸºç¡€

### 1.1. ç¼–ç¨‹è¯­è¨€ä¸èŒƒç•´è®ºçš„æœ¬è´¨è”ç³»

-**å®šç†1ï¼šç¼–ç¨‹è¯­è¨€èŒƒç•´è¡¨ç¤º**

ç¼–ç¨‹è¯­è¨€å¯è¡¨ç¤ºä¸ºèŒƒç•´ï¼š

$$\text{Lang} = (\text{Types}, \text{Functions}, \circ, \text{id})$$

å…¶ä¸­Typesä¸ºå¯¹è±¡ï¼ŒFunctionsä¸ºæ€å°„ï¼Œ$\circ$ä¸ºç»„åˆï¼Œidä¸ºæ’ç­‰æ€å°„ã€‚

**å½¢å¼åŒ–åˆ†æ**ï¼šä»èŒƒç•´è®ºè§†è§’ï¼Œç¼–ç¨‹è¯­è¨€çš„æ ¸å¿ƒæ˜¯ä¸€ä¸ªèŒƒç•´ï¼Œå…¶ä¸­ï¼š

- **å¯¹è±¡**ï¼šç±»å‹ï¼ˆå¦‚Intã€Boolã€è‡ªå®šä¹‰ç±»å‹ç­‰ï¼‰
- **æ€å°„**ï¼šå‡½æ•°ï¼ˆä»ä¸€ä¸ªç±»å‹åˆ°å¦ä¸€ä¸ªç±»å‹çš„æ˜ å°„ï¼‰
- **æ€å°„ç»„åˆ**ï¼šå¯¹åº”å‡½æ•°ç»„åˆï¼ˆ$g \circ f$è¡¨ç¤ºå…ˆæ‰§è¡Œ$f$å†æ‰§è¡Œ$g$ï¼‰
- **æ’ç­‰æ€å°„**ï¼šå¯¹åº”æ’ç­‰å‡½æ•°ï¼ˆ$\text{id}_A: A \to A$ï¼‰

### 1.2. èŒƒç•´è®ºç»“æ„åœ¨ç¼–ç¨‹è¯­è¨€ä¸­çš„ä½“ç°

| èŒƒç•´æ¦‚å¿µ | ç¼–ç¨‹æ¦‚å¿µ | Haskell | Scala | Rust |
|---------|---------|---------|-------|------|
| å¯¹è±¡ | ç±»å‹ | å®Œå…¨ç¬¦åˆ | å®Œå…¨ç¬¦åˆ | å¢åŠ ç”Ÿå‘½å‘¨æœŸå‚æ•° |
| æ€å°„ | å‡½æ•° | çº¯å‡½æ•° | æ–¹æ³•/å‡½æ•° | å‡½æ•°/æ–¹æ³• |
| å‡½å­ | ç±»å‹æ„é€ å™¨ | Functorç±»å‹ç±» | ç‰¹è´¨/æ„é€ å™¨ | ç‰¹è´¨/æ³›å‹ |
| è‡ªç„¶å˜æ¢ | å¤šæ€å‡½æ•° | é«˜é˜¶å¤šæ€ | é«˜é˜¶å¤šæ€ | æœ‰é™å¤šæ€ |
| å•å­ | æ•ˆåº”å°è£… | æ˜¾å¼å•å­ | éšå¼å•å­ | æ— æ˜¾å¼å•å­ |
| ç§¯ | ç§¯ç±»å‹ | (a,b) | (A,B)/ç±» | (A,B)/ç»“æ„ä½“ |
| ä½™ç§¯ | å’Œç±»å‹ | Either/ADT | å¯†å°ç‰¹è´¨/ADT | æšä¸¾/Option |

## 2. ç±»å‹ç³»ç»Ÿçš„ç†è®ºåŸºç¡€

### 2.1. ç±»å‹ç³»ç»Ÿçš„åŸºæœ¬æ¦‚å¿µ

**ç±»å‹**ï¼šç±»å‹æ˜¯å€¼çš„é›†åˆï¼Œå®šä¹‰äº†å€¼çš„å¯èƒ½å½¢å¼å’Œæ“ä½œã€‚

**ç±»å‹ç³»ç»Ÿ**ï¼šç±»å‹ç³»ç»Ÿæ˜¯ä¸€ç»„è§„åˆ™ï¼Œç”¨äºï¼š

- å°†ç±»å‹åˆ†é…ç»™ç¨‹åºä¸­çš„è¡¨è¾¾å¼
- æ£€æŸ¥ç±»å‹å…¼å®¹æ€§
- é˜²æ­¢ç±»å‹é”™è¯¯

**ç±»å‹å®‰å…¨**ï¼šç±»å‹å®‰å…¨çš„è¯­è¨€åœ¨ç¼–è¯‘æ—¶æˆ–è¿è¡Œæ—¶èƒ½å¤Ÿæ£€æµ‹å¹¶é˜²æ­¢ç±»å‹é”™è¯¯ã€‚

### 2.2. ç±»å‹ç³»ç»Ÿçš„åˆ†ç±»

#### 2.2.1. æŒ‰ç±»å‹æ£€æŸ¥æ—¶æœºåˆ†ç±»

**é™æ€ç±»å‹ç³»ç»Ÿ**ï¼š

- åœ¨ç¼–è¯‘æ—¶è¿›è¡Œç±»å‹æ£€æŸ¥
- ä¼˜ç‚¹ï¼šæ—©æœŸé”™è¯¯æ£€æµ‹ï¼Œæ›´å¥½çš„æ€§èƒ½
- ç¼ºç‚¹ï¼šéœ€è¦æ˜¾å¼ç±»å‹å£°æ˜
- ä¾‹å­ï¼šHaskellã€Scalaã€Rustã€Java

**åŠ¨æ€ç±»å‹ç³»ç»Ÿ**ï¼š

- åœ¨è¿è¡Œæ—¶è¿›è¡Œç±»å‹æ£€æŸ¥
- ä¼˜ç‚¹ï¼šçµæ´»æ€§é«˜ï¼Œå¼€å‘é€Ÿåº¦å¿«
- ç¼ºç‚¹ï¼šè¿è¡Œæ—¶é”™è¯¯ï¼Œæ€§èƒ½å¼€é”€
- ä¾‹å­ï¼šPythonã€JavaScriptã€Ruby

#### 2.2.2. æŒ‰ç±»å‹æ¨å¯¼èƒ½åŠ›åˆ†ç±»

**æ˜¾å¼ç±»å‹ç³»ç»Ÿ**ï¼š

- ç¨‹åºå‘˜å¿…é¡»æ˜¾å¼å£°æ˜æ‰€æœ‰ç±»å‹
- ä¾‹å­ï¼šCã€Java

**éšå¼ç±»å‹ç³»ç»Ÿ**ï¼š

- ç¼–è¯‘å™¨èƒ½å¤Ÿæ¨å¯¼å¤§éƒ¨åˆ†ç±»å‹
- ä¾‹å­ï¼šHaskellã€Scalaã€Rust

### 2.3. å¤šæ€æ€§ç†è®º

#### 2.3.1. å‚æ•°å¤šæ€ (Parametric Polymorphism)

å‚æ•°å¤šæ€å…è®¸å‡½æ•°æˆ–æ•°æ®ç±»å‹ä»¥ç»Ÿä¸€çš„æ–¹å¼å¤„ç†ä¸åŒç±»å‹çš„å€¼ã€‚

**Haskellç¤ºä¾‹**ï¼š

```haskell
-- å‚æ•°å¤šæ€å‡½æ•°
id :: a -> a
id x = x

-- å‚æ•°å¤šæ€æ•°æ®ç±»å‹
data Maybe a = Nothing | Just a
```

**Scalaç¤ºä¾‹**ï¼š

```scala
// å‚æ•°å¤šæ€å‡½æ•°
def id[A](x: A): A = x

// å‚æ•°å¤šæ€æ•°æ®ç±»å‹
sealed trait Option[+A]
case object None extends Option[Nothing]
case class Some[+A](value: A) extends Option[A]
```

**Rustç¤ºä¾‹**ï¼š

```rust
// å‚æ•°å¤šæ€å‡½æ•°
fn id<T>(x: T) -> T { x }

// å‚æ•°å¤šæ€æ•°æ®ç±»å‹
enum Option<T> {
    None,
    Some(T),
}
```

#### 2.3.2. ç‰¹è®¾å¤šæ€ (Ad-hoc Polymorphism)

ç‰¹è®¾å¤šæ€å…è®¸å‡½æ•°æ ¹æ®å‚æ•°ç±»å‹çš„ä¸åŒè€Œæœ‰ä¸åŒçš„å®ç°ã€‚

**å‡½æ•°é‡è½½**ï¼š

```scala
// Scalaä¸­çš„å‡½æ•°é‡è½½
def add(x: Int, y: Int): Int = x + y
def add(x: String, y: String): String = x + y
```

**ç±»å‹ç±» (Type Classes)**ï¼š

```haskell
-- Haskellä¸­çš„ç±»å‹ç±»
class Eq a where
    (==) :: a -> a -> Bool
    (/=) :: a -> a -> Bool

instance Eq Int where
    (==) = (==)
    (/=) = (/=)
```

**ç‰¹è´¨ (Traits)**ï¼š

```rust
// Rustä¸­çš„ç‰¹è´¨
trait Eq {
    fn eq(&self, other: &Self) -> bool;
    fn ne(&self, other: &Self) -> bool {
        !self.eq(other)
    }
}

impl Eq for i32 {
    fn eq(&self, other: &i32) -> bool {
        self == other
    }
}
```

#### 2.3.3. å­ç±»å‹å¤šæ€ (Subtype Polymorphism)

å­ç±»å‹å¤šæ€å…è®¸å­ç±»å‹çš„å€¼åœ¨éœ€è¦çˆ¶ç±»å‹çš„åœ°æ–¹ä½¿ç”¨ã€‚

**Scalaç¤ºä¾‹**ï¼š

```scala
// å­ç±»å‹å¤šæ€
class Animal
class Dog extends Animal
class Cat extends Animal

def makeSound(animal: Animal): Unit = {
    // å¯ä»¥æ¥å—Animalçš„ä»»ä½•å­ç±»å‹
}

val dog: Dog = new Dog
makeSound(dog) // å­ç±»å‹å¯ä»¥æ›¿ä»£çˆ¶ç±»å‹
```

## 3. å‡½æ•°å¼ç¼–ç¨‹ç†è®º

### 3.1. çº¯å‡½æ•°ä¸å‰¯ä½œç”¨

**çº¯å‡½æ•°**ï¼šå‡½æ•°çš„è¾“å‡ºå®Œå…¨ç”±å…¶è¾“å…¥å†³å®šï¼Œæ²¡æœ‰å‰¯ä½œç”¨ã€‚

**å‰¯ä½œç”¨**ï¼šå‡½æ•°é™¤äº†è¿”å›å€¼å¤–ï¼Œè¿˜å¯¹å¤–éƒ¨ç¯å¢ƒäº§ç”Ÿå½±å“ã€‚

**Haskellä¸­çš„çº¯å‡½æ•°**ï¼š

```haskell
-- çº¯å‡½æ•°ï¼šè¾“å‡ºå®Œå…¨ç”±è¾“å…¥å†³å®š
add :: Int -> Int -> Int
add x y = x + y

-- æœ‰å‰¯ä½œç”¨çš„å‡½æ•°ï¼ˆé€šè¿‡IOå•å­å°è£…ï¼‰
getLine :: IO String
putStrLn :: String -> IO ()
```

### 3.2. é«˜é˜¶å‡½æ•°

**é«˜é˜¶å‡½æ•°**ï¼šæ¥å—å‡½æ•°ä½œä¸ºå‚æ•°æˆ–è¿”å›å‡½æ•°çš„å‡½æ•°ã€‚

**Haskellç¤ºä¾‹**ï¼š

```haskell
-- é«˜é˜¶å‡½æ•°
map :: (a -> b) -> [a] -> [b]
map f [] = []
map f (x:xs) = f x : map f xs

filter :: (a -> Bool) -> [a] -> [a]
filter p [] = []
filter p (x:xs) = if p x then x : filter p xs else filter p xs

-- å‡½æ•°ç»„åˆ
(.) :: (b -> c) -> (a -> b) -> a -> c
f . g = \x -> f (g x)
```

**Scalaç¤ºä¾‹**ï¼š

```scala
// é«˜é˜¶å‡½æ•°
def map[A, B](list: List[A])(f: A => B): List[B] = list match {
    case Nil => Nil
    case x :: xs => f(x) :: map(xs)(f)
}

def filter[A](list: List[A])(p: A => Boolean): List[A] = list match {
    case Nil => Nil
    case x :: xs => if (p(x)) x :: filter(xs)(p) else filter(xs)(p)
}

// å‡½æ•°ç»„åˆ
def compose[A, B, C](f: B => C, g: A => B): A => C = x => f(g(x))
```

### 3.3. å‡½å­ (Functor)

**å‡½å­**ï¼šèƒ½å¤Ÿæ˜ å°„å‡½æ•°åˆ°å®¹å™¨ä¸­çš„å€¼çš„ç±»å‹æ„é€ å™¨ã€‚

**å‡½å­å®šå¾‹**ï¼š

1. æ’ç­‰å¾‹ï¼š`fmap id = id`
2. ç»“åˆå¾‹ï¼š`fmap (f . g) = fmap f . fmap g`

**Haskellå®ç°**ï¼š

```haskell
class Functor f where
    fmap :: (a -> b) -> f a -> f b

instance Functor Maybe where
    fmap f Nothing = Nothing
    fmap f (Just x) = Just (f x)

instance Functor [] where
    fmap = map
```

**Scalaå®ç°**ï¼š

```scala
trait Functor[F[_]] {
    def map[A, B](fa: F[A])(f: A => B): F[B]
}

implicit object OptionFunctor extends Functor[Option] {
    def map[A, B](fa: Option[A])(f: A => B): Option[B] = fa match {
        case None => None
        case Some(x) => Some(f(x))
    }
}
```

**Rustå®ç°**ï¼š

```rust
trait Functor<A, B> {
    type Target;
    fn fmap<F>(self, f: F) -> Self::Target
    where F: FnOnce(A) -> B;
}

impl<A, B> Functor<A, B> for Option<A> {
    type Target = Option<B>;
    fn fmap<F>(self, f: F) -> Option<B>
    where F: FnOnce(A) -> B {
        match self {
            None => None,
            Some(x) => Some(f(x)),
        }
    }
}
```

### 3.4. å•å­ (Monad)

**å•å­**ï¼šç”¨äºå¤„ç†è®¡ç®—åºåˆ—çš„ç±»å‹æ„é€ å™¨ï¼Œç‰¹åˆ«æ˜¯æœ‰å‰¯ä½œç”¨çš„è®¡ç®—ã€‚

**å•å­å®šå¾‹**ï¼š

1. å·¦å•ä½å¾‹ï¼š`return a >>= f = f a`
2. å³å•ä½å¾‹ï¼š`m >>= return = m`
3. ç»“åˆå¾‹ï¼š`(m >>= f) >>= g = m >>= (\x -> f x >>= g)`

**Haskellå®ç°**ï¼š

```haskell
class Monad m where
    return :: a -> m a
    (>>=) :: m a -> (a -> m b) -> m b

instance Monad Maybe where
    return = Just
    Nothing >>= f = Nothing
    Just x >>= f = f x

-- ä½¿ç”¨doè®°æ³•
maybeExample :: Maybe Int
maybeExample = do
    x <- Just 5
    y <- Just 3
    return (x + y)
```

**Scalaå®ç°**ï¼š

```scala
trait Monad[F[_]] {
    def pure[A](a: A): F[A]
    def flatMap[A, B](fa: F[A])(f: A => F[B]): F[B]
}

implicit object OptionMonad extends Monad[Option] {
    def pure[A](a: A): Option[A] = Some(a)
    def flatMap[A, B](fa: Option[A])(f: A => Option[B]): Option[B] = fa match {
        case None => None
        case Some(x) => f(x)
    }
}

// ä½¿ç”¨foræ¨å¯¼å¼
def optionExample: Option[Int] = for {
    x <- Some(5)
    y <- Some(3)
} yield x + y
```

## 4. ç±»å‹ç³»ç»Ÿçš„é«˜çº§ç‰¹æ€§

### 4.1. ä»£æ•°æ•°æ®ç±»å‹ (Algebraic Data Types)

**ä»£æ•°æ•°æ®ç±»å‹**ï¼šé€šè¿‡ç§¯ç±»å‹å’Œå’Œç±»å‹æ„é€ çš„å¤åˆç±»å‹ã€‚

**ç§¯ç±»å‹ (Product Types)**ï¼š

```haskell
-- Haskellä¸­çš„ç§¯ç±»å‹
data Person = Person String Int

-- Scalaä¸­çš„ç§¯ç±»å‹
case class Person(name: String, age: Int)

-- Rustä¸­çš„ç§¯ç±»å‹
struct Person {
    name: String,
    age: u32,
}
```

**å’Œç±»å‹ (Sum Types)**ï¼š

```haskell
-- Haskellä¸­çš„å’Œç±»å‹
data Shape = Circle Double | Rectangle Double Double

-- Scalaä¸­çš„å’Œç±»å‹
sealed trait Shape
case class Circle(radius: Double) extends Shape
case class Rectangle(width: Double, height: Double) extends Shape

-- Rustä¸­çš„å’Œç±»å‹
enum Shape {
    Circle { radius: f64 },
    Rectangle { width: f64, height: f64 },
}
```

### 4.2. ä¾èµ–ç±»å‹ (Dependent Types)

**ä¾èµ–ç±»å‹**ï¼šç±»å‹å¯ä»¥ä¾èµ–äºå€¼ã€‚

**Idrisç¤ºä¾‹**ï¼š

```idris
-- å‘é‡ç±»å‹ï¼Œé•¿åº¦åœ¨ç±»å‹ä¸­ç¼–ç 
data Vect : Nat -> Type -> Type where
    Nil : Vect Z a
    (::) : a -> Vect n a -> Vect (S n) a

-- ç±»å‹å®‰å…¨çš„å‘é‡è¿æ¥
append : Vect n a -> Vect m a -> Vect (n + m) a
append Nil ys = ys
append (x :: xs) ys = x :: append xs ys
```

### 4.3. çº¿æ€§ç±»å‹ (Linear Types)

**çº¿æ€§ç±»å‹**ï¼šæ¯ä¸ªå€¼å¿…é¡»è¢«ä½¿ç”¨æ°å¥½ä¸€æ¬¡ã€‚

**Rustçš„æ‰€æœ‰æƒç³»ç»Ÿ**ï¼š

```rust
// Rusté€šè¿‡æ‰€æœ‰æƒå®ç°çº¿æ€§ç±»å‹
fn take_ownership(s: String) {
    println!("{}", s);
    // såœ¨è¿™é‡Œè¢«é”€æ¯
}

fn main() {
    let s = String::from("hello");
    take_ownership(s);
    // println!("{}", s); // ç¼–è¯‘é”™è¯¯ï¼šså·²ç»è¢«ç§»åŠ¨
}
```

## 5. ç±»å‹æ¨å¯¼ç†è®º

### 5.1. Hindley-Milnerç±»å‹ç³»ç»Ÿ

**Hindley-Milnerç±»å‹ç³»ç»Ÿ**ï¼šä¸€ç§å¤šæ€ç±»å‹ç³»ç»Ÿï¼Œæ”¯æŒè‡ªåŠ¨ç±»å‹æ¨å¯¼ã€‚

**æ ¸å¿ƒç®—æ³•**ï¼š

1. **ç±»å‹æ¨å¯¼**ï¼šä¸ºè¡¨è¾¾å¼æ¨å¯¼æœ€ä¸€èˆ¬çš„ç±»å‹
2. **ç±»å‹ç»Ÿä¸€**ï¼šæ‰¾åˆ°ç±»å‹å˜é‡çš„æ›¿æ¢ï¼Œä½¿ä¸¤ä¸ªç±»å‹ç›¸ç­‰
3. **æ³›åŒ–**ï¼šå°†ç±»å‹å˜é‡è½¬æ¢ä¸ºå…¨ç§°é‡è¯

**Haskellç¤ºä¾‹**ï¼š

```haskell
-- è‡ªåŠ¨æ¨å¯¼ç±»å‹
id x = x  -- æ¨å¯¼ä¸º id :: a -> a
const x y = x  -- æ¨å¯¼ä¸º const :: a -> b -> a

-- ç±»å‹æ¨å¯¼è¿‡ç¨‹
-- 1. ä¸ºxåˆ†é…ç±»å‹å˜é‡a
-- 2. ä¸ºyåˆ†é…ç±»å‹å˜é‡b
-- 3. å‡½æ•°è¿”å›xï¼Œæ‰€ä»¥è¿”å›ç±»å‹æ˜¯a
-- 4. æœ€ç»ˆç±»å‹ï¼ša -> b -> a
```

### 5.2. ç±»å‹æ¨å¯¼ç®—æ³•

**ç®—æ³•W (Algorithm W)**ï¼š

```haskell
-- ç®€åŒ–çš„ç±»å‹æ¨å¯¼ç®—æ³•
typeEnv :: [(String, Type)]
typeEnv = []

infer :: TypeEnv -> Expr -> (Subst, Type)
infer env (Var x) =
    case lookup x env of
        Just t -> (emptySubst, t)
        Nothing -> error "Unbound variable"

infer env (App e1 e2) =
    let (s1, t1) = infer env e1
        (s2, t2) = infer env e2
        t3 = freshTypeVar
        s3 = unify (apply s1 t1) (t2 `arrow` t3)
    in (s3 `compose` s2 `compose` s1, apply s3 t3)

infer env (Lam x e) =
    let t1 = freshTypeVar
        env' = (x, t1) : env
        (s, t2) = infer env' e
    in (s, apply s t1 `arrow` t2)
```

## 6. ç¨‹åºéªŒè¯ç†è®º

### 6.1. ç±»å‹çº§ç¼–ç¨‹

**ç±»å‹çº§ç¼–ç¨‹**ï¼šåœ¨ç±»å‹ç³»ç»Ÿä¸­è¿›è¡Œç¼–ç¨‹ï¼Œåˆ©ç”¨ç±»å‹æ£€æŸ¥å™¨è¿›è¡ŒéªŒè¯ã€‚

**Haskellç¤ºä¾‹**ï¼š

```haskell
-- ç±»å‹çº§è‡ªç„¶æ•°
data Zero
data Succ n

-- ç±»å‹çº§åŠ æ³•
type family Add n m where
    Add Zero m = m
    Add (Succ n) m = Succ (Add n m)

-- é•¿åº¦ç¼–ç çš„å‘é‡
data Vect n a where
    Nil :: Vect Zero a
    Cons :: a -> Vect n a -> Vect (Succ n) a

-- ç±»å‹å®‰å…¨çš„å‘é‡è¿æ¥
append :: Vect n a -> Vect m a -> Vect (Add n m) a
append Nil ys = ys
append (Cons x xs) ys = Cons x (append xs ys)
```

### 6.2. å¥‘çº¦ç¼–ç¨‹

**å¥‘çº¦ç¼–ç¨‹**ï¼šé€šè¿‡å‰ç½®æ¡ä»¶ã€åç½®æ¡ä»¶å’Œä¸å˜å¼æ¥éªŒè¯ç¨‹åºæ­£ç¡®æ€§ã€‚

**Scalaç¤ºä¾‹**ï¼š

```scala
// ä½¿ç”¨Scalaçš„æ–­è¨€è¿›è¡Œå¥‘çº¦ç¼–ç¨‹
def factorial(n: Int): Int = {
    require(n >= 0, "n must be non-negative")

    val result = if (n == 0) 1 else n * factorial(n - 1)

    ensure(result > 0, "factorial result must be positive")
    result
}
```

**Rustç¤ºä¾‹**ï¼š

```rust
// ä½¿ç”¨Rustçš„æ–­è¨€è¿›è¡Œå¥‘çº¦ç¼–ç¨‹
fn factorial(n: u32) -> u32 {
    assert!(n >= 0, "n must be non-negative");

    let result = if n == 0 { 1 } else { n * factorial(n - 1) };

    assert!(result > 0, "factorial result must be positive");
    result
}
```

## 7. å¹¶å‘ä¸å¹¶è¡Œç¼–ç¨‹ç†è®º

### 7.1. å¹¶å‘æ¨¡å‹

**å…±äº«å†…å­˜æ¨¡å‹**ï¼š

```rust
// Rustä¸­çš„å…±äº«å†…å­˜å¹¶å‘
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }
}
```

**æ¶ˆæ¯ä¼ é€’æ¨¡å‹**ï¼š

```rust
// Rustä¸­çš„æ¶ˆæ¯ä¼ é€’å¹¶å‘
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hello");
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!("Got: {}", received);
}
```

### 7.2. å‡½æ•°å¼å¹¶å‘

**Haskellä¸­çš„STM (Software Transactional Memory)**ï¼š

```haskell
import Control.Concurrent.STM

-- åŸå­äº‹åŠ¡
transfer :: TVar Int -> TVar Int -> Int -> STM ()
transfer from to amount = do
    fromVal <- readTVar from
    toVal <- readTVar to
    writeTVar from (fromVal - amount)
    writeTVar to (toVal + amount)

-- æ‰§è¡Œäº‹åŠ¡
main :: IO ()
main = do
    account1 <- newTVarIO 100
    account2 <- newTVarIO 0
    atomically $ transfer account1 account2 50
```

## 8. ç¨‹åºè¯­è¨€è¯­ä¹‰ç†è®º

### 8.1. æ“ä½œè¯­ä¹‰

**æ“ä½œè¯­ä¹‰**ï¼šæè¿°ç¨‹åºå¦‚ä½•æ‰§è¡Œã€‚

**å°æ­¥æ“ä½œè¯­ä¹‰ç¤ºä¾‹**ï¼š

```text
-- ç®—æœ¯è¡¨è¾¾å¼çš„æ“ä½œè¯­ä¹‰
e1 â†’ e1'
----------------- (E-Add1)
e1 + e2 â†’ e1' + e2

e2 â†’ e2'
----------------- (E-Add2)
v1 + e2 â†’ v1 + e2'

----------------- (E-Add)
n1 + n2 â†’ n1 + n2
```

### 8.2. æŒ‡ç§°è¯­ä¹‰

**æŒ‡ç§°è¯­ä¹‰**ï¼šå°†ç¨‹åºæ˜ å°„åˆ°æ•°å­¦å¯¹è±¡ã€‚

**ç®€å•è¡¨è¾¾å¼çš„æŒ‡ç§°è¯­ä¹‰**ï¼š

```haskell
-- è¡¨è¾¾å¼çš„æŒ‡ç§°è¯­ä¹‰
[[n]] = n
[[e1 + e2]] = [[e1]] + [[e2]]
[[e1 * e2]] = [[e1]] * [[e2]]
```

### 8.3. å…¬ç†è¯­ä¹‰

**å…¬ç†è¯­ä¹‰**ï¼šä½¿ç”¨é€»è¾‘æ–­è¨€æè¿°ç¨‹åºè¡Œä¸ºã€‚

**Hoareé€»è¾‘ç¤ºä¾‹**ï¼š

```text
{P} S {Q}
```

å…¶ä¸­Pæ˜¯å‰ç½®æ¡ä»¶ï¼ŒSæ˜¯ç¨‹åºè¯­å¥ï¼ŒQæ˜¯åç½®æ¡ä»¶ã€‚

**èµ‹å€¼å…¬ç†**ï¼š

```text
{Q[E/x]} x := E {Q}
```

**åºåˆ—å…¬ç†**ï¼š

```text
{P} S1 {R}    {R} S2 {Q}
------------------------
{P} S1; S2 {Q}
```

## 9. ç¨‹åºè¯­è¨€è®¾è®¡åŸåˆ™

### 9.1. æ­£äº¤æ€§

**æ­£äº¤æ€§**ï¼šè¯­è¨€ç‰¹æ€§ä¹‹é—´ç›¸äº’ç‹¬ç«‹ï¼Œå¯ä»¥è‡ªç”±ç»„åˆã€‚

**ä¾‹å­**ï¼š

- å‡½æ•°å’Œç±»å‹æ˜¯æ­£äº¤çš„
- æ§åˆ¶ç»“æ„å’Œæ•°æ®ç±»å‹æ˜¯æ­£äº¤çš„

### 9.2. ä¸€è‡´æ€§

**ä¸€è‡´æ€§**ï¼šç›¸ä¼¼çš„æ¦‚å¿µä½¿ç”¨ç›¸ä¼¼çš„è¯­æ³•å’Œè¯­ä¹‰ã€‚

**ä¾‹å­**ï¼š

- æ‰€æœ‰å‡½æ•°è°ƒç”¨ä½¿ç”¨ç›¸åŒçš„è¯­æ³•
- æ‰€æœ‰ç±»å‹å£°æ˜ä½¿ç”¨ç›¸åŒçš„è¯­æ³•

### 9.3. ç®€æ´æ€§

**ç®€æ´æ€§**ï¼šç”¨æœ€å°‘çš„è¯­æ³•è¡¨è¾¾æœ€å¤šçš„è¯­ä¹‰ã€‚

**ä¾‹å­**ï¼š

- ä½¿ç”¨ç±»å‹æ¨å¯¼å‡å°‘æ˜¾å¼ç±»å‹å£°æ˜
- ä½¿ç”¨è¯­æ³•ç³–ç®€åŒ–å¸¸è§æ¨¡å¼

### 9.4. è¡¨è¾¾èƒ½åŠ›

**è¡¨è¾¾èƒ½åŠ›**ï¼šè¯­è¨€èƒ½å¤Ÿè¡¨è¾¾å„ç§ç¼–ç¨‹æ¨¡å¼ã€‚

**ä¾‹å­**ï¼š

- æ”¯æŒå‡½æ•°å¼ç¼–ç¨‹
- æ”¯æŒé¢å‘å¯¹è±¡ç¼–ç¨‹
- æ”¯æŒå¹¶å‘ç¼–ç¨‹

## 10. æœªæ¥å‘å±•è¶‹åŠ¿

### 10.1. ç±»å‹ç³»ç»Ÿå‘å±•

**ä¾èµ–ç±»å‹**ï¼šæ›´å¼ºå¤§çš„ç±»å‹ç³»ç»Ÿï¼Œæ”¯æŒå€¼ä¾èµ–ç±»å‹ã€‚

**çº¿æ€§ç±»å‹**ï¼šæ›´å¥½çš„èµ„æºç®¡ç†å’Œå¹¶å‘å®‰å…¨ã€‚

**æ•ˆåº”ç³»ç»Ÿ**ï¼šæ˜¾å¼å¤„ç†å‰¯ä½œç”¨å’Œæ•ˆåº”ã€‚

### 10.2. å¹¶å‘ç¼–ç¨‹

**ç»“æ„åŒ–å¹¶å‘**ï¼šæ›´å¥½çš„å¹¶å‘æ§åˆ¶ç»“æ„ã€‚

**å¼‚æ­¥ç¼–ç¨‹**ï¼šæ›´è‡ªç„¶çš„å¼‚æ­¥ç¼–ç¨‹æ¨¡å‹ã€‚

**åˆ†å¸ƒå¼ç¼–ç¨‹**ï¼šè¯­è¨€çº§åˆ«çš„åˆ†å¸ƒå¼æ”¯æŒã€‚

### 10.3. ç¨‹åºéªŒè¯

**å½¢å¼åŒ–éªŒè¯**ï¼šæ›´å¼ºçš„ç¨‹åºæ­£ç¡®æ€§ä¿è¯ã€‚

**ç±»å‹çº§ç¼–ç¨‹**ï¼šåœ¨ç±»å‹ç³»ç»Ÿä¸­è¿›è¡Œæ›´å¤šç¼–ç¨‹ã€‚

**å¥‘çº¦ç¼–ç¨‹**ï¼šæ›´ä¸°å¯Œçš„å¥‘çº¦è¡¨è¾¾èƒ½åŠ›ã€‚

## 11. å‚è€ƒæ–‡çŒ®

1. Pierce, B. C. (2002). Types and Programming Languages. MIT Press.
2. Harper, R. (2016). Practical Foundations for Programming Languages. Cambridge University Press.
3. Wadler, P. (1992). The essence of functional programming. In Proceedings of the 19th ACM SIGPLAN-SIGACT symposium on Principles of programming languages (pp. 1-14).
4. Milner, R. (1978). A theory of type polymorphism in programming. Journal of computer and system sciences, 17(3), 348-375.
5. Hindley, J. R. (1969). The principal type-scheme of an object in combinatory logic. Transactions of the American Mathematical Society, 146, 29-60.
6. Hoare, C. A. R. (1969). An axiomatic basis for computer programming. Communications of the ACM, 12(10), 576-580.
7. Plotkin, G. D. (1981). A structural approach to operational semantics. Journal of Logic and Algebraic Programming, 60, 17-139.

## 12. å¤šè¡¨å¾

ç¼–ç¨‹è¯­è¨€åŸºç¡€ç†è®ºæ”¯æŒå¤šç§è¡¨å¾æ–¹å¼ï¼ŒåŒ…æ‹¬ï¼š

- ç¬¦å·è¡¨å¾ï¼ˆè¯­æ³•ã€è¯­ä¹‰ã€ç±»å‹ã€æ“ä½œç¬¦ç­‰ï¼‰
- æŠ½è±¡è¯­æ³•æ ‘/å›¾ç»“æ„ï¼ˆASTã€ä¾èµ–å›¾ã€ç»“æ„å›¾ç­‰ï¼‰
- å‘é‡/å¼ é‡ï¼ˆè¯­æ³•åµŒå…¥ã€ç‰¹å¾å‘é‡ï¼‰
- è‡ªç„¶è¯­è¨€ï¼ˆå®šä¹‰ã€æ³¨é‡Šã€æè¿°ï¼‰
- å›¾åƒ/å¯è§†åŒ–ï¼ˆè¯­æ³•ç»“æ„å›¾ã€æµç¨‹å›¾ã€å¯¹æ¯”å›¾ç­‰ï¼‰
è¿™äº›è¡¨å¾å¯äº’æ˜ ï¼Œæå‡ç¼–ç¨‹è¯­è¨€ç†è®ºè¡¨è¾¾åŠ›ã€‚

## 13. å½¢å¼åŒ–è¯­ä¹‰

- è¯­ä¹‰åŸŸï¼š$D$ï¼Œå¦‚è¯­æ³•ç»“æ„é›†ã€ç±»å‹é›†ã€æ“ä½œç©ºé—´ã€æ¨¡å‹ç©ºé—´
- è§£é‡Šå‡½æ•°ï¼š$I: S \to D$ï¼Œå°†ç¬¦å·/ç»“æ„æ˜ å°„åˆ°å…·ä½“è¯­ä¹‰å¯¹è±¡
- è¯­ä¹‰ä¸€è‡´æ€§ï¼šæ¯ä¸ªç»“æ„/å…¬å¼/èŒƒå¼åœ¨$D$ä¸­æœ‰æ˜ç¡®å®šä¹‰

## 14. å½¢å¼åŒ–è¯­æ³•ä¸è¯æ˜

- è¯­æ³•è§„åˆ™ï¼šå¦‚è¯­æ³•äº§ç”Ÿå¼ã€æ¨ç†è§„åˆ™ã€ç±»å‹è§„åˆ™ã€çº¦æŸæ¡ä»¶
- **å®šç†**ï¼šç¼–ç¨‹è¯­è¨€åŸºç¡€ç†è®ºçš„è¯­æ³•ç³»ç»Ÿå…·ä¸€è‡´æ€§ä¸å¯æ‰©å±•æ€§ã€‚
- **è¯æ˜**ï¼šç”±è¯­æ³•äº§ç”Ÿå¼ã€ç±»å‹è§„åˆ™ä¸æ¨ç†è§„åˆ™é€’å½’å®šä¹‰ï¼Œä¿è¯ç³»ç»Ÿä¸€è‡´ä¸å¯æ‰©å±•ã€‚
