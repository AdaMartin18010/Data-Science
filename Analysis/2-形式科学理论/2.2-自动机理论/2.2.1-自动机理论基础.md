# 2.2.1-è‡ªåŠ¨æœºç†è®ºåŸºç¡€

## ğŸ“‘ ç›®å½•

- [2.2.1-è‡ªåŠ¨æœºç†è®ºåŸºç¡€](#221-è‡ªåŠ¨æœºç†è®ºåŸºç¡€)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ‘˜è¦](#1-æ‘˜è¦)
  - [2. è‡ªåŠ¨æœºç†è®ºæ¦‚è¿°](#2-è‡ªåŠ¨æœºç†è®ºæ¦‚è¿°)
    - [2.1. è‡ªåŠ¨æœºç†è®ºçš„å®šä¹‰](#21-è‡ªåŠ¨æœºç†è®ºçš„å®šä¹‰)
    - [2.2. è‡ªåŠ¨æœºç†è®ºçš„å‘å±•å†ç¨‹](#22-è‡ªåŠ¨æœºç†è®ºçš„å‘å±•å†ç¨‹)
    - [2.3. è‡ªåŠ¨æœºçš„åˆ†ç±»](#23-è‡ªåŠ¨æœºçš„åˆ†ç±»)
  - [3. æ¦‚è¿°](#3-æ¦‚è¿°)
  - [æœ‰é™è‡ªåŠ¨æœº (FA)](#æœ‰é™è‡ªåŠ¨æœº-fa)
    - [3.1. ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº (DFA)](#31-ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº-dfa)
      - [3.1.1. DFAå½¢å¼åŒ–å®šä¹‰](#311-dfaå½¢å¼åŒ–å®šä¹‰)
      - [3.1.2. DFAå®ç°ç¤ºä¾‹](#312-dfaå®ç°ç¤ºä¾‹)
    - [3.2. éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº (NFA)](#32-éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº-nfa)
      - [3.2.1. NFAå½¢å¼åŒ–å®šä¹‰](#321-nfaå½¢å¼åŒ–å®šä¹‰)
      - [3.2.2. NFAå®ç°ç¤ºä¾‹](#322-nfaå®ç°ç¤ºä¾‹)
    - [3.3. DFAä¸NFAç­‰ä»·æ€§](#33-dfaä¸nfaç­‰ä»·æ€§)
      - [3.3.1. å­é›†æ„é€ æ³•](#331-å­é›†æ„é€ æ³•)
      - [3.3.2. ç­‰ä»·æ€§è¯æ˜](#332-ç­‰ä»·æ€§è¯æ˜)
  - [4. ä¸‹æ¨è‡ªåŠ¨æœº (PDA)](#4-ä¸‹æ¨è‡ªåŠ¨æœº-pda)
    - [4.1. PDAå½¢å¼åŒ–å®šä¹‰](#41-pdaå½¢å¼åŒ–å®šä¹‰)
      - [4.1.1. PDAåŸºæœ¬ç»“æ„](#411-pdaåŸºæœ¬ç»“æ„)
      - [4.1.2. PDAå®ç°ç¤ºä¾‹](#412-pdaå®ç°ç¤ºä¾‹)
    - [4.2. ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•ä¸PDA](#42-ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•ä¸pda)
      - [4.2.1. ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•](#421-ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•)
      - [4.2.2. PDAä¸CFGç­‰ä»·æ€§](#422-pdaä¸cfgç­‰ä»·æ€§)
  - [5. å›¾çµæœº (TM)](#5-å›¾çµæœº-tm)
    - [5.1. åŸºæœ¬å›¾çµæœº](#51-åŸºæœ¬å›¾çµæœº)
      - [5.1.1. å›¾çµæœºå½¢å¼åŒ–å®šä¹‰](#511-å›¾çµæœºå½¢å¼åŒ–å®šä¹‰)
      - [5.1.2. å›¾çµæœºå®ç°ç¤ºä¾‹](#512-å›¾çµæœºå®ç°ç¤ºä¾‹)
    - [5.2. å›¾çµæœºå˜ä½“](#52-å›¾çµæœºå˜ä½“)
      - [5.2.1. å¤šå¸¦å›¾çµæœº](#521-å¤šå¸¦å›¾çµæœº)
      - [5.2.2. éç¡®å®šæ€§å›¾çµæœº](#522-éç¡®å®šæ€§å›¾çµæœº)
      - [5.2.3. é€šç”¨å›¾çµæœº](#523-é€šç”¨å›¾çµæœº)
  - [6. è®¡ç®—å¤æ‚æ€§](#6-è®¡ç®—å¤æ‚æ€§)
    - [6.1. æ—¶é—´å¤æ‚æ€§](#61-æ—¶é—´å¤æ‚æ€§)
      - [6.1.1. æ—¶é—´å¤æ‚æ€§å®šä¹‰](#611-æ—¶é—´å¤æ‚æ€§å®šä¹‰)
      - [6.1.2. å¤§Oè®°å·](#612-å¤§oè®°å·)
    - [6.2. ç©ºé—´å¤æ‚æ€§](#62-ç©ºé—´å¤æ‚æ€§)
      - [6.2.1. ç©ºé—´å¤æ‚æ€§å®šä¹‰](#621-ç©ºé—´å¤æ‚æ€§å®šä¹‰)
    - [6.3. å¤æ‚æ€§ç±»](#63-å¤æ‚æ€§ç±»)
      - [6.3.1. Pç±»](#631-pç±»)
      - [6.3.2. NPç±»](#632-npç±»)
      - [6.3.3. PSPACEç±»](#633-pspaceç±»)
  - [7. å¯è®¡ç®—æ€§ç†è®º](#7-å¯è®¡ç®—æ€§ç†è®º)
    - [7.1. å¯åˆ¤å®šæ€§](#71-å¯åˆ¤å®šæ€§)
      - [7.1.1. å¯åˆ¤å®šé—®é¢˜](#711-å¯åˆ¤å®šé—®é¢˜)
      - [7.1.2. ä¸å¯åˆ¤å®šé—®é¢˜](#712-ä¸å¯åˆ¤å®šé—®é¢˜)
    - [7.2. åœæœºé—®é¢˜](#72-åœæœºé—®é¢˜)
      - [7.2.1. åœæœºé—®é¢˜å®šä¹‰](#721-åœæœºé—®é¢˜å®šä¹‰)
      - [7.2.2. ä¸å¯åˆ¤å®šæ€§è¯æ˜](#722-ä¸å¯åˆ¤å®šæ€§è¯æ˜)
    - [7.3. é€’å½’å¯æšä¸¾æ€§](#73-é€’å½’å¯æšä¸¾æ€§)
      - [7.3.1. é€’å½’è¯­è¨€](#731-é€’å½’è¯­è¨€)
      - [7.3.2. é€’å½’å¯æšä¸¾è¯­è¨€](#732-é€’å½’å¯æšä¸¾è¯­è¨€)
  - [8. è‡ªåŠ¨æœºåº”ç”¨](#8-è‡ªåŠ¨æœºåº”ç”¨)
    - [8.1. ç¼–è¯‘å™¨è®¾è®¡](#81-ç¼–è¯‘å™¨è®¾è®¡)
      - [8.1.1. è¯æ³•åˆ†æ](#811-è¯æ³•åˆ†æ)
      - [8.1.2. è¯­æ³•åˆ†æ](#812-è¯­æ³•åˆ†æ)
    - [8.2. æ­£åˆ™è¡¨è¾¾å¼](#82-æ­£åˆ™è¡¨è¾¾å¼)
      - [8.2.1. æ­£åˆ™è¡¨è¾¾å¼å®šä¹‰](#821-æ­£åˆ™è¡¨è¾¾å¼å®šä¹‰)
      - [8.2.2. æ­£åˆ™è¡¨è¾¾å¼ä¸DFAç­‰ä»·æ€§](#822-æ­£åˆ™è¡¨è¾¾å¼ä¸dfaç­‰ä»·æ€§)
    - [8.3. å½¢å¼è¯­è¨€ç†è®º](#83-å½¢å¼è¯­è¨€ç†è®º)
      - [8.3.1. Chomskyå±‚æ¬¡](#831-chomskyå±‚æ¬¡)
      - [8.3.2. è¯­è¨€ç±»åŒ…å«å…³ç³»](#832-è¯­è¨€ç±»åŒ…å«å…³ç³»)
  - [è‡ªåŠ¨æœºå®ç°](#è‡ªåŠ¨æœºå®ç°)
    - [DFAå®ç°](#dfaå®ç°)
    - [å›¾çµæœºå®ç°](#å›¾çµæœºå®ç°)
  - [é«˜çº§ä¸»é¢˜](#é«˜çº§ä¸»é¢˜)
    - [é‡å­è‡ªåŠ¨æœº](#é‡å­è‡ªåŠ¨æœº)
    - [æ¦‚ç‡è‡ªåŠ¨æœº](#æ¦‚ç‡è‡ªåŠ¨æœº)
    - [ç»†èƒè‡ªåŠ¨æœº](#ç»†èƒè‡ªåŠ¨æœº)
  - [9. å½¢å¼åŒ–å®šä¹‰ä¸è¯æ˜](#9-å½¢å¼åŒ–å®šä¹‰ä¸è¯æ˜)
    - [9.1. è‡ªåŠ¨æœºå½¢å¼åŒ–](#91-è‡ªåŠ¨æœºå½¢å¼åŒ–)
    - [9.2. è¯­è¨€æ¥å—å½¢å¼åŒ–](#92-è¯­è¨€æ¥å—å½¢å¼åŒ–)
  - [10. å¤šè¡¨å¾](#10-å¤šè¡¨å¾)
  - [11. æ€»ç»“ä¸å±•æœ›](#11-æ€»ç»“ä¸å±•æœ›)
    - [11.1. æ€»ç»“](#111-æ€»ç»“)
    - [11.2. æœªæ¥å±•æœ›](#112-æœªæ¥å±•æœ›)
  - [12. å‚è€ƒæ–‡çŒ®](#12-å‚è€ƒæ–‡çŒ®)

---


## 1. æ‘˜è¦

è‡ªåŠ¨æœºç†è®ºæ˜¯è®¡ç®—ç†è®ºçš„æ ¸å¿ƒåˆ†æ”¯ï¼Œç ”ç©¶æŠ½è±¡è®¡ç®—æ¨¡å‹çš„å½¢å¼åŒ–å®šä¹‰ã€æ€§è´¨å’Œè®¡ç®—èƒ½åŠ›ã€‚æœ¬æ–‡æ¡£ç³»ç»Ÿæ¢³ç†è‡ªåŠ¨æœºç†è®ºåŸºç¡€ï¼Œæ¶µç›–æœ‰é™è‡ªåŠ¨æœºã€ä¸‹æ¨è‡ªåŠ¨æœºã€å›¾çµæœºç­‰åŸºæœ¬æ¦‚å¿µï¼Œä»¥åŠè®¡ç®—å¤æ‚æ€§ã€å¯è®¡ç®—æ€§ç†è®ºç­‰æ ¸å¿ƒå†…å®¹ï¼Œä¸ºè®¡ç®—æœºç§‘å­¦å’Œè½¯ä»¶å·¥ç¨‹æä¾›é‡è¦çš„ç†è®ºåŸºç¡€ã€‚

---

## 2. è‡ªåŠ¨æœºç†è®ºæ¦‚è¿°

### 2.1. è‡ªåŠ¨æœºç†è®ºçš„å®šä¹‰

**è‡ªåŠ¨æœºç†è®ºï¼ˆAutomata Theoryï¼‰**æ˜¯ç ”ç©¶æŠ½è±¡è®¡ç®—æ¨¡å‹å’Œå½¢å¼è¯­è¨€çš„æ•°å­¦ç†è®ºï¼Œå®ƒæä¾›äº†è®¡ç®—çš„å½¢å¼åŒ–åŸºç¡€ã€‚

**è‡ªåŠ¨æœºçš„æ ¸å¿ƒæ¦‚å¿µ**ï¼š

1. **çŠ¶æ€ï¼ˆStateï¼‰**ï¼šç³»ç»Ÿåœ¨æŸä¸ªæ—¶åˆ»çš„é…ç½®
2. **è½¬ç§»ï¼ˆTransitionï¼‰**ï¼šä»ä¸€ä¸ªçŠ¶æ€åˆ°å¦ä¸€ä¸ªçŠ¶æ€çš„å˜åŒ–
3. **è¾“å…¥ï¼ˆInputï¼‰**ï¼šç³»ç»Ÿæ¥æ”¶çš„ç¬¦å·åºåˆ—
4. **æ¥å—ï¼ˆAcceptanceï¼‰**ï¼šç³»ç»Ÿå¯¹è¾“å…¥çš„åˆ¤å®šç»“æœ

**è‡ªåŠ¨æœºç†è®ºçš„ç ”ç©¶å†…å®¹**ï¼š

- **è‡ªåŠ¨æœºæ¨¡å‹**ï¼šDFAã€NFAã€PDAã€TMç­‰
- **è¯­è¨€è¯†åˆ«**ï¼šè‡ªåŠ¨æœºæ¥å—çš„è¯­è¨€ç±»
- **è®¡ç®—èƒ½åŠ›**ï¼šä¸åŒè‡ªåŠ¨æœºçš„è®¡ç®—èƒ½åŠ›
- **å¤æ‚æ€§åˆ†æ**ï¼šæ—¶é—´å’Œç©ºé—´å¤æ‚æ€§

### 2.2. è‡ªåŠ¨æœºç†è®ºçš„å‘å±•å†ç¨‹

**è‡ªåŠ¨æœºç†è®ºå‘å±•æ—¶é—´çº¿**ï¼š

1. **1936å¹´**ï¼šå›¾çµæå‡ºå›¾çµæœºæ¨¡å‹ï¼ˆTuring, 1936ï¼‰
2. **1943å¹´**ï¼šMcCullochå’ŒPittsæå‡ºç¥ç»ç½‘ç»œæ¨¡å‹
3. **1951å¹´**ï¼šKleeneæå‡ºæ­£åˆ™è¡¨è¾¾å¼
4. **1956å¹´**ï¼šChomskyæå‡ºå½¢å¼è¯­è¨€å±‚æ¬¡
5. **1959å¹´**ï¼šRabinå’ŒScottè¯æ˜DFAä¸NFAç­‰ä»·
6. **1960s**ï¼šä¸‹æ¨è‡ªåŠ¨æœºç†è®ºå‘å±•
7. **1970s**ï¼šè®¡ç®—å¤æ‚æ€§ç†è®ºå»ºç«‹

### 2.3. è‡ªåŠ¨æœºçš„åˆ†ç±»

**æŒ‰è®¡ç®—èƒ½åŠ›åˆ†ç±»**ï¼š

1. **æœ‰é™è‡ªåŠ¨æœºï¼ˆFAï¼‰**ï¼šè¯†åˆ«æ­£åˆ™è¯­è¨€
2. **ä¸‹æ¨è‡ªåŠ¨æœºï¼ˆPDAï¼‰**ï¼šè¯†åˆ«ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€
3. **çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœºï¼ˆLBAï¼‰**ï¼šè¯†åˆ«ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€
4. **å›¾çµæœºï¼ˆTMï¼‰**ï¼šè¯†åˆ«é€’å½’å¯æšä¸¾è¯­è¨€

**æŒ‰ç¡®å®šæ€§åˆ†ç±»**ï¼š

1. **ç¡®å®šæ€§è‡ªåŠ¨æœº**ï¼šæ¯ä¸ªçŠ¶æ€å’Œè¾“å…¥ç¬¦å·æœ‰å”¯ä¸€è½¬ç§»
2. **éç¡®å®šæ€§è‡ªåŠ¨æœº**ï¼šæ¯ä¸ªçŠ¶æ€å’Œè¾“å…¥ç¬¦å·å¯èƒ½æœ‰å¤šä¸ªè½¬ç§»

---

## 3. æ¦‚è¿°

è‡ªåŠ¨æœºç†è®ºæ˜¯è®¡ç®—ç†è®ºçš„æ ¸å¿ƒåˆ†æ”¯ï¼Œç ”ç©¶æŠ½è±¡è®¡ç®—æ¨¡å‹çš„å½¢å¼åŒ–å®šä¹‰ã€æ€§è´¨å’Œè®¡ç®—èƒ½åŠ›ã€‚æœ¬æ¨¡å—ä»‹ç»æœ‰é™è‡ªåŠ¨æœºã€ä¸‹æ¨è‡ªåŠ¨æœºã€å›¾çµæœºç­‰åŸºæœ¬æ¦‚å¿µã€‚

## æœ‰é™è‡ªåŠ¨æœº (FA)

### 3.1. ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº (DFA)

#### 3.1.1. DFAå½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 3.1.1ï¼ˆç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœºï¼‰**:

ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœºæ˜¯ä¸€ä¸ªäº”å…ƒç»„ $M = (Q, \Sigma, \delta, q_0, F)$ï¼Œå…¶ä¸­ï¼š

- $Q$ï¼šæœ‰é™çŠ¶æ€é›†åˆ
- $\Sigma$ï¼šæœ‰é™è¾“å…¥å­—æ¯è¡¨
- $\delta: Q \times \Sigma \to Q$ï¼šè½¬ç§»å‡½æ•°
- $q_0 \in Q$ï¼šåˆå§‹çŠ¶æ€
- $F \subseteq Q$ï¼šæ¥å—çŠ¶æ€é›†åˆ

**æ‰©å±•è½¬ç§»å‡½æ•°**ï¼š

$$\delta^*(q, \varepsilon) = q$$

$$\delta^*(q, wa) = \delta(\delta^*(q, w), a)$$

å…¶ä¸­ $w \in \Sigma^*$ï¼Œ$a \in \Sigma$ã€‚

**è¯­è¨€æ¥å—**ï¼š

$$L(M) = \{w \in \Sigma^* \mid \delta^*(q_0, w) \in F\}$$

#### 3.1.2. DFAå®ç°ç¤ºä¾‹

```python
class DFA:
    def __init__(self, states, alphabet, transitions, start_state, accept_states):
        self.states = states
        self.alphabet = alphabet
        self.transitions = transitions
        self.start_state = start_state
        self.accept_states = accept_states

    def process(self, input_string):
        """å¤„ç†è¾“å…¥å­—ç¬¦ä¸²"""
        current_state = self.start_state
        for symbol in input_string:
            if symbol not in self.alphabet:
                return False
            if (current_state, symbol) not in self.transitions:
                return False
            current_state = self.transitions[(current_state, symbol)]
        return current_state in self.accept_states

# ç¤ºä¾‹ï¼šè¯†åˆ«ä»¥"ab"ç»“å°¾çš„å­—ç¬¦ä¸²
dfa = DFA(
    states={'q0', 'q1', 'q2'},
    alphabet={'a', 'b'},
    transitions={
        ('q0', 'a'): 'q1', ('q0', 'b'): 'q0',
        ('q1', 'a'): 'q1', ('q1', 'b'): 'q2',
        ('q2', 'a'): 'q1', ('q2', 'b'): 'q0',
    },
    start_state='q0',
    accept_states={'q2'}
)
```

### 3.2. éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº (NFA)

#### 3.2.1. NFAå½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 3.2.1ï¼ˆéç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœºï¼‰**:

éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœºæ˜¯ä¸€ä¸ªäº”å…ƒç»„ $M = (Q, \Sigma, \delta, q_0, F)$ï¼Œå…¶ä¸­ï¼š

- $Q$ï¼šæœ‰é™çŠ¶æ€é›†åˆ
- $\Sigma$ï¼šæœ‰é™è¾“å…¥å­—æ¯è¡¨
- $\delta: Q \times \Sigma \to 2^Q$ï¼šè½¬ç§»å‡½æ•°ï¼ˆè¿”å›çŠ¶æ€é›†åˆï¼‰
- $q_0 \in Q$ï¼šåˆå§‹çŠ¶æ€
- $F \subseteq Q$ï¼šæ¥å—çŠ¶æ€é›†åˆ

**æ‰©å±•è½¬ç§»å‡½æ•°**ï¼š

$$\delta^*(q, \varepsilon) = \{q\}$$

$$\delta^*(q, wa) = \bigcup_{p \in \delta^*(q, w)} \delta(p, a)$$

**è¯­è¨€æ¥å—**ï¼š

$$L(M) = \{w \in \Sigma^* \mid \delta^*(q_0, w) \cap F \neq \emptyset\}$$

#### 3.2.2. NFAå®ç°ç¤ºä¾‹

```python
class NFA:
    def __init__(self, states, alphabet, transitions, start_state, accept_states):
        self.states = states
        self.alphabet = alphabet
        self.transitions = transitions  # (state, symbol) -> set of states
        self.start_state = start_state
        self.accept_states = accept_states

    def epsilon_closure(self, states):
        """è®¡ç®—Îµé—­åŒ…"""
        closure = set(states)
        stack = list(states)
        while stack:
            state = stack.pop()
            if (state, 'Îµ') in self.transitions:
                for next_state in self.transitions[(state, 'Îµ')]:
                    if next_state not in closure:
                        closure.add(next_state)
                        stack.append(next_state)
        return closure

    def process(self, input_string):
        """å¤„ç†è¾“å…¥å­—ç¬¦ä¸²"""
        current_states = self.epsilon_closure({self.start_state})
        for symbol in input_string:
            next_states = set()
            for state in current_states:
                if (state, symbol) in self.transitions:
                    next_states.update(self.transitions[(state, symbol)])
            current_states = self.epsilon_closure(next_states)
        return bool(current_states & self.accept_states)
```

### 3.3. DFAä¸NFAç­‰ä»·æ€§

#### 3.3.1. å­é›†æ„é€ æ³•

**å®šç† 3.3.1ï¼ˆNFAä¸DFAç­‰ä»·ï¼‰**:

å¯¹äºæ¯ä¸ªNFA $M$ï¼Œå­˜åœ¨ç­‰ä»·çš„DFA $M'$ ä½¿å¾— $L(M) = L(M')$ã€‚

**å­é›†æ„é€ æ³•**ï¼š

ç»™å®šNFA $M = (Q, \Sigma, \delta, q_0, F)$ï¼Œæ„é€ DFA $M' = (Q', \Sigma, \delta', q_0', F')$ï¼š

1. **çŠ¶æ€é›†åˆ**ï¼š$Q' = 2^Q$ï¼ˆNFAçŠ¶æ€é›†åˆçš„å¹‚é›†ï¼‰
2. **åˆå§‹çŠ¶æ€**ï¼š$q_0' = \text{ECLOSE}(q_0)$
3. **è½¬ç§»å‡½æ•°**ï¼š$\delta'(S, a) = \bigcup_{q \in S} \text{ECLOSE}(\delta(q, a))$
4. **æ¥å—çŠ¶æ€**ï¼š$F' = \{S \subseteq Q \mid S \cap F \neq \emptyset\}$

#### 3.3.2. ç­‰ä»·æ€§è¯æ˜

**è¯æ˜æ€è·¯**ï¼š

1. **è¯­è¨€åŒ…å«**ï¼š$L(M) \subseteq L(M')$
   - å¯¹äº $w \in L(M)$ï¼Œå­˜åœ¨æ¥å—è·¯å¾„
   - DFA $M'$ æ¨¡æ‹ŸNFA $M$ çš„æ‰€æœ‰å¯èƒ½è·¯å¾„
   - å› æ­¤ $w \in L(M')$

2. **è¯­è¨€åŒ…å«**ï¼š$L(M') \subseteq L(M)$
   - å¯¹äº $w \in L(M')$ï¼ŒDFA $M'$ åˆ°è¾¾æ¥å—çŠ¶æ€
   - è¯¥æ¥å—çŠ¶æ€å¯¹åº”NFA $M$ çš„æ¥å—çŠ¶æ€é›†åˆ
   - å› æ­¤ $w \in L(M)$

## 4. ä¸‹æ¨è‡ªåŠ¨æœº (PDA)

### 4.1. PDAå½¢å¼åŒ–å®šä¹‰

#### 4.1.1. PDAåŸºæœ¬ç»“æ„

**å®šä¹‰ 4.1.1ï¼ˆä¸‹æ¨è‡ªåŠ¨æœºï¼‰**:

ä¸‹æ¨è‡ªåŠ¨æœºæ˜¯ä¸€ä¸ªä¸ƒå…ƒç»„ $M = (Q, \Sigma, \Gamma, \delta, q_0, Z_0, F)$ï¼Œå…¶ä¸­ï¼š

- $Q$ï¼šæœ‰é™çŠ¶æ€é›†åˆ
- $\Sigma$ï¼šæœ‰é™è¾“å…¥å­—æ¯è¡¨
- $\Gamma$ï¼šæœ‰é™æ ˆå­—æ¯è¡¨
- $\delta: Q \times (\Sigma \cup \{\varepsilon\}) \times \Gamma \to 2^{Q \times \Gamma^*}$ï¼šè½¬ç§»å‡½æ•°
- $q_0 \in Q$ï¼šåˆå§‹çŠ¶æ€
- $Z_0 \in \Gamma$ï¼šåˆå§‹æ ˆç¬¦å·
- $F \subseteq Q$ï¼šæ¥å—çŠ¶æ€é›†åˆ

**PDAé…ç½®**ï¼š

é…ç½®æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $(q, w, \gamma)$ï¼Œå…¶ä¸­ï¼š

- $q \in Q$ï¼šå½“å‰çŠ¶æ€
- $w \in \Sigma^*$ï¼šå‰©ä½™è¾“å…¥
- $\gamma \in \Gamma^*$ï¼šæ ˆå†…å®¹

**è½¬ç§»å…³ç³»**ï¼š

$$(q, aw, Z\gamma) \vdash (p, w, \alpha\gamma)$$

å½“ä¸”ä»…å½“ $(p, \alpha) \in \delta(q, a, Z)$ã€‚

**è¯­è¨€æ¥å—**ï¼š

$$L(M) = \{w \in \Sigma^* \mid (q_0, w, Z_0) \vdash^* (q, \varepsilon, \gamma), q \in F\}$$

#### 4.1.2. PDAå®ç°ç¤ºä¾‹

```python
class PDA:
    def __init__(self, states, alphabet, stack_alphabet, transitions,
                 start_state, start_stack_symbol, accept_states):
        self.states = states
        self.alphabet = alphabet
        self.stack_alphabet = stack_alphabet
        self.transitions = transitions
        self.start_state = start_state
        self.start_stack_symbol = start_stack_symbol
        self.accept_states = accept_states

    def process(self, input_string):
        """å¤„ç†è¾“å…¥å­—ç¬¦ä¸²ï¼ˆæŒ‰æœ€ç»ˆçŠ¶æ€æ¥å—ï¼‰"""
        configs = [(self.start_state, input_string, [self.start_stack_symbol])]
        while configs:
            state, remaining, stack = configs.pop()
            if not remaining and state in self.accept_states:
                return True
            current_input = remaining[0] if remaining else 'Îµ'
            stack_top = stack[-1] if stack else None
            for input_symbol in [current_input, 'Îµ']:
                if (state, input_symbol, stack_top) in self.transitions:
                    for next_state, stack_push in self.transitions[(state, input_symbol, stack_top)]:
                        new_remaining = remaining[1:] if input_symbol == current_input and remaining else remaining
                        new_stack = stack[:-1] + list(reversed(stack_push))
                        configs.append((next_state, new_remaining, new_stack))
        return False
```

### 4.2. ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•ä¸PDA

#### 4.2.1. ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•

**å®šä¹‰ 4.2.1ï¼ˆä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•ï¼‰**:

ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•æ˜¯ä¸€ä¸ªå››å…ƒç»„ $G = (V, T, P, S)$ï¼Œå…¶ä¸­ï¼š

- $V$ï¼šéç»ˆç»“ç¬¦é›†åˆ
- $T$ï¼šç»ˆç»“ç¬¦é›†åˆ
- $P$ï¼šäº§ç”Ÿå¼é›†åˆï¼Œå½¢å¼ä¸º $A \to \alpha$ï¼Œå…¶ä¸­ $A \in V$ï¼Œ$\alpha \in (V \cup T)^*$
- $S \in V$ï¼šå¼€å§‹ç¬¦å·

#### 4.2.2. PDAä¸CFGç­‰ä»·æ€§

**å®šç† 4.2.1ï¼ˆPDAä¸CFGç­‰ä»·ï¼‰**:

è¯­è¨€ $L$ æ˜¯ä¸Šä¸‹æ–‡æ— å…³çš„å½“ä¸”ä»…å½“å­˜åœ¨PDA $M$ ä½¿å¾— $L(M) = L$ã€‚

**è¯æ˜æ€è·¯**ï¼š

1. **CFGåˆ°PDA**ï¼šæ„é€ PDAæ¨¡æ‹ŸCFGçš„æ¨å¯¼
2. **PDAåˆ°CFG**ï¼šä»PDAæ„é€ ç­‰ä»·çš„CFG

## 5. å›¾çµæœº (TM)

### 5.1. åŸºæœ¬å›¾çµæœº

#### 5.1.1. å›¾çµæœºå½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 5.1.1ï¼ˆå›¾çµæœºï¼‰**:

å›¾çµæœºæ˜¯ä¸€ä¸ªä¸ƒå…ƒç»„ $M = (Q, \Sigma, \Gamma, \delta, q_0, B, F)$ï¼Œå…¶ä¸­ï¼š

- $Q$ï¼šæœ‰é™çŠ¶æ€é›†åˆ
- $\Sigma$ï¼šæœ‰é™è¾“å…¥å­—æ¯è¡¨
- $\Gamma$ï¼šæœ‰é™å¸¦å­—æ¯è¡¨ï¼Œ$\Sigma \subseteq \Gamma$
- $\delta: Q \times \Gamma \to Q \times \Gamma \times \{L, R\}$ï¼šè½¬ç§»å‡½æ•°
- $q_0 \in Q$ï¼šåˆå§‹çŠ¶æ€
- $B \in \Gamma \setminus \Sigma$ï¼šç©ºç™½ç¬¦å·
- $F \subseteq Q$ï¼šæ¥å—çŠ¶æ€é›†åˆ

**å›¾çµæœºé…ç½®**ï¼š

é…ç½®æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $(q, \alpha, \beta)$ï¼Œå…¶ä¸­ï¼š

- $q \in Q$ï¼šå½“å‰çŠ¶æ€
- $\alpha \in \Gamma^*$ï¼šå¸¦å¤´å·¦ä¾§çš„å¸¦å†…å®¹
- $\beta \in \Gamma^*$ï¼šå¸¦å¤´ä½ç½®åŠå…¶å³ä¾§çš„å¸¦å†…å®¹

**è½¬ç§»å…³ç³»**ï¼š

$$(q, X\alpha, Y\beta) \vdash (p, X\alpha, Z\beta)$$

å¦‚æœ $\delta(q, Y) = (p, Z, R)$ã€‚

**è¯­è¨€æ¥å—**ï¼š

$$L(M) = \{w \in \Sigma^* \mid (q_0, \varepsilon, w) \vdash^* (q, \alpha, \beta), q \in F\}$$

#### 5.1.2. å›¾çµæœºå®ç°ç¤ºä¾‹

```python
class TuringMachine:
    def __init__(self, states, alphabet, tape_alphabet, transitions,
                 start_state, blank_symbol, accept_states):
        self.states = states
        self.alphabet = alphabet
        self.tape_alphabet = tape_alphabet
        self.transitions = transitions
        self.start_state = start_state
        self.blank_symbol = blank_symbol
        self.accept_states = accept_states

    def run(self, input_string, max_steps=10000):
        """è¿è¡Œå›¾çµæœº"""
        tape_left = []
        tape_right = list(input_string)
        current_state = self.start_state
        head_pos = 0
        steps = 0
        while current_state not in self.accept_states and steps < max_steps:
            steps += 1
            current_symbol = tape_right[head_pos] if head_pos < len(tape_right) else self.blank_symbol
            if (current_state, current_symbol) not in self.transitions:
                return False, steps
            next_state, write_symbol, direction = self.transitions[(current_state, current_symbol)]
            if head_pos < len(tape_right):
                tape_right[head_pos] = write_symbol
            else:
                tape_right.append(write_symbol)
            if direction == 'R':
                head_pos += 1
            elif direction == 'L' and head_pos > 0:
                head_pos -= 1
            current_state = next_state
        return current_state in self.accept_states, steps
```

### 5.2. å›¾çµæœºå˜ä½“

#### 5.2.1. å¤šå¸¦å›¾çµæœº

**å®šä¹‰ 5.2.1ï¼ˆkå¸¦å›¾çµæœºï¼‰**:

kå¸¦å›¾çµæœºæœ‰kæ¡å¸¦ï¼Œæ¯æ¡å¸¦éƒ½æœ‰è‡ªå·±çš„å¸¦å¤´ã€‚

**å®šç† 5.2.1ï¼ˆå¤šå¸¦å›¾çµæœºç­‰ä»·æ€§ï¼‰**:

kå¸¦å›¾çµæœºä¸å•å¸¦å›¾çµæœºç­‰ä»·ã€‚

#### 5.2.2. éç¡®å®šæ€§å›¾çµæœº

**å®šä¹‰ 5.2.2ï¼ˆéç¡®å®šæ€§å›¾çµæœºï¼‰**:

éç¡®å®šæ€§å›¾çµæœºçš„è½¬ç§»å‡½æ•°ä¸ºï¼š

$$\delta: Q \times \Gamma \to 2^{Q \times \Gamma \times \{L, R\}}$$

**å®šç† 5.2.2ï¼ˆéç¡®å®šæ€§å›¾çµæœºç­‰ä»·æ€§ï¼‰**:

éç¡®å®šæ€§å›¾çµæœºä¸ç¡®å®šæ€§å›¾çµæœºç­‰ä»·ï¼ˆåœ¨è®¡ç®—èƒ½åŠ›ä¸Šï¼‰ã€‚

#### 5.2.3. é€šç”¨å›¾çµæœº

**å®šä¹‰ 5.2.3ï¼ˆé€šç”¨å›¾çµæœºï¼‰**:

é€šç”¨å›¾çµæœºå¯ä»¥æ¨¡æ‹Ÿä»»æ„å›¾çµæœºçš„è®¡ç®—ã€‚

**å®šç† 5.2.3ï¼ˆé€šç”¨å›¾çµæœºå­˜åœ¨æ€§ï¼‰**:

å­˜åœ¨é€šç”¨å›¾çµæœº $U$ï¼Œå¯¹äºä»»æ„å›¾çµæœº $M$ å’Œè¾“å…¥ $w$ï¼š

$$U(\langle M, w \rangle) = M(w)$$

## 6. è®¡ç®—å¤æ‚æ€§

### 6.1. æ—¶é—´å¤æ‚æ€§

#### 6.1.1. æ—¶é—´å¤æ‚æ€§å®šä¹‰

**å®šä¹‰ 6.1.1ï¼ˆæ—¶é—´å¤æ‚æ€§ï¼‰**:

å¯¹äºå›¾çµæœº $M$ï¼Œæ—¶é—´å¤æ‚æ€§å‡½æ•° $T_M: \mathbb{N} \to \mathbb{N}$ å®šä¹‰ä¸ºï¼š

$$T_M(n) = \max\{t \mid \text{å­˜åœ¨é•¿åº¦ä¸º}n\text{çš„è¾“å…¥}w\text{ï¼Œ}M\text{åœ¨}w\text{ä¸Šè¿è¡Œ}t\text{æ­¥}\}$$

#### 6.1.2. å¤§Oè®°å·

**å®šä¹‰ 6.1.2ï¼ˆå¤§Oè®°å·ï¼‰**:

$$f(n) = O(g(n)) \Leftrightarrow \exists c > 0, n_0 > 0: \forall n \geq n_0, f(n) \leq c \cdot g(n)$$

**å¸¸è§æ—¶é—´å¤æ‚æ€§ç±»**ï¼š

- $O(1)$ï¼šå¸¸æ•°æ—¶é—´
- $O(\log n)$ï¼šå¯¹æ•°æ—¶é—´
- $O(n)$ï¼šçº¿æ€§æ—¶é—´
- $O(n \log n)$ï¼šçº¿æ€§å¯¹æ•°æ—¶é—´
- $O(n^2)$ï¼šå¹³æ–¹æ—¶é—´
- $O(2^n)$ï¼šæŒ‡æ•°æ—¶é—´

### 6.2. ç©ºé—´å¤æ‚æ€§

#### 6.2.1. ç©ºé—´å¤æ‚æ€§å®šä¹‰

**å®šä¹‰ 6.2.1ï¼ˆç©ºé—´å¤æ‚æ€§ï¼‰**:

å¯¹äºå›¾çµæœº $M$ï¼Œç©ºé—´å¤æ‚æ€§å‡½æ•° $S_M: \mathbb{N} \to \mathbb{N}$ å®šä¹‰ä¸ºï¼š

$$S_M(n) = \max\{s \mid \text{å­˜åœ¨é•¿åº¦ä¸º}n\text{çš„è¾“å…¥}w\text{ï¼Œ}M\text{åœ¨}w\text{ä¸Šä½¿ç”¨}s\text{ä¸ªå¸¦æ ¼å­}\}$$

### 6.3. å¤æ‚æ€§ç±»

#### 6.3.1. Pç±»

**å®šä¹‰ 6.3.1ï¼ˆPç±»ï¼‰**:

$$P = \bigcup_{k \geq 0} \text{TIME}(n^k)$$

Pç±»åŒ…å«æ‰€æœ‰åœ¨å¤šé¡¹å¼æ—¶é—´å†…å¯åˆ¤å®šçš„è¯­è¨€ã€‚

#### 6.3.2. NPç±»

**å®šä¹‰ 6.3.2ï¼ˆNPç±»ï¼‰**:

$$NP = \bigcup_{k \geq 0} \text{NTIME}(n^k)$$

NPç±»åŒ…å«æ‰€æœ‰åœ¨éç¡®å®šæ€§å¤šé¡¹å¼æ—¶é—´å†…å¯åˆ¤å®šçš„è¯­è¨€ã€‚

**NPå®Œå…¨é—®é¢˜**ï¼š

- å¸ƒå°”å¯æ»¡è¶³æ€§é—®é¢˜ï¼ˆSATï¼‰
- æ—…è¡Œå•†é—®é¢˜ï¼ˆTSPï¼‰
- å›¾ç€è‰²é—®é¢˜

#### 6.3.3. PSPACEç±»

**å®šä¹‰ 6.3.3ï¼ˆPSPACEç±»ï¼‰**:

$$PSPACE = \bigcup_{k \geq 0} \text{SPACE}(n^k)$$

PSPACEç±»åŒ…å«æ‰€æœ‰åœ¨å¤šé¡¹å¼ç©ºé—´å†…å¯åˆ¤å®šçš„è¯­è¨€ã€‚

**å¤æ‚æ€§ç±»åŒ…å«å…³ç³»**ï¼š

$$P \subseteq NP \subseteq PSPACE \subseteq EXPTIME$$

## 7. å¯è®¡ç®—æ€§ç†è®º

### 7.1. å¯åˆ¤å®šæ€§

#### 7.1.1. å¯åˆ¤å®šé—®é¢˜

**å®šä¹‰ 7.1.1ï¼ˆå¯åˆ¤å®šé—®é¢˜ï¼‰**:

é—®é¢˜ $P$ æ˜¯å¯åˆ¤å®šçš„ï¼Œå¦‚æœå­˜åœ¨å›¾çµæœº $M$ï¼Œå¯¹äºæ‰€æœ‰è¾“å…¥ï¼š

- å¦‚æœè¾“å…¥ $\in P$ï¼Œ$M$ æ¥å—
- å¦‚æœè¾“å…¥ $\notin P$ï¼Œ$M$ æ‹’ç»

**å¯åˆ¤å®šé—®é¢˜ç¤ºä¾‹**ï¼š

- æ­£åˆ™è¯­è¨€æˆå‘˜é—®é¢˜
- ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€æˆå‘˜é—®é¢˜
- æœ‰é™è‡ªåŠ¨æœºç­‰ä»·é—®é¢˜

#### 7.1.2. ä¸å¯åˆ¤å®šé—®é¢˜

**ä¸å¯åˆ¤å®šé—®é¢˜ç¤ºä¾‹**ï¼š

- åœæœºé—®é¢˜
- Postå¯¹åº”é—®é¢˜
- å›¾çµæœºç­‰ä»·é—®é¢˜

### 7.2. åœæœºé—®é¢˜

#### 7.2.1. åœæœºé—®é¢˜å®šä¹‰

**å®šä¹‰ 7.2.1ï¼ˆåœæœºé—®é¢˜ï¼‰**:

åœæœºé—®é¢˜æ˜¯ï¼šç»™å®šå›¾çµæœº $M$ å’Œè¾“å…¥ $w$ï¼Œåˆ¤æ–­ $M$ åœ¨ $w$ ä¸Šæ˜¯å¦åœæœºã€‚

#### 7.2.2. ä¸å¯åˆ¤å®šæ€§è¯æ˜

**å®šç† 7.2.1ï¼ˆåœæœºé—®é¢˜ä¸å¯åˆ¤å®šï¼‰**:

åœæœºé—®é¢˜æ˜¯ä¸å¯åˆ¤å®šçš„ã€‚

**è¯æ˜**ï¼ˆåè¯æ³•ï¼‰ï¼š

å‡è®¾å­˜åœ¨å›¾çµæœº $H$ åˆ¤å®šåœæœºé—®é¢˜ã€‚æ„é€ å›¾çµæœº $D$ï¼š

$$
D(\langle M \rangle) = \begin{cases}
\text{æ¥å—} & \text{å¦‚æœ}H(\langle M, \langle M \rangle \rangle)\text{æ‹’ç»} \\
\text{å¾ªç¯} & \text{å¦‚æœ}H(\langle M, \langle M \rangle \rangle)\text{æ¥å—}
\end{cases}
$$

è€ƒè™‘ $D(\langle D \rangle)$ ä¼šå¯¼è‡´çŸ›ç›¾ï¼Œå› æ­¤åœæœºé—®é¢˜æ˜¯ä¸å¯åˆ¤å®šçš„ã€‚

### 7.3. é€’å½’å¯æšä¸¾æ€§

#### 7.3.1. é€’å½’è¯­è¨€

**å®šä¹‰ 7.3.1ï¼ˆé€’å½’è¯­è¨€ï¼‰**:

è¯­è¨€ $L$ æ˜¯é€’å½’çš„ï¼Œå¦‚æœå­˜åœ¨å›¾çµæœº $M$ï¼š

- å¦‚æœ $w \in L$ï¼Œ$M$ æ¥å— $w$
- å¦‚æœ $w \notin L$ï¼Œ$M$ æ‹’ç» $w$

#### 7.3.2. é€’å½’å¯æšä¸¾è¯­è¨€

**å®šä¹‰ 7.3.2ï¼ˆé€’å½’å¯æšä¸¾è¯­è¨€ï¼‰**:

è¯­è¨€ $L$ æ˜¯é€’å½’å¯æšä¸¾çš„ï¼Œå¦‚æœå­˜åœ¨å›¾çµæœº $M$ï¼š

- å¦‚æœ $w \in L$ï¼Œ$M$ æ¥å— $w$
- å¦‚æœ $w \notin L$ï¼Œ$M$ å¯èƒ½æ‹’ç»æˆ–æ°¸ä¸åœæœº

**å…³ç³»**ï¼š

$$\text{é€’å½’è¯­è¨€} \subset \text{é€’å½’å¯æšä¸¾è¯­è¨€}$$

## 8. è‡ªåŠ¨æœºåº”ç”¨

### 8.1. ç¼–è¯‘å™¨è®¾è®¡

#### 8.1.1. è¯æ³•åˆ†æ

**è¯æ³•åˆ†æå™¨**ä½¿ç”¨DFAè¯†åˆ«è¯æ³•å•å…ƒï¼ˆtokenï¼‰ã€‚

**ç¤ºä¾‹**ï¼šè¯†åˆ«æ ‡è¯†ç¬¦

```python
# æ ‡è¯†ç¬¦DFAï¼šå­—æ¯å¼€å¤´ï¼Œåè·Ÿå­—æ¯æˆ–æ•°å­—
identifier_dfa = DFA(
    states={'q0', 'q1'},
    alphabet=set('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'),
    transitions={...},
    start_state='q0',
    accept_states={'q1'}
)
```

#### 8.1.2. è¯­æ³•åˆ†æ

**è¯­æ³•åˆ†æå™¨**ä½¿ç”¨PDAè¿›è¡Œè¯­æ³•åˆ†æã€‚

### 8.2. æ­£åˆ™è¡¨è¾¾å¼

#### 8.2.1. æ­£åˆ™è¡¨è¾¾å¼å®šä¹‰

**å®šä¹‰ 8.2.1ï¼ˆæ­£åˆ™è¡¨è¾¾å¼ï¼‰**:

æ­£åˆ™è¡¨è¾¾å¼çš„è¯­æ³•ï¼š

$$E ::= \emptyset \mid \varepsilon \mid a \mid E + E \mid E \cdot E \mid E^*$$

å…¶ä¸­ $a \in \Sigma$ã€‚

#### 8.2.2. æ­£åˆ™è¡¨è¾¾å¼ä¸DFAç­‰ä»·æ€§

**å®šç† 8.2.1ï¼ˆæ­£åˆ™è¡¨è¾¾å¼ä¸DFAç­‰ä»·ï¼‰**:

è¯­è¨€ $L$ æ˜¯æ­£åˆ™çš„å½“ä¸”ä»…å½“å­˜åœ¨æ­£åˆ™è¡¨è¾¾å¼ $E$ ä½¿å¾— $L(E) = L$ã€‚

**è¯æ˜æ€è·¯**ï¼š

1. **æ­£åˆ™è¡¨è¾¾å¼åˆ°DFA**ï¼šé€šè¿‡Thompsonæ„é€ æ³•
2. **DFAåˆ°æ­£åˆ™è¡¨è¾¾å¼**ï¼šé€šè¿‡çŠ¶æ€æ¶ˆé™¤æ³•

### 8.3. å½¢å¼è¯­è¨€ç†è®º

#### 8.3.1. Chomskyå±‚æ¬¡

**Chomskyå±‚æ¬¡**ï¼š

1. **ç±»å‹0ï¼ˆé€’å½’å¯æšä¸¾è¯­è¨€ï¼‰**ï¼šå›¾çµæœº
2. **ç±»å‹1ï¼ˆä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€ï¼‰**ï¼šçº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœº
3. **ç±»å‹2ï¼ˆä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ï¼‰**ï¼šä¸‹æ¨è‡ªåŠ¨æœº
4. **ç±»å‹3ï¼ˆæ­£åˆ™è¯­è¨€ï¼‰**ï¼šæœ‰é™è‡ªåŠ¨æœº

#### 8.3.2. è¯­è¨€ç±»åŒ…å«å…³ç³»

$$\text{æ­£åˆ™è¯­è¨€} \subset \text{ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€} \subset \text{ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€} \subset \text{é€’å½’å¯æšä¸¾è¯­è¨€}$$

## è‡ªåŠ¨æœºå®ç°

### DFAå®ç°

```python
class DFA:
    def __init__(self, states, alphabet, transitions, start_state, accept_states):
        self.states = states
        self.alphabet = alphabet
        self.transitions = transitions
        self.current_state = start_state
        self.accept_states = accept_states

    def process(self, input_string):
        for symbol in input_string:
            if symbol not in self.alphabet:
                return False
            self.current_state = self.transitions[self.current_state][symbol]
        return self.current_state in self.accept_states
```

### å›¾çµæœºå®ç°

```python
class TuringMachine:
    def __init__(self, states, alphabet, transitions, start_state, accept_states):
        self.states = states
        self.alphabet = alphabet
        self.transitions = transitions
        self.current_state = start_state
        self.accept_states = accept_states
        self.tape = []
        self.head = 0

    def run(self, input_string):
        self.tape = list(input_string)
        self.head = 0

        while self.current_state not in self.accept_states:
            current_symbol = self.tape[self.head] if self.head < len(self.tape) else 'B'
            if (self.current_state, current_symbol) not in self.transitions:
                return False

            new_state, new_symbol, direction = self.transitions[(self.current_state, current_symbol)]
            self.tape[self.head] = new_symbol
            self.current_state = new_state

            if direction == 'R':
                self.head += 1
            elif direction == 'L':
                self.head -= 1

        return True
```

## é«˜çº§ä¸»é¢˜

### é‡å­è‡ªåŠ¨æœº

```text
é‡å­æœ‰é™è‡ªåŠ¨æœº (QFA)ï¼š
- çŠ¶æ€æ˜¯é‡å­å åŠ 
- è½¬ç§»æ˜¯é…‰å˜æ¢
- æµ‹é‡å†³å®šæ¥å—æˆ–æ‹’ç»
```

### æ¦‚ç‡è‡ªåŠ¨æœº

```text
æ¦‚ç‡æœ‰é™è‡ªåŠ¨æœº (PFA)ï¼š
- è½¬ç§»å…·æœ‰æ¦‚ç‡
- æ¥å—æ¦‚ç‡é˜ˆå€¼å†³å®šè¯­è¨€
```

### ç»†èƒè‡ªåŠ¨æœº

```text
ç»†èƒè‡ªåŠ¨æœºï¼š
- æ— é™ç½‘æ ¼
- å±€éƒ¨è§„åˆ™
- æ¶Œç°å¤æ‚æ€§
```

## 9. å½¢å¼åŒ–å®šä¹‰ä¸è¯æ˜

### 9.1. è‡ªåŠ¨æœºå½¢å¼åŒ–

**è‡ªåŠ¨æœºå½¢å¼åŒ–å®šä¹‰**ï¼š

è®¾è‡ªåŠ¨æœº $\mathcal{A} = (Q, \Sigma, \delta, q_0, F)$ï¼Œå…¶ä¸­ï¼š

- $Q$ï¼šçŠ¶æ€é›†åˆ
- $\Sigma$ï¼šè¾“å…¥å­—æ¯è¡¨
- $\delta$ï¼šè½¬ç§»å‡½æ•°
- $q_0$ï¼šåˆå§‹çŠ¶æ€
- $F$ï¼šæ¥å—çŠ¶æ€é›†åˆ

### 9.2. è¯­è¨€æ¥å—å½¢å¼åŒ–

**è¯­è¨€æ¥å—å½¢å¼åŒ–**ï¼š

$$L(\mathcal{A}) = \{w \in \Sigma^* \mid \delta^*(q_0, w) \in F\}$$

---

## 10. å¤šè¡¨å¾

è‡ªåŠ¨æœºç†è®ºåŸºç¡€æ”¯æŒå¤šç§è¡¨å¾æ–¹å¼ï¼ŒåŒ…æ‹¬ï¼š

- **ç¬¦å·è¡¨å¾**ï¼šçŠ¶æ€ã€è½¬ç§»ã€é…ç½®ç­‰
- **å›¾ç»“æ„**ï¼šçŠ¶æ€è½¬ç§»å›¾ã€è®¡ç®—æ ‘ç­‰
- **å‘é‡/å¼ é‡**ï¼šçŠ¶æ€å‘é‡ã€è½¬ç§»çŸ©é˜µç­‰
- **è‡ªç„¶è¯­è¨€**ï¼šå®šä¹‰ã€æ³¨é‡Šã€æè¿°
- **å›¾åƒ/å¯è§†åŒ–**ï¼šè‡ªåŠ¨æœºå›¾ã€è®¡ç®—å¯è§†åŒ–ç­‰

è¿™äº›è¡¨å¾å¯äº’æ˜ ï¼Œæå‡è‡ªåŠ¨æœºç†è®ºè¡¨è¾¾åŠ›ã€‚

---

## 11. æ€»ç»“ä¸å±•æœ›

### 11.1. æ€»ç»“

è‡ªåŠ¨æœºç†è®ºä¸ºè®¡ç®—æä¾›äº†å½¢å¼åŒ–åŸºç¡€ï¼Œä»ç®€å•çš„æœ‰é™è‡ªåŠ¨æœºåˆ°å¼ºå¤§çš„å›¾çµæœºï¼Œå½¢æˆäº†å®Œæ•´çš„è®¡ç®—èƒ½åŠ›å±‚æ¬¡ç»“æ„ï¼Œä¸ºè®¡ç®—æœºç§‘å­¦å’Œè½¯ä»¶å·¥ç¨‹æä¾›äº†é‡è¦çš„ç†è®ºåŸºç¡€ã€‚

**æ ¸å¿ƒè´¡çŒ®**ï¼š

1. **å½¢å¼åŒ–æ¨¡å‹**ï¼šDFAã€NFAã€PDAã€TMç­‰
2. **è¯­è¨€è¯†åˆ«**ï¼šæ­£åˆ™è¯­è¨€ã€ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ç­‰
3. **è®¡ç®—èƒ½åŠ›**ï¼šä¸åŒè‡ªåŠ¨æœºçš„è®¡ç®—èƒ½åŠ›
4. **å¤æ‚æ€§åˆ†æ**ï¼šæ—¶é—´å’Œç©ºé—´å¤æ‚æ€§

### 11.2. æœªæ¥å±•æœ›

1. **é‡å­è‡ªåŠ¨æœº**ï¼šé‡å­è®¡ç®—æ¨¡å‹
2. **æ¦‚ç‡è‡ªåŠ¨æœº**ï¼šéšæœºè®¡ç®—æ¨¡å‹
3. **ç»†èƒè‡ªåŠ¨æœº**ï¼šå¹¶è¡Œè®¡ç®—æ¨¡å‹
4. **ç”Ÿç‰©è®¡ç®—**ï¼šDNAè®¡ç®—ã€è†œè®¡ç®—

---

## 12. å‚è€ƒæ–‡çŒ®

1. Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). Introduction to Automata Theory, Languages, and Computation. Pearson.
2. Sipser, M. (2012). Introduction to the Theory of Computation. Cengage Learning.
3. Turing, A. M. (1936). On computable numbers, with an application to the Entscheidungsproblem. Proceedings of the London Mathematical Society.
4. Chomsky, N. (1956). Three models for the description of language. IRE Transactions on Information Theory.
5. Rabin, M. O., & Scott, D. (1959). Finite automata and their decision problems. IBM Journal of Research and Development.
6. Cook, S. A. (1971). The complexity of theorem-proving procedures. Proceedings of the third annual ACM symposium on Theory of computing.

---

[è¿”å›è‡ªåŠ¨æœºç†è®ºå¯¼èˆª](README.md)
