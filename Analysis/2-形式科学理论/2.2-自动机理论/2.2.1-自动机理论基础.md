# 2.2.1-自动机理论基础

## 概述

自动机理论是计算理论的核心分支，研究抽象计算模型的形式化定义、性质和计算能力。本模块介绍有限自动机、下推自动机、图灵机等基本概念。

## 有限自动机 (FA)

### 确定性有限自动机 (DFA)

```text
DFA = (Q, Σ, δ, q₀, F)
其中：
- Q: 状态集合
- Σ: 输入字母表
- δ: Q × Σ → Q (转移函数)
- q₀: 初始状态
- F: 接受状态集合
```

### 非确定性有限自动机 (NFA)

```text
NFA = (Q, Σ, δ, q₀, F)
其中：
- δ: Q × Σ → P(Q) (转移函数返回状态集合)
```

### DFA与NFA等价性

```text
定理：对于每个NFA，存在等价的DFA
证明：通过子集构造法
```

## 下推自动机 (PDA)

### PDA定义

```text
PDA = (Q, Σ, Γ, δ, q₀, Z₀, F)
其中：
- Q: 状态集合
- Σ: 输入字母表
- Γ: 栈字母表
- δ: Q × Σ × Γ → P(Q × Γ*) (转移函数)
- q₀: 初始状态
- Z₀: 初始栈符号
- F: 接受状态集合
```

### 上下文无关文法与PDA

```text
定理：语言L是上下文无关的当且仅当存在PDA接受L
```

## 图灵机 (TM)

### 基本图灵机

```text
TM = (Q, Σ, Γ, δ, q₀, B, F)
其中：
- Q: 状态集合
- Σ: 输入字母表
- Γ: 带字母表 (Σ ⊆ Γ)
- δ: Q × Γ → Q × Γ × {L, R} (转移函数)
- q₀: 初始状态
- B: 空白符号
- F: 接受状态集合
```

### 图灵机变体

1. **多带图灵机**: 多条带，等价于单带图灵机
2. **非确定性图灵机**: 转移函数返回状态集合
3. **通用图灵机**: 可以模拟其他图灵机

## 计算复杂性

### 时间复杂性

```text
对于图灵机M和输入w，时间复杂性T(n)是M在长度为n的输入上的最大步数
```

### 空间复杂性

```text
空间复杂性S(n)是M在长度为n的输入上使用的最大带格子数
```

### 复杂性类

- **P**: 多项式时间可解的问题
- **NP**: 非确定性多项式时间可验证的问题
- **PSPACE**: 多项式空间可解的问题
- **EXPTIME**: 指数时间可解的问题

## 可计算性理论

### 可判定性

```text
问题P是可判定的，如果存在图灵机M，对于所有输入：
- 如果输入∈P，M接受
- 如果输入∉P，M拒绝
```

### 停机问题

```text
停机问题：给定图灵机M和输入w，判断M在w上是否停机
定理：停机问题是不可判定的
```

### 递归可枚举性

```text
语言L是递归可枚举的，如果存在图灵机M：
- 如果w∈L，M接受w
- 如果w∉L，M可能拒绝或永不停机
```

## 自动机应用

### 编译器设计

```text
词法分析器：使用DFA识别词法单元
语法分析器：使用PDA进行语法分析
```

### 正则表达式

```text
正则表达式与DFA等价
正则语言：被DFA接受的语言
```

### 形式语言理论

```text
Chomsky层次：
- 类型0：递归可枚举语言 (图灵机)
- 类型1：上下文相关语言
- 类型2：上下文无关语言 (PDA)
- 类型3：正则语言 (DFA)
```

## 自动机实现

### DFA实现

```python
class DFA:
    def __init__(self, states, alphabet, transitions, start_state, accept_states):
        self.states = states
        self.alphabet = alphabet
        self.transitions = transitions
        self.current_state = start_state
        self.accept_states = accept_states
    
    def process(self, input_string):
        for symbol in input_string:
            if symbol not in self.alphabet:
                return False
            self.current_state = self.transitions[self.current_state][symbol]
        return self.current_state in self.accept_states
```

### 图灵机实现

```python
class TuringMachine:
    def __init__(self, states, alphabet, transitions, start_state, accept_states):
        self.states = states
        self.alphabet = alphabet
        self.transitions = transitions
        self.current_state = start_state
        self.accept_states = accept_states
        self.tape = []
        self.head = 0
    
    def run(self, input_string):
        self.tape = list(input_string)
        self.head = 0
        
        while self.current_state not in self.accept_states:
            current_symbol = self.tape[self.head] if self.head < len(self.tape) else 'B'
            if (self.current_state, current_symbol) not in self.transitions:
                return False
            
            new_state, new_symbol, direction = self.transitions[(self.current_state, current_symbol)]
            self.tape[self.head] = new_symbol
            self.current_state = new_state
            
            if direction == 'R':
                self.head += 1
            elif direction == 'L':
                self.head -= 1
        
        return True
```

## 高级主题

### 量子自动机

```text
量子有限自动机 (QFA)：
- 状态是量子叠加
- 转移是酉变换
- 测量决定接受或拒绝
```

### 概率自动机

```text
概率有限自动机 (PFA)：
- 转移具有概率
- 接受概率阈值决定语言
```

### 细胞自动机

```text
细胞自动机：
- 无限网格
- 局部规则
- 涌现复杂性
```

## 总结

自动机理论为计算提供了形式化基础，从简单的有限自动机到强大的图灵机，形成了完整的计算能力层次结构，为计算机科学和软件工程提供了重要的理论基础。

---

**相关链接：**

- [8.2-自动机理论深化](../8-形式理论深化/8.2-自动机理论深化/README.md)
- [2.3-Petri网理论](2.3-Petri网理论/2.3.1-Petri网理论基础.md)
