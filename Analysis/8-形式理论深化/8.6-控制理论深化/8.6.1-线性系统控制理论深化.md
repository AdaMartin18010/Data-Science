# 8.6.1 çº¿æ€§ç³»ç»Ÿæ§åˆ¶ç†è®ºæ·±åŒ–

## ğŸ“‘ ç›®å½•

- [8.6.1 çº¿æ€§ç³»ç»Ÿæ§åˆ¶ç†è®ºæ·±åŒ–](#861-çº¿æ€§ç³»ç»Ÿæ§åˆ¶ç†è®ºæ·±åŒ–)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. çº¿æ€§ç³»ç»ŸåŸºç¡€](#1-çº¿æ€§ç³»ç»ŸåŸºç¡€)
    - [1.1. çº¿æ€§ç³»ç»Ÿå®šä¹‰](#11-çº¿æ€§ç³»ç»Ÿå®šä¹‰)
  - [2. ç³»ç»Ÿç‰¹æ€§åˆ†æ](#2-ç³»ç»Ÿç‰¹æ€§åˆ†æ)
  - [3. çŠ¶æ€ç©ºé—´æ¨¡å‹](#3-çŠ¶æ€ç©ºé—´æ¨¡å‹)
    - [3.1. çŠ¶æ€ç©ºé—´è¡¨ç¤º](#31-çŠ¶æ€ç©ºé—´è¡¨ç¤º)
  - [4. ç³»ç»Ÿåˆ†è§£](#4-ç³»ç»Ÿåˆ†è§£)
  - [5. æ§åˆ¶å™¨è®¾è®¡](#5-æ§åˆ¶å™¨è®¾è®¡)
    - [5.1. çŠ¶æ€åé¦ˆæ§åˆ¶](#51-çŠ¶æ€åé¦ˆæ§åˆ¶)
  - [6. è§‚æµ‹å™¨è®¾è®¡](#6-è§‚æµ‹å™¨è®¾è®¡)
  - [7. ç¨³å®šæ€§åˆ†æ](#7-ç¨³å®šæ€§åˆ†æ)
    - [7.1. Lyapunovç¨³å®šæ€§](#71-lyapunovç¨³å®šæ€§)
  - [8. é¢‘åŸŸç¨³å®šæ€§](#8-é¢‘åŸŸç¨³å®šæ€§)
  - [9. åº”ç”¨æ¡ˆä¾‹](#9-åº”ç”¨æ¡ˆä¾‹)
    - [9.1. å€’ç«‹æ‘†æ§åˆ¶](#91-å€’ç«‹æ‘†æ§åˆ¶)
  - [10. ç›´æµç”µæœºæ§åˆ¶](#10-ç›´æµç”µæœºæ§åˆ¶)
  - [11. å·¥å…·å®ç°](#11-å·¥å…·å®ç°)
    - [11.1. Pythonæ§åˆ¶ç†è®ºå·¥å…·](#111-pythonæ§åˆ¶ç†è®ºå·¥å…·)
  - [12. JavaScriptæ§åˆ¶ç†è®ºå®ç°](#12-javascriptæ§åˆ¶ç†è®ºå®ç°)
  - [13. å­¦ä¹ è·¯å¾„](#13-å­¦ä¹ è·¯å¾„)
    - [13.1. åŸºç¡€å­¦ä¹ ](#131-åŸºç¡€å­¦ä¹ )
    - [13.2. è¿›é˜¶å­¦ä¹ ](#132-è¿›é˜¶å­¦ä¹ )
    - [13.3. åº”ç”¨å®è·µ](#133-åº”ç”¨å®è·µ)
  - [14. æ€»ç»“](#14-æ€»ç»“)

---


## 1. çº¿æ€§ç³»ç»ŸåŸºç¡€

### 1.1. çº¿æ€§ç³»ç»Ÿå®šä¹‰

çº¿æ€§ç³»ç»Ÿæ˜¯æ»¡è¶³å åŠ åŸç†çš„åŠ¨æ€ç³»ç»Ÿï¼Œå…¶è¾“å‡ºä¸è¾“å…¥ä¹‹é—´æ»¡è¶³çº¿æ€§å…³ç³»ã€‚

```python
import numpy as np
from scipy import linalg
import matplotlib.pyplot as plt

class LinearSystem:
    def __init__(self, A, B, C, D=None):
        """
        çº¿æ€§ç³»ç»ŸçŠ¶æ€ç©ºé—´æ¨¡å‹
        dx/dt = Ax + Bu
        y = Cx + Du
        """
        self.A = np.array(A)  # çŠ¶æ€çŸ©é˜µ
        self.B = np.array(B)  # è¾“å…¥çŸ©é˜µ
        self.C = np.array(C)  # è¾“å‡ºçŸ©é˜µ
        self.D = np.array(D) if D is not None else np.zeros((self.C.shape[0], self.B.shape[1]))

        self.n = self.A.shape[0]  # çŠ¶æ€ç»´åº¦
        self.m = self.B.shape[1]  # è¾“å…¥ç»´åº¦
        self.p = self.C.shape[0]  # è¾“å‡ºç»´åº¦

    def simulate(self, x0, u, t):
        """æ¨¡æ‹Ÿç³»ç»Ÿå“åº”"""
        dt = t[1] - t[0]
        x = np.zeros((len(t), self.n))
        y = np.zeros((len(t), self.p))

        x[0] = x0

        for i in range(1, len(t)):
# æ¬§æ‹‰æ³•ç§¯åˆ†
            dx = self.A @ x[i-1] + self.B @ u[i-1]
            x[i] = x[i-1] + dt * dx
            y[i] = self.C @ x[i] + self.D @ u[i]

        return x, y

    def transfer_function(self, s):
        """è®¡ç®—ä¼ é€’å‡½æ•°"""
# G(s) = C(sI - A)^(-1)B + D
        sI_minus_A = s * np.eye(self.n) - self.A
        return self.C @ np.linalg.inv(sI_minus_A) @ self.B + self.D

    def eigenvalues(self):
        """è®¡ç®—ç‰¹å¾å€¼"""
        return np.linalg.eigvals(self.A)

    def controllability_matrix(self):
        """è®¡ç®—å¯æ§æ€§çŸ©é˜µ"""
        C = self.B
        for i in range(1, self.n):
            C = np.hstack([C, self.A**i @ self.B])
        return C

    def observability_matrix(self):
        """è®¡ç®—å¯è§‚æ€§çŸ©é˜µ"""
        O = self.C
        for i in range(1, self.n):
            O = np.vstack([O, self.C @ self.A**i])
        return O

    def is_controllable(self):
        """æ£€æŸ¥å¯æ§æ€§"""
        C = self.controllability_matrix()
        return np.linalg.matrix_rank(C) == self.n

    def is_observable(self):
        """æ£€æŸ¥å¯è§‚æ€§"""
        O = self.observability_matrix()
        return np.linalg.matrix_rank(O) == self.n
```

## 2. ç³»ç»Ÿç‰¹æ€§åˆ†æ

```python
class SystemAnalysis:
    def __init__(self, system):
        self.system = system

    def stability_analysis(self):
        """ç¨³å®šæ€§åˆ†æ"""
        eigenvalues = self.system.eigenvalues()
        real_parts = np.real(eigenvalues)

# æ¸è¿‘ç¨³å®šæ€§
        asymptotically_stable = np.all(real_parts < 0)

# ä¸´ç•Œç¨³å®šæ€§
        marginally_stable = np.all(real_parts <= 0) and np.any(real_parts == 0)

# ä¸ç¨³å®š
        unstable = np.any(real_parts > 0)

        return {
            'eigenvalues': eigenvalues,
            'asymptotically_stable': asymptotically_stable,
            'marginally_stable': marginally_stable,
            'unstable': unstable
        }

    def controllability_analysis(self):
        """å¯æ§æ€§åˆ†æ"""
        controllable = self.system.is_controllable()
        controllability_matrix = self.system.controllability_matrix()
        controllability_rank = np.linalg.matrix_rank(controllability_matrix)

        return {
            'controllable': controllable,
            'controllability_rank': controllability_rank,
            'controllability_matrix': controllability_matrix
        }

    def observability_analysis(self):
        """å¯è§‚æ€§åˆ†æ"""
        observable = self.system.is_observable()
        observability_matrix = self.system.observability_matrix()
        observability_rank = np.linalg.matrix_rank(observability_matrix)

        return {
            'observable': observable,
            'observability_rank': observability_rank,
            'observability_matrix': observability_matrix
        }

    def step_response(self, t_final=10, dt=0.01):
        """é˜¶è·ƒå“åº”"""
        t = np.arange(0, t_final, dt)
        u = np.ones((len(t), self.system.m))
        x0 = np.zeros(self.system.n)

        x, y = self.system.simulate(x0, u, t)

        return t, y

    def impulse_response(self, t_final=10, dt=0.01):
        """è„‰å†²å“åº”"""
        t = np.arange(0, t_final, dt)
        u = np.zeros((len(t), self.system.m))
        u[0] = 1/dt  # å•ä½è„‰å†²
        x0 = np.zeros(self.system.n)

        x, y = self.system.simulate(x0, u, t)

        return t, y
```

## 3. çŠ¶æ€ç©ºé—´æ¨¡å‹

### 3.1. çŠ¶æ€ç©ºé—´è¡¨ç¤º

```python
class StateSpaceModel:
    def __init__(self, A, B, C, D=None):
        self.system = LinearSystem(A, B, C, D)

    def continuous_to_discrete(self, dt):
        """è¿ç»­æ—¶é—´åˆ°ç¦»æ•£æ—¶é—´è½¬æ¢"""
        A_d = linalg.expm(self.system.A * dt)
        B_d = np.linalg.inv(self.system.A) @ (A_d - np.eye(self.system.n)) @ self.system.B
        C_d = self.system.C
        D_d = self.system.D

        return StateSpaceModel(A_d, B_d, C_d, D_d)

    def canonical_forms(self):
        """è®¡ç®—æ ‡å‡†å‹"""
# å¯æ§æ ‡å‡†å‹
        controllable_form = self.controllable_canonical_form()

# å¯è§‚æ ‡å‡†å‹
        observable_form = self.observable_canonical_form()

# å¯¹è§’æ ‡å‡†å‹
        diagonal_form = self.diagonal_canonical_form()

        return {
            'controllable': controllable_form,
            'observable': observable_form,
            'diagonal': diagonal_form
        }

    def controllable_canonical_form(self):
        """å¯æ§æ ‡å‡†å‹"""
        if not self.system.is_controllable():
            raise ValueError("System is not controllable")

# è®¡ç®—ç‰¹å¾å¤šé¡¹å¼
        char_poly = np.poly(self.system.A)

# æ„å»ºå¯æ§æ ‡å‡†å‹çŸ©é˜µ
        A_c = np.zeros((self.system.n, self.system.n))
        A_c[:-1, 1:] = np.eye(self.system.n - 1)
        A_c[-1, :] = -char_poly[1:]

        B_c = np.zeros((self.system.n, 1))
        B_c[-1] = 1

# è®¡ç®—å˜æ¢çŸ©é˜µ
        C_orig = self.system.controllability_matrix()
        C_c = np.zeros((self.system.n, self.system.n))
        C_c[:-1, 1:] = np.eye(self.system.n - 1)
        C_c[-1, :] = char_poly[1:]

        T = C_orig @ np.linalg.inv(C_c)

        C_c = self.system.C @ T
        D_c = self.system.D

        return StateSpaceModel(A_c, B_c, C_c, D_c)

    def diagonal_canonical_form(self):
        """å¯¹è§’æ ‡å‡†å‹"""
        eigenvalues, eigenvectors = np.linalg.eig(self.system.A)

        A_d = np.diag(eigenvalues)
        T = eigenvectors
        B_d = np.linalg.inv(T) @ self.system.B
        C_d = self.system.C @ T
        D_d = self.system.D

        return StateSpaceModel(A_d, B_d, C_d, D_d)
```

## 4. ç³»ç»Ÿåˆ†è§£

```python
class SystemDecomposition:
    def __init__(self, system):
        self.system = system

    def kalman_decomposition(self):
        """Kalmanåˆ†è§£"""
# è®¡ç®—å¯æ§å’Œå¯è§‚å­ç©ºé—´
        controllable = self.system.is_controllable()
        observable = self.system.is_observable()

        if controllable and observable:
# ç³»ç»Ÿå®Œå…¨å¯æ§å¯è§‚
            return {
                'type': 'minimal',
                'system': self.system
            }
        else:
# éœ€è¦åˆ†è§£
            return self.perform_kalman_decomposition()

    def perform_kalman_decomposition(self):
        """æ‰§è¡ŒKalmanåˆ†è§£"""
# è®¡ç®—å¯æ§æ€§çŸ©é˜µçš„æ ¸ç©ºé—´
        C = self.system.controllability_matrix()
        kernel_C = self.null_space(C.T)

# è®¡ç®—å¯è§‚æ€§çŸ©é˜µçš„æ ¸ç©ºé—´
        O = self.system.observability_matrix()
        kernel_O = self.null_space(O)

# æ„å»ºå˜æ¢çŸ©é˜µ
        T = self.construct_transformation_matrix(kernel_C, kernel_O)

# åº”ç”¨å˜æ¢
        A_tilde = np.linalg.inv(T) @ self.system.A @ T
        B_tilde = np.linalg.inv(T) @ self.system.B
        C_tilde = self.system.C @ T

        return {
            'type': 'decomposed',
            'transformation_matrix': T,
            'A_tilde': A_tilde,
            'B_tilde': B_tilde,
            'C_tilde': C_tilde
        }

    def null_space(self, A):
        """è®¡ç®—çŸ©é˜µçš„æ ¸ç©ºé—´"""
        U, S, Vt = np.linalg.svd(A)
        rank = np.sum(S > 1e-10)
        return Vt[rank:].T

    def construct_transformation_matrix(self, kernel_C, kernel_O):
        """æ„å»ºå˜æ¢çŸ©é˜µ"""
# æ ¹æ®Kalbreneråˆ†è§£ç®—æ³•æ„å»ºå˜æ¢çŸ©é˜µ
        n = self.system.n

# è®¡ç®—å¯æ§å­ç©ºé—´å’Œä¸å¯æ§å­ç©ºé—´
        controllable_space = self.system.controllable_subspace()
        uncontrollable_space = self.null_space(controllable_space.T)

# è®¡ç®—å¯è§‚å­ç©ºé—´å’Œä¸å¯è§‚å­ç©ºé—´
        observable_space = self.system.observable_subspace()
        unobservable_space = self.null_space(observable_space.T)

# æ„å»ºå˜æ¢çŸ©é˜µ
        T = np.zeros((n, n))

# ç¬¬ä¸€å—ï¼šå¯æ§ä¸”å¯è§‚
        controllable_observable = controllable_space @ observable_space.T
        if controllable_observable.shape[1] > 0:
            T[:, :controllable_observable.shape[1]] = controllable_observable

# ç¬¬äºŒå—ï¼šå¯æ§ä½†ä¸å¯è§‚
        controllable_unobservable = controllable_space @ unobservable_space.T
        if controllable_unobservable.shape[1] > 0:
            start_col = controllable_observable.shape[1]
            end_col = start_col + controllable_unobservable.shape[1]
            T[:, start_col:end_col] = controllable_unobservable

# ç¬¬ä¸‰å—ï¼šä¸å¯æ§ä½†å¯è§‚
        uncontrollable_observable = uncontrollable_space @ observable_space.T
        if uncontrollable_observable.shape[1] > 0:
            start_col = controllable_observable.shape[1] + controllable_unobservable.shape[1]
            end_col = start_col + uncontrollable_observable.shape[1]
            T[:, start_col:end_col] = uncontrollable_observable

# ç¬¬å››å—ï¼šä¸å¯æ§ä¸”ä¸å¯è§‚
        uncontrollable_unobservable = uncontrollable_space @ unobservable_space.T
        if uncontrollable_unobservable.shape[1] > 0:
            start_col = (controllable_observable.shape[1] +
                        controllable_unobservable.shape[1] +
                        uncontrollable_observable.shape[1])
            end_col = start_col + uncontrollable_unobservable.shape[1]
            T[:, start_col:end_col] = uncontrollable_unobservable

# ç¡®ä¿Tæ˜¯å¯é€†çš„
        if np.linalg.det(T) == 0:
# å¦‚æœTä¸å¯é€†ï¼Œä½¿ç”¨QRåˆ†è§£
            Q, R = np.linalg.qr(T)
            T = Q

        return T
```

## 5. æ§åˆ¶å™¨è®¾è®¡

### 5.1. çŠ¶æ€åé¦ˆæ§åˆ¶

```python
class StateFeedbackController:
    def __init__(self, system):
        self.system = system

    def pole_placement(self, desired_poles):
        """æç‚¹é…ç½®"""
        if not self.system.is_controllable():
            raise ValueError("System is not controllable")

# ä½¿ç”¨Ackermannå…¬å¼
        char_poly_desired = np.poly(desired_poles)
        char_poly_actual = np.poly(self.system.A)

# è®¡ç®—åé¦ˆå¢ç›Š
        K = self.ackermann_formula(char_poly_desired, char_poly_actual)

        return K

    def ackermann_formula(self, char_poly_desired, char_poly_actual):
        """Ackermannå…¬å¼"""
        n = self.system.n

# è®¡ç®—å¯æ§æ€§çŸ©é˜µ
        C = self.system.controllability_matrix()

# è®¡ç®—æœŸæœ›ç‰¹å¾å¤šé¡¹å¼çš„ç³»æ•°
        alpha_desired = char_poly_desired[1:]  # å»æ‰æœ€é«˜æ¬¡é¡¹ç³»æ•°
        alpha_actual = char_poly_actual[1:]

# è®¡ç®—åé¦ˆå¢ç›Š
        K = np.zeros((1, n))
        K[0, -1] = 1
        K = K @ np.linalg.inv(C)

# è®¡ç®—ç‰¹å¾å¤šé¡¹å¼å·®å€¼
        delta_alpha = alpha_desired - alpha_actual

# åº”ç”¨Ackermannå…¬å¼
        phi_A = np.zeros((n, n))
        for i, alpha in enumerate(delta_alpha):
            phi_A += alpha * self.system.A**i

        K = K @ phi_A

        return K

    def lqr_design(self, Q, R):
        """LQRè®¾è®¡"""
# æ±‚è§£ä»£æ•°Riccatiæ–¹ç¨‹
        P = self.solve_algebraic_riccati_equation(Q, R)

# è®¡ç®—æœ€ä¼˜åé¦ˆå¢ç›Š
        K = np.linalg.inv(R) @ self.system.B.T @ P

        return K

    def solve_algebraic_riccati_equation(self, Q, R):
        """æ±‚è§£ä»£æ•°Riccatiæ–¹ç¨‹"""
# ä½¿ç”¨scipyçš„æ±‚è§£å™¨
        from scipy.linalg import solve_continuous_are

        P = solve_continuous_are(self.system.A, self.system.B, Q, R)
        return P

    def closed_loop_system(self, K):
        """é—­ç¯ç³»ç»Ÿ"""
        A_cl = self.system.A - self.system.B @ K
        B_cl = self.system.B
        C_cl = self.system.C
        D_cl = self.system.D

        return LinearSystem(A_cl, B_cl, C_cl, D_cl)
```

## 6. è§‚æµ‹å™¨è®¾è®¡

```python
class ObserverDesign:
    def __init__(self, system):
        self.system = system

    def luenberger_observer(self, desired_poles):
        """Luenbergerè§‚æµ‹å™¨è®¾è®¡"""
        if not self.system.is_observable():
            raise ValueError("System is not observable")

# è®¾è®¡è§‚æµ‹å™¨å¢ç›Š
        L = self.pole_placement_for_observer(desired_poles)

        return L

    def pole_placement_for_observer(self, desired_poles):
        """è§‚æµ‹å™¨æç‚¹é…ç½®"""
# å¯¹å¶ç³»ç»Ÿæ–¹æ³•
        A_dual = self.system.A.T
        B_dual = self.system.C.T
        C_dual = self.system.B.T

# è®¾è®¡å¯¹å¶ç³»ç»Ÿçš„çŠ¶æ€åé¦ˆ
        dual_controller = StateFeedbackController(LinearSystem(A_dual, B_dual, C_dual))
        K_dual = dual_controller.pole_placement(desired_poles)

# è§‚æµ‹å™¨å¢ç›Šæ˜¯å¯¹å¶ç³»ç»Ÿåé¦ˆå¢ç›Šçš„è½¬ç½®
        L = K_dual.T

        return L

    def kalman_filter(self, Q, R):
        """å¡å°”æ›¼æ»¤æ³¢å™¨è®¾è®¡"""
# è¿ç»­æ—¶é—´å¡å°”æ›¼æ»¤æ³¢å™¨
        P = self.solve_continuous_riccati_equation(Q, R)

# è®¡ç®—å¡å°”æ›¼å¢ç›Š
        L = P @ self.system.C.T @ np.linalg.inv(R)

        return L

    def solve_continuous_riccati_equation(self, Q, R):
        """æ±‚è§£è¿ç»­æ—¶é—´Riccatiæ–¹ç¨‹"""
        from scipy.linalg import solve_continuous_are

        P = solve_continuous_are(self.system.A.T, self.system.C.T, Q, R)
        return P

    def observer_system(self, L):
        """è§‚æµ‹å™¨ç³»ç»Ÿ"""
        A_obs = self.system.A - L @ self.system.C
        B_obs = np.hstack([self.system.B, L])
        C_obs = np.eye(self.system.n)
        D_obs = np.zeros((self.system.n, self.system.m + self.system.p))

        return LinearSystem(A_obs, B_obs, C_obs, D_obs)
```

## 7. ç¨³å®šæ€§åˆ†æ

### 7.1. Lyapunovç¨³å®šæ€§

```python
class LyapunovStability:
    def __init__(self, system):
        self.system = system

    def lyapunov_stability_test(self, P):
        """Lyapunovç¨³å®šæ€§æµ‹è¯•"""
# æ£€æŸ¥Pæ˜¯å¦æ­£å®š
        if not self.is_positive_definite(P):
            return False, "P is not positive definite"

# è®¡ç®—A^T P + P A
        ATP_plus_PA = self.system.A.T @ P + P @ self.system.A

# æ£€æŸ¥æ˜¯å¦è´Ÿå®š
        if not self.is_negative_definite(ATP_plus_PA):
            return False, "ATP + PA is not negative definite"

        return True, "System is asymptotically stable"

    def is_positive_definite(self, A):
        """æ£€æŸ¥çŸ©é˜µæ˜¯å¦æ­£å®š"""
        try:
            np.linalg.cholesky(A)
            return True
        except np.linalg.LinAlgError:
            return False

    def is_negative_definite(self, A):
        """æ£€æŸ¥çŸ©é˜µæ˜¯å¦è´Ÿå®š"""
        return self.is_positive_definite(-A)

    def find_lyapunov_function(self):
        """å¯»æ‰¾Lyapunovå‡½æ•°"""
# æ±‚è§£Lyapunovæ–¹ç¨‹
        Q = np.eye(self.system.n)
        P = self.solve_lyapunov_equation(Q)

        return P

    def solve_lyapunov_equation(self, Q):
        """æ±‚è§£Lyapunovæ–¹ç¨‹"""
        from scipy.linalg import solve_continuous_lyapunov

        P = solve_continuous_lyapunov(self.system.A, -Q)
        return P

    def robust_stability_analysis(self, uncertainty_bounds):
        """é²æ£’ç¨³å®šæ€§åˆ†æ"""
# è¿™é‡Œå¯ä»¥å®ç°æ›´å¤æ‚çš„é²æ£’ç¨³å®šæ€§åˆ†æ
# ä¾‹å¦‚ï¼šå‚æ•°ä¸ç¡®å®šæ€§ã€æœªå»ºæ¨¡åŠ¨æ€ç­‰
        pass
```

## 8. é¢‘åŸŸç¨³å®šæ€§

```python
class FrequencyDomainStability:
    def __init__(self, system):
        self.system = system

    def nyquist_stability_criterion(self, frequencies):
        """Nyquistç¨³å®šæ€§åˆ¤æ®"""
# è®¡ç®—å¼€ç¯ä¼ é€’å‡½æ•°
        G_ol = self.open_loop_transfer_function(frequencies)

# è®¡ç®—Nyquistå›¾
        nyquist_plot = self.compute_nyquist_plot(G_ol)

# åº”ç”¨Nyquiståˆ¤æ®
        stability_result = self.apply_nyquist_criterion(nyquist_plot)

        return stability_result

    def open_loop_transfer_function(self, frequencies):
        """è®¡ç®—å¼€ç¯ä¼ é€’å‡½æ•°"""
        G_ol = []
        for s in 1j * frequencies:
            G = self.system.transfer_function(s)
            G_ol.append(G)

        return np.array(G_ol)

    def compute_nyquist_plot(self, G_ol):
        """è®¡ç®—Nyquistå›¾"""
        real_part = np.real(G_ol)
        imag_part = np.imag(G_ol)

        return real_part, imag_part

    def apply_nyquist_criterion(self, nyquist_plot):
        """åº”ç”¨Nyquiståˆ¤æ®"""
        real_part, imag_part = nyquist_plot

# è®¡ç®—åŒ…å›´(-1,0)ç‚¹çš„æ¬¡æ•°
        encirclements = self.count_encirclements(real_part, imag_part)

# æ ¹æ®å¼€ç¯ç³»ç»Ÿçš„ä¸ç¨³å®šæç‚¹æ•°å’ŒåŒ…å›´æ¬¡æ•°åˆ¤æ–­ç¨³å®šæ€§
# è¿™é‡Œéœ€è¦æ ¹æ®å…·ä½“çš„ç³»ç»Ÿç‰¹æ€§å®ç°
        return {
            'encirclements': encirclements,
            'stable': encirclements == 0  # ç®€åŒ–åˆ¤æ–­
        }

    def count_encirclements(self, real_part, imag_part):
        """è®¡ç®—åŒ…å›´æ¬¡æ•°"""
# ä½¿ç”¨Nyquiståˆ¤æ®è®¡ç®—åŒ…å›´æ¬¡æ•°
# è®¡ç®—åŒ…å›´åŸç‚¹çš„æ¬¡æ•°

# æ„å»ºå¤æ•°è·¯å¾„
        path = np.array(real_part) + 1j * np.array(imag_part)

# è®¡ç®—è§’åº¦å˜åŒ–
        angles = np.angle(path)
        angle_changes = np.diff(angles)

# å¤„ç†è§’åº¦è·³è·ƒï¼ˆä»-Ï€åˆ°Ï€æˆ–ä»Ï€åˆ°-Ï€ï¼‰
        for i in range(len(angle_changes)):
            if angle_changes[i] > np.pi:
                angle_changes[i] -= 2 * np.pi
            elif angle_changes[i] < -np.pi:
                angle_changes[i] += 2 * np.pi

# è®¡ç®—æ€»è§’åº¦å˜åŒ–
        total_angle_change = np.sum(angle_changes)

# åŒ…å›´æ¬¡æ•° = æ€»è§’åº¦å˜åŒ– / (2Ï€)
        encirclements = total_angle_change / (2 * np.pi)

        return int(round(encirclements))
```

## 9. åº”ç”¨æ¡ˆä¾‹

### 9.1. å€’ç«‹æ‘†æ§åˆ¶

```python
class InvertedPendulum:
    def __init__(self, M=0.5, m=0.2, b=0.1, I=0.006, g=9.8, l=0.3):
        """
        å€’ç«‹æ‘†ç³»ç»Ÿå‚æ•°
        M: å°è½¦è´¨é‡
        m: æ‘†æ†è´¨é‡
        b: æ‘©æ“¦ç³»æ•°
        I: è½¬åŠ¨æƒ¯é‡
        g: é‡åŠ›åŠ é€Ÿåº¦
        l: æ‘†æ†é•¿åº¦
        """
        self.M = M
        self.m = m
        self.b = b
        self.I = I
        self.g = g
        self.l = l

# æ„å»ºçŠ¶æ€ç©ºé—´æ¨¡å‹
        self.system = self.build_state_space_model()

    def build_state_space_model(self):
        """æ„å»ºçŠ¶æ€ç©ºé—´æ¨¡å‹"""
# çŠ¶æ€å˜é‡: [x, x_dot, theta, theta_dot]
# x: å°è½¦ä½ç½®, theta: æ‘†æ†è§’åº¦

        p = self.I * (self.M + self.m) + self.M * self.m * self.l**2

        A = np.array([
            [0, 1, 0, 0],
            [0, -(self.I + self.m * self.l**2) * self.b / p, self.m**2 * self.g * self.l**2 / p, 0],
            [0, 0, 0, 1],
            [0, -self.m * self.l * self.b / p, self.m * self.g * self.l * (self.M + self.m) / p, 0]
        ])

        B = np.array([
            [0],
            [(self.I + self.m * self.l**2) / p],
            [0],
            [self.m * self.l / p]
        ])

        C = np.array([
            [1, 0, 0, 0],
            [0, 0, 1, 0]
        ])

        D = np.zeros((2, 1))

        return LinearSystem(A, B, C, D)

    def design_controller(self):
        """è®¾è®¡æ§åˆ¶å™¨"""
# æœŸæœ›æç‚¹
        desired_poles = [-2, -2.1, -2.2, -2.3]

# çŠ¶æ€åé¦ˆæ§åˆ¶å™¨
        controller = StateFeedbackController(self.system)
        K = controller.pole_placement(desired_poles)

        return K

    def design_observer(self):
        """è®¾è®¡è§‚æµ‹å™¨"""
# è§‚æµ‹å™¨æç‚¹ï¼ˆæ¯”æ§åˆ¶å™¨æç‚¹å¿«3å€ï¼‰
        observer_poles = [-6, -6.3, -6.6, -6.9]

# Luenbergerè§‚æµ‹å™¨
        observer_designer = ObserverDesign(self.system)
        L = observer_designer.luenberger_observer(observer_poles)

        return L

    def simulate_controlled_system(self, x0, t_final=10):
        """æ¨¡æ‹Ÿå—æ§ç³»ç»Ÿ"""
# è®¾è®¡æ§åˆ¶å™¨å’Œè§‚æµ‹å™¨
        K = self.design_controller()
        L = self.design_observer()

# æ„å»ºè§‚æµ‹å™¨
        observer = observer_designer.observer_system(L)

# æ¨¡æ‹Ÿç³»ç»Ÿ
        dt = 0.01
        t = np.arange(0, t_final, dt)

        x = np.zeros((len(t), 4))
        x_hat = np.zeros((len(t), 4))
        u = np.zeros((len(t), 1))

        x[0] = x0
        x_hat[0] = x0  # å‡è®¾åˆå§‹çŠ¶æ€å·²çŸ¥

        for i in range(1, len(t)):
# æ§åˆ¶è¾“å…¥
            u[i-1] = -K @ x_hat[i-1]

# ç³»ç»Ÿå“åº”
            dx = self.system.A @ x[i-1] + self.system.B @ u[i-1]
            x[i] = x[i-1] + dt * dx

# è§‚æµ‹å™¨æ›´æ–°
            y = self.system.C @ x[i-1]
            dx_hat = observer.A @ x_hat[i-1] + observer.B @ np.vstack([u[i-1], y])
            x_hat[i] = x_hat[i-1] + dt * dx_hat.flatten()

        return t, x, x_hat, u
```

## 10. ç›´æµç”µæœºæ§åˆ¶

```python
class DCMotor:
    def __init__(self, R=1, L=0.5, J=0.01, b=0.1, Kt=0.01, Ke=0.01):
        """
        ç›´æµç”µæœºå‚æ•°
        R: ç”µé˜»
        L: ç”µæ„Ÿ
        J: è½¬åŠ¨æƒ¯é‡
        b: æ‘©æ“¦ç³»æ•°
        Kt: è½¬çŸ©å¸¸æ•°
        Ke: åç”µåŠ¨åŠ¿å¸¸æ•°
        """
        self.R = R
        self.L = L
        self.J = J
        self.b = b
        self.Kt = Kt
        self.Ke = Ke

# æ„å»ºçŠ¶æ€ç©ºé—´æ¨¡å‹
        self.system = self.build_state_space_model()

    def build_state_space_model(self):
        """æ„å»ºçŠ¶æ€ç©ºé—´æ¨¡å‹"""
# çŠ¶æ€å˜é‡: [i, omega]
# i: ç”µæµ, omega: è§’é€Ÿåº¦

        A = np.array([
            [-self.R/self.L, -self.Ke/self.L],
            [self.Kt/self.J, -self.b/self.J]
        ])

        B = np.array([
            [1/self.L],
            [0]
        ])

        C = np.array([
            [1, 0],
            [0, 1]
        ])

        D = np.zeros((2, 1))

        return LinearSystem(A, B, C, D)

    def design_pid_controller(self, Kp, Ki, Kd):
        """è®¾è®¡PIDæ§åˆ¶å™¨"""
# ä½¿ç”¨Ziegler-Nicholsæ–¹æ³•æˆ–å…¶ä»–è°ƒå‚æ–¹æ³•
# è¿™é‡Œå®ç°ä¸€ä¸ªåŸºäºç³»ç»Ÿç‰¹æ€§çš„PIDè®¾è®¡

# è·å–ç³»ç»Ÿç‰¹æ€§
        poles = np.linalg.eigvals(self.system.A)
        natural_frequency = np.max(np.abs(poles))
        damping_ratio = -np.real(poles[0]) / np.abs(poles[0])

# åŸºäºç³»ç»Ÿç‰¹æ€§è°ƒæ•´PIDå‚æ•°
        if natural_frequency > 10:
# é«˜é¢‘ç³»ç»Ÿï¼Œéœ€è¦æ›´ä¿å®ˆçš„å‚æ•°
            Kp_adjusted = Kp * 0.5
            Ki_adjusted = Ki * 0.3
            Kd_adjusted = Kd * 0.7
        elif damping_ratio < 0.5:
# ä½é˜»å°¼ç³»ç»Ÿï¼Œéœ€è¦æ›´å¼ºçš„é˜»å°¼
            Kp_adjusted = Kp * 0.8
            Ki_adjusted = Ki * 0.5
            Kd_adjusted = Kd * 1.5
        else:
# æ­£å¸¸ç³»ç»Ÿ
            Kp_adjusted = Kp
            Ki_adjusted = Ki
            Kd_adjusted = Kd

        return Kp_adjusted, Ki_adjusted, Kd_adjusted

    def simulate_with_pid(self, reference, t_final=10):
        """PIDæ§åˆ¶ä»¿çœŸ"""
        dt = 0.01
        t = np.arange(0, t_final, dt)

# PIDå‚æ•°
        Kp, Ki, Kd = 10, 5, 1

        x = np.zeros((len(t), 2))
        u = np.zeros((len(t), 1))
        error = np.zeros(len(t))
        error_integral = 0
        error_derivative = 0

        for i in range(1, len(t)):
# è®¡ç®—è¯¯å·®
            current_output = x[i-1, 1]  # è§’é€Ÿåº¦è¾“å‡º
            error[i] = reference - current_output

# PIDæ§åˆ¶
            error_integral += error[i] * dt
            error_derivative = (error[i] - error[i-1]) / dt

            u[i-1] = Kp * error[i] + Ki * error_integral + Kd * error_derivative

# ç³»ç»Ÿå“åº”
            dx = self.system.A @ x[i-1] + self.system.B @ u[i-1]
            x[i] = x[i-1] + dt * dx

        return t, x, u, error
```

## 11. å·¥å…·å®ç°

### 11.1. Pythonæ§åˆ¶ç†è®ºå·¥å…·

```python
class ControlTheoryTools:
    def __init__(self):
        self.analysis_tools = {
            'stability': StabilityAnalysis,
            'controllability': ControllabilityAnalysis,
            'observability': ObservabilityAnalysis
        }

    def analyze_system(self, system, analysis_type):
        """åˆ†æç³»ç»Ÿ"""
        if analysis_type in self.analysis_tools:
            analyzer = self.analysis_tools[analysis_type](system)
            return analyzer.analyze()
        else:
            raise ValueError(f"Unknown analysis type: {analysis_type}")

    def design_controller(self, system, method, **kwargs):
        """è®¾è®¡æ§åˆ¶å™¨"""
        if method == 'pole_placement':
            controller = StateFeedbackController(system)
            return controller.pole_placement(kwargs['desired_poles'])
        elif method == 'lqr':
            controller = StateFeedbackController(system)
            return controller.lqr_design(kwargs['Q'], kwargs['R'])
        else:
            raise ValueError(f"Unknown controller design method: {method}")

    def simulate_system(self, system, controller, x0, t_final=10):
        """ä»¿çœŸç³»ç»Ÿ"""
# æ„å»ºé—­ç¯ç³»ç»Ÿ
        closed_loop = controller.closed_loop_system(controller.K)

# ä»¿çœŸ
        dt = 0.01
        t = np.arange(0, t_final, dt)
        u = np.zeros((len(t), system.m))

        x, y = closed_loop.simulate(x0, u, t)

        return t, x, y

class StabilityAnalysis:
    def __init__(self, system):
        self.system = system

    def analyze(self):
        """åˆ†æç¨³å®šæ€§"""
# ç‰¹å¾å€¼åˆ†æ
        eigenvalues = self.system.eigenvalues()

# Lyapunovç¨³å®šæ€§
        lyapunov_analyzer = LyapunovStability(self.system)
        P = lyapunov_analyzer.find_lyapunov_function()
        lyapunov_stable, _ = lyapunov_analyzer.lyapunov_stability_test(P)

        return {
            'eigenvalues': eigenvalues,
            'asymptotically_stable': np.all(np.real(eigenvalues) < 0),
            'lyapunov_stable': lyapunov_stable,
            'lyapunov_matrix': P
        }
```

## 12. JavaScriptæ§åˆ¶ç†è®ºå®ç°

```javascript
class ControlTheoryTools {
  constructor() {
    this.analysisTools = {
      'stability': StabilityAnalysis,
      'controllability': ControllabilityAnalysis,
      'observability': ObservabilityAnalysis
    };
  }

  analyzeSystem(system, analysisType) {
    if (analysisType in this.analysisTools) {
      const analyzer = new this.analysisTools[analysisType](system);
      return analyzer.analyze();
    } else {
      throw new Error(`Unknown analysis type: ${analysisType}`);
    }
  }

  designController(system, method, config) {
    if (method === 'pole_placement') {
      const controller = new StateFeedbackController(system);
      return controller.polePlacement(config.desiredPoles);
    } else if (method === 'lqr') {
      const controller = new StateFeedbackController(system);
      return controller.lqrDesign(config.Q, config.R);
    } else {
      throw new Error(`Unknown controller design method: ${method}`);
    }
  }

  simulateSystem(system, controller, x0, tFinal = 10) {
    // æ„å»ºé—­ç¯ç³»ç»Ÿ
    const closedLoop = controller.closedLoopSystem(controller.K);

    // ä»¿çœŸ
    const dt = 0.01;
    const t = [];
    for (let i = 0; i <= tFinal / dt; i++) {
      t.push(i * dt);
    }

    const u = new Array(t.length).fill(0).map(() => new Array(system.m).fill(0));

    const { x, y } = closedLoop.simulate(x0, u, t);

    return { t, x, y };
  }
}

class LinearSystem {
  constructor(A, B, C, D = null) {
    this.A = A;
    this.B = B;
    this.C = C;
    this.D = D || math.zeros(C.length, B[0].length);

    this.n = A.length;
    this.m = B[0].length;
    this.p = C.length;
  }

  simulate(x0, u, t) {
    const dt = t[1] - t[0];
    const x = new Array(t.length).fill(0).map(() => new Array(this.n).fill(0));
    const y = new Array(t.length).fill(0).map(() => new Array(this.p).fill(0));

    x[0] = [...x0];

    for (let i = 1; i < t.length; i++) {
      // æ¬§æ‹‰æ³•ç§¯åˆ†
      const dx = math.add(
        math.multiply(this.A, x[i-1]),
        math.multiply(this.B, u[i-1])
      );

      x[i] = math.add(x[i-1], math.multiply(dt, dx));
      y[i] = math.add(
        math.multiply(this.C, x[i]),
        math.multiply(this.D, u[i])
      );
    }

    return { x, y };
  }

  eigenvalues() {
    return math.eigs(this.A).values;
  }
}
```

## 13. å­¦ä¹ è·¯å¾„

### 13.1. åŸºç¡€å­¦ä¹ 

1. **çº¿æ€§ä»£æ•°åŸºç¡€** (2-3å‘¨)
   - çŸ©é˜µè¿ç®—
   - ç‰¹å¾å€¼ä¸ç‰¹å¾å‘é‡
   - çº¿æ€§å˜æ¢

2. **å¾®åˆ†æ–¹ç¨‹** (2-3å‘¨)
   - å¸¸å¾®åˆ†æ–¹ç¨‹
   - çº¿æ€§å¾®åˆ†æ–¹ç¨‹
   - çŠ¶æ€ç©ºé—´è¡¨ç¤º

### 13.2. è¿›é˜¶å­¦ä¹ 

1. **çº¿æ€§ç³»ç»Ÿç†è®º** (3-4å‘¨)
   - çŠ¶æ€ç©ºé—´æ¨¡å‹
   - å¯æ§æ€§ä¸å¯è§‚æ€§
   - ç¨³å®šæ€§åˆ†æ

2. **æ§åˆ¶å™¨è®¾è®¡** (3-4å‘¨)
   - æç‚¹é…ç½®
   - LQRè®¾è®¡
   - è§‚æµ‹å™¨è®¾è®¡

### 13.3. åº”ç”¨å®è·µ

1. **å®é™…ç³»ç»Ÿ** (4-5å‘¨)
   - å€’ç«‹æ‘†æ§åˆ¶
   - ç”µæœºæ§åˆ¶
   - é£è¡Œå™¨æ§åˆ¶

2. **å·¥å…·å¼€å‘** (3-4å‘¨)
   - ä»¿çœŸå·¥å…·
   - åˆ†æå·¥å…·
   - è®¾è®¡å·¥å…·

## 14. æ€»ç»“

çº¿æ€§ç³»ç»Ÿæ§åˆ¶ç†è®ºä¸ºç°ä»£æ§åˆ¶å·¥ç¨‹æä¾›äº†é‡è¦çš„ç†è®ºåŸºç¡€ã€‚é€šè¿‡æ·±å…¥ç†è§£çŠ¶æ€ç©ºé—´æ¨¡å‹ã€æ§åˆ¶å™¨è®¾è®¡å’Œç¨³å®šæ€§åˆ†æï¼Œå¯ä»¥è®¾è®¡å‡ºæ—¢æ»¡è¶³æ€§èƒ½éœ€æ±‚åˆå…·å¤‡ç¨³å®šæ€§çš„æ§åˆ¶ç³»ç»Ÿã€‚
