# 8.6.2 éçº¿æ€§ç³»ç»Ÿæ§åˆ¶ç†è®ºæ·±åŒ–

## ğŸ“‘ ç›®å½•

- [8.6.2 éçº¿æ€§ç³»ç»Ÿæ§åˆ¶ç†è®ºæ·±åŒ–](#862-éçº¿æ€§ç³»ç»Ÿæ§åˆ¶ç†è®ºæ·±åŒ–)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. éçº¿æ€§ç³»ç»ŸåŸºç¡€](#1-éçº¿æ€§ç³»ç»ŸåŸºç¡€)
    - [1.1. éçº¿æ€§ç³»ç»Ÿå®šä¹‰](#11-éçº¿æ€§ç³»ç»Ÿå®šä¹‰)
  - [2. éçº¿æ€§ç³»ç»Ÿç‰¹æ€§](#2-éçº¿æ€§ç³»ç»Ÿç‰¹æ€§)
  - [3. Lyapunovç¨³å®šæ€§ç†è®º](#3-lyapunovç¨³å®šæ€§ç†è®º)
    - [3.1. Lyapunovå‡½æ•°](#31-lyapunovå‡½æ•°)
  - [4. ç¨³å®šæ€§åˆ†æ](#4-ç¨³å®šæ€§åˆ†æ)
  - [5. åé¦ˆçº¿æ€§åŒ–](#5-åé¦ˆçº¿æ€§åŒ–)
    - [5.1. è¾“å…¥-è¾“å‡ºçº¿æ€§åŒ–](#51-è¾“å…¥-è¾“å‡ºçº¿æ€§åŒ–)
  - [6. ç²¾ç¡®çº¿æ€§åŒ–](#6-ç²¾ç¡®çº¿æ€§åŒ–)
  - [7. æ»‘æ¨¡æ§åˆ¶](#7-æ»‘æ¨¡æ§åˆ¶)
    - [7.1. æ»‘æ¨¡é¢è®¾è®¡](#71-æ»‘æ¨¡é¢è®¾è®¡)
  - [8. é«˜é˜¶æ»‘æ¨¡æ§åˆ¶](#8-é«˜é˜¶æ»‘æ¨¡æ§åˆ¶)
  - [9. è‡ªé€‚åº”æ§åˆ¶](#9-è‡ªé€‚åº”æ§åˆ¶)
    - [9.1. æ¨¡å‹å‚è€ƒè‡ªé€‚åº”æ§åˆ¶](#91-æ¨¡å‹å‚è€ƒè‡ªé€‚åº”æ§åˆ¶)
  - [10. è‡ªé€‚åº”æ»‘æ¨¡æ§åˆ¶](#10-è‡ªé€‚åº”æ»‘æ¨¡æ§åˆ¶)
  - [11. åº”ç”¨æ¡ˆä¾‹](#11-åº”ç”¨æ¡ˆä¾‹)
    - [11.1. å€’ç«‹æ‘†æ§åˆ¶](#111-å€’ç«‹æ‘†æ§åˆ¶)
  - [12. æœºå™¨äººæ§åˆ¶](#12-æœºå™¨äººæ§åˆ¶)
  - [13. å·¥å…·å®ç°](#13-å·¥å…·å®ç°)
    - [13.1. Pythonéçº¿æ€§æ§åˆ¶å·¥å…·](#131-pythonéçº¿æ€§æ§åˆ¶å·¥å…·)
  - [14. JavaScriptéçº¿æ€§æ§åˆ¶å®ç°](#14-javascriptéçº¿æ€§æ§åˆ¶å®ç°)
  - [15. å­¦ä¹ è·¯å¾„](#15-å­¦ä¹ è·¯å¾„)
    - [15.1. åŸºç¡€å­¦ä¹ ](#151-åŸºç¡€å­¦ä¹ )
    - [15.2. è¿›é˜¶å­¦ä¹ ](#152-è¿›é˜¶å­¦ä¹ )
    - [15.3. åº”ç”¨å®è·µ](#153-åº”ç”¨å®è·µ)
  - [16. æ€»ç»“](#16-æ€»ç»“)

---


## 1. éçº¿æ€§ç³»ç»ŸåŸºç¡€

### 1.1. éçº¿æ€§ç³»ç»Ÿå®šä¹‰

éçº¿æ€§ç³»ç»Ÿæ˜¯ä¸æ»¡è¶³å åŠ åŸç†çš„åŠ¨æ€ç³»ç»Ÿï¼Œå…¶è¾“å‡ºä¸è¾“å…¥ä¹‹é—´ä¸æ»¡è¶³çº¿æ€§å…³ç³»ã€‚

```python
import numpy as np
from scipy.integrate import odeint
import matplotlib.pyplot as plt

class NonlinearSystem:
    def __init__(self, f, g, h):
        """
        éçº¿æ€§ç³»ç»Ÿ
        dx/dt = f(x, u)
        y = h(x)
        """
        self.f = f  # çŠ¶æ€æ–¹ç¨‹
        self.g = g  # è¾“å…¥å‡½æ•°
        self.h = h  # è¾“å‡ºå‡½æ•°

    def dynamics(self, x, t, u):
        """ç³»ç»ŸåŠ¨åŠ›å­¦"""
        return self.f(x, u)

    def simulate(self, x0, u_func, t):
        """æ¨¡æ‹Ÿç³»ç»Ÿå“åº”"""
        def system_ode(x, t):
            u = u_func(t)
            return self.dynamics(x, t, u)

        x = odeint(system_ode, x0, t)
        y = np.array([self.h(xi) for xi in x])

        return x, y

    def equilibrium_points(self, u_eq=0):
        """è®¡ç®—å¹³è¡¡ç‚¹"""
        from scipy.optimize import fsolve

        def equilibrium_condition(x):
            return self.f(x, u_eq)

# å¯»æ‰¾å¹³è¡¡ç‚¹
        x_eq = fsolve(equilibrium_condition, np.zeros(self.n))
        return x_eq

    def linearize(self, x_eq, u_eq):
        """åœ¨å¹³è¡¡ç‚¹é™„è¿‘çº¿æ€§åŒ–"""
        from scipy.misc import derivative

        n = len(x_eq)
        m = 1 if np.isscalar(u_eq) else len(u_eq)

# è®¡ç®—é›…å¯æ¯”çŸ©é˜µ
        A = np.zeros((n, n))
        B = np.zeros((n, m))

        for i in range(n):
            for j in range(n):
                def f_i(x):
                    x_temp = x_eq.copy()
                    x_temp[j] = x
                    return self.f(x_temp, u_eq)[i]
                A[i, j] = derivative(f_i, x_eq[j], dx=1e-6)

        for i in range(n):
            def f_i(u):
                if np.isscalar(u):
                    return self.f(x_eq, u)[i]
                else:
                    return self.f(x_eq, u)[i]
            B[i, 0] = derivative(f_i, u_eq, dx=1e-6)

        C = np.zeros((self.p, n))
        for i in range(self.p):
            for j in range(n):
                def h_i(x):
                    x_temp = x_eq.copy()
                    x_temp[j] = x
                    return self.h(x_temp)[i]
                C[i, j] = derivative(h_i, x_eq[j], dx=1e-6)

        return A, B, C

class VanDerPolOscillator:
    def __init__(self, mu=1.0):
        """Van der PolæŒ¯è¡å™¨"""
        self.mu = mu
        self.n = 2
        self.p = 1

    def dynamics(self, x, u):
        """Van der PolåŠ¨åŠ›å­¦"""
        x1, x2 = x
        dx1 = x2
        dx2 = -x1 + self.mu * (1 - x1**2) * x2 + u
        return np.array([dx1, dx2])

    def output(self, x):
        """è¾“å‡ºå‡½æ•°"""
        return np.array([x[0]])

    def simulate(self, x0, u_func, t):
        """æ¨¡æ‹Ÿç³»ç»Ÿ"""
        def system_ode(x, t):
            u = u_func(t)
            return self.dynamics(x, u)

        x = odeint(system_ode, x0, t)
        y = np.array([self.output(xi) for xi in x])

        return x, y

class PendulumSystem:
    def __init__(self, m=1.0, l=1.0, g=9.81, b=0.1):
        """å•æ‘†ç³»ç»Ÿ"""
        self.m = m
        self.l = l
        self.g = g
        self.b = b
        self.n = 2
        self.p = 1

    def dynamics(self, x, u):
        """å•æ‘†åŠ¨åŠ›å­¦"""
        theta, omega = x
        dtheta = omega
        domega = (-self.g/self.l) * np.sin(theta) - (self.b/(self.m*self.l**2)) * omega + u/(self.m*self.l**2)
        return np.array([dtheta, domega])

    def output(self, x):
        """è¾“å‡ºå‡½æ•°"""
        return np.array([x[0]])  # è§’åº¦è¾“å‡º

    def simulate(self, x0, u_func, t):
        """æ¨¡æ‹Ÿç³»ç»Ÿ"""
        def system_ode(x, t):
            u = u_func(t)
            return self.dynamics(x, u)

        x = odeint(system_ode, x0, t)
        y = np.array([self.output(xi) for xi in x])

        return x, y
```

## 2. éçº¿æ€§ç³»ç»Ÿç‰¹æ€§

```python
class NonlinearSystemAnalysis:
    def __init__(self, system):
        self.system = system

    def equilibrium_analysis(self):
        """å¹³è¡¡ç‚¹åˆ†æ"""
# å¯»æ‰¾å¹³è¡¡ç‚¹
        x_eq = self.system.equilibrium_points()

# åœ¨å¹³è¡¡ç‚¹é™„è¿‘çº¿æ€§åŒ–
        A, B, C = self.system.linearize(x_eq, 0)

# åˆ†æçº¿æ€§åŒ–ç³»ç»Ÿçš„ç¨³å®šæ€§
        eigenvalues = np.linalg.eigvals(A)

        return {
            'equilibrium_points': x_eq,
            'linearized_A': A,
            'linearized_B': B,
            'linearized_C': C,
            'eigenvalues': eigenvalues,
            'stable': np.all(np.real(eigenvalues) < 0)
        }

    def bifurcation_analysis(self, param_range, param_name):
        """åˆ†å²”åˆ†æ"""
        bifurcation_points = []

        for param in param_range:
# ä¿®æ”¹ç³»ç»Ÿå‚æ•°
            setattr(self.system, param_name, param)

# å¯»æ‰¾å¹³è¡¡ç‚¹
            x_eq = self.system.equilibrium_points()

# çº¿æ€§åŒ–å¹¶åˆ†æç¨³å®šæ€§
            A, _, _ = self.system.linearize(x_eq, 0)
            eigenvalues = np.linalg.eigvals(A)

# æ£€æŸ¥æ˜¯å¦æœ‰ç‰¹å¾å€¼ç©¿è¿‡è™šè½´
            if np.any(np.abs(np.real(eigenvalues)) < 1e-6):
                bifurcation_points.append({
                    'parameter': param,
                    'equilibrium': x_eq,
                    'eigenvalues': eigenvalues
                })

        return bifurcation_points

    def limit_cycle_analysis(self, x0, t_final=50):
        """æé™ç¯åˆ†æ"""
        t = np.linspace(0, t_final, 1000)

        def u_func(t):
            return 0  # æ— è¾“å…¥

        x, _ = self.system.simulate(x0, u_func, t)

# åˆ†æè½¨è¿¹æ˜¯å¦æ”¶æ•›åˆ°æé™ç¯
# è¿™é‡Œå¯ä»¥å®ç°æ›´å¤æ‚çš„æé™ç¯æ£€æµ‹ç®—æ³•
        return x
```

## 3. Lyapunovç¨³å®šæ€§ç†è®º

### 3.1. Lyapunovå‡½æ•°

```python
class LyapunovStability:
    def __init__(self, system):
        self.system = system

    def check_lyapunov_stability(self, V, x0, t_final=10):
        """æ£€æŸ¥Lyapunovç¨³å®šæ€§"""
        t = np.linspace(0, t_final, 1000)

        def u_func(t):
            return 0  # æ— è¾“å…¥

        x, _ = self.system.simulate(x0, u_func, t)

# è®¡ç®—Lyapunovå‡½æ•°å€¼
        V_values = np.array([V(xi) for xi in x])

# æ£€æŸ¥Lyapunovå‡½æ•°æ˜¯å¦é€’å‡
        V_decreasing = np.all(np.diff(V_values) <= 0)

# æ£€æŸ¥æ˜¯å¦æ”¶æ•›åˆ°å¹³è¡¡ç‚¹
        x_eq = self.system.equilibrium_points()
        convergence = np.linalg.norm(x[-1] - x_eq) < 1e-3

        return {
            'V_values': V_values,
            'V_decreasing': V_decreasing,
            'convergence': convergence,
            'asymptotically_stable': V_decreasing and convergence
        }

    def construct_lyapunov_function(self, method='energy'):
        """æ„é€ Lyapunovå‡½æ•°"""
        if method == 'energy':
            return self.energy_based_lyapunov()
        elif method == 'quadratic':
            return self.quadratic_lyapunov()
        else:
            raise ValueError(f"Unknown method: {method}")

    def energy_based_lyapunov(self):
        """åŸºäºèƒ½é‡çš„Lyapunovå‡½æ•°"""
        def V(x):
# å¯¹äºå•æ‘†ç³»ç»Ÿï¼Œä½¿ç”¨æ€»èƒ½é‡
            theta, omega = x
            kinetic = 0.5 * self.system.m * (self.system.l * omega)**2
            potential = self.system.m * self.system.g * self.system.l * (1 - np.cos(theta))
            return kinetic + potential
        return V

    def quadratic_lyapunov(self):
        """äºŒæ¬¡å‹Lyapunovå‡½æ•°"""
# åœ¨å¹³è¡¡ç‚¹é™„è¿‘çº¿æ€§åŒ–
        x_eq = self.system.equilibrium_points()
        A, _, _ = self.system.linearize(x_eq, 0)

# æ±‚è§£Lyapunovæ–¹ç¨‹
        Q = np.eye(A.shape[0])
        P = self.solve_lyapunov_equation(A, Q)

        def V(x):
            x_tilde = x - x_eq
            return x_tilde.T @ P @ x_tilde

        return V

    def solve_lyapunov_equation(self, A, Q):
        """æ±‚è§£Lyapunovæ–¹ç¨‹"""
        from scipy.linalg import solve_continuous_lyapunov
        return solve_continuous_lyapunov(A, -Q)

    def adaptive_control_lyapunov(self, theta_hat, theta_dot_hat):
        """è‡ªé€‚åº”æ§åˆ¶çš„Lyapunovå‡½æ•°"""
        def V(x, theta_hat):
# çŠ¶æ€è¯¯å·®
            x_error = x - self.system.equilibrium_points()

# å‚æ•°è¯¯å·®
            theta_error = theta_hat - self.true_parameters

# æ€»Lyapunovå‡½æ•°
            V_state = x_error.T @ P @ x_error
            V_param = theta_error.T @ Gamma_inv @ theta_error

            return V_state + V_param

        return V
```

## 4. ç¨³å®šæ€§åˆ†æ

```python
class StabilityAnalysis:
    def __init__(self, system):
        self.system = system

    def local_stability_analysis(self, x_eq):
        """å±€éƒ¨ç¨³å®šæ€§åˆ†æ"""
# åœ¨å¹³è¡¡ç‚¹é™„è¿‘çº¿æ€§åŒ–
        A, _, _ = self.system.linearize(x_eq, 0)

# è®¡ç®—ç‰¹å¾å€¼
        eigenvalues = np.linalg.eigvals(A)

# åˆ¤æ–­ç¨³å®šæ€§
        real_parts = np.real(eigenvalues)

        if np.all(real_parts < 0):
            stability = 'asymptotically_stable'
        elif np.all(real_parts <= 0) and np.any(real_parts == 0):
            stability = 'marginally_stable'
        else:
            stability = 'unstable'

        return {
            'eigenvalues': eigenvalues,
            'stability': stability,
            'linearized_matrix': A
        }

    def global_stability_analysis(self, x0_set, t_final=10):
        """å…¨å±€ç¨³å®šæ€§åˆ†æ"""
        results = []

        for x0 in x0_set:
# æ¨¡æ‹Ÿç³»ç»Ÿå“åº”
            t = np.linspace(0, t_final, 1000)

            def u_func(t):
                return 0

            x, _ = self.system.simulate(x0, u_func, t)

# æ£€æŸ¥æ˜¯å¦æ”¶æ•›åˆ°å¹³è¡¡ç‚¹
            x_eq = self.system.equilibrium_points()
            final_error = np.linalg.norm(x[-1] - x_eq)

            results.append({
                'initial_condition': x0,
                'final_error': final_error,
                'converges': final_error < 1e-3,
                'trajectory': x
            })

        return results

    def robust_stability_analysis(self, uncertainty_bounds):
        """é²æ£’ç¨³å®šæ€§åˆ†æ"""
# è¿™é‡Œå¯ä»¥å®ç°æ›´å¤æ‚çš„é²æ£’ç¨³å®šæ€§åˆ†æ
# ä¾‹å¦‚ï¼šå‚æ•°ä¸ç¡®å®šæ€§ã€æœªå»ºæ¨¡åŠ¨æ€ç­‰
        pass
```

## 5. åé¦ˆçº¿æ€§åŒ–

### 5.1. è¾“å…¥-è¾“å‡ºçº¿æ€§åŒ–

```python
class FeedbackLinearization:
    def __init__(self, system):
        self.system = system

    def input_output_linearization(self, output_index=0):
        """è¾“å…¥-è¾“å‡ºçº¿æ€§åŒ–"""
# è®¡ç®—ç›¸å¯¹åº¦
        relative_degree = self.compute_relative_degree(output_index)

# è®¡ç®—Lieå¯¼æ•°
        L_f_h = self.lie_derivative_f(output_index)
        L_g_L_f_h = self.lie_derivative_g_L_f_h(output_index, relative_degree)

# æ„é€ çº¿æ€§åŒ–æ§åˆ¶å¾‹
        def control_law(x, v):
            alpha = -L_f_h(x) / L_g_L_f_h(x)
            beta = 1 / L_g_L_f_h(x)
            return alpha + beta * v

        return control_law, relative_degree

    def compute_relative_degree(self, output_index):
        """è®¡ç®—ç›¸å¯¹åº¦"""
# è®¡ç®—è¾“å‡ºå‡½æ•°h(x)ç›¸å¯¹äºè¾“å…¥uçš„ç›¸å¯¹åº¦
        h = self.system.output_functions[output_index]

# è®¡ç®—L_f h
        L_f_h = self.lie_derivative_f(output_index)

# æ£€æŸ¥L_g L_f^(r-1) hæ˜¯å¦éé›¶
        r = 1
        while r <= self.system.n:
            if r == 1:
                L_g_L_f_h = self.lie_derivative_g_h(output_index)
            else:
                L_g_L_f_h = self.lie_derivative_g_L_f_h(output_index, r)

# æ£€æŸ¥æ˜¯å¦éé›¶
            if self.is_nonzero_function(L_g_L_f_h):
                return r

            r += 1

        return None  # ç›¸å¯¹åº¦ä¸å­˜åœ¨

    def lie_derivative_f(self, output_index):
        """è®¡ç®—L_f h"""
        h = self.system.output_functions[output_index]
        f = self.system.dynamics_f

        def L_f_h(x):
# è®¡ç®—L_f h = âˆ‡h(x) Â· f(x)
            grad_h = self.compute_gradient(h, x)
            f_x = f(x)
            return np.dot(grad_h, f_x)

        return L_f_h

    def lie_derivative_g_h(self, output_index):
        """è®¡ç®—L_g h"""
        h = self.system.output_functions[output_index]
        g = self.system.dynamics_g

        def L_g_h(x):
# è®¡ç®—L_g h = âˆ‡h(x) Â· g(x)
            grad_h = self.compute_gradient(h, x)
            g_x = g(x)
            return np.dot(grad_h, g_x)

        return L_g_h

    def lie_derivative_g_L_f_h(self, output_index, relative_degree):
        """è®¡ç®—L_g L_f^(r-1) h"""
        if relative_degree == 1:
            return self.lie_derivative_g_h(output_index)
        else:
# é€’å½’è®¡ç®—L_g L_f^(r-1) h
            L_f_h = self.lie_derivative_f(output_index)
            g = self.system.dynamics_g

            def L_g_L_f_h(x):
# è®¡ç®—L_g L_f^(r-1) h = âˆ‡(L_f^(r-1) h)(x) Â· g(x)
                grad_L_f_h = self.compute_gradient(L_f_h, x)
                g_x = g(x)
                return np.dot(grad_L_f_h, g_x)

            return L_g_L_f_h

    def compute_gradient(self, function, x):
        """è®¡ç®—å‡½æ•°çš„æ¢¯åº¦"""
# ä½¿ç”¨æ•°å€¼å¾®åˆ†
        epsilon = 1e-6
        n = len(x)
        grad = np.zeros(n)

        for i in range(n):
            x_plus = x.copy()
            x_plus[i] += epsilon
            x_minus = x.copy()
            x_minus[i] -= epsilon

            grad[i] = (function(x_plus) - function(x_minus)) / (2 * epsilon)

        return grad

    def is_nonzero_function(self, function):
        """æ£€æŸ¥å‡½æ•°æ˜¯å¦éé›¶"""
# åœ¨å¤šä¸ªç‚¹ä¸Šæ£€æŸ¥å‡½æ•°å€¼
        test_points = [
            np.array([0, 0]),
            np.array([1, 1]),
            np.array([-1, -1]),
            np.array([0.5, -0.5])
        ]

        for x in test_points:
            if abs(function(x)) > 1e-6:
                return True

        return False

    def full_state_linearization(self):
        """å…¨çŠ¶æ€çº¿æ€§åŒ–"""
# æ£€æŸ¥ç³»ç»Ÿæ˜¯å¦å¯åé¦ˆçº¿æ€§åŒ–
        if not self.is_feedback_linearizable():
            raise ValueError("System is not feedback linearizable")

# æ„é€ åæ ‡å˜æ¢
        z_transform = self.construct_coordinate_transformation()

# æ„é€ æ§åˆ¶å¾‹
        control_law = self.construct_control_law()

        return z_transform, control_law

    def is_feedback_linearizable(self):
        """æ£€æŸ¥ç³»ç»Ÿæ˜¯å¦å¯åé¦ˆçº¿æ€§åŒ–"""
# æ£€æŸ¥å¯æ§æ€§åˆ†å¸ƒ
# è¿™é‡Œéœ€è¦å®ç°æ›´å¤æ‚çš„ç®—æ³•
        return True

    def construct_coordinate_transformation(self):
        """æ„é€ åæ ‡å˜æ¢"""
        def z_transform(x):
# å¯¹äºå•æ‘†ç³»ç»Ÿï¼Œæ„é€ åæ ‡å˜æ¢
# z1 = x1 (è§’åº¦)
# z2 = x2 (è§’é€Ÿåº¦)
            theta, omega = x

# è®¡ç®—ç›¸å¯¹åº¦
            relative_degree = self.calculate_relative_degree()

            if relative_degree == 2:
# å¯¹äºç›¸å¯¹åº¦ä¸º2çš„ç³»ç»Ÿ
                z1 = theta
                z2 = omega
                return np.array([z1, z2])
            else:
# å¯¹äºå…¶ä»–ç›¸å¯¹åº¦çš„ç³»ç»Ÿï¼Œéœ€è¦æ›´å¤æ‚çš„å˜æ¢
                return self.advanced_coordinate_transformation(x)

        return z_transform

    def calculate_relative_degree(self):
        """è®¡ç®—ç›¸å¯¹åº¦"""
# å¯¹äºå•æ‘†ç³»ç»Ÿï¼Œç›¸å¯¹åº¦ä¸º2
        return 2

    def advanced_coordinate_transformation(self, x):
        """é«˜çº§åæ ‡å˜æ¢"""
# å¯¹äºæ›´å¤æ‚çš„ç³»ç»Ÿï¼Œå®ç°æ›´é«˜çº§çš„åæ ‡å˜æ¢
        theta, omega = x

# ä½¿ç”¨éçº¿æ€§å˜æ¢
        z1 = theta
        z2 = omega + self.nonlinear_term(theta)

        return np.array([z1, z2])

    def nonlinear_term(self, theta):
        """éçº¿æ€§é¡¹"""
# æ·»åŠ éçº¿æ€§é¡¹ä»¥æ”¹å–„å˜æ¢
        return 0.1 * np.sin(theta)

    def construct_control_law(self):
        """æ„é€ æ§åˆ¶å¾‹"""
        def control_law(x, v):
# å¯¹äºå•æ‘†ç³»ç»Ÿï¼Œæ„é€ åé¦ˆçº¿æ€§åŒ–æ§åˆ¶å¾‹
            theta, omega = x
            m, l, g, b = self.system.m, self.system.l, self.system.g, self.system.b

# è®¡ç®—Lieå¯¼æ•°
            Lf_h = omega
            Lg_Lf_h = 1.0 / (m * l**2)

# åé¦ˆçº¿æ€§åŒ–æ§åˆ¶å¾‹
            alpha = -Lf_h / Lg_Lf_h
            beta = 1.0 / Lg_Lf_h

            u = alpha + beta * v

            return u

        return control_law
```

## 6. ç²¾ç¡®çº¿æ€§åŒ–

```python
class ExactLinearization:
    def __init__(self, system):
        self.system = system

    def exact_linearization_control(self):
        """ç²¾ç¡®çº¿æ€§åŒ–æ§åˆ¶"""
# æ„é€ çº¿æ€§åŒ–æ§åˆ¶å¾‹
        def linearizing_control(x, v):
# å¯¹äºå•æ‘†ç³»ç»Ÿ
            theta, omega = x
            m, l, g, b = self.system.m, self.system.l, self.system.g, self.system.b

# çº¿æ€§åŒ–æ§åˆ¶å¾‹
            alpha = (m * l**2) * (g/l * np.sin(theta) + b/(m*l**2) * omega)
            beta = m * l**2

            return alpha + beta * v

        return linearizing_control

    def simulate_linearized_system(self, x0, reference, t_final=10):
        """ä»¿çœŸçº¿æ€§åŒ–ç³»ç»Ÿ"""
# çº¿æ€§åŒ–æ§åˆ¶å¾‹
        control_law = self.exact_linearization_control()

# ä»¿çœŸå‚æ•°
        dt = 0.01
        t = np.arange(0, t_final, dt)

        x = np.zeros((len(t), 2))
        u = np.zeros(len(t))

        x[0] = x0

        for i in range(1, len(t)):
# è®¡ç®—å‚è€ƒä¿¡å·
            r = reference(t[i])

# è®¡ç®—æ§åˆ¶è¾“å…¥
            v = -2 * (x[i-1, 0] - r) - 3 * x[i-1, 1]  # PDæ§åˆ¶å™¨
            u[i-1] = control_law(x[i-1], v)

# ç³»ç»Ÿå“åº”
            dx = self.system.dynamics(x[i-1], u[i-1])
            x[i] = x[i-1] + dt * dx

        return t, x, u
```

## 7. æ»‘æ¨¡æ§åˆ¶

### 7.1. æ»‘æ¨¡é¢è®¾è®¡

```python
class SlidingModeControl:
    def __init__(self, system):
        self.system = system

    def design_sliding_surface(self, lambda_coeff):
        """è®¾è®¡æ»‘æ¨¡é¢"""
        def sliding_surface(x):
# å¯¹äºäºŒé˜¶ç³»ç»Ÿï¼Œæ»‘æ¨¡é¢ä¸º s = x2 + lambda * x1
            return x[1] + lambda_coeff * x[0]

        return sliding_surface

    def sliding_mode_control_law(self, sliding_surface, eta, k):
        """æ»‘æ¨¡æ§åˆ¶å¾‹"""
        def control_law(x):
            s = sliding_surface(x)

# ç­‰æ•ˆæ§åˆ¶
            u_eq = self.equivalent_control(x)

# åˆ‡æ¢æ§åˆ¶
            u_sw = -k * np.sign(s)

            return u_eq + u_sw

        return control_law

    def equivalent_control(self, x):
        """ç­‰æ•ˆæ§åˆ¶"""
# å¯¹äºå•æ‘†ç³»ç»Ÿ
        theta, omega = x
        m, l, g, b = self.system.m, self.system.l, self.system.g, self.system.b

# ç­‰æ•ˆæ§åˆ¶
        u_eq = m * l**2 * (g/l * np.sin(theta) + b/(m*l**2) * omega)

        return u_eq

    def simulate_sliding_mode_control(self, x0, reference, t_final=10):
        """ä»¿çœŸæ»‘æ¨¡æ§åˆ¶"""
# è®¾è®¡æ»‘æ¨¡é¢
        lambda_coeff = 2.0
        sliding_surface = self.design_sliding_surface(lambda_coeff)

# è®¾è®¡æ§åˆ¶å¾‹
        eta = 0.1
        k = 10.0
        control_law = self.sliding_mode_control_law(sliding_surface, eta, k)

# ä»¿çœŸå‚æ•°
        dt = 0.01
        t = np.arange(0, t_final, dt)

        x = np.zeros((len(t), 2))
        u = np.zeros(len(t))
        s = np.zeros(len(t))

        x[0] = x0

        for i in range(1, len(t)):
# è®¡ç®—æ»‘æ¨¡é¢
            s[i-1] = sliding_surface(x[i-1])

# è®¡ç®—æ§åˆ¶è¾“å…¥
            u[i-1] = control_law(x[i-1])

# ç³»ç»Ÿå“åº”
            dx = self.system.dynamics(x[i-1], u[i-1])
            x[i] = x[i-1] + dt * dx

        s[-1] = sliding_surface(x[-1])

        return t, x, u, s

    def chattering_reduction(self, sliding_surface, eta, k, boundary_layer):
        """å‡å°‘æŠ–æŒ¯"""
        def control_law(x):
            s = sliding_surface(x)

# ç­‰æ•ˆæ§åˆ¶
            u_eq = self.equivalent_control(x)

# è¾¹ç•Œå±‚å†…çš„è¿ç»­æ§åˆ¶
            if abs(s) <= boundary_layer:
                u_sw = -k * s / boundary_layer
            else:
                u_sw = -k * np.sign(s)

            return u_eq + u_sw

        return control_law
```

## 8. é«˜é˜¶æ»‘æ¨¡æ§åˆ¶

```python
class HigherOrderSlidingMode:
    def __init__(self, system):
        self.system = system

    def super_twisting_algorithm(self, lambda_coeff, alpha, beta):
        """è¶…èºæ—‹ç®—æ³•"""
        def control_law(x):
            s = x[1] + lambda_coeff * x[0]

# ç­‰æ•ˆæ§åˆ¶
            u_eq = self.equivalent_control(x)

# è¶…èºæ—‹æ§åˆ¶
            u_st = -alpha * np.sqrt(abs(s)) * np.sign(s) - beta * np.sign(s)

            return u_eq + u_st

        return control_law

    def twisting_algorithm(self, lambda_coeff, alpha1, alpha2):
        """èºæ—‹ç®—æ³•"""
        def control_law(x):
            s = x[1] + lambda_coeff * x[0]

# ç­‰æ•ˆæ§åˆ¶
            u_eq = self.equivalent_control(x)

# èºæ—‹æ§åˆ¶
            if s > 0:
                u_tw = -alpha1
            else:
                u_tw = -alpha2

            return u_eq + u_tw

        return control_law
```

## 9. è‡ªé€‚åº”æ§åˆ¶

### 9.1. æ¨¡å‹å‚è€ƒè‡ªé€‚åº”æ§åˆ¶

```python
class ModelReferenceAdaptiveControl:
    def __init__(self, system, reference_model):
        self.system = system
        self.reference_model = reference_model

    def design_mrac_controller(self, gamma):
        """è®¾è®¡MRACæ§åˆ¶å™¨"""
# è‡ªé€‚åº”å‚æ•°
        theta_hat = np.zeros(2)

        def control_law(x, xm, t):
# å‚è€ƒæ¨¡å‹è¾“å‡º
            ym = self.reference_model.output(xm)

# è·Ÿè¸ªè¯¯å·®
            e = x[0] - ym

# è‡ªé€‚åº”å¾‹
            phi = np.array([x[0], x[1]])
            theta_dot = -gamma * e * phi

# æ§åˆ¶å¾‹
            u = theta_hat[0] * x[0] + theta_hat[1] * x[1]

# æ›´æ–°å‚æ•°ä¼°è®¡
            theta_hat += theta_dot * 0.01  # ç§¯åˆ†æ­¥é•¿

            return u, theta_hat

        return control_law

    def reference_model_dynamics(self, xm, r):
        """å‚è€ƒæ¨¡å‹åŠ¨åŠ›å­¦"""
# ä¸€é˜¶å‚è€ƒæ¨¡å‹
        xm_dot = -xm + r
        return xm_dot

    def simulate_mrac_system(self, x0, reference, t_final=10):
        """ä»¿çœŸMRACç³»ç»Ÿ"""
# è®¾è®¡æ§åˆ¶å™¨
        gamma = 1.0
        control_law = self.design_mrac_controller(gamma)

# ä»¿çœŸå‚æ•°
        dt = 0.01
        t = np.arange(0, t_final, dt)

        x = np.zeros((len(t), 2))
        xm = np.zeros(len(t))
        u = np.zeros(len(t))
        theta_hat = np.zeros((len(t), 2))

        x[0] = x0
        xm[0] = 0

        for i in range(1, len(t)):
# å‚è€ƒä¿¡å·
            r = reference(t[i])

# å‚è€ƒæ¨¡å‹
            xm_dot = self.reference_model_dynamics(xm[i-1], r)
            xm[i] = xm[i-1] + dt * xm_dot

# æ§åˆ¶å¾‹
            u[i-1], theta_hat[i] = control_law(x[i-1], xm[i-1], t[i])

# ç³»ç»Ÿå“åº”
            dx = self.system.dynamics(x[i-1], u[i-1])
            x[i] = x[i-1] + dt * dx

        return t, x, xm, u, theta_hat
```

## 10. è‡ªé€‚åº”æ»‘æ¨¡æ§åˆ¶

```python
class AdaptiveSlidingModeControl:
    def __init__(self, system):
        self.system = system

    def adaptive_sliding_mode_control(self, lambda_coeff, k, gamma):
        """è‡ªé€‚åº”æ»‘æ¨¡æ§åˆ¶"""
# è‡ªé€‚åº”å‚æ•°
        k_hat = k
        lambda_hat = lambda_coeff

        def control_law(x):
# æ»‘æ¨¡é¢
            s = x[1] + lambda_hat * x[0]

# ç­‰æ•ˆæ§åˆ¶
            u_eq = self.equivalent_control(x)

# è‡ªé€‚åº”åˆ‡æ¢æ§åˆ¶
            u_sw = -k_hat * np.sign(s)

# è‡ªé€‚åº”å¾‹
            k_dot = gamma * abs(s)
            lambda_dot = gamma * x[0] * s

# æ›´æ–°å‚æ•°
            k_hat += k_dot * 0.01
            lambda_hat += lambda_dot * 0.01

            return u_eq + u_sw, k_hat, lambda_hat

        return control_law

    def simulate_adaptive_sliding_mode(self, x0, reference, t_final=10):
        """ä»¿çœŸè‡ªé€‚åº”æ»‘æ¨¡æ§åˆ¶"""
# è®¾è®¡æ§åˆ¶å™¨
        lambda_coeff = 2.0
        k = 10.0
        gamma = 1.0
        control_law = self.adaptive_sliding_mode_control(lambda_coeff, k, gamma)

# ä»¿çœŸå‚æ•°
        dt = 0.01
        t = np.arange(0, t_final, dt)

        x = np.zeros((len(t), 2))
        u = np.zeros(len(t))
        k_hat = np.zeros(len(t))
        lambda_hat = np.zeros(len(t))

        x[0] = x0
        k_hat[0] = k
        lambda_hat[0] = lambda_coeff

        for i in range(1, len(t)):
# æ§åˆ¶å¾‹
            u[i-1], k_hat[i], lambda_hat[i] = control_law(x[i-1])

# ç³»ç»Ÿå“åº”
            dx = self.system.dynamics(x[i-1], u[i-1])
            x[i] = x[i-1] + dt * dx

        return t, x, u, k_hat, lambda_hat
```

## 11. åº”ç”¨æ¡ˆä¾‹

### 11.1. å€’ç«‹æ‘†æ§åˆ¶

```python
class InvertedPendulumControl:
    def __init__(self):
        self.system = PendulumSystem()

    def feedback_linearization_control(self):
        """åé¦ˆçº¿æ€§åŒ–æ§åˆ¶"""
# è®¾è®¡çº¿æ€§åŒ–æ§åˆ¶å¾‹
        def control_law(x, v):
            theta, omega = x
            m, l, g, b = self.system.m, self.system.l, self.system.g, self.system.b

# çº¿æ€§åŒ–æ§åˆ¶å¾‹
            alpha = m * l**2 * (g/l * np.sin(theta) + b/(m*l**2) * omega)
            beta = m * l**2

            return alpha + beta * v

        return control_law

    def sliding_mode_control(self):
        """æ»‘æ¨¡æ§åˆ¶"""
# è®¾è®¡æ»‘æ¨¡é¢
        lambda_coeff = 2.0
        def sliding_surface(x):
            return x[1] + lambda_coeff * x[0]

# è®¾è®¡æ§åˆ¶å¾‹
        def control_law(x):
            s = sliding_surface(x)

# ç­‰æ•ˆæ§åˆ¶
            theta, omega = x
            m, l, g, b = self.system.m, self.system.l, self.system.g, self.system.b
            u_eq = m * l**2 * (g/l * np.sin(theta) + b/(m*l**2) * omega)

# åˆ‡æ¢æ§åˆ¶
            k = 10.0
            u_sw = -k * np.sign(s)

            return u_eq + u_sw

        return control_law

    def simulate_controlled_system(self, x0, control_method='feedback_linearization', t_final=10):
        """ä»¿çœŸå—æ§ç³»ç»Ÿ"""
        if control_method == 'feedback_linearization':
            control_law = self.feedback_linearization_control()
        elif control_method == 'sliding_mode':
            control_law = self.sliding_mode_control()
        else:
            raise ValueError(f"Unknown control method: {control_method}")

# ä»¿çœŸå‚æ•°
        dt = 0.01
        t = np.arange(0, t_final, dt)

        x = np.zeros((len(t), 2))
        u = np.zeros(len(t))

        x[0] = x0

        for i in range(1, len(t)):
# è®¡ç®—æ§åˆ¶è¾“å…¥
            u[i-1] = control_law(x[i-1])

# ç³»ç»Ÿå“åº”
            dx = self.system.dynamics(x[i-1], u[i-1])
            x[i] = x[i-1] + dt * dx

        return t, x, u
```

## 12. æœºå™¨äººæ§åˆ¶

```python
class RobotControl:
    def __init__(self, n_joints=2):
        self.n_joints = n_joints
        self.system = self.build_robot_model()

    def build_robot_model(self):
        """æ„å»ºæœºå™¨äººæ¨¡å‹"""
# ç®€åŒ–çš„äºŒè‡ªç”±åº¦æœºå™¨äººæ¨¡å‹
        class RobotSystem:
            def __init__(self):
                self.n = 4  # [q1, q2, dq1, dq2]
                self.p = 2  # [q1, q2]

            def dynamics(self, x, u):
                q1, q2, dq1, dq2 = x
                tau1, tau2 = u

# ç®€åŒ–çš„åŠ¨åŠ›å­¦æ¨¡å‹
                M11 = 1.0 + 0.5 * np.cos(q2)
                M12 = 0.25 * np.cos(q2)
                M21 = 0.25 * np.cos(q2)
                M22 = 0.25

                M = np.array([[M11, M12], [M21, M22]])

# ç§‘æ°åŠ›å’Œç¦»å¿ƒåŠ›
                C = np.array([
                    [-0.25 * dq2 * np.sin(q2), -0.25 * (dq1 + dq2) * np.sin(q2)],
                    [0.25 * dq1 * np.sin(q2), 0]
                ])

# é‡åŠ›é¡¹
                G = np.array([0, 0])

# åŠ é€Ÿåº¦
                ddq = np.linalg.inv(M) @ (np.array([tau1, tau2]) - C @ np.array([dq1, dq2]) - G)

                return np.array([dq1, dq2, ddq[0], ddq[1]])

            def output(self, x):
                return x[:2]

        return RobotSystem()

    def computed_torque_control(self, qd, dqd, ddqd):
        """è®¡ç®—åŠ›çŸ©æ§åˆ¶"""
        def control_law(x, t):
            q1, q2, dq1, dq2 = x

# æœŸæœ›è½¨è¿¹
            q1d = qd[0](t)
            q2d = qd[1](t)
            dq1d = dqd[0](t)
            dq2d = dqd[1](t)
            ddq1d = ddqd[0](t)
            ddq2d = ddqd[1](t)

# è·Ÿè¸ªè¯¯å·®
            e1 = q1 - q1d
            e2 = q2 - q2d
            de1 = dq1 - dq1d
            de2 = dq2 - dq2d

# PDæ§åˆ¶å™¨å¢ç›Š
            Kp = np.array([[10, 0], [0, 10]])
            Kd = np.array([[5, 0], [0, 5]])

# æ§åˆ¶å¾‹
            tau = self.system.dynamics(x, [0, 0])[2:] + ddqd(t) - Kp @ np.array([e1, e2]) - Kd @ np.array([de1, de2])

            return tau

        return control_law

    def simulate_robot_control(self, x0, qd, dqd, ddqd, t_final=10):
        """ä»¿çœŸæœºå™¨äººæ§åˆ¶"""
# è®¾è®¡æ§åˆ¶å™¨
        control_law = self.computed_torque_control(qd, dqd, ddqd)

# ä»¿çœŸå‚æ•°
        dt = 0.01
        t = np.arange(0, t_final, dt)

        x = np.zeros((len(t), 4))
        u = np.zeros((len(t), 2))

        x[0] = x0

        for i in range(1, len(t)):
# è®¡ç®—æ§åˆ¶è¾“å…¥
            u[i-1] = control_law(x[i-1], t[i])

# ç³»ç»Ÿå“åº”
            dx = self.system.dynamics(x[i-1], u[i-1])
            x[i] = x[i-1] + dt * dx

        return t, x, u
```

## 13. å·¥å…·å®ç°

### 13.1. Pythonéçº¿æ€§æ§åˆ¶å·¥å…·

```python
class NonlinearControlTools:
    def __init__(self):
        self.analysis_tools = {
            'stability': LyapunovStability,
            'linearization': FeedbackLinearization,
            'sliding_mode': SlidingModeControl,
            'adaptive': ModelReferenceAdaptiveControl
        }

    def analyze_system(self, system, analysis_type):
        """åˆ†æç³»ç»Ÿ"""
        if analysis_type in self.analysis_tools:
            analyzer = self.analysis_tools[analysis_type](system)
            return analyzer.analyze()
        else:
            raise ValueError(f"Unknown analysis type: {analysis_type}")

    def design_controller(self, system, method, **kwargs):
        """è®¾è®¡æ§åˆ¶å™¨"""
        if method == 'feedback_linearization':
            controller = FeedbackLinearization(system)
            return controller.input_output_linearization()
        elif method == 'sliding_mode':
            controller = SlidingModeControl(system)
            return controller.sliding_mode_control_law()
        elif method == 'adaptive':
            controller = ModelReferenceAdaptiveControl(system, kwargs['reference_model'])
            return controller.design_mrac_controller(kwargs['gamma'])
        else:
            raise ValueError(f"Unknown controller design method: {method}")

    def simulate_controlled_system(self, system, controller, x0, t_final=10):
        """ä»¿çœŸå—æ§ç³»ç»Ÿ"""
        dt = 0.01
        t = np.arange(0, t_final, dt)

        x = np.zeros((len(t), system.n))
        u = np.zeros((len(t), system.m))

        x[0] = x0

        for i in range(1, len(t)):
# è®¡ç®—æ§åˆ¶è¾“å…¥
            u[i-1] = controller(x[i-1])

# ç³»ç»Ÿå“åº”
            dx = system.dynamics(x[i-1], u[i-1])
            x[i] = x[i-1] + dt * dx

        return t, x, u
```

## 14. JavaScriptéçº¿æ€§æ§åˆ¶å®ç°

```javascript
class NonlinearControlTools {
  constructor() {
    this.analysisTools = {
      'stability': LyapunovStability,
      'linearization': FeedbackLinearization,
      'slidingMode': SlidingModeControl,
      'adaptive': ModelReferenceAdaptiveControl
    };
  }

  analyzeSystem(system, analysisType) {
    if (analysisType in this.analysisTools) {
      const analyzer = new this.analysisTools[analysisType](system);
      return analyzer.analyze();
    } else {
      throw new Error(`Unknown analysis type: ${analysisType}`);
    }
  }

  designController(system, method, config) {
    if (method === 'feedback_linearization') {
      const controller = new FeedbackLinearization(system);
      return controller.inputOutputLinearization();
    } else if (method === 'sliding_mode') {
      const controller = new SlidingModeControl(system);
      return controller.slidingModeControlLaw();
    } else if (method === 'adaptive') {
      const controller = new ModelReferenceAdaptiveControl(system, config.referenceModel);
      return controller.designMracController(config.gamma);
    } else {
      throw new Error(`Unknown controller design method: ${method}`);
    }
  }

  simulateControlledSystem(system, controller, x0, tFinal = 10) {
    const dt = 0.01;
    const t = [];
    for (let i = 0; i <= tFinal / dt; i++) {
      t.push(i * dt);
    }

    const x = new Array(t.length).fill(0).map(() => new Array(system.n).fill(0));
    const u = new Array(t.length).fill(0).map(() => new Array(system.m).fill(0));

    x[0] = [...x0];

    for (let i = 1; i < t.length; i++) {
      // è®¡ç®—æ§åˆ¶è¾“å…¥
      u[i-1] = controller(x[i-1]);

      // ç³»ç»Ÿå“åº”
      const dx = system.dynamics(x[i-1], u[i-1]);
      x[i] = math.add(x[i-1], math.multiply(dt, dx));
    }

    return { t, x, u };
  }
}

class NonlinearSystem {
  constructor(f, g, h) {
    this.f = f;  // çŠ¶æ€æ–¹ç¨‹
    this.g = g;  // è¾“å…¥å‡½æ•°
    this.h = h;  // è¾“å‡ºå‡½æ•°
  }

  dynamics(x, u) {
    return this.f(x, u);
  }

  simulate(x0, uFunc, t) {
    // ä½¿ç”¨æ•°å€¼ç§¯åˆ†æ–¹æ³•
    const x = new Array(t.length).fill(0).map(() => new Array(x0.length).fill(0));
    const y = new Array(t.length).fill(0).map(() => new Array(this.h(x0).length).fill(0));

    x[0] = [...x0];
    y[0] = this.h(x0);

    for (let i = 1; i < t.length; i++) {
      const dt = t[i] - t[i-1];
      const u = uFunc(t[i]);

      // æ¬§æ‹‰æ³•ç§¯åˆ†
      const dx = this.dynamics(x[i-1], u);
      x[i] = math.add(x[i-1], math.multiply(dt, dx));
      y[i] = this.h(x[i]);
    }

    return { x, y };
  }
}
```

## 15. å­¦ä¹ è·¯å¾„

### 15.1. åŸºç¡€å­¦ä¹ 

1. **éçº¿æ€§ç³»ç»ŸåŸºç¡€** (2-3å‘¨)
   - éçº¿æ€§ç³»ç»Ÿæ¦‚å¿µ
   - å¹³è¡¡ç‚¹åˆ†æ
   - å±€éƒ¨çº¿æ€§åŒ–

2. **Lyapunovç¨³å®šæ€§ç†è®º** (3-4å‘¨)
   - Lyapunovå‡½æ•°
   - ç¨³å®šæ€§åˆ¤æ®
   - å…¨å±€ç¨³å®šæ€§

### 15.2. è¿›é˜¶å­¦ä¹ 

1. **åé¦ˆçº¿æ€§åŒ–** (3-4å‘¨)
   - è¾“å…¥-è¾“å‡ºçº¿æ€§åŒ–
   - å…¨çŠ¶æ€çº¿æ€§åŒ–
   - åæ ‡å˜æ¢

2. **æ»‘æ¨¡æ§åˆ¶** (3-4å‘¨)
   - æ»‘æ¨¡é¢è®¾è®¡
   - ç­‰æ•ˆæ§åˆ¶
   - æŠ–æŒ¯æŠ‘åˆ¶

### 15.3. åº”ç”¨å®è·µ

1. **å®é™…ç³»ç»Ÿ** (4-5å‘¨)
   - å€’ç«‹æ‘†æ§åˆ¶
   - æœºå™¨äººæ§åˆ¶
   - é£è¡Œå™¨æ§åˆ¶

2. **å·¥å…·å¼€å‘** (3-4å‘¨)
   - ä»¿çœŸå·¥å…·
   - åˆ†æå·¥å…·
   - è®¾è®¡å·¥å…·

## 16. æ€»ç»“

éçº¿æ€§ç³»ç»Ÿæ§åˆ¶ç†è®ºä¸ºå¤„ç†å¤æ‚åŠ¨æ€ç³»ç»Ÿæä¾›äº†å¼ºå¤§çš„ç†è®ºå·¥å…·ã€‚é€šè¿‡æ·±å…¥ç†è§£Lyapunovç¨³å®šæ€§ã€åé¦ˆçº¿æ€§åŒ–ã€æ»‘æ¨¡æ§åˆ¶å’Œè‡ªé€‚åº”æ§åˆ¶ï¼Œå¯ä»¥è®¾è®¡å‡ºæ—¢æ»¡è¶³æ€§èƒ½éœ€æ±‚åˆå…·å¤‡é²æ£’æ€§çš„éçº¿æ€§æ§åˆ¶ç³»ç»Ÿã€‚
