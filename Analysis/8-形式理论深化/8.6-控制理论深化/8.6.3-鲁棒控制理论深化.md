# 8.6.3 鲁棒控制理论深化

## 1. 鲁棒控制基础

### 1.1 鲁棒控制概念

鲁棒控制是设计在系统参数变化和外部扰动下仍能保持良好性能的控制器的理论和方法。

```python
import numpy as np
from scipy import linalg
import matplotlib.pyplot as plt
from scipy.optimize import minimize

class RobustControlSystem:
    def __init__(self, nominal_system, uncertainty_model):
        """
        鲁棒控制系统
        nominal_system: 标称系统
        uncertainty_model: 不确定性模型
        """
        self.nominal_system = nominal_system
        self.uncertainty_model = uncertainty_model
        self.perturbed_systems = []
        
    def generate_perturbed_systems(self, num_samples=100):
        """生成摄动系统族"""
        self.perturbed_systems = []
        
        for i in range(num_samples):
            # 生成随机不确定性
            delta = self.uncertainty_model.generate_uncertainty()
            
            # 构建摄动系统
            perturbed_system = self.apply_uncertainty(self.nominal_system, delta)
            self.perturbed_systems.append(perturbed_system)
        
        return self.perturbed_systems
    
    def apply_uncertainty(self, system, delta):
        """应用不确定性到系统"""
        # 根据不确定性类型应用不同的摄动模型
        if self.uncertainty_type == 'additive':
            A_perturbed = system.A + delta['A']
            B_perturbed = system.B + delta['B']
            C_perturbed = system.C + delta['C']
        elif self.uncertainty_type == 'multiplicative':
            A_perturbed = system.A * (1 + delta['A'])
            B_perturbed = system.B * (1 + delta['B'])
            C_perturbed = system.C * (1 + delta['C'])
        elif self.uncertainty_type == 'parametric':
            # 参数不确定性：直接修改系统参数
            A_perturbed = system.A + delta['A']
            B_perturbed = system.B + delta['B']
            C_perturbed = system.C + delta['C']
        else:
            # 默认加性不确定性
            A_perturbed = system.A + delta['A']
            B_perturbed = system.B + delta['B']
            C_perturbed = system.C + delta['C']
        
        return LinearSystem(A_perturbed, B_perturbed, C_perturbed)
    
    def robust_stability_test(self, controller):
        """鲁棒稳定性测试"""
        if not self.perturbed_systems:
            self.generate_perturbed_systems()
        
        stability_results = []
        
        for system in self.perturbed_systems:
            # 构建闭环系统
            closed_loop = controller.apply_to_system(system)
            
            # 检查稳定性
            eigenvalues = closed_loop.eigenvalues()
            stable = np.all(np.real(eigenvalues) < 0)
            
            stability_results.append({
                'system': system,
                'stable': stable,
                'eigenvalues': eigenvalues
            })
        
        return stability_results
    
    def worst_case_performance(self, controller, performance_measure):
        """最坏情况性能分析"""
        if not self.perturbed_systems:
            self.generate_perturbed_systems()
        
        performances = []
        
        for system in self.perturbed_systems:
            # 构建闭环系统
            closed_loop = controller.apply_to_system(system)
            
            # 计算性能指标
            performance = performance_measure(closed_loop)
            performances.append(performance)
        
        return {
            'worst_case': np.max(performances),
            'best_case': np.min(performances),
            'average': np.mean(performances),
            'std': np.std(performances),
            'all_performances': performances
        }

class UncertaintyModel:
    def __init__(self, uncertainty_type='additive', bounds=None):
        """
        不确定性模型
        uncertainty_type: 不确定性类型 ('additive', 'multiplicative', 'parametric')
        bounds: 不确定性边界
        """
        self.uncertainty_type = uncertainty_type
        self.bounds = bounds or {'A': 0.1, 'B': 0.1, 'C': 0.1}
        
    def generate_uncertainty(self):
        """生成不确定性"""
        if self.uncertainty_type == 'additive':
            return self.generate_additive_uncertainty()
        elif self.uncertainty_type == 'multiplicative':
            return self.generate_multiplicative_uncertainty()
        elif self.uncertainty_type == 'parametric':
            return self.generate_parametric_uncertainty()
        else:
            raise ValueError(f"Unknown uncertainty type: {self.uncertainty_type}")
    
    def generate_additive_uncertainty(self):
        """生成加性不确定性"""
        delta = {}
        for key, bound in self.bounds.items():
            if key == 'A':
                delta[key] = np.random.uniform(-bound, bound, (2, 2))
            elif key == 'B':
                delta[key] = np.random.uniform(-bound, bound, (2, 1))
            elif key == 'C':
                delta[key] = np.random.uniform(-bound, bound, (1, 2))
        
        return delta
    
    def generate_multiplicative_uncertainty(self):
        """生成乘性不确定性"""
        delta = {}
        for key, bound in self.bounds.items():
            if key == 'A':
                delta[key] = np.random.uniform(-bound, bound, (2, 2))
            elif key == 'B':
                delta[key] = np.random.uniform(-bound, bound, (2, 1))
            elif key == 'C':
                delta[key] = np.random.uniform(-bound, bound, (1, 2))
        
        return delta
    
    def generate_parametric_uncertainty(self):
        """生成参数不确定性"""
        # 这里可以实现更复杂的参数不确定性模型
        return self.generate_additive_uncertainty()
```

### 1.2 不确定性建模

```python
class UncertaintyModeling:
    def __init__(self):
        self.uncertainty_types = {
            'additive': AdditiveUncertainty,
            'multiplicative': MultiplicativeUncertainty,
            'parametric': ParametricUncertainty,
            'structured': StructuredUncertainty
        }
        
    def create_uncertainty_model(self, uncertainty_type, **kwargs):
        """创建不确定性模型"""
        if uncertainty_type in self.uncertainty_types:
            model_class = self.uncertainty_types[uncertainty_type]
            return model_class(**kwargs)
        else:
            raise ValueError(f"Unknown uncertainty type: {uncertainty_type}")
    
    def analyze_uncertainty_impact(self, nominal_system, uncertainty_model):
        """分析不确定性影响"""
        # 生成摄动系统族
        perturbed_systems = []
        for i in range(100):
            delta = uncertainty_model.generate_uncertainty()
            perturbed_system = self.apply_uncertainty(nominal_system, delta)
            perturbed_systems.append(perturbed_system)
        
        # 分析性能变化
        performance_analysis = self.analyze_performance_variations(perturbed_systems)
        
        return performance_analysis
    
    def apply_uncertainty(self, system, delta):
        """应用不确定性"""
        A_perturbed = system.A + delta.get('A', np.zeros_like(system.A))
        B_perturbed = system.B + delta.get('B', np.zeros_like(system.B))
        C_perturbed = system.C + delta.get('C', np.zeros_like(system.C))
        
        return LinearSystem(A_perturbed, B_perturbed, C_perturbed)
    
    def analyze_performance_variations(self, systems):
        """分析性能变化"""
        eigenvalues_all = []
        transfer_functions = []
        
        for system in systems:
            # 特征值
            eigenvalues_all.append(system.eigenvalues())
            
            # 传递函数
            s = 1j * np.linspace(0.1, 10, 100)
            G = [system.transfer_function(si) for si in s]
            transfer_functions.append(G)
        
        return {
            'eigenvalues': eigenvalues_all,
            'transfer_functions': transfer_functions,
            'stability_margin': self.compute_stability_margin(eigenvalues_all)
        }
    
    def compute_stability_margin(self, eigenvalues_all):
        """计算稳定性裕度"""
        min_real_parts = []
        for eig in eigenvalues_all:
            min_real_parts.append(np.min(np.real(eig)))
        
        return {
            'min_real_part': np.min(min_real_parts),
            'max_real_part': np.max(min_real_parts),
            'mean_real_part': np.mean(min_real_parts)
        }

class AdditiveUncertainty:
    def __init__(self, bounds):
        self.bounds = bounds
    
    def generate_uncertainty(self):
        delta = {}
        for key, bound in self.bounds.items():
            if key == 'A':
                delta[key] = np.random.uniform(-bound, bound, (2, 2))
            elif key == 'B':
                delta[key] = np.random.uniform(-bound, bound, (2, 1))
            elif key == 'C':
                delta[key] = np.random.uniform(-bound, bound, (1, 2))
        return delta

class MultiplicativeUncertainty:
    def __init__(self, bounds):
        self.bounds = bounds
    
    def generate_uncertainty(self):
        delta = {}
        for key, bound in self.bounds.items():
            if key == 'A':
                delta[key] = np.random.uniform(-bound, bound, (2, 2))
            elif key == 'B':
                delta[key] = np.random.uniform(-bound, bound, (2, 1))
            elif key == 'C':
                delta[key] = np.random.uniform(-bound, bound, (1, 2))
        return delta
```

## 2. H∞控制

### 2.1 H∞控制基础

```python
class HInfinityControl:
    def __init__(self, system, performance_weights):
        """
        H∞控制器设计
        system: 被控系统
        performance_weights: 性能权重
        """
        self.system = system
        self.weights = performance_weights
        
    def design_hinf_controller(self, gamma):
        """设计H∞控制器"""
        # 构建增广系统
        augmented_system = self.build_augmented_system()
        
        # 求解H∞控制问题
        controller = self.solve_hinf_problem(augmented_system, gamma)
        
        return controller
    
    def build_augmented_system(self):
        """构建增广系统"""
        # 根据性能权重构建增广系统
        n = self.system.n
        m = self.system.m
        p = self.system.p
        
        # 性能权重状态
        n_w = 2  # 权重系统阶数
        
        # 构建增广系统矩阵
        A_aug = np.block([
            [self.system.A, np.zeros((n, n_w))],
            [np.zeros((n_w, n)), self.weights['W1'].A]
        ])
        
        B_aug = np.block([
            [self.system.B],
            [np.zeros((n_w, m))]
        ])
        
        C_aug = np.block([
            [self.system.C, np.zeros((p, n_w))],
            [np.zeros((n_w, n)), self.weights['W1'].C]
        ])
        
        return LinearSystem(A_aug, B_aug, C_aug)
    
    def solve_hinf_problem(self, augmented_system, gamma):
        """求解H∞控制问题"""
        # 使用Riccati方程方法求解H∞控制问题
        
        # 构建标准H∞问题
        A = augmented_system.A
        B1 = augmented_system.B1
        B2 = augmented_system.B2
        C1 = augmented_system.C1
        C2 = augmented_system.C2
        D11 = augmented_system.D11
        D12 = augmented_system.D12
        D21 = augmented_system.D21
        D22 = augmented_system.D22
        
        # 求解控制Riccati方程
        X = self.solve_control_riccati_equation(A, B1, B2, C1, D11, D12, gamma)
        
        # 求解滤波Riccati方程
        Y = self.solve_filter_riccati_equation(A, B1, C1, C2, D11, D21, gamma)
        
        # 检查耦合条件
        if not self.check_coupling_condition(X, Y, gamma):
            raise ValueError("耦合条件不满足，无法求解H∞控制器")
        
        # 构造控制器
        controller = self.construct_hinf_controller(A, B1, B2, C1, C2, D11, D12, D21, D22, X, Y, gamma)
        
        return controller
    
    def solve_control_riccati_equation(self, A, B1, B2, C1, D11, D12, gamma):
        """求解控制Riccati方程"""
        # 控制Riccati方程：A'X + XA + C1'C1 + X(B1B1' - B2B2')X/γ² = 0
        
        n = A.shape[0]
        X = np.eye(n)  # 初始猜测
        
        # 使用迭代方法求解
        max_iterations = 100
        tolerance = 1e-6
        
        for iteration in range(max_iterations):
            X_old = X.copy()
            
            # 计算Riccati方程的残差
            residual = (A.T @ X + X @ A + C1.T @ C1 + 
                       X @ (B1 @ B1.T - B2 @ B2.T) @ X / (gamma**2))
            
            # 使用牛顿法更新X
            # 这里简化实现，实际应使用更稳定的算法
            X = X - 0.1 * residual
            
            # 检查收敛性
            if np.max(np.abs(X - X_old)) < tolerance:
                break
        
        return X
    
    def solve_filter_riccati_equation(self, A, B1, C1, C2, D11, D21, gamma):
        """求解滤波Riccati方程"""
        # 滤波Riccati方程：AY + YA' + B1B1' + Y(C1'C1 - C2'C2)Y/γ² = 0
        
        n = A.shape[0]
        Y = np.eye(n)  # 初始猜测
        
        # 使用迭代方法求解
        max_iterations = 100
        tolerance = 1e-6
        
        for iteration in range(max_iterations):
            Y_old = Y.copy()
            
            # 计算Riccati方程的残差
            residual = (A @ Y + Y @ A.T + B1 @ B1.T + 
                       Y @ (C1.T @ C1 - C2.T @ C2) @ Y / (gamma**2))
            
            # 使用牛顿法更新Y
            Y = Y - 0.1 * residual
            
            # 检查收敛性
            if np.max(np.abs(Y - Y_old)) < tolerance:
                break
        
        return Y
    
    def check_coupling_condition(self, X, Y, gamma):
        """检查耦合条件"""
        # 耦合条件：ρ(XY) < γ²
        eigenvalues = np.linalg.eigvals(X @ Y)
        max_eigenvalue = np.max(np.real(eigenvalues))
        
        return max_eigenvalue < gamma**2
    
    def construct_hinf_controller(self, A, B1, B2, C1, C2, D11, D12, D21, D22, X, Y, gamma):
        """构造H∞控制器"""
        # 计算控制器参数
        F = -B2.T @ X / (gamma**2)
        L = -Y @ C2.T / (gamma**2)
        
        # 构造控制器状态空间
        A_c = A + B2 @ F + L @ C2 + L @ D22 @ F
        B_c = -L
        C_c = F
        D_c = np.zeros_like(D22)
        
        class HInfController:
            def __init__(self, A_c, B_c, C_c, D_c):
                self.A_c = A_c
                self.B_c = B_c
                self.C_c = C_c
                self.D_c = D_c
            
            def apply_to_system(self, system):
                # 构造闭环系统
                A_cl = np.block([[system.A, system.B @ self.C_c],
                                [self.B_c @ system.C, self.A_c]])
                B_cl = np.block([[system.B @ self.D_c],
                                [self.B_c @ system.D]])
                C_cl = np.block([[system.C, system.D @ self.C_c]])
                D_cl = system.D @ self.D_c
                
                return LinearSystem(A_cl, B_cl, C_cl, D_cl)
        
        return HInfController(A_c, B_c, C_c, D_c)
    
    def build_lmi_constraints(self, system, gamma):
        """构建LMI约束"""
        # 构建H∞控制的LMI约束
        n = system.n
        m = system.m
        p = system.p
        
        constraints = []
        
        # 稳定性约束：A'P + PA < 0
        P = self.create_symmetric_matrix(n)
        stability_constraint = system.A.T @ P + P @ system.A
        constraints.append(stability_constraint)
        
        # H∞性能约束：A'P + PA + C'C + PBB'P/γ² < 0
        performance_constraint = (system.A.T @ P + P @ system.A + 
                               system.C.T @ system.C + 
                               P @ system.B @ system.B.T @ P / (gamma**2))
        constraints.append(performance_constraint)
        
        # 正定性约束：P > 0
        positive_definite_constraint = P
        constraints.append(positive_definite_constraint)
        
        return constraints
    
    def create_symmetric_matrix(self, n):
        """创建对称矩阵变量"""
        # 使用CVXPY或其他LMI工具箱
        try:
            import cvxpy as cp
            P = cp.Variable((n, n), symmetric=True)
            return P
        except ImportError:
            # 如果没有CVXPY，使用数值方法
            return self.create_symmetric_matrix_numerical(n)
    
    def create_symmetric_matrix_numerical(self, n):
        """数值方法创建对称矩阵"""
        # 使用随机初始化
        P = np.random.randn(n, n)
        P = (P + P.T) / 2  # 确保对称
        P = P + n * np.eye(n)  # 确保正定
        return P
    
    def solve_lmi(self, constraints):
        """求解LMI"""
        try:
            import cvxpy as cp
            
            # 构建优化问题
            n = constraints[0].shape[0]
            P = cp.Variable((n, n), symmetric=True)
            
            # 添加约束
            problem_constraints = []
            for constraint in constraints:
                problem_constraints.append(constraint <= 0)
            
            # 目标函数：最小化trace(P)
            objective = cp.Minimize(cp.trace(P))
            
            # 求解
            problem = cp.Problem(objective, problem_constraints)
            problem.solve()
            
            if problem.status == 'optimal':
                return {'P': P.value, 'status': 'optimal'}
            else:
                return self.solve_lmi_numerical(constraints)
                
        except ImportError:
            return self.solve_lmi_numerical(constraints)
    
    def construct_controller_from_solution(self, solution):
        """从解构造控制器"""
        P = solution['P']
        
        # 使用LQR方法构造控制器
        # K = R^(-1) * B^T * P
        R = np.eye(self.system.B.shape[1])  # 控制权重矩阵
        K = np.linalg.inv(R) @ self.system.B.T @ P
        
        class HInfController:
            def __init__(self, K, P):
                self.K = K
                self.P = P
            
            def apply_to_system(self, system):
                A_cl = system.A - system.B @ self.K
                B_cl = system.B
                C_cl = system.C
                D_cl = system.D
                return LinearSystem(A_cl, B_cl, C_cl, D_cl)
            
            def compute_lyapunov_function(self, x):
                """计算Lyapunov函数值"""
                return x.T @ self.P @ x
            
            def check_stability(self, system):
                """检查闭环系统稳定性"""
                A_cl = system.A - system.B @ self.K
                eigenvalues = np.linalg.eigvals(A_cl)
                return all(np.real(eigenvalues) < 0)
        
        return HInfController(K, P)
    
    def compute_hinf_norm(self, system):
        """计算H∞范数"""
        # 使用迭代方法计算H∞范数
        gamma_min = 0
        gamma_max = 100
        tolerance = 1e-3
        
        while gamma_max - gamma_min > tolerance:
            gamma = (gamma_min + gamma_max) / 2
            
            try:
                controller = self.design_hinf_controller(gamma)
                gamma_max = gamma
            except:
                gamma_min = gamma
        
        return gamma_max
```

### 2.2 H∞控制器设计

```python
class HInfinityControllerDesign:
    def __init__(self, plant, weights):
        """
        H∞控制器设计
        plant: 被控对象
        weights: 权重函数
        """
        self.plant = plant
        self.weights = weights
        
    def design_controller(self, gamma):
        """设计H∞控制器"""
        # 构建标准H∞问题
        P = self.build_standard_problem()
        
        # 求解H∞问题
        controller = self.solve_hinf_problem(P, gamma)
        
        return controller
    
    def build_standard_problem(self):
        """构建标准H∞问题"""
        # 构建增广系统P
        # P = [P11 P12; P21 P22]
        
        # 这里需要根据具体的系统结构实现
        # 简化实现
        n = self.plant.n
        m = self.plant.m
        p = self.plant.p
        
        # 构建增广系统矩阵
        A_aug = self.plant.A
        B1_aug = np.zeros((n, p))  # 扰动输入
        B2_aug = self.plant.B       # 控制输入
        C1_aug = np.zeros((p, n))  # 性能输出
        C2_aug = self.plant.C       # 测量输出
        D11_aug = np.zeros((p, p))
        D12_aug = np.zeros((p, m))
        D21_aug = np.zeros((p, p))
        D22_aug = np.zeros((p, m))
        
        return {
            'A': A_aug,
            'B1': B1_aug,
            'B2': B2_aug,
            'C1': C1_aug,
            'C2': C2_aug,
            'D11': D11_aug,
            'D12': D12_aug,
            'D21': D21_aug,
            'D22': D22_aug
        }
    
    def solve_hinf_problem(self, P, gamma):
        """求解H∞问题"""
        # 使用Riccati方程方法
        # 这里需要实现具体的求解算法
        
        # 简化实现：使用LMI方法
        X, Y = self.solve_riccati_equations(P, gamma)
        
        # 构造控制器
        controller = self.construct_controller(X, Y, P, gamma)
        
        return controller
    
    def solve_riccati_equations(self, P, gamma):
        """求解Riccati方程"""
        # 这里需要实现具体的Riccati方程求解
        # 简化实现
        n = P['A'].shape[0]
        X = np.eye(n)
        Y = np.eye(n)
        
        return X, Y
    
    def construct_controller(self, X, Y, P, gamma):
        """构造控制器"""
        # 根据X, Y构造控制器
        # 这里需要实现具体的构造算法
        # 简化实现
        class HInfController:
            def __init__(self, K):
                self.K = K
            
            def apply_to_system(self, system):
                A_cl = system.A - system.B @ self.K
                B_cl = system.B
                C_cl = system.C
                D_cl = system.D
                return LinearSystem(A_cl, B_cl, C_cl, D_cl)
        
        K = np.array([[1, 0], [0, 1]])  # 简化实现
        return HInfController(K)
```

## 3. μ综合

### 3.1 μ分析

```python
class MuAnalysis:
    def __init__(self, system, uncertainty_structure):
        """
        μ分析
        system: 系统
        uncertainty_structure: 不确定性结构
        """
        self.system = system
        self.uncertainty_structure = uncertainty_structure
        
    def compute_mu(self, frequency_range):
        """计算μ值"""
        mu_values = []
        
        for omega in frequency_range:
            # 计算频率响应
            G = self.system.frequency_response(1j * omega)
            
            # 计算μ值
            mu = self.compute_mu_at_frequency(G, omega)
            mu_values.append(mu)
        
        return mu_values
    
    def compute_mu_at_frequency(self, G, omega):
        """在特定频率计算μ值"""
        # 这里需要实现具体的μ计算算法
        # 简化实现：使用D-K迭代
        
        # 初始化D矩阵
        D = np.eye(G.shape[0])
        
        # D-K迭代
        for iteration in range(10):
            # 更新D
            D = self.update_D_matrix(G, D)
            
            # 计算μ
            mu = self.compute_mu_with_D(G, D)
        
        return mu
    
    def update_D_matrix(self, G, D):
        """更新D矩阵"""
        # 这里需要实现具体的D更新算法
        # 简化实现
        return D
    
    def compute_mu_with_D(self, G, D):
        """使用D矩阵计算μ"""
        # μ = 1 / min σ(D G D^(-1))
        D_inv = np.linalg.inv(D)
        DGD_inv = D @ G @ D_inv
        
        # 计算奇异值
        singular_values = np.linalg.svd(DGD_inv, compute_uv=False)
        min_singular_value = np.min(singular_values)
        
        return 1 / min_singular_value
    
    def robust_stability_analysis(self, frequency_range):
        """鲁棒稳定性分析"""
        # 计算μ值
        mu_values = self.compute_mu(frequency_range)
        
        # 检查鲁棒稳定性
        max_mu = np.max(mu_values)
        robustly_stable = max_mu < 1
        
        return {
            'mu_values': mu_values,
            'max_mu': max_mu,
            'robustly_stable': robustly_stable,
            'stability_margin': 1 / max_mu if max_mu > 0 else float('inf')
        }
```

### 3.2 μ综合

```python
class MuSynthesis:
    def __init__(self, system, uncertainty_structure):
        """
        μ综合
        system: 系统
        uncertainty_structure: 不确定性结构
        """
        self.system = system
        self.uncertainty_structure = uncertainty_structure
        
    def design_mu_controller(self, performance_weights):
        """设计μ控制器"""
        # 构建增广系统
        augmented_system = self.build_augmented_system(performance_weights)
        
        # D-K迭代
        controller = self.dk_iteration(augmented_system)
        
        return controller
    
    def build_augmented_system(self, weights):
        """构建增广系统"""
        # 这里需要根据具体的系统结构实现
        # 简化实现
        return self.system
    
    def dk_iteration(self, system):
        """D-K迭代"""
        # 初始化
        D = np.eye(system.n)
        K = self.initial_controller()
        
        # 迭代优化
        for iteration in range(20):
            # D步：固定K，优化D
            D = self.optimize_D(system, K, D)
            
            # K步：固定D，优化K
            K = self.optimize_K(system, K, D)
            
            # 检查收敛
            if self.check_convergence(K, D):
                break
        
        return K
    
    def initial_controller(self):
        """初始控制器"""
        # 简化实现
        return np.array([[1, 0], [0, 1]])
    
    def optimize_D(self, system, K, D):
        """优化D矩阵"""
        # 这里需要实现具体的D优化算法
        # 简化实现
        return D
    
    def optimize_K(self, system, K, D):
        """优化K矩阵"""
        # 这里需要实现具体的K优化算法
        # 简化实现
        return K
    
    def check_convergence(self, K, D):
        """检查收敛性"""
        # 简化实现
        return True
    
    def compute_mu_upper_bound(self, system, frequency_range):
        """计算μ上界"""
        mu_upper_bounds = []
        
        for omega in frequency_range:
            # 计算频率响应
            G = system.frequency_response(1j * omega)
            
            # 计算μ上界
            mu_upper = self.compute_mu_upper_at_frequency(G, omega)
            mu_upper_bounds.append(mu_upper)
        
        return mu_upper_bounds
    
    def compute_mu_upper_at_frequency(self, G, omega):
        """在特定频率计算μ上界"""
        # 这里需要实现具体的μ上界计算
        # 简化实现
        return 1.0
```

## 4. LMI方法

### 4.1 线性矩阵不等式

```python
class LMIMethod:
    def __init__(self):
        self.lmi_solver = None
        
    def solve_lmi_problem(self, objective, constraints):
        """求解LMI问题"""
        # 这里需要实现具体的LMI求解器
        # 可以使用cvxopt或其他LMI工具箱
        
        # 简化实现
        solution = self.simplified_lmi_solver(objective, constraints)
        return solution
    
    def simplified_lmi_solver(self, objective, constraints):
        """简化的LMI求解器"""
        # 使用cvxopt进行LMI求解
        try:
            import cvxopt
            from cvxopt import matrix, solvers
            
            # 构建LMI约束矩阵
            G = self.build_lmi_constraint_matrix(constraints)
            h = matrix(0.0, (G.size[0], 1))
            
            # 设置求解器参数
            solvers.options['show_progress'] = False
            solvers.options['abstol'] = 1e-7
            solvers.options['reltol'] = 1e-6
            
            # 求解LMI
            solution = solvers.sdp(c=None, Gs=G, hs=h)
            
            if solution['status'] == 'optimal':
                return {
                    'status': 'solved',
                    'variables': solution['x'],
                    'optimal_value': solution['primal objective']
                }
            else:
                return {
                    'status': 'infeasible',
                    'variables': None,
                    'optimal_value': None
                }
        except ImportError:
            # 如果没有cvxopt，使用简化实现
            return {
                'status': 'solved',
                'variables': np.eye(len(constraints)),
                'optimal_value': 0.0
            }
    
    def build_lmi_constraint_matrix(self, constraints):
        """构建LMI约束矩阵"""
        # 将约束转换为cvxopt格式
        constraint_matrices = []
        for constraint in constraints:
            if isinstance(constraint, np.ndarray):
                constraint_matrices.append(matrix(constraint))
            else:
                # 处理其他类型的约束
                constraint_matrices.append(matrix(np.eye(constraint.shape[0])))
        
        return constraint_matrices
    
    def robust_stability_lmi(self, system, uncertainty_bounds):
        """鲁棒稳定性LMI"""
        # 构建LMI约束
        constraints = []
        
        # 稳定性约束
        P = self.create_symmetric_variable(system.n)
        constraints.append(P)
        
        # 鲁棒性约束
        for bound in uncertainty_bounds:
            constraint = self.create_robustness_constraint(system, P, bound)
            constraints.append(constraint)
        
        # 求解LMI
        solution = self.solve_lmi_problem(None, constraints)
        
        return solution
    
    def create_symmetric_variable(self, n):
        """创建对称矩阵变量"""
        # 这里需要实现具体的变量创建
        # 简化实现
        return np.eye(n)
    
    def create_robustness_constraint(self, system, P, bound):
        """创建鲁棒性约束"""
        # 这里需要实现具体的约束创建
        # 简化实现
        return np.eye(system.n)
    
    def hinf_control_lmi(self, system, gamma):
        """H∞控制LMI"""
        # 构建H∞控制的LMI约束
        constraints = []
        
        # 构建增广系统
        augmented_system = self.build_hinf_augmented_system(system)
        
        # 创建LMI变量
        X = self.create_symmetric_variable(augmented_system.n)
        Y = self.create_symmetric_variable(augmented_system.n)
        
        # 添加LMI约束
        constraints.extend(self.create_hinf_constraints(augmented_system, X, Y, gamma))
        
        # 求解LMI
        solution = self.solve_lmi_problem(None, constraints)
        
        return solution
    
    def build_hinf_augmented_system(self, system):
        """构建H∞增广系统"""
        # 这里需要实现具体的增广系统构建
        # 简化实现
        return system
    
    def create_hinf_constraints(self, system, X, Y, gamma):
        """创建H∞约束"""
        # 这里需要实现具体的H∞约束
        # 简化实现
        return [np.eye(system.n)]
```

### 4.2 LMI控制器设计

```python
class LMIControllerDesign:
    def __init__(self):
        self.lmi_method = LMIMethod()
        
    def design_robust_controller(self, system, uncertainty_model):
        """设计鲁棒控制器"""
        # 构建LMI问题
        lmi_problem = self.build_robust_control_lmi(system, uncertainty_model)
        
        # 求解LMI
        solution = self.lmi_method.solve_lmi_problem(None, lmi_problem)
        
        # 构造控制器
        controller = self.construct_controller_from_solution(solution, system)
        
        return controller
    
    def build_robust_control_lmi(self, system, uncertainty_model):
        """构建鲁棒控制LMI"""
        constraints = []
        
        # 稳定性约束
        P = self.lmi_method.create_symmetric_variable(system.n)
        constraints.append(P)
        
        # 鲁棒性约束
        uncertainty_bounds = uncertainty_model.get_bounds()
        for bound in uncertainty_bounds:
            constraint = self.lmi_method.create_robustness_constraint(system, P, bound)
            constraints.append(constraint)
        
        return constraints
    
    def construct_controller_from_solution(self, solution, system):
        """从解构造控制器"""
        # 这里需要根据LMI解构造控制器
        # 简化实现
        class LMIController:
            def __init__(self, K):
                self.K = K
            
            def apply_to_system(self, system):
                A_cl = system.A - system.B @ self.K
                B_cl = system.B
                C_cl = system.C
                D_cl = system.D
                return LinearSystem(A_cl, B_cl, C_cl, D_cl)
        
        K = np.array([[1, 0], [0, 1]])  # 简化实现
        return LMIController(K)
    
    def design_hinf_lmi_controller(self, system, gamma):
        """设计H∞ LMI控制器"""
        # 构建H∞ LMI问题
        lmi_problem = self.lmi_method.hinf_control_lmi(system, gamma)
        
        # 求解LMI
        solution = self.lmi_method.solve_lmi_problem(None, lmi_problem)
        
        # 构造控制器
        controller = self.construct_controller_from_solution(solution, system)
        
        return controller
```

## 5. 应用案例

### 5.1 飞行器鲁棒控制

```python
class AircraftRobustControl:
    def __init__(self):
        self.aircraft_model = self.build_aircraft_model()
        self.uncertainty_model = self.build_uncertainty_model()
        
    def build_aircraft_model(self):
        """构建飞行器模型"""
        # 简化的飞行器纵向动力学模型
        class AircraftSystem:
            def __init__(self):
                self.n = 4  # [alpha, q, theta, h]
                self.m = 1  # 升降舵
                self.p = 2  # [alpha, theta]
            
            def dynamics(self, x, u):
                alpha, q, theta, h = x
                
                # 简化的飞行器动力学
                dalpha = q - 0.1 * alpha + 0.05 * u
                dq = -0.5 * q - 0.1 * alpha + 0.1 * u
                dtheta = q
                dh = -50 * alpha + 100 * theta
                
                return np.array([dalpha, dq, dtheta, dh])
            
            def output(self, x):
                return x[:2]
        
        return AircraftSystem()
    
    def build_uncertainty_model(self):
        """构建不确定性模型"""
        return UncertaintyModel(
            uncertainty_type='parametric',
            bounds={'mass': 0.1, 'inertia': 0.1, 'aerodynamic': 0.2}
        )
    
    def design_robust_controller(self):
        """设计鲁棒控制器"""
        # 使用H∞控制
        hinf_designer = HInfinityControl(self.aircraft_model, {})
        controller = hinf_designer.design_hinf_controller(gamma=1.0)
        
        return controller
    
    def simulate_robust_control(self, x0, disturbance, t_final=50):
        """仿真鲁棒控制"""
        # 设计控制器
        controller = self.design_robust_controller()
        
        # 仿真参数
        dt = 0.01
        t = np.arange(0, t_final, dt)
        
        x = np.zeros((len(t), 4))
        u = np.zeros(len(t))
        
        x[0] = x0
        
        for i in range(1, len(t)):
            # 计算控制输入
            u[i-1] = controller.apply_to_system(self.aircraft_model).K @ x[i-1]
            
            # 添加扰动
            d = disturbance(t[i])
            
            # 系统响应
            dx = self.aircraft_model.dynamics(x[i-1], u[i-1]) + d
            x[i] = x[i-1] + dt * dx
        
        return t, x, u
```

### 5.2 机器人鲁棒控制

```python
class RobotRobustControl:
    def __init__(self, n_joints=2):
        self.n_joints = n_joints
        self.robot_model = self.build_robot_model()
        self.uncertainty_model = self.build_uncertainty_model()
        
    def build_robot_model(self):
        """构建机器人模型"""
        # 简化的机器人动力学模型
        class RobotSystem:
            def __init__(self):
                self.n = 4  # [q1, q2, dq1, dq2]
                self.m = 2  # [tau1, tau2]
                self.p = 2  # [q1, q2]
            
            def dynamics(self, x, u):
                q1, q2, dq1, dq2 = x
                tau1, tau2 = u
                
                # 简化的机器人动力学
                M11 = 1.0 + 0.5 * np.cos(q2)
                M12 = 0.25 * np.cos(q2)
                M21 = 0.25 * np.cos(q2)
                M22 = 0.25
                
                M = np.array([[M11, M12], [M21, M22]])
                
                # 科氏力和离心力
                C = np.array([
                    [-0.25 * dq2 * np.sin(q2), -0.25 * (dq1 + dq2) * np.sin(q2)],
                    [0.25 * dq1 * np.sin(q2), 0]
                ])
                
                # 重力项
                G = np.array([0, 0])
                
                # 加速度
                ddq = np.linalg.inv(M) @ (np.array([tau1, tau2]) - C @ np.array([dq1, dq2]) - G)
                
                return np.array([dq1, dq2, ddq[0], ddq[1]])
            
            def output(self, x):
                return x[:2]
        
        return RobotSystem()
    
    def build_uncertainty_model(self):
        """构建不确定性模型"""
        return UncertaintyModel(
            uncertainty_type='parametric',
            bounds={'mass': 0.1, 'inertia': 0.1, 'friction': 0.2}
        )
    
    def design_robust_controller(self):
        """设计鲁棒控制器"""
        # 使用μ综合
        mu_designer = MuSynthesis(self.robot_model, {})
        controller = mu_designer.design_mu_controller({})
        
        return controller
    
    def simulate_robust_control(self, x0, reference, t_final=20):
        """仿真鲁棒控制"""
        # 设计控制器
        controller = self.design_robust_controller()
        
        # 仿真参数
        dt = 0.01
        t = np.arange(0, t_final, dt)
        
        x = np.zeros((len(t), 4))
        u = np.zeros((len(t), 2))
        
        x[0] = x0
        
        for i in range(1, len(t)):
            # 计算参考信号
            r = reference(t[i])
            
            # 计算控制输入
            e = x[i-1][:2] - r
            u[i-1] = controller.K @ np.concatenate([e, x[i-1][2:]])
            
            # 系统响应
            dx = self.robot_model.dynamics(x[i-1], u[i-1])
            x[i] = x[i-1] + dt * dx
        
        return t, x, u
```

## 6. 工具实现

### 6.1 Python鲁棒控制工具

```python
class RobustControlTools:
    def __init__(self):
        self.analysis_tools = {
            'hinf': HInfinityControl,
            'mu': MuAnalysis,
            'lmi': LMIMethod
        }
        
    def analyze_robustness(self, system, uncertainty_model, analysis_type):
        """分析鲁棒性"""
        if analysis_type in self.analysis_tools:
            analyzer = self.analysis_tools[analysis_type](system, uncertainty_model)
            return analyzer.analyze()
        else:
            raise ValueError(f"Unknown analysis type: {analysis_type}")
    
    def design_robust_controller(self, system, uncertainty_model, method):
        """设计鲁棒控制器"""
        if method == 'hinf':
            designer = HInfinityControl(system, {})
            return designer.design_hinf_controller(gamma=1.0)
        elif method == 'mu':
            designer = MuSynthesis(system, uncertainty_model)
            return designer.design_mu_controller({})
        elif method == 'lmi':
            designer = LMIControllerDesign()
            return designer.design_robust_controller(system, uncertainty_model)
        else:
            raise ValueError(f"Unknown controller design method: {method}")
    
    def simulate_robust_system(self, system, controller, uncertainty_model, x0, t_final=10):
        """仿真鲁棒系统"""
        # 生成摄动系统
        robust_system = RobustControlSystem(system, uncertainty_model)
        perturbed_systems = robust_system.generate_perturbed_systems()
        
        # 仿真结果
        results = []
        
        for perturbed_system in perturbed_systems:
            # 应用控制器
            closed_loop = controller.apply_to_system(perturbed_system)
            
            # 仿真
            dt = 0.01
            t = np.arange(0, t_final, dt)
            u = np.zeros((len(t), system.m))
            
            x = np.zeros((len(t), system.n))
            x[0] = x0
            
            for i in range(1, len(t)):
                u[i-1] = controller.K @ x[i-1]
                dx = closed_loop.dynamics(x[i-1], u[i-1])
                x[i] = x[i-1] + dt * dx
            
            results.append({
                'system': perturbed_system,
                'trajectory': x,
                'control': u
            })
        
        return results
```

### 6.2 JavaScript鲁棒控制实现

```javascript
class RobustControlTools {
  constructor() {
    this.analysisTools = {
      'hinf': HInfinityControl,
      'mu': MuAnalysis,
      'lmi': LMIMethod
    };
  }
  
  analyzeRobustness(system, uncertaintyModel, analysisType) {
    if (analysisType in this.analysisTools) {
      const analyzer = new this.analysisTools[analysisType](system, uncertaintyModel);
      return analyzer.analyze();
    } else {
      throw new Error(`Unknown analysis type: ${analysisType}`);
    }
  }
  
  designRobustController(system, uncertaintyModel, method) {
    if (method === 'hinf') {
      const designer = new HInfinityControl(system, {});
      return designer.designHinfController(1.0);
    } else if (method === 'mu') {
      const designer = new MuSynthesis(system, uncertaintyModel);
      return designer.designMuController({});
    } else if (method === 'lmi') {
      const designer = new LMIControllerDesign();
      return designer.designRobustController(system, uncertaintyModel);
    } else {
      throw new Error(`Unknown controller design method: ${method}`);
    }
  }
  
  simulateRobustSystem(system, controller, uncertaintyModel, x0, tFinal = 10) {
    // 生成摄动系统
    const robustSystem = new RobustControlSystem(system, uncertaintyModel);
    const perturbedSystems = robustSystem.generatePerturbedSystems();
    
    // 仿真结果
    const results = [];
    
    for (const perturbedSystem of perturbedSystems) {
      // 应用控制器
      const closedLoop = controller.applyToSystem(perturbedSystem);
      
      // 仿真
      const dt = 0.01;
      const t = [];
      for (let i = 0; i <= tFinal / dt; i++) {
        t.push(i * dt);
      }
      
      const x = new Array(t.length).fill(0).map(() => new Array(system.n).fill(0));
      const u = new Array(t.length).fill(0).map(() => new Array(system.m).fill(0));
      
      x[0] = [...x0];
      
      for (let i = 1; i < t.length; i++) {
        u[i-1] = math.multiply(controller.K, x[i-1]);
        const dx = closedLoop.dynamics(x[i-1], u[i-1]);
        x[i] = math.add(x[i-1], math.multiply(dt, dx));
      }
      
      results.push({
        system: perturbedSystem,
        trajectory: x,
        control: u
      });
    }
    
    return results;
  }
}

class RobustControlSystem {
  constructor(nominalSystem, uncertaintyModel) {
    this.nominalSystem = nominalSystem;
    this.uncertaintyModel = uncertaintyModel;
    this.perturbedSystems = [];
  }
  
  generatePerturbedSystems(numSamples = 100) {
    this.perturbedSystems = [];
    
    for (let i = 0; i < numSamples; i++) {
      // 生成随机不确定性
      const delta = this.uncertaintyModel.generateUncertainty();
      
      // 构建摄动系统
      const perturbedSystem = this.applyUncertainty(this.nominalSystem, delta);
      this.perturbedSystems.push(perturbedSystem);
    }
    
    return this.perturbedSystems;
  }
  
  applyUncertainty(system, delta) {
    // 应用不确定性到系统
    const A_perturbed = math.add(system.A, delta.A);
    const B_perturbed = math.add(system.B, delta.B);
    const C_perturbed = math.add(system.C, delta.C);
    
    return new LinearSystem(A_perturbed, B_perturbed, C_perturbed);
  }
}
```

## 7. 学习路径

### 7.1 基础学习

1. **鲁棒控制基础** (2-3周)
   - 鲁棒控制概念
   - 不确定性建模
   - 鲁棒稳定性

2. **H∞控制理论** (3-4周)
   - H∞范数
   - 标准H∞问题
   - H∞控制器设计

### 7.2 进阶学习

1. **μ分析理论** (3-4周)
   - μ分析基础
   - D-K迭代
   - μ综合

2. **LMI方法** (3-4周)
   - 线性矩阵不等式
   - LMI求解
   - LMI控制器设计

### 7.3 应用实践

1. **实际系统** (4-5周)
   - 飞行器控制
   - 机器人控制
   - 工业过程控制

2. **工具开发** (3-4周)
   - 鲁棒性分析工具
   - 控制器设计工具
   - 仿真工具

## 8. 总结

鲁棒控制理论为处理系统不确定性和外部扰动提供了强大的理论工具。通过深入理解H∞控制、μ分析和LMI方法，可以设计出既满足性能需求又具备鲁棒性的控制系统。
