# 8.2.1-æœ‰é™è‡ªåŠ¨æœºæ·±åŒ–

## ğŸ“– æ¦‚è¿°

æœ‰é™è‡ªåŠ¨æœºæ˜¯è®¡ç®—ç†è®ºçš„åŸºç¡€æ¨¡å‹ï¼Œæè¿°äº†å…·æœ‰æœ‰é™çŠ¶æ€å’Œæœ‰é™è¾“å…¥å­—æ¯è¡¨çš„è®¡ç®—è®¾å¤‡ã€‚
æœ‰é™è‡ªåŠ¨æœºæ·±åŒ–ç ”ç©¶æ¶µç›–äº†ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœºï¼ˆDFAï¼‰ã€éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœºï¼ˆNFAï¼‰ã€Îµ-éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœºï¼ˆÎµ-NFAï¼‰ä»¥åŠå®ƒä»¬ä¹‹é—´çš„å…³ç³»å’Œä¼˜åŒ–æŠ€æœ¯ã€‚

### æ ¸å¿ƒæ¦‚å¿µ

- **çŠ¶æ€æœº**ï¼šæœ‰é™çŠ¶æ€é›†åˆå’ŒçŠ¶æ€è½¬æ¢
- **ç¡®å®šæ€§**ï¼šæ¯ä¸ªçŠ¶æ€å’Œè¾“å…¥ç¬¦å·å¯¹åº”å”¯ä¸€çš„ä¸‹ä¸€ä¸ªçŠ¶æ€
- **éç¡®å®šæ€§**ï¼šå…è®¸å¤šä¸ªå¯èƒ½çš„ä¸‹ä¸€çŠ¶æ€
- **ç­‰ä»·æ€§**ï¼šä¸åŒè‡ªåŠ¨æœºæ¨¡å‹çš„è¯­è¨€è¯†åˆ«èƒ½åŠ›

## ğŸ—ï¸ æ ¸å¿ƒç†è®ºæ¡†æ¶

### æœ‰é™è‡ªåŠ¨æœºåŸºç¡€

```haskell
-- æœ‰é™è‡ªåŠ¨æœºç±»å‹å®šä¹‰
data FiniteAutomaton q a where
  DFA :: Set q -> Set a -> q -> (q -> a -> q) -> Set q -> FiniteAutomaton q a
  NFA :: Set q -> Set a -> q -> (q -> a -> Set q) -> Set q -> FiniteAutomaton q a
  EpsilonNFA :: Set q -> Set a -> q -> (q -> Maybe a -> Set q) -> Set q -> FiniteAutomaton q a

-- è‡ªåŠ¨æœºè¿è¡Œå‡½æ•°
runAutomaton :: FiniteAutomaton q a -> [a] -> Bool
runAutomaton (DFA states alphabet start delta finals) input = 
    -- è¿è¡ŒDFA
    let finalState = foldl delta start input
    in finalState `elem` finals
```

### ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœºï¼ˆDFAï¼‰

#### åŸºæœ¬å®šä¹‰

```rust
// Rustä¸­çš„DFAå®ç°
use std::collections::HashMap;

struct DFA {
    states: Vec<String>,
    alphabet: Vec<char>,
    start_state: String,
    transitions: HashMap<(String, char), String>,
    final_states: Vec<String>,
}

impl DFA {
    fn new() -> Self {
        DFA {
            states: Vec::new(),
            alphabet: Vec::new(),
            start_state: String::new(),
            transitions: HashMap::new(),
            final_states: Vec::new(),
        }
    }
    
    fn add_state(&mut self, state: String) {
        self.states.push(state);
    }
    
    fn add_transition(&mut self, from: String, input: char, to: String) {
        self.transitions.insert((from, input), to);
    }
    
    fn run(&self, input: &str) -> bool {
        let mut current_state = self.start_state.clone();
        
        for c in input.chars() {
            if let Some(next_state) = self.transitions.get(&(current_state.clone(), c)) {
                current_state = next_state.clone();
            } else {
                return false; // æ— å®šä¹‰è½¬æ¢
            }
        }
        
        self.final_states.contains(&current_state)
    }
}
```

#### DFAæœ€å°åŒ–

```haskell
-- DFAæœ€å°åŒ–ç®—æ³•
minimizeDFA :: DFA -> DFA
minimizeDFA dfa = 
    let -- ç§»é™¤ä¸å¯è¾¾çŠ¶æ€
        reachable = findReachableStates dfa
        -- æ‰¾åˆ°ç­‰ä»·çŠ¶æ€
        equivalent = findEquivalentStates dfa
        -- åˆå¹¶ç­‰ä»·çŠ¶æ€
        minimized = mergeEquivalentStates dfa equivalent
    in minimized

-- æ‰¾åˆ°ç­‰ä»·çŠ¶æ€
findEquivalentStates :: DFA -> Set (Set State)
findEquivalentStates dfa = 
    -- ä½¿ç”¨åˆ†åŒºç»†åŒ–ç®—æ³•
    partitionRefinement dfa
```

### éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœºï¼ˆNFAï¼‰

#### åŸºæœ¬å®šä¹‰1

```rust
// Rustä¸­çš„NFAå®ç°
struct NFA {
    states: Vec<String>,
    alphabet: Vec<char>,
    start_state: String,
    transitions: HashMap<(String, char), Vec<String>>,
    final_states: Vec<String>,
}

impl NFA {
    fn new() -> Self {
        NFA {
            states: Vec::new(),
            alphabet: Vec::new(),
            start_state: String::new(),
            transitions: HashMap::new(),
            final_states: Vec::new(),
        }
    }
    
    fn add_transition(&mut self, from: String, input: char, to: Vec<String>) {
        self.transitions.insert((from, input), to);
    }
    
    fn run(&self, input: &str) -> bool {
        let mut current_states = vec![self.start_state.clone()];
        
        for c in input.chars() {
            let mut next_states = Vec::new();
            for state in &current_states {
                if let Some(transitions) = self.transitions.get(&(state.clone(), c)) {
                    next_states.extend(transitions.clone());
                }
            }
            current_states = next_states;
        }
        
        // æ£€æŸ¥æ˜¯å¦æœ‰æœ€ç»ˆçŠ¶æ€
        current_states.iter().any(|state| self.final_states.contains(state))
    }
}
```

#### NFAåˆ°DFAçš„è½¬æ¢

```haskell
-- å­é›†æ„é€ æ³•ï¼šNFAè½¬DFA
nfaToDFA :: NFA -> DFA
nfaToDFA nfa = 
    let -- è®¡ç®—Îµé—­åŒ…
        epsilonClosure = computeEpsilonClosure nfa
        -- æ„å»ºDFAçŠ¶æ€
        dfaStates = buildDFAStates nfa epsilonClosure
        -- æ„å»ºDFAè½¬æ¢
        dfaTransitions = buildDFATransitions nfa dfaStates
        -- æ„å»ºDFAæœ€ç»ˆçŠ¶æ€
        dfaFinals = buildDFAFinalStates nfa dfaStates
    in DFA dfaStates (alphabet nfa) (startState nfa) dfaTransitions dfaFinals

-- è®¡ç®—Îµé—­åŒ…
computeEpsilonClosure :: NFA -> State -> Set State
computeEpsilonClosure nfa state = 
    -- é€’å½’è®¡ç®—Îµé—­åŒ…
    let direct = epsilonTransitions nfa state
        indirect = concatMap (computeEpsilonClosure nfa) direct
    in state : (direct ++ indirect)
```

### Îµ-éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœºï¼ˆÎµ-NFAï¼‰

#### åŸºæœ¬å®šä¹‰2

```haskell
-- Îµ-NFAå®šä¹‰
data EpsilonNFA q a where
  EpsilonNFA :: Set q -> Set a -> q -> (q -> Maybe a -> Set q) -> Set q -> EpsilonNFA q a

-- Îµ-NFAè¿è¡Œ
runEpsilonNFA :: EpsilonNFA q a -> [a] -> Bool
runEpsilonNFA (EpsilonNFA states alphabet start delta finals) input = 
    let -- è®¡ç®—åˆå§‹Îµé—­åŒ…
        initialStates = epsilonClosure start
        -- è¿è¡Œè‡ªåŠ¨æœº
        finalStates = runWithEpsilonClosure delta initialStates input
    in any (`elem` finals) finalStates
```

## ğŸ”¬ é«˜çº§ç†è®ºå‘å±•

### è‡ªåŠ¨æœºä¼˜åŒ–

#### çŠ¶æ€æœ€å°åŒ–

```haskell
-- Hopcroftç®—æ³•ï¼šDFAæœ€å°åŒ–
hopcroftMinimization :: DFA -> DFA
hopcroftMinimization dfa = 
    let -- åˆå§‹åˆ†åŒºï¼šæœ€ç»ˆçŠ¶æ€å’Œéæœ€ç»ˆçŠ¶æ€
        initialPartition = partitionByFinalStates dfa
        -- è¿­ä»£ç»†åŒ–åˆ†åŒº
        refinedPartition = refinePartition dfa initialPartition
        -- æ„å»ºæœ€å°åŒ–DFA
        minimizedDFA = buildMinimizedDFA dfa refinedPartition
    in minimizedDFA

-- åˆ†åŒºç»†åŒ–
refinePartition :: DFA -> Partition -> Partition
refinePartition dfa partition = 
    -- ä½¿ç”¨Hopcroftç®—æ³•ç»†åŒ–åˆ†åŒº
    hopcroftRefinement dfa partition
```

#### è‡ªåŠ¨æœºç­‰ä»·æ€§

```haskell
-- è‡ªåŠ¨æœºç­‰ä»·æ€§æ£€æŸ¥
automataEquivalence :: FiniteAutomaton q a -> FiniteAutomaton q' a -> Bool
automataEquivalence fa1 fa2 = 
    let -- è½¬æ¢ä¸ºDFA
        dfa1 = toDFA fa1
        dfa2 = toDFA fa2
        -- æœ€å°åŒ–
        minDFA1 = minimizeDFA dfa1
        minDFA2 = minimizeDFA dfa2
        -- æ£€æŸ¥åŒæ„
    in areIsomorphic minDFA1 minDFA2
```

### é«˜çº§è‡ªåŠ¨æœºå˜ç§

#### æ¦‚ç‡æœ‰é™è‡ªåŠ¨æœº

```haskell
-- æ¦‚ç‡æœ‰é™è‡ªåŠ¨æœº
data ProbabilisticFA q a where
  ProbabilisticFA :: Set q -> Set a -> q -> (q -> a -> Map q Double) -> Set q -> ProbabilisticFA q a

-- æ¦‚ç‡è‡ªåŠ¨æœºè¿è¡Œ
runProbabilisticFA :: ProbabilisticFA q a -> [a] -> Double
runProbabilisticFA (ProbabilisticFA states alphabet start delta finals) input = 
    -- è®¡ç®—æ¥å—æ¦‚ç‡
    computeAcceptanceProbability delta start input finals
```

#### åŠ æƒæœ‰é™è‡ªåŠ¨æœº

```haskell
-- åŠ æƒæœ‰é™è‡ªåŠ¨æœº
data WeightedFA q a w where
  WeightedFA :: Set q -> Set a -> q -> (q -> a -> q -> w) -> Set q -> WeightedFA q a w

-- åŠ æƒè‡ªåŠ¨æœºè¿è¡Œ
runWeightedFA :: WeightedFA q a w -> [a] -> w
runWeightedFA (WeightedFA states alphabet start delta finals) input = 
    -- è®¡ç®—è·¯å¾„æƒé‡
    computePathWeight delta start input finals
```

## ğŸ¯ åº”ç”¨åœºæ™¯ä¸å®ä¾‹

### ç¼–è¯‘å™¨è®¾è®¡

#### è¯æ³•åˆ†æå™¨

```rust
// è¯æ³•åˆ†æå™¨ä¸­çš„æœ‰é™è‡ªåŠ¨æœº
struct LexicalAnalyzer {
    dfa: DFA,
    token_types: HashMap<String, TokenType>,
}

impl LexicalAnalyzer {
    fn new() -> Self {
        let mut analyzer = LexicalAnalyzer {
            dfa: DFA::new(),
            token_types: HashMap::new(),
        };
        
        // æ„å»ºè¯†åˆ«å„ç§tokençš„DFA
        analyzer.build_identifier_dfa();
        analyzer.build_number_dfa();
        analyzer.build_string_dfa();
        analyzer.build_operator_dfa();
        
        analyzer
    }
    
    fn tokenize(&self, input: &str) -> Vec<Token> {
        let mut tokens = Vec::new();
        let mut current_pos = 0;
        
        while current_pos < input.len() {
            let (token, new_pos) = self.recognize_token(&input[current_pos..]);
            tokens.push(token);
            current_pos = new_pos;
        }
        
        tokens
    }
    
    fn recognize_token(&self, input: &str) -> (Token, usize) {
        // ä½¿ç”¨DFAè¯†åˆ«token
        let mut current_state = self.dfa.start_state.clone();
        let mut recognized_length = 0;
        
        for (i, c) in input.chars().enumerate() {
            if let Some(next_state) = self.dfa.transitions.get(&(current_state.clone(), c)) {
                current_state = next_state.clone();
                recognized_length = i + 1;
            } else {
                break;
            }
        }
        
        let token_text = &input[..recognized_length];
        let token_type = self.token_types.get(token_text).unwrap_or(&TokenType::Unknown);
        
        (Token::new(token_type.clone(), token_text.to_string()), recognized_length)
    }
}
```

#### æ­£åˆ™è¡¨è¾¾å¼å¼•æ“

```haskell
-- æ­£åˆ™è¡¨è¾¾å¼åˆ°NFAçš„è½¬æ¢
regexToNFA :: Regex -> NFA
regexToNFA (Char c) = buildCharNFA c
regexToNFA (Concat r1 r2) = concatNFA (regexToNFA r1) (regexToNFA r2)
regexToNFA (Union r1 r2) = unionNFA (regexToNFA r1) (regexToNFA r2)
regexToNFA (Star r) = starNFA (regexToNFA r)

-- æ„å»ºå­—ç¬¦NFA
buildCharNFA :: Char -> NFA
buildCharNFA c = 
    NFA [0, 1] [c] 0 [(0, c, [1])] [1]

-- è¿æ¥NFA
concatNFA :: NFA -> NFA -> NFA
concatNFA nfa1 nfa2 = 
    -- è¿æ¥ä¸¤ä¸ªNFA
    let states1 = states nfa1
        states2 = states nfa2
        -- é‡å‘½åçŠ¶æ€
        renamedStates2 = map (+ length states1) states2
        -- è¿æ¥è½¬æ¢
        transitions = concatTransitions nfa1 nfa2
    in NFA (states1 ++ renamedStates2) (alphabet nfa1) (startState nfa1) transitions (finalStates nfa2)
```

### ç½‘ç»œåè®®

#### åè®®çŠ¶æ€æœº

```rust
// ç½‘ç»œåè®®çŠ¶æ€æœº
struct ProtocolStateMachine {
    current_state: ProtocolState,
    transitions: HashMap<(ProtocolState, ProtocolEvent), ProtocolState>,
    actions: HashMap<(ProtocolState, ProtocolEvent), Box<dyn Fn()>>,
}

impl ProtocolStateMachine {
    fn new() -> Self {
        let mut sm = ProtocolStateMachine {
            current_state: ProtocolState::Idle,
            transitions: HashMap::new(),
            actions: HashMap::new(),
        };
        
        // å®šä¹‰çŠ¶æ€è½¬æ¢
        sm.add_transition(ProtocolState::Idle, ProtocolEvent::Connect, ProtocolState::Connecting);
        sm.add_transition(ProtocolState::Connecting, ProtocolEvent::Connected, ProtocolState::Connected);
        sm.add_transition(ProtocolState::Connected, ProtocolEvent::Disconnect, ProtocolState::Idle);
        
        // å®šä¹‰åŠ¨ä½œ
        sm.add_action(ProtocolState::Connecting, ProtocolEvent::Connected, || {
            println!("Connection established");
        });
        
        sm
    }
    
    fn process_event(&mut self, event: ProtocolEvent) {
        if let Some(next_state) = self.transitions.get(&(self.current_state, event)) {
            // æ‰§è¡ŒåŠ¨ä½œ
            if let Some(action) = self.actions.get(&(self.current_state, event)) {
                action();
            }
            
            // è½¬æ¢çŠ¶æ€
            self.current_state = *next_state;
        }
    }
}
```

### ç¡¬ä»¶è®¾è®¡

#### æ•°å­—ç”µè·¯çŠ¶æ€æœº

```verilog
// Verilogä¸­çš„æœ‰é™çŠ¶æ€æœº
module fsm (
    input wire clk,
    input wire reset,
    input wire [1:0] input_signal,
    output reg [1:0] output_signal
);

    // çŠ¶æ€å®šä¹‰
    parameter IDLE = 2'b00;
    parameter STATE1 = 2'b01;
    parameter STATE2 = 2'b10;
    parameter FINAL = 2'b11;
    
    reg [1:0] current_state, next_state;
    
    // çŠ¶æ€è½¬æ¢é€»è¾‘
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            current_state <= IDLE;
        end else begin
            current_state <= next_state;
        end
    end
    
    // ä¸‹ä¸€çŠ¶æ€é€»è¾‘
    always @(*) begin
        case (current_state)
            IDLE: begin
                if (input_signal == 2'b01) begin
                    next_state = STATE1;
                end else begin
                    next_state = IDLE;
                end
            end
            STATE1: begin
                if (input_signal == 2'b10) begin
                    next_state = STATE2;
                end else begin
                    next_state = IDLE;
                end
            end
            STATE2: begin
                if (input_signal == 2'b11) begin
                    next_state = FINAL;
                end else begin
                    next_state = IDLE;
                end
            end
            FINAL: begin
                next_state = IDLE;
            end
        endcase
    end
    
    // è¾“å‡ºé€»è¾‘
    always @(*) begin
        case (current_state)
            IDLE: output_signal = 2'b00;
            STATE1: output_signal = 2'b01;
            STATE2: output_signal = 2'b10;
            FINAL: output_signal = 2'b11;
        endcase
    end

endmodule
```

## ğŸ”— ä¸å…¶ä»–ç†è®ºçš„äº¤å‰

### ä¸ç±»å‹ç†è®º

#### ç±»å‹çº§è‡ªåŠ¨æœº

```haskell
-- ç±»å‹çº§æœ‰é™è‡ªåŠ¨æœº
data TypeLevelFA (states :: [Symbol]) (alphabet :: [Symbol]) where
  TypeLevelFA :: Proxy states -> Proxy alphabet -> TypeLevelFA states alphabet

-- ç±»å‹çº§çŠ¶æ€è½¬æ¢
type family Transition (fa :: TypeLevelFA states alphabet) 
                      (state :: Symbol) 
                      (input :: Symbol) :: Symbol where
  Transition fa 'State1 'Input1 = 'State2
  Transition fa 'State2 'Input2 = 'State3
  -- ... æ›´å¤šè½¬æ¢è§„åˆ™

-- ç±»å‹çº§è¿è¡Œ
type family RunFA (fa :: TypeLevelFA states alphabet) 
                  (input :: [Symbol]) 
                  (start :: Symbol) :: Symbol where
  RunFA fa '[] start = start
  RunFA fa (input ': inputs) start = 
    RunFA fa inputs (Transition fa start input)
```

### ä¸Petriç½‘ç†è®º

#### è‡ªåŠ¨æœºåˆ°Petriç½‘çš„è½¬æ¢

```haskell
-- è‡ªåŠ¨æœºåˆ°Petriç½‘çš„è½¬æ¢
automatonToPetriNet :: FiniteAutomaton q a -> PetriNet
automatonToPetriNet (DFA states alphabet start delta finals) = 
    let -- çŠ¶æ€ä½œä¸ºåº“æ‰€
        places = map StateToPlace states
        -- è½¬æ¢ä½œä¸ºå˜è¿
        transitions = map TransitionToTransition (allTransitions delta)
        -- åˆå§‹æ ‡è®°
        initialMarking = [(StateToPlace start, 1)]
    in PetriNet places transitions initialMarking
```

### ä¸é‡å­è®¡ç®—

#### é‡å­æœ‰é™è‡ªåŠ¨æœº

```haskell
-- é‡å­æœ‰é™è‡ªåŠ¨æœº
data QuantumFA q a where
  QuantumFA :: Set q -> Set a -> q -> (q -> a -> QuantumState q) -> Set q -> QuantumFA q a

-- é‡å­è‡ªåŠ¨æœºè¿è¡Œ
runQuantumFA :: QuantumFA q a -> [a] -> Double
runQuantumFA (QuantumFA states alphabet start delta finals) input = 
    let -- åˆå§‹é‡å­çŠ¶æ€
        initialState = quantumState start
        -- è¿è¡Œé‡å­è‡ªåŠ¨æœº
        finalState = runQuantumAutomaton delta initialState input
        -- æµ‹é‡æœ€ç»ˆçŠ¶æ€
    in measureFinalState finalState finals
```

## ğŸš€ å‘å±•å‰æ²¿ä¸æŒ‘æˆ˜

### ç ”ç©¶æ–¹å‘

#### 1. è‡ªåŠ¨æœºä¼˜åŒ–ç®—æ³•

- **å¹¶è¡ŒåŒ–**ï¼šè‡ªåŠ¨æœºè¿è¡Œçš„å¹¶è¡ŒåŒ–å¤„ç†
- **ç¼“å­˜ä¼˜åŒ–**ï¼šè‡ªåŠ¨æœºçŠ¶æ€è½¬æ¢çš„ç¼“å­˜ç­–ç•¥
- **å†…å­˜ä¼˜åŒ–**ï¼šè‡ªåŠ¨æœºè¡¨ç¤ºçš„å†…å­˜ä¼˜åŒ–

#### 2. é«˜çº§è‡ªåŠ¨æœºæ¨¡å‹

- **æ¦‚ç‡è‡ªåŠ¨æœº**ï¼šå¸¦æ¦‚ç‡çš„æœ‰é™è‡ªåŠ¨æœº
- **åŠ æƒè‡ªåŠ¨æœº**ï¼šå¸¦æƒé‡çš„æœ‰é™è‡ªåŠ¨æœº
- **æ¨¡ç³Šè‡ªåŠ¨æœº**ï¼šæ¨¡ç³Šé€»è¾‘çš„æœ‰é™è‡ªåŠ¨æœº

#### 3. å®é™…åº”ç”¨æ‰©å±•

- **æœºå™¨å­¦ä¹ **ï¼šè‡ªåŠ¨æœºåœ¨æœºå™¨å­¦ä¹ ä¸­çš„åº”ç”¨
- **ç½‘ç»œå®‰å…¨**ï¼šè‡ªåŠ¨æœºåœ¨ç½‘ç»œå®‰å…¨ä¸­çš„åº”ç”¨
- **ç”Ÿç‰©ä¿¡æ¯å­¦**ï¼šè‡ªåŠ¨æœºåœ¨ç”Ÿç‰©åºåˆ—åˆ†æä¸­çš„åº”ç”¨

### æŠ€æœ¯æŒ‘æˆ˜

#### 1. æ€§èƒ½æŒ‘æˆ˜

```haskell
-- è‡ªåŠ¨æœºæ€§èƒ½ä¼˜åŒ–
class AutomatonOptimization a where
    optimize :: a -> a
    parallelize :: a -> Parallel a
    cache :: a -> Cached a
```

#### 2. è¡¨è¾¾èƒ½åŠ›æŒ‘æˆ˜

```haskell
-- æ‰©å±•è‡ªåŠ¨æœºè¡¨è¾¾èƒ½åŠ›
data ExtendedAutomaton a where
    Deterministic :: a -> ExtendedAutomaton a
    NonDeterministic :: a -> ExtendedAutomaton a
    Probabilistic :: a -> ExtendedAutomaton a
    Quantum :: a -> ExtendedAutomaton a
```

#### 3. å·¥å…·æ”¯æŒæŒ‘æˆ˜

- **å¯è§†åŒ–å·¥å…·**ï¼šè‡ªåŠ¨æœºçš„å¯è§†åŒ–è¡¨ç¤º
- **è°ƒè¯•å·¥å…·**ï¼šè‡ªåŠ¨æœºè¿è¡Œçš„è°ƒè¯•æ”¯æŒ
- **æ€§èƒ½åˆ†æ**ï¼šè‡ªåŠ¨æœºæ€§èƒ½åˆ†æå·¥å…·

## ğŸ› ï¸ å·¥å…·ä¸å®ç°

### ç¼–ç¨‹è¯­è¨€æ”¯æŒ

#### Python

```python
# Pythonä¸­çš„æœ‰é™è‡ªåŠ¨æœºå®ç°
class FiniteAutomaton:
    def __init__(self, states, alphabet, start_state, transitions, final_states):
        self.states = states
        self.alphabet = alphabet
        self.start_state = start_state
        self.transitions = transitions
        self.final_states = final_states
    
    def run(self, input_string):
        current_state = self.start_state
        
        for symbol in input_string:
            if (current_state, symbol) in self.transitions:
                current_state = self.transitions[(current_state, symbol)]
            else:
                return False
        
        return current_state in self.final_states

# ä½¿ç”¨ç¤ºä¾‹
states = {'q0', 'q1', 'q2'}
alphabet = {'a', 'b'}
start_state = 'q0'
transitions = {
    ('q0', 'a'): 'q1',
    ('q1', 'b'): 'q2',
    ('q2', 'a'): 'q0'
}
final_states = {'q2'}

fa = FiniteAutomaton(states, alphabet, start_state, transitions, final_states)
print(fa.run('aba'))  # True
print(fa.run('ab'))   # True
print(fa.run('a'))    # False
```

#### Java

```java
// Javaä¸­çš„æœ‰é™è‡ªåŠ¨æœºå®ç°
import java.util.*;

public class FiniteAutomaton {
    private Set<String> states;
    private Set<Character> alphabet;
    private String startState;
    private Map<StateInput, String> transitions;
    private Set<String> finalStates;
    
    public FiniteAutomaton(Set<String> states, Set<Character> alphabet, 
                          String startState, Map<StateInput, String> transitions, 
                          Set<String> finalStates) {
        this.states = states;
        this.alphabet = alphabet;
        this.startState = startState;
        this.transitions = transitions;
        this.finalStates = finalStates;
    }
    
    public boolean run(String input) {
        String currentState = startState;
        
        for (char symbol : input.toCharArray()) {
            StateInput key = new StateInput(currentState, symbol);
            if (transitions.containsKey(key)) {
                currentState = transitions.get(key);
            } else {
                return false;
            }
        }
        
        return finalStates.contains(currentState);
    }
    
    private static class StateInput {
        private String state;
        private char input;
        
        public StateInput(String state, char input) {
            this.state = state;
            this.input = input;
        }
        
        @Override
        public boolean equals(Object obj) {
            if (this == obj) return true;
            if (obj == null || getClass() != obj.getClass()) return false;
            StateInput that = (StateInput) obj;
            return input == that.input && Objects.equals(state, that.state);
        }
        
        @Override
        public int hashCode() {
            return Objects.hash(state, input);
        }
    }
}
```

### å½¢å¼åŒ–å·¥å…·

#### Coq

```coq
(* Coqä¸­çš„æœ‰é™è‡ªåŠ¨æœº *)
Inductive state : Set :=
| q0 : state
| q1 : state
| q2 : state.

Inductive symbol : Set :=
| a : symbol
| b : symbol.

Definition transition (s : state) (sym : symbol) : state :=
match s, sym with
| q0, a => q1
| q1, b => q2
| q2, a => q0
| _, _ => q0
end.

Definition final_states : list state := [q2].

Fixpoint run_automaton (input : list symbol) (current : state) : state :=
match input with
| nil => current
| sym :: rest => run_automaton rest (transition current sym)
end.

Definition accepts (input : list symbol) : bool :=
In (run_automaton input q0) final_states.
```

#### Isabelle

```isabelle
(* Isabelleä¸­çš„æœ‰é™è‡ªåŠ¨æœº *)
theory FiniteAutomaton
imports Main

begin

datatype state = q0 | q1 | q2
datatype symbol = a | b

fun transition :: "state â‡’ symbol â‡’ state" where
"transition q0 a = q1" |
"transition q1 b = q2" |
"transition q2 a = q0" |
"transition _ _ = q0"

fun run_automaton :: "symbol list â‡’ state â‡’ state" where
"run_automaton [] s = s" |
"run_automaton (x # xs) s = run_automaton xs (transition s x)"

definition final_states :: "state set" where
"final_states = {q2}"

definition accepts :: "symbol list â‡’ bool" where
"accepts input = (run_automaton input q0 âˆˆ final_states)"

end
```

### éªŒè¯å·¥å…·

#### è‡ªåŠ¨æœºéªŒè¯å™¨

```haskell
-- è‡ªåŠ¨æœºéªŒè¯å™¨
class AutomatonValidator a where
    validate :: a -> Bool
    checkDeterministic :: a -> Bool
    checkComplete :: a -> Bool

instance AutomatonValidator (DFA q a) where
    validate dfa = 
        checkDeterministic dfa && checkComplete dfa
    checkDeterministic dfa = 
        -- æ£€æŸ¥ç¡®å®šæ€§
        all (\s -> all (\a -> length (transitions dfa s a) == 1) (alphabet dfa)) (states dfa)
    checkComplete dfa = 
        -- æ£€æŸ¥å®Œæ•´æ€§
        all (\s -> all (\a -> transitions dfa s a /= []) (alphabet dfa)) (states dfa)
```

## ğŸ“š å­¦ä¹ è·¯å¾„

### åŸºç¡€é˜¶æ®µ

1. **è‡ªåŠ¨æœºç†è®ºåŸºç¡€**
   - å½¢å¼è¯­è¨€ç†è®º
   - è‡ªåŠ¨æœºåŸºæœ¬æ¦‚å¿µ
   - çŠ¶æ€è½¬æ¢å›¾

2. **ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº**
   - DFAå®šä¹‰å’Œæ€§è´¨
   - DFAæœ€å°åŒ–
   - DFAç­‰ä»·æ€§

3. **éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº**
   - NFAå®šä¹‰å’Œæ€§è´¨
   - NFAåˆ°DFAçš„è½¬æ¢
   - Îµ-NFA

### è¿›é˜¶é˜¶æ®µ

1. **é«˜çº§è‡ªåŠ¨æœºæ¨¡å‹**
   - æ¦‚ç‡è‡ªåŠ¨æœº
   - åŠ æƒè‡ªåŠ¨æœº
   - æ¨¡ç³Šè‡ªåŠ¨æœº

2. **è‡ªåŠ¨æœºä¼˜åŒ–**
   - çŠ¶æ€æœ€å°åŒ–ç®—æ³•
   - è‡ªåŠ¨æœºç­‰ä»·æ€§æ£€æŸ¥
   - æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯

3. **åº”ç”¨å®è·µ**
   - ç¼–è¯‘å™¨è®¾è®¡åº”ç”¨
   - ç½‘ç»œåè®®åº”ç”¨
   - ç¡¬ä»¶è®¾è®¡åº”ç”¨

### é«˜çº§é˜¶æ®µ

1. **ç†è®ºç ”ç©¶**
   - è‡ªåŠ¨æœºç†è®ºå‰æ²¿
   - è‡ªåŠ¨æœºä¼˜åŒ–ç®—æ³•
   - è‡ªåŠ¨æœºå¤æ‚æ€§åˆ†æ

2. **å·¥å…·å¼€å‘**
   - è‡ªåŠ¨æœºå¯è§†åŒ–å·¥å…·
   - è‡ªåŠ¨æœºéªŒè¯å·¥å…·
   - è‡ªåŠ¨æœºæ€§èƒ½åˆ†æå·¥å…·

3. **è·¨é¢†åŸŸåº”ç”¨**
   - é‡å­è®¡ç®—åº”ç”¨
   - æœºå™¨å­¦ä¹ åº”ç”¨
   - ç”Ÿç‰©ä¿¡æ¯å­¦åº”ç”¨

## ğŸ”— ç›¸å…³é“¾æ¥

- [8.2.2-ä¸‹æ¨è‡ªåŠ¨æœºæ·±åŒ–](8.2.2-ä¸‹æ¨è‡ªåŠ¨æœºæ·±åŒ–.md)
- [8.2.3-å›¾çµæœºæ·±åŒ–](8.2.3-å›¾çµæœºæ·±åŒ–.md)
- [8.2.4-é‡å­è‡ªåŠ¨æœºæ·±åŒ–](8.2.4-é‡å­è‡ªåŠ¨æœºæ·±åŒ–.md)
- [8.2.5-çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœºæ·±åŒ–](8.2.5-çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœºæ·±åŒ–.md)
- [8.2.6-è‡ªåŠ¨æœºå±‚æ¬¡ç»“æ„æ·±åŒ–](8.2.6-è‡ªåŠ¨æœºå±‚æ¬¡ç»“æ„æ·±åŒ–.md)
- [8.1-ç±»å‹ç†è®ºæ·±åŒ–](../8.1-ç±»å‹ç†è®ºæ·±åŒ–/README.md)
- [8.7-é‡å­ç³»ç»Ÿç†è®º](../8.7-é‡å­ç³»ç»Ÿç†è®º/README.md)

---

**ğŸ“– è¿”å›å¯¼èˆª**:

- [è¿”å›è‡ªåŠ¨æœºç†è®ºæ·±åŒ–å¯¼èˆª](README.md)
- [è¿”å›å½¢å¼ç†è®ºæ·±åŒ–æ€»å¯¼èˆª](../README.md)
