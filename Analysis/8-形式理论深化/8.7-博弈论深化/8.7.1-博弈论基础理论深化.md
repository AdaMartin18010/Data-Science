# 8.7.1 博弈论基础理论深化

## 1. 博弈论基础

### 1.1 博弈论基本概念

博弈论是研究理性决策者在相互依存情况下如何做出最优决策的理论。

```python
import numpy as np
from itertools import product
import matplotlib.pyplot as plt

class Game:
    def __init__(self, players, strategies, payoffs):
        """
        博弈类
        players: 玩家列表
        strategies: 每个玩家的策略集
        payoffs: 支付函数
        """
        self.players = players
        self.strategies = strategies
        self.payoffs = payoffs
        self.n_players = len(players)
        
    def get_payoff(self, strategy_profile):
        """获取策略组合的支付"""
        return self.payoffs[strategy_profile]
    
    def get_best_response(self, player, opponent_strategies):
        """获取最佳响应"""
        best_payoff = float('-inf')
        best_strategy = None
        
        for strategy in self.strategies[player]:
            # 构建策略组合
            strategy_profile = list(opponent_strategies)
            strategy_profile.insert(player, strategy)
            strategy_profile = tuple(strategy_profile)
            
            payoff = self.get_payoff(strategy_profile)[player]
            if payoff > best_payoff:
                best_payoff = payoff
                best_strategy = strategy
        
        return best_strategy, best_payoff
    
    def is_nash_equilibrium(self, strategy_profile):
        """检查是否为纳什均衡"""
        for player in range(self.n_players):
            # 获取其他玩家的策略
            opponent_strategies = list(strategy_profile)
            opponent_strategies.pop(player)
            
            # 获取当前玩家的最佳响应
            best_response, best_payoff = self.get_best_response(player, opponent_strategies)
            
            # 获取当前策略的支付
            current_payoff = self.get_payoff(strategy_profile)[player]
            
            # 如果不是最佳响应，则不是纳什均衡
            if best_payoff > current_payoff:
                return False
        
        return True
    
    def find_nash_equilibria(self):
        """寻找所有纳什均衡"""
        equilibria = []
        
        # 遍历所有可能的策略组合
        strategy_combinations = list(product(*self.strategies))
        
        for strategy_profile in strategy_combinations:
            if self.is_nash_equilibrium(strategy_profile):
                equilibria.append(strategy_profile)
        
        return equilibria
    
    def is_dominant_strategy(self, player, strategy):
        """检查是否为占优策略"""
        for opponent_strategies in product(*[self.strategies[i] for i in range(self.n_players) if i != player]):
            # 构建包含当前策略的策略组合
            strategy_profile = list(opponent_strategies)
            strategy_profile.insert(player, strategy)
            strategy_profile = tuple(strategy_profile)
            
            # 检查是否对所有对手策略都是最佳响应
            best_response, _ = self.get_best_response(player, opponent_strategies)
            if best_response != strategy:
                return False
        
        return True
    
    def find_dominant_strategies(self):
        """寻找所有占优策略"""
        dominant_strategies = {}
        
        for player in range(self.n_players):
            dominant_strategies[player] = []
            for strategy in self.strategies[player]:
                if self.is_dominant_strategy(player, strategy):
                    dominant_strategies[player].append(strategy)
        
        return dominant_strategies

class PrisonersDilemma(Game):
    def __init__(self):
        """囚徒困境博弈"""
        players = ['Player 1', 'Player 2']
        strategies = [['Cooperate', 'Defect'], ['Cooperate', 'Defect']]
        
        # 支付矩阵
        payoffs = {
            ('Cooperate', 'Cooperate'): [3, 3],
            ('Cooperate', 'Defect'): [0, 5],
            ('Defect', 'Cooperate'): [5, 0],
            ('Defect', 'Defect'): [1, 1]
        }
        
        super().__init__(players, strategies, payoffs)
    
    def analyze_game(self):
        """分析博弈"""
        print("囚徒困境博弈分析:")
        print("=" * 50)
        
        # 寻找纳什均衡
        nash_equilibria = self.find_nash_equilibria()
        print(f"纳什均衡: {nash_equilibria}")
        
        # 寻找占优策略
        dominant_strategies = self.find_dominant_strategies()
        print(f"占优策略: {dominant_strategies}")
        
        # 帕累托最优
        pareto_optimal = self.find_pareto_optimal()
        print(f"帕累托最优: {pareto_optimal}")
        
        return {
            'nash_equilibria': nash_equilibria,
            'dominant_strategies': dominant_strategies,
            'pareto_optimal': pareto_optimal
        }
    
    def find_pareto_optimal(self):
        """寻找帕累托最优策略组合"""
        pareto_optimal = []
        strategy_combinations = list(product(*self.strategies))
        
        for strategy_profile in strategy_combinations:
            is_pareto_optimal = True
            current_payoffs = self.get_payoff(strategy_profile)
            
            for other_profile in strategy_combinations:
                if other_profile != strategy_profile:
                    other_payoffs = self.get_payoff(other_profile)
                    
                    # 检查是否存在帕累托改进
                    if all(other_payoffs[i] >= current_payoffs[i] for i in range(self.n_players)) and \
                       any(other_payoffs[i] > current_payoffs[i] for i in range(self.n_players)):
                        is_pareto_optimal = False
                        break
            
            if is_pareto_optimal:
                pareto_optimal.append(strategy_profile)
        
        return pareto_optimal
```

### 1.2 博弈类型

```python
class GameTypes:
    def __init__(self):
        self.game_types = {
            'zero_sum': ZeroSumGame,
            'cooperative': CooperativeGame,
            'non_cooperative': NonCooperativeGame,
            'repeated': RepeatedGame
        }
    
    def create_game(self, game_type, **kwargs):
        """创建特定类型的博弈"""
        if game_type in self.game_types:
            game_class = self.game_types[game_type]
            return game_class(**kwargs)
        else:
            raise ValueError(f"Unknown game type: {game_type}")

class ZeroSumGame(Game):
    def __init__(self, players, strategies, payoffs):
        """零和博弈"""
        super().__init__(players, strategies, payoffs)
        self.verify_zero_sum()
    
    def verify_zero_sum(self):
        """验证零和性质"""
        for strategy_profile in product(*self.strategies):
            payoffs = self.get_payoff(strategy_profile)
            if abs(sum(payoffs)) > 1e-10:
                raise ValueError("Game is not zero-sum")
    
    def find_minimax_strategy(self, player):
        """寻找最小最大策略"""
        if player == 0:
            # 玩家1选择行，玩家2选择列
            payoff_matrix = self.build_payoff_matrix()
            
            # 计算最小最大策略
            row_minima = np.min(payoff_matrix, axis=1)
            maximin = np.max(row_minima)
            maximin_strategy = np.argmax(row_minima)
            
            return maximin_strategy, maximin
        else:
            # 玩家2选择列，玩家1选择行
            payoff_matrix = self.build_payoff_matrix()
            
            # 计算最大最小策略
            column_maxima = np.max(payoff_matrix, axis=0)
            minimax = np.min(column_maxima)
            minimax_strategy = np.argmin(column_maxima)
            
            return minimax_strategy, minimax
    
    def build_payoff_matrix(self):
        """构建支付矩阵"""
        # 这里需要根据具体的博弈结构实现
        # 简化实现
        return np.array([[3, 0], [5, 1]])

class CooperativeGame(Game):
    def __init__(self, players, strategies, payoffs):
        """合作博弈"""
        super().__init__(players, strategies, payoffs)
        self.coalitions = self.generate_coalitions()
    
    def generate_coalitions(self):
        """生成所有可能的联盟"""
        from itertools import combinations
        
        coalitions = []
        for i in range(1, self.n_players + 1):
            coalitions.extend(list(combinations(range(self.n_players), i)))
        
        return coalitions
    
    def characteristic_function(self, coalition):
        """特征函数"""
        # 这里需要实现具体的特征函数
        # 简化实现
        return len(coalition) * 10
    
    def find_core(self):
        """寻找核"""
        # 这里需要实现核的计算
        # 简化实现
        return []
    
    def find_shapley_value(self):
        """计算Shapley值"""
        shapley_values = [0] * self.n_players
        
        for player in range(self.n_players):
            for coalition in self.coalitions:
                if player in coalition:
                    # 计算边际贡献
                    coalition_without_player = tuple(p for p in coalition if p != player)
                    marginal_contribution = self.characteristic_function(coalition) - \
                                         self.characteristic_function(coalition_without_player)
                    
                    # 计算权重
                    weight = len(coalition) * len([c for c in self.coalitions if player in c])
                    
                    shapley_values[player] += marginal_contribution / weight
        
        return shapley_values
```

## 2. 策略型博弈

### 2.1 策略型博弈表示

```python
class StrategicGame(Game):
    def __init__(self, players, strategies, payoffs):
        """策略型博弈"""
        super().__init__(players, strategies, payoffs)
        self.payoff_matrix = self.build_payoff_matrix()
    
    def build_payoff_matrix(self):
        """构建支付矩阵"""
        # 这里需要根据具体的博弈结构实现
        # 简化实现
        return np.array([[[3, 3], [0, 5]], [[5, 0], [1, 1]]])
    
    def find_pure_strategy_equilibria(self):
        """寻找纯策略均衡"""
        return self.find_nash_equilibria()
    
    def find_mixed_strategy_equilibria(self):
        """寻找混合策略均衡"""
        # 这里需要实现混合策略均衡的计算
        # 简化实现
        return []
    
    def best_response_correspondence(self, player, opponent_strategies):
        """最佳响应对应"""
        best_responses = []
        best_payoff = float('-inf')
        
        for strategy in self.strategies[player]:
            # 构建策略组合
            strategy_profile = list(opponent_strategies)
            strategy_profile.insert(player, strategy)
            strategy_profile = tuple(strategy_profile)
            
            payoff = self.get_payoff(strategy_profile)[player]
            if payoff > best_payoff:
                best_payoff = payoff
                best_responses = [strategy]
            elif payoff == best_payoff:
                best_responses.append(strategy)
        
        return best_responses
    
    def is_strictly_dominated(self, player, strategy):
        """检查是否为严格被占优策略"""
        for other_strategy in self.strategies[player]:
            if other_strategy != strategy:
                # 检查other_strategy是否严格占优strategy
                is_dominant = True
                for opponent_strategies in product(*[self.strategies[i] for i in range(self.n_players) if i != player]):
                    strategy_profile_with_strategy = list(opponent_strategies)
                    strategy_profile_with_strategy.insert(player, strategy)
                    strategy_profile_with_strategy = tuple(strategy_profile_with_strategy)
                    
                    strategy_profile_with_other = list(opponent_strategies)
                    strategy_profile_with_other.insert(player, other_strategy)
                    strategy_profile_with_other = tuple(strategy_profile_with_other)
                    
                    if self.get_payoff(strategy_profile_with_strategy)[player] >= \
                       self.get_payoff(strategy_profile_with_other)[player]:
                        is_dominant = False
                        break
                
                if is_dominant:
                    return True
        
        return False
    
    def iterated_elimination_of_dominated_strategies(self):
        """迭代消除被占优策略"""
        eliminated_strategies = {player: set() for player in range(self.n_players)}
        
        while True:
            eliminated_this_round = False
            
            for player in range(self.n_players):
                remaining_strategies = [s for s in self.strategies[player] 
                                     if s not in eliminated_strategies[player]]
                
                for strategy in remaining_strategies:
                    if self.is_strictly_dominated(player, strategy):
                        eliminated_strategies[player].add(strategy)
                        eliminated_this_round = True
            
            if not eliminated_this_round:
                break
        
        return eliminated_strategies
```

### 2.2 博弈分析工具

```python
class GameAnalysis:
    def __init__(self, game):
        self.game = game
    
    def comprehensive_analysis(self):
        """综合分析"""
        analysis = {}
        
        # 纳什均衡
        analysis['nash_equilibria'] = self.game.find_nash_equilibria()
        
        # 占优策略
        analysis['dominant_strategies'] = self.game.find_dominant_strategies()
        
        # 被占优策略
        if isinstance(self.game, StrategicGame):
            analysis['dominated_strategies'] = self.game.iterated_elimination_of_dominated_strategies()
        
        # 帕累托最优
        analysis['pareto_optimal'] = self.find_pareto_optimal()
        
        # 社会最优
        analysis['social_optimal'] = self.find_social_optimal()
        
        return analysis
    
    def find_pareto_optimal(self):
        """寻找帕累托最优"""
        pareto_optimal = []
        strategy_combinations = list(product(*self.game.strategies))
        
        for strategy_profile in strategy_combinations:
            is_pareto_optimal = True
            current_payoffs = self.game.get_payoff(strategy_profile)
            
            for other_profile in strategy_combinations:
                if other_profile != strategy_profile:
                    other_payoffs = self.game.get_payoff(other_profile)
                    
                    # 检查是否存在帕累托改进
                    if all(other_payoffs[i] >= current_payoffs[i] for i in range(self.game.n_players)) and \
                       any(other_payoffs[i] > current_payoffs[i] for i in range(self.game.n_players)):
                        is_pareto_optimal = False
                        break
            
            if is_pareto_optimal:
                pareto_optimal.append(strategy_profile)
        
        return pareto_optimal
    
    def find_social_optimal(self):
        """寻找社会最优"""
        strategy_combinations = list(product(*self.game.strategies))
        best_social_welfare = float('-inf')
        social_optimal = []
        
        for strategy_profile in strategy_combinations:
            payoffs = self.game.get_payoff(strategy_profile)
            social_welfare = sum(payoffs)
            
            if social_welfare > best_social_welfare:
                best_social_welfare = social_welfare
                social_optimal = [strategy_profile]
            elif social_welfare == best_social_welfare:
                social_optimal.append(strategy_profile)
        
        return social_optimal
    
    def efficiency_analysis(self):
        """效率分析"""
        nash_equilibria = self.game.find_nash_equilibria()
        social_optimal = self.find_social_optimal()
        
        efficiency_measures = {}
        
        for equilibrium in nash_equilibria:
            equilibrium_payoffs = self.game.get_payoff(equilibrium)
            equilibrium_welfare = sum(equilibrium_payoffs)
            
            # 计算效率
            max_welfare = sum(self.game.get_payoff(social_optimal[0]))
            efficiency = equilibrium_welfare / max_welfare if max_welfare > 0 else 0
            
            efficiency_measures[equilibrium] = {
                'welfare': equilibrium_welfare,
                'efficiency': efficiency,
                'payoffs': equilibrium_payoffs
            }
        
        return efficiency_measures
```

## 3. 扩展型博弈

### 3.1 扩展型博弈表示

```python
class ExtensiveGame:
    def __init__(self, players, game_tree):
        """
        扩展型博弈
        players: 玩家列表
        game_tree: 博弈树
        """
        self.players = players
        self.game_tree = game_tree
        self.n_players = len(players)
        
    def find_subgame_perfect_equilibria(self):
        """寻找子博弈完美均衡"""
        # 使用逆向归纳法
        equilibria = self.backward_induction()
        return equilibria
    
    def backward_induction(self):
        """逆向归纳法"""
        # 这里需要实现具体的逆向归纳算法
        # 简化实现
        return []
    
    def find_nash_equilibria(self):
        """寻找纳什均衡"""
        # 将扩展型博弈转换为策略型博弈
        strategic_form = self.convert_to_strategic_form()
        return strategic_form.find_nash_equilibria()
    
    def convert_to_strategic_form(self):
        """转换为策略型博弈"""
        # 这里需要实现具体的转换算法
        # 简化实现
        return None

class GameTree:
    def __init__(self, root):
        """
        博弈树
        root: 根节点
        """
        self.root = root
        
    def get_all_nodes(self):
        """获取所有节点"""
        nodes = []
        self.collect_nodes(self.root, nodes)
        return nodes
    
    def collect_nodes(self, node, nodes):
        """收集节点"""
        nodes.append(node)
        for child in node.children:
            self.collect_nodes(child, nodes)
    
    def get_leaf_nodes(self):
        """获取叶子节点"""
        leaf_nodes = []
        self.collect_leaf_nodes(self.root, leaf_nodes)
        return leaf_nodes
    
    def collect_leaf_nodes(self, node, leaf_nodes):
        """收集叶子节点"""
        if not node.children:
            leaf_nodes.append(node)
        else:
            for child in node.children:
                self.collect_leaf_nodes(child, leaf_nodes)

class GameNode:
    def __init__(self, player, actions=None, payoffs=None):
        """
        博弈节点
        player: 玩家
        actions: 可用行动
        payoffs: 支付
        """
        self.player = player
        self.actions = actions or []
        self.payoffs = payoffs
        self.children = []
        
    def add_child(self, child):
        """添加子节点"""
        self.children.append(child)
    
    def is_leaf(self):
        """是否为叶子节点"""
        return len(self.children) == 0
    
    def get_optimal_action(self):
        """获取最优行动"""
        if self.is_leaf():
            return None
        
        best_action = None
        best_payoff = float('-inf')
        
        for i, child in enumerate(self.children):
            if child.payoffs and child.payoffs[self.player] > best_payoff:
                best_payoff = child.payoffs[self.player]
                best_action = self.actions[i]
        
        return best_action
```

### 3.2 动态博弈

```python
class DynamicGame(ExtensiveGame):
    def __init__(self, players, game_tree, discount_factor=1.0):
        """动态博弈"""
        super().__init__(players, game_tree)
        self.discount_factor = discount_factor
    
    def find_subgame_perfect_equilibrium(self):
        """寻找子博弈完美均衡"""
        return self.backward_induction()
    
    def backward_induction(self):
        """逆向归纳法"""
        equilibrium_actions = {}
        
        # 从叶子节点开始，向上计算最优行动
        leaf_nodes = self.game_tree.get_leaf_nodes()
        
        # 为每个叶子节点计算最优行动
        for leaf in leaf_nodes:
            if leaf.payoffs:
                best_action = leaf.get_optimal_action()
                if best_action:
                    equilibrium_actions[leaf] = best_action
        
        # 向上传播最优行动
        self.propagate_optimal_actions(self.game_tree.root, equilibrium_actions)
        
        return equilibrium_actions
    
    def propagate_optimal_actions(self, node, equilibrium_actions):
        """传播最优行动"""
        if node.is_leaf():
            return
        
        # 递归处理子节点
        for child in node.children:
            self.propagate_optimal_actions(child, equilibrium_actions)
        
        # 计算当前节点的最优行动
        best_action = node.get_optimal_action()
        if best_action:
            equilibrium_actions[node] = best_action
    
    def calculate_present_value(self, payoffs, period):
        """计算现值"""
        return [payoff * (self.discount_factor ** period) for payoff in payoffs]
    
    def find_stationary_equilibrium(self):
        """寻找稳态均衡"""
        # 这里需要实现稳态均衡的计算
        # 简化实现
        return {}
```

## 4. 纳什均衡

### 4.1 纳什均衡计算

```python
class NashEquilibrium:
    def __init__(self, game):
        self.game = game
    
    def find_all_equilibria(self):
        """寻找所有纳什均衡"""
        equilibria = {
            'pure_strategy': self.find_pure_strategy_equilibria(),
            'mixed_strategy': self.find_mixed_strategy_equilibria()
        }
        return equilibria
    
    def find_pure_strategy_equilibria(self):
        """寻找纯策略纳什均衡"""
        return self.game.find_nash_equilibria()
    
    def find_mixed_strategy_equilibria(self):
        """寻找混合策略纳什均衡"""
        # 这里需要实现混合策略均衡的计算
        # 简化实现
        return []
    
    def is_evolutionarily_stable(self, strategy_profile):
        """检查是否为演化稳定策略"""
        # 这里需要实现演化稳定性的检查
        # 简化实现
        return True
    
    def find_evolutionarily_stable_strategies(self):
        """寻找演化稳定策略"""
        # 这里需要实现演化稳定策略的计算
        # 简化实现
        return []
    
    def trembling_hand_perfect_equilibrium(self):
        """颤抖手完美均衡"""
        # 这里需要实现颤抖手完美均衡的计算
        # 简化实现
        return []

class MixedStrategyEquilibrium:
    def __init__(self, game):
        self.game = game
    
    def solve_2x2_game(self):
        """求解2x2博弈的混合策略均衡"""
        if self.game.n_players != 2 or len(self.game.strategies[0]) != 2 or len(self.game.strategies[1]) != 2:
            raise ValueError("This method only works for 2x2 games")
        
        # 构建支付矩阵
        payoff_matrix = self.build_2x2_payoff_matrix()
        
        # 计算混合策略均衡
        equilibrium = self.calculate_mixed_equilibrium_2x2(payoff_matrix)
        
        return equilibrium
    
    def build_2x2_payoff_matrix(self):
        """构建2x2支付矩阵"""
        # 这里需要根据具体的博弈结构实现
        # 简化实现
        return np.array([[[3, 3], [0, 5]], [[5, 0], [1, 1]]])
    
    def calculate_mixed_equilibrium_2x2(self, payoff_matrix):
        """计算2x2博弈的混合策略均衡"""
        # 玩家1的混合策略
        p = self.calculate_player1_mixed_strategy(payoff_matrix)
        
        # 玩家2的混合策略
        q = self.calculate_player2_mixed_strategy(payoff_matrix)
        
        return {
            'player1_mixed_strategy': p,
            'player2_mixed_strategy': q
        }
    
    def calculate_player1_mixed_strategy(self, payoff_matrix):
        """计算玩家1的混合策略"""
        # 使用无差异条件
        # 这里需要实现具体的计算
        # 简化实现
        return 0.5
    
    def calculate_player2_mixed_strategy(self, payoff_matrix):
        """计算玩家2的混合策略"""
        # 使用无差异条件
        # 这里需要实现具体的计算
        # 简化实现
        return 0.5
```

### 4.2 均衡选择

```python
class EquilibriumSelection:
    def __init__(self, game):
        self.game = game
    
    def select_equilibrium(self, method='pareto_dominance'):
        """选择均衡"""
        equilibria = self.game.find_nash_equilibria()
        
        if method == 'pareto_dominance':
            return self.pareto_dominant_equilibrium(equilibria)
        elif method == 'risk_dominance':
            return self.risk_dominant_equilibrium(equilibria)
        elif method == 'payoff_dominance':
            return self.payoff_dominant_equilibrium(equilibria)
        else:
            raise ValueError(f"Unknown selection method: {method}")
    
    def pareto_dominant_equilibrium(self, equilibria):
        """帕累托占优均衡"""
        if not equilibria:
            return None
        
        pareto_dominant = equilibria[0]
        pareto_dominant_payoffs = self.game.get_payoff(pareto_dominant)
        
        for equilibrium in equilibria[1:]:
            payoffs = self.game.get_payoff(equilibrium)
            
            # 检查是否帕累托占优
            if all(payoffs[i] >= pareto_dominant_payoffs[i] for i in range(self.game.n_players)) and \
               any(payoffs[i] > pareto_dominant_payoffs[i] for i in range(self.game.n_players)):
                pareto_dominant = equilibrium
                pareto_dominant_payoffs = payoffs
        
        return pareto_dominant
    
    def risk_dominant_equilibrium(self, equilibria):
        """风险占优均衡"""
        if len(equilibria) < 2:
            return equilibria[0] if equilibria else None
        
        # 计算风险因子
        risk_factors = {}
        for equilibrium in equilibria:
            risk_factor = self.calculate_risk_factor(equilibrium)
            risk_factors[equilibrium] = risk_factor
        
        # 选择风险最小的均衡
        return min(risk_factors.keys(), key=lambda x: risk_factors[x])
    
    def calculate_risk_factor(self, equilibrium):
        """计算风险因子"""
        # 这里需要实现具体的风险因子计算
        # 简化实现
        return 0.5
    
    def payoff_dominant_equilibrium(self, equilibria):
        """支付占优均衡"""
        if not equilibria:
            return None
        
        payoff_dominant = equilibria[0]
        max_total_payoff = sum(self.game.get_payoff(payoff_dominant))
        
        for equilibrium in equilibria[1:]:
            total_payoff = sum(self.game.get_payoff(equilibrium))
            if total_payoff > max_total_payoff:
                payoff_dominant = equilibrium
                max_total_payoff = total_payoff
        
        return payoff_dominant
```

## 5. 应用案例

### 5.1 囚徒困境

```python
class PrisonersDilemmaAnalysis:
    def __init__(self):
        self.game = PrisonersDilemma()
        self.analysis = GameAnalysis(self.game)
    
    def comprehensive_analysis(self):
        """综合分析"""
        print("囚徒困境博弈综合分析")
        print("=" * 50)
        
        # 基本分析
        basic_analysis = self.game.analyze_game()
        
        # 效率分析
        efficiency_analysis = self.analysis.efficiency_analysis()
        
        # 均衡选择
        equilibrium_selector = EquilibriumSelection(self.game)
        selected_equilibrium = equilibrium_selector.select_equilibrium('pareto_dominance')
        
        print(f"选择的均衡: {selected_equilibrium}")
        print(f"效率分析: {efficiency_analysis}")
        
        return {
            'basic_analysis': basic_analysis,
            'efficiency_analysis': efficiency_analysis,
            'selected_equilibrium': selected_equilibrium
        }
    
    def repeated_game_analysis(self, rounds=10, discount_factor=0.9):
        """重复博弈分析"""
        print(f"重复囚徒困境分析 (回合数: {rounds}, 折扣因子: {discount_factor})")
        print("=" * 50)
        
        # 构建重复博弈
        repeated_game = RepeatedGame(self.game, rounds, discount_factor)
        
        # 分析重复博弈的均衡
        equilibria = repeated_game.find_equilibria()
        
        print(f"重复博弈均衡: {equilibria}")
        
        return equilibria

class RepeatedGame:
    def __init__(self, stage_game, rounds, discount_factor=1.0):
        """重复博弈"""
        self.stage_game = stage_game
        self.rounds = rounds
        self.discount_factor = discount_factor
    
    def find_equilibria(self):
        """寻找重复博弈的均衡"""
        # 这里需要实现重复博弈均衡的计算
        # 简化实现
        return []
    
    def calculate_present_value(self, payoffs, period):
        """计算现值"""
        return [payoff * (self.discount_factor ** period) for payoff in payoffs]
```

### 5.2 协调博弈

```python
class CoordinationGame(Game):
    def __init__(self):
        """协调博弈"""
        players = ['Player 1', 'Player 2']
        strategies = [['A', 'B'], ['A', 'B']]
        
        # 支付矩阵
        payoffs = {
            ('A', 'A'): [3, 3],
            ('A', 'B'): [0, 0],
            ('B', 'A'): [0, 0],
            ('B', 'B'): [2, 2]
        }
        
        super().__init__(players, strategies, payoffs)
    
    def analyze_coordination(self):
        """分析协调问题"""
        print("协调博弈分析")
        print("=" * 30)
        
        # 纳什均衡
        nash_equilibria = self.find_nash_equilibria()
        print(f"纳什均衡: {nash_equilibria}")
        
        # 帕累托最优
        pareto_optimal = self.find_pareto_optimal()
        print(f"帕累托最优: {pareto_optimal}")
        
        # 风险占优
        risk_dominant = self.find_risk_dominant_equilibrium()
        print(f"风险占优均衡: {risk_dominant}")
        
        return {
            'nash_equilibria': nash_equilibria,
            'pareto_optimal': pareto_optimal,
            'risk_dominant': risk_dominant
        }
    
    def find_risk_dominant_equilibrium(self):
        """寻找风险占优均衡"""
        # 计算风险因子
        risk_factors = {}
        
        for equilibrium in self.find_nash_equilibria():
            risk_factor = self.calculate_risk_factor(equilibrium)
            risk_factors[equilibrium] = risk_factor
        
        # 选择风险最小的均衡
        return min(risk_factors.keys(), key=lambda x: risk_factors[x])
    
    def calculate_risk_factor(self, equilibrium):
        """计算风险因子"""
        # 这里需要实现具体的风险因子计算
        # 简化实现
        return 0.5
```

## 6. 工具实现

### 6.1 Python博弈论工具

```python
class GameTheoryTools:
    def __init__(self):
        self.game_types = {
            'prisoners_dilemma': PrisonersDilemma,
            'coordination': CoordinationGame,
            'battle_of_sexes': BattleOfSexes,
            'chicken': ChickenGame
        }
    
    def create_game(self, game_type, **kwargs):
        """创建博弈"""
        if game_type in self.game_types:
            game_class = self.game_types[game_type]
            return game_class(**kwargs)
        else:
            raise ValueError(f"Unknown game type: {game_type}")
    
    def analyze_game(self, game):
        """分析博弈"""
        analyzer = GameAnalysis(game)
        return analyzer.comprehensive_analysis()
    
    def find_equilibria(self, game, equilibrium_type='all'):
        """寻找均衡"""
        if equilibrium_type == 'all':
            return {
                'nash': game.find_nash_equilibria(),
                'dominant': game.find_dominant_strategies(),
                'pareto': analyzer.find_pareto_optimal()
            }
        elif equilibrium_type == 'nash':
            return game.find_nash_equilibria()
        else:
            raise ValueError(f"Unknown equilibrium type: {equilibrium_type}")
    
    def select_equilibrium(self, game, method='pareto_dominance'):
        """选择均衡"""
        selector = EquilibriumSelection(game)
        return selector.select_equilibrium(method)

class BattleOfSexes(Game):
    def __init__(self):
        """性别之战博弈"""
        players = ['Player 1', 'Player 2']
        strategies = [['Football', 'Opera'], ['Football', 'Opera']]
        
        payoffs = {
            ('Football', 'Football'): [3, 2],
            ('Football', 'Opera'): [0, 0],
            ('Opera', 'Football'): [0, 0],
            ('Opera', 'Opera'): [2, 3]
        }
        
        super().__init__(players, strategies, payoffs)

class ChickenGame(Game):
    def __init__(self):
        """懦夫博弈"""
        players = ['Player 1', 'Player 2']
        strategies = [['Swerve', 'Straight'], ['Swerve', 'Straight']]
        
        payoffs = {
            ('Swerve', 'Swerve'): [0, 0],
            ('Swerve', 'Straight'): [-1, 1],
            ('Straight', 'Swerve'): [1, -1],
            ('Straight', 'Straight'): [-10, -10]
        }
        
        super().__init__(players, strategies, payoffs)
```

### 6.2 JavaScript博弈论实现

```javascript
class GameTheoryTools {
  constructor() {
    this.gameTypes = {
      'prisonersDilemma': PrisonersDilemma,
      'coordination': CoordinationGame,
      'battleOfSexes': BattleOfSexes,
      'chicken': ChickenGame
    };
  }
  
  createGame(gameType, config) {
    if (gameType in this.gameTypes) {
      const GameClass = this.gameTypes[gameType];
      return new GameClass(config);
    } else {
      throw new Error(`Unknown game type: ${gameType}`);
    }
  }
  
  analyzeGame(game) {
    const analyzer = new GameAnalysis(game);
    return analyzer.comprehensiveAnalysis();
  }
  
  findEquilibria(game, equilibriumType = 'all') {
    if (equilibriumType === 'all') {
      const analyzer = new GameAnalysis(game);
      return {
        nash: game.findNashEquilibria(),
        dominant: game.findDominantStrategies(),
        pareto: analyzer.findParetoOptimal()
      };
    } else if (equilibriumType === 'nash') {
      return game.findNashEquilibria();
    } else {
      throw new Error(`Unknown equilibrium type: ${equilibriumType}`);
    }
  }
  
  selectEquilibrium(game, method = 'pareto_dominance') {
    const selector = new EquilibriumSelection(game);
    return selector.selectEquilibrium(method);
  }
}

class Game {
  constructor(players, strategies, payoffs) {
    this.players = players;
    this.strategies = strategies;
    this.payoffs = payoffs;
    this.nPlayers = players.length;
  }
  
  getPayoff(strategyProfile) {
    return this.payoffs[strategyProfile];
  }
  
  getBestResponse(player, opponentStrategies) {
    let bestPayoff = -Infinity;
    let bestStrategy = null;
    
    for (const strategy of this.strategies[player]) {
      const strategyProfile = [...opponentStrategies];
      strategyProfile.splice(player, 0, strategy);
      const strategyProfileTuple = strategyProfile.join(',');
      
      const payoff = this.getPayoff(strategyProfileTuple)[player];
      if (payoff > bestPayoff) {
        bestPayoff = payoff;
        bestStrategy = strategy;
      }
    }
    
    return [bestStrategy, bestPayoff];
  }
  
  isNashEquilibrium(strategyProfile) {
    for (let player = 0; player < this.nPlayers; player++) {
      const opponentStrategies = [...strategyProfile];
      opponentStrategies.splice(player, 1);
      
      const [bestResponse, bestPayoff] = this.getBestResponse(player, opponentStrategies);
      const currentPayoff = this.getPayoff(strategyProfile.join(','))[player];
      
      if (bestPayoff > currentPayoff) {
        return false;
      }
    }
    
    return true;
  }
  
  findNashEquilibria() {
    const equilibria = [];
    const strategyCombinations = this.generateStrategyCombinations();
    
    for (const strategyProfile of strategyCombinations) {
      if (this.isNashEquilibrium(strategyProfile)) {
        equilibria.push(strategyProfile);
      }
    }
    
    return equilibria;
  }
  
  generateStrategyCombinations() {
    // 这里需要实现策略组合的生成
    // 简化实现
    return [];
  }
}
```

## 7. 学习路径

### 7.1 基础学习

1. **博弈论基础** (2-3周)
   - 博弈论基本概念
   - 策略型博弈
   - 纳什均衡

2. **扩展型博弈** (2-3周)
   - 博弈树
   - 逆向归纳法
   - 子博弈完美均衡

### 7.2 进阶学习

1. **均衡理论** (3-4周)
   - 混合策略均衡
   - 演化稳定策略
   - 颤抖手完美均衡

2. **博弈分析** (3-4周)
   - 均衡选择
   - 效率分析
   - 机制设计

### 7.3 应用实践

1. **实际应用** (4-5周)
   - 经济学应用
   - 政治学应用
   - 生物学应用

2. **工具开发** (3-4周)
   - 博弈分析工具
   - 均衡计算工具
   - 仿真工具

## 8. 总结

博弈论基础理论为理解理性决策者在相互依存情况下的行为提供了重要的理论框架。通过深入理解策略型博弈、扩展型博弈和纳什均衡，可以分析各种社会、经济和政治现象中的策略互动。
