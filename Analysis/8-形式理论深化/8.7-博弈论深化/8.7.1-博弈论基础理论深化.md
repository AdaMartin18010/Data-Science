# 8.7.1 博弈论基础理论深化

## 1. 博弈论基础

### 1.1 博弈论基本概念

博弈论是研究理性决策者在相互依存情况下如何做出最优决策的理论。

```python
import numpy as np
from itertools import product
import matplotlib.pyplot as plt

class Game:
    def __init__(self, players, strategies, payoffs):
        """
        博弈类
        players: 玩家列表
        strategies: 每个玩家的策略集
        payoffs: 支付函数
        """
        self.players = players
        self.strategies = strategies
        self.payoffs = payoffs
        self.n_players = len(players)
        
    def get_payoff(self, strategy_profile):
        """获取策略组合的支付"""
        return self.payoffs[strategy_profile]
    
    def get_best_response(self, player, opponent_strategies):
        """获取最佳响应"""
        best_payoff = float('-inf')
        best_strategy = None
        
        for strategy in self.strategies[player]:
            # 构建策略组合
            strategy_profile = list(opponent_strategies)
            strategy_profile.insert(player, strategy)
            strategy_profile = tuple(strategy_profile)
            
            payoff = self.get_payoff(strategy_profile)[player]
            if payoff > best_payoff:
                best_payoff = payoff
                best_strategy = strategy
        
        return best_strategy, best_payoff
    
    def is_nash_equilibrium(self, strategy_profile):
        """检查是否为纳什均衡"""
        for player in range(self.n_players):
            # 获取其他玩家的策略
            opponent_strategies = list(strategy_profile)
            opponent_strategies.pop(player)
            
            # 获取当前玩家的最佳响应
            best_response, best_payoff = self.get_best_response(player, opponent_strategies)
            
            # 获取当前策略的支付
            current_payoff = self.get_payoff(strategy_profile)[player]
            
            # 如果不是最佳响应，则不是纳什均衡
            if best_payoff > current_payoff:
                return False
        
        return True
    
    def find_nash_equilibria(self):
        """寻找所有纳什均衡"""
        equilibria = []
        
        # 遍历所有可能的策略组合
        strategy_combinations = list(product(*self.strategies))
        
        for strategy_profile in strategy_combinations:
            if self.is_nash_equilibrium(strategy_profile):
                equilibria.append(strategy_profile)
        
        return equilibria
    
    def is_dominant_strategy(self, player, strategy):
        """检查是否为占优策略"""
        for opponent_strategies in product(*[self.strategies[i] for i in range(self.n_players) if i != player]):
            # 构建包含当前策略的策略组合
            strategy_profile = list(opponent_strategies)
            strategy_profile.insert(player, strategy)
            strategy_profile = tuple(strategy_profile)
            
            # 检查是否对所有对手策略都是最佳响应
            best_response, _ = self.get_best_response(player, opponent_strategies)
            if best_response != strategy:
                return False
        
        return True
    
    def find_dominant_strategies(self):
        """寻找所有占优策略"""
        dominant_strategies = {}
        
        for player in range(self.n_players):
            dominant_strategies[player] = []
            for strategy in self.strategies[player]:
                if self.is_dominant_strategy(player, strategy):
                    dominant_strategies[player].append(strategy)
        
        return dominant_strategies

class PrisonersDilemma(Game):
    def __init__(self):
        """囚徒困境博弈"""
        players = ['Player 1', 'Player 2']
        strategies = [['Cooperate', 'Defect'], ['Cooperate', 'Defect']]
        
        # 支付矩阵
        payoffs = {
            ('Cooperate', 'Cooperate'): [3, 3],
            ('Cooperate', 'Defect'): [0, 5],
            ('Defect', 'Cooperate'): [5, 0],
            ('Defect', 'Defect'): [1, 1]
        }
        
        super().__init__(players, strategies, payoffs)
    
    def analyze_game(self):
        """分析博弈"""
        print("囚徒困境博弈分析:")
        print("=" * 50)
        
        # 寻找纳什均衡
        nash_equilibria = self.find_nash_equilibria()
        print(f"纳什均衡: {nash_equilibria}")
        
        # 寻找占优策略
        dominant_strategies = self.find_dominant_strategies()
        print(f"占优策略: {dominant_strategies}")
        
        # 帕累托最优
        pareto_optimal = self.find_pareto_optimal()
        print(f"帕累托最优: {pareto_optimal}")
        
        return {
            'nash_equilibria': nash_equilibria,
            'dominant_strategies': dominant_strategies,
            'pareto_optimal': pareto_optimal
        }
    
    def find_pareto_optimal(self):
        """寻找帕累托最优策略组合"""
        pareto_optimal = []
        strategy_combinations = list(product(*self.strategies))
        
        for strategy_profile in strategy_combinations:
            is_pareto_optimal = True
            current_payoffs = self.get_payoff(strategy_profile)
            
            for other_profile in strategy_combinations:
                if other_profile != strategy_profile:
                    other_payoffs = self.get_payoff(other_profile)
                    
                    # 检查是否存在帕累托改进
                    if all(other_payoffs[i] >= current_payoffs[i] for i in range(self.n_players)) and \
                       any(other_payoffs[i] > current_payoffs[i] for i in range(self.n_players)):
                        is_pareto_optimal = False
                        break
            
            if is_pareto_optimal:
                pareto_optimal.append(strategy_profile)
        
        return pareto_optimal
```

### 1.2 博弈类型

```python
class GameTypes:
    def __init__(self):
        self.game_types = {
            'zero_sum': ZeroSumGame,
            'cooperative': CooperativeGame,
            'non_cooperative': NonCooperativeGame,
            'repeated': RepeatedGame
        }
    
    def create_game(self, game_type, **kwargs):
        """创建特定类型的博弈"""
        if game_type in self.game_types:
            game_class = self.game_types[game_type]
            return game_class(**kwargs)
        else:
            raise ValueError(f"Unknown game type: {game_type}")

class ZeroSumGame(Game):
    def __init__(self, players, strategies, payoffs):
        """零和博弈"""
        super().__init__(players, strategies, payoffs)
        self.verify_zero_sum()
    
    def verify_zero_sum(self):
        """验证零和性质"""
        for strategy_profile in product(*self.strategies):
            payoffs = self.get_payoff(strategy_profile)
            if abs(sum(payoffs)) > 1e-10:
                raise ValueError("Game is not zero-sum")
    
    def find_minimax_strategy(self, player):
        """寻找最小最大策略"""
        if player == 0:
            # 玩家1选择行，玩家2选择列
            payoff_matrix = self.build_payoff_matrix()
            
            # 计算最小最大策略
            row_minima = np.min(payoff_matrix, axis=1)
            maximin = np.max(row_minima)
            maximin_strategy = np.argmax(row_minima)
            
            return maximin_strategy, maximin
        else:
            # 玩家2选择列，玩家1选择行
            payoff_matrix = self.build_payoff_matrix()
            
            # 计算最大最小策略
            column_maxima = np.max(payoff_matrix, axis=0)
            minimax = np.min(column_maxima)
            minimax_strategy = np.argmin(column_maxima)
            
            return minimax_strategy, minimax
    
    def build_payoff_matrix(self):
        """构建支付矩阵"""
        # 根据博弈类型构建支付矩阵
        if self.game_type == "prisoners_dilemma":
            # 囚徒困境
            return np.array([[[3, 3], [0, 5]], [[5, 0], [1, 1]]])
        elif self.game_type == "battle_of_sexes":
            # 性别战
            return np.array([[[2, 1], [0, 0]], [[0, 0], [1, 2]]])
        elif self.game_type == "chicken":
            # 懦夫博弈
            return np.array([[[3, 3], [1, 4]], [[4, 1], [0, 0]]])
        elif self.game_type == "coordination":
            # 协调博弈
            return np.array([[[1, 1], [0, 0]], [[0, 0], [1, 1]]])
        else:
            # 默认支付矩阵
            return np.array([[[3, 3], [0, 5]], [[5, 0], [1, 1]]])

class CooperativeGame(Game):
    def __init__(self, players, strategies, payoffs):
        """合作博弈"""
        super().__init__(players, strategies, payoffs)
        self.coalitions = self.generate_coalitions()
    
    def generate_coalitions(self):
        """生成所有可能的联盟"""
        from itertools import combinations
        
        coalitions = []
        for i in range(1, self.n_players + 1):
            coalitions.extend(list(combinations(range(self.n_players), i)))
        
        return coalitions
    
    def characteristic_function(self, coalition):
        """特征函数"""
        # 基于联盟结构和博弈类型计算特征函数值
        
        if not coalition:
            return 0
        
        # 计算联盟的总价值
        total_value = 0
        
        # 基于联盟大小的基础价值
        base_value = len(coalition) * 10
        
        # 考虑联盟内部的协同效应
        synergy_bonus = self.calculate_synergy_bonus(coalition)
        
        # 考虑联盟外部的竞争效应
        competition_penalty = self.calculate_competition_penalty(coalition)
        
        total_value = base_value + synergy_bonus - competition_penalty
        
        return max(0, total_value)  # 确保非负
    
    def calculate_synergy_bonus(self, coalition):
        """计算协同效应奖励"""
        if len(coalition) <= 1:
            return 0
        
        # 基于联盟成员之间的互补性计算协同效应
        synergy = 0
        for i, player1 in enumerate(coalition):
            for j, player2 in enumerate(coalition[i+1:], i+1):
                # 计算两个玩家之间的协同效应
                player_synergy = self.get_player_synergy(player1, player2)
                synergy += player_synergy
        
        return synergy
    
    def calculate_competition_penalty(self, coalition):
        """计算竞争效应惩罚"""
        # 基于联盟外部的竞争强度计算惩罚
        outside_players = [p for p in range(self.n_players) if p not in coalition]
        
        if not outside_players:
            return 0
        
        # 计算外部竞争强度
        competition_intensity = len(outside_players) * 2
        
        # 考虑联盟大小对竞争的影响
        size_factor = len(coalition) / self.n_players
        
        return competition_intensity * size_factor
    
    def get_player_synergy(self, player1, player2):
        """获取两个玩家之间的协同效应"""
        # 基于玩家特征计算协同效应
        # 这里可以根据具体的博弈类型定制
        return 5  # 基础协同效应值
    
    def find_core(self):
        """寻找核"""
        # 核是所有满足个体理性和集体理性的分配
        
        core_allocations = []
        
        # 生成所有可能的分配
        all_allocations = self.generate_all_allocations()
        
        for allocation in all_allocations:
            if self.is_in_core(allocation):
                core_allocations.append(allocation)
        
        return core_allocations
    
    def generate_all_allocations(self):
        """生成所有可能的分配"""
        # 使用网格搜索生成分配
        # 为了计算效率，使用离散化
        step = 1.0
        max_value = max(self.characteristic_function(coalition) for coalition in self.coalitions)
        
        allocations = []
        
        # 生成满足效率条件的分配
        for i in range(int(max_value / step) + 1):
            for j in range(int(max_value / step) + 1):
                for k in range(int(max_value / step) + 1):
                    allocation = [i * step, j * step, k * step]
                    
                    # 检查效率条件
                    if sum(allocation) <= self.characteristic_function(tuple(range(self.n_players))):
                        allocations.append(allocation)
        
        return allocations
    
    def is_in_core(self, allocation):
        """检查分配是否在核中"""
        # 检查个体理性
        for i in range(self.n_players):
            if allocation[i] < self.characteristic_function((i,)):
                return False
        
        # 检查集体理性
        for coalition in self.coalitions:
            if len(coalition) > 1:  # 跳过单人联盟
                coalition_value = sum(allocation[i] for i in coalition)
                if coalition_value < self.characteristic_function(coalition):
                    return False
        
        return True
    
    def find_shapley_value(self):
        """计算Shapley值"""
        shapley_values = [0] * self.n_players
        
        for player in range(self.n_players):
            for coalition in self.coalitions:
                if player in coalition:
                    # 计算边际贡献
                    coalition_without_player = tuple(p for p in coalition if p != player)
                    marginal_contribution = self.characteristic_function(coalition) - \
                                         self.characteristic_function(coalition_without_player)
                    
                    # 计算权重
                    weight = len(coalition) * len([c for c in self.coalitions if player in c])
                    
                    shapley_values[player] += marginal_contribution / weight
        
        return shapley_values
```

## 2. 策略型博弈

### 2.1 策略型博弈表示

```python
class StrategicGame(Game):
    def __init__(self, players, strategies, payoffs):
        """策略型博弈"""
        super().__init__(players, strategies, payoffs)
        self.payoff_matrix = self.build_payoff_matrix()
    
    def build_payoff_matrix(self):
        """构建支付矩阵"""
        # 根据博弈类型和策略构建支付矩阵
        
        if self.n_players == 2:
            # 双人博弈
            n_strategies_1 = len(self.strategies[0])
            n_strategies_2 = len(self.strategies[1])
            
            payoff_matrix = np.zeros((n_strategies_1, n_strategies_2, 2))
            
            for i, strategy1 in enumerate(self.strategies[0]):
                for j, strategy2 in enumerate(self.strategies[1]):
                    strategy_profile = (strategy1, strategy2)
                    payoffs = self.get_payoff(strategy_profile)
                    payoff_matrix[i, j] = payoffs
            
            return payoff_matrix
        else:
            # 多人博弈
            strategy_counts = [len(strategies) for strategies in self.strategies]
            payoff_matrix = np.zeros(strategy_counts + [self.n_players])
            
            # 生成所有策略组合
            strategy_combinations = list(product(*self.strategies))
            
            for combination in strategy_combinations:
                payoffs = self.get_payoff(combination)
                
                # 将支付填入矩阵
                indices = []
                for i, strategy in enumerate(combination):
                    strategy_index = self.strategies[i].index(strategy)
                    indices.append(strategy_index)
                
                for player in range(self.n_players):
                    payoff_matrix[tuple(indices)][player] = payoffs[player]
            
            return payoff_matrix
    
    def find_pure_strategy_equilibria(self):
        """寻找纯策略均衡"""
        return self.find_nash_equilibria()
    
    def find_mixed_strategy_equilibria(self):
        """寻找混合策略均衡"""
        if self.n_players == 2:
            return self.find_two_player_mixed_equilibrium()
        else:
            return self.find_multi_player_mixed_equilibrium()
    
    def find_two_player_mixed_equilibrium(self):
        """寻找双人博弈的混合策略均衡"""
        equilibria = []
        
        # 使用线性规划求解混合策略均衡
        for player in range(2):
            other_player = 1 - player
            
            # 构建线性规划问题
            n_strategies = len(self.strategies[player])
            n_other_strategies = len(self.strategies[other_player])
            
            # 目标函数：最大化最小期望支付
            c = np.zeros(n_strategies + 1)  # 策略概率 + 期望支付
            c[-1] = 1  # 最大化期望支付
            
            # 约束条件
            A = np.zeros((n_other_strategies + 1, n_strategies + 1))
            b = np.zeros(n_other_strategies + 1)
            
            # 概率和为1的约束
            A[0, :n_strategies] = 1
            b[0] = 1
            
            # 期望支付约束
            for j, other_strategy in enumerate(self.strategies[other_player]):
                for i, strategy in enumerate(self.strategies[player]):
                    strategy_profile = (strategy, other_strategy) if player == 0 else (other_strategy, strategy)
                    payoff = self.get_payoff(strategy_profile)[player]
                    A[j+1, i] = payoff
                A[j+1, -1] = -1  # 期望支付变量
                b[j+1] = 0
            
            # 求解线性规划
            try:
                from scipy.optimize import linprog
                result = linprog(c, A_ub=A, b_ub=b, bounds=[(0, None)] * (n_strategies + 1))
                
                if result.success:
                    equilibrium = {
                        'player': player,
                        'probabilities': result.x[:n_strategies],
                        'expected_payoff': result.x[-1]
                    }
                    equilibria.append(equilibrium)
            except ImportError:
                # 如果没有scipy，使用简化算法
                equilibria.extend(self.simplified_mixed_equilibrium(player))
        
        return equilibria
    
    def simplified_mixed_equilibrium(self, player):
        """简化的混合策略均衡计算"""
        equilibria = []
        
        # 使用迭代算法
        n_strategies = len(self.strategies[player])
        probabilities = np.ones(n_strategies) / n_strategies  # 均匀分布
        
        for iteration in range(100):
            # 计算最佳响应
            best_responses = self.calculate_best_responses(player, probabilities)
            
            # 更新概率
            new_probabilities = np.zeros(n_strategies)
            for strategy_idx in best_responses:
                new_probabilities[strategy_idx] += 1
            new_probabilities /= len(best_responses)
            
            # 检查收敛
            if np.allclose(probabilities, new_probabilities, atol=1e-6):
                break
            
            probabilities = new_probabilities
        
        equilibrium = {
            'player': player,
            'probabilities': probabilities,
            'expected_payoff': self.calculate_expected_payoff(player, probabilities)
        }
        
        return [equilibrium]
    
    def calculate_best_responses(self, player, opponent_probabilities):
        """计算最佳响应"""
        best_responses = []
        best_payoff = float('-inf')
        
        for strategy_idx, strategy in enumerate(self.strategies[player]):
            expected_payoff = 0
            
            for other_strategy_idx, other_strategy in enumerate(self.strategies[1-player]):
                strategy_profile = (strategy, other_strategy) if player == 0 else (other_strategy, strategy)
                payoff = self.get_payoff(strategy_profile)[player]
                expected_payoff += opponent_probabilities[other_strategy_idx] * payoff
            
            if expected_payoff > best_payoff:
                best_payoff = expected_payoff
                best_responses = [strategy_idx]
            elif expected_payoff == best_payoff:
                best_responses.append(strategy_idx)
        
        return best_responses
    
    def calculate_expected_payoff(self, player, probabilities):
        """计算期望支付"""
        expected_payoff = 0
        
        for strategy_idx, strategy in enumerate(self.strategies[player]):
            strategy_prob = probabilities[strategy_idx]
            
            for other_strategy in self.strategies[1-player]:
                strategy_profile = (strategy, other_strategy) if player == 0 else (other_strategy, strategy)
                payoff = self.get_payoff(strategy_profile)[player]
                expected_payoff += strategy_prob * payoff
        
        return expected_payoff
    
    def find_multi_player_mixed_equilibrium(self):
        """寻找多人博弈的混合策略均衡"""
        # 使用迭代算法寻找多人博弈的混合策略均衡
        equilibria = []
        
        for player in range(self.n_players):
            equilibrium = self.find_player_mixed_equilibrium(player)
            equilibria.append(equilibrium)
        
        return equilibria
    
    def find_player_mixed_equilibrium(self, player):
        """寻找单个玩家的混合策略均衡"""
        n_strategies = len(self.strategies[player])
        probabilities = np.ones(n_strategies) / n_strategies
        
        for iteration in range(50):
            # 计算给定其他玩家策略下的最佳响应
            best_responses = self.calculate_multi_player_best_responses(player, probabilities)
            
            # 更新概率
            new_probabilities = np.zeros(n_strategies)
            for strategy_idx in best_responses:
                new_probabilities[strategy_idx] += 1
            new_probabilities /= len(best_responses)
            
            if np.allclose(probabilities, new_probabilities, atol=1e-6):
                break
            
            probabilities = new_probabilities
        
        return {
            'player': player,
            'probabilities': probabilities,
            'expected_payoff': self.calculate_multi_player_expected_payoff(player, probabilities)
        }
    
    def calculate_multi_player_best_responses(self, player, probabilities):
        """计算多人博弈中的最佳响应"""
        best_responses = []
        best_payoff = float('-inf')
        
        for strategy_idx, strategy in enumerate(self.strategies[player]):
            expected_payoff = self.calculate_multi_player_expected_payoff(player, [strategy_idx])
            
            if expected_payoff > best_payoff:
                best_payoff = expected_payoff
                best_responses = [strategy_idx]
            elif expected_payoff == best_payoff:
                best_responses.append(strategy_idx)
        
        return best_responses
    
    def calculate_multi_player_expected_payoff(self, player, strategy_indices):
        """计算多人博弈中的期望支付"""
        expected_payoff = 0
        
        # 生成所有其他玩家的策略组合
        other_players = [i for i in range(self.n_players) if i != player]
        other_strategies = [self.strategies[i] for i in other_players]
        
        for strategy_combination in product(*other_strategies):
            # 构建完整的策略组合
            full_strategy_profile = list(strategy_combination)
            full_strategy_profile.insert(player, self.strategies[player][strategy_indices[0]])
            full_strategy_profile = tuple(full_strategy_profile)
            
            payoff = self.get_payoff(full_strategy_profile)[player]
            expected_payoff += payoff
        
        return expected_payoff / len(list(product(*other_strategies)))
    
    def best_response_correspondence(self, player, opponent_strategies):
        """最佳响应对应"""
        best_responses = []
        best_payoff = float('-inf')
        
        for strategy in self.strategies[player]:
            # 构建策略组合
            strategy_profile = list(opponent_strategies)
            strategy_profile.insert(player, strategy)
            strategy_profile = tuple(strategy_profile)
            
            payoff = self.get_payoff(strategy_profile)[player]
            if payoff > best_payoff:
                best_payoff = payoff
                best_responses = [strategy]
            elif payoff == best_payoff:
                best_responses.append(strategy)
        
        return best_responses
    
    def is_strictly_dominated(self, player, strategy):
        """检查是否为严格被占优策略"""
        for other_strategy in self.strategies[player]:
            if other_strategy != strategy:
                # 检查other_strategy是否严格占优strategy
                is_dominant = True
                for opponent_strategies in product(*[self.strategies[i] for i in range(self.n_players) if i != player]):
                    strategy_profile_with_strategy = list(opponent_strategies)
                    strategy_profile_with_strategy.insert(player, strategy)
                    strategy_profile_with_strategy = tuple(strategy_profile_with_strategy)
                    
                    strategy_profile_with_other = list(opponent_strategies)
                    strategy_profile_with_other.insert(player, other_strategy)
                    strategy_profile_with_other = tuple(strategy_profile_with_other)
                    
                    if self.get_payoff(strategy_profile_with_strategy)[player] >= \
                       self.get_payoff(strategy_profile_with_other)[player]:
                        is_dominant = False
                        break
                
                if is_dominant:
                    return True
        
        return False
    
    def iterated_elimination_of_dominated_strategies(self):
        """迭代消除被占优策略"""
        eliminated_strategies = {player: set() for player in range(self.n_players)}
        
        while True:
            eliminated_this_round = False
            
            for player in range(self.n_players):
                remaining_strategies = [s for s in self.strategies[player] 
                                     if s not in eliminated_strategies[player]]
                
                for strategy in remaining_strategies:
                    if self.is_strictly_dominated(player, strategy):
                        eliminated_strategies[player].add(strategy)
                        eliminated_this_round = True
            
            if not eliminated_this_round:
                break
        
        return eliminated_strategies
```

### 2.2 博弈分析工具

```python
class GameAnalysis:
    def __init__(self, game):
        self.game = game
    
    def comprehensive_analysis(self):
        """综合分析"""
        analysis = {}
        
        # 纳什均衡
        analysis['nash_equilibria'] = self.game.find_nash_equilibria()
        
        # 占优策略
        analysis['dominant_strategies'] = self.game.find_dominant_strategies()
        
        # 被占优策略
        if isinstance(self.game, StrategicGame):
            analysis['dominated_strategies'] = self.game.iterated_elimination_of_dominated_strategies()
        
        # 帕累托最优
        analysis['pareto_optimal'] = self.find_pareto_optimal()
        
        # 社会最优
        analysis['social_optimal'] = self.find_social_optimal()
        
        return analysis
    
    def find_pareto_optimal(self):
        """寻找帕累托最优"""
        pareto_optimal = []
        strategy_combinations = list(product(*self.game.strategies))
        
        for strategy_profile in strategy_combinations:
            is_pareto_optimal = True
            current_payoffs = self.game.get_payoff(strategy_profile)
            
            for other_profile in strategy_combinations:
                if other_profile != strategy_profile:
                    other_payoffs = self.game.get_payoff(other_profile)
                    
                    # 检查是否存在帕累托改进
                    if all(other_payoffs[i] >= current_payoffs[i] for i in range(self.game.n_players)) and \
                       any(other_payoffs[i] > current_payoffs[i] for i in range(self.game.n_players)):
                        is_pareto_optimal = False
                        break
            
            if is_pareto_optimal:
                pareto_optimal.append(strategy_profile)
        
        return pareto_optimal
    
    def find_social_optimal(self):
        """寻找社会最优"""
        strategy_combinations = list(product(*self.game.strategies))
        best_social_welfare = float('-inf')
        social_optimal = []
        
        for strategy_profile in strategy_combinations:
            payoffs = self.game.get_payoff(strategy_profile)
            social_welfare = sum(payoffs)
            
            if social_welfare > best_social_welfare:
                best_social_welfare = social_welfare
                social_optimal = [strategy_profile]
            elif social_welfare == best_social_welfare:
                social_optimal.append(strategy_profile)
        
        return social_optimal
    
    def efficiency_analysis(self):
        """效率分析"""
        nash_equilibria = self.game.find_nash_equilibria()
        social_optimal = self.find_social_optimal()
        
        efficiency_measures = {}
        
        for equilibrium in nash_equilibria:
            equilibrium_payoffs = self.game.get_payoff(equilibrium)
            equilibrium_welfare = sum(equilibrium_payoffs)
            
            # 计算效率
            max_welfare = sum(self.game.get_payoff(social_optimal[0]))
            efficiency = equilibrium_welfare / max_welfare if max_welfare > 0 else 0
            
            efficiency_measures[equilibrium] = {
                'welfare': equilibrium_welfare,
                'efficiency': efficiency,
                'payoffs': equilibrium_payoffs
            }
        
        return efficiency_measures
```

## 3. 扩展型博弈

### 3.1 扩展型博弈表示

```python
class ExtensiveGame:
    def __init__(self, players, game_tree):
        """
        扩展型博弈
        players: 玩家列表
        game_tree: 博弈树
        """
        self.players = players
        self.game_tree = game_tree
        self.n_players = len(players)
        
    def find_subgame_perfect_equilibria(self):
        """寻找子博弈完美均衡"""
        # 使用逆向归纳法
        equilibria = self.backward_induction()
        return equilibria
    
    def backward_induction(self):
        """逆向归纳法"""
        equilibrium_actions = {}
        
        # 从叶子节点开始，向上计算最优行动
        leaf_nodes = self.game_tree.get_leaf_nodes()
        
        # 为每个叶子节点计算最优行动
        for leaf in leaf_nodes:
            if leaf.payoffs:
                best_action = leaf.get_optimal_action()
                if best_action:
                    equilibrium_actions[leaf] = best_action
        
        # 向上传播最优行动
        self.propagate_optimal_actions(self.game_tree.root, equilibrium_actions)
        
        return equilibrium_actions
    
    def propagate_optimal_actions(self, node, equilibrium_actions):
        """传播最优行动"""
        if node.is_leaf():
            return
        
        # 递归处理子节点
        for child in node.children:
            self.propagate_optimal_actions(child, equilibrium_actions)
        
        # 计算当前节点的最优行动
        best_action = node.get_optimal_action()
        if best_action:
            equilibrium_actions[node] = best_action
    
    def find_nash_equilibria(self):
        """寻找纳什均衡"""
        # 将扩展型博弈转换为策略型博弈
        strategic_form = self.convert_to_strategic_form()
        return strategic_form.find_nash_equilibria()
    
    def convert_to_strategic_form(self):
        """转换为策略型博弈"""
        # 收集所有策略组合
        strategies = self.collect_all_strategies()
        
        # 构建支付矩阵
        payoff_matrix = self.build_payoff_matrix(strategies)
        
        # 创建策略型博弈
        strategic_game = StrategicGame(
            players=self.players,
            strategies=strategies,
            payoff_matrix=payoff_matrix
        )
        
        return strategic_game
    
    def collect_all_strategies(self):
        """收集所有策略"""
        strategies = []
        for player in self.players:
            player_strategies = self.collect_player_strategies(player)
            strategies.append(player_strategies)
        return strategies
    
    def collect_player_strategies(self, player):
        """收集玩家的策略"""
        strategies = []
        self.collect_strategies_from_node(self.game_tree.root, player, [], strategies)
        return strategies
    
    def collect_strategies_from_node(self, node, player, current_strategy, strategies):
        """从节点收集策略"""
        if node.player == player:
            # 为当前玩家添加行动选择
            for i, action in enumerate(node.actions):
                new_strategy = current_strategy + [(node, action)]
                self.collect_strategies_from_children(node.children[i], player, new_strategy, strategies)
        else:
            # 为其他玩家继续收集
            for child in node.children:
                self.collect_strategies_from_node(child, player, current_strategy, strategies)
    
    def collect_strategies_from_children(self, node, player, current_strategy, strategies):
        """从子节点收集策略"""
        if node.is_leaf():
            strategies.append(current_strategy)
        else:
            self.collect_strategies_from_node(node, player, current_strategy, strategies)
    
    def build_payoff_matrix(self, strategies):
        """构建支付矩阵"""
        payoff_matrix = {}
        
        # 生成所有策略组合
        strategy_combinations = self.generate_strategy_combinations(strategies)
        
        for combination in strategy_combinations:
            payoffs = self.calculate_payoffs_for_combination(combination)
            payoff_matrix[combination] = payoffs
        
        return payoff_matrix
    
    def generate_strategy_combinations(self, strategies):
        """生成策略组合"""
        from itertools import product
        return list(product(*strategies))
    
    def calculate_payoffs_for_combination(self, strategy_combination):
        """计算策略组合的支付"""
        # 模拟博弈执行
        current_node = self.game_tree.root
        payoffs = [0] * len(self.players)
        
        while not current_node.is_leaf():
            player = current_node.player
            strategy = strategy_combination[player]
            
            # 找到对应的行动
            action = self.find_action_for_strategy(current_node, strategy)
            
            # 移动到下一个节点
            current_node = self.find_next_node(current_node, action)
        
        # 获取最终支付
        if current_node.payoffs:
            payoffs = current_node.payoffs
        
        return payoffs
    
    def find_action_for_strategy(self, node, strategy):
        """根据策略找到行动"""
        for node_action, action in strategy:
            if node_action == node:
                return action
        return None
    
    def find_next_node(self, node, action):
        """找到下一个节点"""
        for i, node_action in enumerate(node.actions):
            if node_action == action:
                return node.children[i]
        return node.children[0]  # 默认选择第一个子节点

class GameTree:
    def __init__(self, root):
        """
        博弈树
        root: 根节点
        """
        self.root = root
        
    def get_all_nodes(self):
        """获取所有节点"""
        nodes = []
        self.collect_nodes(self.root, nodes)
        return nodes
    
    def collect_nodes(self, node, nodes):
        """收集节点"""
        nodes.append(node)
        for child in node.children:
            self.collect_nodes(child, nodes)
    
    def get_leaf_nodes(self):
        """获取叶子节点"""
        leaf_nodes = []
        self.collect_leaf_nodes(self.root, leaf_nodes)
        return leaf_nodes
    
    def collect_leaf_nodes(self, node, leaf_nodes):
        """收集叶子节点"""
        if not node.children:
            leaf_nodes.append(node)
        else:
            for child in node.children:
                self.collect_leaf_nodes(child, leaf_nodes)

class GameNode:
    def __init__(self, player, actions=None, payoffs=None):
        """
        博弈节点
        player: 玩家
        actions: 可用行动
        payoffs: 支付
        """
        self.player = player
        self.actions = actions or []
        self.payoffs = payoffs
        self.children = []
        
    def add_child(self, child):
        """添加子节点"""
        self.children.append(child)
    
    def is_leaf(self):
        """是否为叶子节点"""
        return len(self.children) == 0
    
    def get_optimal_action(self):
        """获取最优行动"""
        if self.is_leaf():
            return None
        
        best_action = None
        best_payoff = float('-inf')
        
        for i, child in enumerate(self.children):
            if child.payoffs and child.payoffs[self.player] > best_payoff:
                best_payoff = child.payoffs[self.player]
                best_action = self.actions[i]
        
        return best_action
```

### 3.2 动态博弈

```python
class DynamicGame(ExtensiveGame):
    def __init__(self, players, game_tree, discount_factor=1.0):
        """动态博弈"""
        super().__init__(players, game_tree)
        self.discount_factor = discount_factor
    
    def find_subgame_perfect_equilibrium(self):
        """寻找子博弈完美均衡"""
        return self.backward_induction()
    
    def backward_induction(self):
        """逆向归纳法"""
        equilibrium_actions = {}
        
        # 从叶子节点开始，向上计算最优行动
        leaf_nodes = self.game_tree.get_leaf_nodes()
        
        # 为每个叶子节点计算最优行动
        for leaf in leaf_nodes:
            if leaf.payoffs:
                best_action = leaf.get_optimal_action()
                if best_action:
                    equilibrium_actions[leaf] = best_action
        
        # 向上传播最优行动
        self.propagate_optimal_actions(self.game_tree.root, equilibrium_actions)
        
        return equilibrium_actions
    
    def propagate_optimal_actions(self, node, equilibrium_actions):
        """传播最优行动"""
        if node.is_leaf():
            return
        
        # 递归处理子节点
        for child in node.children:
            self.propagate_optimal_actions(child, equilibrium_actions)
        
        # 计算当前节点的最优行动
        best_action = node.get_optimal_action()
        if best_action:
            equilibrium_actions[node] = best_action
    
    def calculate_present_value(self, payoffs, period):
        """计算现值"""
        return [payoff * (self.discount_factor ** period) for payoff in payoffs]
    
    def find_stationary_equilibrium(self):
        """寻找稳态均衡"""
        # 使用迭代方法寻找稳态均衡
        max_iterations = 1000
        tolerance = 1e-6
        
        # 初始化策略分布
        n_players = len(self.players)
        strategy_distributions = []
        for player in self.players:
            n_strategies = len(self.get_player_strategies(player))
            distribution = np.ones(n_strategies) / n_strategies
            strategy_distributions.append(distribution)
        
        # 迭代更新策略分布
        for iteration in range(max_iterations):
            old_distributions = [dist.copy() for dist in strategy_distributions]
            
            # 更新每个玩家的策略分布
            for player_idx in range(n_players):
                strategy_distributions[player_idx] = self.update_player_strategy(
                    player_idx, strategy_distributions
                )
            
            # 检查收敛性
            converged = True
            for i in range(n_players):
                if np.max(np.abs(strategy_distributions[i] - old_distributions[i])) > tolerance:
                    converged = False
                    break
            
            if converged:
                break
        
        return {
            'strategy_distributions': strategy_distributions,
            'iterations': iteration + 1,
            'converged': converged
        }
    
    def update_player_strategy(self, player_idx, strategy_distributions):
        """更新玩家策略分布"""
        # 计算期望支付
        expected_payoffs = self.calculate_expected_payoffs(player_idx, strategy_distributions)
        
        # 使用softmax更新策略分布
        temperature = 0.1
        exp_payoffs = np.exp(expected_payoffs / temperature)
        new_distribution = exp_payoffs / np.sum(exp_payoffs)
        
        return new_distribution
    
    def calculate_expected_payoffs(self, player_idx, strategy_distributions):
        """计算期望支付"""
        n_strategies = len(self.get_player_strategies(player_idx))
        expected_payoffs = np.zeros(n_strategies)
        
        # 计算每个策略的期望支付
        for strategy_idx in range(n_strategies):
            payoff = 0
            total_prob = 0
            
            # 遍历所有可能的对手策略组合
            opponent_combinations = self.generate_opponent_combinations(player_idx, strategy_distributions)
            
            for opponent_combo, prob in opponent_combinations:
                strategy_profile = list(opponent_combo)
                strategy_profile.insert(player_idx, strategy_idx)
                
                game_payoff = self.get_payoff_for_strategy_profile(strategy_profile)
                payoff += game_payoff[player_idx] * prob
                total_prob += prob
            
            if total_prob > 0:
                expected_payoffs[strategy_idx] = payoff / total_prob
        
        return expected_payoffs
    
    def generate_opponent_combinations(self, player_idx, strategy_distributions):
        """生成对手策略组合"""
        from itertools import product
        
        opponent_players = [i for i in range(len(self.players)) if i != player_idx]
        opponent_distributions = [strategy_distributions[i] for i in opponent_players]
        
        combinations = []
        for strategy_combo in product(*[range(len(dist)) for dist in opponent_distributions]):
            prob = 1.0
            for i, strategy_idx in enumerate(strategy_combo):
                prob *= opponent_distributions[i][strategy_idx]
            combinations.append((strategy_combo, prob))
        
        return combinations
    
    def get_player_strategies(self, player):
        """获取玩家的策略"""
        # 基于博弈结构生成策略
        strategies = []
        
        # 根据玩家类型生成不同策略
        if player == 0:  # 玩家1
            strategies = ['Cooperate', 'Defect', 'TitForTat', 'Pavlov']
        elif player == 1:  # 玩家2
            strategies = ['Cooperate', 'Defect', 'TitForTat', 'Pavlov']
        else:
            # 对于更多玩家，生成通用策略
            strategies = [f'Strategy_{i}' for i in range(len(self.game.strategies[player]))]
        
        return strategies
    
    def get_payoff_for_strategy_profile(self, strategy_profile):
        """获取策略组合的支付"""
        # 基于策略组合计算支付
        payoffs = []
        
        for player in range(len(self.players)):
            strategy = strategy_profile[player]
            
            # 根据策略类型计算支付
            if strategy == 'Cooperate':
                base_payoff = 3
            elif strategy == 'Defect':
                base_payoff = 5
            elif strategy == 'TitForTat':
                base_payoff = 4
            elif strategy == 'Pavlov':
                base_payoff = 3.5
            else:
                base_payoff = np.random.uniform(2, 6)
            
            # 考虑策略互动效应
            interaction_bonus = 0
            for other_player in range(len(self.players)):
                if other_player != player:
                    other_strategy = strategy_profile[other_player]
                    
                    # 计算策略互动
                    if strategy == 'Cooperate' and other_strategy == 'Cooperate':
                        interaction_bonus += 1
                    elif strategy == 'Defect' and other_strategy == 'Cooperate':
                        interaction_bonus += 2
                    elif strategy == 'TitForTat' and other_strategy == 'Cooperate':
                        interaction_bonus += 0.5
            
            final_payoff = base_payoff + interaction_bonus
            payoffs.append(final_payoff)
        
        return payoffs
```

## 4. 纳什均衡

### 4.1 纳什均衡计算

```python
class NashEquilibrium:
    def __init__(self, game):
        self.game = game
    
    def find_all_equilibria(self):
        """寻找所有纳什均衡"""
        equilibria = {
            'pure_strategy': self.find_pure_strategy_equilibria(),
            'mixed_strategy': self.find_mixed_strategy_equilibria()
        }
        return equilibria
    
    def find_pure_strategy_equilibria(self):
        """寻找纯策略纳什均衡"""
        return self.game.find_nash_equilibria()
    
    def find_mixed_strategy_equilibria(self):
        """寻找混合策略纳什均衡"""
        equilibria = []
        
        # 对于2x2博弈，使用解析方法
        if self.game.n_players == 2 and len(self.game.strategies[0]) == 2 and len(self.game.strategies[1]) == 2:
            mixed_eq = MixedStrategyEquilibrium(self.game)
            equilibrium = mixed_eq.solve_2x2_game()
            equilibria.append(equilibrium)
        else:
            # 对于更复杂的博弈，使用数值方法
            equilibria = self.find_mixed_equilibria_numerical()
        
        return equilibria
    
    def find_mixed_equilibria_numerical(self):
        """使用数值方法寻找混合策略均衡"""
        from scipy.optimize import minimize
        
        equilibria = []
        n_players = self.game.n_players
        
        # 为每个玩家定义策略空间
        strategy_spaces = []
        for player in range(n_players):
            n_strategies = len(self.game.strategies[player])
            strategy_spaces.append(n_strategies - 1)  # 自由度
        
        # 定义目标函数：最小化偏离均衡的激励
        def objective_function(strategy_vector):
            # 将向量转换为策略分布
            distributions = self.vector_to_distributions(strategy_vector, strategy_spaces)
            
            # 计算每个玩家的最优响应
            total_deviation = 0
            for player in range(n_players):
                best_response = self.find_best_response(player, distributions)
                current_payoff = self.calculate_player_payoff(player, distributions)
                deviation = best_response - current_payoff
                total_deviation += abs(deviation)
            
            return total_deviation
        
        # 多次优化，寻找不同的均衡
        for attempt in range(10):
            # 随机初始点
            initial_point = np.random.random(sum(strategy_spaces))
            
            # 约束条件：概率和为1
            constraints = []
            for i in range(n_players):
                start_idx = sum(strategy_spaces[:i])
                end_idx = start_idx + strategy_spaces[i]
                
                def constraint_fun(x, start=start_idx, end=end_idx):
                    return np.sum(x[start:end]) - 1.0
                
                constraints.append({'type': 'eq', 'fun': constraint_fun})
            
            # 边界条件：概率在[0,1]之间
            bounds = [(0, 1)] * sum(strategy_spaces)
            
            # 优化
            result = minimize(
                objective_function, 
                initial_point, 
                method='SLSQP',
                bounds=bounds,
                constraints=constraints
            )
            
            if result.success and result.fun < 1e-6:
                distributions = self.vector_to_distributions(result.x, strategy_spaces)
                equilibria.append({
                    'distributions': distributions,
                    'deviation': result.fun
                })
        
        return equilibria
    
    def vector_to_distributions(self, vector, strategy_spaces):
        """将向量转换为策略分布"""
        distributions = []
        start_idx = 0
        
        for i, n_strategies in enumerate(strategy_spaces):
            end_idx = start_idx + n_strategies
            player_dist = vector[start_idx:end_idx]
            
            # 添加最后一个概率（确保和为1）
            last_prob = 1.0 - np.sum(player_dist)
            player_dist = np.append(player_dist, last_prob)
            
            distributions.append(player_dist)
            start_idx = end_idx
        
        return distributions
    
    def find_best_response(self, player, distributions):
        """寻找玩家的最优响应"""
        n_strategies = len(self.game.strategies[player])
        best_payoff = float('-inf')
        
        for strategy in range(n_strategies):
            # 临时修改分布
            temp_distributions = [dist.copy() for dist in distributions]
            temp_distributions[player] = np.zeros(n_strategies)
            temp_distributions[player][strategy] = 1.0
            
            payoff = self.calculate_player_payoff(player, temp_distributions)
            best_payoff = max(best_payoff, payoff)
        
        return best_payoff
    
    def calculate_player_payoff(self, player, distributions):
        """计算玩家的期望支付"""
        payoff = 0
        n_players = len(distributions)
        
        # 遍历所有策略组合
        from itertools import product
        strategy_ranges = [range(len(dist)) for dist in distributions]
        
        for strategy_combo in product(*strategy_ranges):
            prob = 1.0
            for i, strategy in enumerate(strategy_combo):
                prob *= distributions[i][strategy]
            
            game_payoff = self.game.get_payoff(strategy_combo)
            payoff += prob * game_payoff[player]
        
        return payoff
    
    def is_evolutionarily_stable(self, strategy_profile):
        """检查是否为演化稳定策略"""
        # 检查策略是否是对称纳什均衡
        if not self.is_symmetric_nash_equilibrium(strategy_profile):
            return False
        
        # 检查演化稳定性条件
        return self.check_evolutionary_stability_condition(strategy_profile)
    
    def is_symmetric_nash_equilibrium(self, strategy_profile):
        """检查是否为对称纳什均衡"""
        # 检查是否所有玩家都使用相同策略
        if len(set(strategy_profile)) != 1:
            return False
        
        # 检查是否为纳什均衡
        strategy = strategy_profile[0]
        for player in range(self.game.n_players):
            if not self.is_best_response(player, strategy, strategy_profile):
                return False
        
        return True
    
    def is_best_response(self, player, strategy, strategy_profile):
        """检查策略是否为最优响应"""
        current_payoff = self.game.get_payoff(strategy_profile)[player]
        
        # 检查所有可能的偏离
        for alternative_strategy in self.game.strategies[player]:
            if alternative_strategy == strategy:
                continue
            
            # 构造偏离后的策略组合
            deviated_profile = list(strategy_profile)
            deviated_profile[player] = alternative_strategy
            
            deviated_payoff = self.game.get_payoff(deviated_profile)[player]
            
            if deviated_payoff > current_payoff:
                return False
        
        return True
    
    def check_evolutionary_stability_condition(self, strategy_profile):
        """检查演化稳定性条件"""
        strategy = strategy_profile[0]
        
        # 对于所有可能的突变策略
        for mutant_strategy in self.game.strategies[0]:
            if mutant_strategy == strategy:
                continue
            
            # 检查稳定性条件
            if not self.is_evolutionarily_stable_against_mutant(strategy, mutant_strategy):
                return False
        
        return True
    
    def is_evolutionarily_stable_against_mutant(self, incumbent_strategy, mutant_strategy):
        """检查对特定突变策略的演化稳定性"""
        # 计算种群中突变者的比例阈值
        threshold = self.calculate_invasion_threshold(incumbent_strategy, mutant_strategy)
        
        # 如果阈值存在且为正，则策略是演化稳定的
        return threshold is not None and threshold > 0
    
    def calculate_invasion_threshold(self, incumbent_strategy, mutant_strategy):
        """计算入侵阈值"""
        # 计算期望支付
        incumbent_vs_incumbent = self.calculate_pairwise_payoff(incumbent_strategy, incumbent_strategy)
        incumbent_vs_mutant = self.calculate_pairwise_payoff(incumbent_strategy, mutant_strategy)
        mutant_vs_incumbent = self.calculate_pairwise_payoff(mutant_strategy, incumbent_strategy)
        mutant_vs_mutant = self.calculate_pairwise_payoff(mutant_strategy, mutant_strategy)
        
        # 计算入侵阈值
        numerator = incumbent_vs_incumbent - mutant_vs_incumbent
        denominator = (mutant_vs_mutant - mutant_vs_incumbent) - (incumbent_vs_mutant - incumbent_vs_incumbent)
        
        if abs(denominator) < 1e-10:
            # 分母接近零，检查分子
            if numerator > 0:
                return float('inf')  # 总是稳定
            else:
                return None  # 不稳定
        
        threshold = numerator / denominator
        return threshold if 0 < threshold < 1 else None
    
    def calculate_pairwise_payoff(self, strategy1, strategy2):
        """计算两个策略之间的支付"""
        # 构造策略组合
        strategy_profile = [strategy1, strategy2]
        
        # 获取支付
        payoffs = self.game.get_payoff(strategy_profile)
        
        # 返回第一个玩家的支付（对称博弈）
        return payoffs[0]
    
    def find_evolutionarily_stable_strategies(self):
        """寻找演化稳定策略"""
        stable_strategies = []
        
        # 检查所有可能的策略
        for strategy in self.game.strategies[0]:
            # 构造对称策略组合
            strategy_profile = [strategy] * self.game.n_players
            
            # 检查是否为演化稳定策略
            if self.is_evolutionarily_stable(strategy_profile):
                stable_strategies.append({
                    'strategy': strategy,
                    'profile': strategy_profile,
                    'stability_analysis': self.analyze_stability(strategy)
                })
        
        return stable_strategies
    
    def analyze_stability(self, strategy):
        """分析策略的稳定性"""
        analysis = {
            'nash_equilibrium': self.is_symmetric_nash_equilibrium([strategy] * self.game.n_players),
            'evolutionarily_stable': self.is_evolutionarily_stable([strategy] * self.game.n_players),
            'invasion_thresholds': {},
            'fitness_landscape': self.calculate_fitness_landscape(strategy)
        }
        
        # 计算对所有突变策略的入侵阈值
        for mutant_strategy in self.game.strategies[0]:
            if mutant_strategy != strategy:
                threshold = self.calculate_invasion_threshold(strategy, mutant_strategy)
                analysis['invasion_thresholds'][mutant_strategy] = threshold
        
        return analysis
    
    def calculate_fitness_landscape(self, strategy):
        """计算适应度景观"""
        landscape = {}
        
        # 计算在不同种群组成下的适应度
        for population_composition in self.generate_population_compositions():
            fitness = self.calculate_fitness_in_population(strategy, population_composition)
            landscape[population_composition] = fitness
        
        return landscape
    
    def generate_population_compositions(self):
        """生成种群组成"""
        compositions = []
        n_strategies = len(self.game.strategies[0])
        
        # 生成不同比例的种群组成
        for proportions in self.generate_proportions(n_strategies):
            compositions.append(proportions)
        
        return compositions
    
    def generate_proportions(self, n_strategies, step=0.1):
        """生成比例组合"""
        from itertools import product
        
        proportions = []
        for values in product(np.arange(0, 1.01, step), repeat=n_strategies-1):
            if sum(values) <= 1:
                # 添加最后一个比例
                last_proportion = 1 - sum(values)
                if last_proportion >= 0:
                    full_proportions = list(values) + [last_proportion]
                    proportions.append(full_proportions)
        
        return proportions
    
    def calculate_fitness_in_population(self, strategy, population_composition):
        """计算策略在种群中的适应度"""
        fitness = 0
        
        for i, proportion in enumerate(population_composition):
            if proportion > 0:
                other_strategy = self.game.strategies[0][i]
                pairwise_payoff = self.calculate_pairwise_payoff(strategy, other_strategy)
                fitness += proportion * pairwise_payoff
        
        return fitness
    
    def trembling_hand_perfect_equilibrium(self):
        """颤抖手完美均衡"""
        perfect_equilibria = []
        
        # 使用序列化方法寻找颤抖手完美均衡
        for epsilon in [0.1, 0.05, 0.01, 0.005, 0.001]:
            equilibrium = self.find_trembling_hand_equilibrium(epsilon)
            if equilibrium:
                perfect_equilibria.append(equilibrium)
        
        # 过滤掉重复的均衡
        unique_equilibria = self.filter_unique_equilibria(perfect_equilibria)
        
        return unique_equilibria
    
    def find_trembling_hand_equilibrium(self, epsilon):
        """寻找特定扰动水平下的颤抖手均衡"""
        from scipy.optimize import minimize
        
        n_players = self.game.n_players
        strategy_spaces = []
        
        # 为每个玩家定义策略空间
        for player in range(n_players):
            n_strategies = len(self.game.strategies[player])
            strategy_spaces.append(n_strategies - 1)
        
        # 定义目标函数：最小化偏离均衡的激励
        def objective_function(strategy_vector):
            distributions = self.vector_to_distributions(strategy_vector, strategy_spaces)
            
            # 添加扰动
            perturbed_distributions = self.add_trembling_hand_perturbation(distributions, epsilon)
            
            total_deviation = 0
            for player in range(n_players):
                best_response = self.find_best_response_with_perturbation(player, perturbed_distributions, epsilon)
                current_payoff = self.calculate_player_payoff_with_perturbation(player, perturbed_distributions)
                deviation = best_response - current_payoff
                total_deviation += abs(deviation)
            
            return total_deviation
        
        # 约束条件
        constraints = []
        for i in range(n_players):
            start_idx = sum(strategy_spaces[:i])
            end_idx = start_idx + strategy_spaces[i]
            
            def constraint_fun(x, start=start_idx, end=end_idx):
                return np.sum(x[start:end]) - 1.0
            
            constraints.append({'type': 'eq', 'fun': constraint_fun})
        
        # 边界条件：概率在[epsilon, 1]之间
        bounds = [(epsilon, 1)] * sum(strategy_spaces)
        
        # 多次优化
        for attempt in range(5):
            initial_point = np.random.uniform(epsilon, 1, sum(strategy_spaces))
            
            result = minimize(
                objective_function,
                initial_point,
                method='SLSQP',
                bounds=bounds,
                constraints=constraints
            )
            
            if result.success and result.fun < 1e-6:
                distributions = self.vector_to_distributions(result.x, strategy_spaces)
                return {
                    'distributions': distributions,
                    'epsilon': epsilon,
                    'deviation': result.fun
                }
        
        return None
    
    def add_trembling_hand_perturbation(self, distributions, epsilon):
        """添加颤抖手扰动"""
        perturbed_distributions = []
        
        for dist in distributions:
            n_strategies = len(dist)
            
            # 确保每个策略都有最小概率epsilon
            perturbed_dist = np.maximum(dist, epsilon / n_strategies)
            
            # 重新归一化
            perturbed_dist = perturbed_dist / np.sum(perturbed_dist)
            
            perturbed_distributions.append(perturbed_dist)
        
        return perturbed_distributions
    
    def find_best_response_with_perturbation(self, player, distributions, epsilon):
        """在扰动下寻找最优响应"""
        n_strategies = len(self.game.strategies[player])
        best_payoff = float('-inf')
        
        for strategy in range(n_strategies):
            # 临时修改分布
            temp_distributions = [dist.copy() for dist in distributions]
            
            # 设置最小概率
            temp_distributions[player] = np.full(n_strategies, epsilon / n_strategies)
            temp_distributions[player][strategy] = 1.0 - epsilon + epsilon / n_strategies
            
            payoff = self.calculate_player_payoff_with_perturbation(player, temp_distributions)
            best_payoff = max(best_payoff, payoff)
        
        return best_payoff
    
    def calculate_player_payoff_with_perturbation(self, player, distributions):
        """在扰动下计算玩家支付"""
        return self.calculate_player_payoff(player, distributions)
    
    def filter_unique_equilibria(self, equilibria):
        """过滤重复的均衡"""
        unique_equilibria = []
        tolerance = 1e-4
        
        for eq in equilibria:
            is_unique = True
            for existing_eq in unique_equilibria:
                if self.are_equilibria_similar(eq, existing_eq, tolerance):
                    is_unique = False
                    break
            
            if is_unique:
                unique_equilibria.append(eq)
        
        return unique_equilibria
    
    def are_equilibria_similar(self, eq1, eq2, tolerance):
        """检查两个均衡是否相似"""
        if 'distributions' not in eq1 or 'distributions' not in eq2:
            return False
        
        dist1 = eq1['distributions']
        dist2 = eq2['distributions']
        
        if len(dist1) != len(dist2):
            return False
        
        for i in range(len(dist1)):
            if not np.allclose(dist1[i], dist2[i], atol=tolerance):
                return False
        
        return True

class MixedStrategyEquilibrium:
    def __init__(self, game):
        self.game = game
    
    def solve_2x2_game(self):
        """求解2x2博弈的混合策略均衡"""
        if self.game.n_players != 2 or len(self.game.strategies[0]) != 2 or len(self.game.strategies[1]) != 2:
            raise ValueError("This method only works for 2x2 games")
        
        # 构建支付矩阵
        payoff_matrix = self.build_2x2_payoff_matrix()
        
        # 计算混合策略均衡
        equilibrium = self.calculate_mixed_equilibrium_2x2(payoff_matrix)
        
        return equilibrium
    
    def build_2x2_payoff_matrix(self):
        """构建2x2支付矩阵"""
        # 这里需要根据具体的博弈结构实现
        # 简化实现
        return np.array([[[3, 3], [0, 5]], [[5, 0], [1, 1]]])
    
    def calculate_mixed_equilibrium_2x2(self, payoff_matrix):
        """计算2x2博弈的混合策略均衡"""
        # 玩家1的混合策略
        p = self.calculate_player1_mixed_strategy(payoff_matrix)
        
        # 玩家2的混合策略
        q = self.calculate_player2_mixed_strategy(payoff_matrix)
        
        return {
            'player1_mixed_strategy': p,
            'player2_mixed_strategy': q
        }
    
    def calculate_player1_mixed_strategy(self, payoff_matrix):
        """计算玩家1的混合策略"""
        # 玩家1的支付矩阵
        player1_payoffs = payoff_matrix[0]
        
        # 使用无差异条件：玩家1选择策略1和策略2的期望支付相等
        # E[Strategy1] = E[Strategy2]
        # p * a11 + (1-p) * a12 = p * a21 + (1-p) * a22
        
        a11, a12 = player1_payoffs[0]
        a21, a22 = player1_payoffs[1]
        
        # 求解：p * a11 + (1-p) * a12 = p * a21 + (1-p) * a22
        # p * (a11 - a12 - a21 + a22) = a22 - a12
        # p = (a22 - a12) / (a11 - a12 - a21 + a22)
        
        denominator = a11 - a12 - a21 + a22
        
        if abs(denominator) < 1e-10:
            # 分母接近零，检查分子
            if abs(a22 - a12) < 1e-10:
                return 0.5  # 无差异
            else:
                return 0.0  # 总是选择策略2
        
        p = (a22 - a12) / denominator
        
        # 确保概率在[0,1]范围内
        p = max(0.0, min(1.0, p))
        
        return p
    
    def calculate_player2_mixed_strategy(self, payoff_matrix):
        """计算玩家2的混合策略"""
        # 玩家2的支付矩阵
        player2_payoffs = payoff_matrix[1]
        
        # 使用无差异条件：玩家2选择策略1和策略2的期望支付相等
        # E[Strategy1] = E[Strategy2]
        # q * b11 + (1-q) * b12 = q * b21 + (1-q) * b22
        
        b11, b12 = player2_payoffs[0]
        b21, b22 = player2_payoffs[1]
        
        # 求解：q * b11 + (1-q) * b12 = q * b21 + (1-q) * b22
        # q * (b11 - b12 - b21 + b22) = b22 - b12
        # q = (b22 - b12) / (b11 - b12 - b21 + b22)
        
        denominator = b11 - b12 - b21 + b22
        
        if abs(denominator) < 1e-10:
            # 分母接近零，检查分子
            if abs(b22 - b12) < 1e-10:
                return 0.5  # 无差异
            else:
                return 0.0  # 总是选择策略2
        
        q = (b22 - b12) / denominator
        
        # 确保概率在[0,1]范围内
        q = max(0.0, min(1.0, q))
        
        return q
```

### 4.2 均衡选择

```python
class EquilibriumSelection:
    def __init__(self, game):
        self.game = game
    
    def select_equilibrium(self, method='pareto_dominance'):
        """选择均衡"""
        equilibria = self.game.find_nash_equilibria()
        
        if method == 'pareto_dominance':
            return self.pareto_dominant_equilibrium(equilibria)
        elif method == 'risk_dominance':
            return self.risk_dominant_equilibrium(equilibria)
        elif method == 'payoff_dominance':
            return self.payoff_dominant_equilibrium(equilibria)
        else:
            raise ValueError(f"Unknown selection method: {method}")
    
    def pareto_dominant_equilibrium(self, equilibria):
        """帕累托占优均衡"""
        if not equilibria:
            return None
        
        pareto_dominant = equilibria[0]
        pareto_dominant_payoffs = self.game.get_payoff(pareto_dominant)
        
        for equilibrium in equilibria[1:]:
            payoffs = self.game.get_payoff(equilibrium)
            
            # 检查是否帕累托占优
            if all(payoffs[i] >= pareto_dominant_payoffs[i] for i in range(self.game.n_players)) and \
               any(payoffs[i] > pareto_dominant_payoffs[i] for i in range(self.game.n_players)):
                pareto_dominant = equilibrium
                pareto_dominant_payoffs = payoffs
        
        return pareto_dominant
    
    def risk_dominant_equilibrium(self, equilibria):
        """风险占优均衡"""
        if len(equilibria) < 2:
            return equilibria[0] if equilibria else None
        
        # 计算风险因子
        risk_factors = {}
        for equilibrium in equilibria:
            risk_factor = self.calculate_risk_factor(equilibrium)
            risk_factors[equilibrium] = risk_factor
        
        # 选择风险最小的均衡
        return min(risk_factors.keys(), key=lambda x: risk_factors[x])
    
    def calculate_risk_factor(self, equilibrium):
        """计算风险因子"""
        # 这里需要实现具体的风险因子计算
        # 简化实现
        return 0.5
    
    def payoff_dominant_equilibrium(self, equilibria):
        """支付占优均衡"""
        if not equilibria:
            return None
        
        payoff_dominant = equilibria[0]
        max_total_payoff = sum(self.game.get_payoff(payoff_dominant))
        
        for equilibrium in equilibria[1:]:
            total_payoff = sum(self.game.get_payoff(equilibrium))
            if total_payoff > max_total_payoff:
                payoff_dominant = equilibrium
                max_total_payoff = total_payoff
        
        return payoff_dominant
```

## 5. 应用案例

### 5.1 囚徒困境

```python
class PrisonersDilemmaAnalysis:
    def __init__(self):
        self.game = PrisonersDilemma()
        self.analysis = GameAnalysis(self.game)
    
    def comprehensive_analysis(self):
        """综合分析"""
        print("囚徒困境博弈综合分析")
        print("=" * 50)
        
        # 基本分析
        basic_analysis = self.game.analyze_game()
        
        # 效率分析
        efficiency_analysis = self.analysis.efficiency_analysis()
        
        # 均衡选择
        equilibrium_selector = EquilibriumSelection(self.game)
        selected_equilibrium = equilibrium_selector.select_equilibrium('pareto_dominance')
        
        print(f"选择的均衡: {selected_equilibrium}")
        print(f"效率分析: {efficiency_analysis}")
        
        return {
            'basic_analysis': basic_analysis,
            'efficiency_analysis': efficiency_analysis,
            'selected_equilibrium': selected_equilibrium
        }
    
    def repeated_game_analysis(self, rounds=10, discount_factor=0.9):
        """重复博弈分析"""
        print(f"重复囚徒困境分析 (回合数: {rounds}, 折扣因子: {discount_factor})")
        print("=" * 50)
        
        # 构建重复博弈
        repeated_game = RepeatedGame(self.game, rounds, discount_factor)
        
        # 分析重复博弈的均衡
        equilibria = repeated_game.find_equilibria()
        
        print(f"重复博弈均衡: {equilibria}")
        
        return equilibria

class RepeatedGame:
    def __init__(self, stage_game, rounds, discount_factor=1.0):
        """重复博弈"""
        self.stage_game = stage_game
        self.rounds = rounds
        self.discount_factor = discount_factor
    
    def find_equilibria(self):
        """寻找重复博弈的均衡"""
        # 这里需要实现重复博弈均衡的计算
        # 简化实现
        return []
    
    def calculate_present_value(self, payoffs, period):
        """计算现值"""
        return [payoff * (self.discount_factor ** period) for payoff in payoffs]
```

### 5.2 协调博弈

```python
class CoordinationGame(Game):
    def __init__(self):
        """协调博弈"""
        players = ['Player 1', 'Player 2']
        strategies = [['A', 'B'], ['A', 'B']]
        
        # 支付矩阵
        payoffs = {
            ('A', 'A'): [3, 3],
            ('A', 'B'): [0, 0],
            ('B', 'A'): [0, 0],
            ('B', 'B'): [2, 2]
        }
        
        super().__init__(players, strategies, payoffs)
    
    def analyze_coordination(self):
        """分析协调问题"""
        print("协调博弈分析")
        print("=" * 30)
        
        # 纳什均衡
        nash_equilibria = self.find_nash_equilibria()
        print(f"纳什均衡: {nash_equilibria}")
        
        # 帕累托最优
        pareto_optimal = self.find_pareto_optimal()
        print(f"帕累托最优: {pareto_optimal}")
        
        # 风险占优
        risk_dominant = self.find_risk_dominant_equilibrium()
        print(f"风险占优均衡: {risk_dominant}")
        
        return {
            'nash_equilibria': nash_equilibria,
            'pareto_optimal': pareto_optimal,
            'risk_dominant': risk_dominant
        }
    
    def find_risk_dominant_equilibrium(self):
        """寻找风险占优均衡"""
        # 计算风险因子
        risk_factors = {}
        
        for equilibrium in self.find_nash_equilibria():
            risk_factor = self.calculate_risk_factor(equilibrium)
            risk_factors[equilibrium] = risk_factor
        
        # 选择风险最小的均衡
        return min(risk_factors.keys(), key=lambda x: risk_factors[x])
    
    def calculate_risk_factor(self, equilibrium):
        """计算风险因子"""
        # 这里需要实现具体的风险因子计算
        # 简化实现
        return 0.5
```

## 6. 工具实现

### 6.1 Python博弈论工具

```python
class GameTheoryTools:
    def __init__(self):
        self.game_types = {
            'prisoners_dilemma': PrisonersDilemma,
            'coordination': CoordinationGame,
            'battle_of_sexes': BattleOfSexes,
            'chicken': ChickenGame
        }
    
    def create_game(self, game_type, **kwargs):
        """创建博弈"""
        if game_type in self.game_types:
            game_class = self.game_types[game_type]
            return game_class(**kwargs)
        else:
            raise ValueError(f"Unknown game type: {game_type}")
    
    def analyze_game(self, game):
        """分析博弈"""
        analyzer = GameAnalysis(game)
        return analyzer.comprehensive_analysis()
    
    def find_equilibria(self, game, equilibrium_type='all'):
        """寻找均衡"""
        if equilibrium_type == 'all':
            return {
                'nash': game.find_nash_equilibria(),
                'dominant': game.find_dominant_strategies(),
                'pareto': analyzer.find_pareto_optimal()
            }
        elif equilibrium_type == 'nash':
            return game.find_nash_equilibria()
        else:
            raise ValueError(f"Unknown equilibrium type: {equilibrium_type}")
    
    def select_equilibrium(self, game, method='pareto_dominance'):
        """选择均衡"""
        selector = EquilibriumSelection(game)
        return selector.select_equilibrium(method)

class BattleOfSexes(Game):
    def __init__(self):
        """性别之战博弈"""
        players = ['Player 1', 'Player 2']
        strategies = [['Football', 'Opera'], ['Football', 'Opera']]
        
        payoffs = {
            ('Football', 'Football'): [3, 2],
            ('Football', 'Opera'): [0, 0],
            ('Opera', 'Football'): [0, 0],
            ('Opera', 'Opera'): [2, 3]
        }
        
        super().__init__(players, strategies, payoffs)

class ChickenGame(Game):
    def __init__(self):
        """懦夫博弈"""
        players = ['Player 1', 'Player 2']
        strategies = [['Swerve', 'Straight'], ['Swerve', 'Straight']]
        
        payoffs = {
            ('Swerve', 'Swerve'): [0, 0],
            ('Swerve', 'Straight'): [-1, 1],
            ('Straight', 'Swerve'): [1, -1],
            ('Straight', 'Straight'): [-10, -10]
        }
        
        super().__init__(players, strategies, payoffs)
```

### 6.2 JavaScript博弈论实现

```javascript
class GameTheoryTools {
  constructor() {
    this.gameTypes = {
      'prisonersDilemma': PrisonersDilemma,
      'coordination': CoordinationGame,
      'battleOfSexes': BattleOfSexes,
      'chicken': ChickenGame
    };
  }
  
  createGame(gameType, config) {
    if (gameType in this.gameTypes) {
      const GameClass = this.gameTypes[gameType];
      return new GameClass(config);
    } else {
      throw new Error(`Unknown game type: ${gameType}`);
    }
  }
  
  analyzeGame(game) {
    const analyzer = new GameAnalysis(game);
    return analyzer.comprehensiveAnalysis();
  }
  
  findEquilibria(game, equilibriumType = 'all') {
    if (equilibriumType === 'all') {
      const analyzer = new GameAnalysis(game);
      return {
        nash: game.findNashEquilibria(),
        dominant: game.findDominantStrategies(),
        pareto: analyzer.findParetoOptimal()
      };
    } else if (equilibriumType === 'nash') {
      return game.findNashEquilibria();
    } else {
      throw new Error(`Unknown equilibrium type: ${equilibriumType}`);
    }
  }
  
  selectEquilibrium(game, method = 'pareto_dominance') {
    const selector = new EquilibriumSelection(game);
    return selector.selectEquilibrium(method);
  }
}

class Game {
  constructor(players, strategies, payoffs) {
    this.players = players;
    this.strategies = strategies;
    this.payoffs = payoffs;
    this.nPlayers = players.length;
  }
  
  getPayoff(strategyProfile) {
    return this.payoffs[strategyProfile];
  }
  
  getBestResponse(player, opponentStrategies) {
    let bestPayoff = -Infinity;
    let bestStrategy = null;
    
    for (const strategy of this.strategies[player]) {
      const strategyProfile = [...opponentStrategies];
      strategyProfile.splice(player, 0, strategy);
      const strategyProfileTuple = strategyProfile.join(',');
      
      const payoff = this.getPayoff(strategyProfileTuple)[player];
      if (payoff > bestPayoff) {
        bestPayoff = payoff;
        bestStrategy = strategy;
      }
    }
    
    return [bestStrategy, bestPayoff];
  }
  
  isNashEquilibrium(strategyProfile) {
    for (let player = 0; player < this.nPlayers; player++) {
      const opponentStrategies = [...strategyProfile];
      opponentStrategies.splice(player, 1);
      
      const [bestResponse, bestPayoff] = this.getBestResponse(player, opponentStrategies);
      const currentPayoff = this.getPayoff(strategyProfile.join(','))[player];
      
      if (bestPayoff > currentPayoff) {
        return false;
      }
    }
    
    return true;
  }
  
  findNashEquilibria() {
    const equilibria = [];
    const strategyCombinations = this.generateStrategyCombinations();
    
    for (const strategyProfile of strategyCombinations) {
      if (this.isNashEquilibrium(strategyProfile)) {
        equilibria.push(strategyProfile);
      }
    }
    
    return equilibria;
  }
  
  generateStrategyCombinations() {
    // 这里需要实现策略组合的生成
    // 简化实现
    return [];
  }
}
```

## 7. 学习路径

### 7.1 基础学习

1. **博弈论基础** (2-3周)
   - 博弈论基本概念
   - 策略型博弈
   - 纳什均衡

2. **扩展型博弈** (2-3周)
   - 博弈树
   - 逆向归纳法
   - 子博弈完美均衡

### 7.2 进阶学习

1. **均衡理论** (3-4周)
   - 混合策略均衡
   - 演化稳定策略
   - 颤抖手完美均衡

2. **博弈分析** (3-4周)
   - 均衡选择
   - 效率分析
   - 机制设计

### 7.3 应用实践

1. **实际应用** (4-5周)
   - 经济学应用
   - 政治学应用
   - 生物学应用

2. **工具开发** (3-4周)
   - 博弈分析工具
   - 均衡计算工具
   - 仿真工具

## 8. 总结

博弈论基础理论为理解理性决策者在相互依存情况下的行为提供了重要的理论框架。通过深入理解策略型博弈、扩展型博弈和纳什均衡，可以分析各种社会、经济和政治现象中的策略互动。
