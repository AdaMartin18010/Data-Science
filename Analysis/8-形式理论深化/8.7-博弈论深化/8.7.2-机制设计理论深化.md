# 8.7.2 机制设计理论深化

## 1. 机制设计基础

### 1.1 机制设计概念

机制设计是设计博弈规则，使得在理性参与者的情况下能够实现期望的社会目标。

```python
import numpy as np
from itertools import permutations, combinations
import matplotlib.pyplot as plt

class MechanismDesign:
    def __init__(self, agents, alternatives, preferences):
        """
        机制设计基础类
        agents: 参与者列表
        alternatives: 可选方案列表
        preferences: 偏好函数
        """
        self.agents = agents
        self.alternatives = alternatives
        self.preferences = preferences
        self.n_agents = len(agents)
        self.n_alternatives = len(alternatives)
        
    def social_choice_function(self, preference_profile):
        """社会选择函数"""
        # 实现多种社会选择函数
        if self.choice_rule == "plurality":
            return self.plurality_voting(preference_profile)
        elif self.choice_rule == "borda":
            return self.borda_count(preference_profile)
        elif self.choice_rule == "copeland":
            return self.copeland_method(preference_profile)
        elif self.choice_rule == "condorcet":
            return self.condorcet_winner(preference_profile)
        else:
            return self.plurality_voting(preference_profile)
    
    def plurality_voting(self, preference_profile):
        """多数投票"""
        votes = {}
        for alternative in self.alternatives:
            votes[alternative] = 0
        
        for agent in range(self.n_agents):
            best_alternative = self.get_best_alternative(agent, preference_profile[agent])
            votes[best_alternative] += 1
        
        return max(votes.keys(), key=lambda x: votes[x])
    
    def borda_count(self, preference_profile):
        """Borda计数"""
        scores = {}
        for alternative in self.alternatives:
            scores[alternative] = 0
        
        for agent in range(self.n_agents):
            preferences = preference_profile[agent]
            for rank, alternative in enumerate(sorted(self.alternatives, key=lambda x: preferences[x], reverse=True)):
                scores[alternative] += len(self.alternatives) - rank - 1
        
        return max(scores.keys(), key=lambda x: scores[x])
    
    def copeland_method(self, preference_profile):
        """Copeland方法"""
        scores = {}
        for alternative in self.alternatives:
            scores[alternative] = 0
        
        for i, alt1 in enumerate(self.alternatives):
            for j, alt2 in enumerate(self.alternatives[i+1:], i+1):
                wins = 0
                for agent in range(self.n_agents):
                    if preference_profile[agent][alt1] > preference_profile[agent][alt2]:
                        wins += 1
                    else:
                        wins -= 1
                
                if wins > 0:
                    scores[alt1] += 1
                    scores[alt2] -= 1
                elif wins < 0:
                    scores[alt1] -= 1
                    scores[alt2] += 1
        
        return max(scores.keys(), key=lambda x: scores[x])
    
    def condorcet_winner(self, preference_profile):
        """Condorcet赢家"""
        for alternative in self.alternatives:
            is_condorcet_winner = True
            for other in self.alternatives:
                if other != alternative:
                    wins = 0
                    for agent in range(self.n_agents):
                        if preference_profile[agent][alternative] > preference_profile[agent][other]:
                            wins += 1
                        else:
                            wins -= 1
                    
                    if wins <= 0:
                        is_condorcet_winner = False
                        break
            
            if is_condorcet_winner:
                return alternative
        
        # 如果没有Condorcet赢家，使用Borda计数作为后备
        return self.borda_count(preference_profile)
    
    def get_best_alternative(self, agent, preferences):
        """获取最佳方案"""
        return max(self.alternatives, key=lambda x: preferences[x])
    
    def is_strategy_proof(self, mechanism):
        """检查是否为策略证明"""
        # 检查是否存在参与者可以通过谎报偏好而获益
        for agent in range(self.n_agents):
            for true_preferences in self.generate_preference_profiles():
                for false_preferences in self.generate_preference_profiles():
                    if true_preferences[agent] != false_preferences[agent]:
                        # 计算真实偏好下的结果
                        true_outcome = mechanism(true_preferences)
                        true_utility = self.preferences[agent][true_outcome]
                        
                        # 计算谎报偏好下的结果
                        false_profile = list(true_preferences)
                        false_profile[agent] = false_preferences[agent]
                        false_outcome = mechanism(false_profile)
                        false_utility = self.preferences[agent][false_outcome]
                        
                        # 如果谎报偏好能获得更高效用，则不是策略证明
                        if false_utility > true_utility:
                            return False
        
        return True
    
    def generate_preference_profiles(self):
        """生成偏好配置"""
        from itertools import permutations
        
        # 生成所有可能的偏好配置
        preference_profiles = []
        
        # 为每个参与者生成偏好排序
        for agent in range(self.n_agents):
            # 生成所有可能的偏好排序
            agent_preferences = list(permutations(self.alternatives))
            
            # 为每个偏好排序分配效用值
            for preference_order in agent_preferences:
                preference_profile = {}
                for i, alternative in enumerate(preference_order):
                    # 效用值递减，最喜欢的效用最高
                    preference_profile[alternative] = len(preference_order) - i
                
                preference_profiles.append(preference_profile)
        
        return preference_profiles
    
    def is_efficient(self, mechanism):
        """检查是否为帕累托效率"""
        for preference_profile in self.generate_preference_profiles():
            outcome = mechanism(preference_profile)
            
            # 检查是否存在帕累托改进
            for alternative in self.alternatives:
                if alternative != outcome:
                    # 检查alternative是否帕累托占优outcome
                    pareto_dominant = True
                    for agent in range(self.n_agents):
                        if self.preferences[agent][alternative] <= self.preferences[agent][outcome]:
                            pareto_dominant = False
                            break
                    
                    if pareto_dominant:
                        return False
        
        return True
    
    def is_individually_rational(self, mechanism):
        """检查是否为个人理性"""
        for preference_profile in self.generate_preference_profiles():
            outcome = mechanism(preference_profile)
            
            # 检查每个参与者的效用是否非负
            for agent in range(self.n_agents):
                if self.preferences[agent][outcome] < 0:
                    return False
        
        return True

class VickreyClarkeGroves(MechanismDesign):
    def __init__(self, agents, alternatives, preferences, valuations):
        """VCG机制"""
        super().__init__(agents, alternatives, preferences)
        self.valuations = valuations
    
    def vcg_mechanism(self, valuation_profile):
        """VCG机制"""
        # 计算社会最优分配
        optimal_allocation = self.find_optimal_allocation(valuation_profile)
        
        # 计算支付
        payments = self.calculate_vcg_payments(valuation_profile, optimal_allocation)
        
        return optimal_allocation, payments
    
    def find_optimal_allocation(self, valuation_profile):
        """寻找最优分配"""
        max_social_welfare = float('-inf')
        optimal_allocation = None
        
        # 遍历所有可能的分配
        for allocation in self.generate_allocations():
            social_welfare = self.calculate_social_welfare(valuation_profile, allocation)
            if social_welfare > max_social_welfare:
                max_social_welfare = social_welfare
                optimal_allocation = allocation
        
        return optimal_allocation
    
    def calculate_social_welfare(self, valuation_profile, allocation):
        """计算社会福利"""
        total_welfare = 0
        for agent in range(self.n_agents):
            total_welfare += valuation_profile[agent][allocation[agent]]
        return total_welfare
    
    def calculate_vcg_payments(self, valuation_profile, allocation):
        """计算VCG支付"""
        payments = [0] * self.n_agents
        
        for agent in range(self.n_agents):
            # 计算包含agent时的社会福利
            welfare_with_agent = self.calculate_social_welfare(valuation_profile, allocation)
            
            # 计算不包含agent时的社会福利
            welfare_without_agent = self.calculate_welfare_without_agent(valuation_profile, agent)
            
            # VCG支付 = 外部性
            payments[agent] = welfare_without_agent - (welfare_with_agent - valuation_profile[agent][allocation[agent]])
        
        return payments
    
    def calculate_welfare_without_agent(self, valuation_profile, excluded_agent):
        """计算排除某个参与者时的社会福利"""
        # 创建不包含excluded_agent的估值配置
        reduced_valuation_profile = []
        for agent in range(self.n_agents):
            if agent != excluded_agent:
                reduced_valuation_profile.append(valuation_profile[agent])
        
        # 寻找最优分配
        optimal_allocation = self.find_optimal_allocation_for_reduced_profile(reduced_valuation_profile)
        
        # 计算社会福利
        return self.calculate_social_welfare_for_reduced_profile(reduced_valuation_profile, optimal_allocation)
    
    def find_optimal_allocation_for_reduced_profile(self, reduced_valuation_profile):
        """为减少的估值配置寻找最优分配"""
        from itertools import permutations
        
        max_welfare = float('-inf')
        optimal_allocation = None
        
        # 生成所有可能的分配
        n_agents = len(reduced_valuation_profile)
        n_items = len(reduced_valuation_profile[0]) if reduced_valuation_profile else 0
        
        # 如果物品数量等于参与者数量，使用排列
        if n_items == n_agents:
            for allocation in permutations(range(n_items)):
                welfare = sum(reduced_valuation_profile[i][allocation[i]] for i in range(n_agents))
                if welfare > max_welfare:
                    max_welfare = welfare
                    optimal_allocation = list(allocation)
        else:
            # 否则使用贪心算法
            optimal_allocation = self.greedy_allocation(reduced_valuation_profile)
        
        return optimal_allocation
    
    def calculate_social_welfare_for_reduced_profile(self, reduced_valuation_profile, allocation):
        """计算减少配置的社会福利"""
        if not allocation or not reduced_valuation_profile:
            return 0
        
        total_welfare = 0
        for agent in range(len(reduced_valuation_profile)):
            if agent < len(allocation):
                total_welfare += reduced_valuation_profile[agent][allocation[agent]]
        
        return total_welfare
    
    def greedy_allocation(self, valuation_profile):
        """贪心分配算法"""
        if not valuation_profile:
            return []
        
        n_agents = len(valuation_profile)
        n_items = len(valuation_profile[0]) if valuation_profile else 0
        
        allocation = [-1] * n_agents  # -1表示未分配
        used_items = set()
        
        # 按估值排序所有(agent, item)对
        agent_item_pairs = []
        for agent in range(n_agents):
            for item in range(n_items):
                agent_item_pairs.append((valuation_profile[agent][item], agent, item))
        
        # 按估值降序排序
        agent_item_pairs.sort(reverse=True)
        
        # 贪心分配
        for _, agent, item in agent_item_pairs:
            if allocation[agent] == -1 and item not in used_items:
                allocation[agent] = item
                used_items.add(item)
        
        return allocation
    
    def generate_allocations(self):
        """生成所有可能的分配"""
        from itertools import permutations
        
        n_agents = self.n_agents
        n_items = len(self.alternatives)
        
        allocations = []
        
        # 如果物品数量等于参与者数量，使用排列
        if n_items == n_agents:
            for allocation in permutations(range(n_items)):
                allocations.append(list(allocation))
        else:
            # 否则生成所有可能的分配组合
            self._generate_allocations_recursive([], set(), allocations, n_agents, n_items)
        
        return allocations
    
    def _generate_allocations_recursive(self, current_allocation, used_items, allocations, n_agents, n_items):
        """递归生成所有可能的分配"""
        if len(current_allocation) == n_agents:
            allocations.append(current_allocation[:])
            return
        
        for item in range(n_items):
            if item not in used_items:
                current_allocation.append(item)
                used_items.add(item)
                self._generate_allocations_recursive(current_allocation, used_items, allocations, n_agents, n_items)
                used_items.remove(item)
                current_allocation.pop()
    
    def calculate_reduced_social_welfare(self, reduced_bids, allocation):
        """计算减少配置的社会福利"""
        total_welfare = 0
        for bidder in range(len(reduced_bids)):
            if bidder < len(allocation):
                bundle = allocation[bidder]
                total_welfare += reduced_bids[bidder].get(bundle, 0)
        return total_welfare
    
    def calculate_social_welfare_for_reduced_bids(self, reduced_bids, allocation):
        """计算减少配置的社会福利"""
        total_welfare = 0
        for bidder in range(len(reduced_bids)):
            if bidder < len(allocation):
                bundle = allocation[bidder]
                # 计算组合估值
                bundle_value = self.calculate_bundle_value(reduced_bids[bidder], bundle)
                total_welfare += bundle_value
        return total_welfare
    
    def calculate_bundle_value(self, bidder_valuations, bundle):
        """计算组合估值"""
        if not bundle:
            return 0
        
        # 基础估值
        base_value = bidder_valuations.get(bundle, 0)
        
        # 考虑物品间的协同效应
        synergy_bonus = 0
        for item1 in bundle:
            for item2 in bundle:
                if item1 != item2:
                    # 计算物品间的协同效应
                    synergy = self.calculate_item_synergy(item1, item2)
                    synergy_bonus += synergy
        
        return base_value + synergy_bonus
    
    def calculate_item_synergy(self, item1, item2):
        """计算物品间的协同效应"""
        # 基于物品类型的协同效应
        item_types = {
            0: 'electronics', 1: 'clothing', 2: 'books', 
            3: 'sports', 4: 'food', 5: 'furniture'
        }
        
        type1 = item_types.get(item1, 'unknown')
        type2 = item_types.get(item2, 'unknown')
        
        # 定义协同效应矩阵
        synergy_matrix = {
            ('electronics', 'electronics'): 0.1,
            ('electronics', 'clothing'): 0.05,
            ('electronics', 'books'): 0.02,
            ('clothing', 'clothing'): 0.08,
            ('clothing', 'sports'): 0.15,
            ('books', 'books'): 0.03,
            ('sports', 'sports'): 0.12,
            ('food', 'food'): 0.06,
            ('furniture', 'furniture'): 0.09
        }
        
        # 查找协同效应
        key = (type1, type2)
        reverse_key = (type2, type1)
        
        if key in synergy_matrix:
            return synergy_matrix[key]
        elif reverse_key in synergy_matrix:
            return synergy_matrix[reverse_key]
        else:
            return 0.01  # 默认小协同效应
```

### 1.2 机制设计性质

```python
class MechanismProperties:
    def __init__(self, mechanism):
        self.mechanism = mechanism
    
    def check_strategy_proofness(self):
        """检查策略证明性"""
        return self.mechanism.is_strategy_proof(self.mechanism.social_choice_function)
    
    def check_efficiency(self):
        """检查效率性"""
        return self.mechanism.is_efficient(self.mechanism.social_choice_function)
    
    def check_individual_rationality(self):
        """检查个人理性"""
        return self.mechanism.is_individually_rational(self.mechanism.social_choice_function)
    
    def check_budget_balance(self):
        """检查预算平衡"""
        # 获取机制的支付函数
        if hasattr(self.mechanism, 'calculate_payments'):
            payments = self.mechanism.calculate_payments()
            
            # 检查总支付是否为零（预算平衡）
            total_payment = sum(payments)
            
            # 允许小的数值误差
            epsilon = 1e-10
            return abs(total_payment) < epsilon
        
        # 如果没有支付函数，假设是预算平衡的
        return True
    
    def check_revenue_equivalence(self):
        """检查收益等价性"""
        # 收益等价性：在相同类型配置下，所有策略证明机制产生相同的期望收益
        
        if not hasattr(self.mechanism, 'calculate_expected_revenue'):
            return True
        
        # 生成多个类型配置
        type_profiles = self.generate_type_profiles()
        
        if len(type_profiles) < 2:
            return True
        
        # 计算第一个配置的期望收益
        first_revenue = self.mechanism.calculate_expected_revenue(type_profiles[0])
        
        # 检查其他配置的收益是否相同
        for profile in type_profiles[1:]:
            revenue = self.mechanism.calculate_expected_revenue(profile)
            if abs(revenue - first_revenue) > 1e-10:
                return False
        
        return True
    
    def generate_type_profiles(self):
        """生成类型配置"""
        # 简化的类型配置生成
        profiles = []
        n_agents = getattr(self.mechanism, 'n_agents', 2)
        n_types = 3  # 假设每个参与者有3种类型
        
        # 生成一些示例类型配置
        for i in range(min(5, n_types ** n_agents)):  # 限制数量避免计算爆炸
            profile = []
            for agent in range(n_agents):
                agent_type = (i // (n_types ** agent)) % n_types
                profile.append(agent_type)
            profiles.append(profile)
        
        return profiles
    
    def comprehensive_analysis(self):
        """综合分析"""
        analysis = {
            'strategy_proof': self.check_strategy_proofness(),
            'efficient': self.check_efficiency(),
            'individually_rational': self.check_individual_rationality(),
            'budget_balanced': self.check_budget_balance(),
            'revenue_equivalent': self.check_revenue_equivalence()
        }
        
        return analysis

class RevelationPrinciple:
    def __init__(self):
        self.principle_statement = """
        显示原理：对于任何机制，都存在一个等价的直接显示机制，
        其中每个参与者都真实报告自己的类型。
        """
    
    def apply_revelation_principle(self, mechanism):
        """应用显示原理"""
        # 显示原理：将任何机制转换为直接显示机制
        
        def direct_mechanism(type_profile):
            """直接显示机制"""
            # 1. 将类型配置转换为最优策略
            strategy_profile = self.convert_types_to_strategies(type_profile)
            
            # 2. 应用原始机制
            outcome = mechanism(strategy_profile)
            
            # 3. 计算支付（如果机制支持）
            payments = None
            if hasattr(mechanism, 'calculate_payments'):
                payments = mechanism.calculate_payments(strategy_profile)
            
            return outcome, payments
        
        return direct_mechanism
    
    def construct_direct_mechanism(self, original_mechanism):
        """构造直接机制"""
        def direct_mechanism(type_profile):
            # 将类型配置转换为策略配置
            strategy_profile = self.convert_types_to_strategies(type_profile)
            
            # 应用原始机制
            return original_mechanism(strategy_profile)
        
        return direct_mechanism
    
    def convert_types_to_strategies(self, type_profile):
        """将类型配置转换为策略配置"""
        # 在直接显示机制中，类型配置就是策略配置
        # 每个参与者直接报告自己的类型
        
        strategy_profile = []
        for agent_type in type_profile:
            # 将类型转换为相应的策略
            strategy = self.type_to_strategy(agent_type)
            strategy_profile.append(strategy)
        
        return strategy_profile
    
    def type_to_strategy(self, agent_type):
        """将代理类型转换为策略"""
        # 这里实现具体的类型到策略的映射
        # 可以根据具体的机制设计来定制
        
        if isinstance(agent_type, (int, float)):
            # 数值类型：直接作为估值报告
            return agent_type
        elif isinstance(agent_type, dict):
            # 字典类型：包含估值和偏好的完整类型
            return agent_type
        else:
            # 其他类型：转换为标准格式
            return {'valuation': float(agent_type), 'preferences': []}
```

## 2. 拍卖理论

### 2.1 拍卖机制

```python
class AuctionTheory:
    def __init__(self, bidders, items, valuations):
        """
        拍卖理论
        bidders: 投标者列表
        items: 物品列表
        valuations: 估值函数
        """
        self.bidders = bidders
        self.items = items
        self.valuations = valuations
        self.n_bidders = len(bidders)
        self.n_items = len(items)
    
    def first_price_auction(self, bids):
        """一价拍卖"""
        # 找到最高投标者
        highest_bidder = max(range(self.n_bidders), key=lambda i: bids[i])
        highest_bid = bids[highest_bidder]
        
        # 分配物品给最高投标者
        allocation = [0] * self.n_bidders
        allocation[highest_bidder] = 1
        
        # 支付等于投标金额
        payments = [0] * self.n_bidders
        payments[highest_bidder] = highest_bid
        
        return allocation, payments
    
    def second_price_auction(self, bids):
        """二价拍卖"""
        # 找到最高和次高投标者
        sorted_bidders = sorted(range(self.n_bidders), key=lambda i: bids[i], reverse=True)
        highest_bidder = sorted_bidders[0]
        second_highest_bid = bids[sorted_bidders[1]] if len(sorted_bidders) > 1 else 0
        
        # 分配物品给最高投标者
        allocation = [0] * self.n_bidders
        allocation[highest_bidder] = 1
        
        # 支付等于次高投标金额
        payments = [0] * self.n_bidders
        payments[highest_bidder] = second_highest_bid
        
        return allocation, payments
    
    def all_pay_auction(self, bids):
        """全支付拍卖"""
        # 找到最高投标者
        highest_bidder = max(range(self.n_bidders), key=lambda i: bids[i])
        
        # 分配物品给最高投标者
        allocation = [0] * self.n_bidders
        allocation[highest_bidder] = 1
        
        # 所有投标者都支付
        payments = bids.copy()
        
        return allocation, payments
    
    def dutch_auction(self, starting_price, decrement):
        """荷兰式拍卖"""
        current_price = starting_price
        winner = None
        
        while current_price > 0 and winner is None:
            # 检查是否有投标者接受当前价格
            for bidder in range(self.n_bidders):
                if self.valuations[bidder] >= current_price:
                    winner = bidder
                    break
            
            if winner is None:
                current_price -= decrement
        
        # 分配和支付
        allocation = [0] * self.n_bidders
        payments = [0] * self.n_bidders
        
        if winner is not None:
            allocation[winner] = 1
            payments[winner] = current_price
        
        return allocation, payments
    
    def english_auction(self, starting_price, increment):
        """英式拍卖"""
        current_price = starting_price
        active_bidders = set(range(self.n_bidders))
        winner = None
        
        while len(active_bidders) > 1:
            # 检查哪些投标者退出
            exiting_bidders = set()
            for bidder in active_bidders:
                if self.valuations[bidder] < current_price:
                    exiting_bidders.add(bidder)
            
            active_bidders -= exiting_bidders
            current_price += increment
        
        # 分配和支付
        allocation = [0] * self.n_bidders
        payments = [0] * self.n_bidders
        
        if len(active_bidders) == 1:
            winner = list(active_bidders)[0]
            allocation[winner] = 1
            payments[winner] = current_price - increment
        
        return allocation, payments

class OptimalBidding:
    def __init__(self, auction_type, valuations):
        self.auction_type = auction_type
        self.valuations = valuations
    
    def optimal_bid_first_price(self, bidder, other_bids):
        """一价拍卖的最优投标"""
        # 在对称均衡中，最优投标是估值的函数
        n = len(self.valuations)
        valuation = self.valuations[bidder]
        
        # 使用贝叶斯纳什均衡分析
        # 假设估值服从均匀分布U[0,1]
        if n == 2:
            # 两投标者情况：最优投标 = 估值/2
            optimal_bid = valuation / 2
        else:
            # 多投标者情况：最优投标 = 估值 * (n-1)/n
            optimal_bid = valuation * (n - 1) / n
        
        # 考虑其他投标者的影响
        if other_bids:
            max_other_bid = max(other_bids)
            # 确保投标不超过估值
            optimal_bid = min(optimal_bid, valuation)
            # 如果其他投标很高，适当调整
            if max_other_bid > optimal_bid:
                optimal_bid = max_other_bid + 0.01
        
        return optimal_bid
    
    def optimal_bid_second_price(self, bidder):
        """二价拍卖的最优投标"""
        # 在二价拍卖中，真实投标是占优策略
        return self.valuations[bidder]
    
    def optimal_bid_all_pay(self, bidder, other_bids):
        """全支付拍卖的最优投标"""
        # 全支付拍卖的均衡分析
        n = len(self.valuations)
        
        # 在对称均衡中，最优投标策略
        # 使用Nash均衡分析
        if n == 2:
            # 两投标者情况：最优投标 = 估值/2
            optimal_bid = self.valuations[bidder] / 2
        else:
            # 多投标者情况：使用更复杂的均衡分析
            # 基于其他投标者的分布
            max_other_bid = max(other_bids) if other_bids else 0
            optimal_bid = max(self.valuations[bidder] / n, max_other_bid + 0.01)
        
        return optimal_bid
    
    def revenue_equivalence_theorem(self):
        """收益等价定理"""
        # 在独立私有价值模型中，满足相同分配规则的拍卖具有相同的期望收益
        return True
```

### 2.2 组合拍卖

```python
class CombinatorialAuction:
    def __init__(self, bidders, items, valuations):
        """
        组合拍卖
        bidders: 投标者列表
        items: 物品列表
        valuations: 组合估值函数
        """
        self.bidders = bidders
        self.items = items
        self.valuations = valuations
        self.n_bidders = len(bidders)
        self.n_items = len(items)
    
    def vcg_auction(self, bids):
        """VCG组合拍卖"""
        # 寻找社会福利最大化的分配
        optimal_allocation = self.find_optimal_allocation(bids)
        
        # 计算VCG支付
        payments = self.calculate_vcg_payments(bids, optimal_allocation)
        
        return optimal_allocation, payments
    
    def find_optimal_allocation(self, bids):
        """寻找最优分配"""
        max_social_welfare = float('-inf')
        optimal_allocation = None
        
        # 遍历所有可能的分配
        for allocation in self.generate_allocations():
            social_welfare = self.calculate_social_welfare(bids, allocation)
            if social_welfare > max_social_welfare:
                max_social_welfare = social_welfare
                optimal_allocation = allocation
        
        return optimal_allocation
    
    def calculate_social_welfare(self, bids, allocation):
        """计算社会福利"""
        total_welfare = 0
        for bidder in range(self.n_bidders):
            bundle = allocation[bidder]
            total_welfare += bids[bidder].get(bundle, 0)
        return total_welfare
    
    def calculate_vcg_payments(self, bids, allocation):
        """计算VCG支付"""
        payments = [0] * self.n_bidders
        
        for bidder in range(self.n_bidders):
            # 计算包含bidder时的社会福利
            welfare_with_bidder = self.calculate_social_welfare(bids, allocation)
            
            # 计算不包含bidder时的社会福利
            welfare_without_bidder = self.calculate_welfare_without_bidder(bids, bidder)
            
            # VCG支付 = 外部性
            bidder_bundle = allocation[bidder]
            bidder_value = bids[bidder].get(bidder_bundle, 0)
            payments[bidder] = welfare_without_bidder - (welfare_with_bidder - bidder_value)
        
        return payments
    
    def calculate_welfare_without_bidder(self, bids, excluded_bidder):
        """计算排除某个投标者时的社会福利"""
        # 创建不包含excluded_bidder的投标配置
        reduced_bids = []
        for bidder in range(self.n_bidders):
            if bidder != excluded_bidder:
                reduced_bids.append(bids[bidder])
        
        # 寻找最优分配
        optimal_allocation = self.find_optimal_allocation_for_reduced_bids(reduced_bids)
        
        # 计算社会福利
        return self.calculate_social_welfare_for_reduced_bids(reduced_bids, optimal_allocation)
    
    def find_optimal_allocation_for_reduced_bids(self, reduced_bids):
        """为减少的投标配置寻找最优分配"""
        # 使用整数线性规划求解最优分配
        from itertools import combinations
        
        n_reduced_bidders = len(reduced_bids)
        n_items = self.n_items
        
        max_welfare = float('-inf')
        optimal_allocation = None
        
        # 生成所有可能的物品组合
        all_bundles = []
        for r in range(1, n_items + 1):
            all_bundles.extend(list(combinations(range(n_items), r)))
        
        # 生成所有可能的分配
        for allocation in self.generate_reduced_allocations(n_reduced_bidders, all_bundles):
            welfare = self.calculate_reduced_social_welfare(reduced_bids, allocation)
            if welfare > max_welfare:
                max_welfare = welfare
                optimal_allocation = allocation
        
        return optimal_allocation
    
    def generate_reduced_allocations(self, n_bidders, bundles):
        """生成减少投标者的分配"""
        # 使用回溯算法生成所有可能的分配
        allocations = []
        self._generate_allocations_backtrack([], set(), allocations, n_bidders, bundles)
        return allocations
    
    def _generate_allocations_backtrack(self, current_allocation, used_items, allocations, n_bidders, bundles):
        """回溯生成分配"""
        if len(current_allocation) == n_bidders:
            allocations.append(current_allocation[:])
            return
        
        for bundle in bundles:
            # 检查bundle是否与已分配物品冲突
            bundle_items = set(bundle)
            if not bundle_items.intersection(used_items):
                current_allocation.append(bundle)
                used_items.update(bundle_items)
                self._generate_allocations_backtrack(current_allocation, used_items, allocations, n_bidders, bundles)
                used_items.difference_update(bundle_items)
                current_allocation.pop()
    
    def calculate_reduced_social_welfare(self, reduced_bids, allocation):
        """计算减少配置的社会福利"""
        total_welfare = 0
        for bidder in range(len(reduced_bids)):
            if bidder < len(allocation):
                bundle = allocation[bidder]
                total_welfare += reduced_bids[bidder].get(bundle, 0)
        return total_welfare
    
    def calculate_social_welfare_for_reduced_bids(self, reduced_bids, allocation):
        """计算减少配置的社会福利"""
        total_welfare = 0
        for bidder in range(len(reduced_bids)):
            if bidder < len(allocation):
                bundle = allocation[bidder]
                # 计算组合估值
                bundle_value = self.calculate_bundle_value(reduced_bids[bidder], bundle)
                total_welfare += bundle_value
        return total_welfare
    
    def calculate_bundle_value(self, bidder_valuations, bundle):
        """计算组合估值"""
        if not bundle:
            return 0
        
        # 基础估值
        base_value = bidder_valuations.get(bundle, 0)
        
        # 考虑物品间的协同效应
        synergy_bonus = 0
        for item1 in bundle:
            for item2 in bundle:
                if item1 != item2:
                    # 计算物品间的协同效应
                    synergy = self.calculate_item_synergy(item1, item2)
                    synergy_bonus += synergy
        
        return base_value + synergy_bonus
    
    def calculate_item_synergy(self, item1, item2):
        """计算物品间的协同效应"""
        # 基于物品类型的协同效应
        item_types = {
            0: 'electronics', 1: 'clothing', 2: 'books', 
            3: 'sports', 4: 'food', 5: 'furniture'
        }
        
        type1 = item_types.get(item1, 'unknown')
        type2 = item_types.get(item2, 'unknown')
        
        # 定义协同效应矩阵
        synergy_matrix = {
            ('electronics', 'electronics'): 0.1,
            ('electronics', 'clothing'): 0.05,
            ('electronics', 'books'): 0.02,
            ('clothing', 'clothing'): 0.08,
            ('clothing', 'sports'): 0.15,
            ('books', 'books'): 0.03,
            ('sports', 'sports'): 0.12,
            ('food', 'food'): 0.06,
            ('furniture', 'furniture'): 0.09
        }
        
        # 查找协同效应
        key = (type1, type2)
        reverse_key = (type2, type1)
        
        if key in synergy_matrix:
            return synergy_matrix[key]
        elif reverse_key in synergy_matrix:
            return synergy_matrix[reverse_key]
        else:
            return 0.01  # 默认小协同效应
```

## 3. 匹配理论

### 3.1 稳定匹配

```python
class MatchingTheory:
    def __init__(self, men, women, men_preferences, women_preferences):
        """
        匹配理论
        men: 男性列表
        women: 女性列表
        men_preferences: 男性偏好
        women_preferences: 女性偏好
        """
        self.men = men
        self.women = women
        self.men_preferences = men_preferences
        self.women_preferences = women_preferences
        self.n_men = len(men)
        self.n_women = len(women)
    
    def gale_shapley_algorithm(self, proposers='men'):
        """Gale-Shapley算法"""
        if proposers == 'men':
            return self.men_proposing_algorithm()
        else:
            return self.women_proposing_algorithm()
    
    def men_proposing_algorithm(self):
        """男性求婚算法"""
        # 初始化
        matching = {}
        men_free = set(range(self.n_men))
        women_free = set(range(self.n_women))
        men_proposals = {i: 0 for i in range(self.n_men)}
        
        while men_free:
            man = list(men_free)[0]
            
            # 获取下一个求婚对象
            if men_proposals[man] < self.n_women:
                woman = self.men_preferences[man][men_proposals[man]]
                men_proposals[man] += 1
                
                if woman in women_free:
                    # 女性接受求婚
                    matching[man] = woman
                    matching[woman] = man
                    men_free.remove(man)
                    women_free.remove(woman)
                else:
                    # 女性比较当前匹配和新的求婚者
                    current_man = matching[woman]
                    if self.women_preferences[woman].index(man) < self.women_preferences[woman].index(current_man):
                        # 女性接受新的求婚者
                        matching[man] = woman
                        matching[woman] = man
                        men_free.remove(man)
                        men_free.add(current_man)
                        matching.pop(current_man, None)
        
        return matching
    
    def women_proposing_algorithm(self):
        """女性求婚算法"""
        # 初始化
        matching = {}
        women_free = set(range(self.n_women))
        men_free = set(range(self.n_men))
        women_proposals = {i: 0 for i in range(self.n_women)}
        
        while women_free:
            woman = list(women_free)[0]
            
            # 获取下一个求婚对象
            if women_proposals[woman] < self.n_men:
                man = self.women_preferences[woman][women_proposals[woman]]
                women_proposals[woman] += 1
                
                if man in men_free:
                    # 男性接受求婚
                    matching[woman] = man
                    matching[man] = woman
                    women_free.remove(woman)
                    men_free.remove(man)
                else:
                    # 男性比较当前匹配和新的求婚者
                    current_woman = matching[man]
                    if self.men_preferences[man].index(woman) < self.men_preferences[man].index(current_woman):
                        # 男性接受新的求婚者
                        matching[woman] = man
                        matching[man] = woman
                        women_free.remove(woman)
                        women_free.add(current_woman)
                        matching.pop(current_woman, None)
        
        return matching
    
    def is_stable_matching(self, matching):
        """检查是否为稳定匹配"""
        for man in range(self.n_men):
            for woman in range(self.n_women):
                # 检查是否存在不稳定对
                if self.is_blocking_pair(man, woman, matching):
                    return False
        
        return True
    
    def is_blocking_pair(self, man, woman, matching):
        """检查是否为阻塞对"""
        # 检查man和woman是否都更偏好对方
        current_man_partner = matching.get(man)
        current_woman_partner = matching.get(woman)
        
        # 如果man更偏好woman
        man_prefers_woman = (current_man_partner is None or 
                            self.men_preferences[man].index(woman) < 
                            self.men_preferences[man].index(current_man_partner))
        
        # 如果woman更偏好man
        woman_prefers_man = (current_woman_partner is None or 
                            self.women_preferences[woman].index(man) < 
                            self.women_preferences[woman].index(current_woman_partner))
        
        return man_prefers_woman and woman_prefers_man
    
    def find_all_stable_matchings(self):
        """寻找所有稳定匹配"""
        # 使用Roth-Vande Vate算法寻找所有稳定匹配
        
        stable_matchings = []
        
        # 男性最优匹配
        men_optimal = self.men_proposing_algorithm()
        stable_matchings.append(men_optimal)
        
        # 女性最优匹配
        women_optimal = self.women_proposing_algorithm()
        if women_optimal != men_optimal:
            stable_matchings.append(women_optimal)
        
        # 寻找中间稳定匹配
        intermediate_matchings = self.find_intermediate_stable_matchings(men_optimal, women_optimal)
        stable_matchings.extend(intermediate_matchings)
        
        return stable_matchings
    
    def find_intermediate_stable_matchings(self, men_optimal, women_optimal):
        """寻找中间稳定匹配"""
        intermediate_matchings = []
        
        # 使用旋转算法寻找中间稳定匹配
        rotations = self.find_rotations(men_optimal, women_optimal)
        
        for rotation in rotations:
            # 应用旋转得到新的稳定匹配
            new_matching = self.apply_rotation(men_optimal, rotation)
            if new_matching != men_optimal and new_matching != women_optimal:
                intermediate_matchings.append(new_matching)
        
        return intermediate_matchings
    
    def find_rotations(self, men_optimal, women_optimal):
        """寻找旋转"""
        # 简化实现：返回一些基本的旋转
        rotations = []
        
        # 这里可以实现完整的旋转寻找算法
        # 目前返回空列表作为占位符
        return rotations
    
    def apply_rotation(self, matching, rotation):
        """应用旋转"""
        new_matching = matching.copy()
        
        # 应用旋转操作
        for man, woman in rotation:
            new_matching[man] = woman
            new_matching[woman] = man
        
        return new_matching
```

### 3.2 学校选择问题

```python
class SchoolChoice:
    def __init__(self, students, schools, student_preferences, school_capacities):
        """
        学校选择问题
        students: 学生列表
        schools: 学校列表
        student_preferences: 学生偏好
        school_capacities: 学校容量
        """
        self.students = students
        self.schools = schools
        self.student_preferences = student_preferences
        self.school_capacities = school_capacities
        self.n_students = len(students)
        self.n_schools = len(schools)
    
    def deferred_acceptance_algorithm(self):
        """延迟接受算法"""
        # 初始化
        matching = {student: None for student in range(self.n_students)}
        school_applications = {school: [] for school in range(self.n_schools)}
        student_proposals = {student: 0 for student in range(self.n_students)}
        
        while True:
            # 学生提出申请
            new_applications = []
            for student in range(self.n_students):
                if matching[student] is None and student_proposals[student] < self.n_schools:
                    school = self.student_preferences[student][student_proposals[student]]
                    new_applications.append((student, school))
                    student_proposals[student] += 1
            
            if not new_applications:
                break
            
            # 学校处理申请
            for student, school in new_applications:
                school_applications[school].append(student)
            
            # 学校接受申请
            for school in range(self.n_schools):
                if len(school_applications[school]) > self.school_capacities[school]:
                    # 学校需要拒绝一些学生
                    accepted_students = self.school_acceptance_rule(school, school_applications[school])
                    
                    # 更新匹配
                    for student in school_applications[school]:
                        if student in accepted_students:
                            matching[student] = school
                        else:
                            matching[student] = None
                    
                    # 清空申请列表
                    school_applications[school] = accepted_students
                else:
                    # 学校接受所有申请
                    for student in school_applications[school]:
                        matching[student] = school
        
        return matching
    
    def school_acceptance_rule(self, school, applicants):
        """学校接受规则"""
        # 这里可以实现不同的接受规则
        # 简化实现：按学生ID排序
        return sorted(applicants)[:self.school_capacities[school]]
    
    def top_trading_cycles_algorithm(self):
        """顶级交易圈算法"""
        # 初始化
        matching = {student: None for student in range(self.n_students)}
        school_assignments = {school: [] for school in range(self.n_schools)}
        
        # 为每个学生分配初始学校
        for student in range(self.n_students):
            initial_school = student % self.n_schools
            school_assignments[initial_school].append(student)
            matching[student] = initial_school
        
        # 寻找并执行交易圈
        while True:
            cycles = self.find_trading_cycles(matching)
            if not cycles:
                break
            
            # 执行交易圈
            for cycle in cycles:
                self.execute_trading_cycle(cycle, matching)
        
        return matching
    
    def find_trading_cycles(self, matching):
        """寻找交易圈"""
        cycles = []
        visited = set()
        
        for student in range(self.n_students):
            if student not in visited:
                cycle = self.find_cycle_from_student(student, matching, visited)
                if cycle and len(cycle) > 1:
                    cycles.append(cycle)
        
        return cycles
    
    def find_cycle_from_student(self, start_student, matching, visited):
        """从学生开始寻找交易圈"""
        cycle = []
        current_student = start_student
        
        while current_student not in visited:
            visited.add(current_student)
            cycle.append(current_student)
            
            # 找到当前学生最偏好的学校
            preferred_school = self.get_preferred_school(current_student, matching)
            
            # 找到该学校中优先级最低的学生
            next_student = self.get_least_preferred_student(preferred_school, matching)
            
            if next_student in cycle:
                # 找到圈
                cycle_start = cycle.index(next_student)
                return cycle[cycle_start:]
            
            current_student = next_student
        
        return None
    
    def get_preferred_school(self, student, matching):
        """获取学生最偏好的学校"""
        current_school = matching[student]
        
        # 在学生偏好列表中找到比当前学校更偏好的学校
        for school in self.student_preferences[student]:
            if school != current_school:
                return school
        
        return current_school
    
    def get_least_preferred_student(self, school, matching):
        """获取学校中优先级最低的学生"""
        students_at_school = [s for s, sch in matching.items() if sch == school]
        
        if not students_at_school:
            return None
        
        # 返回学校偏好列表中优先级最低的学生
        return min(students_at_school, key=lambda s: self.get_school_preference_rank(school, s))
    
    def get_school_preference_rank(self, school, student):
        """获取学校对学生的偏好排名"""
        # 简化实现：假设学校偏好按学生ID排序
        return student
    
    def execute_trading_cycle(self, cycle, matching):
        """执行交易圈"""
        # 执行循环交换
        for i in range(len(cycle)):
            current_student = cycle[i]
            next_student = cycle[(i + 1) % len(cycle)]
            
            # 交换学校分配
            current_school = matching[current_student]
            next_school = matching[next_student]
            
            matching[current_student] = next_school
            matching[next_student] = current_school
    
    def boston_mechanism(self):
        """波士顿机制"""
        # 初始化
        matching = {student: None for student in range(self.n_students)}
        school_applications = {school: [] for school in range(self.n_schools)}
        
        # 按轮次处理申请
        for round_num in range(self.n_schools):
            # 学生提出申请
            new_applications = []
            for student in range(self.n_students):
                if matching[student] is None and round_num < len(self.student_preferences[student]):
                    school = self.student_preferences[student][round_num]
                    new_applications.append((student, school))
            
            # 学校立即接受申请
            for student, school in new_applications:
                if len(school_applications[school]) < self.school_capacities[school]:
                    # 学校还有容量，接受申请
                    school_applications[school].append(student)
                    matching[student] = school
        
        return matching
```

## 4. 投票理论

### 4.1 投票机制

```python
class VotingTheory:
    def __init__(self, voters, candidates, preferences):
        """
        投票理论
        voters: 选民列表
        candidates: 候选人列表
        preferences: 偏好配置
        """
        self.voters = voters
        self.candidates = candidates
        self.preferences = preferences
        self.n_voters = len(voters)
        self.n_candidates = len(candidates)
    
    def plurality_voting(self):
        """多数投票"""
        votes = {candidate: 0 for candidate in range(self.n_candidates)}
        
        for voter in range(self.n_voters):
            # 每个选民投票给最偏好的候选人
            favorite = self.preferences[voter][0]
            votes[favorite] += 1
        
        # 返回得票最多的候选人
        return max(votes.keys(), key=lambda x: votes[x])
    
    def borda_count(self):
        """Borda计数"""
        scores = {candidate: 0 for candidate in range(self.n_candidates)}
        
        for voter in range(self.n_voters):
            for position, candidate in enumerate(self.preferences[voter]):
                # Borda分数 = n - position - 1
                scores[candidate] += self.n_candidates - position - 1
        
        # 返回得分最高的候选人
        return max(scores.keys(), key=lambda x: scores[x])
    
    def instant_runoff_voting(self):
        """即时决选投票"""
        remaining_candidates = set(range(self.n_candidates))
        
        while len(remaining_candidates) > 1:
            # 计算当前轮次的投票
            votes = {candidate: 0 for candidate in remaining_candidates}
            
            for voter in range(self.n_voters):
                # 找到选民最偏好的剩余候选人
                for candidate in self.preferences[voter]:
                    if candidate in remaining_candidates:
                        votes[candidate] += 1
                        break
            
            # 找到得票最少的候选人
            min_votes = min(votes.values())
            eliminated = [candidate for candidate, vote in votes.items() if vote == min_votes]
            
            # 淘汰得票最少的候选人
            remaining_candidates -= set(eliminated)
        
        return list(remaining_candidates)[0]
    
    def condorcet_winner(self):
        """孔多塞赢家"""
        for candidate in range(self.n_candidates):
            is_condorcet_winner = True
            
            for other_candidate in range(self.n_candidates):
                if other_candidate != candidate:
                    # 计算candidate vs other_candidate的投票
                    votes_for_candidate = 0
                    votes_for_other = 0
                    
                    for voter in range(self.n_voters):
                        candidate_rank = self.preferences[voter].index(candidate)
                        other_rank = self.preferences[voter].index(other_candidate)
                        
                        if candidate_rank < other_rank:
                            votes_for_candidate += 1
                        else:
                            votes_for_other += 1
                    
                    if votes_for_candidate <= votes_for_other:
                        is_condorcet_winner = False
                        break
            
            if is_condorcet_winner:
                return candidate
        
        return None  # 没有孔多塞赢家
    
    def approval_voting(self, approval_thresholds):
        """认可投票"""
        votes = {candidate: 0 for candidate in range(self.n_candidates)}
        
        for voter in range(self.n_voters):
            threshold = approval_thresholds[voter]
            
            for position, candidate in enumerate(self.preferences[voter]):
                if position < threshold:
                    votes[candidate] += 1
        
        # 返回得票最多的候选人
        return max(votes.keys(), key=lambda x: votes[x])
    
    def arrow_impossibility_theorem(self):
        """阿罗不可能定理"""
        # 阿罗不可能定理：不存在满足所有理想性质的投票系统
        properties = {
            'unanimity': True,  # 一致性
            'independence': True,  # 独立性
            'non_dictatorship': True,  # 非独裁性
            'completeness': True,  # 完备性
            'transitivity': True  # 传递性
        }
        
        # 检查是否所有性质都能同时满足
        return not all(properties.values())
```

### 4.2 投票悖论

```python
class VotingParadoxes:
    def __init__(self):
        self.paradoxes = {
            'condorcet_paradox': self.condorcet_paradox,
            'alabama_paradox': self.alabama_paradox,
            'population_paradox': self.population_paradox
        }
    
    def condorcet_paradox(self):
        """孔多塞悖论"""
        # 构造一个偏好配置，使得孔多塞赢家不存在
        preferences = [
            [0, 1, 2],  # 选民1: A > B > C
            [1, 2, 0],  # 选民2: B > C > A
            [2, 0, 1]   # 选民3: C > A > B
        ]
        
        # 检查是否存在孔多塞赢家
        voting_system = VotingTheory(['V1', 'V2', 'V3'], ['A', 'B', 'C'], preferences)
        condorcet_winner = voting_system.condorcet_winner()
        
        return condorcet_winner is None
    
    def alabama_paradox(self):
        """阿拉巴马悖论"""
        # 构造一个例子，增加席位后某个州的席位反而减少
        
        # 初始人口和席位
        initial_populations = {
            'A': 1000,
            'B': 2000,
            'C': 3000
        }
        initial_seats = 10
        
        # 计算初始席位分配
        initial_allocation = self.hamilton_method(initial_populations, initial_seats)
        
        # 增加席位后的分配
        new_seats = 11
        new_allocation = self.hamilton_method(initial_populations, new_seats)
        
        # 检查是否存在阿拉巴马悖论
        for state in initial_populations:
            if new_allocation[state] < initial_allocation[state]:
                return True
        
        return False
    
    def hamilton_method(self, populations, total_seats):
        """汉密尔顿方法分配席位"""
        total_population = sum(populations.values())
        quota = total_population / total_seats
        
        # 计算每个州的初始配额
        allocations = {}
        for state, population in populations.items():
            allocations[state] = int(population / quota)
        
        # 分配剩余席位
        allocated_seats = sum(allocations.values())
        remaining_seats = total_seats - allocated_seats
        
        # 按小数部分排序，分配剩余席位
        fractional_parts = []
        for state, population in populations.items():
            fractional_part = (population / quota) - allocations[state]
            fractional_parts.append((fractional_part, state))
        
        fractional_parts.sort(reverse=True)
        
        for i in range(remaining_seats):
            if i < len(fractional_parts):
                state = fractional_parts[i][1]
                allocations[state] += 1
        
        return allocations
    
    def population_paradox(self):
        """人口悖论"""
        # 构造一个例子，人口增加后某个州的席位反而减少
        
        # 初始人口
        initial_populations = {
            'A': 1000,
            'B': 2000,
            'C': 3000
        }
        total_seats = 10
        
        # 计算初始席位分配
        initial_allocation = self.hamilton_method(initial_populations, total_seats)
        
        # 人口变化后的分配
        new_populations = {
            'A': 1100,  # A州人口增加
            'B': 2100,  # B州人口增加
            'C': 2900   # C州人口减少
        }
        new_allocation = self.hamilton_method(new_populations, total_seats)
        
        # 检查是否存在人口悖论
        for state in initial_populations:
            if new_allocation[state] < initial_allocation[state]:
                return True
        
        return False
    
    def demonstrate_paradoxes(self):
        """演示各种悖论"""
        results = {}
        
        for paradox_name, paradox_func in self.paradoxes.items():
            results[paradox_name] = paradox_func()
        
        return results
```

## 5. 应用案例

### 5.1 频谱拍卖

```python
class SpectrumAuction:
    def __init__(self, bidders, licenses, valuations):
        """
        频谱拍卖
        bidders: 投标者列表
        licenses: 频谱许可证列表
        valuations: 估值函数
        """
        self.bidders = bidders
        self.licenses = licenses
        self.valuations = valuations
        self.n_bidders = len(bidders)
        self.n_licenses = len(licenses)
    
    def simultaneous_ascending_auction(self):
        """同时上升拍卖"""
        # 初始化
        current_prices = {license: 0 for license in range(self.n_licenses)}
        current_assignments = {license: None for license in range(self.n_licenses)}
        active_bidders = set(range(self.n_bidders))
        
        while active_bidders:
            # 每个投标者提交投标
            bids = {}
            for bidder in active_bidders:
                bidder_bids = self.submit_bids(bidder, current_prices)
                bids[bidder] = bidder_bids
            
            # 更新价格和分配
            new_prices, new_assignments = self.update_prices_and_assignments(
                bids, current_prices, current_assignments)
            
            # 检查是否有投标者退出
            exiting_bidders = self.check_exiting_bidders(bids, new_prices)
            active_bidders -= exiting_bidders
            
            # 更新当前状态
            current_prices = new_prices
            current_assignments = new_assignments
        
        return current_assignments, current_prices
    
    def submit_bids(self, bidder, current_prices):
        """提交投标"""
        bids = {}
        
        # 计算投标者的预算
        budget = self.calculate_budget(bidder)
        
        # 为每个许可证计算最优投标
        for license in range(self.n_licenses):
            valuation = self.valuations[bidder][license]
            current_price = current_prices[license]
            
            # 如果估值高于当前价格，考虑投标
            if valuation > current_price:
                # 计算最优投标金额
                optimal_bid = self.calculate_optimal_bid(
                    bidder, license, valuation, current_price, budget)
                
                if optimal_bid > current_price:
                    bids[license] = optimal_bid
        
        return bids
    
    def calculate_budget(self, bidder):
        """计算投标者预算"""
        # 基于投标者的总估值和风险偏好计算预算
        total_valuation = sum(self.valuations[bidder].values())
        risk_factor = 0.8  # 风险因子
        return total_valuation * risk_factor
    
    def calculate_optimal_bid(self, bidder, license, valuation, current_price, budget):
        """计算最优投标金额"""
        # 使用边际价值分析
        marginal_value = valuation - current_price
        
        # 考虑竞争强度
        competition_factor = self.estimate_competition(bidder, license)
        
        # 计算最优投标
        optimal_bid = current_price + (marginal_value * competition_factor)
        
        # 确保不超过预算
        optimal_bid = min(optimal_bid, budget)
        
        return optimal_bid
    
    def estimate_competition(self, bidder, license):
        """估计竞争强度"""
        # 基于历史数据和当前价格估计竞争
        # 简化实现：使用固定竞争因子
        return 0.7
    
    def update_prices_and_assignments(self, bids, current_prices, current_assignments):
        """更新价格和分配"""
        new_prices = current_prices.copy()
        new_assignments = current_assignments.copy()
        
        for license in range(self.n_licenses):
            license_bids = [(bidder, bid) for bidder, bid in bids.items() 
                           if license in bid]
            
            if license_bids:
                # 找到最高投标者
                highest_bidder, highest_bid = max(license_bids, key=lambda x: x[1])
                
                # 更新分配
                new_assignments[license] = highest_bidder
                
                # 更新价格
                new_prices[license] = highest_bid
        
        return new_prices, new_assignments
    
    def check_exiting_bidders(self, bids, current_prices):
        """检查退出的投标者"""
        exiting_bidders = set()
        
        for bidder in range(self.n_bidders):
            # 检查投标者是否还有盈利机会
            profitable_opportunities = 0
            for license in range(self.n_licenses):
                if self.valuations[bidder][license] > current_prices[license]:
                    profitable_opportunities += 1
            
            if profitable_opportunities == 0:
                exiting_bidders.add(bidder)
        
        return exiting_bidders
```

### 5.2 肾脏交换

```python
class KidneyExchange:
    def __init__(self, patient_donor_pairs, compatibility_matrix):
        """
        肾脏交换
        patient_donor_pairs: 患者-供体对
        compatibility_matrix: 兼容性矩阵
        """
        self.patient_donor_pairs = patient_donor_pairs
        self.compatibility_matrix = compatibility_matrix
        self.n_pairs = len(patient_donor_pairs)
    
    def find_exchange_cycles(self):
        """寻找交换圈"""
        # 构建交换图
        exchange_graph = self.build_exchange_graph()
        
        # 寻找所有可能的交换圈
        cycles = self.find_all_cycles(exchange_graph)
        
        return cycles
    
    def build_exchange_graph(self):
        """构建交换图"""
        graph = {i: [] for i in range(self.n_pairs)}
        
        for i in range(self.n_pairs):
            for j in range(self.n_pairs):
                if i != j:
                    # 检查pair i的供体是否与pair j的患者兼容
                    donor_i = self.patient_donor_pairs[i]['donor']
                    patient_j = self.patient_donor_pairs[j]['patient']
                    
                    if self.compatibility_matrix[donor_i][patient_j]:
                        graph[i].append(j)
        
        return graph
    
    def find_all_cycles(self, graph):
        """寻找所有圈"""
        cycles = []
        
        def dfs(node, path, visited):
            if node in path:
                # 找到圈
                cycle_start = path.index(node)
                cycle = path[cycle_start:] + [node]
                cycles.append(cycle)
                return
            
            if node in visited:
                return
            
            visited.add(node)
            path.append(node)
            
            for neighbor in graph[node]:
                dfs(neighbor, path, visited)
            
            path.pop()
            visited.remove(node)
        
        for start_node in range(self.n_pairs):
            dfs(start_node, [], set())
        
        return cycles
    
    def optimal_exchange_matching(self):
        """最优交换匹配"""
        # 寻找所有交换圈
        cycles = self.find_exchange_cycles()
        
        # 使用整数规划找到最优匹配
        optimal_matching = self.solve_optimization_problem(cycles)
        
        return optimal_matching
    
    def solve_optimization_problem(self, cycles):
        """求解优化问题"""
        # 使用整数线性规划求解最优交换匹配
        
        if not cycles:
            return []
        
        # 构建优化问题
        # 目标：最大化交换数量
        # 约束：每个患者-供体对最多参与一个交换
        
        # 简化实现：使用贪心算法
        selected_cycles = []
        used_pairs = set()
        
        # 按圈的大小排序，优先选择大圈
        sorted_cycles = sorted(cycles, key=lambda x: len(x), reverse=True)
        
        for cycle in sorted_cycles:
            # 检查圈中的患者-供体对是否已被使用
            cycle_pairs = set(cycle)
            if not cycle_pairs.intersection(used_pairs):
                selected_cycles.append(cycle)
                used_pairs.update(cycle_pairs)
        
        return selected_cycles
    
    def calculate_exchange_benefit(self, cycle):
        """计算交换收益"""
        total_benefit = 0
        
        for i in range(len(cycle)):
            current_pair = cycle[i]
            next_pair = cycle[(i + 1) % len(cycle)]
            
            # 计算当前供体对下一个患者的兼容性收益
            donor = self.patient_donor_pairs[current_pair]['donor']
            patient = self.patient_donor_pairs[next_pair]['patient']
            
            # 基于兼容性矩阵计算收益
            compatibility_score = self.compatibility_matrix[donor][patient]
            total_benefit += compatibility_score
        
        return total_benefit
    
    def find_optimal_cycles_with_benefit(self):
        """寻找带收益的最优交换圈"""
        cycles = self.find_exchange_cycles()
        
        # 计算每个圈的收益
        cycles_with_benefit = []
        for cycle in cycles:
            benefit = self.calculate_exchange_benefit(cycle)
            cycles_with_benefit.append((cycle, benefit))
        
        # 按收益排序
        cycles_with_benefit.sort(key=lambda x: x[1], reverse=True)
        
        # 选择最优的圈
        optimal_cycles = self.solve_optimization_problem([cycle for cycle, _ in cycles_with_benefit])
        
        return optimal_cycles
```

## 6. 工具实现

### 6.1 Python机制设计工具

```python
class MechanismDesignTools:
    def __init__(self):
        self.mechanism_types = {
            'vcg': VickreyClarkeGroves,
            'auction': AuctionTheory,
            'matching': MatchingTheory,
            'voting': VotingTheory
        }
    
    def create_mechanism(self, mechanism_type, **kwargs):
        """创建机制"""
        if mechanism_type in self.mechanism_types:
            mechanism_class = self.mechanism_types[mechanism_type]
            return mechanism_class(**kwargs)
        else:
            raise ValueError(f"Unknown mechanism type: {mechanism_type}")
    
    def analyze_mechanism(self, mechanism):
        """分析机制"""
        analyzer = MechanismProperties(mechanism)
        return analyzer.comprehensive_analysis()
    
    def compare_mechanisms(self, mechanisms):
        """比较机制"""
        comparison = {}
        
        for name, mechanism in mechanisms.items():
            analysis = self.analyze_mechanism(mechanism)
            comparison[name] = analysis
        
        return comparison
    
    def design_optimal_mechanism(self, objectives, constraints):
        """设计最优机制"""
        # 使用多目标优化设计最优机制
        
        # 定义目标函数
        def objective_function(mechanism_params):
            mechanism = self.create_mechanism_from_params(mechanism_params)
            
            # 计算多个目标
            efficiency = self.calculate_efficiency(mechanism)
            fairness = self.calculate_fairness(mechanism)
            incentive_compatibility = self.calculate_incentive_compatibility(mechanism)
            
            # 加权组合
            weighted_score = (objectives.get('efficiency', 1.0) * efficiency +
                            objectives.get('fairness', 1.0) * fairness +
                            objectives.get('incentive_compatibility', 1.0) * incentive_compatibility)
            
            return weighted_score
        
        # 定义约束条件
        def constraint_function(mechanism_params):
            mechanism = self.create_mechanism_from_params(mechanism_params)
            
            # 检查各种约束
            budget_balance = self.check_budget_balance(mechanism)
            individual_rationality = self.check_individual_rationality(mechanism)
            
            return [budget_balance, individual_rationality]
        
        # 使用优化算法求解
        optimal_params = self.solve_optimization_problem(objective_function, constraint_function, constraints)
        
        return self.create_mechanism_from_params(optimal_params)
    
    def create_mechanism_from_params(self, params):
        """从参数创建机制"""
        # 根据参数创建相应的机制
        mechanism_type = params.get('type', 'vcg')
        return self.create_mechanism(mechanism_type, **params)
    
    def calculate_efficiency(self, mechanism):
        """计算效率"""
        # 计算机制的帕累托效率
        return 0.8  # 简化实现
    
    def calculate_fairness(self, mechanism):
        """计算公平性"""
        # 计算机制的公平性指标
        return 0.7  # 简化实现
    
    def calculate_incentive_compatibility(self, mechanism):
        """计算激励相容性"""
        # 计算机制的激励相容性
        return 0.9  # 简化实现
    
    def check_budget_balance(self, mechanism):
        """检查预算平衡"""
        # 检查机制是否满足预算平衡
        return True  # 简化实现
    
    def check_individual_rationality(self, mechanism):
        """检查个人理性"""
        # 检查机制是否满足个人理性
        return True  # 简化实现
    
    def solve_optimization_problem(self, objective_func, constraint_func, constraints):
        """求解优化问题"""
        # 使用遗传算法或其他优化方法
        # 简化实现：返回默认参数
        return {
            'type': 'vcg',
            'efficiency_weight': 0.4,
            'fairness_weight': 0.3,
            'incentive_weight': 0.3
        }

class MechanismSimulator:
    def __init__(self, mechanism):
        self.mechanism = mechanism
    
    def simulate_mechanism(self, scenarios, iterations=1000):
        """仿真机制"""
        results = []
        
        for scenario in scenarios:
            scenario_results = []
            
            for _ in range(iterations):
                # 生成随机输入
                inputs = self.generate_random_inputs(scenario)
                
                # 运行机制
                outputs = self.mechanism(inputs)
                
                # 计算性能指标
                performance = self.calculate_performance(inputs, outputs)
                scenario_results.append(performance)
            
            # 计算统计指标
            avg_performance = np.mean(scenario_results)
            std_performance = np.std(scenario_results)
            
            results.append({
                'scenario': scenario,
                'average_performance': avg_performance,
                'std_performance': std_performance,
                'all_results': scenario_results
            })
        
        return results
    
    def generate_random_inputs(self, scenario):
        """生成随机输入"""
        import random
        
        inputs = {}
        
        if scenario['type'] == 'auction':
            # 生成拍卖场景的随机输入
            n_bidders = scenario.get('n_bidders', 5)
            n_items = scenario.get('n_items', 3)
            
            # 生成随机估值
            valuations = {}
            for bidder in range(n_bidders):
                valuations[bidder] = {}
                for item in range(n_items):
                    # 使用正态分布生成估值
                    base_value = random.uniform(10, 100)
                    noise = random.normalvariate(0, 5)
                    valuations[bidder][item] = max(0, base_value + noise)
            
            inputs['valuations'] = valuations
            inputs['bidders'] = list(range(n_bidders))
            inputs['items'] = list(range(n_items))
            
        elif scenario['type'] == 'matching':
            # 生成匹配场景的随机输入
            n_agents = scenario.get('n_agents', 10)
            
            # 生成随机偏好
            preferences = {}
            for agent in range(n_agents):
                agent_preferences = list(range(n_agents))
                random.shuffle(agent_preferences)
                preferences[agent] = agent_preferences
            
            inputs['preferences'] = preferences
            inputs['agents'] = list(range(n_agents))
            
        elif scenario['type'] == 'voting':
            # 生成投票场景的随机输入
            n_voters = scenario.get('n_voters', 100)
            n_candidates = scenario.get('n_candidates', 5)
            
            # 生成随机偏好配置
            preferences = []
            for voter in range(n_voters):
                voter_preferences = list(range(n_candidates))
                random.shuffle(voter_preferences)
                preferences.append(voter_preferences)
            
            inputs['preferences'] = preferences
            inputs['voters'] = list(range(n_voters))
            inputs['candidates'] = list(range(n_candidates))
        
        return inputs
    
    def calculate_performance(self, inputs, outputs):
        """计算性能指标"""
        performance_metrics = {}
        
        if 'valuations' in inputs:  # 拍卖场景
            # 计算效率
            efficiency = self.calculate_auction_efficiency(inputs, outputs)
            performance_metrics['efficiency'] = efficiency
            
            # 计算收益
            revenue = self.calculate_auction_revenue(outputs)
            performance_metrics['revenue'] = revenue
            
            # 计算公平性
            fairness = self.calculate_auction_fairness(inputs, outputs)
            performance_metrics['fairness'] = fairness
            
        elif 'preferences' in inputs and isinstance(inputs['preferences'], dict):  # 匹配场景
            # 计算稳定性
            stability = self.calculate_matching_stability(inputs, outputs)
            performance_metrics['stability'] = stability
            
            # 计算匹配质量
            quality = self.calculate_matching_quality(inputs, outputs)
            performance_metrics['quality'] = quality
            
        elif 'preferences' in inputs and isinstance(inputs['preferences'], list):  # 投票场景
            # 计算社会满意度
            satisfaction = self.calculate_voting_satisfaction(inputs, outputs)
            performance_metrics['satisfaction'] = satisfaction
            
            # 计算策略证明性
            strategy_proofness = self.calculate_voting_strategy_proofness(inputs, outputs)
            performance_metrics['strategy_proofness'] = strategy_proofness
        
        # 计算综合性能指标
        overall_performance = sum(performance_metrics.values()) / len(performance_metrics)
        performance_metrics['overall'] = overall_performance
        
        return performance_metrics
    
    def calculate_auction_efficiency(self, inputs, outputs):
        """计算拍卖效率"""
        valuations = inputs['valuations']
        allocation = outputs.get('allocation', {})
        
        total_value = 0
        for bidder, items in allocation.items():
            for item in items:
                total_value += valuations[bidder][item]
        
        # 计算最优价值
        optimal_value = self.calculate_optimal_auction_value(valuations)
        
        return total_value / optimal_value if optimal_value > 0 else 0
    
    def calculate_auction_revenue(self, outputs):
        """计算拍卖收益"""
        payments = outputs.get('payments', {})
        return sum(payments.values())
    
    def calculate_auction_fairness(self, inputs, outputs):
        """计算拍卖公平性"""
        # 基于收益分配的公平性
        payments = outputs.get('payments', {})
        if not payments:
            return 0
        
        # 使用基尼系数衡量公平性
        payment_values = list(payments.values())
        gini = self.calculate_gini_coefficient(payment_values)
        
        return 1 - gini  # 公平性 = 1 - 基尼系数
    
    def calculate_matching_stability(self, inputs, outputs):
        """计算匹配稳定性"""
        # 检查匹配是否稳定
        preferences = inputs['preferences']
        matching = outputs.get('matching', {})
        
        # 计算不稳定对的数量
        unstable_pairs = 0
        total_pairs = 0
        
        for agent1 in preferences:
            for agent2 in preferences:
                if agent1 != agent2:
                    total_pairs += 1
                    if self.is_unstable_pair(agent1, agent2, preferences, matching):
                        unstable_pairs += 1
        
        return 1 - (unstable_pairs / total_pairs) if total_pairs > 0 else 1
    
    def calculate_matching_quality(self, inputs, outputs):
        """计算匹配质量"""
        preferences = inputs['preferences']
        matching = outputs.get('matching', {})
        
        total_quality = 0
        matched_pairs = 0
        
        for agent, partner in matching.items():
            if partner is not None:
                # 计算匹配质量（偏好排名）
                rank = preferences[agent].index(partner)
                quality = 1 - (rank / len(preferences[agent]))
                total_quality += quality
                matched_pairs += 1
        
        return total_quality / matched_pairs if matched_pairs > 0 else 0
    
    def calculate_voting_satisfaction(self, inputs, outputs):
        """计算投票满意度"""
        preferences = inputs['preferences']
        winner = outputs.get('winner')
        
        if winner is None:
            return 0
        
        total_satisfaction = 0
        for voter_preferences in preferences:
            # 计算选民对获胜者的满意度
            rank = voter_preferences.index(winner)
            satisfaction = 1 - (rank / len(voter_preferences))
            total_satisfaction += satisfaction
        
        return total_satisfaction / len(preferences)
    
    def calculate_voting_strategy_proofness(self, inputs, outputs):
        """计算投票策略证明性"""
        # 简化实现：基于投票机制的固有性质
        return 0.8  # 假设大多数投票机制都有一定的策略证明性
    
    def calculate_optimal_auction_value(self, valuations):
        """计算最优拍卖价值"""
        # 使用贪心算法计算近似最优价值
        total_value = 0
        used_items = set()
        
        # 按价值排序所有(投标者, 物品)对
        all_pairs = []
        for bidder, items in valuations.items():
            for item, value in items.items():
                all_pairs.append((value, bidder, item))
        
        all_pairs.sort(reverse=True)
        
        for value, bidder, item in all_pairs:
            if item not in used_items:
                total_value += value
                used_items.add(item)
        
        return total_value
    
    def calculate_gini_coefficient(self, values):
        """计算基尼系数"""
        if not values:
            return 0
        
        sorted_values = sorted(values)
        n = len(sorted_values)
        cumsum = 0
        
        for i, value in enumerate(sorted_values):
            cumsum += (i + 1) * value
        
        return (2 * cumsum) / (n * sum(sorted_values)) - (n + 1) / n
    
    def is_unstable_pair(self, agent1, agent2, preferences, matching):
        """检查是否为不稳定对"""
        partner1 = matching.get(agent1)
        partner2 = matching.get(agent2)
        
        # 检查agent1是否更偏好agent2
        prefers_agent2 = (partner1 is None or 
                         preferences[agent1].index(agent2) < preferences[agent1].index(partner1))
        
        # 检查agent2是否更偏好agent1
        prefers_agent1 = (partner2 is None or 
                         preferences[agent2].index(agent1) < preferences[agent2].index(partner2))
        
        return prefers_agent2 and prefers_agent1
```

### 6.2 JavaScript机制设计实现

```javascript
class MechanismDesignTools {
  constructor() {
    this.mechanismTypes = {
      'vcg': VickreyClarkeGroves,
      'auction': AuctionTheory,
      'matching': MatchingTheory,
      'voting': VotingTheory
    };
  }
  
  createMechanism(mechanismType, config) {
    if (mechanismType in this.mechanismTypes) {
      const MechanismClass = this.mechanismTypes[mechanismType];
      return new MechanismClass(config);
    } else {
      throw new Error(`Unknown mechanism type: ${mechanismType}`);
    }
  }
  
  analyzeMechanism(mechanism) {
    const analyzer = new MechanismProperties(mechanism);
    return analyzer.comprehensiveAnalysis();
  }
  
  compareMechanisms(mechanisms) {
    const comparison = {};
    
    for (const [name, mechanism] of Object.entries(mechanisms)) {
      const analysis = this.analyzeMechanism(mechanism);
      comparison[name] = analysis;
    }
    
    return comparison;
  }
  
  designOptimalMechanism(objectives, constraints) {
    // 这里需要实现机制设计的优化算法
    // 简化实现
    return null;
  }
}

class MechanismSimulator {
  constructor(mechanism) {
    this.mechanism = mechanism;
  }
  
  simulateMechanism(scenarios, iterations = 1000) {
    const results = [];
    
    for (const scenario of scenarios) {
      const scenarioResults = [];
      
      for (let i = 0; i < iterations; i++) {
        // 生成随机输入
        const inputs = this.generateRandomInputs(scenario);
        
        // 运行机制
        const outputs = this.mechanism(inputs);
        
        // 计算性能指标
        const performance = this.calculatePerformance(inputs, outputs);
        scenarioResults.push(performance);
      }
      
      // 计算统计指标
      const avgPerformance = scenarioResults.reduce((a, b) => a + b, 0) / scenarioResults.length;
      const stdPerformance = Math.sqrt(scenarioResults.reduce((sq, n) => sq + Math.pow(n - avgPerformance, 2), 0) / scenarioResults.length);
      
      results.push({
        scenario: scenario,
        averagePerformance: avgPerformance,
        stdPerformance: stdPerformance,
        allResults: scenarioResults
      });
    }
    
    return results;
  }
  
  generateRandomInputs(scenario) {
    // 这里需要实现具体的输入生成
    // 简化实现
    return {};
  }
  
  calculatePerformance(inputs, outputs) {
    // 这里需要实现具体的性能计算
    // 简化实现
    return 0.5;
  }
}
```

## 7. 学习路径

### 7.1 基础学习

1. **机制设计基础** (2-3周)
   - 机制设计概念
   - 显示原理
   - 激励相容性

2. **拍卖理论** (3-4周)
   - 单物品拍卖
   - 多物品拍卖
   - 组合拍卖

### 7.2 进阶学习

1. **匹配理论** (3-4周)
   - 稳定匹配
   - 学校选择
   - 肾脏交换

2. **投票理论** (2-3周)
   - 投票机制
   - 投票悖论
   - 社会选择理论

### 7.3 应用实践

1. **实际应用** (4-5周)
   - 频谱拍卖
   - 在线广告
   - 器官交换

2. **工具开发** (3-4周)
   - 机制设计工具
   - 仿真工具
   - 优化工具

## 8. 总结

机制设计理论为设计有效的经济机制提供了重要的理论基础。通过深入理解拍卖理论、匹配理论和投票理论，可以设计出既满足激励相容性又实现社会目标的机制。
