# 8.1.3-æ—¶æ€ç±»å‹ç†è®ºæ·±åŒ–

## 1. æ¦‚è¿°

æ—¶æ€ç±»å‹ç†è®ºæ˜¯ç±»å‹ç†è®ºçš„é‡è¦åˆ†æ”¯ï¼Œä¸“æ³¨äºæ—¶é—´ç›¸å…³çš„ç±»å‹ç³»ç»Ÿå’Œå®æ—¶çº¦æŸã€‚
å®ƒå°†æ—¶é—´ä½œä¸ºç±»å‹ç³»ç»Ÿçš„ä¸€ç­‰å…¬æ°‘ï¼Œä¸ºå®æ—¶ç³»ç»Ÿã€å¹¶å‘ç³»ç»Ÿå’Œæ—¶é—´æ•æ„Ÿåº”ç”¨æä¾›äº†å¼ºå¤§çš„ç†è®ºåŸºç¡€ã€‚

### 1.1. æ ¸å¿ƒæ¦‚å¿µ

- **æ—¶é—´ç±»å‹**ï¼šæ—¶é—´ä½œä¸ºç±»å‹ç³»ç»Ÿçš„åŸºæœ¬æ¦‚å¿µ
- **å®æ—¶çº¦æŸ**ï¼šç¼–è¯‘æ—¶æ£€æŸ¥æ—¶é—´çº¦æŸ
- **æ—¶åºé€»è¾‘**ï¼šç»“åˆæ—¶æ€é€»è¾‘çš„ç±»å‹ç³»ç»Ÿ
- **æ—¶é—´å®‰å…¨**ï¼šç¡®ä¿æ—¶é—´ç›¸å…³æ“ä½œçš„æ­£ç¡®æ€§

## 2. ï¸ æ ¸å¿ƒç†è®ºæ¡†æ¶

### 2.1. æ—¶æ€é€»è¾‘åŸºç¡€

```haskell
-- æ—¶æ€ç±»å‹ç³»ç»Ÿç¤ºä¾‹
data Temporal a where
  Now :: a -> Temporal a
  Always :: Temporal a -> Temporal a
  Eventually :: Temporal a -> Temporal a
  Until :: Temporal a -> Temporal a -> Temporal a

-- æ—¶æ€å‡½æ•°ç±»å‹
type TemporalFunction a b = Temporal a -> Temporal b

-- æ—¶é—´çº¦æŸç¤ºä¾‹
class TimeConstraint a where
  deadline :: a -> Time
  duration :: a -> Duration
```

### 2.2. æ—¶æ€ç±»å‹ç³»ç»Ÿ

#### 2.2.1. åŸºæœ¬è§„åˆ™

1. **æ—¶é—´å˜é‡è§„åˆ™**ï¼šæ—¶é—´å˜é‡å¿…é¡»åœ¨æŒ‡å®šæ—¶é—´å†…ä½¿ç”¨
2. **æ—¶æ€å‡½æ•°è§„åˆ™**ï¼šæ—¶æ€å‡½æ•°å¿…é¡»æ»¡è¶³æ—¶é—´çº¦æŸ
3. **å®æ—¶çº¦æŸè§„åˆ™**ï¼šå®æ—¶æ“ä½œå¿…é¡»åœ¨æˆªæ­¢æ—¶é—´å†…å®Œæˆ

#### 2.2.2. ç±»å‹æ„é€ 

```rust
// Rustä¸­çš„æ—¶æ€ç±»å‹ç³»ç»Ÿ
struct Temporal<T> {
    value: T,
    deadline: Instant,
    created: Instant,
}

impl<T> Temporal<T> {
    fn new(value: T, deadline: Duration) -> Self {
        let now = Instant::now();
        Temporal {
            value,
            deadline: now + deadline,
            created: now,
        }
    }
    
    fn is_expired(&self) -> bool {
        Instant::now() > self.deadline
    }
    
    fn time_remaining(&self) -> Duration {
        if self.is_expired() {
            Duration::ZERO
        } else {
            self.deadline - Instant::now()
        }
    }
}
```

### 2.3. é«˜çº§æ—¶æ€ç±»å‹

#### 2.3.1. å®æ—¶ç±»å‹

```haskell
-- å®æ—¶ç±»å‹ï¼šå¿…é¡»åœ¨æŒ‡å®šæ—¶é—´å†…å®Œæˆ
data RealTime a where
  RealTime :: a -> Duration -> RealTime a
  
-- å®æ—¶å‡½æ•°
type RealTimeFunction a b = a -> RealTime b
```

#### 2.3.2. è½¯å®æ—¶ç±»å‹

```haskell
-- è½¯å®æ—¶ç±»å‹ï¼šå°½é‡åœ¨æŒ‡å®šæ—¶é—´å†…å®Œæˆ
data SoftRealTime a where
  SoftRealTime :: a -> Duration -> SoftRealTime a
  
-- è½¯å®æ—¶å‡½æ•°
type SoftRealTimeFunction a b = a -> SoftRealTime b
```

## 3. é«˜çº§ç†è®ºå‘å±•

### 3.1. æ—¶æ€é€»è¾‘æ‰©å±•

#### 3.1.1. æ—¶æ€æ¨¡æ€

```haskell
-- æ—¶æ€æ¨¡æ€ï¼šæ—¶é—´ç›¸å…³çš„ç±»å‹æ„é€ 
data TemporalModal a where
  Past :: a -> TemporalModal a
  Present :: a -> TemporalModal a
  Future :: a -> TemporalModal a
  Interval :: Time -> Time -> a -> TemporalModal a
```

#### 3.1.2. æ—¶æ€é€»è¾‘è¿æ¥è¯

```haskell
-- æ—¶æ€é€»è¾‘è¿æ¥è¯
data TemporalLogic a b where
  TemporalAnd :: Temporal a -> Temporal b -> TemporalLogic a b      -- âˆ§
  TemporalOr :: Temporal a -> Temporal b -> TemporalLogic a b       -- âˆ¨
  TemporalImplies :: Temporal a -> Temporal b -> TemporalLogic a b  -- â†’
  TemporalUntil :: Temporal a -> Temporal b -> TemporalLogic a b    -- U
```

### 3.2. æ—¶æ€ç±»å‹ç³»ç»Ÿå˜ç§

#### 3.2.1. æ—¶æ€Haskell

```haskell
-- æ—¶æ€Haskellæ‰©å±•
{-# LANGUAGE TemporalTypes #-}

-- æ—¶æ€å‡½æ•°
f :: a %time-> b
f x = -- å¿…é¡»åœ¨æŒ‡å®šæ—¶é—´å†…å®Œæˆ

-- æ—¶æ€æ•°æ®ç±»å‹
data TemporalList a where
  Nil :: TemporalList a
  Cons :: a %time-> TemporalList a %time-> TemporalList a
```

#### 3.2.2. Rustæ—¶æ€ç³»ç»Ÿ

```rust
// Rustçš„æ—¶æ€ç±»å‹ç³»ç»Ÿ
use std::time::{Duration, Instant};

struct TemporalSystem<T> {
    data: T,
    time_constraints: TimeConstraints,
}

struct TimeConstraints {
    deadline: Instant,
    max_duration: Duration,
    priority: Priority,
}

impl<T> TemporalSystem<T> {
    fn new(data: T, deadline: Duration) -> Self {
        TemporalSystem {
            data,
            time_constraints: TimeConstraints {
                deadline: Instant::now() + deadline,
                max_duration: deadline,
                priority: Priority::Normal,
            },
        }
    }
    
    fn execute<F, R>(self, f: F) -> Result<R, TimeoutError>
    where
        F: FnOnce(T) -> R,
    {
        let start = Instant::now();
        if start > self.time_constraints.deadline {
            return Err(TimeoutError::AlreadyExpired);
        }
        
        let result = f(self.data);
        let elapsed = start.elapsed();
        
        if elapsed > self.time_constraints.max_duration {
            Err(TimeoutError::ExceededDuration)
        } else {
            Ok(result)
        }
    }
}
```

## 4. åº”ç”¨åœºæ™¯ä¸å®ä¾‹

### 4.1. å®æ—¶ç³»ç»Ÿ

#### 4.1.1. å®æ—¶ä»»åŠ¡è°ƒåº¦

```rust
// å®æ—¶ä»»åŠ¡è°ƒåº¦å™¨
use std::time::{Duration, Instant};
use std::sync::{Arc, Mutex};

struct RealTimeScheduler {
    tasks: Arc<Mutex<Vec<RealTimeTask>>>,
}

struct RealTimeTask {
    id: u64,
    deadline: Instant,
    priority: u32,
    execute: Box<dyn FnOnce() -> Result<(), ()> + Send>,
}

impl RealTimeScheduler {
    fn new() -> Self {
        RealTimeScheduler {
            tasks: Arc::new(Mutex::new(Vec::new())),
        }
    }
    
    fn add_task<F>(&self, deadline: Duration, priority: u32, task: F)
    where
        F: FnOnce() -> Result<(), ()> + Send + 'static,
    {
        let real_time_task = RealTimeTask {
            id: rand::random(),
            deadline: Instant::now() + deadline,
            priority,
            execute: Box::new(task),
        };
        
        let mut tasks = self.tasks.lock().unwrap();
        tasks.push(real_time_task);
        tasks.sort_by(|a, b| a.deadline.cmp(&b.deadline));
    }
    
    fn execute_earliest_deadline(&self) -> Result<(), SchedulerError> {
        let mut tasks = self.tasks.lock().unwrap();
        
        if let Some(task) = tasks.pop() {
            if Instant::now() > task.deadline {
                return Err(SchedulerError::DeadlineMissed);
            }
            
            (task.execute)()
        } else {
            Err(SchedulerError::NoTasks)
        }
    }
}
```

#### 4.1.2. å®æ—¶æ•°æ®æµ

```haskell
-- å®æ—¶æ•°æ®æµå¤„ç†
data RealTimeStream a where
  Stream :: [a] -> Duration -> RealTimeStream a

processRealTimeStream :: RealTimeStream a %time-> RealTimeStream b
processRealTimeStream (Stream data duration) = 
    Stream (map process data) duration

-- å®æ—¶çª—å£æ“ä½œ
realTimeWindow :: Duration -> RealTimeStream a %time-> RealTimeStream [a]
realTimeWindow windowSize (Stream data duration) = 
    Stream (windowed windowSize data) duration
```

### 4.2. å¹¶å‘ç³»ç»Ÿ

#### 4.2.1. æ—¶æ€å¹¶å‘æ§åˆ¶

```rust
// æ—¶æ€å¹¶å‘æ§åˆ¶
use std::sync::{Arc, Mutex};
use std::time::{Duration, Instant};

struct TemporalLock<T> {
    data: Arc<Mutex<T>>,
    timeout: Duration,
}

impl<T> TemporalLock<T> {
    fn new(data: T, timeout: Duration) -> Self {
        TemporalLock {
            data: Arc::new(Mutex::new(data)),
            timeout,
        }
    }
    
    fn with_timeout<F, R>(&self, f: F) -> Result<R, TimeoutError>
    where
        F: FnOnce(&mut T) -> R,
    {
        let start = Instant::now();
        
        match self.data.try_lock() {
            Ok(mut guard) => {
                let result = f(&mut *guard);
                let elapsed = start.elapsed();
                
                if elapsed > self.timeout {
                    Err(TimeoutError::ExceededTimeout)
                } else {
                    Ok(result)
                }
            }
            Err(_) => Err(TimeoutError::LockAcquisitionFailed),
        }
    }
}
```

#### 4.2.2. æ—¶æ€äº‹åŠ¡

```haskell
-- æ—¶æ€äº‹åŠ¡
data TemporalTransaction a where
  Transaction :: a -> Duration -> TemporalTransaction a

runTemporalTransaction :: TemporalTransaction a %time-> Either TimeoutError a
runTemporalTransaction (Transaction action duration) = 
    -- åœ¨æŒ‡å®šæ—¶é—´å†…æ‰§è¡Œäº‹åŠ¡
    case executeWithTimeout action duration of
        Just result -> Right result
        Nothing -> Left TimeoutError
```

### 4.3. æ—¶é—´æ•æ„Ÿåº”ç”¨

#### 4.3.1. å®æ—¶æ¸¸æˆ

```rust
// å®æ—¶æ¸¸æˆå¾ªç¯
struct RealTimeGameLoop {
    frame_time: Duration,
    max_frame_time: Duration,
}

impl RealTimeGameLoop {
    fn new(target_fps: u32) -> Self {
        RealTimeGameLoop {
            frame_time: Duration::from_secs(1) / target_fps,
            max_frame_time: Duration::from_millis(16), // 60 FPS
        }
    }
    
    fn run<F>(&self, game_logic: F) -> Result<(), GameError>
    where
        F: FnMut(Duration) -> Result<(), GameError>,
    {
        let mut last_frame = Instant::now();
        
        loop {
            let frame_start = Instant::now();
            let delta_time = frame_start - last_frame;
            
            if delta_time > self.max_frame_time {
                return Err(GameError::FrameTimeExceeded);
            }
            
            game_logic(delta_time)?;
            
            let frame_end = Instant::now();
            let frame_duration = frame_end - frame_start;
            
            if frame_duration < self.frame_time {
                std::thread::sleep(self.frame_time - frame_duration);
            }
            
            last_frame = frame_start;
        }
    }
}
```

#### 4.3.2. å®æ—¶éŸ³é¢‘å¤„ç†

```haskell
-- å®æ—¶éŸ³é¢‘å¤„ç†
data RealTimeAudio where
  AudioStream :: [Sample] -> SampleRate -> RealTimeAudio

processRealTimeAudio :: RealTimeAudio %time-> RealTimeAudio
processRealTimeAudio (AudioStream samples rate) = 
    AudioStream (map processSample samples) rate

-- å®æ—¶éŸ³é¢‘æ•ˆæœ
realTimeEffect :: AudioEffect -> RealTimeAudio %time-> RealTimeAudio
realTimeEffect effect (AudioStream samples rate) = 
    AudioStream (map (applyEffect effect) samples) rate
```

## 5. ğŸ”— ä¸å…¶ä»–ç†è®ºçš„äº¤å‰

### 5.1. ä¸è‡ªåŠ¨æœºç†è®º

#### 5.1.1. æ—¶æ€è‡ªåŠ¨æœº

```haskell
-- æ—¶æ€è‡ªåŠ¨æœº
data TemporalAutomaton s a where
  TemporalAutomaton :: s %time-> (s %time-> a %time-> s) %time-> TemporalAutomaton s a

runTemporalAutomaton :: TemporalAutomaton s a %time-> [a] %time-> s
runTemporalAutomaton (TemporalAutomaton s f) [] = s
runTemporalAutomaton (TemporalAutomaton s f) (x:xs) = 
    runTemporalAutomaton (TemporalAutomaton (f s x) f) xs
```

### 5.2. ä¸Petriç½‘ç†è®º

#### 5.2.1. æ—¶æ€Petriç½‘

```haskell
-- æ—¶æ€Petriç½‘ï¼štokenæœ‰æ—¶é—´çº¦æŸ
data TemporalPetriNet p t where
  TemporalPetriNet :: Map p (Int, Duration) %time-> [(p, t, p, Duration)] %time-> TemporalPetriNet p t

fireTemporalTransition :: TemporalPetriNet p t %time-> t %time-> Maybe (TemporalPetriNet p t)
fireTemporalTransition (TemporalPetriNet places transitions) t = 
    -- æ—¶æ€æ“ä½œï¼šæ£€æŸ¥æ—¶é—´çº¦æŸ
    -- ... å®ç°é€»è¾‘
```

### 5.3. ä¸é‡å­è®¡ç®—

#### 5.3.1. æ—¶æ€é‡å­ç±»å‹

```haskell
-- æ—¶æ€é‡å­ç±»å‹
data TemporalQuantum a where
  TemporalQubit :: QuantumState -> Duration -> TemporalQuantum Qubit
  TemporalEntangled :: TemporalQuantum a %time-> TemporalQuantum b %time-> TemporalQuantum (a, b)

-- æ—¶æ€é‡å­æ“ä½œ
temporalMeasure :: TemporalQuantum Qubit %time-> (Bool, Duration)
temporalMeasure (TemporalQubit state duration) = 
    -- æµ‹é‡æ“ä½œï¼šåœ¨æŒ‡å®šæ—¶é—´å†…å®Œæˆ
    (measureResult, measurementTime)
```

## 6. å‘å±•å‰æ²¿ä¸æŒ‘æˆ˜

### 6.1. ç ”ç©¶æ–¹å‘

#### 6.1.1. æ—¶æ€ç±»å‹ç³»ç»Ÿä¼˜åŒ–

- **ç¼–è¯‘ä¼˜åŒ–**ï¼šæ—¶æ€ç±»å‹çš„ç¼–è¯‘æ—¶ä¼˜åŒ–
- **è¿è¡Œæ—¶æ£€æŸ¥**ï¼šé«˜æ•ˆçš„æ—¶æ€çº¦æŸæ£€æŸ¥
- **ç±»å‹æ¨å¯¼**ï¼šè‡ªåŠ¨æ—¶æ€ç±»å‹æ¨å¯¼

#### 6.1.2. æ—¶æ€é€»è¾‘æ‰©å±•

- **é«˜é˜¶æ—¶æ€é€»è¾‘**ï¼šé«˜é˜¶æ—¶æ€ç±»å‹ç³»ç»Ÿ
- **æ—¶æ€ä¾èµ–ç±»å‹**ï¼šç»“åˆä¾èµ–ç±»å‹çš„æ—¶æ€ç³»ç»Ÿ
- **æ—¶æ€åŒä¼¦ç±»å‹**ï¼šæ—¶æ€åŒä¼¦ç±»å‹ç†è®º

#### 6.1.3. å®é™…åº”ç”¨æ‰©å±•

- **åˆ†å¸ƒå¼æ—¶æ€ç±»å‹**ï¼šåˆ†å¸ƒå¼ç³»ç»Ÿä¸­çš„æ—¶æ€ç±»å‹
- **å®æ—¶æ—¶æ€ç±»å‹**ï¼šå®æ—¶ç³»ç»Ÿçš„æ—¶æ€ç±»å‹
- **å®‰å…¨æ—¶æ€ç±»å‹**ï¼šå®‰å…¨åè®®ä¸­çš„æ—¶æ€ç±»å‹

### 6.2. æŠ€æœ¯æŒ‘æˆ˜

#### 6.2.1. æ€§èƒ½æŒ‘æˆ˜

```haskell
-- æ—¶æ€çº¦æŸæ£€æŸ¥çš„æ€§èƒ½ä¼˜åŒ–
class TemporalCheck a where
    checkTemporal :: a -> Bool
    optimizeTemporal :: a -> a
```

#### 6.2.2. è¡¨è¾¾èƒ½åŠ›æŒ‘æˆ˜

```haskell
-- æ‰©å±•æ—¶æ€ç±»å‹è¡¨è¾¾èƒ½åŠ›
data ExtendedTemporal a where
    Temporal :: a -> ExtendedTemporal a
    RealTime :: a -> ExtendedTemporal a
    SoftRealTime :: a -> ExtendedTemporal a
```

#### 6.2.3. å·¥å…·æ”¯æŒæŒ‘æˆ˜

- **IDEæ”¯æŒ**ï¼šæ—¶æ€ç±»å‹çš„IDEé›†æˆ
- **è°ƒè¯•å·¥å…·**ï¼šæ—¶æ€ç±»å‹è°ƒè¯•æ”¯æŒ
- **æ€§èƒ½åˆ†æ**ï¼šæ—¶æ€ç±»å‹æ€§èƒ½åˆ†æ

## 7. ğŸ› ï¸ å·¥å…·ä¸å®ç°

### 7.1. ç¼–ç¨‹è¯­è¨€æ”¯æŒ

#### 7.1.1. Rust

```rust
// Rustçš„æ—¶æ€ç±»å‹ç³»ç»Ÿ
use std::time::{Duration, Instant};

#[derive(Debug)]
struct Temporal<T> {
    value: T,
    deadline: Instant,
}

impl<T> Temporal<T> {
    fn new(value: T, deadline: Duration) -> Self {
        Temporal {
            value,
            deadline: Instant::now() + deadline,
        }
    }
    
    fn is_expired(&self) -> bool {
        Instant::now() > self.deadline
    }
    
    fn execute<F, R>(self, f: F) -> Result<R, TimeoutError>
    where
        F: FnOnce(T) -> R,
    {
        if self.is_expired() {
            Err(TimeoutError::Expired)
        } else {
            Ok(f(self.value))
        }
    }
}
```

#### 7.1.2. Temporal Haskell

```haskell
-- Temporal Haskellå®ç°
{-# LANGUAGE TemporalTypes #-}

-- æ—¶æ€å‡½æ•°
temporalFunction :: a %time-> b
temporalFunction x = -- å¿…é¡»åœ¨æŒ‡å®šæ—¶é—´å†…å®Œæˆ

-- æ—¶æ€æ•°æ®ç»“æ„
data TemporalVector a where
    Empty :: TemporalVector a
    Append :: a %time-> TemporalVector a %time-> TemporalVector a
```

#### 7.1.3. Idris 2

```idris
-- Idris 2çš„æ—¶æ€ç±»å‹
data Temporal : Type -> Type where
    MkTemporal : a -> Temporal a

-- æ—¶æ€å‡½æ•°
temporalMap : (a -> b) -> Temporal a -> Temporal b
temporalMap f (MkTemporal x) = MkTemporal (f x)
```

### 7.2. å½¢å¼åŒ–å·¥å…·

#### 7.2.1. Coq

```coq
(* Coqä¸­çš„æ—¶æ€é€»è¾‘ *)
Inductive temporal_prop : Type :=
| temporal_and : temporal_prop -> temporal_prop -> temporal_prop
| temporal_or : temporal_prop -> temporal_prop -> temporal_prop
| temporal_until : temporal_prop -> temporal_prop -> temporal_prop
| temporal_always : temporal_prop -> temporal_prop
| temporal_eventually : temporal_prop -> temporal_prop.

(* æ—¶æ€é€»è¾‘è§„åˆ™ *)
Axiom temporal_until_rule : forall A B, temporal_prop -> temporal_prop -> Prop.
```

#### 7.2.2. Agda

```agda
-- Agdaä¸­çš„æ—¶æ€ç±»å‹
data Temporal (A : Set) : Set where
  temporal : A â†’ Temporal A

-- æ—¶æ€å‡½æ•°
TemporalFunction : Set â†’ Set â†’ Set
TemporalFunction A B = Temporal A â†’ Temporal B
```

### 7.3. éªŒè¯å·¥å…·

#### 7.3.1. æ—¶æ€ç±»å‹æ£€æŸ¥å™¨

```haskell
-- æ—¶æ€ç±»å‹æ£€æŸ¥å™¨
class TemporalTypeCheck a where
    typeCheck :: a -> Bool
    temporalCheck :: a -> Bool

instance TemporalTypeCheck (Temporal a) where
    typeCheck _ = True
    temporalCheck (Temporal _) = True
```

## 8. å­¦ä¹ è·¯å¾„

### 8.1. åŸºç¡€é˜¶æ®µ

1. **æ—¶æ€é€»è¾‘åŸºç¡€**
   - æ—¶æ€é€»è¾‘è¯­æ³•å’Œè¯­ä¹‰
   - æ—¶æ€é€»è¾‘è¯æ˜ç³»ç»Ÿ
   - æ—¶æ€é€»è¾‘ä¸ç»å…¸é€»è¾‘çš„å…³ç³»

2. **æ—¶æ€ç±»å‹ç³»ç»Ÿ**
   - æ—¶æ€ç±»å‹è¯­æ³•
   - æ—¶æ€ç±»å‹è§„åˆ™
   - æ—¶æ€ç±»å‹æ¨å¯¼

3. **å®æ—¶ç³»ç»Ÿ**
   - å®æ—¶ç³»ç»ŸåŸç†
   - æ—¶é—´çº¦æŸç®¡ç†
   - å®æ—¶è°ƒåº¦ç®—æ³•

### 8.2. è¿›é˜¶é˜¶æ®µ

1. **é«˜çº§æ—¶æ€ç±»å‹**
   - æ—¶æ€æ¨¡æ€ç³»ç»Ÿ
   - æ—¶æ€é€»è¾‘è¿æ¥è¯
   - æ—¶æ€ç±»å‹å˜ç§

2. **æ—¶æ€ç±»å‹å˜ç§**
   - æ—¶æ€Haskell
   - Rustæ—¶æ€ç³»ç»Ÿ
   - Idris 2æ—¶æ€ç±»å‹

3. **åº”ç”¨å®è·µ**
   - å®æ—¶ç³»ç»Ÿåº”ç”¨
   - å¹¶å‘ç³»ç»Ÿåº”ç”¨
   - æ—¶é—´æ•æ„Ÿåº”ç”¨

### 8.3. é«˜çº§é˜¶æ®µ

1. **ç†è®ºç ”ç©¶**
   - æ—¶æ€ç±»å‹ç†è®ºå‰æ²¿
   - æ—¶æ€é€»è¾‘æ‰©å±•
   - æ—¶æ€ç±»å‹ç³»ç»Ÿä¼˜åŒ–

2. **å·¥å…·å¼€å‘**
   - æ—¶æ€ç±»å‹æ£€æŸ¥å™¨
   - æ—¶æ€ç±»å‹ç¼–è¯‘å™¨
   - æ—¶æ€ç±»å‹è°ƒè¯•å·¥å…·

3. **è·¨é¢†åŸŸåº”ç”¨**
   - é‡å­è®¡ç®—åº”ç”¨
   - åˆ†å¸ƒå¼ç³»ç»Ÿåº”ç”¨
   - å®‰å…¨åè®®åº”ç”¨

## 9. ğŸ”— ç›¸å…³é“¾æ¥

- [8.1.1-çº¿æ€§ç±»å‹ç†è®ºæ·±åŒ–](8.1.1-çº¿æ€§ç±»å‹ç†è®ºæ·±åŒ–.md)
- [8.1.2-ä»¿å°„ç±»å‹ç†è®ºæ·±åŒ–](8.1.2-ä»¿å°„ç±»å‹ç†è®ºæ·±åŒ–.md)
- [8.1.4-é‡å­ç±»å‹ç†è®ºæ·±åŒ–](8.1.4-é‡å­ç±»å‹ç†è®ºæ·±åŒ–.md)
- [8.1.5-ä¾èµ–ç±»å‹ç†è®ºæ·±åŒ–](8.1.5-ä¾èµ–ç±»å‹ç†è®ºæ·±åŒ–.md)
- [8.1.6-åŒä¼¦ç±»å‹ç†è®ºæ·±åŒ–](8.1.6-åŒä¼¦ç±»å‹ç†è®ºæ·±åŒ–.md)
- [8.2-è‡ªåŠ¨æœºç†è®ºæ·±åŒ–](../8.2-è‡ªåŠ¨æœºç†è®ºæ·±åŒ–/README.md)
- [8.4-æ—¶æ€é€»è¾‘æ§åˆ¶ç†è®ºæ·±åŒ–](../8.4-æ—¶æ€é€»è¾‘æ§åˆ¶ç†è®ºæ·±åŒ–/README.md)
- [8.7-é‡å­ç³»ç»Ÿç†è®º](../8.7-é‡å­ç³»ç»Ÿç†è®º/README.md)

---

**ğŸ“– è¿”å›å¯¼èˆª**:

- [è¿”å›ç±»å‹ç†è®ºæ·±åŒ–å¯¼èˆª](README.md)
- [è¿”å›å½¢å¼ç†è®ºæ·±åŒ–æ€»å¯¼èˆª](../README.md)
