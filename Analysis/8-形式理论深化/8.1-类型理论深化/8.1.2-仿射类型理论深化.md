# 8.1.2-ä»¿å°„ç±»å‹ç†è®ºæ·±åŒ–

## ğŸ“– æ¦‚è¿°

ä»¿å°„ç±»å‹ç†è®ºæ˜¯çº¿æ€§ç±»å‹ç†è®ºçš„é‡è¦å˜ç§ï¼Œä¸“æ³¨äº"æœ€å¤šä½¿ç”¨ä¸€æ¬¡"çš„èµ„æºç®¡ç†è¯­ä¹‰ã€‚
ä¸ä¸¥æ ¼çš„çº¿æ€§ç±»å‹ä¸åŒï¼Œä»¿å°„ç±»å‹å…è®¸å€¼è¢«ä¸¢å¼ƒï¼ˆæœªä½¿ç”¨ï¼‰ï¼Œä½†ä¸èƒ½è¢«é‡å¤ä½¿ç”¨ï¼Œä¸ºå®é™…ç¼–ç¨‹æä¾›äº†æ›´çµæ´»çš„æ¨¡å‹ã€‚

### æ ¸å¿ƒæ¦‚å¿µ

- **ä»¿å°„æ€§**ï¼šæ¯ä¸ªå€¼æœ€å¤šä½¿ç”¨ä¸€æ¬¡ï¼Œå¯ä»¥ä¸¢å¼ƒ
- **æ‰€æœ‰æƒè½¬ç§»**ï¼šèµ„æºçš„æ‰€æœ‰æƒå¯ä»¥è½¬ç§»ä½†ä¸èƒ½å…±äº«
- **ç”Ÿå‘½å‘¨æœŸç®¡ç†**ï¼šç¼–è¯‘æ—¶ç¡®å®šèµ„æºçš„ç”Ÿå‘½å‘¨æœŸ
- **å†…å­˜å®‰å…¨**ï¼šé˜²æ­¢æ‚¬ç©ºæŒ‡é’ˆå’Œå†…å­˜æ³„æ¼

## ğŸ—ï¸ æ ¸å¿ƒç†è®ºæ¡†æ¶

### ä»¿å°„é€»è¾‘åŸºç¡€

```haskell
-- ä»¿å°„ç±»å‹ç³»ç»Ÿç¤ºä¾‹
data Affine a where
  Affine :: a -> Affine a
  Discard :: Affine a -> ()
  Use :: Affine a -> a

-- ä»¿å°„å‡½æ•°ç±»å‹
type AffineFunction a b = a -> Affine b

-- èµ„æºç®¡ç†ç¤ºä¾‹
class AffineResource a where
  acquire :: Affine a
  release :: a -> ()
```

### ä»¿å°„ç±»å‹ç³»ç»Ÿ

#### åŸºæœ¬è§„åˆ™

1. **ä»¿å°„å˜é‡è§„åˆ™**ï¼šæ¯ä¸ªä»¿å°„å˜é‡æœ€å¤šä½¿ç”¨ä¸€æ¬¡
2. **ä»¿å°„å‡½æ•°è§„åˆ™**ï¼šä»¿å°„å‡½æ•°å¯ä»¥ä¸¢å¼ƒå…¶å‚æ•°
3. **æ‰€æœ‰æƒè§„åˆ™**ï¼šèµ„æºæ‰€æœ‰æƒå¿…é¡»æ˜ç¡®è½¬ç§»

#### ç±»å‹æ„é€ 

```rust
// Rustä¸­çš„ä»¿å°„ç±»å‹ç³»ç»Ÿ
struct Affine<T> {
    value: Option<T>,
}

impl<T> Affine<T> {
    fn new(value: T) -> Self {
        Affine { value: Some(value) }
    }
    
    fn take(self) -> Option<T> {
        self.value
    }
    
    fn drop(self) {
        // è‡ªåŠ¨ä¸¢å¼ƒï¼Œæ— éœ€æ˜¾å¼æ“ä½œ
    }
}
```

### é«˜çº§ä»¿å°„ç±»å‹

#### ç§»åŠ¨è¯­ä¹‰

```rust
// ç§»åŠ¨è¯­ä¹‰ç¤ºä¾‹
struct MovableData {
    data: Vec<i32>,
}

impl MovableData {
    fn new() -> Self {
        MovableData { data: Vec::new() }
    }
    
    fn consume(self) -> Vec<i32> {
        self.data  // ç§»åŠ¨æ‰€æœ‰æƒ
    }
    
    // æ— æ³•å®ç°Cloneï¼Œå› ä¸ºæ•°æ®è¢«ç§»åŠ¨
    // fn clone(&self) -> Self { ... }
}
```

#### å€Ÿç”¨è¯­ä¹‰

```rust
// å€Ÿç”¨è¯­ä¹‰ç¤ºä¾‹
struct BorrowableData {
    data: String,
}

impl BorrowableData {
    fn new(data: String) -> Self {
        BorrowableData { data }
    }
    
    fn borrow(&self) -> &str {
        &self.data  // ä¸å¯å˜å€Ÿç”¨
    }
    
    fn borrow_mut(&mut self) -> &mut str {
        &mut self.data  // å¯å˜å€Ÿç”¨
    }
}
```

## ğŸ”¬ é«˜çº§ç†è®ºå‘å±•

### ä»¿å°„é€»è¾‘æ‰©å±•

#### ä»¿å°„æ¨¡æ€

```haskell
-- ä»¿å°„æ¨¡æ€ï¼šå…è®¸ä¸¢å¼ƒ
data AffineModal a where
  AffineBang :: a -> AffineModal a
  Weakening :: AffineModal a -> AffineModal a
  Derelict :: AffineModal a -> a
```

#### ä»¿å°„é€»è¾‘è¿æ¥è¯

```haskell
-- ä»¿å°„é€»è¾‘è¿æ¥è¯
data AffineLogic a b where
  AffineTensor :: a -> b -> AffineLogic a b      -- âŠ—
  AffineWith :: a -> b -> AffineLogic a b        -- &
  AffinePlus :: a -> b -> AffineLogic a b        -- âŠ•
  AffineOne :: AffineLogic a a                    -- 1
```

### ä»¿å°„ç±»å‹ç³»ç»Ÿå˜ç§

#### ä»¿å°„Haskell

```haskell
-- ä»¿å°„Haskellæ‰©å±•
{-# LANGUAGE AffineTypes #-}

-- ä»¿å°„å‡½æ•°
f :: a %0-> b
f x = -- æœ€å¤šä½¿ç”¨xä¸€æ¬¡ï¼Œå¯ä»¥ä¸¢å¼ƒ

-- ä»¿å°„æ•°æ®ç±»å‹
data AffineList a where
  Nil :: AffineList a
  Cons :: a %0-> AffineList a %0-> AffineList a
```

#### Rustç§»åŠ¨è¯­ä¹‰

```rust
// Rustçš„ç§»åŠ¨è¯­ä¹‰ç³»ç»Ÿ
struct MoveSemantics<T> {
    data: T,
}

impl<T> MoveSemantics<T> {
    fn new(data: T) -> Self {
        MoveSemantics { data }
    }
    
    fn move_into(self) -> T {
        self.data  // ç§»åŠ¨æ‰€æœ‰æƒ
    }
    
    // æ— æ³•å®ç°Copy trait
    // impl<T> Copy for MoveSemantics<T> { }
}
```

## ğŸ¯ åº”ç”¨åœºæ™¯ä¸å®ä¾‹

### ç³»ç»Ÿç¼–ç¨‹

#### æ™ºèƒ½æŒ‡é’ˆç®¡ç†

```rust
// æ™ºèƒ½æŒ‡é’ˆçš„ä»¿å°„è¯­ä¹‰
struct SmartPointer<T> {
    data: Box<T>,
}

impl<T> SmartPointer<T> {
    fn new(data: T) -> Self {
        SmartPointer { data: Box::new(data) }
    }
    
    fn deref(&self) -> &T {
        &self.data
    }
    
    fn into_inner(self) -> T {
        *self.data  // ç§»åŠ¨æ‰€æœ‰æƒ
    }
    
    // ææ„å‡½æ•°è‡ªåŠ¨è°ƒç”¨
    // Drop trait è‡ªåŠ¨å®ç°
}
```

#### æ–‡ä»¶å¥æŸ„ç®¡ç†

```rust
// æ–‡ä»¶å¥æŸ„çš„ä»¿å°„ç®¡ç†
struct FileHandle {
    file: std::fs::File,
}

impl FileHandle {
    fn open(path: &str) -> std::io::Result<Self> {
        let file = std::fs::File::open(path)?;
        Ok(FileHandle { file })
    }
    
    fn read(&mut self, buf: &mut [u8]) -> std::io::Result<usize> {
        self.file.read(buf)
    }
    
    // æ–‡ä»¶åœ¨Dropæ—¶è‡ªåŠ¨å…³é—­
}

impl Drop for FileHandle {
    fn drop(&mut self) {
        // è‡ªåŠ¨å…³é—­æ–‡ä»¶
    }
}
```

### å¹¶å‘ç¼–ç¨‹

#### é€šé“ç®¡ç†

```rust
// ä»¿å°„é€šé“
use std::sync::mpsc;

struct AffineChannel<T> {
    sender: mpsc::Sender<T>,
    receiver: mpsc::Receiver<T>,
}

impl<T> AffineChannel<T> {
    fn new() -> Self {
        let (sender, receiver) = mpsc::channel();
        AffineChannel { sender, receiver }
    }
    
    fn send(self, value: T) -> Result<(), mpsc::SendError<T>> {
        self.sender.send(value)
    }
    
    fn recv(self) -> Result<T, mpsc::RecvError> {
        self.receiver.recv()
    }
}
```

#### é”ç®¡ç†

```rust
// ä»¿å°„é”
use std::sync::Mutex;

struct AffineLock<T> {
    mutex: Mutex<T>,
}

impl<T> AffineLock<T> {
    fn new(data: T) -> Self {
        AffineLock { mutex: Mutex::new(data) }
    }
    
    fn lock(self) -> Result<MutexGuard<T>, std::sync::PoisonError<MutexGuard<T>>> {
        self.mutex.lock()
    }
}
```

### å‡½æ•°å¼ç¼–ç¨‹

#### ä»¿å°„æ•°æ®ç»“æ„

```haskell
-- ä»¿å°„åˆ—è¡¨
data AffineList a where
  Nil :: AffineList a
  Cons :: a %0-> AffineList a %0-> AffineList a

-- ä»¿å°„æ˜ å°„
affineMap :: (a %0-> b) %0-> AffineList a %0-> AffineList b
affineMap _ Nil = Nil
affineMap f (Cons x xs) = Cons (f x) (affineMap f xs)
```

#### ä»¿å°„è§£æå™¨

```haskell
-- ä»¿å°„è§£æå™¨ç»„åˆå­
newtype AffineParser a = AffineParser (String %0-> (a, String))

instance AffineFunctor AffineParser where
    affineMap f (AffineParser p) = AffineParser (\s -> 
        let (a, s') = p s in (f a, s')
    )
```

## ğŸ”— ä¸å…¶ä»–ç†è®ºçš„äº¤å‰

### ä¸è‡ªåŠ¨æœºç†è®º

#### ä»¿å°„çŠ¶æ€æœº

```haskell
-- ä»¿å°„çŠ¶æ€æœº
data AffineStateMachine s a where
  AffineStateMachine :: s %0-> (s %0-> a %0-> s) %0-> AffineStateMachine s a

runAffineStateMachine :: AffineStateMachine s a %0-> [a] %0-> s
runAffineStateMachine (AffineStateMachine s f) [] = s
runAffineStateMachine (AffineStateMachine s f) (x:xs) = 
    runAffineStateMachine (AffineStateMachine (f s x) f) xs
```

### ä¸Petriç½‘ç†è®º

#### ä»¿å°„Petriç½‘

```haskell
-- ä»¿å°„Petriç½‘ï¼štokenå¯ä»¥è¢«ä¸¢å¼ƒ
data AffinePetriNet p t where
  AffinePetriNet :: Map p Int %0-> [(p, t, p)] %0-> AffinePetriNet p t

fireAffineTransition :: AffinePetriNet p t %0-> t %0-> Maybe (AffinePetriNet p t)
fireAffineTransition (AffinePetriNet places transitions) t = 
    -- ä»¿å°„æ“ä½œï¼štokenå¯ä»¥è¢«ä¸¢å¼ƒ
    -- ... å®ç°é€»è¾‘
```

### ä¸é‡å­è®¡ç®—

#### ä»¿å°„é‡å­ç±»å‹

```haskell
-- ä»¿å°„é‡å­ç±»å‹
data AffineQuantum a where
  AffineQubit :: QuantumState -> AffineQuantum Qubit
  AffineEntangled :: AffineQuantum a %0-> AffineQuantum b %0-> AffineQuantum (a, b)

-- ä»¿å°„é‡å­æ“ä½œ
affineMeasure :: AffineQuantum Qubit %0-> (Bool, ())
affineMeasure (AffineQubit state) = 
    -- æµ‹é‡æ“ä½œï¼šæ¶ˆè€—é‡å­çŠ¶æ€ï¼Œå¯ä»¥ä¸¢å¼ƒ
    (measureResult, ())
```

## ğŸš€ å‘å±•å‰æ²¿ä¸æŒ‘æˆ˜

### ç ”ç©¶æ–¹å‘

#### 1. ä»¿å°„ç±»å‹ç³»ç»Ÿä¼˜åŒ–

- **ç¼–è¯‘ä¼˜åŒ–**ï¼šä»¿å°„ç±»å‹çš„ç¼–è¯‘æ—¶ä¼˜åŒ–
- **è¿è¡Œæ—¶æ£€æŸ¥**ï¼šé«˜æ•ˆçš„ä»¿å°„æ€§æ£€æŸ¥
- **ç±»å‹æ¨å¯¼**ï¼šè‡ªåŠ¨ä»¿å°„ç±»å‹æ¨å¯¼

#### 2. ä»¿å°„é€»è¾‘æ‰©å±•

- **é«˜é˜¶ä»¿å°„é€»è¾‘**ï¼šé«˜é˜¶ä»¿å°„ç±»å‹ç³»ç»Ÿ
- **ä»¿å°„ä¾èµ–ç±»å‹**ï¼šç»“åˆä¾èµ–ç±»å‹çš„ä»¿å°„ç³»ç»Ÿ
- **ä»¿å°„åŒä¼¦ç±»å‹**ï¼šä»¿å°„åŒä¼¦ç±»å‹ç†è®º

#### 3. å®é™…åº”ç”¨æ‰©å±•

- **åˆ†å¸ƒå¼ä»¿å°„ç±»å‹**ï¼šåˆ†å¸ƒå¼ç³»ç»Ÿä¸­çš„ä»¿å°„ç±»å‹
- **å®æ—¶ä»¿å°„ç±»å‹**ï¼šå®æ—¶ç³»ç»Ÿçš„ä»¿å°„ç±»å‹
- **å®‰å…¨ä»¿å°„ç±»å‹**ï¼šå®‰å…¨åè®®ä¸­çš„ä»¿å°„ç±»å‹

### æŠ€æœ¯æŒ‘æˆ˜

#### 1. æ€§èƒ½æŒ‘æˆ˜

```haskell
-- ä»¿å°„æ€§æ£€æŸ¥çš„æ€§èƒ½ä¼˜åŒ–
class AffineCheck a where
    checkAffine :: a -> Bool
    optimizeAffine :: a -> a
```

#### 2. è¡¨è¾¾èƒ½åŠ›æŒ‘æˆ˜

```haskell
-- æ‰©å±•ä»¿å°„ç±»å‹è¡¨è¾¾èƒ½åŠ›
data ExtendedAffine a where
    Affine :: a -> ExtendedAffine a
    Linear :: a -> ExtendedAffine a
    Relevant :: a -> ExtendedAffine a
```

#### 3. å·¥å…·æ”¯æŒæŒ‘æˆ˜

- **IDEæ”¯æŒ**ï¼šä»¿å°„ç±»å‹çš„IDEé›†æˆ
- **è°ƒè¯•å·¥å…·**ï¼šä»¿å°„ç±»å‹è°ƒè¯•æ”¯æŒ
- **æ€§èƒ½åˆ†æ**ï¼šä»¿å°„ç±»å‹æ€§èƒ½åˆ†æ

## ğŸ› ï¸ å·¥å…·ä¸å®ç°

### ç¼–ç¨‹è¯­è¨€æ”¯æŒ

#### Rust

```rust
// Rustçš„ä»¿å°„ç±»å‹ç³»ç»Ÿ
#[derive(Debug)]
struct Affine<T> {
    value: Option<T>,
}

impl<T> Affine<T> {
    fn new(value: T) -> Self {
        Affine { value: Some(value) }
    }
    
    fn take(self) -> Option<T> {
        self.value
    }
    
    fn drop(self) {
        // è‡ªåŠ¨ä¸¢å¼ƒ
    }
}
```

#### Affine Haskell

```haskell
-- Affine Haskellå®ç°
{-# LANGUAGE AffineTypes #-}

-- ä»¿å°„å‡½æ•°
affineFunction :: a %0-> b
affineFunction x = -- å®ç°

-- ä»¿å°„æ•°æ®ç»“æ„
data AffineVector a where
    Empty :: AffineVector a
    Append :: a %0-> AffineVector a %0-> AffineVector a
```

#### Idris 2

```idris
-- Idris 2çš„ä»¿å°„ç±»å‹
data Affine : Type -> Type where
    MkAffine : a -> Affine a

-- ä»¿å°„å‡½æ•°
affineMap : (a -> b) -> Affine a -> Affine b
affineMap f (MkAffine x) = MkAffine (f x)
```

### å½¢å¼åŒ–å·¥å…·

#### Coq

```coq
(* Coqä¸­çš„ä»¿å°„é€»è¾‘ *)
Inductive affine_prop : Type :=
| affine_tensor : affine_prop -> affine_prop -> affine_prop
| affine_with : affine_prop -> affine_prop -> affine_prop
| affine_one : affine_prop.

(* ä»¿å°„é€»è¾‘è§„åˆ™ *)
Axiom affine_tensor_rule : forall A B, affine_prop -> affine_prop -> Prop.
```

#### Agda

```agda
-- Agdaä¸­çš„ä»¿å°„ç±»å‹
data Affine (A : Set) : Set where
  affine : A â†’ Affine A

-- ä»¿å°„å‡½æ•°
AffineFunction : Set â†’ Set â†’ Set
AffineFunction A B = Affine A â†’ Affine B
```

### éªŒè¯å·¥å…·

#### ä»¿å°„ç±»å‹æ£€æŸ¥å™¨

```haskell
-- ä»¿å°„ç±»å‹æ£€æŸ¥å™¨
class AffineTypeCheck a where
    typeCheck :: a -> Bool
    affinenessCheck :: a -> Bool

instance AffineTypeCheck (Affine a) where
    typeCheck _ = True
    affinenessCheck (Affine _) = True
```

## ğŸ“š å­¦ä¹ è·¯å¾„

### åŸºç¡€é˜¶æ®µ

1. **ä»¿å°„é€»è¾‘åŸºç¡€**
   - ä»¿å°„é€»è¾‘è¯­æ³•å’Œè¯­ä¹‰
   - ä»¿å°„é€»è¾‘è¯æ˜ç³»ç»Ÿ
   - ä»¿å°„é€»è¾‘ä¸çº¿æ€§é€»è¾‘çš„å…³ç³»

2. **ä»¿å°„ç±»å‹ç³»ç»Ÿ**
   - ä»¿å°„ç±»å‹è¯­æ³•
   - ä»¿å°„ç±»å‹è§„åˆ™
   - ä»¿å°„ç±»å‹æ¨å¯¼

3. **æ‰€æœ‰æƒç®¡ç†**
   - ç§»åŠ¨è¯­ä¹‰åŸç†
   - ç”Ÿå‘½å‘¨æœŸç®¡ç†
   - å€Ÿç”¨è¯­ä¹‰

### è¿›é˜¶é˜¶æ®µ

1. **é«˜çº§ä»¿å°„ç±»å‹**
   - ä»¿å°„æ¨¡æ€ç³»ç»Ÿ
   - ä»¿å°„é€»è¾‘è¿æ¥è¯
   - ä»¿å°„ç±»å‹å˜ç§

2. **ä»¿å°„ç±»å‹å˜ç§**
   - ä»¿å°„Haskell
   - Rustç§»åŠ¨è¯­ä¹‰
   - Idris 2ä»¿å°„ç±»å‹

3. **åº”ç”¨å®è·µ**
   - ç³»ç»Ÿç¼–ç¨‹åº”ç”¨
   - å¹¶å‘ç¼–ç¨‹åº”ç”¨
   - å‡½æ•°å¼ç¼–ç¨‹åº”ç”¨

### é«˜çº§é˜¶æ®µ

1. **ç†è®ºç ”ç©¶**
   - ä»¿å°„ç±»å‹ç†è®ºå‰æ²¿
   - ä»¿å°„é€»è¾‘æ‰©å±•
   - ä»¿å°„ç±»å‹ç³»ç»Ÿä¼˜åŒ–

2. **å·¥å…·å¼€å‘**
   - ä»¿å°„ç±»å‹æ£€æŸ¥å™¨
   - ä»¿å°„ç±»å‹ç¼–è¯‘å™¨
   - ä»¿å°„ç±»å‹è°ƒè¯•å·¥å…·

3. **è·¨é¢†åŸŸåº”ç”¨**
   - é‡å­è®¡ç®—åº”ç”¨
   - åˆ†å¸ƒå¼ç³»ç»Ÿåº”ç”¨
   - å®‰å…¨åè®®åº”ç”¨

## ğŸ”— ç›¸å…³é“¾æ¥

- [8.1.1-çº¿æ€§ç±»å‹ç†è®ºæ·±åŒ–](8.1.1-çº¿æ€§ç±»å‹ç†è®ºæ·±åŒ–.md)
- [8.1.3-æ—¶æ€ç±»å‹ç†è®ºæ·±åŒ–](8.1.3-æ—¶æ€ç±»å‹ç†è®ºæ·±åŒ–.md)
- [8.1.4-é‡å­ç±»å‹ç†è®ºæ·±åŒ–](8.1.4-é‡å­ç±»å‹ç†è®ºæ·±åŒ–.md)
- [8.1.5-ä¾èµ–ç±»å‹ç†è®ºæ·±åŒ–](8.1.5-ä¾èµ–ç±»å‹ç†è®ºæ·±åŒ–.md)
- [8.1.6-åŒä¼¦ç±»å‹ç†è®ºæ·±åŒ–](8.1.6-åŒä¼¦ç±»å‹ç†è®ºæ·±åŒ–.md)
- [8.2-è‡ªåŠ¨æœºç†è®ºæ·±åŒ–](../8.2-è‡ªåŠ¨æœºç†è®ºæ·±åŒ–/README.md)
- [8.7-é‡å­ç³»ç»Ÿç†è®º](../8.7-é‡å­ç³»ç»Ÿç†è®º/README.md)

---

**ğŸ“– è¿”å›å¯¼èˆª**:

- [è¿”å›ç±»å‹ç†è®ºæ·±åŒ–å¯¼èˆª](README.md)
- [è¿”å›å½¢å¼ç†è®ºæ·±åŒ–æ€»å¯¼èˆª](../README.md)
