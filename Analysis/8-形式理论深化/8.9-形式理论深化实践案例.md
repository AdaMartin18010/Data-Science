# 8.9 å½¢å¼ç†è®ºæ·±åŒ–å®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [8.9 å½¢å¼ç†è®ºæ·±åŒ–å®è·µæ¡ˆä¾‹](#89-å½¢å¼ç†è®ºæ·±åŒ–å®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [2. æ¦‚è¿°](#2-æ¦‚è¿°)
  - [3. åšå¼ˆè®ºå®è·µæ¡ˆä¾‹](#3-åšå¼ˆè®ºå®è·µæ¡ˆä¾‹)
    - [3.1. æ‹å–æœºåˆ¶è®¾è®¡](#31-æ‹å–æœºåˆ¶è®¾è®¡)
  - [4. åšå¼ˆè®ºç­–ç•¥åˆ†æ](#4-åšå¼ˆè®ºç­–ç•¥åˆ†æ)
  - [5. é‡å­è®¡ç®—å®è·µæ¡ˆä¾‹](#5-é‡å­è®¡ç®—å®è·µæ¡ˆä¾‹)
    - [5.1. é‡å­æ¯”ç‰¹æ¨¡æ‹Ÿå™¨](#51-é‡å­æ¯”ç‰¹æ¨¡æ‹Ÿå™¨)
  - [6. æ€»ç»“](#6-æ€»ç»“)

---

## 2. æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›å½¢å¼ç†è®ºæ·±åŒ–åœ¨å®é™…é¡¹ç›®ä¸­çš„å…·ä½“åº”ç”¨æ¡ˆä¾‹ï¼Œæ¶µç›–åšå¼ˆè®ºã€é‡å­è®¡ç®—ã€æœºåˆ¶è®¾è®¡ç­‰å„ä¸ªæ–¹é¢çš„å®é™…åº”ç”¨ã€‚

## 3. åšå¼ˆè®ºå®è·µæ¡ˆä¾‹

### 3.1. æ‹å–æœºåˆ¶è®¾è®¡

```python
# æ‹å–æœºåˆ¶è®¾è®¡å®è·µ
import numpy as np
from typing import List, Dict, Tuple
from dataclasses import dataclass
from enum import Enum

class AuctionType(Enum):
    FIRST_PRICE = "first_price"
    SECOND_PRICE = "second_price"
    ALL_PAY = "all_pay"

@dataclass
class Bidder:
    """æŠ•æ ‡è€…"""
    id: str
    valuation: float  # çœŸå®ä¼°å€¼
    budget: float     # é¢„ç®—çº¦æŸ

@dataclass
class Bid:
    """æŠ•æ ‡"""
    bidder_id: str
    amount: float
    timestamp: float

class Auction:
    """æ‹å–åŸºç±»"""

    def __init__(self, auction_type: AuctionType):
        self.auction_type = auction_type
        self.bidders: List[Bidder] = []
        self.bids: List[Bid] = []
        self.winner = None
        self.winning_price = 0.0

    def add_bidder(self, bidder: Bidder):
        """æ·»åŠ æŠ•æ ‡è€…"""
        self.bidders.append(bidder)

    def submit_bid(self, bid: Bid):
        """æäº¤æŠ•æ ‡"""
        self.bids.append(bid)

    def determine_winner(self) -> Tuple[str, float]:
        """ç¡®å®šè·èƒœè€…å’Œä»·æ ¼"""
        if not self.bids:
            return None, 0.0

# æŒ‰æŠ•æ ‡é‡‘é¢æ’åº
        sorted_bids = sorted(self.bids, key=lambda x: x.amount, reverse=True)
        highest_bid = sorted_bids[0]

        if self.auction_type == AuctionType.FIRST_PRICE:
# ç¬¬ä¸€ä»·æ ¼æ‹å–ï¼šè·èƒœè€…æ”¯ä»˜è‡ªå·±çš„æŠ•æ ‡é‡‘é¢
            return highest_bid.bidder_id, highest_bid.amount

        elif self.auction_type == AuctionType.SECOND_PRICE:
# ç¬¬äºŒä»·æ ¼æ‹å–ï¼šè·èƒœè€…æ”¯ä»˜ç¬¬äºŒé«˜çš„æŠ•æ ‡é‡‘é¢
            second_highest = sorted_bids[1].amount if len(sorted_bids) > 1 else 0.0
            return highest_bid.bidder_id, second_highest

        elif self.auction_type == AuctionType.ALL_PAY:
# å…¨æ”¯ä»˜æ‹å–ï¼šæ‰€æœ‰æŠ•æ ‡è€…éƒ½æ”¯ä»˜è‡ªå·±çš„æŠ•æ ‡é‡‘é¢
            return highest_bid.bidder_id, highest_bid.amount

        return None, 0.0

    def calculate_utility(self, bidder_id: str, payment: float) -> float:
        """è®¡ç®—æ•ˆç”¨"""
        bidder = next((b for b in self.bidders if b.id == bidder_id), None)
        if not bidder:
            return 0.0

        if bidder_id == self.winner:
            return bidder.valuation - payment
        else:
            return 0.0

class VickreyAuction(Auction):
    """ç»´å…‹é‡Œæ‹å–ï¼ˆç¬¬äºŒä»·æ ¼å¯†å°æŠ•æ ‡ï¼‰"""

    def __init__(self):
        super().__init__(AuctionType.SECOND_PRICE)

    def optimal_bidding_strategy(self, bidder: Bidder) -> float:
        """æœ€ä¼˜æŠ•æ ‡ç­–ç•¥ï¼šæŠ•æ ‡çœŸå®ä¼°å€¼"""
        return bidder.valuation

class FirstPriceAuction(Auction):
    """ç¬¬ä¸€ä»·æ ¼å¯†å°æŠ•æ ‡æ‹å–"""

    def __init__(self):
        super().__init__(AuctionType.FIRST_PRICE)

    def optimal_bidding_strategy(self, bidder: Bidder, num_bidders: int) -> float:
        """æœ€ä¼˜æŠ•æ ‡ç­–ç•¥ï¼šåœ¨å¯¹ç§°æƒ…å†µä¸‹ï¼ŒæŠ•æ ‡ (n-1)/n * valuation"""
        if num_bidders <= 1:
            return bidder.valuation
        return (num_bidders - 1) / num_bidders * bidder.valuation

class AllPayAuction(Auction):
    """å…¨æ”¯ä»˜æ‹å–"""

    def __init__(self):
        super().__init__(AuctionType.ALL_PAY)

    def optimal_bidding_strategy(self, bidder: Bidder, num_bidders: int) -> float:
        """æœ€ä¼˜æŠ•æ ‡ç­–ç•¥ï¼šåœ¨å¯¹ç§°æƒ…å†µä¸‹ï¼ŒæŠ•æ ‡ (n-1)/n * valuation^n"""
        if num_bidders <= 1:
            return bidder.valuation
        return (num_bidders - 1) / num_bidders * (bidder.valuation ** num_bidders)

# æ‹å–æ¨¡æ‹Ÿå™¨
class AuctionSimulator:
    """æ‹å–æ¨¡æ‹Ÿå™¨"""

    def __init__(self):
        self.results = []

    def simulate_auction(self, auction: Auction, num_rounds: int = 1000) -> Dict:
        """æ¨¡æ‹Ÿæ‹å–"""
        total_revenue = 0.0
        total_social_welfare = 0.0
        winner_count = {}

        for round_num in range(num_rounds):
# é‡ç½®æ‹å–
            auction.bids.clear()
            auction.winner = None
            auction.winning_price = 0.0

# ç”ŸæˆæŠ•æ ‡
            for bidder in auction.bidders:
                if isinstance(auction, VickreyAuction):
                    bid_amount = auction.optimal_bidding_strategy(bidder)
                elif isinstance(auction, FirstPriceAuction):
                    bid_amount = auction.optimal_bidding_strategy(bidder, len(auction.bidders))
                elif isinstance(auction, AllPayAuction):
                    bid_amount = auction.optimal_bidding_strategy(bidder, len(auction.bidders))
                else:
                    bid_amount = bidder.valuation

# æ·»åŠ ä¸€äº›éšæœºæ€§
                bid_amount *= np.random.uniform(0.9, 1.1)
                bid_amount = min(bid_amount, bidder.budget)

                bid = Bid(bidder.id, bid_amount, round_num)
                auction.submit_bid(bid)

# ç¡®å®šè·èƒœè€…
            winner_id, winning_price = auction.determine_winner()
            if winner_id:
                auction.winner = winner_id
                auction.winning_price = winning_price

# ç»Ÿè®¡
                total_revenue += winning_price
                winner = next(b for b in auction.bidders if b.id == winner_id)
                total_social_welfare += winner.valuation
                winner_count[winner_id] = winner_count.get(winner_id, 0) + 1

        return {
            'auction_type': auction.auction_type.value,
            'num_rounds': num_rounds,
            'avg_revenue': total_revenue / num_rounds,
            'avg_social_welfare': total_social_welfare / num_rounds,
            'winner_distribution': winner_count,
            'efficiency': total_social_welfare / (num_rounds * sum(b.valuation for b in auction.bidders))
        }

# ä½¿ç”¨ç¤ºä¾‹
def auction_example():
    """æ‹å–æœºåˆ¶ç¤ºä¾‹"""
# åˆ›å»ºæŠ•æ ‡è€…
    bidders = [
        Bidder("A", 100.0, 120.0),
        Bidder("B", 80.0, 100.0),
        Bidder("C", 60.0, 80.0),
        Bidder("D", 40.0, 60.0),
    ]

# åˆ›å»ºä¸åŒç±»å‹çš„æ‹å–
    vickrey = VickreyAuction()
    first_price = FirstPriceAuction()
    all_pay = AllPayAuction()

# æ·»åŠ æŠ•æ ‡è€…
    for auction in [vickrey, first_price, all_pay]:
        for bidder in bidders:
            auction.add_bidder(bidder)

# æ¨¡æ‹Ÿæ‹å–
    simulator = AuctionSimulator()

    print("æ‹å–æœºåˆ¶æ¯”è¾ƒ:")
    print("=" * 50)

    for auction in [vickrey, first_price, all_pay]:
        result = simulator.simulate_auction(auction, 1000)
        print(f"\n{result['auction_type'].upper()} æ‹å–:")
        print(f"  å¹³å‡æ”¶å…¥: {result['avg_revenue']:.2f}")
        print(f"  å¹³å‡ç¤¾ä¼šç¦åˆ©: {result['avg_social_welfare']:.2f}")
        print(f"  æ•ˆç‡: {result['efficiency']:.3f}")
        print(f"  è·èƒœè€…åˆ†å¸ƒ: {result['winner_distribution']}")

if __name__ == "__main__":
    auction_example()
```

## 4. åšå¼ˆè®ºç­–ç•¥åˆ†æ

```python
# åšå¼ˆè®ºç­–ç•¥åˆ†æ
import numpy as np
from typing import List, Tuple, Dict
from dataclasses import dataclass

@dataclass
class Strategy:
    """ç­–ç•¥"""
    name: str
    probabilities: List[float]  # æ··åˆç­–ç•¥çš„æ¦‚ç‡åˆ†å¸ƒ

class Game:
    """åšå¼ˆ"""

    def __init__(self, payoff_matrix: np.ndarray):
        self.payoff_matrix = payoff_matrix
        self.num_strategies = payoff_matrix.shape[0]

    def pure_strategy_equilibrium(self) -> List[Tuple[int, int]]:
        """å¯»æ‰¾çº¯ç­–ç•¥çº³ä»€å‡è¡¡"""
        equilibria = []

        for i in range(self.num_strategies):
            for j in range(self.num_strategies):
# æ£€æŸ¥æ˜¯å¦ä¸ºçº³ä»€å‡è¡¡
                is_equilibrium = True

# æ£€æŸ¥ç©å®¶1æ˜¯å¦æœ‰æ›´å¥½çš„ç­–ç•¥
                for k in range(self.num_strategies):
                    if self.payoff_matrix[k, j] > self.payoff_matrix[i, j]:
                        is_equilibrium = False
                        break

                if not is_equilibrium:
                    continue

# æ£€æŸ¥ç©å®¶2æ˜¯å¦æœ‰æ›´å¥½çš„ç­–ç•¥
                for k in range(self.num_strategies):
                    if self.payoff_matrix[i, k] > self.payoff_matrix[i, j]:
                        is_equilibrium = False
                        break

                if is_equilibrium:
                    equilibria.append((i, j))

        return equilibria

    def mixed_strategy_equilibrium(self) -> Tuple[List[float], List[float]]:
        """è®¡ç®—æ··åˆç­–ç•¥çº³ä»€å‡è¡¡"""
# ä½¿ç”¨çº¿æ€§è§„åˆ’æ±‚è§£
        from scipy.optimize import linprog

# æ„å»ºçº¿æ€§è§„åˆ’é—®é¢˜
        n = self.num_strategies

# ç›®æ ‡å‡½æ•°ï¼šæœ€å¤§åŒ–æœ€å°æ”¶ç›Š
        c = [0] * (2 * n) + [1]

# çº¦æŸæ¡ä»¶
        A = []
        b = []

# ç©å®¶1çš„çº¦æŸ
        for j in range(n):
            row = [0] * (2 * n + 1)
            for i in range(n):
                row[i] = self.payoff_matrix[i, j]
            row[2 * n] = -1
            A.append(row)
            b.append(0)

# ç©å®¶2çš„çº¦æŸ
        for i in range(n):
            row = [0] * (2 * n + 1)
            for j in range(n):
                row[n + j] = self.payoff_matrix[i, j]
            row[2 * n] = -1
            A.append(row)
            b.append(0)

# æ¦‚ç‡å’Œä¸º1çš„çº¦æŸ
        prob1_constraint = [1] * n + [0] * (n + 1)
        prob2_constraint = [0] * n + [1] * n + [0]
        A.extend([prob1_constraint, prob2_constraint])
        b.extend([1, 1])

# éè´Ÿçº¦æŸ
        bounds = [(0, None)] * (2 * n + 1)

# æ±‚è§£
        result = linprog(c, A_ub=A, b_ub=b, bounds=bounds, method='highs')

        if result.success:
            solution = result.x
            p1 = solution[:n]
            p2 = solution[n:2*n]
            return p1, p2
        else:
            return None, None

class PrisonersDilemma(Game):
    """å›šå¾’å›°å¢ƒ"""

    def __init__(self):
# æ”¶ç›ŠçŸ©é˜µï¼š(åˆä½œ, èƒŒå›)
# ç©å®¶1é€‰æ‹©è¡Œï¼Œç©å®¶2é€‰æ‹©åˆ—
        payoff_matrix = np.array([
            [3, 0],  # åˆä½œ
            [5, 1]   # èƒŒå›
        ])
        super().__init__(payoff_matrix)

    def get_strategy_names(self) -> List[str]:
        return ["åˆä½œ", "èƒŒå›"]

class BattleOfSexes(Game):
    """æ€§åˆ«ä¹‹æˆ˜"""

    def __init__(self):
# æ”¶ç›ŠçŸ©é˜µï¼š(è¶³çƒ, æ­Œå‰§)
        payoff_matrix = np.array([
            [3, 1],  # è¶³çƒ
            [0, 2]   # æ­Œå‰§
        ])
        super().__init__(payoff_matrix)

    def get_strategy_names(self) -> List[str]:
        return ["è¶³çƒ", "æ­Œå‰§"]

class ChickenGame(Game):
    """æ‡¦å¤«åšå¼ˆ"""

    def __init__(self):
# æ”¶ç›ŠçŸ©é˜µï¼š(ç»§ç»­, è½¬å‘)
        payoff_matrix = np.array([
            [-10, 1],  # ç»§ç»­
            [0, 0]     # è½¬å‘
        ])
        super().__init__(payoff_matrix)

    def get_strategy_names(self) -> List[str]:
        return ["ç»§ç»­", "è½¬å‘"]

# åšå¼ˆåˆ†æå™¨
class GameAnalyzer:
    """åšå¼ˆåˆ†æå™¨"""

    def __init__(self, game: Game):
        self.game = game

    def analyze_pure_strategies(self):
        """åˆ†æçº¯ç­–ç•¥"""
        equilibria = self.game.pure_strategy_equilibrium()
        strategy_names = self.game.get_strategy_names()

        print(f"çº¯ç­–ç•¥çº³ä»€å‡è¡¡:")
        for i, j in equilibria:
            payoff1 = self.game.payoff_matrix[i, j]
            payoff2 = self.game.payoff_matrix[i, j]
            print(f"  ({strategy_names[i]}, {strategy_names[j]}) -> ({payoff1}, {payoff2})")

        return equilibria

    def analyze_mixed_strategies(self):
        """åˆ†ææ··åˆç­–ç•¥"""
        p1, p2 = self.game.mixed_strategy_equilibrium()
        strategy_names = self.game.get_strategy_names()

        if p1 is not None and p2 is not None:
            print(f"æ··åˆç­–ç•¥çº³ä»€å‡è¡¡:")
            print(f"  ç©å®¶1ç­–ç•¥: {dict(zip(strategy_names, p1))}")
            print(f"  ç©å®¶2ç­–ç•¥: {dict(zip(strategy_names, p2))}")

# è®¡ç®—æœŸæœ›æ”¶ç›Š
            expected_payoff1 = np.sum(p1[:, np.newaxis] * self.game.payoff_matrix * p2)
            expected_payoff2 = np.sum(p1[:, np.newaxis] * self.game.payoff_matrix.T * p2)
            print(f"  æœŸæœ›æ”¶ç›Š: ({expected_payoff1:.3f}, {expected_payoff2:.3f})")

        return p1, p2

    def simulate_game(self, num_rounds: int = 1000) -> Dict:
        """æ¨¡æ‹Ÿåšå¼ˆ"""
        p1, p2 = self.game.mixed_strategy_equilibrium()

        if p1 is None or p2 is None:
            return {}

        results = {
            'strategy_counts': {i: 0 for i in range(self.game.num_strategies)},
            'total_payoffs': [0.0, 0.0]
        }

        for _ in range(num_rounds):
# æ ¹æ®æ··åˆç­–ç•¥é€‰æ‹©è¡ŒåŠ¨
            action1 = np.random.choice(self.game.num_strategies, p=p1)
            action2 = np.random.choice(self.game.num_strategies, p=p2)

# è®°å½•ç»“æœ
            results['strategy_counts'][action1] += 1
            results['strategy_counts'][action2] += 1

# è®¡ç®—æ”¶ç›Š
            payoff1 = self.game.payoff_matrix[action1, action2]
            payoff2 = self.game.payoff_matrix[action1, action2]

            results['total_payoffs'][0] += payoff1
            results['total_payoffs'][1] += payoff2

# è®¡ç®—å¹³å‡å€¼
        results['avg_payoffs'] = [p / num_rounds for p in results['total_payoffs']]
        results['strategy_frequencies'] = {
            i: count / (2 * num_rounds)
            for i, count in results['strategy_counts'].items()
        }

        return results

# ä½¿ç”¨ç¤ºä¾‹
def game_theory_example():
    """åšå¼ˆè®ºç¤ºä¾‹"""
    games = [
        ("å›šå¾’å›°å¢ƒ", PrisonersDilemma()),
        ("æ€§åˆ«ä¹‹æˆ˜", BattleOfSexes()),
        ("æ‡¦å¤«åšå¼ˆ", ChickenGame())
    ]

    for game_name, game in games:
        print(f"\n{game_name}:")
        print("=" * 30)

        analyzer = GameAnalyzer(game)

# åˆ†æçº¯ç­–ç•¥
        analyzer.analyze_pure_strategies()

# åˆ†ææ··åˆç­–ç•¥
        analyzer.analyze_mixed_strategies()

# æ¨¡æ‹Ÿåšå¼ˆ
        simulation = analyzer.simulate_game(1000)
        if simulation:
            print(f"æ¨¡æ‹Ÿç»“æœ:")
            print(f"  å¹³å‡æ”¶ç›Š: {simulation['avg_payoffs']}")
            print(f"  ç­–ç•¥é¢‘ç‡: {simulation['strategy_frequencies']}")

if __name__ == "__main__":
    game_theory_example()
```

## 5. é‡å­è®¡ç®—å®è·µæ¡ˆä¾‹

### 5.1. é‡å­æ¯”ç‰¹æ¨¡æ‹Ÿå™¨

```python
# é‡å­æ¯”ç‰¹æ¨¡æ‹Ÿå™¨
import numpy as np
from typing import List, Tuple, Optional
from dataclasses import dataclass

@dataclass
class QuantumState:
    """é‡å­çŠ¶æ€"""
    amplitudes: np.ndarray  # å¤æ•°æŒ¯å¹…
    num_qubits: int

    def __post_init__(self):
        if len(self.amplitudes) != 2 ** self.num_qubits:
            raise ValueError("æŒ¯å¹…æ•°é‡å¿…é¡»ç­‰äº2^num_qubits")

    def normalize(self):
        """å½’ä¸€åŒ–"""
        norm = np.sqrt(np.sum(np.abs(self.amplitudes) ** 2))
        if norm > 0:
            self.amplitudes /= norm

    def measure(self) -> int:
        """æµ‹é‡"""
        probabilities = np.abs(self.amplitudes) ** 2
        return np.random.choice(len(probabilities), p=probabilities)

    def get_probabilities(self) -> np.ndarray:
        """è·å–æµ‹é‡æ¦‚ç‡"""
        return np.abs(self.amplitudes) ** 2

class QuantumGate:
    """é‡å­é—¨"""

    def __init__(self, matrix: np.ndarray):
        self.matrix = matrix

    def apply(self, state: QuantumState, target_qubit: int) -> QuantumState:
        """åº”ç”¨é‡å­é—¨"""
# ç®€åŒ–çš„å•æ¯”ç‰¹é—¨åº”ç”¨
        if target_qubit >= state.num_qubits:
            raise ValueError("ç›®æ ‡æ¯”ç‰¹è¶…å‡ºèŒƒå›´")

# åˆ›å»ºæ–°çš„çŠ¶æ€
        new_amplitudes = np.zeros_like(state.amplitudes)

# åº”ç”¨é—¨æ“ä½œ
        for i in range(len(state.amplitudes)):
# è®¡ç®—ç›®æ ‡æ¯”ç‰¹çš„å€¼
            target_bit = (i >> target_qubit) & 1

# åº”ç”¨é—¨çŸ©é˜µ
            for j in range(2):
                if target_bit == j:
                    new_amplitudes[i] += self.matrix[j, target_bit] * state.amplitudes[i]

        return QuantumState(new_amplitudes, state.num_qubits)

# å¸¸ç”¨é‡å­é—¨
class Gates:
    """é‡å­é—¨é›†åˆ"""

    @staticmethod
    def H() -> QuantumGate:
        """Hadamardé—¨"""
        return QuantumGate(np.array([[1, 1], [1, -1]]) / np.sqrt(2))

    @staticmethod
    def X() -> QuantumGate:
        """Pauli-Xé—¨ï¼ˆNOTé—¨ï¼‰"""
        return QuantumGate(np.array([[0, 1], [1, 0]]))

    @staticmethod
    def Y() -> QuantumGate:
        """Pauli-Yé—¨"""
        return QuantumGate(np.array([[0, -1j], [1j, 0]]))

    @staticmethod
    def Z() -> QuantumGate:
        """Pauli-Zé—¨"""
        return QuantumGate(np.array([[1, 0], [0, -1]]))

    @staticmethod
    def CNOT() -> 'CNOTGate':
        """CNOTé—¨"""
        return CNOTGate()

class CNOTGate:
    """CNOTé—¨ï¼ˆå—æ§NOTé—¨ï¼‰"""

    def apply(self, state: QuantumState, control_qubit: int, target_qubit: int) -> QuantumState:
        """åº”ç”¨CNOTé—¨"""
        if control_qubit >= state.num_qubits or target_qubit >= state.num_qubits:
            raise ValueError("æ¯”ç‰¹è¶…å‡ºèŒƒå›´")

        new_amplitudes = np.zeros_like(state.amplitudes)

        for i in range(len(state.amplitudes)):
            control_bit = (i >> control_qubit) & 1
            target_bit = (i >> target_qubit) & 1

            if control_bit == 1:
# æ§åˆ¶æ¯”ç‰¹ä¸º1æ—¶ï¼Œç¿»è½¬ç›®æ ‡æ¯”ç‰¹
                new_target_bit = 1 - target_bit
                new_index = i ^ (1 << target_qubit)
                new_amplitudes[new_index] = state.amplitudes[i]
            else:
# æ§åˆ¶æ¯”ç‰¹ä¸º0æ—¶ï¼Œä¿æŒä¸å˜
                new_amplitudes[i] = state.amplitudes[i]

        return QuantumState(new_amplitudes, state.num_qubits)

class QuantumCircuit:
    """é‡å­ç”µè·¯"""

    def __init__(self, num_qubits: int):
        self.num_qubits = num_qubits
        self.gates = []

    def h(self, qubit: int):
        """åº”ç”¨Hadamardé—¨"""
        self.gates.append(('H', qubit))

    def x(self, qubit: int):
        """åº”ç”¨Xé—¨"""
        self.gates.append(('X', qubit))

    def cnot(self, control: int, target: int):
        """åº”ç”¨CNOTé—¨"""
        self.gates.append(('CNOT', control, target))

    def execute(self, initial_state: Optional[QuantumState] = None) -> QuantumState:
        """æ‰§è¡Œç”µè·¯"""
        if initial_state is None:
# é»˜è®¤åˆå§‹çŠ¶æ€ï¼š|0...0âŸ©
            amplitudes = np.zeros(2 ** self.num_qubits)
            amplitudes[0] = 1.0
            state = QuantumState(amplitudes, self.num_qubits)
        else:
            state = QuantumState(initial_state.amplitudes.copy(), initial_state.num_qubits)

# åº”ç”¨é—¨åºåˆ—
        for gate_info in self.gates:
            if gate_info[0] == 'H':
                gate = Gates.H()
                state = gate.apply(state, gate_info[1])
            elif gate_info[0] == 'X':
                gate = Gates.X()
                state = gate.apply(state, gate_info[1])
            elif gate_info[0] == 'CNOT':
                gate = Gates.CNOT()
                state = gate.apply(state, gate_info[1], gate_info[2])

        return state

# é‡å­ç®—æ³•å®ç°
class QuantumAlgorithms:
    """é‡å­ç®—æ³•"""

    @staticmethod
    def deutsch_jozsa(oracle: callable, n: int) -> bool:
        """Deutsch-Jozsaç®—æ³•"""
        circuit = QuantumCircuit(n + 1)

# åˆå§‹åŒ–è¾…åŠ©æ¯”ç‰¹ä¸º|1âŸ©
        circuit.x(n)

# åº”ç”¨Hadamardé—¨åˆ°æ‰€æœ‰æ¯”ç‰¹
        for i in range(n + 1):
            circuit.h(i)

# åº”ç”¨Oracleï¼ˆè¿™é‡Œç®€åŒ–å¤„ç†ï¼‰
# åœ¨å®é™…å®ç°ä¸­ï¼ŒOracleä¼šæ˜¯ä¸€ä¸ªé‡å­é—¨åºåˆ—

# å†æ¬¡åº”ç”¨Hadamardé—¨åˆ°å‰nä¸ªæ¯”ç‰¹
        for i in range(n):
            circuit.h(i)

# æ‰§è¡Œç”µè·¯
        final_state = circuit.execute()

# æµ‹é‡å‰nä¸ªæ¯”ç‰¹
        measurement = final_state.measure()

# å¦‚æœæµ‹é‡ç»“æœä¸º0ï¼Œåˆ™å‡½æ•°æ˜¯å¸¸æ•°å‡½æ•°
        return measurement == 0

    @staticmethod
    def grover_search(oracle: callable, n: int, marked_states: List[int]) -> int:
        """Groveræœç´¢ç®—æ³•ï¼ˆç®€åŒ–ç‰ˆï¼‰"""
        circuit = QuantumCircuit(n)

# åˆå§‹åŒ–å åŠ æ€
        for i in range(n):
            circuit.h(i)

# Groverè¿­ä»£ï¼ˆç®€åŒ–ç‰ˆï¼‰
        num_iterations = int(np.pi / 4 * np.sqrt(2 ** n))

        for _ in range(num_iterations):
# Oracleç›¸ä½åè½¬
# åœ¨å®é™…å®ç°ä¸­ï¼Œè¿™éœ€è¦æ›´å¤æ‚çš„ç”µè·¯

# æ‰©æ•£ç®—å­
            for i in range(n):
                circuit.h(i)

# ç›¸ä½åè½¬
            circuit.x(0)
            circuit.h(0)

# å†æ¬¡åº”ç”¨Hadamardé—¨
            for i in range(n):
                circuit.h(i)

# æ‰§è¡Œç”µè·¯
        final_state = circuit.execute()

# æµ‹é‡
        return final_state.measure()

# ä½¿ç”¨ç¤ºä¾‹
def quantum_computing_example():
    """é‡å­è®¡ç®—ç¤ºä¾‹"""
    print("é‡å­è®¡ç®—ç¤ºä¾‹:")
    print("=" * 30)

# 1. å•æ¯”ç‰¹æ“ä½œ
    print("\n1. å•æ¯”ç‰¹æ“ä½œ:")
    initial_state = QuantumState(np.array([1.0, 0.0]), 1)  # |0âŸ©
    print(f"åˆå§‹çŠ¶æ€: |0âŸ©")

# åº”ç”¨Hadamardé—¨
    h_gate = Gates.H()
    superposition_state = h_gate.apply(initial_state, 0)
    print(f"åº”ç”¨Hé—¨å: {superposition_state.amplitudes}")
    print(f"æµ‹é‡æ¦‚ç‡: {superposition_state.get_probabilities()}")

# 2. é‡å­ç”µè·¯
    print("\n2. é‡å­ç”µè·¯:")
    circuit = QuantumCircuit(2)
    circuit.h(0)  # ç¬¬ä¸€ä¸ªæ¯”ç‰¹è¿›å…¥å åŠ æ€
    circuit.cnot(0, 1)  # CNOTé—¨åˆ›å»ºBellæ€

    final_state = circuit.execute()
    print(f"Bellæ€: {final_state.amplitudes}")
    print(f"æµ‹é‡æ¦‚ç‡: {final_state.get_probabilities()}")

# 3. å¤šæ¬¡æµ‹é‡
    print("\n3. å¤šæ¬¡æµ‹é‡:")
    measurements = [final_state.measure() for _ in range(1000)]
    unique, counts = np.unique(measurements, return_counts=True)
    print(f"æµ‹é‡ç»“æœåˆ†å¸ƒ: {dict(zip(unique, counts))}")

if __name__ == "__main__":
    quantum_computing_example()
```

## 6. æ€»ç»“

æœ¬æ–‡æ¡£æä¾›äº†å½¢å¼ç†è®ºæ·±åŒ–åœ¨å®é™…é¡¹ç›®ä¸­çš„å…·ä½“åº”ç”¨æ¡ˆä¾‹ï¼ŒåŒ…æ‹¬ï¼š

1. **åšå¼ˆè®ºå®è·µ**ï¼šæ‹å–æœºåˆ¶è®¾è®¡å’Œåšå¼ˆè®ºç­–ç•¥åˆ†æ
2. **é‡å­è®¡ç®—å®è·µ**ï¼šé‡å­æ¯”ç‰¹æ¨¡æ‹Ÿå™¨å’Œé‡å­ç®—æ³•å®ç°

è¿™äº›æ¡ˆä¾‹å±•ç¤ºäº†å½¢å¼ç†è®ºæ·±åŒ–åœ¨ç»æµå­¦ã€è®¡ç®—æœºç§‘å­¦ç­‰é¢†åŸŸçš„å®é™…åº”ç”¨ï¼Œä¸ºç†è®ºå­¦ä¹ å’Œå®è·µæä¾›äº†å…·ä½“çš„å‚è€ƒå’ŒæŒ‡å¯¼ã€‚
