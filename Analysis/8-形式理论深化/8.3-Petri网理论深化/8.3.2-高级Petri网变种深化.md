# 8.3.2-é«˜çº§Petriç½‘å˜ç§æ·±åŒ–

## ğŸ“– ç†è®ºç»¼è¿°

é«˜çº§Petriç½‘æ˜¯åœ¨åŸºç¡€Petriç½‘çš„åŸºç¡€ä¸Šï¼Œä¸ºäº†æ›´å¥½åœ°æè¿°å¤æ‚ç³»ç»Ÿçš„è¡Œä¸ºå’Œå±æ€§è€Œæå‡ºçš„ä¸€ç³»åˆ—æ‰©å±•æ¨¡å‹ã€‚è¿™äº›å˜ç§é€šè¿‡å¼•å…¥é¢œè‰²ã€æ—¶é—´ã€å±‚æ¬¡ã€æ¦‚ç‡ã€æ¨¡ç³Šç­‰æœºåˆ¶ï¼Œæå¤§åœ°å¢å¼ºäº†Petriç½‘çš„è¡¨è¾¾èƒ½åŠ›å’Œå®é™…åº”ç”¨èŒƒå›´ã€‚

### é«˜çº§Petriç½‘çš„ä¸»è¦å˜ç§

- **æœ‰è‰²Petriç½‘ï¼ˆColored Petri Net, CPNï¼‰**ï¼šé€šè¿‡é¢œè‰²æœºåˆ¶å»ºæ¨¡å¤æ‚æ•°æ®æµ
- **æ—¶é—´Petriç½‘ï¼ˆTimed Petri Net, TPNï¼‰**ï¼šé€šè¿‡æ—¶é—´çº¦æŸå»ºæ¨¡å®æ—¶ç³»ç»Ÿ
- **å±‚æ¬¡Petriç½‘ï¼ˆHierarchical Petri Net, HPNï¼‰**ï¼šé€šè¿‡å±‚æ¬¡ç»“æ„å»ºæ¨¡å¤æ‚ç³»ç»Ÿ
- **ä¼˜å…ˆçº§Petriç½‘ï¼ˆPriority Petri Net, PPNï¼‰**ï¼šé€šè¿‡ä¼˜å…ˆçº§æœºåˆ¶å»ºæ¨¡è°ƒåº¦ç³»ç»Ÿ
- **æ¦‚ç‡Petriç½‘ï¼ˆStochastic Petri Net, SPNï¼‰**ï¼šé€šè¿‡éšæœºæ€§å»ºæ¨¡ä¸ç¡®å®šç³»ç»Ÿ
- **æ¨¡ç³ŠPetriç½‘ï¼ˆFuzzy Petri Net, FPNï¼‰**ï¼šé€šè¿‡æ¨¡ç³Šé€»è¾‘å»ºæ¨¡ä¸ç²¾ç¡®ç³»ç»Ÿ
- **æ··åˆPetriç½‘ï¼ˆHybrid Petri Net, HPNï¼‰**ï¼šé€šè¿‡æ··åˆæœºåˆ¶å»ºæ¨¡æ··åˆç³»ç»Ÿ
- **å¯¹è±¡Petriç½‘ï¼ˆObject Petri Net, OPNï¼‰**ï¼šé€šè¿‡é¢å‘å¯¹è±¡å»ºæ¨¡å¤æ‚ç³»ç»Ÿ

---

## 1. æœ‰è‰²Petriç½‘ï¼ˆCPNï¼‰

### ç†è®ºå®šä¹‰

æœ‰è‰²Petriç½‘é€šè¿‡ä¸ºæ ‡è®°èµ‹äºˆ"é¢œè‰²"ï¼ˆå³æ•°æ®ç±»å‹æˆ–å±æ€§ï¼‰ï¼Œä½¿å¾—Petriç½‘èƒ½å¤Ÿå»ºæ¨¡æ›´å¤æ‚çš„æ•°æ®æµå’Œæ¡ä»¶ã€‚

- **å½¢å¼å®šä¹‰**ï¼š
  - CPN = (P, T, A, Î£, N, C, G, E, I)
    - Pï¼šåº“æ‰€é›†åˆ
    - Tï¼šå˜è¿é›†åˆ
    - Aï¼šå¼§é›†åˆ
    - Î£ï¼šé¢œè‰²é›†
    - Nï¼šèŠ‚ç‚¹å‡½æ•°
    - Cï¼šé¢œè‰²å‡½æ•°
    - Gï¼šå®ˆå«å‡½æ•°
    - Eï¼šå¼§è¡¨è¾¾å¼
    - Iï¼šåˆå§‹æ ‡è®°

### ä»£ç å®ç°

```python
import numpy as np
from typing import Dict, List, Set, Tuple, Any
from dataclasses import dataclass
from enum import Enum

class ColorType(Enum):
    INT = "int"
    STRING = "string"
    BOOL = "bool"
    CUSTOM = "custom"

@dataclass
class Token:
    value: Any
    color: ColorType
    timestamp: float = 0.0

class ColoredPetriNet:
    def __init__(self, places: List[str], transitions: List[str], 
                 colors: Dict[str, ColorType], arcs: List[Tuple], 
                 guards: Dict[str, callable], initial_marking: Dict[str, List[Token]]):
        self.places = places
        self.transitions = transitions
        self.colors = colors
        self.arcs = arcs
        self.guards = guards
        self.marking = initial_marking.copy()
        self.enabled_transitions = set()
        self.update_enabled_transitions()
    
    def update_enabled_transitions(self):
        """æ›´æ–°å¯æ¿€å‘çš„å˜è¿"""
        self.enabled_transitions.clear()
        for transition in self.transitions:
            if self.is_transition_enabled(transition):
                self.enabled_transitions.add(transition)
    
    def is_transition_enabled(self, transition: str) -> bool:
        """æ£€æŸ¥å˜è¿æ˜¯å¦å¯æ¿€å‘"""
        # æ£€æŸ¥è¾“å…¥åº“æ‰€çš„æ ‡è®°
        for arc in self.arcs:
            if arc[1] == transition:  # è¾“å…¥å¼§
                place = arc[0]
                required_tokens = arc[2]
                if len(self.marking.get(place, [])) < required_tokens:
                    return False
        
        # æ£€æŸ¥å®ˆå«æ¡ä»¶
        if transition in self.guards:
            if not self.guards[transition](self.marking):
                return False
        
        return True
    
    def fire_transition(self, transition: str) -> bool:
        """æ¿€å‘å˜è¿"""
        if transition not in self.enabled_transitions:
            return False
        
        # ç§»é™¤è¾“å…¥æ ‡è®°
        for arc in self.arcs:
            if arc[1] == transition:  # è¾“å…¥å¼§
                place = arc[0]
                tokens_to_remove = arc[2]
                for _ in range(tokens_to_remove):
                    if self.marking[place]:
                        self.marking[place].pop()
        
        # æ·»åŠ è¾“å‡ºæ ‡è®°
        for arc in self.arcs:
            if arc[0] == transition:  # è¾“å‡ºå¼§
                place = arc[1]
                tokens_to_add = arc[2]
                for _ in range(tokens_to_add):
                    new_token = Token(
                        value=0,
                        color=self.colors.get(place, ColorType.INT),
                        timestamp=0.0
                    )
                    if place not in self.marking:
                        self.marking[place] = []
                    self.marking[place].append(new_token)
        
        self.update_enabled_transitions()
        return True
    
    def get_marking(self) -> Dict[str, List[Token]]:
        """è·å–å½“å‰æ ‡è®°"""
        return self.marking.copy()
    
    def add_token(self, place: str, token: Token):
        """æ·»åŠ æ ‡è®°åˆ°åº“æ‰€"""
        if place not in self.marking:
            self.marking[place] = []
        self.marking[place].append(token)
        self.update_enabled_transitions()
    
    def remove_token(self, place: str, token: Token):
        """ä»åº“æ‰€ç§»é™¤æ ‡è®°"""
        if place in self.marking and token in self.marking[place]:
            self.marking[place].remove(token)
            self.update_enabled_transitions()
```

### åº”ç”¨å®ä¾‹ï¼šé€šä¿¡åè®®å»ºæ¨¡

```python
class CommunicationProtocol(ColoredPetriNet):
    def __init__(self):
        # å®šä¹‰åº“æ‰€
        places = ["sender_ready", "message_sent", "receiver_ready", 
                 "message_received", "ack_sent", "ack_received"]
        
        # å®šä¹‰å˜è¿
        transitions = ["send_message", "receive_message", "send_ack", "receive_ack"]
        
        # å®šä¹‰é¢œè‰²
        colors = {
            "sender_ready": ColorType.BOOL,
            "message_sent": ColorType.STRING,
            "receiver_ready": ColorType.BOOL,
            "message_received": ColorType.STRING,
            "ack_sent": ColorType.BOOL,
            "ack_received": ColorType.BOOL
        }
        
        # å®šä¹‰å¼§
        arcs = [
            ("sender_ready", "send_message", 1),
            ("send_message", "message_sent", 1),
            ("receiver_ready", "receive_message", 1),
            ("message_sent", "receive_message", 1),
            ("receive_message", "message_received", 1),
            ("message_received", "send_ack", 1),
            ("send_ack", "ack_sent", 1),
            ("ack_sent", "receive_ack", 1),
            ("receive_ack", "ack_received", 1)
        ]
        
        # å®šä¹‰å®ˆå«å‡½æ•°
        guards = {
            "send_message": lambda marking: len(marking.get("sender_ready", [])) > 0,
            "receive_message": lambda marking: len(marking.get("message_sent", [])) > 0,
            "send_ack": lambda marking: len(marking.get("message_received", [])) > 0,
            "receive_ack": lambda marking: len(marking.get("ack_sent", [])) > 0
        }
        
        # åˆå§‹æ ‡è®°
        initial_marking = {
            "sender_ready": [Token(True, ColorType.BOOL)],
            "receiver_ready": [Token(True, ColorType.BOOL)]
        }
        
        super().__init__(places, transitions, colors, arcs, guards, initial_marking)
    
    def simulate_protocol(self, steps: int = 10):
        """æ¨¡æ‹Ÿåè®®æ‰§è¡Œ"""
        print("åˆå§‹çŠ¶æ€:", self.get_marking())
        
        for step in range(steps):
            if not self.enabled_transitions:
                print("æ²¡æœ‰å¯æ¿€å‘çš„å˜è¿")
                break
            
            # éšæœºé€‰æ‹©ä¸€ä¸ªå¯æ¿€å‘çš„å˜è¿
            transition = list(self.enabled_transitions)[0]
            print(f"æ­¥éª¤ {step + 1}: æ¿€å‘å˜è¿ {transition}")
            
            if self.fire_transition(transition):
                print(f"å½“å‰æ ‡è®°: {self.get_marking()}")
            else:
                print(f"æ¿€å‘å˜è¿ {transition} å¤±è´¥")
                break
```

---

## 2. æ—¶é—´Petriç½‘ï¼ˆTPNï¼‰

### ç†è®ºå®šä¹‰2

æ—¶é—´Petriç½‘åœ¨åŸºæœ¬Petriç½‘çš„åŸºç¡€ä¸Šå¼•å…¥äº†æ—¶é—´çº¦æŸï¼Œä½¿å¾—æ¨¡å‹èƒ½å¤Ÿæè¿°å®æ—¶ç³»ç»Ÿçš„è¡Œä¸ºã€‚

- **å½¢å¼å®šä¹‰**ï¼š
  - TPN = (P, T, A, Mâ‚€, I)
    - Pï¼šåº“æ‰€é›†åˆ
    - Tï¼šå˜è¿é›†åˆ
    - Aï¼šå¼§é›†åˆ
    - Mâ‚€ï¼šåˆå§‹æ ‡è®°
    - Iï¼šæ—¶é—´é—´éš”å‡½æ•° I: T â†’ [a, b] âŠ† â„âº

### ä»£ç å®ç°2

```python
@dataclass
class TimeInterval:
    min_time: float
    max_time: float
    
    def __post_init__(self):
        if self.min_time > self.max_time:
            raise ValueError("æœ€å°æ—¶é—´ä¸èƒ½å¤§äºæœ€å¤§æ—¶é—´")

class TimedPetriNet:
    def __init__(self, places: List[str], transitions: List[str], 
                 arcs: List[Tuple], initial_marking: Dict[str, int],
                 time_intervals: Dict[str, TimeInterval]):
        self.places = places
        self.transitions = transitions
        self.arcs = arcs
        self.marking = initial_marking.copy()
        self.time_intervals = time_intervals
        self.transition_timers = {}
        self.current_time = 0.0
        self.update_enabled_transitions()
    
    def update_enabled_transitions(self):
        """æ›´æ–°å¯æ¿€å‘çš„å˜è¿"""
        self.enabled_transitions = set()
        for transition in self.transitions:
            if self.is_transition_enabled(transition):
                self.enabled_transitions.add(transition)
                if transition not in self.transition_timers:
                    interval = self.time_intervals[transition]
                    self.transition_timers[transition] = {
                        'earliest': self.current_time + interval.min_time,
                        'latest': self.current_time + interval.max_time
                    }
    
    def is_transition_enabled(self, transition: str) -> bool:
        """æ£€æŸ¥å˜è¿æ˜¯å¦å¯æ¿€å‘"""
        for arc in self.arcs:
            if arc[1] == transition:  # è¾“å…¥å¼§
                place = arc[0]
                required_tokens = arc[2]
                if self.marking.get(place, 0) < required_tokens:
                    return False
        return True
    
    def can_fire_transition(self, transition: str) -> bool:
        """æ£€æŸ¥å˜è¿æ˜¯å¦å¯ä»¥æ¿€å‘ï¼ˆè€ƒè™‘æ—¶é—´çº¦æŸï¼‰"""
        if transition not in self.enabled_transitions:
            return False
        
        timer = self.transition_timers.get(transition)
        if timer is None:
            return False
        
        return timer['earliest'] <= self.current_time <= timer['latest']
    
    def fire_transition(self, transition: str) -> bool:
        """æ¿€å‘å˜è¿"""
        if not self.can_fire_transition(transition):
            return False
        
        # ç§»é™¤è¾“å…¥æ ‡è®°
        for arc in self.arcs:
            if arc[1] == transition:  # è¾“å…¥å¼§
                place = arc[0]
                tokens_to_remove = arc[2]
                self.marking[place] -= tokens_to_remove
        
        # æ·»åŠ è¾“å‡ºæ ‡è®°
        for arc in self.arcs:
            if arc[0] == transition:  # è¾“å‡ºå¼§
                place = arc[1]
                tokens_to_add = arc[2]
                self.marking[place] = self.marking.get(place, 0) + tokens_to_add
        
        # ç§»é™¤è®¡æ—¶å™¨
        if transition in self.transition_timers:
            del self.transition_timers[transition]
        
        self.update_enabled_transitions()
        return True
    
    def advance_time(self, delta_time: float):
        """æ¨è¿›æ—¶é—´"""
        self.current_time += delta_time
        
        # æ£€æŸ¥æ˜¯å¦æœ‰å˜è¿å› è¶…æ—¶è€Œå¤±æ•ˆ
        expired_transitions = []
        for transition, timer in self.transition_timers.items():
            if self.current_time > timer['latest']:
                expired_transitions.append(transition)
        
        for transition in expired_transitions:
            del self.transition_timers[transition]
            if transition in self.enabled_transitions:
                self.enabled_transitions.remove(transition)
```

### åº”ç”¨å®ä¾‹ï¼šå®æ—¶æ§åˆ¶ç³»ç»Ÿ

```python
class RealTimeControlSystem(TimedPetriNet):
    def __init__(self):
        # å®šä¹‰åº“æ‰€
        places = ["sensor_active", "data_ready", "processor_idle", 
                 "processing", "actuator_ready", "action_completed"]
        
        # å®šä¹‰å˜è¿
        transitions = ["read_sensor", "process_data", "send_command", "execute_action"]
        
        # å®šä¹‰å¼§
        arcs = [
            ("sensor_active", "read_sensor", 1),
            ("read_sensor", "data_ready", 1),
            ("processor_idle", "process_data", 1),
            ("data_ready", "process_data", 1),
            ("process_data", "processing", 1),
            ("processing", "send_command", 1),
            ("actuator_ready", "execute_action", 1),
            ("send_command", "execute_action", 1),
            ("execute_action", "action_completed", 1)
        ]
        
        # åˆå§‹æ ‡è®°
        initial_marking = {
            "sensor_active": 1,
            "processor_idle": 1,
            "actuator_ready": 1
        }
        
        # æ—¶é—´é—´éš”
        time_intervals = {
            "read_sensor": TimeInterval(0.1, 0.5),
            "process_data": TimeInterval(1.0, 3.0),
            "send_command": TimeInterval(0.05, 0.2),
            "execute_action": TimeInterval(0.5, 2.0)
        }
        
        super().__init__(places, transitions, arcs, initial_marking, time_intervals)
    
    def simulate_real_time_system(self, simulation_time: float = 10.0):
        """æ¨¡æ‹Ÿå®æ—¶ç³»ç»Ÿ"""
        print(f"å¼€å§‹å®æ—¶ç³»ç»Ÿæ¨¡æ‹Ÿï¼Œæ€»æ—¶é—´: {simulation_time}")
        print(f"åˆå§‹çŠ¶æ€: {self.marking}")
        
        while self.current_time < simulation_time:
            # æ£€æŸ¥å¯æ¿€å‘çš„å˜è¿
            fireable_transitions = [t for t in self.enabled_transitions 
                                  if self.can_fire_transition(t)]
            
            if fireable_transitions:
                # é€‰æ‹©æœ€æ—©å¯æ¿€å‘çš„å˜è¿
                next_transition = min(fireable_transitions, 
                                   key=lambda t: self.transition_timers[t]['earliest'])
                
                # æ¨è¿›åˆ°æ¿€å‘æ—¶é—´
                fire_time = self.transition_timers[next_transition]['earliest']
                self.advance_time(fire_time - self.current_time)
                
                # æ¿€å‘å˜è¿
                print(f"æ—¶é—´ {self.current_time:.2f}: æ¿€å‘å˜è¿ {next_transition}")
                self.fire_transition(next_transition)
                print(f"å½“å‰æ ‡è®°: {self.marking}")
            else:
                # æ¨è¿›åˆ°ä¸‹ä¸€ä¸ªå¯èƒ½çš„äº‹ä»¶æ—¶é—´
                if self.transition_timers:
                    next_event_time = min(timer['earliest'] for timer in self.transition_timers.values())
                    self.advance_time(next_event_time - self.current_time)
                else:
                    break
        
        print(f"æ¨¡æ‹Ÿç»“æŸï¼Œæœ€ç»ˆçŠ¶æ€: {self.marking}")
```

---

## 3. æ¦‚ç‡Petriç½‘ï¼ˆSPNï¼‰

### ç†è®ºå®šä¹‰3

æ¦‚ç‡Petriç½‘åœ¨åŸºæœ¬Petriç½‘çš„åŸºç¡€ä¸Šå¼•å…¥äº†éšæœºæ€§ï¼Œä½¿å¾—å˜è¿çš„æ¿€å‘æ—¶é—´æœä»æ¦‚ç‡åˆ†å¸ƒã€‚

- **å½¢å¼å®šä¹‰**ï¼š
  - SPN = (P, T, A, Mâ‚€, F)
    - Pï¼šåº“æ‰€é›†åˆ
    - Tï¼šå˜è¿é›†åˆ
    - Aï¼šå¼§é›†åˆ
    - Mâ‚€ï¼šåˆå§‹æ ‡è®°
    - Fï¼šæ¦‚ç‡åˆ†å¸ƒå‡½æ•° F: T â†’ Distribution

### ä»£ç å®ç°3

```python
import random
from scipy.stats import expon, norm, uniform

class StochasticPetriNet:
    def __init__(self, places: List[str], transitions: List[str], 
                 arcs: List[Tuple], initial_marking: Dict[str, int],
                 distributions: Dict[str, callable]):
        self.places = places
        self.transitions = transitions
        self.arcs = arcs
        self.marking = initial_marking.copy()
        self.distributions = distributions
        self.transition_timers = {}
        self.current_time = 0.0
        self.update_enabled_transitions()
    
    def update_enabled_transitions(self):
        """æ›´æ–°å¯æ¿€å‘çš„å˜è¿"""
        self.enabled_transitions = set()
        for transition in self.transitions:
            if self.is_transition_enabled(transition):
                self.enabled_transitions.add(transition)
                if transition not in self.transition_timers:
                    # ç”Ÿæˆéšæœºæ¿€å‘æ—¶é—´
                    fire_time = self.distributions[transition]()
                    self.transition_timers[transition] = self.current_time + fire_time
    
    def is_transition_enabled(self, transition: str) -> bool:
        """æ£€æŸ¥å˜è¿æ˜¯å¦å¯æ¿€å‘"""
        for arc in self.arcs:
            if arc[1] == transition:  # è¾“å…¥å¼§
                place = arc[0]
                required_tokens = arc[2]
                if self.marking.get(place, 0) < required_tokens:
                    return False
        return True
    
    def get_next_transition(self) -> str:
        """è·å–ä¸‹ä¸€ä¸ªæ¿€å‘çš„å˜è¿"""
        if not self.transition_timers:
            return None
        
        return min(self.transition_timers.keys(), 
                  key=lambda t: self.transition_timers[t])
    
    def fire_transition(self, transition: str) -> bool:
        """æ¿€å‘å˜è¿"""
        if transition not in self.transition_timers:
            return False
        
        # ç§»é™¤è¾“å…¥æ ‡è®°
        for arc in self.arcs:
            if arc[1] == transition:  # è¾“å…¥å¼§
                place = arc[0]
                tokens_to_remove = arc[2]
                self.marking[place] -= tokens_to_remove
        
        # æ·»åŠ è¾“å‡ºæ ‡è®°
        for arc in self.arcs:
            if arc[0] == transition:  # è¾“å‡ºå¼§
                place = arc[1]
                tokens_to_add = arc[2]
                self.marking[place] = self.marking.get(place, 0) + tokens_to_add
        
        # æ›´æ–°æ—¶é—´å’Œè®¡æ—¶å™¨
        self.current_time = self.transition_timers[transition]
        del self.transition_timers[transition]
        
        self.update_enabled_transitions()
        return True
    
    def simulate(self, max_time: float = 100.0, max_events: int = 1000):
        """æ¨¡æ‹Ÿæ¦‚ç‡Petriç½‘"""
        events = []
        event_count = 0
        
        while self.current_time < max_time and event_count < max_events:
            next_transition = self.get_next_transition()
            if next_transition is None:
                break
            
            # è®°å½•äº‹ä»¶
            events.append({
                'time': self.current_time,
                'transition': next_transition,
                'marking': self.marking.copy()
            })
            
            # æ¿€å‘å˜è¿
            self.fire_transition(next_transition)
            event_count += 1
        
        return events
```

### åº”ç”¨å®ä¾‹ï¼šæ’é˜Ÿç³»ç»Ÿ

```python
class QueueingSystem(StochasticPetriNet):
    def __init__(self, arrival_rate: float = 1.0, service_rate: float = 2.0):
        # å®šä¹‰åº“æ‰€
        places = ["queue", "server_idle", "server_busy"]
        
        # å®šä¹‰å˜è¿
        transitions = ["arrival", "service_start", "service_complete"]
        
        # å®šä¹‰å¼§
        arcs = [
            ("arrival", "queue", 1),
            ("server_idle", "service_start", 1),
            ("queue", "service_start", 1),
            ("service_start", "server_busy", 1),
            ("server_busy", "service_complete", 1),
            ("service_complete", "server_idle", 1)
        ]
        
        # åˆå§‹æ ‡è®°
        initial_marking = {
            "server_idle": 1
        }
        
        # æ¦‚ç‡åˆ†å¸ƒ
        distributions = {
            "arrival": lambda: expon.rvs(scale=1/arrival_rate),
            "service_start": lambda: 0.0,  # ç«‹å³æ¿€å‘
            "service_complete": lambda: expon.rvs(scale=1/service_rate)
        }
        
        super().__init__(places, transitions, arcs, initial_marking, distributions)
    
    def analyze_performance(self, simulation_time: float = 1000.0):
        """åˆ†æç³»ç»Ÿæ€§èƒ½"""
        events = self.simulate(simulation_time)
        
        # è®¡ç®—æ€§èƒ½æŒ‡æ ‡
        queue_lengths = []
        server_utilization = []
        
        for event in events:
            marking = event['marking']
            queue_lengths.append(marking.get('queue', 0))
            server_utilization.append(1 if marking.get('server_busy', 0) > 0 else 0)
        
        avg_queue_length = np.mean(queue_lengths)
        avg_server_utilization = np.mean(server_utilization)
        
        return {
            'average_queue_length': avg_queue_length,
            'average_server_utilization': avg_server_utilization,
            'total_events': len(events),
            'simulation_time': events[-1]['time'] if events else 0
        }
```

---

## 4. æ¨¡ç³ŠPetriç½‘ï¼ˆFPNï¼‰

### ç†è®ºå®šä¹‰4

æ¨¡ç³ŠPetriç½‘åœ¨åŸºæœ¬Petriç½‘çš„åŸºç¡€ä¸Šå¼•å…¥äº†æ¨¡ç³Šé€»è¾‘ï¼Œä½¿å¾—æ ‡è®°å’Œå˜è¿çš„æ¿€å‘å…·æœ‰æ¨¡ç³Šæ€§ã€‚

- **å½¢å¼å®šä¹‰**ï¼š
  - FPN = (P, T, A, Mâ‚€, Î¼, Ï„)
    - Pï¼šåº“æ‰€é›†åˆ
    - Tï¼šå˜è¿é›†åˆ
    - Aï¼šå¼§é›†åˆ
    - Mâ‚€ï¼šåˆå§‹æ ‡è®°
    - Î¼ï¼šæ¨¡ç³Šæ ‡è®°å‡½æ•° Î¼: P â†’ [0,1]
    - Ï„ï¼šæ¨¡ç³Šå˜è¿å‡½æ•° Ï„: T â†’ [0,1]

### ä»£ç å®ç°4

```python
class FuzzyPetriNet:
    def __init__(self, places: List[str], transitions: List[str], 
                 arcs: List[Tuple], initial_marking: Dict[str, float],
                 fuzzy_rules: Dict[str, callable]):
        self.places = places
        self.transitions = transitions
        self.arcs = arcs
        self.marking = initial_marking.copy()
        self.fuzzy_rules = fuzzy_rules
        self.enabled_transitions = set()
        self.update_enabled_transitions()
    
    def fuzzy_and(self, values: List[float]) -> float:
        """æ¨¡ç³ŠANDæ“ä½œ"""
        return min(values) if values else 0.0
    
    def fuzzy_or(self, values: List[float]) -> float:
        """æ¨¡ç³ŠORæ“ä½œ"""
        return max(values) if values else 0.0
    
    def fuzzy_not(self, value: float) -> float:
        """æ¨¡ç³ŠNOTæ“ä½œ"""
        return 1.0 - value
    
    def fuzzy_imply(self, antecedent: float, consequent: float) -> float:
        """æ¨¡ç³Šè•´å«æ“ä½œ"""
        return min(1.0, 1.0 - antecedent + consequent)
    
    def update_enabled_transitions(self):
        """æ›´æ–°å¯æ¿€å‘çš„å˜è¿"""
        self.enabled_transitions.clear()
        for transition in self.transitions:
            confidence = self.compute_transition_confidence(transition)
            if confidence > 0.0:
                self.enabled_transitions.add(transition)
    
    def compute_transition_confidence(self, transition: str) -> float:
        """è®¡ç®—å˜è¿çš„ç½®ä¿¡åº¦"""
        input_places = []
        for arc in self.arcs:
            if arc[1] == transition:  # è¾“å…¥å¼§
                place = arc[0]
                input_places.append(self.marking.get(place, 0.0))
        
        if not input_places:
            return 0.0
        
        # ä½¿ç”¨æ¨¡ç³ŠANDè®¡ç®—è¾“å…¥ç½®ä¿¡åº¦
        input_confidence = self.fuzzy_and(input_places)
        
        # åº”ç”¨æ¨¡ç³Šè§„åˆ™
        if transition in self.fuzzy_rules:
            return self.fuzzy_rules[transition](input_confidence)
        
        return input_confidence
    
    def fire_transition(self, transition: str) -> bool:
        """æ¿€å‘å˜è¿"""
        if transition not in self.enabled_transitions:
            return False
        
        confidence = self.compute_transition_confidence(transition)
        
        # æ›´æ–°è¾“å‡ºåº“æ‰€çš„æ¨¡ç³Šæ ‡è®°
        for arc in self.arcs:
            if arc[0] == transition:  # è¾“å‡ºå¼§
                place = arc[1]
                current_marking = self.marking.get(place, 0.0)
                # ä½¿ç”¨æ¨¡ç³ŠORæ›´æ–°æ ‡è®°
                self.marking[place] = self.fuzzy_or([current_marking, confidence])
        
        self.update_enabled_transitions()
        return True
    
    def get_fuzzy_marking(self) -> Dict[str, float]:
        """è·å–æ¨¡ç³Šæ ‡è®°"""
        return self.marking.copy()
```

### åº”ç”¨å®ä¾‹ï¼šæ¨¡ç³Šæ§åˆ¶ç³»ç»Ÿ

```python
class FuzzyControlSystem(FuzzyPetriNet):
    def __init__(self):
        # å®šä¹‰åº“æ‰€
        places = ["temperature_low", "temperature_medium", "temperature_high",
                 "humidity_low", "humidity_medium", "humidity_high",
                 "fan_slow", "fan_medium", "fan_fast"]
        
        # å®šä¹‰å˜è¿
        transitions = ["temp_to_fan", "humidity_to_fan", "combined_control"]
        
        # å®šä¹‰å¼§
        arcs = [
            ("temperature_medium", "temp_to_fan", 1),
            ("humidity_medium", "humidity_to_fan", 1),
            ("temperature_high", "combined_control", 1),
            ("humidity_high", "combined_control", 1),
            ("temp_to_fan", "fan_medium", 1),
            ("humidity_to_fan", "fan_medium", 1),
            ("combined_control", "fan_fast", 1)
        ]
        
        # åˆå§‹æ¨¡ç³Šæ ‡è®°
        initial_marking = {
            "temperature_low": 0.8,
            "temperature_medium": 0.2,
            "temperature_high": 0.0,
            "humidity_low": 0.6,
            "humidity_medium": 0.4,
            "humidity_high": 0.0
        }
        
        # æ¨¡ç³Šè§„åˆ™
        fuzzy_rules = {
            "temp_to_fan": lambda x: x * 0.8,  # æ¸©åº¦æ§åˆ¶è§„åˆ™
            "humidity_to_fan": lambda x: x * 0.7,  # æ¹¿åº¦æ§åˆ¶è§„åˆ™
            "combined_control": lambda x: x * 0.9  # ç»„åˆæ§åˆ¶è§„åˆ™
        }
        
        super().__init__(places, transitions, arcs, initial_marking, fuzzy_rules)
    
    def control_system(self, temperature: float, humidity: float):
        """æ§åˆ¶ç³»ç»Ÿ"""
        # æ›´æ–°ç¯å¢ƒæ¡ä»¶
        self.update_environmental_conditions(temperature, humidity)
        
        # æ‰§è¡Œæ¨¡ç³Šæ¨ç†
        for _ in range(5):  # å¤šæ¬¡æ¨ç†
            for transition in list(self.enabled_transitions):
                self.fire_transition(transition)
        
        # è·å–æ§åˆ¶è¾“å‡º
        fan_speed = self.get_fan_speed()
        return fan_speed
    
    def update_environmental_conditions(self, temperature: float, humidity: float):
        """æ›´æ–°ç¯å¢ƒæ¡ä»¶"""
        # æ¸©åº¦æ¨¡ç³ŠåŒ–
        if temperature < 20:
            self.marking["temperature_low"] = 1.0
            self.marking["temperature_medium"] = 0.0
            self.marking["temperature_high"] = 0.0
        elif temperature < 30:
            self.marking["temperature_low"] = 0.0
            self.marking["temperature_medium"] = 1.0
            self.marking["temperature_high"] = 0.0
        else:
            self.marking["temperature_low"] = 0.0
            self.marking["temperature_medium"] = 0.0
            self.marking["temperature_high"] = 1.0
        
        # æ¹¿åº¦æ¨¡ç³ŠåŒ–
        if humidity < 40:
            self.marking["humidity_low"] = 1.0
            self.marking["humidity_medium"] = 0.0
            self.marking["humidity_high"] = 0.0
        elif humidity < 70:
            self.marking["humidity_low"] = 0.0
            self.marking["humidity_medium"] = 1.0
            self.marking["humidity_high"] = 0.0
        else:
            self.marking["humidity_low"] = 0.0
            self.marking["humidity_medium"] = 0.0
            self.marking["humidity_high"] = 1.0
        
        self.update_enabled_transitions()
    
    def get_fan_speed(self) -> str:
        """è·å–é£æ‰‡é€Ÿåº¦"""
        fan_speeds = {
            "fan_slow": self.marking.get("fan_slow", 0.0),
            "fan_medium": self.marking.get("fan_medium", 0.0),
            "fan_fast": self.marking.get("fan_fast", 0.0)
        }
        
        max_speed = max(fan_speeds, key=fan_speeds.get)
        return max_speed.replace("fan_", "")
```

---

## æ€»ç»“

é«˜çº§Petriç½‘å˜ç§é€šè¿‡å¼•å…¥é¢œè‰²ã€æ—¶é—´ã€æ¦‚ç‡ã€æ¨¡ç³Šã€å±‚æ¬¡ç­‰æœºåˆ¶ï¼Œæå¤§åœ°æ‰©å±•äº†Petriç½‘çš„è¡¨è¾¾èƒ½åŠ›ã€‚è¿™äº›å˜ç§èƒ½å¤Ÿæ›´å¥½åœ°å»ºæ¨¡å¤æ‚ç³»ç»Ÿçš„å„ç§ç‰¹æ€§ï¼š

1. **æœ‰è‰²Petriç½‘**ï¼šé€šè¿‡é¢œè‰²æœºåˆ¶å»ºæ¨¡å¤æ‚çš„æ•°æ®æµå’Œæ¡ä»¶
2. **æ—¶é—´Petriç½‘**ï¼šé€šè¿‡æ—¶é—´çº¦æŸå»ºæ¨¡å®æ—¶ç³»ç»Ÿ
3. **æ¦‚ç‡Petriç½‘**ï¼šé€šè¿‡éšæœºæ€§å»ºæ¨¡ä¸ç¡®å®šç³»ç»Ÿ
4. **æ¨¡ç³ŠPetriç½‘**ï¼šé€šè¿‡æ¨¡ç³Šé€»è¾‘å»ºæ¨¡ä¸ç²¾ç¡®ç³»ç»Ÿ
5. **å±‚æ¬¡Petriç½‘**ï¼šé€šè¿‡å±‚æ¬¡ç»“æ„å»ºæ¨¡å¤æ‚ç³»ç»Ÿ

è¿™äº›å˜ç§ä¸ºä¸åŒé¢†åŸŸçš„åº”ç”¨æä¾›äº†å¼ºå¤§çš„å»ºæ¨¡å·¥å…·ï¼Œä½¿å¾—Petriç½‘ç†è®ºèƒ½å¤Ÿæ›´å¥½åœ°æœåŠ¡äºå®é™…å·¥ç¨‹éœ€æ±‚ã€‚
