# 8.3.3-Petriç½‘åˆ†ææ–¹æ³•æ·±åŒ–

## ğŸ“– ç†è®ºç»¼è¿°

Petriç½‘åˆ†ææ–¹æ³•æ˜¯ç†è§£å’ŒéªŒè¯Petriç½‘æ¨¡å‹è¡Œä¸ºçš„æ ¸å¿ƒå·¥å…·ã€‚
é€šè¿‡ç³»ç»ŸåŒ–çš„åˆ†æï¼Œå¯ä»¥æ­ç¤ºç³»ç»Ÿçš„å¯è¾¾æ€§ã€æ´»æ€§ã€å®‰å…¨æ€§ã€æ­»é”ã€è¦†ç›–æ€§ã€ä¸å˜é‡ç­‰å…³é”®æ€§è´¨ï¼Œä¸ºå¹¶å‘ç³»ç»Ÿã€åˆ†å¸ƒå¼ç³»ç»Ÿã€å®æ—¶ç³»ç»Ÿç­‰çš„å»ºæ¨¡ä¸éªŒè¯æä¾›ç†è®ºåŸºç¡€å’Œå·¥ç¨‹æ‰‹æ®µã€‚

### ä¸»è¦åˆ†ææ–¹æ³•

- **å¯è¾¾æ€§åˆ†æ**
- **æ´»æ€§åˆ†æ**
- **å®‰å…¨æ€§åˆ†æ**
- **æ­»é”æ£€æµ‹**
- **è¦†ç›–æ€§åˆ†æ**
- **ä¸å˜é‡åˆ†æï¼ˆP-ä¸å˜é‡ã€T-ä¸å˜é‡ï¼‰**
- **æœ‰ç•Œæ€§åˆ†æ**
- **ç»“æ„åˆ†æ**
- **æ€§èƒ½åˆ†æ**
- **æ¨¡å‹æ£€æŸ¥**

---

## 1. å¯è¾¾æ€§åˆ†æ

### ç†è®ºå®šä¹‰

å¯è¾¾æ€§åˆ†æç”¨äºåˆ¤æ–­ä»åˆå§‹æ ‡è®°å‡ºå‘ï¼Œç³»ç»Ÿèƒ½å¦åˆ°è¾¾æŸä¸€ç‰¹å®šçŠ¶æ€ã€‚å®ƒæ˜¯Petriç½‘åˆ†æä¸­æœ€åŸºç¡€ä¹Ÿæ˜¯æœ€é‡è¦çš„é—®é¢˜ä¹‹ä¸€ã€‚

- **å¯è¾¾æ€§å›¾**ï¼šä»¥æ ‡è®°ä¸ºèŠ‚ç‚¹ï¼Œå˜è¿ä¸ºè¾¹ï¼Œæè¿°æ‰€æœ‰å¯èƒ½çš„çŠ¶æ€è½¬ç§»ã€‚
- **å¯è¾¾æ€§åˆ¤å®š**ï¼šåˆ¤æ–­ç›®æ ‡æ ‡è®°æ˜¯å¦åœ¨å¯è¾¾æ€§å›¾ä¸­ã€‚

### ä»£ç ç¤ºä¾‹ï¼ˆPythonï¼‰

```python
class PetriNetReachability:
    def __init__(self, net):
        self.net = net

    def reachable_markings(self):
        reachable = {tuple(self.net.initial_marking.items())}
        queue = [self.net.initial_marking]
        while queue:
            current = queue.pop(0)
            for t in self.net.transitions:
                new_marking = self.net.fire(current, t)
                if new_marking:
                    new_tuple = tuple(new_marking.items())
                    if new_tuple not in reachable:
                        reachable.add(new_tuple)
                        queue.append(new_marking)
        return [dict(m) for m in reachable]
```

---

## 2. æ´»æ€§åˆ†æ

### ç†è®ºå®šä¹‰1

æ´»æ€§åˆ†æç”¨äºåˆ¤æ–­Petriç½‘ä¸­æ¯ä¸ªå˜è¿æ˜¯å¦åœ¨æŸäº›å¯è¾¾æ ‡è®°ä¸‹å§‹ç»ˆæœ‰å¯èƒ½è¢«è§¦å‘ã€‚æ´»æ€§æ˜¯è¡¡é‡ç³»ç»Ÿâ€œä¸ä¼šæ°¸ä¹…åœæ»â€çš„é‡è¦æŒ‡æ ‡ã€‚

- **æ´»æ€§ç­‰çº§**ï¼š
  - 0-æ´»æ€§ï¼šå˜è¿æ°¸è¿œä¸ä¼šè¢«è§¦å‘
  - 1-æ´»æ€§ï¼šå˜è¿è‡³å°‘èƒ½è¢«è§¦å‘ä¸€æ¬¡
  - k-æ´»æ€§ï¼šå˜è¿èƒ½è¢«è§¦å‘kæ¬¡
  - Ï‰-æ´»æ€§ï¼šå˜è¿èƒ½è¢«æ— é™æ¬¡è§¦å‘
- **ç³»ç»Ÿæ´»æ€§**ï¼šæ‰€æœ‰å˜è¿å‡ä¸ºÏ‰-æ´»æ€§

### ä»£ç ç¤ºä¾‹ï¼ˆPythonï¼‰1

```python
class PetriNetLiveness:
    def __init__(self, net):
        self.net = net

    def is_live(self):
        reachable = PetriNetReachability(self.net).reachable_markings()
        for t in self.net.transitions:
            if not any(self.net.can_fire(m, t) for m in reachable):
                return False
        return True
```

---

## 3. å®‰å…¨æ€§åˆ†æ

### ç†è®ºå®šä¹‰2

å®‰å…¨æ€§åˆ†æç”¨äºåˆ¤æ–­ç³»ç»Ÿæ˜¯å¦ä¼šè¿›å…¥â€œå±é™©â€çŠ¶æ€ï¼ˆå¦‚èµ„æºæº¢å‡ºã€éæ³•è®¿é—®ç­‰ï¼‰ã€‚å®‰å…¨æ€§æ˜¯ç³»ç»Ÿæ­£ç¡®æ€§çš„é‡è¦ä¿éšœã€‚

- **å®‰å…¨åº“æ‰€**ï¼šæŸåº“æ‰€çš„æ ‡è®°æ•°åœ¨æ‰€æœ‰å¯è¾¾æ ‡è®°ä¸‹å‡ä¸è¶…è¿‡1
- **k-å®‰å…¨**ï¼šæŸåº“æ‰€çš„æ ‡è®°æ•°åœ¨æ‰€æœ‰å¯è¾¾æ ‡è®°ä¸‹å‡ä¸è¶…è¿‡k

### ä»£ç ç¤ºä¾‹ï¼ˆPythonï¼‰2

```python
class PetriNetSafety:
    def __init__(self, net):
        self.net = net

    def is_safe(self, place, k=1):
        reachable = PetriNetReachability(self.net).reachable_markings()
        return all(m[place] <= k for m in reachable)
```

---

## 4. è¦†ç›–æ€§åˆ†æ

### ç†è®ºå®šä¹‰3

è¦†ç›–æ€§åˆ†æç”¨äºåˆ¤æ–­ç³»ç»Ÿæ˜¯å¦èƒ½å¤Ÿé€šè¿‡å˜è¿åºåˆ—è¦†ç›–æ‰€æœ‰å¯èƒ½çš„æ ‡è®°ã€‚è¦†ç›–æ€§æ˜¯è¡¡é‡ç³»ç»Ÿâ€œè¡¨è¾¾èƒ½åŠ›â€çš„é‡è¦æŒ‡æ ‡ã€‚

- **è¦†ç›–æ€§å›¾**ï¼šä»¥æ ‡è®°ä¸ºèŠ‚ç‚¹ï¼Œå˜è¿ä¸ºè¾¹ï¼Œæè¿°æ‰€æœ‰å¯èƒ½çš„æ ‡è®°è¦†ç›–ã€‚
- **è¦†ç›–æ€§åˆ¤å®š**ï¼šåˆ¤æ–­ç›®æ ‡æ ‡è®°æ˜¯å¦åœ¨è¦†ç›–æ€§å›¾ä¸­ã€‚

### ä»£ç ç¤ºä¾‹ï¼ˆPythonï¼‰3

```python
class PetriNetCoverability:
    def __init__(self, net):
        self.net = net

    def is_coverable(self, marking):
        reachable = PetriNetReachability(self.net).reachable_markings()
        queue = [marking]
        covered = set()
        while queue:
            current = queue.pop(0)
            if current not in covered:
                covered.add(current)
                for t in self.net.transitions:
                    new_marking = self.net.fire(current, t)
                    if new_marking:
                        new_tuple = tuple(new_marking.items())
                        if new_tuple not in covered:
                            queue.append(new_marking)
        return all(m in covered for m in reachable)
```

---

## 5. æ­»é”æ£€æµ‹

### ç†è®ºå®šä¹‰4

æ­»é”æ£€æµ‹ç”¨äºåˆ¤æ–­ç³»ç»Ÿæ˜¯å¦å­˜åœ¨æ— æ³•ç»§ç»­æ‰§è¡Œçš„è¿›ç¨‹æˆ–çº¿ç¨‹ã€‚æ­»é”æ˜¯å¹¶å‘ç³»ç»Ÿä¸­å¸¸è§çš„é—®é¢˜ã€‚

- **æ­»é”çŠ¶æ€**ï¼šç³»ç»Ÿä¸­å­˜åœ¨ä¸€ç»„è¿›ç¨‹ï¼Œæ¯ä¸ªè¿›ç¨‹éƒ½åœ¨ç­‰å¾…å…¶ä»–è¿›ç¨‹é‡Šæ”¾èµ„æºã€‚
- **æ­»é”åˆ¤å®š**ï¼šåˆ¤æ–­ç³»ç»Ÿæ˜¯å¦å­˜åœ¨æ­»é”ã€‚

### ä»£ç ç¤ºä¾‹ï¼ˆPythonï¼‰4

```python
class PetriNetDeadlock:
    def __init__(self, net):
        self.net = net

    def has_deadlock(self):
        reachable = PetriNetReachability(self.net).reachable_markings()
        for m in reachable:
            if self.net.can_fire(m, t) for t in self.net.transitions:
                return True
        return False
```

---

## 6. ä¸å˜é‡åˆ†æ

### ç†è®ºå®šä¹‰5

ä¸å˜é‡åˆ†æç”¨äºå‘ç°Petriç½‘ä¸­ä¿æŒä¸å˜çš„æ•°å­¦å…³ç³»ï¼Œè¿™äº›å…³ç³»å¯¹äºç†è§£ç³»ç»Ÿè¡Œä¸ºå’ŒéªŒè¯ç³»ç»Ÿæ€§è´¨å…·æœ‰é‡è¦æ„ä¹‰ã€‚

- **P-ä¸å˜é‡**ï¼šåº“æ‰€æ ‡è®°æ•°çš„çº¿æ€§ç»„åˆåœ¨ç³»ç»Ÿè¿è¡Œä¸­ä¿æŒä¸å˜
- **T-ä¸å˜é‡**ï¼šå˜è¿è§¦å‘æ¬¡æ•°çš„çº¿æ€§ç»„åˆä½¿å¾—ç³»ç»Ÿå›åˆ°åˆå§‹çŠ¶æ€

### ä»£ç ç¤ºä¾‹ï¼ˆPythonï¼‰5

```python
import numpy as np

class PetriNetInvariants:
    def __init__(self, net):
        self.net = net

    def compute_p_invariants(self):
        # æ„å»ºå…³è”çŸ©é˜µ
        incidence_matrix = self.build_incidence_matrix()
        # è®¡ç®—P-ä¸å˜é‡ï¼ˆé›¶ç©ºé—´ï¼‰
        p_invariants = np.linalg.null_space(incidence_matrix.T)
        return p_invariants

    def compute_t_invariants(self):
        # æ„å»ºå…³è”çŸ©é˜µ
        incidence_matrix = self.build_incidence_matrix()
        # è®¡ç®—T-ä¸å˜é‡ï¼ˆé›¶ç©ºé—´ï¼‰
        t_invariants = np.linalg.null_space(incidence_matrix)
        return t_invariants

    def build_incidence_matrix(self):
        # æ„å»ºå…³è”çŸ©é˜µ C = Post - Pre
        places = list(self.net.places)
        transitions = list(self.net.transitions)
        matrix = np.zeros((len(places), len(transitions)))
        
        for i, p in enumerate(places):
            for j, t in enumerate(transitions):
                post = self.net.post_matrix.get(t, {}).get(p, 0)
                pre = self.net.pre_matrix.get(p, {}).get(t, 0)
                matrix[i, j] = post - pre
        
        return matrix
```

---

## 7. æœ‰ç•Œæ€§åˆ†æ

### ç†è®ºå®šä¹‰6

æœ‰ç•Œæ€§åˆ†æç”¨äºåˆ¤æ–­Petriç½‘ä¸­åº“æ‰€çš„æ ‡è®°æ•°æ˜¯å¦æœ‰ä¸Šç•Œï¼Œè¿™å¯¹äºç³»ç»Ÿèµ„æºç®¡ç†å’Œå®‰å…¨æ€§åˆ†æå…·æœ‰é‡è¦æ„ä¹‰ã€‚

- **k-æœ‰ç•Œ**ï¼šæŸåº“æ‰€çš„æ ‡è®°æ•°åœ¨æ‰€æœ‰å¯è¾¾æ ‡è®°ä¸‹å‡ä¸è¶…è¿‡k
- **æœ‰ç•ŒPetriç½‘**ï¼šæ‰€æœ‰åº“æ‰€å‡ä¸ºk-æœ‰ç•Œï¼ˆå¯¹æŸä¸ªkï¼‰

### ä»£ç ç¤ºä¾‹ï¼ˆPythonï¼‰6

```python
class PetriNetBoundedness:
    def __init__(self, net):
        self.net = net

    def is_bounded(self, place):
        reachable = PetriNetReachability(self.net).reachable_markings()
        max_tokens = max(m.get(place, 0) for m in reachable)
        return max_tokens < float('inf')

    def get_bound(self, place):
        reachable = PetriNetReachability(self.net).reachable_markings()
        return max(m.get(place, 0) for m in reachable)
```

---

## 8. ç»“æ„åˆ†æ

### ç†è®ºå®šä¹‰7

ç»“æ„åˆ†æåŸºäºPetriç½‘çš„æ‹“æ‰‘ç»“æ„ï¼Œä¸ä¾èµ–äºåˆå§‹æ ‡è®°ï¼Œèƒ½å¤Ÿå‘ç°ç³»ç»Ÿçš„ç»“æ„æ€§è´¨ã€‚

- **ç»“æ„æ´»æ€§**ï¼šå­˜åœ¨åˆå§‹æ ‡è®°ä½¿å¾—ç³»ç»Ÿä¸ºæ´»çš„
- **ç»“æ„æœ‰ç•Œæ€§**ï¼šå­˜åœ¨åˆå§‹æ ‡è®°ä½¿å¾—ç³»ç»Ÿä¸ºæœ‰ç•Œçš„
- **ç»“æ„æ­»é”**ï¼šæ— è®ºåˆå§‹æ ‡è®°å¦‚ä½•ï¼Œç³»ç»Ÿéƒ½å­˜åœ¨æ­»é”

### ä»£ç ç¤ºä¾‹ï¼ˆPythonï¼‰7

```python
class PetriNetStructuralAnalysis:
    def __init__(self, net):
        self.net = net

    def is_structurally_live(self):
        # æ£€æŸ¥æ˜¯å¦å­˜åœ¨P-ä¸å˜é‡å’ŒT-ä¸å˜é‡
        p_invariants = PetriNetInvariants(self.net).compute_p_invariants()
        t_invariants = PetriNetInvariants(self.net).compute_t_invariants()
        
        # ç»“æ„æ´»æ€§æ£€æŸ¥ï¼ˆç®€åŒ–ç‰ˆï¼‰
        return len(p_invariants) > 0 and len(t_invariants) > 0

    def is_structurally_bounded(self):
        # æ£€æŸ¥æ˜¯å¦å­˜åœ¨æ­£çš„P-ä¸å˜é‡
        p_invariants = PetriNetInvariants(self.net).compute_p_invariants()
        return any(np.all(inv > 0) for inv in p_invariants)
```

---

## 9. æ€§èƒ½åˆ†æ

### ç†è®ºå®šä¹‰8

æ€§èƒ½åˆ†æç”¨äºè¯„ä¼°Petriç½‘ç³»ç»Ÿçš„ååé‡ã€å“åº”æ—¶é—´ã€èµ„æºåˆ©ç”¨ç‡ç­‰æ€§èƒ½æŒ‡æ ‡ï¼Œå¯¹äºç³»ç»Ÿä¼˜åŒ–å…·æœ‰é‡è¦æ„ä¹‰ã€‚

- **ç¨³æ€åˆ†æ**ï¼šè®¡ç®—ç³»ç»Ÿåœ¨é•¿æœŸè¿è¡Œä¸‹çš„æ€§èƒ½æŒ‡æ ‡
- **ç¬æ€åˆ†æ**ï¼šåˆ†æç³»ç»Ÿåœ¨ç‰¹å®šæ—¶é—´ç‚¹çš„æ€§èƒ½è¡¨ç°

### ä»£ç ç¤ºä¾‹ï¼ˆPythonï¼‰8

```python
import numpy as np
from scipy.linalg import solve

class PetriNetPerformance:
    def __init__(self, net):
        self.net = net

    def steady_state_analysis(self):
        # æ„å»ºé©¬å°”å¯å¤«é“¾ï¼ˆç®€åŒ–ç‰ˆï¼‰
        reachable = PetriNetReachability(self.net).reachable_markings()
        n_states = len(reachable)
        
        # æ„å»ºè½¬ç§»çŸ©é˜µï¼ˆéœ€è¦æ¦‚ç‡ä¿¡æ¯ï¼‰
        transition_matrix = self.build_transition_matrix(reachable)
        
        # æ±‚è§£ç¨³æ€æ¦‚ç‡
        steady_state = self.solve_steady_state(transition_matrix)
        
        return {
            'steady_state': steady_state,
            'throughput': self.calculate_throughput(steady_state),
            'utilization': self.calculate_utilization(steady_state)
        }

    def build_transition_matrix(self, reachable):
        """æ„å»ºè½¬ç§»çŸ©é˜µ"""
        n_states = len(reachable)
        matrix = np.zeros((n_states, n_states))
        
        # è®¡ç®—è½¬ç§»æ¦‚ç‡
        for i, state in enumerate(reachable):
            enabled_transitions = [t for t in self.net.transitions 
                                 if self.net.can_fire(state, t)]
            if enabled_transitions:
                # æ ¹æ®å˜è¿çš„æƒé‡æˆ–ä¼˜å…ˆçº§è®¡ç®—æ¦‚ç‡
                total_weight = sum(self.get_transition_weight(t) for t in enabled_transitions)
                
                for t in enabled_transitions:
                    weight = self.get_transition_weight(t)
                    prob = weight / total_weight if total_weight > 0 else 1.0 / len(enabled_transitions)
                    
                    new_state = self.net.fire(state, t)
                    if new_state:
                        j = reachable.index(new_state)
                        matrix[i, j] = prob
        
        return matrix
    
    def get_transition_weight(self, transition):
        """è·å–å˜è¿æƒé‡"""
        # å¯ä»¥ä»å˜è¿çš„å±æ€§ä¸­è·å–æƒé‡
        if hasattr(transition, 'weight'):
            return transition.weight
        elif hasattr(transition, 'rate'):
            return transition.rate
        else:
            return 1.0  # é»˜è®¤æƒé‡

    def solve_steady_state(self, transition_matrix):
        # æ±‚è§£ç¨³æ€æ¦‚ç‡ Ï€ = Ï€P
        n_states = transition_matrix.shape[0]
        
        # æ„å»ºçº¿æ€§æ–¹ç¨‹ç»„
        A = transition_matrix.T - np.eye(n_states)
        A[-1, :] = 1  # æ¦‚ç‡å’Œä¸º1çš„çº¦æŸ
        b = np.zeros(n_states)
        b[-1] = 1
        
        # æ±‚è§£çº¿æ€§æ–¹ç¨‹ç»„
        steady_state = solve(A, b)
        return steady_state
```

---

## 10. æ¨¡å‹æ£€æŸ¥

### ç†è®ºå®šä¹‰9

æ¨¡å‹æ£€æŸ¥ç”¨äºéªŒè¯Petriç½‘æ˜¯å¦æ»¡è¶³ç‰¹å®šçš„æ—¶åºé€»è¾‘æ€§è´¨ï¼Œæ˜¯å½¢å¼åŒ–éªŒè¯çš„é‡è¦æ–¹æ³•ã€‚

- **CTLï¼ˆè®¡ç®—æ ‘é€»è¾‘ï¼‰**ï¼šç”¨äºæè¿°åˆ†æ”¯æ—¶é—´æ€§è´¨
- **LTLï¼ˆçº¿æ€§æ—¶åºé€»è¾‘ï¼‰**ï¼šç”¨äºæè¿°çº¿æ€§æ—¶é—´æ€§è´¨
- **æ¨¡å‹æ£€æŸ¥ç®—æ³•**ï¼šè‡ªåŠ¨éªŒè¯ç³»ç»Ÿæ˜¯å¦æ»¡è¶³æ€§è´¨

### ä»£ç ç¤ºä¾‹ï¼ˆPythonï¼‰9

```python
class PetriNetModelChecker:
    def __init__(self, net):
        self.net = net

    def check_ctl_property(self, property_formula):
        """CTLæ€§è´¨æ£€æŸ¥"""
        # è§£æCTLå…¬å¼
        parsed_formula = self.parse_ctl_formula(property_formula)
        
        if parsed_formula['operator'] == 'AG':
            # å…¨å±€æ€§è´¨ï¼šæ‰€æœ‰è·¯å¾„éƒ½æ»¡è¶³
            return self.check_global_property(parsed_formula['subformula'])
        elif parsed_formula['operator'] == 'EF':
            # å­˜åœ¨æ€§è´¨ï¼šå­˜åœ¨è·¯å¾„æ»¡è¶³
            return self.check_existential_property(parsed_formula['subformula'])
        elif parsed_formula['operator'] == 'EG':
            # å­˜åœ¨å…¨å±€æ€§è´¨ï¼šå­˜åœ¨è·¯å¾„æ€»æ˜¯æ»¡è¶³
            return self.check_existential_global_property(parsed_formula['subformula'])
        elif parsed_formula['operator'] == 'AF':
            # å…¨å±€å­˜åœ¨æ€§è´¨ï¼šæ‰€æœ‰è·¯å¾„æœ€ç»ˆæ»¡è¶³
            return self.check_global_existential_property(parsed_formula['subformula'])
        else:
            return False
    
    def parse_ctl_formula(self, formula):
        """è§£æCTLå…¬å¼"""
        # ç®€åŒ–çš„CTLè§£æå™¨
        if formula.startswith("AG"):
            return {'operator': 'AG', 'subformula': formula[2:]}
        elif formula.startswith("EF"):
            return {'operator': 'EF', 'subformula': formula[2:]}
        elif formula.startswith("EG"):
            return {'operator': 'EG', 'subformula': formula[2:]}
        elif formula.startswith("AF"):
            return {'operator': 'AF', 'subformula': formula[2:]}
        else:
            return {'operator': 'ATOMIC', 'subformula': formula}
    
    def check_existential_global_property(self, sub_property):
        """æ£€æŸ¥å­˜åœ¨å…¨å±€æ€§è´¨ EG Ï†"""
        # ä½¿ç”¨Tarjanç®—æ³•æ‰¾åˆ°å¼ºè¿é€šåˆ†é‡
        sccs = self.find_strongly_connected_components()
        
        for scc in sccs:
            # æ£€æŸ¥SCCä¸­æ˜¯å¦æ‰€æœ‰çŠ¶æ€éƒ½æ»¡è¶³æ€§è´¨
            if all(self.evaluate_property(m, sub_property) for m in scc):
                # æ£€æŸ¥æ˜¯å¦ä»åˆå§‹çŠ¶æ€å¯è¾¾
                if self.is_scc_reachable(scc):
                    return True
        
        return False
    
    def check_global_existential_property(self, sub_property):
        """æ£€æŸ¥å…¨å±€å­˜åœ¨æ€§è´¨ AF Ï†"""
        # ä½¿ç”¨æ¨¡å‹æ£€æŸ¥ç®—æ³•
        reachable = PetriNetReachability(self.net).reachable_markings()
        
        # æ‰¾åˆ°æ»¡è¶³æ€§è´¨çš„çŠ¶æ€
        satisfying_states = [m for m in reachable if self.evaluate_property(m, sub_property)]
        
        # æ£€æŸ¥æ˜¯å¦æ‰€æœ‰è·¯å¾„éƒ½èƒ½åˆ°è¾¾æ»¡è¶³çŠ¶æ€
        return self.check_all_paths_reach_satisfying(satisfying_states)
    
    def find_strongly_connected_components(self):
        """æ‰¾åˆ°å¼ºè¿é€šåˆ†é‡"""
        # ä½¿ç”¨Tarjanç®—æ³•
        reachable = PetriNetReachability(self.net).reachable_markings()
        graph = self.build_transition_graph(reachable)
        
        return self.tarjan_algorithm(graph)
    
    def tarjan_algorithm(self, graph):
        """Tarjanç®—æ³•æ‰¾åˆ°å¼ºè¿é€šåˆ†é‡"""
        n = len(graph)
        index = 0
        indices = [-1] * n
        lowlinks = [-1] * n
        on_stack = [False] * n
        stack = []
        sccs = []
        
        def strongconnect(v):
            nonlocal index
            indices[v] = index
            lowlinks[v] = index
            index += 1
            stack.append(v)
            on_stack[v] = True
            
            for w in graph[v]:
                if indices[w] == -1:
                    strongconnect(w)
                    lowlinks[v] = min(lowlinks[v], lowlinks[w])
                elif on_stack[w]:
                    lowlinks[v] = min(lowlinks[v], indices[w])
            
            if lowlinks[v] == indices[v]:
                scc = []
                while True:
                    w = stack.pop()
                    on_stack[w] = False
                    scc.append(w)
                    if w == v:
                        break
                sccs.append(scc)
        
        for v in range(n):
            if indices[v] == -1:
                strongconnect(v)
        
        return sccs
    
    def build_transition_graph(self, markings):
        """æ„å»ºè½¬æ¢å›¾"""
        graph = [[] for _ in range(len(markings))]
        
        for i, marking in enumerate(markings):
            for j, other_marking in enumerate(markings):
                if i != j and self.can_reach(marking, other_marking):
                    graph[i].append(j)
        
        return graph
    
    def can_reach(self, marking1, marking2):
        """æ£€æŸ¥æ˜¯å¦å¯ä»¥ä»marking1åˆ°è¾¾marking2"""
        # æ£€æŸ¥æ˜¯å¦å­˜åœ¨ä¸€ä¸ªå˜è¿åºåˆ—
        return self.net.can_fire_sequence(marking1, marking2)
    
    def is_scc_reachable(self, scc):
        """æ£€æŸ¥å¼ºè¿é€šåˆ†é‡æ˜¯å¦ä»åˆå§‹çŠ¶æ€å¯è¾¾"""
        initial_marking = self.net.initial_marking
        reachable = PetriNetReachability(self.net).reachable_markings()
        
        # æ£€æŸ¥SCCä¸­æ˜¯å¦æœ‰çŠ¶æ€åœ¨å¯è¾¾é›†ä¸­
        return any(m in reachable for m in scc)
    
    def check_all_paths_reach_satisfying(self, satisfying_states):
        """æ£€æŸ¥æ‰€æœ‰è·¯å¾„æ˜¯å¦éƒ½èƒ½åˆ°è¾¾æ»¡è¶³çŠ¶æ€"""
        # ä½¿ç”¨Tarjanç®—æ³•æ‰¾åˆ°å¼ºè¿é€šåˆ†é‡
        sccs = self.find_strongly_connected_components()
        
        # æ„å»ºå¯è¾¾æ€§å›¾
        reachability_graph = self.build_reachability_graph()
        
        # æ£€æŸ¥æ¯ä¸ªå¼ºè¿é€šåˆ†é‡
        for scc in sccs:
            # å¦‚æœSCCä¸­æ²¡æœ‰æ»¡è¶³çŠ¶æ€ï¼Œæ£€æŸ¥æ˜¯å¦å¯ä»¥ä»SCCåˆ°è¾¾æ»¡è¶³çŠ¶æ€
            scc_has_satisfying = any(state in satisfying_states for state in scc)
            
            if not scc_has_satisfying:
                # æ£€æŸ¥SCCæ˜¯å¦å¯ä»¥ä»å¤–éƒ¨åˆ°è¾¾æ»¡è¶³çŠ¶æ€
                if not self.scc_can_reach_satisfying(scc, satisfying_states, reachability_graph):
                    return False
        
        return True
    
    def find_strongly_connected_components(self):
        """ä½¿ç”¨Tarjanç®—æ³•æ‰¾åˆ°å¼ºè¿é€šåˆ†é‡"""
        # Tarjanç®—æ³•å®ç°
        index = 0
        indices = {}
        lowlinks = {}
        on_stack = set()
        stack = []
        sccs = []
        
        def strongconnect(node):
            nonlocal index
            indices[node] = index
            lowlinks[node] = index
            index += 1
            stack.append(node)
            on_stack.add(node)
            
            # è€ƒè™‘æ‰€æœ‰åç»§èŠ‚ç‚¹
            for successor in self.net.get_successors(node):
                if successor not in indices:
                    strongconnect(successor)
                    lowlinks[node] = min(lowlinks[node], lowlinks[successor])
                elif successor in on_stack:
                    lowlinks[node] = min(lowlinks[node], indices[successor])
            
            # å¦‚æœnodeæ˜¯å¼ºè¿é€šåˆ†é‡çš„æ ¹
            if lowlinks[node] == indices[node]:
                scc = []
                while True:
                    w = stack.pop()
                    on_stack.remove(w)
                    scc.append(w)
                    if w == node:
                        break
                sccs.append(scc)
        
        # å¯¹æ‰€æœ‰èŠ‚ç‚¹è¿è¡ŒTarjanç®—æ³•
        reachable = PetriNetReachability(self.net).reachable_markings()
        for node in reachable:
            if node not in indices:
                strongconnect(node)
        
        return sccs
    
    def build_reachability_graph(self):
        """æ„å»ºå¯è¾¾æ€§å›¾"""
        reachable = PetriNetReachability(self.net).reachable_markings()
        graph = {}
        
        for marking in reachable:
            graph[marking] = []
            for successor in self.net.get_successors(marking):
                graph[marking].append(successor)
        
        return graph
    
    def scc_can_reach_satisfying(self, scc, satisfying_states, reachability_graph):
        """æ£€æŸ¥SCCæ˜¯å¦å¯ä»¥ä»å¤–éƒ¨åˆ°è¾¾æ»¡è¶³çŠ¶æ€"""
        # ä½¿ç”¨å¹¿åº¦ä¼˜å…ˆæœç´¢æ£€æŸ¥å¯è¾¾æ€§
        visited = set()
        queue = list(scc)
        
        while queue:
            current = queue.pop(0)
            
            if current in satisfying_states:
                return True
            
            if current in visited:
                continue
            
            visited.add(current)
            
            # æ·»åŠ æ‰€æœ‰åç»§çŠ¶æ€
            for successor in reachability_graph.get(current, []):
                if successor not in visited:
                    queue.append(successor)
        
        return False
    
    def can_reach_satisfying(self, marking, satisfying_states):
        """æ£€æŸ¥æ˜¯å¦å¯ä»¥ä»markingåˆ°è¾¾æ»¡è¶³çŠ¶æ€"""
        # ä½¿ç”¨å¹¿åº¦ä¼˜å…ˆæœç´¢
        visited = set()
        queue = [marking]
        
        while queue:
            current = queue.pop(0)
            if current in satisfying_states:
                return True
            
            if current in visited:
                continue
            
            visited.add(current)
            
            # æ·»åŠ æ‰€æœ‰åç»§çŠ¶æ€
            for next_marking in self.net.get_successors(current):
                if next_marking not in visited:
                    queue.append(next_marking)
        
        return False

    def check_ltl_property(self, property_formula):
        """LTLæ€§è´¨æ£€æŸ¥"""
        # å°†LTLè½¬æ¢ä¸ºBÃ¼chiè‡ªåŠ¨æœº
        buchi_automaton = self.ltl_to_buchi(property_formula)
        
        # æ„å»ºPetriç½‘çš„è‡ªåŠ¨æœºè¡¨ç¤º
        petri_automaton = self.petri_net_to_automaton()
        
        # æ£€æŸ¥è¯­è¨€åŒ…å«å…³ç³»
        return self.check_language_inclusion(petri_automaton, buchi_automaton)
    
    def ltl_to_buchi(self, ltl_formula):
        """å°†LTLå…¬å¼è½¬æ¢ä¸ºBÃ¼chiè‡ªåŠ¨æœº"""
        # ä½¿ç”¨Spotåº“æˆ–è‡ªå®šä¹‰å®ç°
        # è¿™é‡Œæä¾›ç®€åŒ–çš„å®ç°
        
        # è§£æLTLå…¬å¼
        parsed = self.parse_ltl_formula(ltl_formula)
        
        # æ„å»ºBÃ¼chiè‡ªåŠ¨æœº
        buchi = self.build_buchi_automaton(parsed)
        
        return buchi
    
    def parse_ltl_formula(self, formula):
        """è§£æLTLå…¬å¼"""
        # ç®€åŒ–çš„LTLè§£æå™¨
        tokens = self.tokenize_ltl(formula)
        return self.build_ltl_tree(tokens)
    
    def tokenize_ltl(self, formula):
        """å°†LTLå…¬å¼åˆ†è¯"""
        # ç®€åŒ–çš„åˆ†è¯å™¨
        tokens = []
        current = ""
        
        for char in formula:
            if char in ['(', ')', '!', '&', '|', 'U', 'X', 'F', 'G']:
                if current:
                    tokens.append(current)
                    current = ""
                tokens.append(char)
            elif char.isalnum():
                current += char
            elif char.isspace():
                if current:
                    tokens.append(current)
                    current = ""
        
        if current:
            tokens.append(current)
        
        return tokens
    
    def build_ltl_tree(self, tokens):
        """æ„å»ºLTLè¯­æ³•æ ‘"""
        # ç®€åŒ–çš„è¯­æ³•æ ‘æ„å»º
        if len(tokens) == 1:
            return {'type': 'atomic', 'value': tokens[0]}
        
        # å¤„ç†ä¸€å…ƒæ“ä½œç¬¦
        if tokens[0] in ['!', 'X', 'F', 'G']:
            return {
                'type': 'unary',
                'operator': tokens[0],
                'operand': self.build_ltl_tree(tokens[1:])
            }
        
        # å¤„ç†äºŒå…ƒæ“ä½œç¬¦
        for i, token in enumerate(tokens):
            if token in ['&', '|', 'U']:
                return {
                    'type': 'binary',
                    'operator': token,
                    'left': self.build_ltl_tree(tokens[:i]),
                    'right': self.build_ltl_tree(tokens[i+1:])
                }
        
        return {'type': 'atomic', 'value': tokens[0]}
    
    def build_buchi_automaton(self, ltl_tree):
        """æ„å»ºBÃ¼chiè‡ªåŠ¨æœº"""
        # ç®€åŒ–çš„BÃ¼chiè‡ªåŠ¨æœºæ„å»º
        states = self.generate_states(ltl_tree)
        transitions = self.generate_transitions(ltl_tree, states)
        accepting = self.identify_accepting_states(ltl_tree, states)
        
        return {
            'states': states,
            'transitions': transitions,
            'accepting': accepting,
            'initial': states[0]
        }
    
    def generate_states(self, ltl_tree):
        """ç”ŸæˆBÃ¼chiè‡ªåŠ¨æœºçŠ¶æ€"""
        # åŸºäºLTLå…¬å¼çš„å­å…¬å¼ç”ŸæˆçŠ¶æ€
        states = []
        
        def collect_subformulas(node, states):
            if node['type'] == 'atomic':
                states.append(node['value'])
            elif node['type'] == 'unary':
                states.append(f"{node['operator']}({node['operand']['value']})")
                collect_subformulas(node['operand'], states)
            elif node['type'] == 'binary':
                states.append(f"({node['left']['value']}{node['operator']}{node['right']['value']})")
                collect_subformulas(node['left'], states)
                collect_subformulas(node['right'], states)
        
        collect_subformulas(ltl_tree, states)
        return list(set(states))  # å»é‡
    
    def generate_transitions(self, ltl_tree, states):
        """ç”Ÿæˆè½¬æ¢å…³ç³»"""
        transitions = {}
        
        for state in states:
            transitions[state] = []
            # åŸºäºLTLè¯­ä¹‰ç”Ÿæˆè½¬æ¢
            for next_state in states:
                if self.is_valid_transition(state, next_state):
                    transitions[state].append(next_state)
        
        return transitions
    
    def is_valid_transition(self, current_state, next_state):
        """æ£€æŸ¥è½¬æ¢æ˜¯å¦æœ‰æ•ˆ"""
        # åŸºäºLTLè¯­ä¹‰çš„è½¬æ¢è§„åˆ™
        # å®ç°å…·ä½“çš„LTLè¯­ä¹‰è½¬æ¢è§„åˆ™
        
        # è§£æå½“å‰çŠ¶æ€å’Œä¸‹ä¸€çŠ¶æ€çš„LTLå…¬å¼
        current_formula = self.parse_ltl_state(current_state)
        next_formula = self.parse_ltl_state(next_state)
        
        # æ£€æŸ¥è½¬æ¢çš„è¯­ä¹‰æœ‰æ•ˆæ€§
        return self.check_ltl_transition_validity(current_formula, next_formula)
    
    def parse_ltl_state(self, state):
        """è§£æçŠ¶æ€çš„LTLå…¬å¼"""
        # å°†çŠ¶æ€è½¬æ¢ä¸ºLTLå…¬å¼
        if isinstance(state, str):
            return self.parse_ltl_formula(state)
        else:
            return state
    
    def check_ltl_transition_validity(self, current_formula, next_state):
        """æ£€æŸ¥LTLè½¬æ¢çš„æœ‰æ•ˆæ€§"""
        # å®ç°LTLè¯­ä¹‰çš„è½¬æ¢è§„åˆ™
        
        # è§„åˆ™1ï¼šXæ“ä½œç¬¦çš„è¯­ä¹‰
        if self.has_next_operator(current_formula):
            return self.check_next_operator_transition(current_formula, next_state)
        
        # è§„åˆ™2ï¼šUæ“ä½œç¬¦çš„è¯­ä¹‰
        elif self.has_until_operator(current_formula):
            return self.check_until_operator_transition(current_formula, next_state)
        
        # è§„åˆ™3ï¼šGæ“ä½œç¬¦çš„è¯­ä¹‰
        elif self.has_always_operator(current_formula):
            return self.check_always_operator_transition(current_formula, next_state)
        
        # è§„åˆ™4ï¼šFæ“ä½œç¬¦çš„è¯­ä¹‰
        elif self.has_eventually_operator(current_formula):
            return self.check_eventually_operator_transition(current_formula, next_state)
        
        # è§„åˆ™5ï¼šåŸå­å‘½é¢˜çš„è¯­ä¹‰
        else:
            return self.check_atomic_proposition_transition(current_formula, next_state)
    
    def has_next_operator(self, formula):
        """æ£€æŸ¥æ˜¯å¦åŒ…å«Xæ“ä½œç¬¦"""
        return isinstance(formula, dict) and formula.get('type') == 'unary' and formula.get('operator') == 'X'
    
    def has_until_operator(self, formula):
        """æ£€æŸ¥æ˜¯å¦åŒ…å«Uæ“ä½œç¬¦"""
        return isinstance(formula, dict) and formula.get('type') == 'binary' and formula.get('operator') == 'U'
    
    def has_always_operator(self, formula):
        """æ£€æŸ¥æ˜¯å¦åŒ…å«Gæ“ä½œç¬¦"""
        return isinstance(formula, dict) and formula.get('type') == 'unary' and formula.get('operator') == 'G'
    
    def has_eventually_operator(self, formula):
        """æ£€æŸ¥æ˜¯å¦åŒ…å«Fæ“ä½œç¬¦"""
        return isinstance(formula, dict) and formula.get('type') == 'unary' and formula.get('operator') == 'F'
    
    def check_next_operator_transition(self, current_formula, next_state):
        """æ£€æŸ¥Xæ“ä½œç¬¦çš„è½¬æ¢æœ‰æ•ˆæ€§"""
        # X Ï† çš„è¯­ä¹‰ï¼šä¸‹ä¸€çŠ¶æ€å¿…é¡»æ»¡è¶³Ï†
        phi = current_formula['operand']
        return self.evaluate_formula(phi, next_state)
    
    def check_until_operator_transition(self, current_formula, next_state):
        """æ£€æŸ¥Uæ“ä½œç¬¦çš„è½¬æ¢æœ‰æ•ˆæ€§"""
        # Ï† U Ïˆ çš„è¯­ä¹‰ï¼šç›´åˆ°Ïˆæˆç«‹ï¼Œä¸”ä¹‹å‰Ï†æˆç«‹
        phi = current_formula['left']
        psi = current_formula['right']
        
        # å¦‚æœÏˆåœ¨å½“å‰çŠ¶æ€æˆç«‹ï¼Œåˆ™è½¬æ¢æœ‰æ•ˆ
        if self.evaluate_formula(psi, next_state):
            return True
        
        # å¦‚æœÏ†åœ¨å½“å‰çŠ¶æ€æˆç«‹ä¸”Ïˆä¸æˆç«‹ï¼Œåˆ™ç»§ç»­æ£€æŸ¥
        elif self.evaluate_formula(phi, next_state):
            return True
        
        return False
    
    def check_always_operator_transition(self, current_formula, next_state):
        """æ£€æŸ¥Gæ“ä½œç¬¦çš„è½¬æ¢æœ‰æ•ˆæ€§"""
        # G Ï† çš„è¯­ä¹‰ï¼šæ‰€æœ‰çŠ¶æ€éƒ½å¿…é¡»æ»¡è¶³Ï†
        phi = current_formula['operand']
        return self.evaluate_formula(phi, next_state)
    
    def check_eventually_operator_transition(self, current_formula, next_state):
        """æ£€æŸ¥Fæ“ä½œç¬¦çš„è½¬æ¢æœ‰æ•ˆæ€§"""
        # F Ï† çš„è¯­ä¹‰ï¼šå­˜åœ¨çŠ¶æ€æ»¡è¶³Ï†
        phi = current_formula['operand']
        
        # å¦‚æœÏ†åœ¨å½“å‰çŠ¶æ€æˆç«‹ï¼Œåˆ™è½¬æ¢æœ‰æ•ˆ
        if self.evaluate_formula(phi, next_state):
            return True
        
        # å¦åˆ™ç»§ç»­æ£€æŸ¥ï¼ˆF Ï† å¯ä»¥å»¶è¿Ÿæ»¡è¶³ï¼‰
        return True
    
    def check_atomic_proposition_transition(self, current_formula, next_state):
        """æ£€æŸ¥åŸå­å‘½é¢˜çš„è½¬æ¢æœ‰æ•ˆæ€§"""
        # åŸå­å‘½é¢˜çš„è½¬æ¢ï¼šå¦‚æœå½“å‰çŠ¶æ€æ»¡è¶³å‘½é¢˜ï¼Œåˆ™è½¬æ¢æœ‰æ•ˆ
        return self.evaluate_formula(current_formula, next_state)
    
    def evaluate_formula(self, formula, state):
        """åœ¨ç»™å®šçŠ¶æ€ä¸‹è¯„ä¼°å…¬å¼"""
        if isinstance(formula, dict):
            if formula['type'] == 'atomic':
                return formula['value'] in state
            elif formula['type'] == 'unary':
                if formula['operator'] == 'not':
                    return not self.evaluate_formula(formula['operand'], state)
            elif formula['type'] == 'binary':
                if formula['operator'] == 'and':
                    return (self.evaluate_formula(formula['left'], state) and 
                           self.evaluate_formula(formula['right'], state))
                elif formula['operator'] == 'or':
                    return (self.evaluate_formula(formula['left'], state) or 
                           self.evaluate_formula(formula['right'], state))
        return True
    
    def identify_accepting_states(self, ltl_tree, states):
        """è¯†åˆ«æ¥å—çŠ¶æ€"""
        # åŸºäºLTLå…¬å¼çš„å…¬å¹³æ€§æ¡ä»¶è¯†åˆ«æ¥å—çŠ¶æ€
        accepting = []
        
        for state in states:
            if self.is_accepting_state(state, ltl_tree):
                accepting.append(state)
        
        return accepting
    
    def is_accepting_state(self, state, ltl_tree):
        """æ£€æŸ¥çŠ¶æ€æ˜¯å¦ä¸ºæ¥å—çŠ¶æ€"""
        # åŸºäºLTLè¯­ä¹‰çš„æ¥å—æ¡ä»¶
        # å®ç°å…·ä½“çš„æ¥å—çŠ¶æ€è¯†åˆ«ç®—æ³•
        
        # æ£€æŸ¥å…¬å¹³æ€§æ¡ä»¶
        if self.has_fairness_conditions(ltl_tree):
            return self.check_fairness_acceptance(state, ltl_tree)
        
        # æ£€æŸ¥æ— é™æ€§æ¡ä»¶
        elif self.has_infinity_conditions(ltl_tree):
            return self.check_infinity_acceptance(state, ltl_tree)
        
        # æ£€æŸ¥æœ€ç»ˆæ€§æ¡ä»¶
        elif self.has_eventually_conditions(ltl_tree):
            return self.check_eventually_acceptance(state, ltl_tree)
        
        # é»˜è®¤ï¼šæ‰€æœ‰çŠ¶æ€éƒ½æ˜¯æ¥å—çŠ¶æ€
        else:
            return True
    
    def has_fairness_conditions(self, ltl_tree):
        """æ£€æŸ¥æ˜¯å¦åŒ…å«å…¬å¹³æ€§æ¡ä»¶"""
        return self.contains_operator(ltl_tree, 'G') and self.contains_operator(ltl_tree, 'F')
    
    def has_infinity_conditions(self, ltl_tree):
        """æ£€æŸ¥æ˜¯å¦åŒ…å«æ— é™æ€§æ¡ä»¶"""
        return self.contains_operator(ltl_tree, 'G')
    
    def has_eventually_conditions(self, ltl_tree):
        """æ£€æŸ¥æ˜¯å¦åŒ…å«æœ€ç»ˆæ€§æ¡ä»¶"""
        return self.contains_operator(ltl_tree, 'F')
    
    def contains_operator(self, tree, operator):
        """æ£€æŸ¥è¯­æ³•æ ‘æ˜¯å¦åŒ…å«ç‰¹å®šæ“ä½œç¬¦"""
        if isinstance(tree, dict):
            if tree.get('operator') == operator:
                return True
            elif 'operand' in tree:
                return self.contains_operator(tree['operand'], operator)
            elif 'left' in tree and 'right' in tree:
                return (self.contains_operator(tree['left'], operator) or 
                       self.contains_operator(tree['right'], operator))
        return False
    
    def check_fairness_acceptance(self, state, ltl_tree):
        """æ£€æŸ¥å…¬å¹³æ€§æ¥å—æ¡ä»¶"""
        # å…¬å¹³æ€§æ¡ä»¶ï¼šG F Ï† è¡¨ç¤ºæ— é™ç»å¸¸æ»¡è¶³Ï†
        # è¿™é‡Œç®€åŒ–å®ç°ï¼šæ£€æŸ¥çŠ¶æ€æ˜¯å¦æ»¡è¶³æŸäº›å…¬å¹³æ€§æ¡ä»¶
        fairness_props = self.extract_fairness_propositions(ltl_tree)
        
        for prop in fairness_props:
            if not self.evaluate_formula(prop, state):
                return False
        
        return True
    
    def check_infinity_acceptance(self, state, ltl_tree):
        """æ£€æŸ¥æ— é™æ€§æ¥å—æ¡ä»¶"""
        # æ— é™æ€§æ¡ä»¶ï¼šG Ï† è¡¨ç¤ºæ€»æ˜¯æ»¡è¶³Ï†
        always_props = self.extract_always_propositions(ltl_tree)
        
        for prop in always_props:
            if not self.evaluate_formula(prop, state):
                return False
        
        return True
    
    def check_eventually_acceptance(self, state, ltl_tree):
        """æ£€æŸ¥æœ€ç»ˆæ€§æ¥å—æ¡ä»¶"""
        # æœ€ç»ˆæ€§æ¡ä»¶ï¼šF Ï† è¡¨ç¤ºæœ€ç»ˆæ»¡è¶³Ï†
        eventually_props = self.extract_eventually_propositions(ltl_tree)
        
        # å¦‚æœå½“å‰çŠ¶æ€æ»¡è¶³ä»»ä½•æœ€ç»ˆæ€§æ¡ä»¶ï¼Œåˆ™ä¸ºæ¥å—çŠ¶æ€
        for prop in eventually_props:
            if self.evaluate_formula(prop, state):
                return True
        
        return True  # å…è®¸å»¶è¿Ÿæ»¡è¶³
    
    def extract_fairness_propositions(self, ltl_tree):
        """æå–å…¬å¹³æ€§å‘½é¢˜"""
        # æå–G F Ï†å½¢å¼çš„å‘½é¢˜
        props = []
        self.collect_fairness_propositions(ltl_tree, props)
        return props
    
    def extract_always_propositions(self, ltl_tree):
        """æå–æ€»æ˜¯æ€§å‘½é¢˜"""
        # æå–G Ï†å½¢å¼çš„å‘½é¢˜
        props = []
        self.collect_always_propositions(ltl_tree, props)
        return props
    
    def extract_eventually_propositions(self, ltl_tree):
        """æå–æœ€ç»ˆæ€§å‘½é¢˜"""
        # æå–F Ï†å½¢å¼çš„å‘½é¢˜
        props = []
        self.collect_eventually_propositions(ltl_tree, props)
        return props
    
    def collect_fairness_propositions(self, tree, props):
        """æ”¶é›†å…¬å¹³æ€§å‘½é¢˜"""
        if isinstance(tree, dict):
            if tree.get('type') == 'unary' and tree.get('operator') == 'G':
                operand = tree.get('operand', {})
                if isinstance(operand, dict) and operand.get('type') == 'unary' and operand.get('operator') == 'F':
                    props.append(operand.get('operand'))
            elif 'operand' in tree:
                self.collect_fairness_propositions(tree['operand'], props)
            elif 'left' in tree and 'right' in tree:
                self.collect_fairness_propositions(tree['left'], props)
                self.collect_fairness_propositions(tree['right'], props)
    
    def collect_always_propositions(self, tree, props):
        """æ”¶é›†æ€»æ˜¯æ€§å‘½é¢˜"""
        if isinstance(tree, dict):
            if tree.get('type') == 'unary' and tree.get('operator') == 'G':
                props.append(tree.get('operand'))
            elif 'operand' in tree:
                self.collect_always_propositions(tree['operand'], props)
            elif 'left' in tree and 'right' in tree:
                self.collect_always_propositions(tree['left'], props)
                self.collect_always_propositions(tree['right'], props)
    
    def collect_eventually_propositions(self, tree, props):
        """æ”¶é›†æœ€ç»ˆæ€§å‘½é¢˜"""
        if isinstance(tree, dict):
            if tree.get('type') == 'unary' and tree.get('operator') == 'F':
                props.append(tree.get('operand'))
            elif 'operand' in tree:
                self.collect_eventually_propositions(tree['operand'], props)
            elif 'left' in tree and 'right' in tree:
                self.collect_eventually_propositions(tree['left'], props)
                self.collect_eventually_propositions(tree['right'], props)
```

---

## ğŸ”¬ é«˜çº§åˆ†ææ–¹æ³•

### 1. ç¬¦å·åˆ†æ

#### ç¬¦å·å¯è¾¾æ€§åˆ†æ

```haskell
-- ç¬¦å·Petriç½‘åˆ†æ
data SymbolicPetriNet p t = SymbolicPetriNet {
    places :: Set p,
    transitions :: Set t,
    symbolic_marking :: SymbolicMarking p,
    constraints :: [Constraint]
}

-- ç¬¦å·å¯è¾¾æ€§åˆ†æ
symbolicReachabilityAnalysis :: SymbolicPetriNet p t -> SymbolicReachabilityGraph
symbolicReachabilityAnalysis net = 
    let initial = symbolicMarking net
        -- ä½¿ç”¨ç¬¦å·æŠ€æœ¯æ„å»ºå¯è¾¾æ€§å›¾
        graph = buildSymbolicReachabilityGraph net initial
    in graph
```

### 2. æŠ½è±¡åˆ†æ

#### æŠ½è±¡Petriç½‘

```haskell
-- æŠ½è±¡Petriç½‘
abstractPetriNet :: PetriNet p t -> AbstractPetriNet p t
abstractPetriNet net = 
    let -- è¯†åˆ«ç­‰ä»·çŠ¶æ€
        equivalence_classes = findEquivalenceClasses net
        -- æ„å»ºæŠ½è±¡ç½‘
        abstract_places = map abstractPlace equivalence_classes
        abstract_transitions = map abstractTransition (transitions net)
    in AbstractPetriNet abstract_places abstract_transitions
```

### 3. å¹¶è¡Œåˆ†æ

#### å¹¶è¡ŒPetriç½‘åˆ†æ

```rust
// å¹¶è¡ŒPetriç½‘åˆ†æ
impl PetriNet {
    fn parallel_analysis(&self) -> AnalysisResult {
        let mut handles = vec![];
        
        // å¹¶è¡Œè®¡ç®—å¯è¾¾æ€§
        let reachable_handle = thread::spawn(|| {
            self.compute_reachable_markings()
        });
        
        // å¹¶è¡Œè®¡ç®—ä¸å˜é‡
        let invariants_handle = thread::spawn(|| {
            self.compute_invariants()
        });
        
        // å¹¶è¡Œè®¡ç®—æ´»æ€§
        let liveness_handle = thread::spawn(|| {
            self.check_liveness()
        });
        
        // æ”¶é›†ç»“æœ
        let reachable = reachable_handle.join().unwrap();
        let invariants = invariants_handle.join().unwrap();
        let liveness = liveness_handle.join().unwrap();
        
        AnalysisResult {
            reachable_markings: reachable,
            invariants: invariants,
            is_live: liveness
        }
    }
}
```

---

## ğŸ¯ åº”ç”¨åœºæ™¯ä¸å®ä¾‹

### 1. å¹¶å‘ç³»ç»ŸéªŒè¯

#### å“²å­¦å®¶å°±é¤é—®é¢˜åˆ†æ

```python
def analyze_dining_philosophers(n_philosophers):
    net = create_dining_philosophers_net(n_philosophers)
    
    # å¯è¾¾æ€§åˆ†æ
    reachable = PetriNetReachability(net).reachable_markings()
    print(f"å¯è¾¾æ ‡è®°æ•°é‡: {len(reachable)}")
    
    # æ­»é”æ£€æµ‹
    deadlock = PetriNetDeadlock(net).has_deadlock()
    print(f"å­˜åœ¨æ­»é”: {deadlock}")
    
    # æ´»æ€§åˆ†æ
    live = PetriNetLiveness(net).is_live()
    print(f"ç³»ç»Ÿæ˜¯æ´»çš„: {live}")
    
    # å®‰å…¨æ€§åˆ†æ
    safe = all(PetriNetSafety(net).is_safe(p) for p in net.places)
    print(f"ç³»ç»Ÿæ˜¯å®‰å…¨çš„: {safe}")
```

### 2. é€šä¿¡åè®®éªŒè¯

#### TCPåè®®åˆ†æ

```python
def analyze_tcp_protocol():
    net = create_tcp_protocol_net()
    
    # çŠ¶æ€å¯è¾¾æ€§
    reachable = PetriNetReachability(net).reachable_markings()
    print(f"TCPçŠ¶æ€æ•°é‡: {len(reachable)}")
    
    # åè®®æ­£ç¡®æ€§éªŒè¯
    # æ£€æŸ¥æ˜¯å¦æ€»æ˜¯èƒ½å»ºç«‹è¿æ¥
    can_establish = check_connection_establishment(net)
    print(f"æ€»èƒ½å»ºç«‹è¿æ¥: {can_establish}")
    
    # æ£€æŸ¥æ˜¯å¦æ€»æ˜¯èƒ½æ­£ç¡®å…³é—­
    can_close = check_connection_closure(net)
    print(f"æ€»èƒ½æ­£ç¡®å…³é—­: {can_close}")
```

### 3. åˆ¶é€ ç³»ç»Ÿåˆ†æ

#### æŸ”æ€§åˆ¶é€ ç³»ç»Ÿæ€§èƒ½åˆ†æ

```python
def analyze_manufacturing_system():
    net = create_manufacturing_system_net()
    
    # æ€§èƒ½åˆ†æ
    performance = PetriNetPerformance(net).steady_state_analysis()
    print(f"ç³»ç»Ÿååé‡: {performance['throughput']}")
    print(f"èµ„æºåˆ©ç”¨ç‡: {performance['utilization']}")
    
    # ç“¶é¢ˆåˆ†æ
    bottlenecks = identify_bottlenecks(net)
    print(f"ç³»ç»Ÿç“¶é¢ˆ: {bottlenecks}")
    
    # ä¼˜åŒ–å»ºè®®
    optimizations = suggest_optimizations(net, performance)
    print(f"ä¼˜åŒ–å»ºè®®: {optimizations}")
```

---

## ğŸ”— ä¸å…¶ä»–ç†è®ºçš„äº¤å‰

### 1. ä¸è‡ªåŠ¨æœºç†è®º

#### Petriç½‘åˆ°è‡ªåŠ¨æœºçš„è½¬æ¢

```haskell
-- Petriç½‘åˆ°è‡ªåŠ¨æœºçš„è½¬æ¢
petriNetToAutomaton :: PetriNet p t -> FiniteAutomaton (Marking p) t
petriNetToAutomaton net = 
    let states = reachableMarkings net
        alphabet = transitions net
        start = initialMarking net
        delta = \m t -> case fireTransition net m t of
            Just m' -> m'
            Nothing -> m
        finals = states
    in DFA states alphabet start delta finals
```

### 2. ä¸å›¾è®º

#### Petriç½‘å›¾ç»“æ„åˆ†æ

```haskell
-- Petriç½‘çš„å›¾ç»“æ„åˆ†æ
petriNetGraph :: PetriNet p t -> Graph (Either p t)
petriNetGraph (PetriNet places transitions pre post marking) = 
    let -- æ„å»ºäºŒåˆ†å›¾
        nodes = map Left places ++ map Right transitions
        edges = [(Left p, Right t) | p <- places, t <- transitions, pre p t > 0] ++
                [(Right t, Left p) | t <- transitions, p <- places, post t p > 0]
    in Graph nodes edges
```

### 3. ä¸çº¿æ€§ä»£æ•°

#### Petriç½‘çŸ©é˜µåˆ†æ

```haskell
-- Petriç½‘çŸ©é˜µåˆ†æ
petriNetMatrixAnalysis :: PetriNet p t -> MatrixAnalysis
petriNetMatrixAnalysis net = 
    let incidenceMatrix = buildIncidenceMatrix net
        rank = matrixRank incidenceMatrix
        nullity = matrixNullity incidenceMatrix
        eigenvalues = matrixEigenvalues incidenceMatrix
    in MatrixAnalysis rank nullity eigenvalues
```

---

## ğŸš€ å‘å±•å‰æ²¿ä¸æŒ‘æˆ˜

### 1. ç ”ç©¶æ–¹å‘

#### å¤§è§„æ¨¡Petriç½‘åˆ†æ

- **å¯æ‰©å±•æ€§**ï¼šå¤„ç†å¤§è§„æ¨¡Petriç½‘çš„åˆ†æç®—æ³•
- **å¹¶è¡ŒåŒ–**ï¼šå¹¶è¡ŒPetriç½‘åˆ†ææŠ€æœ¯
- **è¿‘ä¼¼ç®—æ³•**ï¼šå¤§è§„æ¨¡Petriç½‘çš„è¿‘ä¼¼åˆ†ææ–¹æ³•

#### å®æ—¶Petriç½‘åˆ†æ

- **æ—¶é—´çº¦æŸ**ï¼šæ—¶é—´Petriç½‘çš„åˆ†ææ–¹æ³•
- **å®æ—¶æ€§**ï¼šå®æ—¶ç³»ç»Ÿçš„Petriç½‘åˆ†æ
- **æ€§èƒ½åˆ†æ**ï¼šå®æ—¶ç³»ç»Ÿçš„æ€§èƒ½åˆ†æ

#### æ¦‚ç‡Petriç½‘åˆ†æ

- **éšæœºæ€§**ï¼šæ¦‚ç‡Petriç½‘çš„åˆ†ææ–¹æ³•
- **é©¬å°”å¯å¤«é“¾**ï¼šä¸é©¬å°”å¯å¤«é“¾çš„ç»“åˆ
- **æ€§èƒ½è¯„ä¼°**ï¼šæ¦‚ç‡ç³»ç»Ÿçš„æ€§èƒ½è¯„ä¼°

### 2. æŠ€æœ¯æŒ‘æˆ˜

#### çŠ¶æ€ç©ºé—´çˆ†ç‚¸

```haskell
-- çŠ¶æ€ç©ºé—´çˆ†ç‚¸é—®é¢˜
stateSpaceExplosion :: PetriNet p t -> Bool
stateSpaceExplosion net = 
    let reachable = reachableMarkings net
        stateCount = length reachable
        -- æ£€æŸ¥çŠ¶æ€æ•°é‡æ˜¯å¦è¶…è¿‡é˜ˆå€¼
        threshold = 1000000  -- 100ä¸‡ä¸ªçŠ¶æ€
    in stateCount > threshold

-- çŠ¶æ€ç©ºé—´å‹ç¼©æŠ€æœ¯
compressStateSpace :: PetriNet p t -> CompressedPetriNet p t
compressStateSpace net = 
    let -- ä½¿ç”¨ç¬¦å·æŠ€æœ¯å‹ç¼©çŠ¶æ€ç©ºé—´
        symbolicRepresentation = buildSymbolicRepresentation net
        -- ä½¿ç”¨æŠ½è±¡æŠ€æœ¯
        abstractedNet = abstractPetriNet net
    in CompressedPetriNet symbolicRepresentation abstractedNet
```

#### åˆ†æå¤æ‚æ€§

```haskell
-- åˆ†æå¤æ‚æ€§è¯„ä¼°
analysisComplexity :: PetriNet p t -> ComplexityAnalysis
analysisComplexity net = 
    let reachableCount = length (reachableMarkings net)
        transitionCount = length (transitions net)
        placeCount = length (places net)
        
        -- è®¡ç®—å„ç§åˆ†æçš„å¤æ‚åº¦
        reachabilityComplexity = reachableCount * transitionCount
        livenessComplexity = reachableCount ^ 2
        deadlockComplexity = reachableCount * transitionCount
        
        totalComplexity = reachabilityComplexity + livenessComplexity + deadlockComplexity
    in ComplexityAnalysis {
        reachabilityComplexity = reachabilityComplexity,
        livenessComplexity = livenessComplexity,
        deadlockComplexity = deadlockComplexity,
        totalComplexity = totalComplexity
    }
```

---

## ğŸ› ï¸ å·¥å…·ä¸å®ç°

### 1. ç¼–ç¨‹è¯­è¨€æ”¯æŒ

#### Python

```python
# Pythonä¸­çš„Petriç½‘åˆ†æå·¥å…·
import numpy as np
from scipy.linalg import solve

class PetriNetAnalyzer:
    def __init__(self, net):
        self.net = net
        self.reachability_analyzer = PetriNetReachability(net)
        self.liveness_analyzer = PetriNetLiveness(net)
        self.safety_analyzer = PetriNetSafety(net)
        self.deadlock_analyzer = PetriNetDeadlock(net)
        self.invariants_analyzer = PetriNetInvariants(net)
        self.performance_analyzer = PetriNetPerformance(net)
    
    def comprehensive_analysis(self):
        """ç»¼åˆåˆ†æ"""
        results = {}
        
        # å¯è¾¾æ€§åˆ†æ
        results['reachable_markings'] = self.reachability_analyzer.reachable_markings()
        results['reachable_count'] = len(results['reachable_markings'])
        
        # æ´»æ€§åˆ†æ
        results['is_live'] = self.liveness_analyzer.is_live()
        
        # å®‰å…¨æ€§åˆ†æ
        results['is_safe'] = all(self.safety_analyzer.is_safe(p) for p in self.net.places)
        
        # æ­»é”åˆ†æ
        results['has_deadlock'] = self.deadlock_analyzer.has_deadlock()
        
        # ä¸å˜é‡åˆ†æ
        results['p_invariants'] = self.invariants_analyzer.compute_p_invariants()
        results['t_invariants'] = self.invariants_analyzer.compute_t_invariants()
        
        # æ€§èƒ½åˆ†æ
        results['performance'] = self.performance_analyzer.steady_state_analysis()
        
        return results
```

#### Java

```java
// Javaä¸­çš„Petriç½‘åˆ†æå·¥å…·
import java.util.*;

public class PetriNetAnalyzer {
    private PetriNet net;
    private PetriNetReachability reachabilityAnalyzer;
    private PetriNetLiveness livenessAnalyzer;
    private PetriNetSafety safetyAnalyzer;
    private PetriNetDeadlock deadlockAnalyzer;
    private PetriNetInvariants invariantsAnalyzer;
    private PetriNetPerformance performanceAnalyzer;
    
    public PetriNetAnalyzer(PetriNet net) {
        this.net = net;
        this.reachabilityAnalyzer = new PetriNetReachability(net);
        this.livenessAnalyzer = new PetriNetLiveness(net);
        this.safetyAnalyzer = new PetriNetSafety(net);
        this.deadlockAnalyzer = new PetriNetDeadlock(net);
        this.invariantsAnalyzer = new PetriNetInvariants(net);
        this.performanceAnalyzer = new PetriNetPerformance(net);
    }
    
    public AnalysisResult comprehensiveAnalysis() {
        AnalysisResult results = new AnalysisResult();
        
        // å¯è¾¾æ€§åˆ†æ
        Set<Map<String, Integer>> reachable = reachabilityAnalyzer.reachableMarkings();
        results.setReachableMarkings(reachable);
        results.setReachableCount(reachable.size());
        
        // æ´»æ€§åˆ†æ
        boolean isLive = livenessAnalyzer.isLive();
        results.setLive(isLive);
        
        // å®‰å…¨æ€§åˆ†æ
        boolean isSafe = net.getPlaces().stream()
            .allMatch(place -> safetyAnalyzer.isSafe(place));
        results.setSafe(isSafe);
        
        // æ­»é”åˆ†æ
        boolean hasDeadlock = deadlockAnalyzer.hasDeadlock();
        results.setHasDeadlock(hasDeadlock);
        
        // ä¸å˜é‡åˆ†æ
        double[][] pInvariants = invariantsAnalyzer.computePInvariants();
        double[][] tInvariants = invariantsAnalyzer.computeTInvariants();
        results.setPInvariants(pInvariants);
        results.setTInvariants(tInvariants);
        
        // æ€§èƒ½åˆ†æ
        PerformanceMetrics performance = performanceAnalyzer.steadyStateAnalysis();
        results.setPerformance(performance);
        
        return results;
    }
}
```

### 2. å½¢å¼åŒ–éªŒè¯å·¥å…·

#### SPIN

```promela
// SPINä¸­çš„Petriç½‘éªŒè¯
proctype PetriNet() {
    int p1 = 1, p2 = 0, p3 = 0;
    int t1_enabled, t2_enabled;
    
    do
    :: atomic {
        t1_enabled = (p1 > 0);
        t2_enabled = (p2 > 0);
        
        if
        :: t1_enabled -> p1--; p2++
        :: t2_enabled -> p2--; p3++
        :: else -> break
        fi
    }
    od
}

// æ€§è´¨éªŒè¯
ltl liveness { []<>(p1 > 0 || p2 > 0 || p3 > 0) }
ltl safety { []!(p1 < 0 || p2 < 0 || p3 < 0) }
ltl deadlock_freedom { []<>(p1 > 0 || p2 > 0) }
```

#### PRISM

```java
// PRISMä¸­çš„Petriç½‘åˆ†æ
public class StochasticPetriNetModel {
    private Map<String, Double> firingRates;
    private Map<String, String> transitions;
    
    public StochasticPetriNetModel() {
        this.firingRates = new HashMap<>();
        this.transitions = new HashMap<>();
    }
    
    public void addTransition(String name, double rate, String guard) {
        firingRates.put(name, rate);
        transitions.put(name, guard);
    }
    
    public String generatePrismModel() {
        StringBuilder model = new StringBuilder();
        model.append("ctmc\n\n");
        
        // æ·»åŠ çŠ¶æ€å˜é‡
        model.append("// State variables\n");
        model.append("formula p1 = 0..10;\n");
        model.append("formula p2 = 0..10;\n\n");
        
        // æ·»åŠ å˜è¿
        model.append("// Transitions\n");
        for (Map.Entry<String, Double> entry : firingRates.entrySet()) {
            String transition = entry.getKey();
            double rate = entry.getValue();
            String guard = transitions.get(transition);
            
            model.append(String.format("[] %s -> %f: (p1'=p1+1) & (p2'=p2-1);\n", 
                                    guard, rate));
        }
        
        return model.toString();
    }
}
```

### 3. å¯è§†åŒ–å·¥å…·

#### Graphviz

```dot
// Graphvizä¸­çš„Petriç½‘å¯è§†åŒ–
digraph PetriNet {
    // åº“æ‰€èŠ‚ç‚¹
    node [shape=circle, style=filled, fillcolor=lightblue];
    p1 [label="P1"];
    p2 [label="P2"];
    p3 [label="P3"];
    
    // å˜è¿èŠ‚ç‚¹
    node [shape=box, style=filled, fillcolor=lightgreen];
    t1 [label="T1"];
    t2 [label="T2"];
    
    // å¼§
    edge [color=red];
    p1 -> t1 [label="1"];
    t1 -> p2 [label="1"];
    p2 -> t2 [label="1"];
    t2 -> p3 [label="1"];
}
```

---

## ğŸ“š å­¦ä¹ è·¯å¾„

### åŸºç¡€é˜¶æ®µ

1. **Petriç½‘åˆ†ææ–¹æ³•åŸºæœ¬æ¦‚å¿µ**
   - å¯è¾¾æ€§åˆ†æ
   - æ´»æ€§åˆ†æ
   - å®‰å…¨æ€§åˆ†æ
   - æ­»é”æ£€æµ‹

2. **åŸºæœ¬å·¥å…·ä½¿ç”¨**
   - Pythonå®ç°
   - Javaå®ç°
   - å¯è§†åŒ–å·¥å…·

3. **ç®€å•åº”ç”¨**
   - å¹¶å‘ç³»ç»Ÿå»ºæ¨¡
   - ç®€å•åè®®éªŒè¯
   - åŸºæœ¬æ€§èƒ½åˆ†æ

### è¿›é˜¶é˜¶æ®µ

1. **é«˜çº§åˆ†ææ–¹æ³•**
   - ä¸å˜é‡åˆ†æ
   - è¦†ç›–æ€§åˆ†æ
   - ç»“æ„åˆ†æ
   - æ€§èƒ½åˆ†æ

2. **å½¢å¼åŒ–éªŒè¯**
   - æ¨¡å‹æ£€æŸ¥
   - æ—¶åºé€»è¾‘
   - æ€§è´¨éªŒè¯

3. **åº”ç”¨å®è·µ**
   - å¤æ‚ç³»ç»Ÿå»ºæ¨¡
   - åè®®éªŒè¯
   - æ€§èƒ½è¯„ä¼°

### é«˜çº§é˜¶æ®µ

1. **ç†è®ºç ”ç©¶**
   - åˆ†æç®—æ³•ä¼˜åŒ–
   - å¤æ‚æ€§åˆ†æ
   - ç†è®ºå‰æ²¿

2. **å·¥å…·å¼€å‘**
   - åˆ†æå·¥å…·å¼€å‘
   - å¯è§†åŒ–å·¥å…·
   - éªŒè¯å·¥å…·

3. **è·¨é¢†åŸŸåº”ç”¨**
   - é‡å­è®¡ç®—åº”ç”¨
   - ç”Ÿç‰©ä¿¡æ¯å­¦åº”ç”¨
   - äººå·¥æ™ºèƒ½åº”ç”¨

---

## ğŸ”— ç›¸å…³é“¾æ¥

- [8.3.1-åŸºç¡€Petriç½‘æ·±åŒ–](8.3.1-åŸºç¡€Petriç½‘æ·±åŒ–.md)
- [8.3.2-é«˜çº§Petriç½‘å˜ç§æ·±åŒ–](8.3.2-é«˜çº§Petriç½‘å˜ç§æ·±åŒ–.md)
- [8.3.4-Petriç½‘åº”ç”¨åœºæ™¯æ·±åŒ–](8.3.4-Petriç½‘åº”ç”¨åœºæ™¯æ·±åŒ–.md)
- [8.3.5-Petriç½‘ä¸å…¶ä»–ç†è®ºäº¤å‰æ·±åŒ–](8.3.5-Petriç½‘ä¸å…¶ä»–ç†è®ºäº¤å‰æ·±åŒ–.md)
- [8.3.6-Petriç½‘å·¥å…·ä¸å®ç°æ·±åŒ–](8.3.6-Petriç½‘å·¥å…·ä¸å®ç°æ·±åŒ–.md)
- [8.2-è‡ªåŠ¨æœºç†è®ºæ·±åŒ–](../8.2-è‡ªåŠ¨æœºç†è®ºæ·±åŒ–/README.md)
- [8.4-æ—¶æ€é€»è¾‘æ§åˆ¶ç†è®ºæ·±åŒ–](../8.4-æ—¶æ€é€»è¾‘æ§åˆ¶ç†è®ºæ·±åŒ–/README.md)

---

**ğŸ“– è¿”å›å¯¼èˆª**:

- [è¿”å›Petriç½‘ç†è®ºæ·±åŒ–å¯¼èˆª](README.md)
- [è¿”å›å½¢å¼ç†è®ºæ·±åŒ–æ€»å¯¼èˆª](../README.md)
