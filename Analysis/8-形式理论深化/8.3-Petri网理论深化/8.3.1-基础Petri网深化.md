# 8.3.1-åŸºç¡€Petriç½‘æ·±åŒ–

## ğŸ“‘ ç›®å½•

- [8.3.1-åŸºç¡€Petriç½‘æ·±åŒ–](#831-åŸºç¡€petriç½‘æ·±åŒ–)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1. æ ¸å¿ƒæ¦‚å¿µ](#11-æ ¸å¿ƒæ¦‚å¿µ)
  - [2. ï¸ æ ¸å¿ƒç†è®ºæ¡†æ¶](#2-ï¸-æ ¸å¿ƒç†è®ºæ¡†æ¶)
    - [2.1. Petriç½‘æ•°å­¦å®šä¹‰](#21-petriç½‘æ•°å­¦å®šä¹‰)
    - [2.2. åŸºæœ¬æ“ä½œ](#22-åŸºæœ¬æ“ä½œ)
      - [2.2.1. å˜è¿è§¦å‘æ¡ä»¶](#221-å˜è¿è§¦å‘æ¡ä»¶)
      - [2.2.2. å¯è¾¾æ€§åˆ†æ](#222-å¯è¾¾æ€§åˆ†æ)
  - [3. é«˜çº§ç†è®ºå‘å±•](#3-é«˜çº§ç†è®ºå‘å±•)
    - [3.1. ä¸å˜é‡åˆ†æ](#31-ä¸å˜é‡åˆ†æ)
      - [3.1.1. P-ä¸å˜é‡](#311-p-ä¸å˜é‡)
      - [3.1.2. T-ä¸å˜é‡](#312-t-ä¸å˜é‡)
  - [4. åº”ç”¨åœºæ™¯ä¸å®ä¾‹](#4-åº”ç”¨åœºæ™¯ä¸å®ä¾‹)
    - [4.1. ç”Ÿäº§è€…-æ¶ˆè´¹è€…ç³»ç»Ÿ](#41-ç”Ÿäº§è€…-æ¶ˆè´¹è€…ç³»ç»Ÿ)
    - [4.2. å“²å­¦å®¶å°±é¤é—®é¢˜](#42-å“²å­¦å®¶å°±é¤é—®é¢˜)
  - [5. ğŸ”— ä¸å…¶ä»–ç†è®ºçš„äº¤å‰](#5--ä¸å…¶ä»–ç†è®ºçš„äº¤å‰)
    - [5.1. ä¸è‡ªåŠ¨æœºç†è®º](#51-ä¸è‡ªåŠ¨æœºç†è®º)
      - [5.1.1. Petriç½‘åˆ°è‡ªåŠ¨æœºçš„è½¬æ¢](#511-petriç½‘åˆ°è‡ªåŠ¨æœºçš„è½¬æ¢)
    - [5.2. ä¸å›¾è®º](#52-ä¸å›¾è®º)
      - [5.2.1. Petriç½‘å›¾ç»“æ„åˆ†æ](#521-petriç½‘å›¾ç»“æ„åˆ†æ)
  - [6. ğŸ› ï¸ å·¥å…·ä¸å®ç°](#6-ï¸-å·¥å…·ä¸å®ç°)
    - [6.1. ç¼–ç¨‹è¯­è¨€æ”¯æŒ](#61-ç¼–ç¨‹è¯­è¨€æ”¯æŒ)
      - [6.1.1. Python](#611-python)
  - [7. Java](#7-java)
  - [8. å­¦ä¹ è·¯å¾„](#8-å­¦ä¹ è·¯å¾„)
    - [8.1. åŸºç¡€é˜¶æ®µ](#81-åŸºç¡€é˜¶æ®µ)
    - [8.2. è¿›é˜¶é˜¶æ®µ](#82-è¿›é˜¶é˜¶æ®µ)
    - [8.3. é«˜çº§é˜¶æ®µ](#83-é«˜çº§é˜¶æ®µ)
  - [9. ğŸ”— ç›¸å…³é“¾æ¥](#9--ç›¸å…³é“¾æ¥)

---


## 1. æ¦‚è¿°

åŸºç¡€Petriç½‘æ·±åŒ–æ˜¯Petriç½‘ç†è®ºçš„æ ¸å¿ƒéƒ¨åˆ†ï¼Œæ¶µç›–äº†Petriç½‘çš„åŸºæœ¬æ¦‚å¿µã€æ•°å­¦å®šä¹‰ã€åŸºæœ¬æ“ä½œå’Œåˆ†ææ–¹æ³•ã€‚
Petriç½‘ä½œä¸ºä¸€ç§å¹¶å‘ç³»ç»Ÿçš„æ•°å­¦å»ºæ¨¡å·¥å…·ï¼Œä¸ºæè¿°å’Œåˆ†æå¹¶å‘ç³»ç»Ÿçš„è¡Œä¸ºæä¾›äº†å¼ºå¤§çš„ç†è®ºåŸºç¡€ã€‚

### 1.1. æ ¸å¿ƒæ¦‚å¿µ

- **åº“æ‰€(Place)**ï¼šè¡¨ç¤ºç³»ç»ŸçŠ¶æ€æˆ–æ¡ä»¶
- **å˜è¿(Transition)**ï¼šè¡¨ç¤ºäº‹ä»¶æˆ–åŠ¨ä½œ
- **æ ‡è®°(Token)**ï¼šè¡¨ç¤ºèµ„æºæˆ–ä¿¡æ¯
- **è§¦å‘(Firing)**ï¼šå˜è¿çš„æ‰§è¡Œè¿‡ç¨‹
- **å¯è¾¾æ€§(Reachability)**ï¼šç³»ç»Ÿå¯èƒ½è¾¾åˆ°çš„çŠ¶æ€

## 2. ï¸ æ ¸å¿ƒç†è®ºæ¡†æ¶

### 2.1. Petriç½‘æ•°å­¦å®šä¹‰

```haskell
-- Petriç½‘çš„åŸºæœ¬æ•°å­¦å®šä¹‰
data PetriNet p t where
  PetriNet :: Set p -> Set t -> (p -> t -> Int) -> (t -> p -> Int) -> Map p Int -> PetriNet p t

-- å‰å‘å’Œåå‘å…³è”çŸ©é˜µ
type PreMatrix p t = p -> t -> Int
type PostMatrix p t = t -> p -> Int

-- æ ‡è®°å‘é‡
type Marking p = Map p Int

-- Petriç½‘å®ä¾‹
instance PetriNet p t where
  places (PetriNet p t pre post m) = p
  transitions (PetriNet p t pre post m) = t
  preMatrix (PetriNet p t pre post m) = pre
  postMatrix (PetriNet p t pre post m) = post
  initialMarking (PetriNet p t pre post m) = m
```

### 2.2. åŸºæœ¬æ“ä½œ

#### 2.2.1. å˜è¿è§¦å‘æ¡ä»¶

```haskell
-- æ£€æŸ¥å˜è¿æ˜¯å¦å¯ä»¥è§¦å‘
canFire :: PetriNet p t -> Marking p -> t -> Bool
canFire (PetriNet places transitions pre post marking) m t =
    all (\p -> m p >= pre p t) places

-- è§¦å‘å˜è¿
fireTransition :: PetriNet p t -> Marking p -> t -> Maybe (Marking p)
fireTransition net m t =
    if canFire net m t
    then Just (newMarking net m t)
    else Nothing

-- è®¡ç®—æ–°æ ‡è®°
newMarking :: PetriNet p t -> Marking p -> t -> Marking p
newMarking (PetriNet places transitions pre post marking) m t =
    Map.fromList [(p, m p - pre p t + post t p) | p <- places]
```

#### 2.2.2. å¯è¾¾æ€§åˆ†æ

```haskell
-- å¯è¾¾æ€§åˆ†æ
reachableMarkings :: PetriNet p t -> Set (Marking p)
reachableMarkings net =
    let initial = initialMarking net
        transitions = transitions net
        -- å¹¿åº¦ä¼˜å…ˆæœç´¢æ‰€æœ‰å¯è¾¾æ ‡è®°
        bfs = breadthFirstSearch initial transitions
    in bfs

-- å¹¿åº¦ä¼˜å…ˆæœç´¢å®ç°
breadthFirstSearch :: Marking p -> Set t -> Set (Marking p)
breadthFirstSearch initial transitions =
    let queue = [initial]
        visited = Set.singleton initial
        -- é€’å½’æœç´¢
        search [] visited = visited
        search (m:ms) visited =
            let nextMarkings = [newM | t <- transitions,
                                     Just newM <- [fireTransition net m t],
                                     not (Set.member newM visited)]
                newVisited = foldr Set.insert visited nextMarkings
                newQueue = ms ++ nextMarkings
            in search newQueue newVisited
    in search queue visited
```

## 3. é«˜çº§ç†è®ºå‘å±•

### 3.1. ä¸å˜é‡åˆ†æ

#### 3.1.1. P-ä¸å˜é‡

```haskell
-- P-ä¸å˜é‡åˆ†æ
pInvariants :: PetriNet p t -> [Vector Int]
pInvariants net =
    let -- æ„å»ºå…³è”çŸ©é˜µ
        incidenceMatrix = buildIncidenceMatrix net
        -- è®¡ç®—P-ä¸å˜é‡
        invariants = computePInvariants incidenceMatrix
    in invariants

-- æ„å»ºå…³è”çŸ©é˜µ
buildIncidenceMatrix :: PetriNet p t -> Matrix Int
buildIncidenceMatrix (PetriNet places transitions pre post marking) =
    let rows = length places
        cols = length transitions
        matrix = [[post t p - pre p t | t <- transitions] | p <- places]
    in matrix

-- è®¡ç®—P-ä¸å˜é‡
computePInvariants :: Matrix Int -> [Vector Int]
computePInvariants matrix =
    let -- ä½¿ç”¨é«˜æ–¯æ¶ˆå…ƒæ³•è®¡ç®—ä¸å˜é‡
        reducedMatrix = gaussianElimination matrix
        invariants = extractInvariants reducedMatrix
    in invariants
```

#### 3.1.2. T-ä¸å˜é‡

```haskell
-- T-ä¸å˜é‡åˆ†æ
tInvariants :: PetriNet p t -> [Vector Int]
tInvariants net =
    let -- æ„å»ºå…³è”çŸ©é˜µçš„è½¬ç½®
        incidenceMatrix = buildIncidenceMatrix net
        transposedMatrix = transpose incidenceMatrix
        -- è®¡ç®—T-ä¸å˜é‡
        invariants = computeTInvariants transposedMatrix
    in invariants

-- è®¡ç®—T-ä¸å˜é‡
computeTInvariants :: Matrix Int -> [Vector Int]
computeTInvariants matrix =
    let -- ä½¿ç”¨é«˜æ–¯æ¶ˆå…ƒæ³•è®¡ç®—ä¸å˜é‡
        reducedMatrix = gaussianElimination matrix
        invariants = extractInvariants reducedMatrix
    in invariants
```

## 4. åº”ç”¨åœºæ™¯ä¸å®ä¾‹

### 4.1. ç”Ÿäº§è€…-æ¶ˆè´¹è€…ç³»ç»Ÿ

```haskell
-- ç”Ÿäº§è€…-æ¶ˆè´¹è€…Petriç½‘
producerConsumerNet :: PetriNet String String
producerConsumerNet =
    let places = ["buffer_empty", "buffer_full", "producer_ready", "consumer_ready"]
        transitions = ["produce", "consume"]
        pre = \p t -> case (p, t) of
            ("buffer_empty", "produce") -> 1
            ("producer_ready", "produce") -> 1
            ("buffer_full", "consume") -> 1
            ("consumer_ready", "consume") -> 1
            _ -> 0
        post = \t p -> case (t, p) of
            ("produce", "buffer_full") -> 1
            ("produce", "producer_ready") -> 1
            ("consume", "buffer_empty") -> 1
            ("consume", "consumer_ready") -> 1
            _ -> 0
        initial = Map.fromList [("buffer_empty", 1), ("producer_ready", 1),
                               ("consumer_ready", 1), ("buffer_full", 0)]
    in PetriNet places transitions pre post initial
```

### 4.2. å“²å­¦å®¶å°±é¤é—®é¢˜

```haskell
-- å“²å­¦å®¶å°±é¤é—®é¢˜Petriç½‘
diningPhilosophersNet :: Int -> PetriNet String String
diningPhilosophersNet n =
    let places = [show i ++ "_thinking" | i <- [1..n]] ++
                 [show i ++ "_hungry" | i <- [1..n]] ++
                 [show i ++ "_eating" | i <- [1..n]] ++
                 [show i ++ "_fork" | i <- [1..n]]
        transitions = ["pickup_" ++ show i | i <- [1..n]] ++
                     ["putdown_" ++ show i | i <- [1..n]]
        pre = \p t -> case (p, t) of
            (philosopher, "pickup_" ++ i) | philosopher == i ++ "_hungry" -> 1
            (fork, "pickup_" ++ i) | fork == i ++ "_fork" -> 1
            (fork, "pickup_" ++ i) | fork == (if i == "1" then show n else show (read i - 1)) ++ "_fork" -> 1
            (philosopher, "putdown_" ++ i) | philosopher == i ++ "_eating" -> 1
            _ -> 0
        post = \t p -> case (t, p) of
            ("pickup_" ++ i, philosopher) | philosopher == i ++ "_eating" -> 1
            ("putdown_" ++ i, philosopher) | philosopher == i ++ "_thinking" -> 1
            ("putdown_" ++ i, fork) | fork == i ++ "_fork" -> 1
            ("putdown_" ++ i, fork) | fork == (if i == "1" then show n else show (read i - 1)) ++ "_fork" -> 1
            _ -> 0
        initial = Map.fromList $
            [(show i ++ "_thinking", 1) | i <- [1..n]] ++
            [(show i ++ "_hungry", 0) | i <- [1..n]] ++
            [(show i ++ "_eating", 0) | i <- [1..n]] ++
            [(show i ++ "_fork", 1) | i <- [1..n]]
    in PetriNet places transitions pre post initial
```

## 5. ğŸ”— ä¸å…¶ä»–ç†è®ºçš„äº¤å‰

### 5.1. ä¸è‡ªåŠ¨æœºç†è®º

#### 5.1.1. Petriç½‘åˆ°è‡ªåŠ¨æœºçš„è½¬æ¢

```haskell
-- Petriç½‘åˆ°è‡ªåŠ¨æœºçš„è½¬æ¢
petriNetToAutomaton :: PetriNet p t -> FiniteAutomaton (Marking p) t
petriNetToAutomaton net =
    let states = reachableMarkings net
        alphabet = transitions net
        start = initialMarking net
        delta = \m t -> case fireTransition net m t of
            Just m' -> m'
            Nothing -> m  -- æ— å®šä¹‰è½¬æ¢
        finals = states  -- æ‰€æœ‰çŠ¶æ€éƒ½æ˜¯æœ€ç»ˆçŠ¶æ€
    in DFA states alphabet start delta finals
```

### 5.2. ä¸å›¾è®º

#### 5.2.1. Petriç½‘å›¾ç»“æ„åˆ†æ

```haskell
-- Petriç½‘çš„å›¾ç»“æ„åˆ†æ
petriNetGraph :: PetriNet p t -> Graph (Either p t)
petriNetGraph (PetriNet places transitions pre post marking) =
    let -- æ„å»ºäºŒåˆ†å›¾
        nodes = map Left places ++ map Right transitions
        edges = [(Left p, Right t) | p <- places, t <- transitions, pre p t > 0] ++
                [(Right t, Left p) | t <- transitions, p <- places, post t p > 0]
    in Graph nodes edges
```

## 6. ğŸ› ï¸ å·¥å…·ä¸å®ç°

### 6.1. ç¼–ç¨‹è¯­è¨€æ”¯æŒ

#### 6.1.1. Python

```python
# Pythonä¸­çš„Petriç½‘å®ç°
import numpy as np
from collections import defaultdict

class PetriNet:
    def __init__(self, places, transitions, pre_matrix, post_matrix, initial_marking):
        self.places = places
        self.transitions = transitions
        self.pre_matrix = pre_matrix
        self.post_matrix = post_matrix
        self.initial_marking = initial_marking

    def can_fire(self, marking, transition):
        """æ£€æŸ¥å˜è¿æ˜¯å¦å¯ä»¥è§¦å‘"""
        for place in self.places:
            if marking[place] < self.pre_matrix[place][transition]:
                return False
        return True

    def fire(self, marking, transition):
        """è§¦å‘å˜è¿"""
        if not self.can_fire(marking, transition):
            return None

        new_marking = marking.copy()
        for place in self.places:
            new_marking[place] = (marking[place] -
                                self.pre_matrix[place][transition] +
                                self.post_matrix[transition][place])
        return new_marking

    def reachable_markings(self):
        """è®¡ç®—æ‰€æœ‰å¯è¾¾æ ‡è®°"""
        reachable = {tuple(self.initial_marking.items())}
        queue = [self.initial_marking]

        while queue:
            current = queue.pop(0)
            for transition in self.transitions:
                new_marking = self.fire(current, transition)
                if new_marking:
                    new_tuple = tuple(new_marking.items())
                    if new_tuple not in reachable:
                        reachable.add(new_tuple)
                        queue.append(new_marking)

        return [dict(marking) for marking in reachable]
```

## 7. Java

```java
// Javaä¸­çš„Petriç½‘å®ç°
import java.util.*;

public class PetriNet {
    private Set<String> places;
    private Set<String> transitions;
    private Map<String, Map<String, Integer>> preMatrix;
    private Map<String, Map<String, Integer>> postMatrix;
    private Map<String, Integer> initialMarking;

    public PetriNet(Set<String> places, Set<String> transitions,
                   Map<String, Map<String, Integer>> preMatrix,
                   Map<String, Map<String, Integer>> postMatrix,
                   Map<String, Integer> initialMarking) {
        this.places = places;
        this.transitions = transitions;
        this.preMatrix = preMatrix;
        this.postMatrix = postMatrix;
        this.initialMarking = initialMarking;
    }

    public boolean canFire(Map<String, Integer> marking, String transition) {
        for (String place : places) {
            int required = preMatrix.get(place).getOrDefault(transition, 0);
            if (marking.getOrDefault(place, 0) < required) {
                return false;
            }
        }
        return true;
    }

    public Map<String, Integer> fire(Map<String, Integer> marking, String transition) {
        if (!canFire(marking, transition)) {
            return null;
        }

        Map<String, Integer> newMarking = new HashMap<>(marking);
        for (String place : places) {
            int preTokens = preMatrix.get(place).getOrDefault(transition, 0);
            int postTokens = postMatrix.get(transition).getOrDefault(place, 0);
            newMarking.put(place, newMarking.getOrDefault(place, 0) - preTokens + postTokens);
        }
        return newMarking;
    }

    public Set<Map<String, Integer>> reachableMarkings() {
        Set<Map<String, Integer>> reachable = new HashSet<>();
        Queue<Map<String, Integer>> queue = new LinkedList<>();

        reachable.add(initialMarking);
        queue.add(initialMarking);

        while (!queue.isEmpty()) {
            Map<String, Integer> current = queue.poll();
            for (String transition : transitions) {
                Map<String, Integer> newMarking = fire(current, transition);
                if (newMarking != null && !reachable.contains(newMarking)) {
                    reachable.add(newMarking);
                    queue.add(newMarking);
                }
            }
        }

        return reachable;
    }
}
```

## 8. å­¦ä¹ è·¯å¾„

### 8.1. åŸºç¡€é˜¶æ®µ

1. **Petriç½‘åŸºæœ¬æ¦‚å¿µ**
   - åº“æ‰€å’Œå˜è¿çš„å®šä¹‰
   - æ ‡è®°å’Œè§¦å‘è§„åˆ™
   - åŸºæœ¬æ“ä½œå’Œæ€§è´¨

2. **Petriç½‘åˆ†ææ–¹æ³•**
   - å¯è¾¾æ€§åˆ†æ
   - ä¸å˜é‡åˆ†æ
   - æ´»æ€§åˆ†æ

3. **åŸºæœ¬åº”ç”¨**
   - å¹¶å‘ç³»ç»Ÿå»ºæ¨¡
   - ç®€å•åè®®éªŒè¯
   - åŸºæœ¬æ€§èƒ½åˆ†æ

### 8.2. è¿›é˜¶é˜¶æ®µ

1. **é«˜çº§åˆ†ææ–¹æ³•**
   - è¦†ç›–æ€§åˆ†æ
   - æ­»é”æ£€æµ‹
   - å¹¶å‘åˆ†æ

2. **Petriç½‘å˜ç§**
   - æ—¶é—´Petriç½‘
   - æ¦‚ç‡Petriç½‘
   - é¢œè‰²Petriç½‘

3. **åº”ç”¨å®è·µ**
   - å¤æ‚ç³»ç»Ÿå»ºæ¨¡
   - åè®®éªŒè¯
   - æ€§èƒ½åˆ†æ

### 8.3. é«˜çº§é˜¶æ®µ

1. **ç†è®ºç ”ç©¶**
   - Petriç½‘ç†è®ºå‰æ²¿
   - åˆ†æç®—æ³•ä¼˜åŒ–
   - å¤æ‚æ€§åˆ†æ

2. **å·¥å…·å¼€å‘**
   - Petriç½‘å¯è§†åŒ–å·¥å…·
   - åˆ†æç®—æ³•å®ç°
   - éªŒè¯å·¥å…·å¼€å‘

3. **è·¨é¢†åŸŸåº”ç”¨**
   - é‡å­è®¡ç®—åº”ç”¨
   - ç”Ÿç‰©ä¿¡æ¯å­¦åº”ç”¨
   - äººå·¥æ™ºèƒ½åº”ç”¨

## 9. ğŸ”— ç›¸å…³é“¾æ¥

- [8.3.2-é«˜çº§Petriç½‘å˜ç§æ·±åŒ–](8.3.2-é«˜çº§Petriç½‘å˜ç§æ·±åŒ–.md)
- [8.3.3-Petriç½‘åˆ†ææ–¹æ³•æ·±åŒ–](8.3.3-Petriç½‘åˆ†ææ–¹æ³•æ·±åŒ–.md)
- [8.3.4-Petriç½‘åº”ç”¨åœºæ™¯æ·±åŒ–](8.3.4-Petriç½‘åº”ç”¨åœºæ™¯æ·±åŒ–.md)
- [8.3.5-Petriç½‘ä¸å…¶ä»–ç†è®ºäº¤å‰æ·±åŒ–](8.3.5-Petriç½‘ä¸å…¶ä»–ç†è®ºäº¤å‰æ·±åŒ–.md)
- [8.3.6-Petriç½‘å·¥å…·ä¸å®ç°æ·±åŒ–](8.3.6-Petriç½‘å·¥å…·ä¸å®ç°æ·±åŒ–.md)
- [8.2-è‡ªåŠ¨æœºç†è®ºæ·±åŒ–](../8.2-è‡ªåŠ¨æœºç†è®ºæ·±åŒ–/README.md)
- [8.4-æ—¶æ€é€»è¾‘æ§åˆ¶ç†è®ºæ·±åŒ–](../8.4-æ—¶æ€é€»è¾‘æ§åˆ¶ç†è®ºæ·±åŒ–/README.md)

---

**ğŸ“– è¿”å›å¯¼èˆª**:

- [è¿”å›Petriç½‘ç†è®ºæ·±åŒ–å¯¼èˆª](README.md)
- [è¿”å›å½¢å¼ç†è®ºæ·±åŒ–æ€»å¯¼èˆª](../README.md)
