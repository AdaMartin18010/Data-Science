# å¤šè¯­è¨€æ”¯æŒæ¡†æ¶ - 2025å¢å¼ºç‰ˆ

## ğŸ“‘ ç›®å½•

- [å¤šè¯­è¨€æ”¯æŒæ¡†æ¶ - 2025å¢å¼ºç‰ˆ](#å¤šè¯­è¨€æ”¯æŒæ¡†æ¶-2025å¢å¼ºç‰ˆ)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
- [1. æ¦‚è¿°](#1-æ¦‚è¿°)
  - [1.1. æ¡†æ¶ç›®æ ‡](#11-æ¡†æ¶ç›®æ ‡)
  - [1.2. æ”¯æŒè¯­è¨€](#12-æ”¯æŒè¯­è¨€)
- [2. æŠ€æœ¯æ¶æ„](#2-æŠ€æœ¯æ¶æ„)
  - [2.1. å¤šè¯­è¨€æ¶æ„è®¾è®¡](#21-å¤šè¯­è¨€æ¶æ„è®¾è®¡)
  - [2.2. æ–‡ä»¶ç»“æ„](#22-æ–‡ä»¶ç»“æ„)
- [3. ç¿»è¯‘ç®¡ç†ç³»ç»Ÿ](#3-ç¿»è¯‘ç®¡ç†ç³»ç»Ÿ)
  - [3.1. ç¿»è¯‘ç®¡ç†å™¨](#31-ç¿»è¯‘ç®¡ç†å™¨)
---


## 1. æ¦‚è¿°

### 1.1. æ¡†æ¶ç›®æ ‡

**ä¸­æ–‡ç›®æ ‡**: å»ºç«‹å®Œæ•´çš„å›½é™…åŒ–å¤šè¯­è¨€æ”¯æŒæ¡†æ¶ï¼Œå®ç°çŸ¥è¯†åº“çš„å…¨çƒåŒ–è®¿é—®å’Œæœ¬åœ°åŒ–ä½“éªŒã€‚

**English Goal**: Establish a comprehensive internationalization and multi-language support framework to enable global access and localized experience for the knowledge base.

### 1.2. æ”¯æŒè¯­è¨€

| è¯­è¨€ | ä»£ç  | å®Œæˆåº¦ | ä¼˜å…ˆçº§ | çŠ¶æ€ |
|------|------|--------|--------|------|
| ä¸­æ–‡ï¼ˆç®€ä½“ï¼‰ | zh-CN | 100% | P0 | âœ… å®Œæˆ |
| è‹±æ–‡ | en-US | 85% | P0 | ğŸ”„ è¿›è¡Œä¸­ |
| æ—¥æ–‡ | ja-JP | 30% | P1 | ğŸ“‹ è®¡åˆ’ä¸­ |
| å¾·æ–‡ | de-DE | 20% | P1 | ğŸ“‹ è®¡åˆ’ä¸­ |
| æ³•æ–‡ | fr-FR | 15% | P2 | ğŸ“‹ è®¡åˆ’ä¸­ |
| è¥¿ç­ç‰™æ–‡ | es-ES | 10% | P2 | ğŸ“‹ è®¡åˆ’ä¸­ |
| éŸ©æ–‡ | ko-KR | 5% | P3 | ğŸ“‹ è®¡åˆ’ä¸­ |

## 2. æŠ€æœ¯æ¶æ„

### 2.1. å¤šè¯­è¨€æ¶æ„è®¾è®¡

```mermaid
graph TB
    A[ç”¨æˆ·è¯·æ±‚] --> B[è¯­è¨€æ£€æµ‹å™¨]
    B --> C[å†…å®¹è·¯ç”±å™¨]
    C --> D[ä¸­æ–‡å†…å®¹]
    C --> E[è‹±æ–‡å†…å®¹]
    C --> F[æ—¥æ–‡å†…å®¹]
    C --> G[å…¶ä»–è¯­è¨€]

    D --> H[å†…å®¹æ¸²æŸ“å™¨]
    E --> H
    F --> H
    G --> H

    H --> I[æœ¬åœ°åŒ–ç•Œé¢]
    I --> J[ç”¨æˆ·ç•Œé¢]
```

### 2.2. æ–‡ä»¶ç»“æ„

```text
Analysis/
â”œâ”€â”€ zh-CN/                    # ä¸­æ–‡å†…å®¹ï¼ˆä¸»è¯­è¨€ï¼‰
â”‚   â”œâ”€â”€ 1-æ•°æ®åº“ç³»ç»Ÿ/
â”‚   â”œâ”€â”€ 2-å½¢å¼ç§‘å­¦ç†è®º/
â”‚   â””â”€â”€ ...
â”œâ”€â”€ en-US/                    # è‹±æ–‡å†…å®¹
â”‚   â”œâ”€â”€ 1-database-systems/
â”‚   â”œâ”€â”€ 2-formal-sciences/
â”‚   â””â”€â”€ ...
â”œâ”€â”€ ja-JP/                    # æ—¥æ–‡å†…å®¹
â”‚   â”œâ”€â”€ 1-ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚·ã‚¹ãƒ†ãƒ /
â”‚   â”œâ”€â”€ 2-å½¢å¼ç§‘å­¦ç†è«–/
â”‚   â””â”€â”€ ...
â”œâ”€â”€ i18n/                     # å›½é™…åŒ–é…ç½®
â”‚   â”œâ”€â”€ translations/
â”‚   â”œâ”€â”€ locale-configs/
â”‚   â””â”€â”€ language-mappings/
â””â”€â”€ tools/                    # ç¿»è¯‘å·¥å…·
    â”œâ”€â”€ translation-manager.py
    â”œâ”€â”€ language-detector.py
    â””â”€â”€ content-synchronizer.py
```

## 3. ç¿»è¯‘ç®¡ç†ç³»ç»Ÿ

### 3.1. ç¿»è¯‘ç®¡ç†å™¨

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
å¤šè¯­è¨€ç¿»è¯‘ç®¡ç†ç³»ç»Ÿ
æ”¯æŒè‡ªåŠ¨ç¿»è¯‘ã€äººå·¥å®¡æ ¸ã€è´¨é‡æ£€æŸ¥
"""

import os
import json
import yaml
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass, asdict
from datetime import datetime
import requests
from pathlib import Path
import logging

@dataclass
class TranslationTask:
    """ç¿»è¯‘ä»»åŠ¡æ•°æ®ç±»"""
    source_file: str
    target_language: str
    target_file: str
    status: str  # pending, in_progress, completed, reviewed
    priority: int
    created_at: datetime
    updated_at: datetime
    translator: Optional[str] = None
    reviewer: Optional[str] = None
    quality_score: Optional[float] = None
    comments: List[str] = None

class TranslationManager:
    """ç¿»è¯‘ç®¡ç†å™¨"""

    def __init__(self, base_path: str = "Analysis"):
        self.base_path = Path(base_path)
        self.supported_languages = {
            'zh-CN': 'ä¸­æ–‡ï¼ˆç®€ä½“ï¼‰',
            'en-US': 'English',
            'ja-JP': 'æ—¥æœ¬èª',
            'de-DE': 'Deutsch',
            'fr-FR': 'FranÃ§ais',
            'es-ES': 'EspaÃ±ol',
            'ko-KR': 'í•œêµ­ì–´'
        }
        self.translation_cache = {}
        self.quality_threshold = 0.8

    def create_translation_tasks(self, source_lang: str = 'zh-CN') -> List[TranslationTask]:
        """åˆ›å»ºç¿»è¯‘ä»»åŠ¡"""

        tasks = []
        source_path = self.base_path / source_lang

# æ‰«ææºè¯­è¨€æ–‡ä»¶
        for md_file in source_path.rglob("*.md"):
            relative_path = md_file.relative_to(source_path)

# ä¸ºæ¯ç§ç›®æ ‡è¯­è¨€åˆ›å»ºç¿»è¯‘ä»»åŠ¡
            for target_lang in self.supported_languages:
                if target_lang == source_lang:
                    continue

                target_file = self.get_target_file_path(relative_path, target_lang)

# æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ç¿»è¯‘
                if not target_file.exists() or self.needs_update(md_file, target_file):
                    task = TranslationTask(
                        source_file=str(md_file),
                        target_language=target_lang,
                        target_file=str(target_file),
                        status='pending',
                        priority=self.calculate_priority(relative_path),
                        created_at=datetime.now(),
                        updated_at=datetime.now()
                    )
                    tasks.append(task)

        return tasks

    def get_target_file_path(self, relative_path: Path, target_lang: str) -> Path:
        """è·å–ç›®æ ‡æ–‡ä»¶è·¯å¾„"""

# è¯­è¨€ç‰¹å®šçš„è·¯å¾„æ˜ å°„
        path_mappings = {
            'en-US': {
                '1-æ•°æ®åº“ç³»ç»Ÿ': '1-database-systems',
                '2-å½¢å¼ç§‘å­¦ç†è®º': '2-formal-sciences',
                '3-æ•°æ®æ¨¡å‹ä¸ç®—æ³•': '3-data-models-algorithms',
                '4-è½¯ä»¶æ¶æ„ä¸å·¥ç¨‹': '4-software-architecture-engineering',
                '5-è¡Œä¸šåº”ç”¨ä¸åœºæ™¯': '5-industry-applications-scenarios',
                '6-çŸ¥è¯†å›¾è°±ä¸å¯è§†åŒ–': '6-knowledge-graphs-visualization',
                '7-æŒç»­é›†æˆä¸æ¼”è¿›': '7-continuous-integration-evolution',
                '8-å½¢å¼ç†è®ºæ·±åŒ–': '8-formal-theory-advanced',
                '9-è½¯ä»¶å·¥ç¨‹æ·±åŒ–': '9-software-engineering-advanced',
                '10-ç¼–ç¨‹è¯­è¨€æ·±åŒ–': '10-programming-languages-advanced'
            },
            'ja-JP': {
                '1-æ•°æ®åº“ç³»ç»Ÿ': '1-ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚·ã‚¹ãƒ†ãƒ ',
                '2-å½¢å¼ç§‘å­¦ç†è®º': '2-å½¢å¼ç§‘å­¦ç†è«–',
                '3-æ•°æ®æ¨¡å‹ä¸ç®—æ³•': '3-ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«ã¨ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ',
                '4-è½¯ä»¶æ¶æ„ä¸å·¥ç¨‹': '4-ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã¨ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ãƒªãƒ³ã‚°',
                '5-è¡Œä¸šåº”ç”¨ä¸åœºæ™¯': '5-æ¥­ç•Œã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¨ã‚·ãƒŠãƒªã‚ª',
                '6-çŸ¥è¯†å›¾è°±ä¸å¯è§†åŒ–': '6-çŸ¥è­˜ã‚°ãƒ©ãƒ•ã¨å¯è¦–åŒ–',
                '7-æŒç»­é›†æˆä¸æ¼”è¿›': '7-ç¶™ç¶šçš„ã‚¤ãƒ³ãƒ†ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã¨é€²åŒ–',
                '8-å½¢å¼ç†è®ºæ·±åŒ–': '8-å½¢å¼ç†è«–ã®æ·±åŒ–',
                '9-è½¯ä»¶å·¥ç¨‹æ·±åŒ–': '9-ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ãƒªãƒ³ã‚°ã®æ·±åŒ–',
                '10-ç¼–ç¨‹è¯­è¨€æ·±åŒ–': '10-ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã®æ·±åŒ–'
            }
        }

# åº”ç”¨è·¯å¾„æ˜ å°„
        path_parts = list(relative_path.parts)
        if target_lang in path_mappings:
            mapping = path_mappings[target_lang]
            if path_parts[0] in mapping:
                path_parts[0] = mapping[path_parts[0]]

        return self.base_path / target_lang / Path(*path_parts)

    def calculate_priority(self, relative_path: Path) -> int:
        """è®¡ç®—ç¿»è¯‘ä¼˜å…ˆçº§"""

# æ ¸å¿ƒæ¨¡å—ä¼˜å…ˆçº§æ›´é«˜
        core_modules = ['1-æ•°æ®åº“ç³»ç»Ÿ', '2-å½¢å¼ç§‘å­¦ç†è®º', '3-æ•°æ®æ¨¡å‹ä¸ç®—æ³•']

        if any(module in str(relative_path) for module in core_modules):
            return 1  # é«˜ä¼˜å…ˆçº§
        elif 'README' in str(relative_path):
            return 2  # ä¸­ä¼˜å…ˆçº§
        else:
            return 3  # ä½ä¼˜å…ˆçº§

    def needs_update(self, source_file: Path, target_file: Path) -> bool:
        """æ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°ç¿»è¯‘"""

        if not target_file.exists():
            return True

# æ¯”è¾ƒæ–‡ä»¶ä¿®æ”¹æ—¶é—´
        source_mtime = source_file.stat().st_mtime
        target_mtime = target_file.stat().st_mtime

        return source_mtime > target_mtime

    def auto_translate(self, task: TranslationTask, use_ai: bool = True) -> str:
        """è‡ªåŠ¨ç¿»è¯‘"""

# è¯»å–æºæ–‡ä»¶
        with open(task.source_file, 'r', encoding='utf-8') as f:
            content = f.read()

        if use_ai:
# ä½¿ç”¨AIç¿»è¯‘
            translated_content = self.ai_translate(content, task.target_language)
        else:
# ä½¿ç”¨ä¼ ç»Ÿç¿»è¯‘API
            translated_content = self.api_translate(content, task.target_language)

        return translated_content

    def ai_translate(self, content: str, target_lang: str) -> str:
        """AIç¿»è¯‘"""

# è¿™é‡Œé›†æˆå®é™…çš„AIç¿»è¯‘æœåŠ¡
# ä¾‹å¦‚ï¼šOpenAI GPTã€Google Translate APIç­‰

# æ¨¡æ‹ŸAIç¿»è¯‘ç»“æœ
        translation_prompts = {
            'en-US': "Translate the following Chinese technical documentation to English, maintaining technical accuracy and professional tone:",
            'ja-JP': "ä»¥ä¸‹ã®ä¸­å›½èªã®æŠ€è¡“æ–‡æ›¸ã‚’æ—¥æœ¬èªã«ç¿»è¨³ã—ã€æŠ€è¡“çš„ç²¾åº¦ã¨å°‚é–€çš„ãªãƒˆãƒ¼ãƒ³ã‚’ç¶­æŒã—ã¦ãã ã•ã„ï¼š",
            'de-DE': "Ãœbersetzen Sie die folgende chinesische technische Dokumentation ins Deutsche und behalten Sie dabei die technische Genauigkeit und den professionellen Ton bei:",
            'fr-FR': "Traduisez la documentation technique chinoise suivante en franÃ§ais en maintenant la prÃ©cision technique et le ton professionnel :"
        }

        prompt = translation_prompts.get(target_lang, "Translate to target language:")

# å®é™…å®ç°ä¸­ä¼šè°ƒç”¨AIæœåŠ¡
# translated = ai_service.translate(content, prompt)

# æ¨¡æ‹Ÿç¿»è¯‘ç»“æœ
        translated = f"[{target_lang}] {content[:100]}..."

        return translated

    def api_translate(self, content: str, target_lang: str) -> str:
        """APIç¿»è¯‘"""

# è¿™é‡Œé›†æˆç¿»è¯‘API
# ä¾‹å¦‚ï¼šGoogle Translateã€ç™¾åº¦ç¿»è¯‘ã€è…¾è®¯ç¿»è¯‘ç­‰

# æ¨¡æ‹ŸAPIç¿»è¯‘ç»“æœ
        return f"[API-{target_lang}] {content[:100]}..."

    def quality_check(self, original: str, translated: str) -> float:
        """ç¿»è¯‘è´¨é‡æ£€æŸ¥"""

# åŸºç¡€è´¨é‡æ£€æŸ¥
        quality_score = 0.0

# é•¿åº¦æ£€æŸ¥
        if len(translated) > len(original) * 0.5:
            quality_score += 0.2

# æ ¼å¼ä¿æŒæ£€æŸ¥
        if self.check_format_preservation(original, translated):
            quality_score += 0.3

# é“¾æ¥ä¿æŒæ£€æŸ¥
        if self.check_link_preservation(original, translated):
            quality_score += 0.2

# ä»£ç å—ä¿æŒæ£€æŸ¥
        if self.check_code_preservation(original, translated):
            quality_score += 0.3

        return quality_score

    def check_format_preservation(self, original: str, translated: str) -> bool:
        """æ£€æŸ¥æ ¼å¼ä¿æŒ"""

# æ£€æŸ¥Markdownæ ¼å¼
        original_headers = len(re.findall(r'^#+', original, re.MULTILINE))
        translated_headers = len(re.findall(r'^#+', translated, re.MULTILINE))

        return abs(original_headers - translated_headers) <= 1

    def check_link_preservation(self, original: str, translated: str) -> bool:
        """æ£€æŸ¥é“¾æ¥ä¿æŒ"""

        original_links = len(re.findall(r'\[.*?\]\(.*?\)', original))
        translated_links = len(re.findall(r'\[.*?\]\(.*?\)', translated))

        return original_links == translated_links

    def check_code_preservation(self, original: str, translated: str) -> bool:
        """æ£€æŸ¥ä»£ç å—ä¿æŒ"""

        original_code_blocks = len(re.findall(r'```', original))
        translated_code_blocks = len(re.findall(r'```', translated))

        return original_code_blocks == translated_code_blocks

    def save_translation(self, task: TranslationTask, content: str):
        """ä¿å­˜ç¿»è¯‘"""

# åˆ›å»ºç›®æ ‡ç›®å½•
        target_path = Path(task.target_file)
        target_path.parent.mkdir(parents=True, exist_ok=True)

# ä¿å­˜ç¿»è¯‘å†…å®¹
        with open(target_path, 'w', encoding='utf-8') as f:
            f.write(content)

# æ›´æ–°ä»»åŠ¡çŠ¶æ€
        task.status = 'completed'
        task.updated_at = datetime.now()

# è®°å½•ç¿»è¯‘å†å²
        self.record_translation_history(task, content)

    def record_translation_history(self, task: TranslationTask, content: str):
        """è®°å½•ç¿»è¯‘å†å²"""

        history_file = self.base_path / 'i18n' / 'translation-history.json'
        history_file.parent.mkdir(parents=True, exist_ok=True)

        history_entry = {
            'task_id': f"{task.source_file}_{task.target_language}",
            'source_file': task.source_file,
            'target_language': task.target_language,
            'target_file': task.target_file,
            'translated_at': datetime.now().isoformat(),
            'content_length': len(content),
            'quality_score': task.quality_score
        }

# è¯»å–ç°æœ‰å†å²
        if history_file.exists():
            with open(history_file, 'r', encoding='utf-8') as f:
                history = json.load(f)
        else:
            history = []

# æ·»åŠ æ–°è®°å½•
        history.append(history_entry)

# ä¿å­˜å†å²
        with open(history_file, 'w', encoding='utf-8') as f:
            json.dump(history, f, ensure_ascii=False, indent=2)

class LanguageDetector:
    """è¯­è¨€æ£€æµ‹å™¨"""

    def __init__(self):
        self.language_patterns = {
            'zh-CN': [r'[\u4e00-\u9fff]', r'æ•°æ®åº“', r'æŸ¥è¯¢', r'ä¼˜åŒ–'],
            'en-US': [r'\bthe\b', r'\band\b', r'\bof\b', r'\bin\b'],
            'ja-JP': [r'[\u3040-\u309f]', r'[\u30a0-\u30ff]', r'ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹'],
            'de-DE': [r'\bder\b', r'\bdas\b', r'\bdie\b', r'\bund\b'],
            'fr-FR': [r'\ble\b', r'\bla\b', r'\bde\b', r'\bet\b'],
            'es-ES': [r'\bel\b', r'\bla\b', r'\bde\b', r'\by\b'],
            'ko-KR': [r'[\uac00-\ud7af]', r'ë°ì´í„°ë² ì´ìŠ¤']
        }

    def detect_language(self, content: str) -> str:
        """æ£€æµ‹å†…å®¹è¯­è¨€"""

        scores = {}

        for lang, patterns in self.language_patterns.items():
            score = 0
            for pattern in patterns:
                matches = len(re.findall(pattern, content, re.IGNORECASE))
                score += matches

            scores[lang] = score

# è¿”å›å¾—åˆ†æœ€é«˜çš„è¯­è¨€
        return max(scores, key=scores.get) if scores else 'zh-CN'

class ContentSynchronizer:
    """å†…å®¹åŒæ­¥å™¨"""

    def __init__(self, translation_manager: TranslationManager):
        self.translation_manager = translation_manager
        self.sync_rules = self.load_sync_rules()

    def load_sync_rules(self) -> Dict[str, Any]:
        """åŠ è½½åŒæ­¥è§„åˆ™"""

        return {
            'auto_sync': True,
            'sync_interval': 24,  # å°æ—¶
            'priority_files': ['README.md', 'index.md'],
            'exclude_patterns': ['*.tmp', '*.bak'],
            'quality_threshold': 0.8
        }

    def sync_content(self, source_lang: str = 'zh-CN'):
        """åŒæ­¥å†…å®¹"""

        logger.info(f"å¼€å§‹åŒæ­¥ {source_lang} å†…å®¹åˆ°å…¶ä»–è¯­è¨€")

# åˆ›å»ºç¿»è¯‘ä»»åŠ¡
        tasks = self.translation_manager.create_translation_tasks(source_lang)

# æŒ‰ä¼˜å…ˆçº§æ’åº
        tasks.sort(key=lambda x: x.priority)

# æ‰§è¡Œç¿»è¯‘
        for task in tasks:
            try:
                logger.info(f"ç¿»è¯‘ä»»åŠ¡: {task.source_file} -> {task.target_language}")

# è‡ªåŠ¨ç¿»è¯‘
                translated_content = self.translation_manager.auto_translate(task)

# è´¨é‡æ£€æŸ¥
                with open(task.source_file, 'r', encoding='utf-8') as f:
                    original_content = f.read()

                quality_score = self.translation_manager.quality_check(
                    original_content, translated_content
                )
                task.quality_score = quality_score

# ä¿å­˜ç¿»è¯‘
                if quality_score >= self.sync_rules['quality_threshold']:
                    self.translation_manager.save_translation(task, translated_content)
                    logger.info(f"ç¿»è¯‘å®Œæˆï¼Œè´¨é‡åˆ†æ•°: {quality_score:.2f}")
                else:
                    logger.warning(f"ç¿»è¯‘è´¨é‡ä¸è¶³ï¼Œéœ€è¦äººå·¥å®¡æ ¸: {quality_score:.2f}")
                    task.status = 'needs_review'

            except Exception as e:
                logger.error(f"ç¿»è¯‘ä»»åŠ¡å¤±è´¥: {e}")
                task.status = 'failed'

        logger.info("å†…å®¹åŒæ­¥å®Œæˆ")

def main():
    """ä¸»å‡½æ•°"""

# åˆ›å»ºç¿»è¯‘ç®¡ç†å™¨
    translation_manager = TranslationManager()

# åˆ›å»ºå†…å®¹åŒæ­¥å™¨
    synchronizer = ContentSynchronizer(translation_manager)

# æ‰§è¡Œå†…å®¹åŒæ­¥
    synchronizer.sync_content('zh-CN')

    print("å¤šè¯­è¨€æ”¯æŒæ¡†æ¶åˆå§‹åŒ–å®Œæˆï¼")

if __name__ == "__main__":
    main()
