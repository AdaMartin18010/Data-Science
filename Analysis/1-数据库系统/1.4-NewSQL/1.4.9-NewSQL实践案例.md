# 1.4.9 NewSQLå®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [1.4.9 NewSQLå®è·µæ¡ˆä¾‹](#149-newsqlå®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2. ç›®å½•](#2-ç›®å½•)
  - [3. TiDBå®è·µæ¡ˆä¾‹](#3-tidbå®è·µæ¡ˆä¾‹)
    - [3.1. TiDBé›†ç¾¤é…ç½®](#31-tidbé›†ç¾¤é…ç½®)
  - [4. TiDBæ•°æ®æ¨¡å‹è®¾è®¡](#4-tidbæ•°æ®æ¨¡å‹è®¾è®¡)
    - [4.1. TiDBäº‹åŠ¡å¤„ç†](#41-tidbäº‹åŠ¡å¤„ç†)
  - [5. CockroachDBå®è·µæ¡ˆä¾‹](#5-cockroachdbå®è·µæ¡ˆä¾‹)
    - [5.1. CockroachDBå¤šåŒºåŸŸé…ç½®](#51-cockroachdbå¤šåŒºåŸŸé…ç½®)
    - [5.2. CockroachDBäº‹åŠ¡å¤„ç†](#52-cockroachdbäº‹åŠ¡å¤„ç†)
  - [6. åˆ†å¸ƒå¼äº‹åŠ¡å®è·µæ¡ˆä¾‹](#6-åˆ†å¸ƒå¼äº‹åŠ¡å®è·µæ¡ˆä¾‹)
    - [6.1. ä¸¤é˜¶æ®µæäº¤å®ç°](#61-ä¸¤é˜¶æ®µæäº¤å®ç°)
  - [7. æ€§èƒ½ä¼˜åŒ–å®è·µæ¡ˆä¾‹](#7-æ€§èƒ½ä¼˜åŒ–å®è·µæ¡ˆä¾‹)
    - [7.1. è¯»å†™åˆ†ç¦»é…ç½®](#71-è¯»å†™åˆ†ç¦»é…ç½®)
  - [8. è¿æ¥æ± å’Œç¼“å­˜ä¼˜åŒ–](#8-è¿æ¥æ± å’Œç¼“å­˜ä¼˜åŒ–)
  - [9. æ€»ç»“](#9-æ€»ç»“)

---


## 1. æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›NewSQLæ•°æ®åº“ç³»ç»Ÿçš„å®é™…åº”ç”¨æ¡ˆä¾‹ï¼Œæ¶µç›–TiDBã€CockroachDBã€YugabyteDBç­‰ä¸»æµNewSQLæ•°æ®åº“çš„è®¾è®¡æ¨¡å¼ã€åˆ†å¸ƒå¼äº‹åŠ¡ã€æ€§èƒ½ä¼˜åŒ–ç­‰æ ¸å¿ƒä¸»é¢˜ã€‚

## 2. ç›®å½•

- [1.4.9 NewSQLå®è·µæ¡ˆä¾‹](#149-newsqlå®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2. ç›®å½•](#2-ç›®å½•)
  - [3. TiDBå®è·µæ¡ˆä¾‹](#3-tidbå®è·µæ¡ˆä¾‹)
    - [3.1. TiDBé›†ç¾¤é…ç½®](#31-tidbé›†ç¾¤é…ç½®)
  - [4. TiDBæ•°æ®æ¨¡å‹è®¾è®¡](#4-tidbæ•°æ®æ¨¡å‹è®¾è®¡)
    - [4.1. TiDBäº‹åŠ¡å¤„ç†](#41-tidbäº‹åŠ¡å¤„ç†)
  - [5. CockroachDBå®è·µæ¡ˆä¾‹](#5-cockroachdbå®è·µæ¡ˆä¾‹)
    - [5.1. CockroachDBå¤šåŒºåŸŸé…ç½®](#51-cockroachdbå¤šåŒºåŸŸé…ç½®)
    - [5.2. CockroachDBäº‹åŠ¡å¤„ç†](#52-cockroachdbäº‹åŠ¡å¤„ç†)
  - [6. åˆ†å¸ƒå¼äº‹åŠ¡å®è·µæ¡ˆä¾‹](#6-åˆ†å¸ƒå¼äº‹åŠ¡å®è·µæ¡ˆä¾‹)
    - [6.1. ä¸¤é˜¶æ®µæäº¤å®ç°](#61-ä¸¤é˜¶æ®µæäº¤å®ç°)
  - [7. æ€§èƒ½ä¼˜åŒ–å®è·µæ¡ˆä¾‹](#7-æ€§èƒ½ä¼˜åŒ–å®è·µæ¡ˆä¾‹)
    - [7.1. è¯»å†™åˆ†ç¦»é…ç½®](#71-è¯»å†™åˆ†ç¦»é…ç½®)
  - [8. è¿æ¥æ± å’Œç¼“å­˜ä¼˜åŒ–](#8-è¿æ¥æ± å’Œç¼“å­˜ä¼˜åŒ–)
  - [9. æ€»ç»“](#9-æ€»ç»“)

## 3. TiDBå®è·µæ¡ˆä¾‹

### 3.1. TiDBé›†ç¾¤é…ç½®

```yaml
# tidb-cluster.yaml
apiVersion: pingcap.com/v1alpha1
kind: TidbCluster
metadata:
  name: tidb-cluster
spec:
  version: v6.5.0
  pd:
    replicas: 3
    requests:
      storage: "10Gi"
      cpu: 1000m
      memory: 2Gi
  tikv:
    replicas: 3
    requests:
      storage: "100Gi"
      cpu: 2000m
      memory: 4Gi
  tidb:
    replicas: 2
    requests:
      cpu: 1000m
      memory: 2Gi
```

## 4. TiDBæ•°æ®æ¨¡å‹è®¾è®¡

```sql
-- åˆ›å»ºåˆ†åŒºè¡¨
CREATE TABLE users (
    user_id BIGINT PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    status ENUM('active', 'inactive') DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) PARTITION BY RANGE (user_id) (
    PARTITION p0 VALUES LESS THAN (1000000),
    PARTITION p1 VALUES LESS THAN (2000000),
    PARTITION p2 VALUES LESS THAN MAXVALUE
);

-- åˆ›å»ºè®¢å•è¡¨ï¼ˆæŒ‰æ—¶é—´åˆ†åŒºï¼‰
CREATE TABLE orders (
    order_id BIGINT PRIMARY KEY,
    user_id BIGINT NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    status ENUM('pending', 'paid', 'shipped') DEFAULT 'pending',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_user (user_id),
    INDEX idx_status (status)
) PARTITION BY RANGE (TO_DAYS(created_at)) (
    PARTITION p202401 VALUES LESS THAN (TO_DAYS('2024-02-01')),
    PARTITION p202402 VALUES LESS THAN (TO_DAYS('2024-03-01')),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

### 4.1. TiDBäº‹åŠ¡å¤„ç†

```python
import pymysql
from contextlib import contextmanager

class TiDBManager:
    def __init__(self, host, port, user, password, database):
        self.connection_params = {
            'host': host, 'port': port, 'user': user,
            'password': password, 'database': database,
            'autocommit': False
        }

    @contextmanager
    def transaction(self):
        conn = None
        try:
            conn = pymysql.connect(**self.connection_params)
            cursor = conn.cursor()
            yield cursor
            conn.commit()
        except Exception as e:
            if conn:
                conn.rollback()
            raise
        finally:
            if conn:
                conn.close()

    def create_order(self, user_id, items, total_amount):
        with self.transaction() as cursor:
# åˆ›å»ºè®¢å•
            cursor.execute("""
                INSERT INTO orders (user_id, total_amount)
                VALUES (%s, %s)
            """, (user_id, total_amount))

            order_id = cursor.lastrowid

# åˆ›å»ºè®¢å•é¡¹
            for item in items:
                cursor.execute("""
                    INSERT INTO order_items (order_id, product_id, quantity, price)
                    VALUES (%s, %s, %s, %s)
                """, (order_id, item['product_id'], item['quantity'], item['price']))

            return order_id

# ä½¿ç”¨ç¤ºä¾‹
tidb = TiDBManager('localhost', 4000, 'root', '', 'ecommerce')
order_id = tidb.create_order(1001, [
    {'product_id': 2001, 'quantity': 2, 'price': 100.00}
], 200.00)
```

## 5. CockroachDBå®è·µæ¡ˆä¾‹

### 5.1. CockroachDBå¤šåŒºåŸŸé…ç½®

```sql
-- è®¾ç½®å¤šåŒºåŸŸ
ALTER DATABASE ecommerce SET PRIMARY REGION "us-east1";
ALTER DATABASE ecommerce ADD REGION "us-west1";

-- åˆ›å»ºå…¨å±€è¡¨
CREATE TABLE users (
    user_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) LOCALITY GLOBAL;

-- åˆ›å»ºåŒºåŸŸè¡¨
CREATE TABLE orders (
    order_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    status VARCHAR(20) DEFAULT 'pending',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(user_id)
) LOCALITY REGIONAL BY TABLE IN PRIMARY REGION;
```

### 5.2. CockroachDBäº‹åŠ¡å¤„ç†

```python
import psycopg2
from contextlib import contextmanager
import uuid

class CockroachDBManager:
    def __init__(self, host, port, user, password, database):
        self.connection_params = {
            'host': host, 'port': port, 'user': user,
            'password': password, 'database': database
        }

    @contextmanager
    def transaction(self):
        conn = None
        try:
            conn = psycopg2.connect(**self.connection_params)
            conn.autocommit = False
            cursor = conn.cursor()
            yield cursor
            conn.commit()
        except Exception as e:
            if conn:
                conn.rollback()
            raise
        finally:
            if conn:
                conn.close()

    def create_user_with_order(self, username, email, order_items):
        with self.transaction() as cursor:
# åˆ›å»ºç”¨æˆ·
            user_id = str(uuid.uuid4())
            cursor.execute("""
                INSERT INTO users (user_id, username, email)
                VALUES (%s, %s, %s)
            """, (user_id, username, email))

# åˆ›å»ºè®¢å•
            order_id = str(uuid.uuid4())
            total_amount = sum(item['price'] * item['quantity'] for item in order_items)

            cursor.execute("""
                INSERT INTO orders (order_id, user_id, total_amount)
                VALUES (%s, %s, %s)
            """, (order_id, user_id, total_amount))

            return user_id, order_id

# ä½¿ç”¨ç¤ºä¾‹
crdb = CockroachDBManager('localhost', 26257, 'root', '', 'ecommerce')
user_id, order_id = crdb.create_user_with_order(
    'testuser', 'test@example.com',
    [{'price': 100.00, 'quantity': 2}]
)
```

## 6. åˆ†å¸ƒå¼äº‹åŠ¡å®è·µæ¡ˆä¾‹

### 6.1. ä¸¤é˜¶æ®µæäº¤å®ç°

```python
from enum import Enum
import uuid
import time

class TransactionStatus(Enum):
    PREPARING = "preparing"
    PREPARED = "prepared"
    COMMITTED = "committed"
    ABORTED = "aborted"

class TwoPhaseCommitCoordinator:
    def __init__(self):
        self.transactions = {}

    def begin_transaction(self):
        transaction_id = str(uuid.uuid4())
        self.transactions[transaction_id] = {
            'status': TransactionStatus.PREPARING,
            'participants': []
        }
        return transaction_id

    def add_participant(self, transaction_id, participant_id, prepare_func, commit_func, rollback_func):
        self.transactions[transaction_id]['participants'].append({
            'id': participant_id,
            'prepare_func': prepare_func,
            'commit_func': commit_func,
            'rollback_func': rollback_func,
            'prepared': False
        })

    def prepare(self, transaction_id):
        transaction = self.transactions[transaction_id]

        for participant in transaction['participants']:
            try:
                if participant['prepare_func']():
                    participant['prepared'] = True
                else:
                    return False
            except Exception:
                return False

        transaction['status'] = TransactionStatus.PREPARED
        return True

    def commit(self, transaction_id):
        transaction = self.transactions[transaction_id]

        for participant in transaction['participants']:
            if participant['prepared']:
                try:
                    if not participant['commit_func']():
                        self.rollback(transaction_id)
                        return False
                except Exception:
                    self.rollback(transaction_id)
                    return False

        transaction['status'] = TransactionStatus.COMMITTED
        return True

    def rollback(self, transaction_id):
        transaction = self.transactions[transaction_id]
        transaction['status'] = TransactionStatus.ABORTED

        for participant in transaction['participants']:
            if participant['prepared']:
                try:
                    participant['rollback_func']()
                except Exception:
                    pass

# ä½¿ç”¨ç¤ºä¾‹
coordinator = TwoPhaseCommitCoordinator()

def create_order_distributed(user_id, items):
    transaction_id = coordinator.begin_transaction()

# æ·»åŠ å‚ä¸è€…
    coordinator.add_participant(
        transaction_id, 'inventory',
        lambda: prepare_inventory(items),
        lambda: commit_inventory(items),
        lambda: rollback_inventory(items)
    )

    coordinator.add_participant(
        transaction_id, 'payment',
        lambda: prepare_payment(user_id, sum(item['price'] * item['quantity'] for item in items)),
        lambda: commit_payment(user_id),
        lambda: rollback_payment(user_id)
    )

# æ‰§è¡Œä¸¤é˜¶æ®µæäº¤
    if coordinator.prepare(transaction_id):
        return coordinator.commit(transaction_id)
    return False
```

## 7. æ€§èƒ½ä¼˜åŒ–å®è·µæ¡ˆä¾‹

### 7.1. è¯»å†™åˆ†ç¦»é…ç½®

```python
import psycopg2
import random

class ReadWriteSplitManager:
    def __init__(self, master_config, slave_configs):
        self.master_config = master_config
        self.slave_configs = slave_configs

    def get_master_connection(self):
        return psycopg2.connect(**self.master_config)

    def get_slave_connection(self):
        slave_config = random.choice(self.slave_configs)
        return psycopg2.connect(**slave_config)

    def execute_write(self, sql, params=None):
        conn = self.get_master_connection()
        try:
            cursor = conn.cursor()
            cursor.execute(sql, params)
            result = cursor.fetchall() if cursor.description else None
            conn.commit()
            return result
        finally:
            conn.close()

    def execute_read(self, sql, params=None):
        conn = self.get_slave_connection()
        try:
            cursor = conn.cursor()
            cursor.execute(sql, params)
            return cursor.fetchall()
        finally:
            conn.close()

# ä½¿ç”¨ç¤ºä¾‹
rw_manager = ReadWriteSplitManager(
    master_config={'host': 'master', 'port': 26257, 'user': 'root', 'database': 'ecommerce'},
    slave_configs=[
        {'host': 'slave1', 'port': 26257, 'user': 'root', 'database': 'ecommerce'},
        {'host': 'slave2', 'port': 26257, 'user': 'root', 'database': 'ecommerce'}
    ]
)

# å†™æ“ä½œ
rw_manager.execute_write("INSERT INTO users (username, email) VALUES (%s, %s)", ('user1', 'user1@example.com'))

# è¯»æ“ä½œ
results = rw_manager.execute_read("SELECT * FROM users WHERE status = %s", ('active',))
```

## 8. è¿æ¥æ± å’Œç¼“å­˜ä¼˜åŒ–

```python
import redis
import json
from functools import wraps

class NewSQLOptimizer:
    def __init__(self, db_manager, redis_config):
        self.db_manager = db_manager
        self.redis_client = redis.Redis(**redis_config)

    def cache_result(self, ttl=3600):
        def decorator(func):
            @wraps(func)
            def wrapper(*args, **kwargs):
                cache_key = f"{func.__name__}:{hash(str(args) + str(sorted(kwargs.items())))}"

                cached_result = self.redis_client.get(cache_key)
                if cached_result:
                    return json.loads(cached_result)

                result = func(*args, **kwargs)
                self.redis_client.setex(cache_key, ttl, json.dumps(result))
                return result
            return wrapper
        return decorator

    @cache_result(ttl=1800)
    def get_user_profile(self, user_id):
        return self.db_manager.execute_read(
            "SELECT * FROM users WHERE user_id = %s", (user_id,)
        )

    def batch_insert(self, table, data_list):
        if not data_list:
            return

        columns = list(data_list[0].keys())
        placeholders = ','.join(['%s'] * len(columns))
        sql = f"INSERT INTO {table} ({','.join(columns)}) VALUES ({placeholders})"

        values = [tuple(data[col] for col in columns) for data in data_list]
        return self.db_manager.execute_write(sql, values)

# ä½¿ç”¨ç¤ºä¾‹
optimizer = NewSQLOptimizer(
    db_manager=rw_manager,
    redis_config={'host': 'localhost', 'port': 6379, 'db': 0}
)

# æ‰¹é‡æ’å…¥
users_data = [
    {'username': 'user1', 'email': 'user1@example.com'},
    {'username': 'user2', 'email': 'user2@example.com'}
]
optimizer.batch_insert('users', users_data)
```

## 9. æ€»ç»“

è¿™äº›å®è·µæ¡ˆä¾‹å±•ç¤ºäº†NewSQLæ•°æ®åº“ç³»ç»Ÿçš„æ ¸å¿ƒåº”ç”¨åœºæ™¯ï¼ŒåŒ…æ‹¬ï¼š

1. **TiDB**ï¼šåˆ†å¸ƒå¼SQLæ•°æ®åº“ï¼Œæ”¯æŒMySQLå…¼å®¹æ€§
2. **CockroachDB**ï¼šå…¨çƒåˆ†å¸ƒå¼æ•°æ®åº“ï¼Œæ”¯æŒå¤šåŒºåŸŸéƒ¨ç½²
3. **åˆ†å¸ƒå¼äº‹åŠ¡**ï¼šä¸¤é˜¶æ®µæäº¤ï¼ˆ2PCï¼‰å®ç°
4. **æ€§èƒ½ä¼˜åŒ–**ï¼šè¯»å†™åˆ†ç¦»ã€è¿æ¥æ± ã€ç¼“å­˜ä¼˜åŒ–

æ¯ä¸ªæ¡ˆä¾‹éƒ½æä¾›äº†å®Œæ•´çš„ä»£ç ç¤ºä¾‹å’Œæœ€ä½³å®è·µï¼Œå¯ä»¥ç›´æ¥åº”ç”¨äºå®é™…é¡¹ç›®ä¸­ã€‚

**ç›¸å…³é“¾æ¥ï¼š**

- [1.4.1-å½¢å¼æ¨¡å‹](1.4.1-å½¢å¼æ¨¡å‹.md)
- [1.4.2-ç³»ç»Ÿæ¶æ„](1.4.2-ç³»ç»Ÿæ¶æ„.md)
- [1.4.3-æ•°æ®æ¨¡å‹](1.4.3-æ•°æ®æ¨¡å‹.md)
- [1.4.4-åˆ†å¸ƒå¼äº‹åŠ¡ä¸ä¸€è‡´æ€§](1.4.4-åˆ†å¸ƒå¼äº‹åŠ¡ä¸ä¸€è‡´æ€§.md)
- [1.4.5-OLAP_OLTPèåˆ](1.4.5-OLAP_OLTPèåˆ.md)
- [1.4.6-æ€§èƒ½è°ƒä¼˜ä¸ç›‘æ§](1.4.6-æ€§èƒ½è°ƒä¼˜ä¸ç›‘æ§.md)
- [1.4.7-å®‰å…¨ä¸åˆè§„](1.4.7-å®‰å…¨ä¸åˆè§„.md)
- [1.4.8-äº‘åŸç”Ÿä¸å®¹å™¨åŒ–éƒ¨ç½²](1.4.8-äº‘åŸç”Ÿä¸å®¹å™¨åŒ–éƒ¨ç½².md)
