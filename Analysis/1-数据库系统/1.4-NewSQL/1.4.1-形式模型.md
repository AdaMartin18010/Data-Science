# 1.4.1 NewSQL形式模型

## 📑 目录

- [1.4.1 NewSQL形式模型](#141-newsql形式模型)
  - [📑 目录](#-目录)
  - [1. 概述](#1-概述)
    - [1.1. 形式模型定义](#11-形式模型定义)
    - [1.2. NewSQL形式化特征](#12-newsql形式化特征)
  - [2. 关系模型与分布式扩展](#2-关系模型与分布式扩展)
    - [2.1. 关系模型基础](#21-关系模型基础)
      - [2.1.1. 关系模型定义](#211-关系模型定义)
      - [2.1.2. 关系代数](#212-关系代数)
    - [2.2. 分布式扩展](#22-分布式扩展)
      - [2.2.1. 分布式关系模型](#221-分布式关系模型)
      - [2.2.2. 分片策略](#222-分片策略)
    - [2.3. 分布式表模型](#23-分布式表模型)
      - [2.3.1. 分布式表定义](#231-分布式表定义)
      - [2.3.2. 分片函数](#232-分片函数)
    - [2.4. 分区表模型](#24-分区表模型)
      - [2.4.1. 分区定义](#241-分区定义)
      - [2.4.2. 分区策略](#242-分区策略)
    - [2.5. 全局索引模型](#25-全局索引模型)
      - [2.5.1. 全局索引定义](#251-全局索引定义)
      - [2.5.2. 索引类型](#252-索引类型)
  - [3. 一致性协议](#3-一致性协议)
    - [3.1. Paxos协议](#31-paxos协议)
      - [3.1.1. Paxos基础](#311-paxos基础)
      - [3.1.2. Paxos算法](#312-paxos算法)
    - [3.2. Raft协议](#32-raft协议)
      - [3.2.1. Raft基础](#321-raft基础)
      - [3.2.2. Raft算法](#322-raft算法)
    - [3.3. 两阶段提交（2PC）](#33-两阶段提交2pc)
      - [3.3.1. 2PC算法](#331-2pc算法)
      - [3.3.2. 2PC实现](#332-2pc实现)
    - [3.4. 三阶段提交（3PC）](#34-三阶段提交3pc)
      - [3.4.1. 3PC算法](#341-3pc算法)
  - [4. 事务模型](#4-事务模型)
    - [4.1. ACID属性](#41-acid属性)
      - [4.1.1. ACID定义](#411-acid定义)
      - [4.1.2. 原子性](#412-原子性)
    - [4.2. 分布式事务模型](#42-分布式事务模型)
      - [4.2.1. 分布式事务定义](#421-分布式事务定义)
    - [4.3. 隔离级别](#43-隔离级别)
      - [4.3.1. 隔离级别定义](#431-隔离级别定义)
  - [5. 数据一致性模型](#5-数据一致性模型)
    - [5.1. 强一致性](#51-强一致性)
      - [5.1.1. 强一致性定义](#511-强一致性定义)
    - [5.2. 最终一致性](#52-最终一致性)
      - [5.2.1. 最终一致性定义](#521-最终一致性定义)
    - [5.3. 因果一致性](#53-因果一致性)
      - [5.3.1. 因果一致性定义](#531-因果一致性定义)
  - [6. 形式化定义与证明](#6-形式化定义与证明)
    - [6.1. 关系模型形式化](#61-关系模型形式化)
      - [6.1.1. 关系代数完备性](#611-关系代数完备性)
    - [6.2. 一致性协议形式化](#62-一致性协议形式化)
      - [6.2.1. Paxos安全性](#621-paxos安全性)
    - [6.3. 事务模型形式化](#63-事务模型形式化)
      - [6.3.1. 可串行化定理](#631-可串行化定理)
  - [7. 实际系统实现](#7-实际系统实现)
    - [7.1. TiDB形式模型](#71-tidb形式模型)
    - [7.2. CockroachDB形式模型](#72-cockroachdb形式模型)
    - [7.3. OceanBase形式模型](#73-oceanbase形式模型)
  - [8. 多表征](#8-多表征)
  - [9. 总结与展望](#9-总结与展望)
    - [9.1. 总结](#91-总结)
    - [9.2. 发展趋势](#92-发展趋势)

---

## 1. 概述

### 1.1. 形式模型定义

**形式模型（Formal Model）**是使用数学符号和逻辑规则精确描述系统行为的模型。

**NewSQL形式模型的核心要素**：

1. **数据模型**：关系模型的分布式扩展
2. **一致性模型**：分布式一致性协议
3. **事务模型**：分布式事务处理
4. **查询模型**：分布式查询处理

### 1.2. NewSQL形式化特征

**NewSQL形式化特征**：

1. **关系模型兼容**：保持SQL和关系模型语义
2. **分布式扩展**：支持分布式表和分区
3. **强一致性**：通过一致性协议保证
4. **ACID事务**：分布式ACID事务支持

---

## 2. 关系模型与分布式扩展

### 2.1. 关系模型基础

#### 2.1.1. 关系模型定义

**关系（Relation）**是一个二维表，由行（元组）和列（属性）组成。

**形式化定义**：

设关系 $R$ 为：

$$R = (A_1, A_2, \ldots, A_n)$$

其中 $A_i$ 是属性，$A_i \in D_i$（$D_i$ 是属性域）。

**关系实例**：

$$r(R) = \{t_1, t_2, \ldots, t_m\}$$

其中 $t_i = (a_{i1}, a_{i2}, \ldots, a_{in})$ 是元组。

#### 2.1.2. 关系代数

**基本关系代数运算**：

1. **选择（Selection）**：$\sigma_{P}(R)$
2. **投影（Projection）**：$\pi_{A}(R)$
3. **并（Union）**：$R \cup S$
4. **差（Difference）**：$R - S$
5. **笛卡尔积（Cartesian Product）**：$R \times S$
6. **连接（Join）**：$R \bowtie_{P} S$

### 2.2. 分布式扩展

#### 2.2.1. 分布式关系模型

**分布式关系**：

设分布式关系 $R$ 被分片为 $R_1, R_2, \ldots, R_n$：

$$R = R_1 \cup R_2 \cup \ldots \cup R_n$$

其中 $R_i \cap R_j = \emptyset$（不相交分片）或 $R_i \cap R_j \neq \emptyset$（重叠分片）。

#### 2.2.2. 分片策略

**水平分片（Horizontal Partitioning）**：

$$R = \bigcup_{i=1}^{n} R_i$$

其中 $R_i = \sigma_{P_i}(R)$，$P_i$ 是分片谓词。

**垂直分片（Vertical Partitioning）**：

$$R = R_1 \bowtie R_2 \bowtie \ldots \bowtie R_n$$

其中 $R_i = \pi_{A_i}(R)$，$A_i$ 是属性子集。

### 2.3. 分布式表模型

#### 2.3.1. 分布式表定义

**分布式表**是跨多个节点分布的关系表。

**形式化定义**：

设分布式表 $T$ 分布在节点集合 $N = \{N_1, N_2, \ldots, N_k\}$ 上：

$$T = \bigcup_{i=1}^{k} T_i$$

其中 $T_i$ 是节点 $N_i$ 上的表片段。

#### 2.3.2. 分片函数

**哈希分片**：

$$shard(key) = hash(key) \bmod n$$

其中 $n$ 是分片数量。

**范围分片**：

$$shard(key) = i \text{ if } k_i \leq key < k_{i+1}$$

**列表分片**：

$$shard(key) = i \text{ if } key \in L_i$$

其中 $L_i$ 是分片 $i$ 的键值列表。

### 2.4. 分区表模型

#### 2.4.1. 分区定义

**分区表**是逻辑上统一、物理上分区的表。

**形式化定义**：

设分区表 $T$ 有 $n$ 个分区：

$$T = \{P_1, P_2, \ldots, P_n\}$$

其中 $P_i$ 是分区，满足：

$$\bigcup_{i=1}^{n} P_i = T, \quad P_i \cap P_j = \emptyset \text{ for } i \neq j$$

#### 2.4.2. 分区策略

**范围分区**：

```sql
CREATE TABLE orders (
    id BIGINT PRIMARY KEY,
    order_date DATE,
    amount DECIMAL(10,2)
) PARTITION BY RANGE (order_date) (
    PARTITION p202401 VALUES LESS THAN ('2024-02-01'),
    PARTITION p202402 VALUES LESS THAN ('2024-03-01'),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

**哈希分区**：

```sql
CREATE TABLE users (
    id BIGINT PRIMARY KEY,
    username VARCHAR(50)
) PARTITION BY HASH(id) PARTITIONS 8;
```

**列表分区**：

```sql
CREATE TABLE sales (
    id BIGINT PRIMARY KEY,
    region VARCHAR(50)
) PARTITION BY LIST (region) (
    PARTITION p_north VALUES IN ('Beijing', 'Tianjin'),
    PARTITION p_south VALUES IN ('Guangzhou', 'Shenzhen')
);
```

### 2.5. 全局索引模型

#### 2.5.1. 全局索引定义

**全局索引**是跨分片的索引结构。

**形式化定义**：

设全局索引 $I$ 索引关系 $R$：

$$I = \{(k, loc) | k \in K, loc \in L\}$$

其中 $K$ 是键集合，$L$ 是位置集合（分片标识）。

#### 2.5.2. 索引类型

**全局唯一索引**：

保证跨分片的唯一性约束。

**全局非唯一索引**：

支持跨分片的快速查找。

**实现示例**：

```sql
-- 创建全局唯一索引
CREATE UNIQUE INDEX idx_email ON users(email);

-- 查询使用全局索引
SELECT * FROM users WHERE email = 'user@example.com';
-- 系统自动定位到包含该email的分片
```

---

## 3. 一致性协议

### 3.1. Paxos协议

#### 3.1.1. Paxos基础

**Paxos**是分布式一致性算法，用于在异步网络中达成共识。

**Paxos角色**：

1. **Proposer**：提议者
2. **Acceptor**：接受者
3. **Learner**：学习者

#### 3.1.2. Paxos算法

**阶段1：Prepare阶段**:

1. Proposer选择提案编号 $n$
2. 向多数Acceptor发送Prepare(n)请求
3. Acceptor响应：
   - 如果 $n > \max(n_{promised})$，承诺不接受编号小于 $n$ 的提案
   - 返回已接受的最大编号提案

**阶段2：Accept阶段**:

1. Proposer收到多数响应后，选择值 $v$：
   - 如果响应中包含已接受的提案，选择最大编号提案的值
   - 否则，选择自己的值
2. 向多数Acceptor发送Accept(n, v)请求
3. Acceptor接受提案（如果 $n \geq \max(n_{promised})$）

**形式化定义**：

$$
\text{Paxos}(n, v) = \begin{cases}
\text{Accept} & \text{if } |\{a | a \text{ accepts } (n, v)\}| > \frac{N}{2} \\
\text{Reject} & \text{otherwise}
\end{cases}
$$

其中 $N$ 是Acceptor总数。

### 3.2. Raft协议

#### 3.2.1. Raft基础

**Raft**是易于理解的分布式一致性算法。

**Raft角色**：

1. **Leader**：领导者
2. **Follower**：跟随者
3. **Candidate**：候选者

#### 3.2.2. Raft算法

**Leader选举**：

1. Follower超时后成为Candidate
2. Candidate发起选举，请求投票
3. 获得多数票后成为Leader
4. Leader定期发送心跳维持地位

**日志复制**：

1. Leader接收客户端请求，追加到日志
2. Leader并行向所有Follower发送AppendEntries
3. 多数Follower确认后，Leader提交日志
4. Leader通知Follower提交日志

**形式化定义**：

$$
\text{RaftCommit}(entry) = \begin{cases}
\text{Committed} & \text{if } |\{f | f \text{ has } entry\}| > \frac{N}{2} \\
\text{Pending} & \text{otherwise}
\end{cases}
$$

### 3.3. 两阶段提交（2PC）

#### 3.3.1. 2PC算法

**阶段1：Prepare阶段**:

1. Coordinator向所有Participant发送Prepare请求
2. Participant执行事务，但不提交
3. Participant响应：
   - Yes：可以提交
   - No：不能提交

**阶段2：Commit阶段**:

1. 如果所有Participant都响应Yes：
   - Coordinator发送Commit请求
   - Participant提交事务
2. 如果有Participant响应No：
   - Coordinator发送Abort请求
   - Participant回滚事务

**形式化定义**：

$$
\text{2PC}(T) = \begin{cases}
\text{Commit} & \text{if } \forall p \in P: \text{Prepare}(p) = \text{Yes} \\
\text{Abort} & \text{otherwise}
\end{cases}
$$

其中 $P$ 是Participant集合。

#### 3.3.2. 2PC实现

**实现示例**：

```python
class TwoPhaseCommit:
    def __init__(self, participants):
        self.participants = participants
        self.prepared = set()

    def prepare(self, transaction):
        """Prepare阶段"""
        for participant in self.participants:
            if not participant.prepare(transaction):
                return False
            self.prepared.add(participant)
        return True

    def commit(self, transaction):
        """Commit阶段"""
        if self.prepare(transaction):
            for participant in self.prepared:
                participant.commit(transaction)
            return True
        else:
            self.abort(transaction)
            return False

    def abort(self, transaction):
        """Abort阶段"""
        for participant in self.prepared:
            participant.abort(transaction)
```

### 3.4. 三阶段提交（3PC）

#### 3.4.1. 3PC算法

**阶段1：CanCommit阶段**:

1. Coordinator询问Participant是否可以提交
2. Participant响应Yes或No

**阶段2：PreCommit阶段**:

1. 如果所有Participant响应Yes：
   - Coordinator发送PreCommit请求
   - Participant进入PreCommit状态
2. 如果有Participant响应No：
   - Coordinator发送Abort请求
   - Participant回滚

**阶段3：DoCommit阶段**:

1. Coordinator发送DoCommit请求
2. Participant提交事务

**3PC优势**：

- 非阻塞：超时后可以自动恢复
- 减少阻塞时间

**形式化定义**：

$$
\text{3PC}(T) = \begin{cases}
\text{PreCommit} & \text{if } \forall p: \text{CanCommit}(p) = \text{Yes} \\
\text{Abort} & \text{otherwise}
\end{cases}
$$

---

## 4. 事务模型

### 4.1. ACID属性

#### 4.1.1. ACID定义

**ACID属性**：

1. **原子性（Atomicity）**：事务要么全部执行，要么全部不执行
2. **一致性（Consistency）**：事务执行前后数据库保持一致状态
3. **隔离性（Isolation）**：并发事务互不干扰
4. **持久性（Durability）**：已提交事务的结果永久保存

**形式化定义**：

$$\text{ACID}(T) = \text{Atomicity}(T) \land \text{Consistency}(T) \land \text{Isolation}(T) \land \text{Durability}(T)$$

#### 4.1.2. 原子性

**原子性定义**：

$$
\text{Atomicity}(T) = \begin{cases}
\text{All operations commit} & \text{if } T \text{ succeeds} \\
\text{All operations abort} & \text{if } T \text{ fails}
\end{cases}
$$

### 4.2. 分布式事务模型

#### 4.2.1. 分布式事务定义

**分布式事务**是跨多个节点的原子操作。

**形式化定义**：

设分布式事务 $T$ 涉及节点集合 $N = \{N_1, N_2, \ldots, N_k\}$：

$$T = \{T_1, T_2, \ldots, T_k\}$$

其中 $T_i$ 是节点 $N_i$ 上的子事务。

**原子性保证**：

$$\text{Commit}(T) \iff \forall i: \text{Commit}(T_i)$$

$$\text{Abort}(T) \iff \exists i: \text{Abort}(T_i)$$

### 4.3. 隔离级别

#### 4.3.1. 隔离级别定义

**SQL标准隔离级别**：

1. **Read Uncommitted**：读未提交
2. **Read Committed**：读已提交
3. **Repeatable Read**：可重复读
4. **Serializable**：可串行化

**形式化定义**：

$$
\text{Isolation}(T_1, T_2) = \begin{cases}
\text{Serializable} & \text{if } T_1 \parallel T_2 \equiv T_1; T_2 \text{ or } T_2; T_1 \\
\text{Repeatable Read} & \text{if } \text{no phantom reads} \\
\text{Read Committed} & \text{if } \text{no dirty reads} \\
\text{Read Uncommitted} & \text{otherwise}
\end{cases}
$$

---

## 5. 数据一致性模型

### 5.1. 强一致性

#### 5.1.1. 强一致性定义

**强一致性**要求所有节点看到相同的数据。

**形式化定义**：

$$\forall n_1, n_2 \in N, \forall t: \text{Read}(n_1, k, t) = \text{Read}(n_2, k, t)$$

其中 $N$ 是节点集合，$k$ 是键，$t$ 是时间。

### 5.2. 最终一致性

#### 5.2.1. 最终一致性定义

**最终一致性**允许暂时不一致，但最终会一致。

**形式化定义**：

$$\lim_{t \to \infty} \forall n_1, n_2: \text{Read}(n_1, k, t) = \text{Read}(n_2, k, t)$$

### 5.3. 因果一致性

#### 5.3.1. 因果一致性定义

**因果一致性**保证因果相关的操作在所有节点上以相同顺序执行。

**形式化定义**：

$$\text{CausalOrder}(op_1, op_2) \implies \forall n: \text{Order}(n, op_1, op_2)$$

---

## 6. 形式化定义与证明

### 6.1. 关系模型形式化

#### 6.1.1. 关系代数完备性

**关系代数完备性定理**：

关系代数可以表达所有关系查询。

**证明**：

通过归纳法证明所有关系查询都可以用关系代数表达。

### 6.2. 一致性协议形式化

#### 6.2.1. Paxos安全性

**Paxos安全性定理**：

如果值 $v$ 被选定，则所有更高编号的提案都包含值 $v$。

**证明**：

通过数学归纳法证明。

### 6.3. 事务模型形式化

#### 6.3.1. 可串行化定理

**可串行化定理**：

如果事务调度是可串行化的，则满足隔离性。

**证明**：

通过冲突图分析证明。

---

## 7. 实际系统实现

### 7.1. TiDB形式模型

**TiDB架构**：

- **PD（Placement Driver）**：元数据管理，使用Raft
- **TiKV**：存储层，使用Raft
- **TiDB**：计算层，无状态

**一致性保证**：

- 使用Raft保证强一致性
- 支持分布式事务（Percolator模型）

### 7.2. CockroachDB形式模型

**CockroachDB架构**：

- 所有节点对等
- 使用Raft保证一致性
- 支持分布式事务（2PC）

### 7.3. OceanBase形式模型

**OceanBase架构**：

- 计算存储分离
- 使用Paxos保证一致性
- 支持分布式事务（2PC）

---

## 8. 多表征

本主题支持多种表征方式：

1. **符号表征**：形式化定义、数学公式、逻辑证明
2. **图结构**：协议流程图、状态转换图
3. **代码实现**：算法实现、系统配置
4. **自然语言**：概念定义、算法描述
5. **可视化**：协议交互图、系统架构图

---

## 9. 总结与展望

### 9.1. 总结

NewSQL形式模型的核心要点：

1. **关系模型扩展**：分布式表和分区
2. **一致性协议**：Paxos、Raft、2PC、3PC
3. **事务模型**：分布式ACID事务
4. **一致性模型**：强一致性、最终一致性

### 9.2. 发展趋势

**未来发展方向**：

1. **新的一致性协议**：更高效的共识算法
2. **混合一致性**：不同场景使用不同一致性级别
3. **形式化验证**：使用形式化方法验证系统正确性

---

**参考文献**：

1. Lamport, L. (1998). "The Part-Time Parliament". ACM Transactions on Computer Systems.
2. Ongaro, D., & Ousterhout, J. (2014). "In Search of an Understandable Consensus Algorithm".
3. Codd, E. F. (1970). "A Relational Model of Data for Large Shared Data Banks".

---

[返回NewSQL导航](README.md)
