# 1.3.8 NoSQL实践案例

## 概述

本文档提供NoSQL数据库系统的实际应用案例，涵盖MongoDB、Redis、Cassandra等主流NoSQL数据库的设计模式、性能优化、分布式配置等核心主题。每个案例都包含完整的代码示例和最佳实践。

## 目录

- [1. MongoDB实践案例](#1-mongodb实践案例)
- [2. Redis实践案例](#2-redis实践案例)
- [3. Cassandra实践案例](#3-cassandra实践案例)
- [4. 混合架构实践案例](#4-混合架构实践案例)
- [5. 性能优化实践案例](#5-性能优化实践案例)

## 1. MongoDB实践案例

### 1.1 电商系统文档设计

```javascript
// 用户文档设计
const userSchema = {
  _id: ObjectId,
  username: String,
  email: String,
  profile: {
    firstName: String,
    lastName: String,
    phone: String,
    address: {
      street: String,
      city: String,
      state: String,
      zipCode: String
    }
  },
  preferences: {
    language: String,
    currency: String,
    notifications: {
      email: Boolean,
      sms: Boolean,
      push: Boolean
    }
  },
  createdAt: Date,
  updatedAt: Date
};

// 商品文档设计
const productSchema = {
  _id: ObjectId,
  name: String,
  description: String,
  price: {
    amount: Number,
    currency: String
  },
  category: {
    _id: ObjectId,
    name: String,
    path: [String]  // 分类路径
  },
  attributes: {
    brand: String,
    model: String,
    color: [String],
    size: [String],
    weight: Number,
    dimensions: {
      length: Number,
      width: Number,
      height: Number
    }
  },
  inventory: {
    stock: Number,
    reserved: Number,
    available: Number
  },
  images: [{
    url: String,
    alt: String,
    isPrimary: Boolean
  }],
  ratings: {
    average: Number,
    count: Number,
    distribution: {
      1: Number,
      2: Number,
      3: Number,
      4: Number,
      5: Number
    }
  },
  status: String,
  createdAt: Date,
  updatedAt: Date
};

// 订单文档设计
const orderSchema = {
  _id: ObjectId,
  orderNumber: String,
  userId: ObjectId,
  items: [{
    productId: ObjectId,
    productName: String,
    quantity: Number,
    unitPrice: Number,
    totalPrice: Number,
    attributes: {
      color: String,
      size: String
    }
  }],
  totals: {
    subtotal: Number,
    tax: Number,
    shipping: Number,
    discount: Number,
    grandTotal: Number
  },
  shipping: {
    address: {
      street: String,
      city: String,
      state: String,
      zipCode: String,
      country: String
    },
    method: String,
    trackingNumber: String
  },
  payment: {
    method: String,
    status: String,
    transactionId: String,
    processedAt: Date
  },
  status: String,
  statusHistory: [{
    status: String,
    timestamp: Date,
    note: String
  }],
  createdAt: Date,
  updatedAt: Date
};
```

### 1.2 MongoDB聚合管道优化

```javascript
// 复杂聚合查询示例
db.orders.aggregate([
  // 1. 匹配条件
  {
    $match: {
      status: { $in: ['paid', 'shipped', 'delivered'] },
      createdAt: { $gte: new Date('2024-01-01') }
    }
  },
  
  // 2. 展开订单项
  { $unwind: '$items' },
  
  // 3. 关联商品信息
  {
    $lookup: {
      from: 'products',
      localField: 'items.productId',
      foreignField: '_id',
      as: 'product'
    }
  },
  
  // 4. 展开商品信息
  { $unwind: '$product' },
  
  // 5. 按商品分组统计
  {
    $group: {
      _id: {
        productId: '$items.productId',
        productName: '$product.name',
        category: '$product.category.name'
      },
      totalQuantity: { $sum: '$items.quantity' },
      totalRevenue: { $sum: '$items.totalPrice' },
      orderCount: { $sum: 1 },
      avgOrderValue: { $avg: '$items.totalPrice' }
    }
  },
  
  // 6. 按收入排序
  { $sort: { totalRevenue: -1 } },
  
  // 7. 限制结果数量
  { $limit: 10 }
]);

// 使用索引优化聚合查询
db.orders.createIndex({ status: 1, createdAt: 1 });
db.orders.createIndex({ 'items.productId': 1 });
db.products.createIndex({ _id: 1, name: 1, 'category.name': 1 });
```

### 1.3 MongoDB分片配置

```javascript
// 启用分片
sh.enableSharding("ecommerce");

// 为集合启用分片
sh.shardCollection("ecommerce.orders", { userId: 1 });
sh.shardCollection("ecommerce.products", { "category._id": 1 });

// 添加分片
sh.addShard("shard1/mongodb1:27018");
sh.addShard("shard2/mongodb2:27018");
sh.addShard("shard3/mongodb3:27018");

// 配置分片键
sh.shardCollection("ecommerce.users", { email: 1 });

// 查看分片状态
sh.status();
```

## 2. Redis实践案例

### 2.1 缓存策略设计

```python
import redis
import json
import hashlib
from datetime import datetime, timedelta

class RedisCacheManager:
    def __init__(self, host='localhost', port=6379, db=0):
        self.redis_client = redis.Redis(host=host, port=port, db=db)
        self.default_ttl = 3600  # 1小时默认过期时间
    
    def generate_cache_key(self, prefix, *args):
        """生成缓存键"""
        key_parts = [prefix] + [str(arg) for arg in args]
        return ":".join(key_parts)
    
    def get_cached_data(self, key):
        """获取缓存数据"""
        try:
            data = self.redis_client.get(key)
            return json.loads(data) if data else None
        except Exception as e:
            print(f"缓存读取错误: {e}")
            return None
    
    def set_cached_data(self, key, data, ttl=None):
        """设置缓存数据"""
        try:
            ttl = ttl or self.default_ttl
            self.redis_client.setex(
                key, 
                ttl, 
                json.dumps(data, ensure_ascii=False)
            )
            return True
        except Exception as e:
            print(f"缓存设置错误: {e}")
            return False
    
    def invalidate_pattern(self, pattern):
        """批量删除缓存"""
        try:
            keys = self.redis_client.keys(pattern)
            if keys:
                self.redis_client.delete(*keys)
            return len(keys)
        except Exception as e:
            print(f"缓存删除错误: {e}")
            return 0

# 用户信息缓存
class UserCache:
    def __init__(self):
        self.cache = RedisCacheManager()
    
    def get_user_profile(self, user_id):
        """获取用户资料（带缓存）"""
        cache_key = self.cache.generate_cache_key("user:profile", user_id)
        
        # 尝试从缓存获取
        cached_data = self.cache.get_cached_data(cache_key)
        if cached_data:
            return cached_data
        
        # 从数据库获取
        user_data = self.fetch_user_from_db(user_id)
        if user_data:
            # 设置缓存，TTL为30分钟
            self.cache.set_cached_data(cache_key, user_data, 1800)
        
        return user_data
    
    def update_user_profile(self, user_id, user_data):
        """更新用户资料（同时更新缓存）"""
        # 更新数据库
        success = self.update_user_in_db(user_id, user_data)
        if success:
            # 删除相关缓存
            cache_key = self.cache.generate_cache_key("user:profile", user_id)
            self.cache.redis_client.delete(cache_key)
        
        return success
```

### 2.2 Redis数据结构应用

```python
# 购物车实现
class ShoppingCart:
    def __init__(self):
        self.redis_client = redis.Redis(host='localhost', port=6379, db=1)
    
    def add_item(self, user_id, product_id, quantity=1):
        """添加商品到购物车"""
        cart_key = f"cart:{user_id}"
        
        # 使用Hash存储购物车数据
        self.redis_client.hincrby(cart_key, product_id, quantity)
        
        # 设置购物车过期时间（7天）
        self.redis_client.expire(cart_key, 7 * 24 * 3600)
    
    def remove_item(self, user_id, product_id):
        """从购物车移除商品"""
        cart_key = f"cart:{user_id}"
        return self.redis_client.hdel(cart_key, product_id)
    
    def get_cart(self, user_id):
        """获取购物车内容"""
        cart_key = f"cart:{user_id}"
        cart_data = self.redis_client.hgetall(cart_key)
        
        # 转换为字典格式
        return {k.decode(): int(v) for k, v in cart_data.items()}
    
    def clear_cart(self, user_id):
        """清空购物车"""
        cart_key = f"cart:{user_id}"
        return self.redis_client.delete(cart_key)

# 商品排行榜实现
class ProductRanking:
    def __init__(self):
        self.redis_client = redis.Redis(host='localhost', port=6379, db=2)
    
    def increment_sales(self, product_id, amount=1):
        """增加商品销量"""
        ranking_key = "product:sales:ranking"
        self.redis_client.zincrby(ranking_key, amount, product_id)
    
    def get_top_products(self, limit=10):
        """获取销量排行榜"""
        ranking_key = "product:sales:ranking"
        return self.redis_client.zrevrange(ranking_key, 0, limit-1, withscores=True)
    
    def get_product_rank(self, product_id):
        """获取商品排名"""
        ranking_key = "product:sales:ranking"
        rank = self.redis_client.zrevrank(ranking_key, product_id)
        score = self.redis_client.zscore(ranking_key, product_id)
        return rank + 1 if rank is not None else None, score

# 限流器实现
class RateLimiter:
    def __init__(self):
        self.redis_client = redis.Redis(host='localhost', port=6379, db=3)
    
    def is_allowed(self, key, limit, window):
        """检查是否允许请求"""
        current = self.redis_client.get(key)
        
        if current is None:
            # 第一次请求
            self.redis_client.setex(key, window, 1)
            return True
        
        current_count = int(current)
        if current_count < limit:
            # 增加计数
            self.redis_client.incr(key)
            return True
        
        return False
    
    def get_remaining(self, key, limit):
        """获取剩余请求次数"""
        current = self.redis_client.get(key)
        if current is None:
            return limit
        return max(0, limit - int(current))
```

## 3. Cassandra实践案例

### 3.1 时间序列数据设计

```sql
-- 创建键空间
CREATE KEYSPACE IF NOT EXISTS metrics 
WITH replication = {
    'class': 'SimpleStrategy',
    'replication_factor': 3
};

USE metrics;

-- 系统指标表
CREATE TABLE system_metrics (
    host_id text,
    metric_name text,
    timestamp timestamp,
    value double,
    tags map<text, text>,
    PRIMARY KEY ((host_id, metric_name), timestamp)
) WITH CLUSTERING ORDER BY (timestamp DESC);

-- 用户行为表
CREATE TABLE user_events (
    user_id text,
    event_date date,
    event_timestamp timestamp,
    event_type text,
    event_data text,
    session_id text,
    PRIMARY KEY ((user_id, event_date), event_timestamp, event_type)
) WITH CLUSTERING ORDER BY (event_timestamp DESC, event_type ASC);

-- 订单表（按用户分区）
CREATE TABLE orders_by_user (
    user_id text,
    order_date date,
    order_id text,
    order_timestamp timestamp,
    total_amount decimal,
    status text,
    items list<text>,
    PRIMARY KEY ((user_id, order_date), order_timestamp, order_id)
) WITH CLUSTERING ORDER BY (order_timestamp DESC, order_id ASC);

-- 商品销售表（按商品分区）
CREATE TABLE product_sales (
    product_id text,
    sale_date date,
    sale_timestamp timestamp,
    order_id text,
    quantity int,
    unit_price decimal,
    total_price decimal,
    user_id text,
    PRIMARY KEY ((product_id, sale_date), sale_timestamp, order_id)
) WITH CLUSTERING ORDER BY (sale_timestamp DESC, order_id ASC);
```

### 3.2 Cassandra查询优化

```python
from cassandra.cluster import Cluster
from cassandra.query import SimpleStatement
from datetime import datetime, timedelta
import json

class CassandraMetricsManager:
    def __init__(self):
        self.cluster = Cluster(['localhost'])
        self.session = self.cluster.connect('metrics')
    
    def insert_system_metric(self, host_id, metric_name, value, tags=None):
        """插入系统指标"""
        query = """
        INSERT INTO system_metrics (host_id, metric_name, timestamp, value, tags)
        VALUES (?, ?, ?, ?, ?)
        """
        
        self.session.execute(query, (
            host_id,
            metric_name,
            datetime.now(),
            value,
            tags or {}
        ))
    
    def get_metrics_by_host(self, host_id, metric_name, start_time, end_time):
        """获取指定主机的指标数据"""
        query = """
        SELECT timestamp, value, tags
        FROM system_metrics
        WHERE host_id = ? AND metric_name = ?
        AND timestamp >= ? AND timestamp <= ?
        """
        
        statement = SimpleStatement(query, fetch_size=1000)
        rows = self.session.execute(statement, (host_id, metric_name, start_time, end_time))
        
        return [{
            'timestamp': row.timestamp,
            'value': row.value,
            'tags': row.tags
        } for row in rows]
    
    def get_user_events(self, user_id, event_date, event_type=None):
        """获取用户事件"""
        if event_type:
            query = """
            SELECT event_timestamp, event_type, event_data, session_id
            FROM user_events
            WHERE user_id = ? AND event_date = ? AND event_type = ?
            """
            rows = self.session.execute(query, (user_id, event_date, event_type))
        else:
            query = """
            SELECT event_timestamp, event_type, event_data, session_id
            FROM user_events
            WHERE user_id = ? AND event_date = ?
            """
            rows = self.session.execute(query, (user_id, event_date))
        
        return [{
            'timestamp': row.event_timestamp,
            'type': row.event_type,
            'data': json.loads(row.event_data),
            'session_id': row.session_id
        } for row in rows]
    
    def get_product_sales(self, product_id, sale_date):
        """获取商品销售数据"""
        query = """
        SELECT sale_timestamp, order_id, quantity, unit_price, total_price, user_id
        FROM product_sales
        WHERE product_id = ? AND sale_date = ?
        """
        
        rows = self.session.execute(query, (product_id, sale_date))
        
        return [{
            'timestamp': row.sale_timestamp,
            'order_id': row.order_id,
            'quantity': row.quantity,
            'unit_price': float(row.unit_price),
            'total_price': float(row.total_price),
            'user_id': row.user_id
        } for row in rows]
```

## 4. 混合架构实践案例

### 4.1 多数据库协同架构

```python
class HybridDataManager:
    def __init__(self):
        # 初始化各种数据库连接
        self.mongo_client = pymongo.MongoClient('mongodb://localhost:27017/')
        self.redis_client = redis.Redis(host='localhost', port=6379, db=0)
        self.cassandra_session = Cluster(['localhost']).connect('ecommerce')
    
    def get_product_details(self, product_id):
        """获取商品详情（多级缓存）"""
        # 1. 检查Redis缓存
        cache_key = f"product:{product_id}"
        cached_data = self.redis_client.get(cache_key)
        if cached_data:
            return json.loads(cached_data)
        
        # 2. 从MongoDB获取
        product = self.mongo_client.ecommerce.products.find_one({'_id': ObjectId(product_id)})
        if product:
            # 3. 设置Redis缓存
            self.redis_client.setex(cache_key, 3600, json.dumps(product, default=str))
            return product
        
        return None
    
    def record_user_activity(self, user_id, activity_type, activity_data):
        """记录用户活动（多数据库存储）"""
        timestamp = datetime.now()
        
        # 1. 实时数据存储到Cassandra
        self.cassandra_session.execute("""
            INSERT INTO user_events (user_id, event_date, event_timestamp, event_type, event_data)
            VALUES (?, ?, ?, ?, ?)
        """, (user_id, timestamp.date(), timestamp, activity_type, json.dumps(activity_data)))
        
        # 2. 更新Redis计数器
        counter_key = f"user:activity:{user_id}:{activity_type}"
        self.redis_client.incr(counter_key)
        self.redis_client.expire(counter_key, 86400)  # 24小时过期
        
        # 3. 重要活动存储到MongoDB
        if activity_type in ['purchase', 'login', 'profile_update']:
            self.mongo_client.ecommerce.user_activities.insert_one({
                'user_id': user_id,
                'activity_type': activity_type,
                'activity_data': activity_data,
                'timestamp': timestamp
            })
    
    def get_user_analytics(self, user_id, start_date, end_date):
        """获取用户分析数据"""
        analytics = {}
        
        # 1. 从Redis获取实时计数器
        activity_types = ['view', 'click', 'purchase', 'login']
        for activity_type in activity_types:
            counter_key = f"user:activity:{user_id}:{activity_type}"
            count = self.redis_client.get(counter_key)
            analytics[f'{activity_type}_count'] = int(count) if count else 0
        
        # 2. 从Cassandra获取历史事件
        events = self.cassandra_session.execute("""
            SELECT event_type, event_timestamp, event_data
            FROM user_events
            WHERE user_id = ? AND event_date >= ? AND event_date <= ?
        """, (user_id, start_date, end_date))
        
        analytics['events'] = [{
            'type': event.event_type,
            'timestamp': event.event_timestamp,
            'data': json.loads(event.event_data)
        } for event in events]
        
        # 3. 从MongoDB获取详细活动
        detailed_activities = self.mongo_client.ecommerce.user_activities.find({
            'user_id': user_id,
            'timestamp': {'$gte': start_date, '$lte': end_date}
        }).sort('timestamp', -1)
        
        analytics['detailed_activities'] = list(detailed_activities)
        
        return analytics
```

## 5. 性能优化实践案例

### 5.1 索引优化策略

```javascript
// MongoDB索引优化
// 1. 复合索引
db.orders.createIndex({ userId: 1, status: 1, createdAt: -1 });

// 2. 覆盖索引
db.products.createIndex({ 
  categoryId: 1, 
  status: 1, 
  name: 1, 
  price: 1 
});

// 3. 文本搜索索引
db.products.createIndex({ 
  name: "text", 
  description: "text" 
});

// 4. 地理空间索引
db.stores.createIndex({ location: "2dsphere" });

// Redis优化
// 1. 使用Pipeline批量操作
const pipeline = redis.pipeline();
for (let i = 0; i < 1000; i++) {
    pipeline.set(`key:${i}`, `value:${i}`);
}
pipeline.exec();

// 2. 使用Lua脚本原子操作
const luaScript = `
    local key = KEYS[1]
    local value = ARGV[1]
    local ttl = ARGV[2]
    
    if redis.call('EXISTS', key) == 0 then
        redis.call('SETEX', key, ttl, value)
        return 1
    else
        return 0
    end
`;

redis.eval(luaScript, 1, 'mykey', 'myvalue', 3600);
```

### 5.2 连接池和配置优化

```python
# MongoDB连接池配置
from pymongo import MongoClient
from pymongo.errors import ConnectionFailure

class MongoDBManager:
    def __init__(self):
        self.client = MongoClient(
            'mongodb://localhost:27017/',
            maxPoolSize=50,           # 最大连接池大小
            minPoolSize=10,           # 最小连接池大小
            maxIdleTimeMS=30000,      # 最大空闲时间
            waitQueueTimeoutMS=2500,  # 等待队列超时
            connectTimeoutMS=2000,    # 连接超时
            serverSelectionTimeoutMS=3000  # 服务器选择超时
        )
    
    def get_database(self, db_name):
        return self.client[db_name]
    
    def health_check(self):
        try:
            self.client.admin.command('ping')
            return True
        except ConnectionFailure:
            return False

# Redis连接池配置
import redis
from redis.connection import ConnectionPool

class RedisManager:
    def __init__(self):
        self.pool = ConnectionPool(
            host='localhost',
            port=6379,
            db=0,
            max_connections=20,      # 最大连接数
            retry_on_timeout=True,   # 超时重试
            socket_keepalive=True,   # 保持连接
            socket_keepalive_options={}
        )
        self.client = redis.Redis(connection_pool=self.pool)
    
    def get_client(self):
        return self.client
```

## 总结

这些实践案例展示了NoSQL数据库系统的核心应用场景，包括：

1. **MongoDB**：文档数据库设计、聚合管道优化、分片配置
2. **Redis**：缓存策略、数据结构应用、限流器实现
3. **Cassandra**：时间序列数据设计、查询优化
4. **混合架构**：多数据库协同工作
5. **性能优化**：索引优化、连接池配置

每个案例都提供了完整的代码示例和最佳实践，可以直接应用于实际项目中。

**相关链接：**

- [1.3.1-形式模型](1.3.1-形式模型.md)
- [1.3.2-系统架构](1.3.2-系统架构.md)
- [1.3.3-数据模型](1.3.3-数据模型.md)
- [1.3.4-查询与索引](1.3.4-查询与索引.md)
- [1.3.5-分布式一致性与CAP](1.3.5-分布式一致性与CAP.md)
- [1.3.6-性能调优与监控](1.3.6-性能调优与监控.md)
- [1.3.7-安全与合规](1.3.7-安全与合规.md)
