---
title: 02.02-索引结构与优化
slug: 02.02-索引结构与优化
tags: []
pg_version: 16
status: draft
last_review: 2025-09-12
owner: TBD
---

# 索引结构与优化

## 1. 定义与形式化

### 1.1 概念定义

**中文定义**: 索引结构是数据库系统中用于加速数据访问的数据结构，通过建立键值到数据位置的映射关系提高查询性能。PostgreSQL支持多种索引类型，包括B+树、哈希、GiST、GIN等。

**English Definition**: Index structures are data structures in database systems used to accelerate data access by establishing mapping relationships between keys and data locations to improve query performance. PostgreSQL supports multiple index types including B+tree, Hash, GiST, GIN, etc.

### 1.2 形式化定义

```latex
% 数学符号定义
\newcommand{\index}{\mathcal{I}}
\newcommand{\key}{\mathcal{K}}
\newcommand{\pointer}{\mathcal{P}}
\newcommand{\tuple}{\mathcal{T}}

% 索引的形式化定义
\index = \{(k_1, p_1), (k_2, p_2), \ldots, (k_n, p_n)\}

其中：
k_i \in \key: 索引键值
p_i \in \pointer: 指向数据的指针
\forall i \neq j: k_i \neq k_j \text{ (唯一性约束)}
```

### 1.3 核心属性

- **快速查找**: O(log n) 时间复杂度
- **空间效率**: 合理的存储开销
- **动态更新**: 支持插入、删除、更新
- **并发安全**: 支持并发访问

## 2. 理论基础

### 2.1 B+树理论

```latex
\begin{theorem}[B+树性质]
B+树满足以下性质：
1. 所有叶子节点在同一层
2. 非叶子节点只存储键值
3. 叶子节点包含所有数据
4. 支持范围查询和顺序访问
5. 树高为 O(\log n)
\end{theorem}

\begin{proof}
基于B+树的平衡性质和节点分裂合并规则，可以证明B+树的正确性。
\end{proof}
```

### 2.2 哈希索引理论

```latex
\begin{theorem}[哈希索引]
哈希索引通过哈希函数实现：
1. 平均查找时间：O(1)
2. 不支持范围查询
3. 哈希冲突处理：链式法或开放地址法
4. 负载因子影响性能
\end{theorem}
```

### 2.3 索引选择理论

```latex
\begin{theorem}[索引选择性]
索引I对查询Q的选择性为：
\text{Selectivity}(I, Q) = \frac{|\sigma_p(R)|}{|R|}

其中p是Q的谓词条件，选择性越高，索引效果越好。
\end{theorem}
```

## 3. PostgreSQL索引类型

### 3.1 B+树索引

```sql
-- 创建B+树索引
CREATE INDEX idx_emp_salary ON employees (salary);
CREATE INDEX idx_emp_dept_salary ON employees (dept_id, salary);

-- 查看索引信息
SELECT 
    indexname,
    indexdef,
    pg_size_pretty(pg_relation_size(indexname::regclass)) as size
FROM pg_indexes
WHERE tablename = 'employees';

-- 索引使用统计
SELECT 
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE tablename = 'employees'
ORDER BY idx_scan DESC;
```

### 3.2 哈希索引

```sql
-- 创建哈希索引
CREATE INDEX idx_emp_id_hash ON employees USING HASH (emp_id);

-- 哈希索引使用
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE emp_id = 1001;
```

### 3.3 GiST索引

```sql
-- 创建GiST索引（几何数据）
CREATE TABLE spatial_data (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    location POINT
);

CREATE INDEX idx_spatial_location ON spatial_data USING GIST (location);

-- 空间查询
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM spatial_data 
WHERE location <@ box '((0,0),(100,100))';
```

### 3.4 GIN索引

```sql
-- 创建GIN索引（数组数据）
CREATE TABLE documents (
    id SERIAL PRIMARY KEY,
    title VARCHAR(200),
    tags TEXT[]
);

CREATE INDEX idx_doc_tags ON documents USING GIN (tags);

-- 数组查询
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM documents WHERE tags @> ARRAY['postgresql', 'database'];
```

## 4. 索引优化策略

### 4.1 复合索引设计

```sql
-- 复合索引设计原则
CREATE INDEX idx_emp_optimized ON employees (dept_id, salary, hire_date);

-- 最左前缀原则
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE dept_id = 1;  -- 使用索引

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE salary > 50000;  -- 不使用索引

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE dept_id = 1 AND salary > 50000;  -- 使用索引
```

### 4.2 部分索引

```sql
-- 创建部分索引
CREATE INDEX idx_high_salary ON employees (salary) WHERE salary > 100000;

-- 部分索引使用
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE salary > 150000;  -- 使用索引

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE salary < 50000;  -- 不使用索引
```

### 4.3 表达式索引

```sql
-- 创建表达式索引
CREATE INDEX idx_name_lower ON employees (LOWER(name));
CREATE INDEX idx_salary_rounded ON employees ((salary::INTEGER));

-- 表达式索引使用
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE LOWER(name) = 'john doe';

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE (salary::INTEGER) = 50000;
```

### 4.4 覆盖索引

```sql
-- 创建覆盖索引
CREATE INDEX idx_emp_covering ON employees (dept_id) INCLUDE (name, salary);

-- 覆盖索引使用
EXPLAIN (ANALYZE, BUFFERS)
SELECT dept_id, name, salary FROM employees WHERE dept_id = 1;
```

## 5. 索引维护

### 5.1 索引重建

```sql
-- 重建索引
REINDEX INDEX idx_emp_salary;
REINDEX TABLE employees;

-- 并发重建索引
REINDEX INDEX CONCURRENTLY idx_emp_salary;

-- 查看索引膨胀
SELECT 
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexname::regclass)) as index_size,
    pg_size_pretty(pg_relation_size(tablename::regclass)) as table_size
FROM pg_indexes
WHERE tablename = 'employees';
```

### 5.2 索引统计信息

```sql
-- 更新索引统计信息
ANALYZE employees;

-- 查看索引统计
SELECT 
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch,
    idx_blks_read,
    idx_blks_hit
FROM pg_statio_user_indexes
WHERE tablename = 'employees';
```

### 5.3 索引监控

```sql
-- 监控索引使用情况
SELECT 
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch,
    CASE 
        WHEN idx_scan = 0 THEN 'UNUSED'
        WHEN idx_tup_read / idx_scan > 1000 THEN 'INEFFICIENT'
        ELSE 'EFFICIENT'
    END as status
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
ORDER BY idx_scan DESC;
```

## 6. 索引性能分析

### 6.1 索引选择分析

```sql
-- 分析索引选择
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT * FROM employees WHERE emp_id = 1001;

-- 分析复合索引
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT * FROM employees WHERE dept_id = 1 AND salary > 50000;

-- 分析范围查询
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT * FROM employees WHERE salary BETWEEN 40000 AND 60000;
```

### 6.2 索引效率分析

```sql
-- 索引效率分析
SELECT 
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch,
    round(100.0 * idx_blks_hit / (idx_blks_hit + idx_blks_read), 2) as hit_ratio
FROM pg_statio_user_indexes
WHERE idx_blks_hit + idx_blks_read > 0
ORDER BY hit_ratio ASC;
```

### 6.3 索引大小分析

```sql
-- 索引大小分析
SELECT 
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexname::regclass)) as index_size,
    pg_size_pretty(pg_relation_size(tablename::regclass)) as table_size,
    round(100.0 * pg_relation_size(indexname::regclass) / pg_relation_size(tablename::regclass), 2) as size_ratio
FROM pg_indexes
WHERE schemaname = 'public'
ORDER BY pg_relation_size(indexname::regclass) DESC;
```

## 7. 高级索引技术

### 7.1 位图索引扫描

```sql
-- 位图索引扫描
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE dept_id = 1 AND salary > 50000;

-- 位图堆扫描
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE dept_id IN (1, 2, 3) AND salary > 50000;
```

### 7.2 索引跳跃扫描

```sql
-- 索引跳跃扫描
CREATE INDEX idx_emp_skip ON employees (dept_id, salary, hire_date);

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE salary > 50000 ORDER BY dept_id, salary;
```

### 7.3 索引合并

```sql
-- 索引合并
CREATE INDEX idx_emp_dept ON employees (dept_id);
CREATE INDEX idx_emp_salary ON employees (salary);

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE dept_id = 1 OR salary > 50000;
```

## 8. 索引优化实践

### 8.1 查询优化

```sql
-- 优化前
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees 
WHERE dept_id = 1 AND salary > 50000 AND hire_date > '2020-01-01';

-- 创建优化索引
CREATE INDEX idx_emp_optimized ON employees (dept_id, salary, hire_date);

-- 优化后
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees 
WHERE dept_id = 1 AND salary > 50000 AND hire_date > '2020-01-01';
```

### 8.2 批量操作优化

```sql
-- 批量插入优化
BEGIN;
-- 临时禁用索引
DROP INDEX CONCURRENTLY idx_emp_salary;
-- 批量插入
INSERT INTO employees (name, dept_id, salary) 
SELECT 'Employee' || generate_series(1, 100000), 
       (random() * 10)::INTEGER + 1,
       (random() * 100000)::INTEGER + 30000;
-- 重建索引
CREATE INDEX CONCURRENTLY idx_emp_salary ON employees (salary);
COMMIT;
```

### 8.3 索引维护策略

```sql
-- 自动索引维护
CREATE OR REPLACE FUNCTION maintain_indexes()
RETURNS void AS $$
DECLARE
    r RECORD;
BEGIN
    FOR r IN 
        SELECT schemaname, tablename, indexname
        FROM pg_indexes
        WHERE schemaname = 'public'
    LOOP
        -- 检查索引使用情况
        IF (SELECT idx_scan FROM pg_stat_user_indexes 
            WHERE schemaname = r.schemaname 
            AND tablename = r.tablename 
            AND indexname = r.indexname) = 0 THEN
            
            RAISE NOTICE 'Unused index: %.%', r.tablename, r.indexname;
        END IF;
    END LOOP;
END;
$$ LANGUAGE plpgsql;
```

## 9. 实际应用案例

### 9.1 电商系统索引设计

```sql
-- 商品表索引
CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    name VARCHAR(200),
    category_id INTEGER,
    price DECIMAL(10,2),
    stock_quantity INTEGER,
    created_at TIMESTAMP DEFAULT NOW()
);

-- 复合索引
CREATE INDEX idx_products_category_price ON products (category_id, price);
CREATE INDEX idx_products_stock ON products (stock_quantity) WHERE stock_quantity > 0;

-- 订单表索引
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INTEGER,
    order_date TIMESTAMP DEFAULT NOW(),
    status VARCHAR(20),
    total_amount DECIMAL(10,2)
);

-- 时间范围索引
CREATE INDEX idx_orders_date_status ON orders (order_date, status);
CREATE INDEX idx_orders_customer ON orders (customer_id, order_date);
```

### 9.2 日志系统索引设计

```sql
-- 日志表索引
CREATE TABLE log_entries (
    id BIGSERIAL PRIMARY KEY,
    log_time TIMESTAMP,
    level VARCHAR(10),
    source VARCHAR(100),
    message TEXT
);

-- 时间分区索引
CREATE INDEX idx_log_time ON log_entries (log_time);
CREATE INDEX idx_log_level_time ON log_entries (level, log_time);
CREATE INDEX idx_log_source_time ON log_entries (source, log_time);

-- 全文搜索索引
CREATE INDEX idx_log_message_gin ON log_entries USING GIN (to_tsvector('english', message));
```

## 10. 相关概念

### 10.1 上位概念

- **数据结构**: 更广泛的数据组织方式
- **查询优化**: 查询性能优化
- **存储管理**: 数据存储机制

### 10.2 下位概念

- **B+树**: 平衡树结构
- **哈希表**: 哈希数据结构
- **位图**: 位向量结构
- **倒排索引**: 反向索引结构

### 10.3 平行概念

- **缓存**: 内存缓存机制
- **分区**: 数据分区策略
- **压缩**: 数据压缩技术

## 11. 参考文献

1. Comer, D. (1979). The ubiquitous B-tree. ACM Computing Surveys, 11(2), 121-137.
2. PostgreSQL Global Development Group. (2024). PostgreSQL 16.2 Documentation. <https://www.postgresql.org/docs/16/>
3. Zobel, J., & Moffat, A. (2006). Inverted files for text search engines. ACM Computing Surveys, 38(2), 6.
4. Graefe, G. (2011). Modern B-tree techniques. Foundations and Trends in Databases, 3(4), 203-402.

## 12. Wikidata对齐

- **Wikidata ID**: Q192490
- **相关属性**:
  - P31: Q176165 (instance of: database management system)
  - P178: Q9366 (developer: PostgreSQL Global Development Group)
  - P277: Q193321 (programmed in: C)
  - P348: 16.2 (software version)
- **外部链接**:
  - <https://www.postgresql.org/docs/current/indexes.html>
  - <https://www.postgresql.org/docs/current/indexes-types.html>
