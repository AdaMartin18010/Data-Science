# 查询优化器原理

## 1. 定义与形式化

### 1.1 概念定义

**中文定义**: 查询优化器是数据库系统中将用户查询转换为高效执行计划的核心组件，通过代价模型选择最优执行策略，确保查询性能的最优化。

**English Definition**: A query optimizer is a core component in database systems that transforms user queries into efficient execution plans by selecting optimal strategies through cost models, ensuring optimal query performance.

### 1.2 形式化定义

```latex
% 数学符号定义
\newcommand{\query}{\mathcal{Q}}
\newcommand{\plan}{\mathcal{P}}
\newcommand{\cost}{\mathcal{C}}
\newcommand{\optimizer}{\mathcal{O}}

% 查询优化的形式化定义
\optimizer: \query \rightarrow \plan

优化目标：\min_{\plan \in \mathcal{P}(\query)} \cost(\plan)

其中：
\mathcal{P}(\query) = \{\plan_1, \plan_2, \ldots, \plan_n\} \text{ 为查询的所有可能执行计划}
\cost(\plan) = \cost_{IO}(\plan) + \cost_{CPU}(\plan) + \cost_{Memory}(\plan)
```

### 1.3 核心属性

- **正确性**: 保证查询结果正确
- **最优性**: 选择最低代价的执行计划
- **适应性**: 根据数据分布动态调整
- **可扩展性**: 支持复杂查询优化

## 2. 理论基础

### 2.1 查询代价模型

```latex
\begin{theorem}[查询代价模型]
查询代价由以下因素决定：
1. I/O代价：\cost_{IO} = \sum_{i} \text{page\_reads}_i \times \text{page\_cost}
2. CPU代价：\cost_{CPU} = \sum_{i} \text{tuples\_processed}_i \times \text{cpu\_tuple\_cost}
3. 内存代价：\cost_{Memory} = \text{memory\_usage} \times \text{memory\_cost}
\end{theorem}

\begin{proof}
基于系统资源消耗模型和实际性能测试，可以证明代价模型的准确性。
\end{proof}
```

### 2.2 查询重写理论

```latex
\begin{theorem}[查询重写等价性]
查询重写保持语义等价性：
\forall \query, \forall \plan_1, \plan_2 \in \mathcal{P}(\query):
\text{result}(\plan_1) = \text{result}(\plan_2) \Rightarrow \plan_1 \equiv \plan_2
\end{theorem}
```

### 2.3 连接顺序优化

```latex
\begin{theorem}[连接顺序最优性]
对于n个表的连接，最优连接顺序满足：
\min_{\sigma \in S_n} \cost(\text{join}_{\sigma(1)} \bowtie \text{join}_{\sigma(2)} \bowtie \ldots \bowtie \text{join}_{\sigma(n)})
\end{theorem}
```

## 3. PostgreSQL优化器架构

### 3.1 优化器组件

```sql
-- 查看优化器配置
SHOW enable_hashjoin;
SHOW enable_mergejoin;
SHOW enable_nestloop;
SHOW enable_seqscan;
SHOW enable_indexscan;
SHOW enable_bitmapscan;

-- 查看代价参数
SHOW seq_page_cost;
SHOW random_page_cost;
SHOW cpu_tuple_cost;
SHOW cpu_index_tuple_cost;
SHOW cpu_operator_cost;
```

### 3.2 查询解析

```sql
-- 查看查询解析树
EXPLAIN (VERBOSE, BUFFERS) 
SELECT e.name, d.dept_name, e.salary
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id
WHERE e.salary > 50000
ORDER BY e.salary DESC;

-- 查看查询重写
EXPLAIN (VERBOSE) 
SELECT * FROM employees WHERE emp_id IN (
    SELECT emp_id FROM employees WHERE salary > 50000
);
```

### 3.3 统计信息

```sql
-- 查看表统计信息
SELECT 
    schemaname,
    tablename,
    n_tup_ins,
    n_tup_upd,
    n_tup_del,
    n_live_tup,
    n_dead_tup,
    last_vacuum,
    last_autovacuum,
    last_analyze,
    last_autoanalyze
FROM pg_stat_user_tables;

-- 查看列统计信息
SELECT 
    schemaname,
    tablename,
    attname,
    n_distinct,
    correlation,
    most_common_vals,
    most_common_freqs,
    histogram_bounds
FROM pg_stats
WHERE schemaname = 'public' AND tablename = 'employees';
```

## 4. 查询重写优化

### 4.1 谓词下推

```sql
-- 谓词下推示例
EXPLAIN (ANALYZE, BUFFERS)
SELECT e.name, d.dept_name
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id
WHERE e.salary > 50000 AND d.budget > 1000000;

-- 子查询优化
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees 
WHERE dept_id IN (
    SELECT dept_id FROM departments WHERE budget > 1000000
);
```

### 4.2 常量折叠

```sql
-- 常量折叠示例
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees 
WHERE salary > 50000 + 1000;

-- 表达式简化
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees 
WHERE salary * 1.1 > 55000;
```

### 4.3 视图展开

```sql
-- 创建视图
CREATE VIEW emp_summary AS
SELECT dept_id, COUNT(*) as emp_count, AVG(salary) as avg_salary
FROM employees
GROUP BY dept_id;

-- 视图展开
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM emp_summary WHERE emp_count > 10;
```

## 5. 连接优化

### 5.1 连接算法选择

```sql
-- 嵌套循环连接
EXPLAIN (ANALYZE, BUFFERS)
SELECT e.name, d.dept_name
FROM employees e, departments d
WHERE e.dept_id = d.dept_id;

-- 哈希连接
EXPLAIN (ANALYZE, BUFFERS)
SELECT e.name, d.dept_name
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id;

-- 合并连接
EXPLAIN (ANALYZE, BUFFERS)
SELECT e.name, d.dept_name
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id
ORDER BY e.dept_id;
```

### 5.2 连接顺序优化

```sql
-- 多表连接
EXPLAIN (ANALYZE, BUFFERS)
SELECT e.name, d.dept_name, p.project_name
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id
JOIN projects p ON e.emp_id = p.manager_id
WHERE e.salary > 50000;

-- 强制连接顺序
SET join_collapse_limit = 1;
EXPLAIN (ANALYZE, BUFFERS)
SELECT e.name, d.dept_name, p.project_name
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id
JOIN projects p ON e.emp_id = p.manager_id
WHERE e.salary > 50000;
```

### 5.3 连接优化配置

```sql
-- 连接优化参数
SHOW join_collapse_limit;
SHOW from_collapse_limit;
SHOW geqo;
SHOW geqo_threshold;

-- 遗传查询优化
SET geqo = on;
SET geqo_threshold = 12;
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13
WHERE t1.id = t2.id AND t2.id = t3.id AND t3.id = t4.id;
```

## 6. 索引优化

### 6.1 索引选择

```sql
-- 查看索引使用情况
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE emp_id = 1001;

-- 复合索引优化
CREATE INDEX idx_emp_dept_salary ON employees (dept_id, salary);
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE dept_id = 1 AND salary > 50000;

-- 部分索引
CREATE INDEX idx_high_salary ON employees (salary) WHERE salary > 100000;
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE salary > 150000;
```

### 6.2 索引扫描优化

```sql
-- 索引扫描
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE emp_id BETWEEN 1000 AND 2000;

-- 位图索引扫描
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE dept_id = 1 AND salary > 50000;

-- 仅索引扫描
CREATE INDEX idx_emp_covering ON employees (dept_id) INCLUDE (name, salary);
EXPLAIN (ANALYZE, BUFFERS)
SELECT dept_id, name, salary FROM employees WHERE dept_id = 1;
```

## 7. 聚合优化

### 7.1 聚合算法

```sql
-- 哈希聚合
EXPLAIN (ANALYZE, BUFFERS)
SELECT dept_id, COUNT(*), AVG(salary)
FROM employees
GROUP BY dept_id;

-- 排序聚合
EXPLAIN (ANALYZE, BUFFERS)
SELECT dept_id, COUNT(*), AVG(salary)
FROM employees
GROUP BY dept_id
ORDER BY dept_id;

-- 分组聚合优化
EXPLAIN (ANALYZE, BUFFERS)
SELECT dept_id, COUNT(*), AVG(salary)
FROM employees
WHERE salary > 50000
GROUP BY dept_id
HAVING COUNT(*) > 5;
```

### 7.2 窗口函数优化

```sql
-- 窗口函数
EXPLAIN (ANALYZE, BUFFERS)
SELECT 
    name,
    salary,
    ROW_NUMBER() OVER (PARTITION BY dept_id ORDER BY salary DESC) as rank
FROM employees;

-- 窗口函数优化
EXPLAIN (ANALYZE, BUFFERS)
SELECT 
    name,
    salary,
    AVG(salary) OVER (PARTITION BY dept_id) as dept_avg
FROM employees
WHERE dept_id = 1;
```

## 8. 性能调优

### 8.1 优化器配置调优

```sql
-- 工作内存配置
SET work_mem = '256MB';
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM large_table1 t1
JOIN large_table2 t2 ON t1.id = t2.id;

-- 维护工作内存
SET maintenance_work_mem = '1GB';
VACUUM ANALYZE large_table;

-- 有效缓存大小
SET effective_cache_size = '8GB';
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE salary > 50000;
```

### 8.2 查询提示

```sql
-- 使用提示控制优化器
EXPLAIN (ANALYZE, BUFFERS)
SELECT /*+ HashJoin(e d) */ e.name, d.dept_name
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id;

-- 强制索引使用
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE emp_id = 1001;
-- 通过设置参数强制索引扫描
SET enable_seqscan = off;
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE emp_id = 1001;
```

## 9. 实际应用案例

### 9.1 复杂查询优化

```sql
-- 复杂分析查询
EXPLAIN (ANALYZE, BUFFERS)
WITH dept_stats AS (
    SELECT 
        dept_id,
        COUNT(*) as emp_count,
        AVG(salary) as avg_salary,
        MAX(salary) as max_salary
    FROM employees
    GROUP BY dept_id
),
ranked_employees AS (
    SELECT 
        e.*,
        ROW_NUMBER() OVER (PARTITION BY e.dept_id ORDER BY e.salary DESC) as salary_rank
    FROM employees e
)
SELECT 
    d.dept_name,
    ds.emp_count,
    ds.avg_salary,
    re.name as top_earner,
    re.salary as top_salary
FROM departments d
JOIN dept_stats ds ON d.dept_id = ds.dept_id
JOIN ranked_employees re ON d.dept_id = re.dept_id AND re.salary_rank = 1
WHERE ds.emp_count > 10
ORDER BY ds.avg_salary DESC;
```

### 9.2 大数据量查询优化

```sql
-- 分页查询优化
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM large_table
ORDER BY id
LIMIT 20 OFFSET 1000000;

-- 使用游标优化
BEGIN;
DECLARE cur CURSOR FOR 
SELECT * FROM large_table ORDER BY id;
FETCH 20 FROM cur;
FETCH 20 FROM cur;
CLOSE cur;
COMMIT;
```

## 10. 相关概念

### 10.1 上位概念

- **查询处理**: 更广泛的查询处理机制
- **数据库优化**: 数据库性能优化
- **执行引擎**: 查询执行机制

### 10.2 下位概念

- **代价模型**: 查询代价估算
- **查询重写**: 查询转换机制
- **连接优化**: 连接算法选择
- **索引优化**: 索引使用优化

### 10.3 平行概念

- **查询计划器**: 执行计划生成
- **统计信息**: 数据分布统计
- **执行引擎**: 查询执行机制

## 11. 参考文献

1. Selinger, P. G., et al. (1979). Access path selection in a relational database management system. ACM SIGMOD Record, 8(2), 23-34.
2. PostgreSQL Global Development Group. (2024). PostgreSQL 16.2 Documentation. <https://www.postgresql.org/docs/16/>
3. Graefe, G. (1995). The Cascades framework for query optimization. IEEE Data Engineering Bulletin, 18(3), 19-29.
4. Ioannidis, Y. E. (1996). Query optimization. ACM Computing Surveys, 28(1), 121-123.

## 12. Wikidata对齐

- **Wikidata ID**: Q192490
- **相关属性**:
  - P31: Q176165 (instance of: database management system)
  - P178: Q9366 (developer: PostgreSQL Global Development Group)
  - P277: Q193321 (programmed in: C)
  - P348: 16.2 (software version)
- **外部链接**:
  - <https://www.postgresql.org/docs/current/planner-optimizer.html>
  - <https://www.postgresql.org/docs/current/runtime-config-query.html>

## 合并来源与映射（整合中）

- 1.1.4-查询优化.md
- 1.1.4-查询优化-增强版.md
- 1.1.7-查询优化.md
- 1.1.148-PostgreSQL查询优化器国际化标准定义.md
- 1.1.49-选择率估计误差-敏感性与上界.md（误差界与统计部分链接至 02.03）

### 待办

- [ ] 统一代价模型与统计接口描述
- [ ] 去重连接顺序与访问路径章节
- [ ] 将部分形式化证明外链 06.04
