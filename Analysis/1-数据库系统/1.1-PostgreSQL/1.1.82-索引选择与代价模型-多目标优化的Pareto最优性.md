# 1.1.82 索引选择与代价模型：多目标优化的 Pareto 最优性

## 1. 问题建模

- 给定查询集合 \(\{Q_i\}\) 与候选索引集合 \(\{I_j\}\)，目标在约束（存储S、维护M）下最小化多目标：
  - 查询代价 \(C_{run}(I)\)、维护代价 \(C_{maint}(I)\)、存储占用 \(C_{stor}(I)\)。
- 形成向量目标 \(F(I)=(C_{run}, C_{maint}, C_{stor})\)，定义Pareto支配与前沿。

## 2. Pareto 前沿

- 定义：不存在另一解 \(I'\) 使 \(F(I') \preceq F(I)\) 且至少一维严格更优。
- 策略：
  - 加权和：最小化 \(w\cdot F(I)\)（需调权）；
  - ε-约束：固定维护/存储阈值，最小化运行代价；
  - 分层：先筛存储与维护可行区，再在可行集中最小化运行代价。

## 3. 选择与组合

- 候选生成：从谓词与排序键提取（列、顺序、包含列）；
- 互斥与互补：覆盖索引与复合索引组合、部分索引、表达式索引；
- 运行时影响：位图合并、跳跃扫描、仅索引扫描的可用性。

## 4. 启发式与示例

```sql
-- 候选生成（示意）
CREATE INDEX idx_orders_customer_status ON orders (customer_id, status) INCLUDE (created_at, amount);
CREATE INDEX idx_orders_created_at ON orders (created_at);
CREATE INDEX idx_orders_amount_part ON orders (amount) WHERE status = 'paid';

-- 评估（EXPLAIN 采样查询 + 指标记录）
EXPLAIN (ANALYZE, BUFFERS) SELECT * FROM orders WHERE customer_id=123 AND status='paid';
```

- 启发式：
  - 高频等值→前缀列；范围次序靠后；常用覆盖列置于 INCLUDE；
  - 热点谓词使用部分/表达式索引；
  - 与分区策略耦合设计：分区键优先。

## 5. 统计误差与鲁棒性

- 结合 `1.1.49` 的误差模型，以鲁棒选择降低阈值翻转风险：
  - 在不确定集上比较计划代价的最坏情况；
  - 对临界查询保留冗余索引以防误差放大。

## 6. 持续评估与回收

- 监控 `pg_stat_user_indexes` 与 `pg_statio_user_indexes`：低 `idx_scan` 且高维护代价的索引进入回收候选；
- A/B 对照：灰度删除观察回退路径代价；
- 定期重建/重组高膨胀索引，维护覆盖列变更后的统计。

## 7. 交叉引用

- `02-查询处理/02.02-索引结构与优化.md`
- `1.1.58-部分索引与约束排除-语义与正确性.md`
- `1.1.49-选择率估计误差-敏感性与上界.md`
- `1.1.60-物化视图选择-查询重写等价与代价界.md`
