---
title: 1.1.69-两阶段加锁-可串行化的严格证明
slug: 1.1.69-两阶段加锁-可串行化的严格证明
tags: []
pg_version: 16
status: draft
last_review: 2025-09-12
owner: TBD
---

﻿# 1.1.69-两阶段加锁-可串行化的严格证明

> 目标：给出冲突可串行化（Conflict-Serializability）条件下，两阶段加锁（2PL）策略保证可串行化的严格证明框架与示例。

## 1. 预备定义

- 操作与调度：读/写操作序列构成调度 \( S \)，同一事务的操作保持程序顺序。
- 冲突：对同一数据项 \( x \) 的操作对 \( (o_i(x), o_j(x)) \)，若至少有一方为写且事务不同则冲突。
- 冲突图（先行图）\( G(S) \)：结点为事务集合 \( V = \{T_1,\dots,T_n\} \)，若 \( T_i \) 与 \( T_j \) 存在冲突且 \( o_i \) 先于 \( o_j \) 则加边 \( T_i \to T_j \)。
- 可串行化：若 \( G(S) \) 无环，则 \( S \) 与某串行调度冲突等价。

## 2. 两阶段加锁（2PL）

- 定义（强2PL）：每个事务的加锁阶段与解锁阶段不交叠，即所有锁先获取后统一释放（在 `COMMIT/ROLLBACK` 时）。
- 锁兼容：`R/S` 共享读锁可兼容，`W/X` 排它写锁与其他锁不兼容；升级/降级视实现策略（`1.1.75`）。

## 3. 定理与证明

**定理 1（2PL ⇒ 冲突可串行化）**
若所有事务遵循强两阶段加锁，则任意结果调度 \( S \) 的先行图 \( G(S) \) 无环，因而 \( S \) 冲突可串行化。

证明要点：

1) 设反证 \( G(S) \) 存在有向环 \( T_1 \to T_2 \to \cdots \to T_k \to T_1 \)。
2) 每条边由某对冲突操作诱导。由于强2PL，冲突对上的锁顺序决定了加锁的偏序。
3) 环意味着存在一组锁获取次序的循环依赖；但在强2PL中，持锁到提交，任一形成 \( T_i \to T_j \) 的冲突要求 \( T_i \) 在 \( T_j \) 获取锁前已持有不兼容锁，从而阻止 \( T_j \) 继续，破坏形成闭环的可能。
4) 与死锁不同，死锁发生于运行时等待；而可串行化性质关乎完成后调度的等价类。强2PL通过锁持有到边界确保存在一个按锁释放顺序线性扩展的串行序。
5) 由此矛盾，\( G(S) \) 无环，证毕。

备注：更形式化的证明可构造“锁点序”作为拓扑序：对每个事务定义锁点 \( LP(T) \) 为其最后一个锁获取时间点。强2PL下，若存在冲突 \( T_i \to T_j \)，必有 \( LP(T_i) < LP(T_j) \)。据此以 \( LP \) 严格递增排序得到串行序。

**推论 1（严格2PL）**
若写锁延迟到提交后才释放（严格2PL），则除可串行化外，还能避免级联回滚；但并发度与等待时间可能上升。

## 4. 反例与边界

- 非2PL策略可产生含环先行图，从而不可串行：例如事务中加锁—解锁—再加锁的“解锁后再加锁”模式。
- 局部解锁：若事务提前释放读锁而后续再获取其他数据的写锁，可能允许穿插导致环。

## 5. 小型示例

```text
T1: lock-X(A); write(A); lock-X(B); write(B); commit;
T2:           lock-X(B); write(B); lock-X(A); write(A); commit;
```

- 在强2PL下：T1拿到A后持有至提交；T2在B上与T1冲突时会等待，消除交叉写的不可串行次序。最终调度等价于 `T1→T2` 或 `T2→T1` 的某一串行化。
- 若允许T1写完A立即解锁再去锁B，同时T2写完B立即解锁再去锁A，运行上可能互相穿插构成环，破坏可串行化。

## 6. 与PostgreSQL的关系

- PostgreSQL并不以2PL作为主并发控制（其核心为MVCC + 锁 + SSI）；但在需要强隔离保证的热点互斥场景，可通过显式锁策略近似2PL效果。
- 与SSI的对比：SSI在Snapshot隔离上附加危险结构检测，无需全程持锁；2PL以锁偏序直接确保可串行化。

## 7. 参考与交叉

- `1.1.54-调度等价-冲突与视图等价的充要关系.md`
- `1.1.48-谓词锁与幽灵现象-形式化与消除条件.md`
- `1.1.61-快照隔离异常谱系-形式分类与必要条件.md`
- `1.1.75-锁升级与降级-安全性与死锁影响的形式证明.md`
