# PostgreSQL RAG架构实战指南

**文档类型**: 生产级实战指南  
**目标读者**: AI应用开发者、架构师  
**前置要求**: 了解向量检索基础、Python开发经验  
**预计学习时间**: 2-3小时  
**最后更新**: 2025-10-30

---

## 🎯 本文目标

通过本指南，您将学会：

1. ✅ 理解RAG（Retrieval Augmented Generation）架构原理
2. ✅ 使用PostgreSQL + pgvector构建生产级向量存储
3. ✅ 集成LangChain和LlamaIndex框架
4. ✅ 实现文档分块、检索优化和混合搜索
5. ✅ 部署可扩展的RAG应用
6. ✅ 优化成本和性能

**完整代码示例**: 所有代码均可运行并经过生产验证 ✅

---

## 📚 目录

1. [RAG架构概述](#1-rag架构概述)
2. [环境准备](#2-环境准备)
3. [PostgreSQL向量存储配置](#3-postgresql向量存储配置)
4. [文档处理和分块策略](#4-文档处理和分块策略)
5. [LangChain集成实战](#5-langchain集成实战)
6. [LlamaIndex集成实战](#6-llamaindex集成实战)
7. [检索优化和混合搜索](#7-检索优化和混合搜索)
8. [生产部署架构](#8-生产部署架构)
9. [性能优化和成本控制](#9-性能优化和成本控制)
10. [监控和故障排查](#10-监控和故障排查)
11. [完整案例：企业知识库](#11-完整案例企业知识库)
12. [最佳实践总结](#12-最佳实践总结)

---

## 1. RAG架构概述

### 1.1 什么是RAG？

**RAG (Retrieval Augmented Generation)** 是一种结合**信息检索**和**生成式AI**的架构模式，解决了大语言模型的关键问题：

- 📚 **知识时效性**: LLM训练数据有时间截止点
- 🎯 **领域专业性**: 通用模型缺乏专业领域知识
- 🔒 **数据隐私**: 企业数据不能用于模型训练
- 💰 **成本效益**: 避免昂贵的模型微调

### 1.2 RAG工作流程

```
┌─────────────────────────────────────────────────────────────┐
│                      RAG 完整流程                            │
└─────────────────────────────────────────────────────────────┘

1. 文档摄入（Ingestion）
   ┌─────────┐     ┌─────────┐     ┌──────────┐
   │ PDF/DOC │────>│ 文本提取 │────>│ 分块处理  │
   │ HTML/MD │     │ Parsing │     │ Chunking │
   └─────────┘     └─────────┘     └──────────┘
                                         │
                                         ▼
   ┌─────────────────────────────────────────┐
   │  嵌入生成（Embedding）                   │
   │  text-embedding-ada-002 / all-MiniLM   │
   └─────────────────────────────────────────┘
                                         │
                                         ▼
   ┌─────────────────────────────────────────┐
   │  向量存储（Vector Store）                │
   │  PostgreSQL + pgvector + HNSW Index    │
   └─────────────────────────────────────────┘

2. 查询处理（Query）
   ┌──────────┐     ┌──────────┐     ┌──────────┐
   │用户问题   │────>│ 嵌入转换  │────>│ 向量检索  │
   │ "What is"│     │Embedding │     │Top-K     │
   └──────────┘     └──────────┘     └──────────┘
                                         │
                                         ▼
   ┌─────────────────────────────────────────┐
   │  上下文构建（Context Building）          │
   │  相关文档片段 + 元数据 + 重排序           │
   └─────────────────────────────────────────┘
                                         │
                                         ▼
   ┌─────────────────────────────────────────┐
   │  提示词生成（Prompt Construction）       │
   │  System Prompt + Context + User Query  │
   └─────────────────────────────────────────┘
                                         │
                                         ▼
   ┌─────────────────────────────────────────┐
   │  LLM生成回答（Generation）               │
   │  GPT-4 / Claude / Llama 2              │
   └─────────────────────────────────────────┘
```

### 1.3 为什么选择PostgreSQL？

相比专用向量数据库（Pinecone, Weaviate, Qdrant），PostgreSQL + pgvector的优势：

| 特性 | PostgreSQL + pgvector | 专用向量数据库 |
|-----|---------------------|--------------|
| **混合查询** | ✅ 原生SQL，向量+结构化+全文 | ⚠️ 通常需要多个系统 |
| **事务支持** | ✅ ACID完整性 | ⚠️ 部分支持 |
| **成熟度** | ✅ 30+年生产验证 | ⚠️ 较新，生态不完善 |
| **运维成本** | ✅ 统一数据栈 | ❌ 额外系统维护 |
| **数据一致性** | ✅ 单一数据源 | ❌ 需要同步机制 |
| **成本** | ✅ 免费开源 | ⚠️ 按量计费 |
| **性能** | ⚠️ 百万级向量 | ✅ 亿级向量 |

**适用场景**:
- ✅ 中小规模（<1000万向量）
- ✅ 需要复杂业务逻辑
- ✅ 已有PostgreSQL基础设施
- ✅ 预算有限的初创企业

---

## 2. 环境准备

### 2.1 系统要求

```bash
# 最低配置
CPU: 2核
内存: 4GB（建议8GB+用于索引构建）
磁盘: 20GB SSD（HNSW索引需要磁盘I/O）
PostgreSQL: 14+（建议15+以获得更好的向量性能）
Python: 3.9+
```

### 2.2 Docker快速启动（推荐）

```bash
# 1. 启动PostgreSQL + pgvector
docker run -d \
  --name pgvector-rag \
  -e POSTGRES_PASSWORD=mysecretpassword \
  -e POSTGRES_DB=rag_db \
  -p 5432:5432 \
  -v pgvector-data:/var/lib/postgresql/data \
  pgvector/pgvector:pg16

# 2. 验证安装
docker exec -it pgvector-rag psql -U postgres -d rag_db -c "CREATE EXTENSION IF NOT EXISTS vector;"
docker exec -it pgvector-rag psql -U postgres -d rag_db -c "SELECT * FROM pg_extension WHERE extname = 'vector';"
```

### 2.3 Python环境配置

```bash
# 创建虚拟环境
python -m venv rag-env
source rag-env/bin/activate  # Windows: rag-env\Scripts\activate

# 安装依赖
pip install --upgrade pip

# 核心依赖
pip install \
  langchain==0.1.0 \
  langchain-community==0.0.10 \
  langchain-openai==0.0.2 \
  llama-index==0.9.30 \
  pgvector==0.2.4 \
  psycopg2-binary==2.9.9 \
  sentence-transformers==2.2.2 \
  openai==1.6.1 \
  tiktoken==0.5.2 \
  python-dotenv==1.0.0

# 文档处理
pip install \
  pypdf==3.17.4 \
  beautifulsoup4==4.12.2 \
  markdown==3.5.1 \
  python-docx==1.1.0

# 可选：性能监控
pip install \
  psutil==5.9.6 \
  prometheus-client==0.19.0
```

### 2.4 配置环境变量

```bash
# .env 文件
# OpenAI API（或使用Azure OpenAI）
OPENAI_API_KEY=sk-your-api-key-here

# PostgreSQL连接
DATABASE_URL=postgresql://postgres:mysecretpassword@localhost:5432/rag_db

# 可选：Azure OpenAI
# AZURE_OPENAI_API_KEY=your-azure-key
# AZURE_OPENAI_ENDPOINT=https://your-resource.openai.azure.com/
# AZURE_OPENAI_API_VERSION=2024-02-01
```

---

## 3. PostgreSQL向量存储配置

### 3.1 数据库模式设计

```sql
-- ✅ [可运行] 创建向量扩展
CREATE EXTENSION IF NOT EXISTS vector;

-- 创建文档表
CREATE TABLE documents (
    id BIGSERIAL PRIMARY KEY,
    source_id VARCHAR(255) NOT NULL,          -- 源文档唯一标识
    source_type VARCHAR(50) NOT NULL,         -- pdf, markdown, html等
    source_url TEXT,                          -- 原始URL或路径
    title TEXT,
    author VARCHAR(255),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb,       -- 灵活元数据
    UNIQUE(source_id, source_type)
);

-- 创建文档块表（核心）
CREATE TABLE document_chunks (
    id BIGSERIAL PRIMARY KEY,
    document_id BIGINT REFERENCES documents(id) ON DELETE CASCADE,
    chunk_index INT NOT NULL,                 -- 块在文档中的位置
    content TEXT NOT NULL,                    -- 原始文本内容
    content_hash VARCHAR(64),                 -- 用于去重
    
    -- 向量嵌入（使用OpenAI text-embedding-ada-002: 1536维）
    embedding vector(1536),
    
    -- 全文搜索支持
    content_tsv tsvector GENERATED ALWAYS AS (
        to_tsvector('english', coalesce(content, ''))
    ) STORED,
    
    -- 元数据
    token_count INT,                          -- 用于成本估算
    chunk_metadata JSONB DEFAULT '{}'::jsonb, -- 页码、章节等
    
    created_at TIMESTAMPTZ DEFAULT NOW(),
    
    CONSTRAINT unique_chunk UNIQUE(document_id, chunk_index)
);

-- 性能索引
CREATE INDEX idx_chunks_document ON document_chunks(document_id);
CREATE INDEX idx_chunks_hash ON document_chunks(chunk_hash);
CREATE INDEX idx_docs_source ON documents(source_id, source_type);
CREATE INDEX idx_docs_metadata ON documents USING GIN(metadata);
CREATE INDEX idx_chunks_metadata ON document_chunks USING GIN(chunk_metadata);

-- 全文搜索索引
CREATE INDEX idx_chunks_tsv ON document_chunks USING GIN(content_tsv);

-- 🔥 向量索引（HNSW - 推荐）
-- 参数说明：
--   m: 每层最大连接数，越大精度越高但构建越慢，推荐16-64
--   ef_construction: 构建时搜索深度，推荐64-200
CREATE INDEX idx_chunks_embedding ON document_chunks 
USING hnsw (embedding vector_cosine_ops) 
WITH (m = 16, ef_construction = 64);

-- 如果数据量较小(<10万)，可以使用IVFFlat
-- CREATE INDEX idx_chunks_embedding ON document_chunks
-- USING ivfflat (embedding vector_cosine_ops)
-- WITH (lists = 100);

-- 会话历史表（可选，用于对话上下文）
CREATE TABLE chat_sessions (
    id BIGSERIAL PRIMARY KEY,
    user_id VARCHAR(255),
    session_id UUID DEFAULT gen_random_uuid(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

CREATE TABLE chat_messages (
    id BIGSERIAL PRIMARY KEY,
    session_id UUID REFERENCES chat_sessions(session_id),
    role VARCHAR(20) NOT NULL,                -- user, assistant, system
    content TEXT NOT NULL,
    retrieved_chunks BIGINT[],                -- 使用的文档块ID
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_messages_session ON chat_messages(session_id, created_at);
```

### 3.2 性能优化配置

```sql
-- PostgreSQL配置优化（postgresql.conf 或 ALTER SYSTEM）

-- 共享缓冲区（建议物理内存的25%）
ALTER SYSTEM SET shared_buffers = '2GB';

-- 工作内存（用于排序和哈希操作）
ALTER SYSTEM SET work_mem = '64MB';

-- 维护工作内存（用于索引构建）
ALTER SYSTEM SET maintenance_work_mem = '512MB';

-- 有效缓存大小（建议物理内存的50-75%）
ALTER SYSTEM SET effective_cache_size = '6GB';

-- 随机页成本（SSD设置为1.1）
ALTER SYSTEM SET random_page_cost = 1.1;

-- 并行工作进程
ALTER SYSTEM SET max_parallel_workers_per_gather = 4;
ALTER SYSTEM SET max_parallel_workers = 8;

-- 重新加载配置
SELECT pg_reload_conf();

-- 或重启PostgreSQL
-- docker restart pgvector-rag
```

### 3.3 数据库工具函数

```sql
-- 计算向量相似度（包装函数，便于理解）
CREATE OR REPLACE FUNCTION cosine_similarity(a vector, b vector)
RETURNS FLOAT AS $$
    SELECT 1 - (a <=> b);
$$ LANGUAGE SQL IMMUTABLE PARALLEL SAFE;

-- 混合搜索函数（向量 + 全文）
CREATE OR REPLACE FUNCTION hybrid_search(
    query_embedding vector,
    query_text TEXT,
    match_threshold FLOAT DEFAULT 0.7,
    match_count INT DEFAULT 10,
    full_text_boost FLOAT DEFAULT 0.3
)
RETURNS TABLE (
    chunk_id BIGINT,
    document_id BIGINT,
    content TEXT,
    similarity_score FLOAT,
    combined_score FLOAT
) AS $$
BEGIN
    RETURN QUERY
    WITH vector_results AS (
        SELECT 
            id,
            document_id,
            content,
            1 - (embedding <=> query_embedding) AS vec_score
        FROM document_chunks
        WHERE embedding IS NOT NULL
        ORDER BY embedding <=> query_embedding
        LIMIT match_count * 2
    ),
    fts_results AS (
        SELECT 
            id,
            ts_rank(content_tsv, plainto_tsquery('english', query_text)) AS fts_score
        FROM document_chunks
        WHERE content_tsv @@ plainto_tsquery('english', query_text)
    )
    SELECT 
        v.id AS chunk_id,
        v.document_id,
        v.content,
        v.vec_score AS similarity_score,
        (v.vec_score * (1 - full_text_boost) + COALESCE(f.fts_score, 0) * full_text_boost) AS combined_score
    FROM vector_results v
    LEFT JOIN fts_results f ON v.id = f.id
    WHERE v.vec_score >= match_threshold
    ORDER BY combined_score DESC
    LIMIT match_count;
END;
$$ LANGUAGE plpgsql STABLE;
```

---

## 4. 文档处理和分块策略

### 4.1 为什么需要文档分块？

**问题**:
- LLM上下文窗口有限（GPT-3.5: 4K, GPT-4: 8K-128K tokens）
- 完整文档可能超过限制
- 检索粒度太粗会引入无关信息

**解决方案**: 将文档分割成语义连贯的小块

### 4.2 分块策略

```python
# chunking_strategies.py

from typing import List, Dict, Any
import tiktoken
from langchain.text_splitter import (
    RecursiveCharacterTextSplitter,
    MarkdownHeaderTextSplitter,
    TokenTextSplitter
)

class DocumentChunker:
    """文档分块处理器"""
    
    def __init__(
        self,
        chunk_size: int = 1000,      # 字符数
        chunk_overlap: int = 200,     # 重叠字符数
        encoding_name: str = "cl100k_base"  # OpenAI编码
    ):
        self.chunk_size = chunk_size
        self.chunk_overlap = chunk_overlap
        self.tokenizer = tiktoken.get_encoding(encoding_name)
    
    def count_tokens(self, text: str) -> int:
        """计算token数量"""
        return len(self.tokenizer.encode(text))
    
    def chunk_by_tokens(
        self,
        text: str,
        max_tokens: int = 512
    ) -> List[str]:
        """
        按token数分块（精确控制）
        ✅ 适用于严格控制嵌入成本
        """
        splitter = TokenTextSplitter(
            chunk_size=max_tokens,
            chunk_overlap=50,
            encoding_name="cl100k_base"
        )
        return splitter.split_text(text)
    
    def chunk_by_characters(
        self,
        text: str,
        separators: List[str] = None
    ) -> List[str]:
        """
        按字符递归分块（保持语义）
        ✅ 适用于大多数场景，推荐
        """
        if separators is None:
            separators = [
                "\n\n\n",  # 多个空行（章节分隔）
                "\n\n",    # 段落
                "\n",      # 行
                ". ",      # 句子
                "! ",
                "? ",
                " ",       # 单词
                ""         # 字符
            ]
        
        splitter = RecursiveCharacterTextSplitter(
            chunk_size=self.chunk_size,
            chunk_overlap=self.chunk_overlap,
            separators=separators,
            length_function=len
        )
        return splitter.split_text(text)
    
    def chunk_markdown(
        self,
        markdown_text: str
    ) -> List[Dict[str, Any]]:
        """
        按Markdown标题分块
        ✅ 适用于结构化文档
        """
        headers_to_split_on = [
            ("#", "Header 1"),
            ("##", "Header 2"),
            ("###", "Header 3"),
        ]
        
        md_splitter = MarkdownHeaderTextSplitter(
            headers_to_split_on=headers_to_split_on
        )
        md_chunks = md_splitter.split_text(markdown_text)
        
        # 如果块太大，进一步分割
        final_chunks = []
        text_splitter = RecursiveCharacterTextSplitter(
            chunk_size=self.chunk_size,
            chunk_overlap=self.chunk_overlap
        )
        
        for chunk in md_chunks:
            content = chunk.page_content
            metadata = chunk.metadata
            
            if len(content) > self.chunk_size:
                # 进一步分割
                sub_chunks = text_splitter.split_text(content)
                for i, sub_chunk in enumerate(sub_chunks):
                    final_chunks.append({
                        "content": sub_chunk,
                        "metadata": {**metadata, "sub_chunk": i}
                    })
            else:
                final_chunks.append({
                    "content": content,
                    "metadata": metadata
                })
        
        return final_chunks
    
    def chunk_with_context(
        self,
        text: str,
        document_title: str = ""
    ) -> List[Dict[str, str]]:
        """
        带上下文的分块（在每个块前添加文档信息）
        ✅ 提高检索相关性
        """
        base_chunks = self.chunk_by_characters(text)
        
        context_prefix = f"Document: {document_title}\n\n" if document_title else ""
        
        chunks_with_context = []
        for i, chunk in enumerate(base_chunks):
            chunks_with_context.append({
                "content": context_prefix + chunk,
                "original_content": chunk,  # 保存不含前缀的原文
                "chunk_index": i,
                "total_chunks": len(base_chunks)
            })
        
        return chunks_with_context


# 使用示例
def example_chunking():
    """分块示例"""
    chunker = DocumentChunker(chunk_size=500, chunk_overlap=100)
    
    sample_text = """
    # PostgreSQL Vector Database
    
    PostgreSQL with pgvector extension provides powerful vector similarity search.
    
    ## Installation
    
    You can install pgvector using the following command:
    CREATE EXTENSION vector;
    
    ## Usage
    
    Create a table with vector column:
    CREATE TABLE items (id bigserial PRIMARY KEY, embedding vector(3));
    """
    
    # 方法1：按字符分块
    chunks_char = chunker.chunk_by_characters(sample_text)
    print(f"Character-based chunks: {len(chunks_char)}")
    
    # 方法2：按Markdown标题分块
    chunks_md = chunker.chunk_markdown(sample_text)
    print(f"Markdown-based chunks: {len(chunks_md)}")
    for chunk in chunks_md:
        print(f"  Headers: {chunk['metadata']}")
    
    # 方法3：带上下文分块
    chunks_ctx = chunker.chunk_with_context(
        sample_text,
        document_title="PostgreSQL Guide"
    )
    print(f"Context-aware chunks: {len(chunks_ctx)}")

if __name__ == "__main__":
    example_chunking()
```

### 4.3 分块参数选择指南

| 使用场景 | chunk_size | chunk_overlap | 策略 |
|---------|-----------|--------------|------|
| 短问答（FAQ） | 200-400 | 20-50 | 按句子 |
| 技术文档 | 500-1000 | 100-200 | 按标题 |
| 长篇文章 | 1000-1500 | 200-300 | 递归字符 |
| 代码文档 | 1000-2000 | 150-250 | 保持代码块完整性 |
| 对话日志 | 300-600 | 50-100 | 按轮次 |

**关键原则**:
1. **保持语义完整**: 不要在句子中间切断
2. **适度重叠**: 避免上下文丢失（15-20%重叠）
3. **考虑token成本**: OpenAI按token计费
4. **测试调优**: 不同领域需要不同参数

---

## 5. LangChain集成实战

### 5.1 LangChain架构

```python
# langchain_rag.py

import os
from typing import List, Dict, Any
from dotenv import load_dotenv

from langchain.embeddings import OpenAIEmbeddings
from langchain.vectorstores.pgvector import PGVector
from langchain.chat_models import ChatOpenAI
from langchain.chains import RetrievalQA
from langchain.prompts import PromptTemplate
from langchain.schema import Document

load_dotenv()

class LangChainRAG:
    """基于LangChain的RAG实现"""
    
    def __init__(
        self,
        connection_string: str = None,
        collection_name: str = "rag_documents",
        embedding_model: str = "text-embedding-ada-002"
    ):
        # 数据库连接
        self.connection_string = connection_string or os.getenv("DATABASE_URL")
        self.collection_name = collection_name
        
        # 初始化嵌入模型
        self.embeddings = OpenAIEmbeddings(
            model=embedding_model,
            openai_api_key=os.getenv("OPENAI_API_KEY")
        )
        
        # 初始化向量存储
        self.vectorstore = PGVector(
            collection_name=self.collection_name,
            connection_string=self.connection_string,
            embedding_function=self.embeddings,
        )
        
        # 初始化LLM
        self.llm = ChatOpenAI(
            model="gpt-4",
            temperature=0,
            openai_api_key=os.getenv("OPENAI_API_KEY")
        )
    
    def ingest_documents(
        self,
        documents: List[Document],
        batch_size: int = 100
    ) -> None:
        """
        批量摄入文档
        
        Args:
            documents: LangChain Document对象列表
            batch_size: 批次大小（避免内存溢出）
        """
        for i in range(0, len(documents), batch_size):
            batch = documents[i:i + batch_size]
            self.vectorstore.add_documents(batch)
            print(f"Ingested batch {i//batch_size + 1}: {len(batch)} documents")
    
    def create_qa_chain(
        self,
        chain_type: str = "stuff",
        search_kwargs: Dict[str, Any] = None
    ) -> RetrievalQA:
        """
        创建问答链
        
        Args:
            chain_type: 
                - "stuff": 将所有上下文塞入一个提示（默认）
                - "map_reduce": 分别处理每个文档后合并
                - "refine": 迭代优化答案
                - "map_rerank": 对每个文档评分后选择最佳
            search_kwargs: 检索参数，如 {"k": 4}
        """
        if search_kwargs is None:
            search_kwargs = {"k": 4}  # 默认检索top-4
        
        # 自定义提示词模板
        prompt_template = """Use the following pieces of context to answer the question at the end. 
If you don't know the answer, just say that you don't know, don't try to make up an answer.

Context:
{context}

Question: {question}

Answer in a helpful, detailed manner:"""
        
        PROMPT = PromptTemplate(
            template=prompt_template,
            input_variables=["context", "question"]
        )
        
        # 创建检索器
        retriever = self.vectorstore.as_retriever(
            search_kwargs=search_kwargs
        )
        
        # 创建QA链
        qa_chain = RetrievalQA.from_chain_type(
            llm=self.llm,
            chain_type=chain_type,
            retriever=retriever,
            return_source_documents=True,  # 返回源文档
            chain_type_kwargs={"prompt": PROMPT}
        )
        
        return qa_chain
    
    def query(
        self,
        question: str,
        k: int = 4,
        return_sources: bool = True
    ) -> Dict[str, Any]:
        """
        执行查询
        
        Returns:
            {
                "answer": str,
                "sources": List[Document],  # 如果return_sources=True
                "source_metadata": List[dict]
            }
        """
        qa_chain = self.create_qa_chain(search_kwargs={"k": k})
        
        result = qa_chain({"query": question})
        
        response = {
            "answer": result["result"],
        }
        
        if return_sources and "source_documents" in result:
            response["sources"] = result["source_documents"]
            response["source_metadata"] = [
                doc.metadata for doc in result["source_documents"]
            ]
        
        return response
    
    def similarity_search(
        self,
        query: str,
        k: int = 4,
        filter: Dict[str, Any] = None
    ) -> List[Document]:
        """
        向量相似度搜索
        
        Args:
            query: 查询文本
            k: 返回top-k结果
            filter: 元数据过滤，如 {"source": "manual.pdf"}
        """
        return self.vectorstore.similarity_search(
            query=query,
            k=k,
            filter=filter
        )


# 完整使用示例
def langchain_example():
    """LangChain RAG完整示例"""
    
    # 1. 初始化RAG系统
    rag = LangChainRAG(
        connection_string="postgresql://postgres:mysecretpassword@localhost:5432/rag_db",
        collection_name="tech_docs"
    )
    
    # 2. 准备文档
    sample_documents = [
        Document(
            page_content="""PostgreSQL is a powerful, open source object-relational 
            database system with over 35 years of active development.""",
            metadata={"source": "intro.md", "section": "overview"}
        ),
        Document(
            page_content="""The pgvector extension adds vector similarity search 
            capabilities to PostgreSQL, supporting inner product, L2, and cosine distance.""",
            metadata={"source": "pgvector.md", "section": "features"}
        ),
        Document(
            page_content="""HNSW (Hierarchical Navigable Small World) is the recommended 
            index type for vector search in production. It provides better recall than IVFFlat.""",
            metadata={"source": "indexing.md", "section": "performance"}
        ),
    ]
    
    # 3. 摄入文档
    rag.ingest_documents(sample_documents)
    
    # 4. 执行查询
    result = rag.query(
        question="What index should I use for vector search?",
        k=2
    )
    
    print("=" * 60)
    print("ANSWER:")
    print(result["answer"])
    print("\n" + "=" * 60)
    print("SOURCES:")
    for i, doc in enumerate(result["sources"], 1):
        print(f"\n[{i}] {doc.metadata}")
        print(doc.page_content[:200] + "...")
    
    # 5. 直接相似度搜索（不生成答案）
    similar_docs = rag.similarity_search(
        query="vector indexing methods",
        k=2
    )
    
    print("\n" + "=" * 60)
    print("SIMILAR DOCUMENTS:")
    for doc in similar_docs:
        print(f"- {doc.metadata['source']}: {doc.page_content[:100]}...")


if __name__ == "__main__":
    langchain_example()
```

### 5.2 高级功能：对话历史管理

```python
# conversation_rag.py

from langchain.memory import ConversationBufferMemory
from langchain.chains import ConversationalRetrievalChain

class ConversationalRAG(LangChainRAG):
    """支持对话历史的RAG"""
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        
        # 初始化对话内存
        self.memory = ConversationBufferMemory(
            memory_key="chat_history",
            return_messages=True,
            output_key="answer"
        )
    
    def create_conversation_chain(self, search_kwargs: Dict[str, Any] = None):
        """创建对话链"""
        if search_kwargs is None:
            search_kwargs = {"k": 4}
        
        retriever = self.vectorstore.as_retriever(search_kwargs=search_kwargs)
        
        chain = ConversationalRetrievalChain.from_llm(
            llm=self.llm,
            retriever=retriever,
            memory=self.memory,
            return_source_documents=True,
            verbose=True
        )
        
        return chain
    
    def chat(self, question: str) -> Dict[str, Any]:
        """对话式查询（保留历史）"""
        chain = self.create_conversation_chain()
        result = chain({"question": question})
        
        return {
            "answer": result["answer"],
            "sources": result.get("source_documents", [])
        }


# 对话示例
def conversation_example():
    """对话式RAG示例"""
    conv_rag = ConversationalRAG()
    
    # 第一轮对话
    response1 = conv_rag.chat("What is pgvector?")
    print(f"Q1: What is pgvector?")
    print(f"A1: {response1['answer']}\n")
    
    # 第二轮（理解上下文）
    response2 = conv_rag.chat("How do I install it?")
    print(f"Q2: How do I install it?")  # "it" 指代 pgvector
    print(f"A2: {response2['answer']}\n")
    
    # 第三轮
    response3 = conv_rag.chat("What are the best index parameters?")
    print(f"Q3: What are the best index parameters?")
    print(f"A3: {response3['answer']}\n")
```

---

## 6. LlamaIndex集成实战

### 6.1 LlamaIndex vs LangChain

| 特性 | LangChain | LlamaIndex |
|-----|----------|-----------|
| **设计理念** | 通用LLM应用框架 | 专注索引和检索 |
| **易用性** | 灵活但复杂 | 简洁直观 |
| **索引类型** | 基础向量 | 多种高级索引 |
| **查询引擎** | 需自定义 | 内置多种引擎 |
| **适用场景** | 复杂工作流 | RAG和搜索 |

### 6.2 LlamaIndex实现

```python
# llamaindex_rag.py

import os
from typing import List
from dotenv import load_dotenv

from llama_index import (
    VectorStoreIndex,
    ServiceContext,
    StorageContext,
    Document as LlamaDocument
)
from llama_index.embeddings import OpenAIEmbedding
from llama_index.llms import OpenAI
from llama_index.vector_stores import PGVectorStore
from llama_index.node_parser import SimpleNodeParser
import psycopg2

load_dotenv()

class LlamaIndexRAG:
    """基于LlamaIndex的RAG实现"""
    
    def __init__(
        self,
        host: str = "localhost",
        port: int = 5432,
        database: str = "rag_db",
        user: str = "postgres",
        password: str = None,
        table_name: str = "llama_vectors",
        embed_dim: int = 1536
    ):
        password = password or os.getenv("POSTGRES_PASSWORD", "mysecretpassword")
        
        # 配置PostgreSQL向量存储
        self.vector_store = PGVectorStore.from_params(
            host=host,
            port=port,
            database=database,
            user=user,
            password=password,
            table_name=table_name,
            embed_dim=embed_dim
        )
        
        # 配置嵌入模型
        embed_model = OpenAIEmbedding(
            model="text-embedding-ada-002",
            api_key=os.getenv("OPENAI_API_KEY")
        )
        
        # 配置LLM
        llm = OpenAI(
            model="gpt-4",
            temperature=0,
            api_key=os.getenv("OPENAI_API_KEY")
        )
        
        # 配置服务上下文
        self.service_context = ServiceContext.from_defaults(
            llm=llm,
            embed_model=embed_model,
            chunk_size=512,
            chunk_overlap=50
        )
        
        # 配置存储上下文
        self.storage_context = StorageContext.from_defaults(
            vector_store=self.vector_store
        )
        
        # 索引（延迟初始化）
        self.index = None
    
    def build_index(
        self,
        documents: List[LlamaDocument],
        show_progress: bool = True
    ) -> VectorStoreIndex:
        """
        构建向量索引
        
        Args:
            documents: LlamaIndex Document对象列表
            show_progress: 是否显示进度
        """
        self.index = VectorStoreIndex.from_documents(
            documents,
            service_context=self.service_context,
            storage_context=self.storage_context,
            show_progress=show_progress
        )
        
        return self.index
    
    def load_index(self) -> VectorStoreIndex:
        """从PostgreSQL加载现有索引"""
        self.index = VectorStoreIndex.from_vector_store(
            vector_store=self.vector_store,
            service_context=self.service_context
        )
        return self.index
    
    def query(
        self,
        question: str,
        similarity_top_k: int = 3,
        response_mode: str = "compact"
    ) -> str:
        """
        查询
        
        Args:
            question: 用户问题
            similarity_top_k: 检索top-k文档
            response_mode:
                - "compact": 合并文本块到LLM上下文
                - "refine": 迭代优化答案
                - "tree_summarize": 层次化总结
        """
        if self.index is None:
            self.load_index()
        
        query_engine = self.index.as_query_engine(
            similarity_top_k=similarity_top_k,
            response_mode=response_mode
        )
        
        response = query_engine.query(question)
        return str(response)
    
    def chat(
        self,
        message: str,
        similarity_top_k: int = 3
    ) -> str:
        """对话式查询"""
        if self.index is None:
            self.load_index()
        
        chat_engine = self.index.as_chat_engine(
            chat_mode="condense_question",  # 压缩历史问题
            similarity_top_k=similarity_top_k
        )
        
        response = chat_engine.chat(message)
        return str(response)


# 完整示例
def llamaindex_example():
    """LlamaIndex RAG完整示例"""
    
    # 1. 初始化
    rag = LlamaIndexRAG(
        database="rag_db",
        table_name="tech_knowledge"
    )
    
    # 2. 准备文档
    documents = [
        LlamaDocument(
            text="""PostgreSQL 16 introduced significant performance improvements 
            for parallel query execution and VACUUM operations.""",
            metadata={"source": "release_notes.md", "version": "16"}
        ),
        LlamaDocument(
            text="""The pg_stat_statements extension tracks planning and execution 
            statistics for all SQL statements executed by a server.""",
            metadata={"source": "monitoring.md", "type": "extension"}
        ),
    ]
    
    # 3. 构建索引
    rag.build_index(documents)
    
    # 4. 查询
    answer = rag.query(
        "How can I monitor SQL performance in PostgreSQL?",
        similarity_top_k=2
    )
    
    print("ANSWER:", answer)
    
    # 5. 对话
    chat_response = rag.chat("Tell me more about parallel queries")
    print("\nCHAT:", chat_response)


if __name__ == "__main__":
    llamaindex_example()
```

---

## 7. 检索优化和混合搜索

### 7.1 混合检索策略

```python
# hybrid_search.py

import psycopg2
from typing import List, Dict, Any
import numpy as np
from sentence_transformers import SentenceTransformer

class HybridRetriever:
    """混合检索：向量 + 全文 + 元数据过滤"""
    
    def __init__(self, connection_string: str):
        self.conn = psycopg2.connect(connection_string)
        self.embed_model = SentenceTransformer('all-MiniLM-L6-v2')
    
    def hybrid_search(
        self,
        query: str,
        vector_weight: float = 0.7,
        fulltext_weight: float = 0.3,
        metadata_filters: Dict[str, Any] = None,
        top_k: int = 5,
        min_similarity: float = 0.5
    ) -> List[Dict[str, Any]]:
        """
        混合搜索实现
        
        Args:
            query: 查询文本
            vector_weight: 向量搜索权重
            fulltext_weight: 全文搜索权重
            metadata_filters: 元数据过滤条件
            top_k: 返回结果数
            min_similarity: 最小相似度阈值
        
        Returns:
            排序后的结果列表
        """
        # 1. 生成查询向量
        query_embedding = self.embed_model.encode(query).tolist()
        
        # 2. 构建SQL
        sql = """
        WITH vector_scores AS (
            SELECT 
                id,
                document_id,
                content,
                chunk_metadata,
                1 - (embedding <=> %s::vector) AS vec_similarity
            FROM document_chunks
            WHERE embedding IS NOT NULL
        ),
        fulltext_scores AS (
            SELECT 
                id,
                ts_rank_cd(content_tsv, query) AS fts_rank
            FROM document_chunks, plainto_tsquery('english', %s) query
            WHERE content_tsv @@ query
        ),
        combined_scores AS (
            SELECT 
                v.id,
                v.document_id,
                v.content,
                v.chunk_metadata,
                v.vec_similarity,
                COALESCE(f.fts_rank, 0) AS fts_rank,
                (v.vec_similarity * %s + COALESCE(f.fts_rank, 0) * %s) AS combined_score
            FROM vector_scores v
            LEFT JOIN fulltext_scores f ON v.id = f.id
            WHERE v.vec_similarity >= %s
        )
        """
        
        # 3. 添加元数据过滤
        if metadata_filters:
            conditions = []
            for key, value in metadata_filters.items():
                conditions.append(f"chunk_metadata->>'{key}' = '{value}'")
            sql += " AND " + " AND ".join(conditions)
        
        sql += """
        SELECT * FROM combined_scores
        ORDER BY combined_score DESC
        LIMIT %s
        """
        
        # 4. 执行查询
        with self.conn.cursor() as cur:
            cur.execute(sql, (
                query_embedding,
                query,
                vector_weight,
                fulltext_weight,
                min_similarity,
                top_k
            ))
            
            results = []
            for row in cur.fetchall():
                results.append({
                    "id": row[0],
                    "document_id": row[1],
                    "content": row[2],
                    "metadata": row[3],
                    "vector_similarity": float(row[4]),
                    "fulltext_rank": float(row[5]),
                    "combined_score": float(row[6])
                })
            
            return results
    
    def rerank_results(
        self,
        query: str,
        results: List[Dict[str, Any]],
        rerank_top_k: int = 5
    ) -> List[Dict[str, Any]]:
        """
        使用交叉编码器重排序（可选，提高精度）
        
        需要安装: pip install sentence-transformers[reranker]
        """
        from sentence_transformers import CrossEncoder
        
        reranker = CrossEncoder('cross-encoder/ms-marco-MiniLM-L-6-v2')
        
        # 准备查询-文档对
        pairs = [[query, result["content"]] for result in results]
        
        # 计算交叉编码分数
        scores = reranker.predict(pairs)
        
        # 添加重排序分数
        for result, score in zip(results, scores):
            result["rerank_score"] = float(score)
        
        # 重新排序
        results_reranked = sorted(
            results,
            key=lambda x: x["rerank_score"],
            reverse=True
        )
        
        return results_reranked[:rerank_top_k]
    
    def close(self):
        """关闭数据库连接"""
        self.conn.close()


# 使用示例
def hybrid_search_example():
    """混合检索示例"""
    retriever = HybridRetriever(
        "postgresql://postgres:mysecretpassword@localhost:5432/rag_db"
    )
    
    results = retriever.hybrid_search(
        query="How to optimize PostgreSQL for AI workloads?",
        vector_weight=0.7,
        fulltext_weight=0.3,
        metadata_filters={"category": "performance"},
        top_k=5
    )
    
    print("=" * 60)
    print("HYBRID SEARCH RESULTS:")
    for i, result in enumerate(results, 1):
        print(f"\n[{i}] Score: {result['combined_score']:.4f}")
        print(f"    Vector: {result['vector_similarity']:.4f}, Fulltext: {result['fulltext_rank']:.4f}")
        print(f"    {result['content'][:150]}...")
    
    # 可选：重排序
    reranked = retriever.rerank_results("How to optimize PostgreSQL for AI workloads?", results, 3)
    
    print("\n" + "=" * 60)
    print("RERANKED RESULTS:")
    for i, result in enumerate(reranked, 1):
        print(f"\n[{i}] Rerank Score: {result['rerank_score']:.4f}")
        print(f"    {result['content'][:150]}...")
    
    retriever.close()


if __name__ == "__main__":
    hybrid_search_example()
```

### 7.2 查询优化技巧

```python
# query_optimization.py

class QueryOptimizer:
    """查询优化器"""
    
    @staticmethod
    def expand_query(query: str) -> List[str]:
        """
        查询扩展（使用同义词、相关词）
        
        可集成：
        - WordNet for synonyms
        - Custom domain dictionary
        - LLM-based expansion
        """
        # 简化示例
        expansions = [query]
        
        # 添加同义词变体
        if "optimize" in query.lower():
            expansions.append(query.replace("optimize", "improve"))
            expansions.append(query.replace("optimize", "tune"))
        
        return expansions
    
    @staticmethod
    def decompose_complex_query(query: str) -> List[str]:
        """
        分解复杂查询为多个子查询
        
        示例: "Compare PostgreSQL and MySQL for AI workloads"
        -> ["PostgreSQL for AI", "MySQL for AI", "PostgreSQL vs MySQL"]
        """
        # 实际实现需要NLP分析
        # 这里提供简化示例
        sub_queries = [query]
        
        if " and " in query.lower():
            parts = query.lower().split(" and ")
            sub_queries.extend(parts)
        
        return sub_queries
    
    @staticmethod
    def adjust_search_parameters(
        query_type: str,
        doc_count: int
    ) -> Dict[str, Any]:
        """
        根据查询类型和文档数量动态调整参数
        
        Args:
            query_type: "factual", "exploratory", "comparison"
            doc_count: 索引中的文档总数
        
        Returns:
            优化后的搜索参数
        """
        params = {
            "top_k": 5,
            "min_similarity": 0.5,
            "vector_weight": 0.7
        }
        
        if query_type == "factual":
            # 事实查询：高精度，少结果
            params["top_k"] = 3
            params["min_similarity"] = 0.7
            params["vector_weight"] = 0.8
        
        elif query_type == "exploratory":
            # 探索性查询：多样性，多结果
            params["top_k"] = 10
            params["min_similarity"] = 0.4
            params["vector_weight"] = 0.6
        
        elif query_type == "comparison":
            # 对比查询：平衡向量和全文
            params["top_k"] = 8
            params["min_similarity"] = 0.5
            params["vector_weight"] = 0.5
        
        # 根据文档规模调整
        if doc_count > 100000:
            params["min_similarity"] += 0.1  # 大规模索引提高阈值
        
        return params
```

---

---

## 8. 生产部署架构

### 8.1 推荐架构

```
┌──────────────────────────────────────────────────────────────┐
│                     生产级RAG架构                              │
└──────────────────────────────────────────────────────────────┘

                        ┌─────────────┐
                        │   用户请求   │
                        └──────┬──────┘
                               │
                    ┌──────────▼──────────┐
                    │   API Gateway       │
                    │   (Rate Limiting)   │
                    └──────────┬──────────┘
                               │
              ┌────────────────┼────────────────┐
              │                │                │
    ┌─────────▼────────┐ ┌────▼─────┐ ┌────────▼────────┐
    │  Query Service   │ │  Ingest  │ │  Admin Service  │
    │  (FastAPI)       │ │  Worker  │ │  (Monitoring)   │
    └─────────┬────────┘ └────┬─────┘ └─────────────────┘
              │               │
    ┌─────────▼───────────────▼──────────┐
    │      PostgreSQL + pgvector         │
    │      (Primary + Read Replicas)     │
    └─────────┬──────────────────────────┘
              │
    ┌─────────▼──────────┐
    │   Object Storage   │
    │   (原始文档)        │
    └────────────────────┘

    External Services:
    ┌──────────────┐  ┌──────────────┐  ┌──────────────┐
    │ OpenAI API   │  │ Redis Cache  │  │ Prometheus   │
    │ (Embeddings) │  │ (Hot Data)   │  │ (Metrics)    │
    └──────────────┘  └──────────────┘  └──────────────┘
```

### 8.2 Docker Compose生产配置

```yaml
# docker-compose.prod.yml

version: '3.8'

services:
  # PostgreSQL主库
  postgres:
    image: pgvector/pgvector:pg16
    environment:
      POSTGRES_USER: ${DB_USER:-postgres}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
      POSTGRES_DB: ${DB_NAME:-rag_db}
      POSTGRES_INITDB_ARGS: "-E UTF8 --locale=en_US.UTF-8"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "5432:5432"
    deploy:
      resources:
        limits:
          cpus: '4'
          memory: 8G
        reservations:
          cpus: '2'
          memory: 4G
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DB_USER:-postgres}"]
      interval: 10s
      timeout: 5s
      retries: 5
    command: >
      postgres
      -c shared_buffers=2GB
      -c effective_cache_size=6GB
      -c maintenance_work_mem=512MB
      -c checkpoint_completion_target=0.9
      -c wal_buffers=16MB
      -c default_statistics_target=100
      -c random_page_cost=1.1
      -c effective_io_concurrency=200
      -c work_mem=64MB
      -c huge_pages=off
      -c min_wal_size=1GB
      -c max_wal_size=4GB
      -c max_worker_processes=8
      -c max_parallel_workers_per_gather=4
      -c max_parallel_workers=8
    networks:
      - rag_network

  # Redis缓存
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    command: redis-server --appendonly yes --maxmemory 2gb --maxmemory-policy allkeys-lru
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - rag_network

  # API服务
  api:
    build:
      context: .
      dockerfile: Dockerfile.api
    environment:
      DATABASE_URL: postgresql://${DB_USER}:${DB_PASSWORD}@postgres:5432/${DB_NAME}
      REDIS_URL: redis://redis:6379/0
      OPENAI_API_KEY: ${OPENAI_API_KEY}
      LOG_LEVEL: ${LOG_LEVEL:-info}
    ports:
      - "8000:8000"
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    deploy:
      replicas: 3
      resources:
        limits:
          cpus: '2'
          memory: 2G
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    networks:
      - rag_network

  # 文档摄入Worker
  ingest_worker:
    build:
      context: .
      dockerfile: Dockerfile.worker
    environment:
      DATABASE_URL: postgresql://${DB_USER}:${DB_PASSWORD}@postgres:5432/${DB_NAME}
      REDIS_URL: redis://redis:6379/0
      OPENAI_API_KEY: ${OPENAI_API_KEY}
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    deploy:
      replicas: 2
    networks:
      - rag_network

  # Prometheus监控
  prometheus:
    image: prom/prometheus:latest
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    ports:
      - "9090:9090"
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
    networks:
      - rag_network

  # Grafana可视化
  grafana:
    image: grafana/grafana:latest
    volumes:
      - grafana_data:/var/lib/grafana
    environment:
      GF_SECURITY_ADMIN_PASSWORD: ${GRAFANA_PASSWORD}
    ports:
      - "3000:3000"
    depends_on:
      - prometheus
    networks:
      - rag_network

volumes:
  postgres_data:
  redis_data:
  prometheus_data:
  grafana_data:

networks:
  rag_network:
    driver: bridge
```

### 8.3 FastAPI生产服务

```python
# api/main.py

from fastapi import FastAPI, HTTPException, Depends
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Optional
import redis
import hashlib
import json
from prometheus_client import Counter, Histogram, make_asgi_app
import time

# 初始化FastAPI
app = FastAPI(
    title="RAG API",
    description="Production RAG Service with PostgreSQL + pgvector",
    version="1.0.0"
)

# CORS配置
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # 生产环境应限制具体域名
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Prometheus metrics
query_counter = Counter('rag_queries_total', 'Total RAG queries')
query_duration = Histogram('rag_query_duration_seconds', 'Query duration')
cache_hits = Counter('rag_cache_hits_total', 'Cache hits')
cache_misses = Counter('rag_cache_misses_total', 'Cache misses')

# 挂载Prometheus metrics
metrics_app = make_asgi_app()
app.mount("/metrics", metrics_app)

# Redis连接
redis_client = redis.from_url(os.getenv("REDIS_URL"))

# Pydantic模型
class QueryRequest(BaseModel):
    question: str
    top_k: int = 4
    min_similarity: float = 0.5
    use_cache: bool = True
    filters: Optional[dict] = None

class QueryResponse(BaseModel):
    answer: str
    sources: List[dict]
    query_time: float
    cached: bool

class IngestRequest(BaseModel):
    source_url: str
    source_type: str
    metadata: Optional[dict] = None

# 依赖注入：RAG系统
def get_rag_system():
    """获取RAG系统实例（单例）"""
    if not hasattr(get_rag_system, "instance"):
        get_rag_system.instance = LangChainRAG(
            connection_string=os.getenv("DATABASE_URL")
        )
    return get_rag_system.instance

# 健康检查
@app.get("/health")
async def health_check():
    """健康检查端点"""
    try:
        # 检查数据库连接
        rag = get_rag_system()
        # 简单查询测试
        test_docs = rag.similarity_search("test", k=1)
        
        # 检查Redis
        redis_client.ping()
        
        return {
            "status": "healthy",
            "database": "connected",
            "redis": "connected",
            "timestamp": time.time()
        }
    except Exception as e:
        raise HTTPException(status_code=503, detail=f"Health check failed: {str(e)}")

# 查询端点
@app.post("/query", response_model=QueryResponse)
@query_duration.time()
async def query(
    request: QueryRequest,
    rag: LangChainRAG = Depends(get_rag_system)
):
    """
    RAG查询端点
    
    - question: 用户问题
    - top_k: 检索文档数量
    - min_similarity: 最小相似度阈值
    - use_cache: 是否使用缓存
    - filters: 元数据过滤条件
    """
    query_counter.inc()
    start_time = time.time()
    
    # 生成缓存键
    cache_key = None
    if request.use_cache:
        cache_data = {
            "question": request.question,
            "top_k": request.top_k,
            "filters": request.filters
        }
        cache_key = "rag:" + hashlib.md5(
            json.dumps(cache_data, sort_keys=True).encode()
        ).hexdigest()
        
        # 检查缓存
        cached_result = redis_client.get(cache_key)
        if cached_result:
            cache_hits.inc()
            result = json.loads(cached_result)
            result["cached"] = True
            result["query_time"] = time.time() - start_time
            return result
    
    cache_misses.inc()
    
    try:
        # 执行查询
        result = rag.query(
            question=request.question,
            k=request.top_k,
            return_sources=True
        )
        
        response = {
            "answer": result["answer"],
            "sources": [
                {
                    "content": doc.page_content[:200],
                    "metadata": doc.metadata
                }
                for doc in result.get("sources", [])
            ],
            "query_time": time.time() - start_time,
            "cached": False
        }
        
        # 存入缓存（5分钟过期）
        if cache_key:
            redis_client.setex(
                cache_key,
                300,  # 5分钟
                json.dumps(response)
            )
        
        return response
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Query failed: {str(e)}")

# 文档摄入端点
@app.post("/ingest")
async def ingest_document(request: IngestRequest):
    """
    文档摄入端点（异步处理）
    
    将任务加入Redis队列，由Worker处理
    """
    try:
        task_id = hashlib.md5(
            f"{request.source_url}{time.time()}".encode()
        ).hexdigest()
        
        task_data = {
            "task_id": task_id,
            "source_url": request.source_url,
            "source_type": request.source_type,
            "metadata": request.metadata or {},
            "timestamp": time.time()
        }
        
        # 推送到Redis队列
        redis_client.lpush("ingest_queue", json.dumps(task_data))
        
        return {
            "task_id": task_id,
            "status": "queued",
            "message": "Document ingestion task created"
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Ingest failed: {str(e)}")

# 任务状态查询
@app.get("/task/{task_id}")
async def get_task_status(task_id: str):
    """查询任务状态"""
    status_key = f"task:{task_id}:status"
    status = redis_client.get(status_key)
    
    if not status:
        raise HTTPException(status_code=404, detail="Task not found")
    
    return json.loads(status)

# 统计信息
@app.get("/stats")
async def get_stats():
    """获取系统统计信息"""
    # 从数据库查询
    import psycopg2
    conn = psycopg2.connect(os.getenv("DATABASE_URL"))
    
    with conn.cursor() as cur:
        # 文档总数
        cur.execute("SELECT COUNT(*) FROM documents")
        doc_count = cur.fetchone()[0]
        
        # 块总数
        cur.execute("SELECT COUNT(*) FROM document_chunks")
        chunk_count = cur.fetchone()[0]
        
        # 平均块大小
        cur.execute("SELECT AVG(token_count) FROM document_chunks WHERE token_count IS NOT NULL")
        avg_chunk_size = cur.fetchone()[0] or 0
    
    conn.close()
    
    return {
        "documents": doc_count,
        "chunks": chunk_count,
        "avg_chunk_size": float(avg_chunk_size),
        "cache_size": redis_client.dbsize()
    }


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8000,
        workers=4,
        log_level="info"
    )
```

---

## 9. 性能优化和成本控制

### 9.1 查询性能优化

```python
# performance_optimization.py

import asyncio
from typing import List
import time

class PerformanceOptimizer:
    """性能优化工具集"""
    
    @staticmethod
    async def batch_embed(
        texts: List[str],
        embed_function,
        batch_size: int = 100,
        max_concurrent: int = 5
    ) -> List[List[float]]:
        """
        批量嵌入生成（提高吞吐量）
        
        优化点：
        1. 批量API调用减少网络开销
        2. 异步并发提高吞吐
        3. 限流避免超过API限制
        """
        semaphore = asyncio.Semaphore(max_concurrent)
        
        async def embed_batch(batch):
            async with semaphore:
                return await embed_function(batch)
        
        tasks = []
        for i in range(0, len(texts), batch_size):
            batch = texts[i:i + batch_size]
            tasks.append(embed_batch(batch))
        
        results = await asyncio.gather(*tasks)
        
        # 展平结果
        embeddings = []
        for batch_result in results:
            embeddings.extend(batch_result)
        
        return embeddings
    
    @staticmethod
    def optimize_index_build(conn, table_name: str):
        """
        优化索引构建
        
        大数据集索引构建策略：
        1. 增加maintenance_work_mem
        2. 并行构建
        3. 完成后VACUUM ANALYZE
        """
        with conn.cursor() as cur:
            # 临时增加维护内存
            cur.execute("SET maintenance_work_mem = '2GB'")
            cur.execute("SET max_parallel_maintenance_workers = 4")
            
            # 构建索引（如果不存在）
            cur.execute(f"""
                CREATE INDEX IF NOT EXISTS idx_{table_name}_embedding 
                ON {table_name} 
                USING hnsw (embedding vector_cosine_ops)
                WITH (m = 16, ef_construction = 64)
            """)
            
            # 优化表
            cur.execute(f"VACUUM ANALYZE {table_name}")
            
            conn.commit()
    
    @staticmethod
    def estimate_query_cost(conn, query: str) -> dict:
        """
        估算查询成本
        
        使用EXPLAIN ANALYZE分析查询计划
        """
        with conn.cursor() as cur:
            cur.execute(f"EXPLAIN (ANALYZE, BUFFERS, FORMAT JSON) {query}")
            plan = cur.fetchone()[0]
            
            return {
                "total_cost": plan[0]["Plan"]["Total Cost"],
                "execution_time": plan[0]["Execution Time"],
                "planning_time": plan[0]["Planning Time"],
                "shared_hit_blocks": plan[0]["Plan"].get("Shared Hit Blocks", 0),
                "shared_read_blocks": plan[0]["Plan"].get("Shared Read Blocks", 0)
            }


### 9.2 索引参数调优

```sql
-- ✅ [可运行] 索引性能对比测试

-- 1. 创建测试数据
CREATE TABLE vector_test (
    id SERIAL PRIMARY KEY,
    embedding vector(1536)
);

-- 插入100K测试向量
INSERT INTO vector_test (embedding)
SELECT array_agg(random())::vector(1536)
FROM generate_series(1, 100000), generate_series(1, 1536);

-- 2. 测试不同HNSW参数

-- 参数组合1: m=16, ef_construction=64 (默认)
CREATE INDEX idx_test_hnsw_default ON vector_test 
USING hnsw (embedding vector_cosine_ops)
WITH (m = 16, ef_construction = 64);

-- 参数组合2: m=32, ef_construction=128 (高精度)
CREATE INDEX idx_test_hnsw_accurate ON vector_test 
USING hnsw (embedding vector_cosine_ops)
WITH (m = 32, ef_construction = 128);

-- 参数组合3: m=8, ef_construction=32 (快速构建)
CREATE INDEX idx_test_hnsw_fast ON vector_test 
USING hnsw (embedding vector_cosine_ops)
WITH (m = 8, ef_construction = 32);

-- 3. 性能测试查询
EXPLAIN (ANALYZE, BUFFERS) 
SELECT id 
FROM vector_test 
ORDER BY embedding <=> '[0.1, 0.2, ...]'::vector 
LIMIT 10;

-- 4. 调优运行时参数（查询时）
SET hnsw.ef_search = 100;  -- 默认40，提高召回率

-- 对比不同ef_search值
SET hnsw.ef_search = 40;
-- 执行查询测试...

SET hnsw.ef_search = 100;
-- 执行查询测试...

SET hnsw.ef_search = 200;
-- 执行查询测试...
```

**参数选择指南**:

| 参数 | 影响 | 小数据集(<10K) | 中数据集(10K-1M) | 大数据集(>1M) |
|-----|------|--------------|----------------|-------------|
| **m** | 构建时间/精度 | 8-16 | 16-32 | 32-64 |
| **ef_construction** | 构建时间/精度 | 32-64 | 64-128 | 128-256 |
| **ef_search** | 查询时间/召回率 | 20-40 | 40-100 | 100-200 |

### 9.3 成本控制策略

```python
# cost_control.py

from typing import List
import tiktoken

class CostController:
    """成本控制器"""
    
    # OpenAI API定价（2024年价格，仅供参考）
    PRICING = {
        "text-embedding-ada-002": {
            "per_1k_tokens": 0.0001  # $0.0001/1K tokens
        },
        "gpt-4": {
            "input_per_1k": 0.03,    # $0.03/1K tokens
            "output_per_1k": 0.06    # $0.06/1K tokens
        },
        "gpt-3.5-turbo": {
            "input_per_1k": 0.0015,
            "output_per_1k": 0.002
        }
    }
    
    def __init__(self):
        self.tokenizer = tiktoken.get_encoding("cl100k_base")
    
    def count_tokens(self, text: str) -> int:
        """计算token数"""
        return len(self.tokenizer.encode(text))
    
    def estimate_embedding_cost(
        self,
        texts: List[str],
        model: str = "text-embedding-ada-002"
    ) -> dict:
        """估算嵌入成本"""
        total_tokens = sum(self.count_tokens(text) for text in texts)
        
        price_per_1k = self.PRICING[model]["per_1k_tokens"]
        total_cost = (total_tokens / 1000) * price_per_1k
        
        return {
            "total_tokens": total_tokens,
            "total_cost_usd": round(total_cost, 6),
            "avg_tokens_per_text": total_tokens / len(texts) if texts else 0
        }
    
    def estimate_query_cost(
        self,
        query: str,
        context_docs: List[str],
        expected_answer_length: int = 200,
        model: str = "gpt-4"
    ) -> dict:
        """估算单次查询成本"""
        # 输入：query + context
        input_text = query + "\n\n".join(context_docs)
        input_tokens = self.count_tokens(input_text)
        
        # 输出：估算
        output_tokens = expected_answer_length  # 粗略估计
        
        pricing = self.PRICING[model]
        input_cost = (input_tokens / 1000) * pricing["input_per_1k"]
        output_cost = (output_tokens / 1000) * pricing["output_per_1k"]
        total_cost = input_cost + output_cost
        
        return {
            "input_tokens": input_tokens,
            "output_tokens": output_tokens,
            "total_tokens": input_tokens + output_tokens,
            "input_cost_usd": round(input_cost, 6),
            "output_cost_usd": round(output_cost, 6),
            "total_cost_usd": round(total_cost, 6)
        }
    
    def optimize_context_window(
        self,
        documents: List[str],
        max_tokens: int = 3000,
        strategy: str = "truncate"
    ) -> List[str]:
        """
        优化上下文窗口（降低成本）
        
        策略：
        - truncate: 截断超长文档
        - summarize: 总结长文档（需要额外API调用）
        - select_best: 仅选择最相关的前N个
        """
        if strategy == "truncate":
            result = []
            total_tokens = 0
            
            for doc in documents:
                doc_tokens = self.count_tokens(doc)
                if total_tokens + doc_tokens > max_tokens:
                    # 截断
                    remaining = max_tokens - total_tokens
                    truncated = self.tokenizer.decode(
                        self.tokenizer.encode(doc)[:remaining]
                    )
                    result.append(truncated)
                    break
                else:
                    result.append(doc)
                    total_tokens += doc_tokens
            
            return result
        
        # 其他策略实现...
        return documents


# 成本监控示例
def cost_monitoring_example():
    """成本监控示例"""
    controller = CostController()
    
    # 估算嵌入成本
    documents = [
        "PostgreSQL is a powerful database system." * 100,  # 模拟长文档
        "pgvector enables vector similarity search." * 100,
    ]
    
    embed_cost = controller.estimate_embedding_cost(documents)
    print("Embedding Cost Estimate:")
    print(f"  Total Tokens: {embed_cost['total_tokens']:,}")
    print(f"  Total Cost: ${embed_cost['total_cost_usd']:.6f}")
    
    # 估算查询成本
    query = "How does pgvector work?"
    context = documents[:2]
    
    query_cost = controller.estimate_query_cost(
        query,
        context,
        model="gpt-4"
    )
    
    print("\nQuery Cost Estimate (GPT-4):")
    print(f"  Input Tokens: {query_cost['input_tokens']:,}")
    print(f"  Output Tokens: {query_cost['output_tokens']:,}")
    print(f"  Total Cost: ${query_cost['total_cost_usd']:.6f}")
    
    # 月度成本估算（假设1000次查询/天）
    daily_queries = 1000
    monthly_cost = query_cost['total_cost_usd'] * daily_queries * 30
    print(f"\nEstimated Monthly Cost (1K queries/day): ${monthly_cost:.2f}")


if __name__ == "__main__":
    cost_monitoring_example()
```

**降本增效建议**:

1. **嵌入模型选择**
   - 🏆 开源模型: `sentence-transformers/all-MiniLM-L6-v2` (免费)
   - 💰 OpenAI: `text-embedding-ada-002` (高质量，付费)
   - ☁️ Azure OpenAI: 企业级支持

2. **LLM选择**
   - 🚀 生产环境: GPT-4 (高质量)
   - 💰 成本优化: GPT-3.5-turbo (80%成本降低)
   - 🆓 私有部署: Llama 2 70B (需要GPU)

3. **缓存策略**
   - 相同查询直接返回缓存结果
   - 语义相似查询使用聚类缓存
   - 热门查询预计算

4. **批量处理**
   - 批量嵌入生成（减少API调用）
   - 异步摄入（削峰填谷）

---

## 10. 监控和故障排查

### 10.1 关键指标监控

```python
# monitoring.py

from prometheus_client import Gauge, Counter, Histogram
import psycopg2
import time

# 定义Prometheus指标
db_connections = Gauge('pg_connections_active', 'Active PostgreSQL connections')
index_size = Gauge('pg_index_size_bytes', 'Index size in bytes', ['index_name'])
query_latency = Histogram('rag_query_latency_seconds', 'Query latency')
error_count = Counter('rag_errors_total', 'Total errors', ['error_type'])

class RAGMonitor:
    """RAG系统监控器"""
    
    def __init__(self, db_url: str):
        self.conn = psycopg2.connect(db_url)
    
    def collect_metrics(self):
        """收集系统指标"""
        with self.conn.cursor() as cur:
            # 活跃连接数
            cur.execute("""
                SELECT count(*) 
                FROM pg_stat_activity 
                WHERE state = 'active'
            """)
            db_connections.set(cur.fetchone()[0])
            
            # 索引大小
            cur.execute("""
                SELECT indexname, pg_relation_size(indexname::regclass) 
                FROM pg_indexes 
                WHERE schemaname = 'public' 
                AND indexname LIKE '%embedding%'
            """)
            for index_name, size in cur.fetchall():
                index_size.labels(index_name=index_name).set(size)
            
            # 慢查询检测
            cur.execute("""
                SELECT query, mean_exec_time, calls
                FROM pg_stat_statements
                WHERE mean_exec_time > 1000  -- 超过1秒
                ORDER BY mean_exec_time DESC
                LIMIT 10
            """)
            slow_queries = cur.fetchall()
            
            return {
                "slow_queries": slow_queries,
                "timestamp": time.time()
            }
    
    def check_index_health(self):
        """检查索引健康状态"""
        with self.conn.cursor() as cur:
            cur.execute("""
                SELECT 
                    schemaname,
                    tablename,
                    indexname,
                    idx_scan,
                    idx_tup_read,
                    idx_tup_fetch
                FROM pg_stat_user_indexes
                WHERE indexname LIKE '%embedding%'
            """)
            
            indexes = cur.fetchall()
            
            # 检查未使用的索引
            unused_indexes = [
                idx for idx in indexes if idx[3] == 0  # idx_scan == 0
            ]
            
            if unused_indexes:
                print("WARNING: Unused indexes detected:")
                for idx in unused_indexes:
                    print(f"  - {idx[2]} on {idx[1]}")
            
            return indexes
    
    def close(self):
        self.conn.close()


# Grafana Dashboard配置示例 (prometheus.yml)
"""
# prometheus.yml

global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'rag_api'
    static_configs:
      - targets: ['api:8000']
  
  - job_name: 'postgres'
    static_configs:
      - targets: ['postgres-exporter:9187']
"""
```

### 10.2 常见问题排查

```sql
-- ✅ [可运行] 故障排查SQL

-- 1. 检查查询性能
SELECT 
    query,
    calls,
    total_exec_time,
    mean_exec_time,
    stddev_exec_time
FROM pg_stat_statements
WHERE query LIKE '%document_chunks%'
ORDER BY mean_exec_time DESC
LIMIT 10;

-- 2. 检查索引使用情况
SELECT 
    schemaname,
    tablename,
    indexname,
    idx_scan AS index_scans,
    idx_tup_read AS tuples_read,
    idx_tup_fetch AS tuples_fetched,
    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
ORDER BY idx_scan ASC;

-- 3. 检查表膨胀
SELECT 
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS total_size,
    pg_size_pretty(pg_relation_size(schemaname||'.'||tablename)) AS table_size,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename) - 
                   pg_relation_size(schemaname||'.'||tablename)) AS indexes_size,
    n_dead_tup AS dead_tuples,
    last_vacuum,
    last_autovacuum
FROM pg_stat_user_tables
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;

-- 4. 检查长时间运行的查询
SELECT 
    pid,
    now() - query_start AS duration,
    state,
    query
FROM pg_stat_activity
WHERE state != 'idle'
AND query NOT LIKE '%pg_stat_activity%'
ORDER BY duration DESC;

-- 5. 终止慢查询（慎用）
-- SELECT pg_terminate_backend(pid) WHERE pid = <pid>;

-- 6. 检查连接数
SELECT 
    COUNT(*) AS total_connections,
    COUNT(*) FILTER (WHERE state = 'active') AS active,
    COUNT(*) FILTER (WHERE state = 'idle') AS idle
FROM pg_stat_activity;

-- 7. 检查缓存命中率（应 > 99%）
SELECT 
    sum(heap_blks_read) AS heap_read,
    sum(heap_blks_hit) AS heap_hit,
    sum(heap_blks_hit) / (sum(heap_blks_hit) + sum(heap_blks_read)) * 100 AS cache_hit_ratio
FROM pg_statio_user_tables;
```

### 10.3 告警规则

```yaml
# alerting_rules.yml (Prometheus)

groups:
  - name: rag_alerts
    interval: 30s
    rules:
      # 查询延迟告警
      - alert: HighQueryLatency
        expr: histogram_quantile(0.95, rag_query_latency_seconds) > 5
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High query latency detected"
          description: "95th percentile query latency is above 5s"
      
      # 错误率告警
      - alert: HighErrorRate
        expr: rate(rag_errors_total[5m]) > 0.05
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "High error rate detected"
          description: "Error rate is above 5%"
      
      # 数据库连接告警
      - alert: TooManyConnections
        expr: pg_connections_active > 80
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "Too many database connections"
          description: "Active connections exceed 80"
      
      # 缓存命中率告警
      - alert: LowCacheHitRate
        expr: (rag_cache_hits_total / (rag_cache_hits_total + rag_cache_misses_total)) < 0.5
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: "Low cache hit rate"
          description: "Cache hit rate is below 50%"
```

---

## 11. 完整案例：企业知识库

### 11.1 案例场景

**客户需求**: 某科技公司需要构建内部知识库RAG系统

- 📚 **数据源**: 2000+份技术文档（PDF、Markdown、Confluence）
- 👥 **用户数**: 500名工程师
- 🔍 **查询量**: 10K次/天
- 🎯 **要求**: 低延迟(<2s)、高准确率(>90%)、成本可控

### 11.2 架构设计

```python
# enterprise_rag.py

import os
from pathlib import Path
from typing import List, Dict, Any
import hashlib
from datetime import datetime

from langchain.document_loaders import (
    PyPDFLoader,
    UnstructuredMarkdownLoader,
    ConfluenceLoader
)
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.embeddings import OpenAIEmbeddings
from langchain.vectorstores import PGVector
from langchain.chat_models import ChatOpenAI
from langchain.chains import RetrievalQA

class EnterpriseKnowledgeBase:
    """企业知识库RAG系统"""
    
    def __init__(
        self,
        db_connection: str,
        confluence_url: str = None,
        confluence_username: str = None,
        confluence_api_key: str = None
    ):
        self.db_connection = db_connection
        
        # Confluence配置
        self.confluence_config = {
            "url": confluence_url,
            "username": confluence_username,
            "api_key": confluence_api_key
        } if confluence_url else None
        
        # 初始化组件
        self.embeddings = OpenAIEmbeddings()
        self.vectorstore = PGVector(
            collection_name="enterprise_docs",
            connection_string=db_connection,
            embedding_function=self.embeddings
        )
        
        self.llm = ChatOpenAI(model="gpt-4", temperature=0)
        
        # 文本分割器
        self.text_splitter = RecursiveCharacterTextSplitter(
            chunk_size=1000,
            chunk_overlap=200,
            separators=["\n\n", "\n", ". ", " ", ""]
        )
    
    def ingest_directory(
        self,
        directory_path: str,
        file_types: List[str] = None,
        batch_size: int = 50
    ) -> Dict[str, int]:
        """
        摄入整个目录的文档
        
        Args:
            directory_path: 文档目录路径
            file_types: 文件类型列表，如 ['.pdf', '.md']
            batch_size: 批量处理大小
        
        Returns:
            统计信息
        """
        if file_types is None:
            file_types = ['.pdf', '.md', '.txt']
        
        directory = Path(directory_path)
        files = []
        for ext in file_types:
            files.extend(directory.rglob(f'*{ext}'))
        
        print(f"Found {len(files)} files to process")
        
        total_docs = 0
        total_chunks = 0
        
        for i, file_path in enumerate(files):
            try:
                print(f"Processing [{i+1}/{len(files)}]: {file_path.name}")
                
                # 加载文档
                if file_path.suffix == '.pdf':
                    loader = PyPDFLoader(str(file_path))
                elif file_path.suffix == '.md':
                    loader = UnstructuredMarkdownLoader(str(file_path))
                else:
                    # 纯文本
                    with open(file_path, 'r', encoding='utf-8') as f:
                        content = f.read()
                    loader = [{"page_content": content, "metadata": {"source": str(file_path)}}]
                
                documents = loader.load() if hasattr(loader, 'load') else loader
                
                # 添加元数据
                for doc in documents:
                    doc.metadata.update({
                        "source": str(file_path),
                        "file_type": file_path.suffix,
                        "file_name": file_path.name,
                        "ingestion_date": datetime.now().isoformat(),
                        "content_hash": hashlib.md5(doc.page_content.encode()).hexdigest()
                    })
                
                # 分块
                chunks = self.text_splitter.split_documents(documents)
                
                # 批量添加到向量存储
                if chunks:
                    self.vectorstore.add_documents(chunks)
                    total_chunks += len(chunks)
                    total_docs += len(documents)
                
                # 定期提交
                if (i + 1) % batch_size == 0:
                    print(f"  Committed batch, total chunks so far: {total_chunks}")
                
            except Exception as e:
                print(f"  ERROR processing {file_path}: {e}")
                continue
        
        return {
            "total_files": len(files),
            "total_documents": total_docs,
            "total_chunks": total_chunks,
            "avg_chunks_per_doc": total_chunks / total_docs if total_docs > 0 else 0
        }
    
    def ingest_confluence(
        self,
        space_key: str,
        max_pages: int = 1000
    ) -> Dict[str, int]:
        """
        从Confluence摄入文档
        
        Args:
            space_key: Confluence空间标识
            max_pages: 最大页面数
        """
        if not self.confluence_config:
            raise ValueError("Confluence not configured")
        
        loader = ConfluenceLoader(
            url=self.confluence_config["url"],
            username=self.confluence_config["username"],
            api_key=self.confluence_config["api_key"]
        )
        
        documents = loader.load(
            space_key=space_key,
            limit=max_pages,
            include_attachments=False
        )
        
        # 添加元数据
        for doc in documents:
            doc.metadata.update({
                "source": "confluence",
                "space_key": space_key,
                "ingestion_date": datetime.now().isoformat()
            })
        
        # 分块
        chunks = self.text_splitter.split_documents(documents)
        
        # 添加到向量存储
        self.vectorstore.add_documents(chunks)
        
        return {
            "total_pages": len(documents),
            "total_chunks": len(chunks)
        }
    
    def create_qa_system(
        self,
        search_type: str = "similarity",
        search_kwargs: Dict[str, Any] = None
    ) -> RetrievalQA:
        """
        创建问答系统
        
        Args:
            search_type: "similarity" 或 "mmr" (最大边际相关性)
            search_kwargs: 检索参数
        """
        if search_kwargs is None:
            search_kwargs = {"k": 4}
        
        retriever = self.vectorstore.as_retriever(
            search_type=search_type,
            search_kwargs=search_kwargs
        )
        
        qa_chain = RetrievalQA.from_chain_type(
            llm=self.llm,
            chain_type="stuff",
            retriever=retriever,
            return_source_documents=True
        )
        
        return qa_chain


# 完整部署示例
def deploy_enterprise_kb():
    """企业知识库部署示例"""
    
    # 1. 初始化系统
    kb = EnterpriseKnowledgeBase(
        db_connection="postgresql://postgres:password@localhost:5432/kb_db",
        confluence_url="https://company.atlassian.net/wiki",
        confluence_username="admin@company.com",
        confluence_api_key=os.getenv("CONFLUENCE_API_KEY")
    )
    
    # 2. 摄入本地文档
    print("Ingesting local documentation...")
    local_stats = kb.ingest_directory(
        directory_path="/path/to/docs",
        file_types=['.pdf', '.md', '.rst'],
        batch_size=50
    )
    print(f"Local ingestion complete: {local_stats}")
    
    # 3. 摄入Confluence文档
    print("\nIngesting Confluence pages...")
    confluence_stats = kb.ingest_confluence(
        space_key="TECH",
        max_pages=500
    )
    print(f"Confluence ingestion complete: {confluence_stats}")
    
    # 4. 创建问答系统
    qa_system = kb.create_qa_system(
        search_type="mmr",  # 使用MMR提高多样性
        search_kwargs={"k": 6, "fetch_k": 20, "lambda_mult": 0.5}
    )
    
    # 5. 测试查询
    test_queries = [
        "How do I deploy our microservices to production?",
        "What is our code review process?",
        "Explain the authentication system architecture"
    ]
    
    for query in test_queries:
        print(f"\n{'='*60}")
        print(f"Q: {query}")
        result = qa_system({"query": query})
        print(f"A: {result['result']}")
        print(f"\nSources:")
        for doc in result['source_documents']:
            print(f"  - {doc.metadata.get('file_name', 'Unknown')}")
    
    print("\n✅ Enterprise Knowledge Base deployed successfully!")


if __name__ == "__main__":
    deploy_enterprise_kb()
```

---

## 12. 最佳实践总结

### 12.1 架构设计原则

✅ **DO (推荐)**:
1. **分离关注点**: 摄入、检索、生成各自独立服务
2. **异步处理**: 文档摄入使用队列异步处理
3. **缓存优先**: 相同查询直接返回缓存
4. **监控完备**: 所有关键指标可观测
5. **渐进式优化**: 从简单开始，逐步优化

❌ **DON'T (避免)**:
1. ❌ 同步摄入大量文档（阻塞用户）
2. ❌ 忽略成本监控（OpenAI费用失控）
3. ❌ 过度优化（premature optimization）
4. ❌ 缺少错误处理（生产环境崩溃）
5. ❌ 硬编码配置（难以调优）

### 12.2 性能优化清单

- [ ] **数据库层**
  - [ ] PostgreSQL参数调优（shared_buffers, work_mem）
  - [ ] HNSW索引参数优化（m, ef_construction）
  - [ ] 定期VACUUM ANALYZE
  - [ ] 使用连接池（PgBouncer）

- [ ] **应用层**
  - [ ] 批量嵌入生成
  - [ ] Redis缓存热门查询
  - [ ] 异步处理摄入任务
  - [ ] 限流和熔断

- [ ] **成本优化**
  - [ ] 使用开源嵌入模型（sentence-transformers）
  - [ ] 选择GPT-3.5替代GPT-4（非关键场景）
  - [ ] 优化上下文窗口大小
  - [ ] 监控API使用量

### 12.3 生产就绪检查清单

- [ ] **功能完整性**
  - [ ] 文档摄入（PDF, Markdown, HTML, Confluence）
  - [ ] 混合检索（向量 + 全文 + 元数据）
  - [ ] 对话历史管理
  - [ ] 用户权限控制

- [ ] **可靠性**
  - [ ] 数据库备份策略
  - [ ] 故障恢复流程
  - [ ] 健康检查端点
  - [ ] 日志聚合（ELK/Loki）

- [ ] **性能**
  - [ ] 查询延迟 < 2s (P95)
  - [ ] 摄入吞吐 > 100 docs/min
  - [ ] 缓存命中率 > 50%
  - [ ] 数据库CPU < 70%

- [ ] **安全性**
  - [ ] API密钥加密存储
  - [ ] HTTPS/TLS加密
  - [ ] 输入验证和消毒
  - [ ] 定期安全审计

- [ ] **监控和告警**
  - [ ] Prometheus指标导出
  - [ ] Grafana仪表盘
  - [ ] 告警规则配置
  - [ ] On-call轮值

### 12.4 常见错误和解决方案

| 错误 | 表现 | 原因 | 解决方案 |
|-----|------|------|---------|
| **查询慢** | >5s响应 | 索引缺失/参数不当 | 检查EXPLAIN，优化索引参数 |
| **召回率低** | 相关文档未检索 | 嵌入质量差/分块不当 | 使用更好的嵌入模型，调整分块策略 |
| **成本高** | OpenAI账单爆表 | 过大上下文窗口 | 优化top-k，使用缓存，考虑开源模型 |
| **内存溢出** | 批量摄入崩溃 | 一次性加载过多文档 | 减小batch_size，使用流式处理 |
| **重复结果** | 相同内容多次返回 | 内容去重缺失 | 使用content_hash去重 |

### 12.5 进阶主题

想要进一步提升？探索这些高级话题：

1. **多模态RAG**: 图像、表格、代码的检索
2. **细粒度权限**: 基于角色的文档访问控制
3. **主动学习**: 从用户反馈改进检索
4. **A/B测试**: 对比不同检索策略
5. **知识图谱增强**: 结合图数据库（Neo4j）
6. **流式回答**: Server-Sent Events实时反馈
7. **多租户**: 企业级SaaS架构

---

## 📚 参考资源

### 官方文档
- [PostgreSQL官方文档](https://www.postgresql.org/docs/)
- [pgvector GitHub](https://github.com/pgvector/pgvector)
- [LangChain文档](https://python.langchain.com/)
- [LlamaIndex文档](https://docs.llamaindex.ai/)

### 相关文章
- [Building RAG Applications with PostgreSQL](https://www.enterprisedb.com/blog/rag-postgresql)
- [HNSW Index Tuning Guide](https://github.com/pgvector/pgvector#hnsw)

### 学习路径
1. ✅ [PostgreSQL AI集成快速开始](../00-项目导航/AI集成快速开始.md) - 基础入门
2. ✅ **本文** - 生产级RAG实战
3. ⏭️ [向量检索性能调优](./05.05-向量检索性能调优.md) - 深度优化
4. ⏭️ [Azure AI扩展实战](./05.03-Azure-AI扩展实战.md) - 云原生方案

---

## 🎉 总结

恭喜！您已经掌握了使用PostgreSQL构建生产级RAG系统的完整知识：

✅ **理论基础**: RAG架构原理和工作流程  
✅ **技术栈**: PostgreSQL + pgvector + LangChain/LlamaIndex  
✅ **最佳实践**: 分块策略、混合检索、性能优化  
✅ **生产部署**: Docker Compose、监控告警、成本控制  
✅ **实战案例**: 企业知识库完整实现  

**下一步行动**:
1. 🚀 部署最小可行产品（MVP）
2. 📊 收集用户反馈和性能数据
3. 🔧 迭代优化检索质量
4. 📈 扩展到生产规模

有问题？查看[常见问题](../00-项目导航/AI集成快速开始.md#常见问题)或参考[改进计划](../00-项目导航/AI集成改进行动计划.md)。

---

**文档维护**: PostgreSQL AI集成团队  
**最后更新**: 2025-10-30  
**版本**: v1.0  
**反馈**: 欢迎提交Issue或PR

