# 1.1.1-PostgreSQL形式模型

## 概述

PostgreSQL形式模型是数据库系统的理论基础，基于关系代数和关系演算，提供了严格的形式化定义。本模块深入探讨PostgreSQL的形式化理论基础、数学模型和理论证明。

## 关系代数基础

### 关系模型定义

```text
关系 R(A₁, A₂, ..., Aₙ) 是笛卡尔积 D₁ × D₂ × ... × Dₙ 的子集
其中 Dᵢ 是属性 Aᵢ 的域
```

### 基本关系代数运算

#### 选择运算 (σ)

```sql
-- 形式化定义
σₚ(R) = {t | t ∈ R ∧ p(t)}

-- 示例
SELECT * FROM employees WHERE salary > 50000;
```

#### 投影运算 (π)

```sql
-- 形式化定义
πₐ₁,ₐ₂,...,ₐₘ(R) = {t[A₁, A₂, ..., Aₘ] | t ∈ R}

-- 示例
SELECT name, department FROM employees;
```

#### 并运算 (∪)

```sql
-- 形式化定义
R ∪ S = {t | t ∈ R ∨ t ∈ S}

-- 示例
SELECT * FROM employees_2023
UNION
SELECT * FROM employees_2024;
```

#### 差运算 (-)

```sql
-- 形式化定义
R - S = {t | t ∈ R ∧ t ∉ S}

-- 示例
SELECT * FROM employees_2023
EXCEPT
SELECT * FROM employees_2024;
```

#### 笛卡尔积 (×)

```sql
-- 形式化定义
R × S = {(r, s) | r ∈ R ∧ s ∈ S}

-- 示例
SELECT * FROM employees CROSS JOIN departments;
```

#### 连接运算 (⋈)

```sql
-- 形式化定义
R ⋈ₚ S = σₚ(R × S)

-- 示例
SELECT * FROM employees JOIN departments 
ON employees.dept_id = departments.id;
```

## 关系演算

### 元组关系演算

```text
{t | P(t)}
其中 t 是元组变量，P(t) 是谓词公式
```

### 域关系演算

```text
{<x₁, x₂, ..., xₙ> | P(x₁, x₂, ..., xₙ)}
其中 xᵢ 是域变量
```

### 三值逻辑与 NULL 语义（摘）

```text
布尔域扩展为 {TRUE, FALSE, UNKNOWN}
常见规则：
  TRUE AND UNKNOWN = UNKNOWN
  FALSE AND UNKNOWN = FALSE
  NOT UNKNOWN = UNKNOWN
```

与外连接的交互见 `1.1.71-外连接与NULL-三值逻辑的形式语义.md`。

## 函数依赖理论

### 函数依赖定义

```text
对于关系 R(U)，X, Y ⊆ U
X → Y 表示：如果 t₁[X] = t₂[X]，则 t₁[Y] = t₂[Y]
```

### Armstrong公理

1. **自反律**: 如果 Y ⊆ X，则 X → Y
2. **增广律**: 如果 X → Y，则 XZ → YZ
3. **传递律**: 如果 X → Y 且 Y → Z，则 X → Z

### 函数依赖闭包

```text
X⁺ = {A | X → A 可由 Armstrong 公理推导}
```

## 范式理论

### 第一范式 (1NF)

```text
关系中的每个属性都是原子的，不可再分
```

### 第二范式 (2NF)

```text
关系满足1NF，且每个非主属性完全函数依赖于主键
```

### 第三范式 (3NF)

```text
关系满足2NF，且每个非主属性不传递依赖于主键
```

### Boyce-Codd范式 (BCNF)

```text
关系满足3NF，且对于每个函数依赖 X → Y，X 都是超键
```

## 事务理论

### ACID属性形式化

#### 原子性 (Atomicity)

```text
事务 T 是原子的，当且仅当：
- T 的所有操作要么全部执行，要么全部不执行
- 不存在部分执行的状态
```

#### 一致性 (Consistency)

```text
事务 T 保持一致性，当且仅当：
- 如果数据库在 T 开始前是一致的，则 T 结束后也是一致的
- 事务执行过程中可能暂时不一致，但结束时必须一致
```

#### 隔离性 (Isolation)

```text
事务 T₁ 和 T₂ 是隔离的，当且仅当：
- T₁ 的执行不受 T₂ 的影响，反之亦然
- 并发执行的结果等价于某种串行执行
```

##### 弱隔离级别下的可观察现象（摘）

```text
读未提交：脏读/不可重复读/幻读可能
读已提交：不可重复读/幻读可能
可重复读：幻读可能（PG 的 RR+SSI 可避免部分异常）
可串行化：等价于某串行调度（PG 使用 SSI）
```

#### 持久性 (Durability)

```text
事务 T 是持久的，当且仅当：
- 一旦 T 提交，其效果就是永久的
- 即使系统故障，T 的效果也不会丢失
```

## 并发控制理论

### 可串行化理论

```text
调度 S 是可串行化的，当且仅当：
存在某个串行调度 S'，使得 S ≡ S'
```

### 冲突可串行化

```text
两个操作冲突，当且仅当：
1. 它们属于不同事务
2. 它们操作同一个数据项
3. 至少有一个是写操作
```

### 两阶段加锁协议

```text
事务 T 遵循两阶段加锁协议，当且仅当：
1. 在释放任何锁之前，T 获得所有需要的锁
2. 在获得任何锁之后，T 不再获得新的锁
```

## 查询优化理论

### 查询计划空间

```text
对于查询 Q，其计划空间 P(Q) 包含所有可能的执行计划
```

### 代价模型

```text
Cost(P) = Σᵢ Cost(opᵢ)
其中 opᵢ 是计划 P 中的操作
```

示例：块 I/O + CPU 模型；随机/顺序代价、回表惩罚、并行开销与收益。

### 动态规划优化

```text
对于子查询 Q'，最优计划为：
Opt(Q') = argminₚ∈P(Q') Cost(P)
```

## 索引理论

### B+树索引

```text
B+树是平衡的多路搜索树，满足：
1. 所有叶子节点在同一层
2. 非叶子节点存储键值，不存储数据
3. 叶子节点通过链表连接
```

### 索引选择理论

```text
对于查询 Q，索引 I 的选择性为：
Selectivity(I, Q) = |σₚ(R)| / |R|
其中 p 是 Q 的谓词条件
```

## 恢复理论

### 日志协议

```text
Write-Ahead Logging (WAL) 协议：
在修改数据页之前，必须先写日志记录
```

### 检查点协议

```text
检查点包含：
1. 所有脏页的列表
2. 活跃事务的列表
3. 日志序列号 (LSN)
```

## 分布式理论

### CAP定理

```text
对于分布式系统，最多只能同时满足：
- Consistency (一致性)
- Availability (可用性)  
- Partition tolerance (分区容错性)
中的两个
```

### 一致性模型

```text
强一致性：所有节点看到相同的数据
最终一致性：最终所有节点会看到相同的数据
因果一致性：因果相关的操作在所有节点上保持顺序
```

## 形式化验证

### 模型检查

```text
使用形式化方法验证数据库系统的正确性：
1. 构建系统模型
2. 定义性质规范
3. 自动检查模型是否满足性质
```

### 定理证明

```text
使用数学证明验证系统性质：
1. 形式化系统规范
2. 证明关键定理
3. 验证实现正确性
```

## 总结

PostgreSQL形式模型为数据库系统提供了坚实的理论基础，通过严格的形式化定义和数学证明，确保了系统的正确性和可靠性。

---

**相关链接：**

- [1.1.2-数据模型](1.1.2-数据模型.md)
- [1.1.3-查询语言](1.1.3-查询语言.md)
- [2.1.1-基础类型理论](../2-形式科学理论/2.1-类型理论/2.1.1-基础类型理论.md)
