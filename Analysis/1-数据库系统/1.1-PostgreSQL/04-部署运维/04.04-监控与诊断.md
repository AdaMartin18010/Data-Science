# 监控与诊断

**PostgreSQL版本**: 17.x (推荐) | 16.x, 15.x (兼容)
**难度**: ⭐⭐⭐
**最后更新**: 2025-10-30

> 🆕 **PostgreSQL 17监控增强**
>
> PostgreSQL 17引入多项监控改进：
>
> - ✅ **新增系统视图**: 增强的pg_stat_statements，新增标准差统计
> - ✅ **改进的进度报告**: pg_stat_progress_*视图更详细
> - ✅ **共享内存监控**: 新增pg_shmem_allocations视图
> - ✅ **更细粒度的等待事件**: 更准确的性能诊断

---

## 目录

- [1. 指标体系](#1-指标体系)
- [2. PostgreSQL 17新增监控特性](#2-postgresql-17新增监控特性)
- [3. 常用视图与SQL](#3-常用视图与sql)
- [4. 监控实现](#4-监控实现)
- [5. 诊断流程](#5-诊断流程)
- [6. 仪表盘建议](#6-仪表盘建议)
- [7. 告警配置](#7-告警配置)

---

## 1. 指标体系

- 实例级：连接数、事务提交/回滚、缓冲命中率、WAL写入速率、检查点频率、后台写入/清理队列。
- 表/索引级：`seq_scan/idx_scan`、膨胀与死元组、热点对象、I/O命中。
- 查询级：调用次数、平均/TP95/TP99耗时、返回行数、共享块命中率。

## 2. PostgreSQL 17新增监控特性

### 2.1 增强的pg_stat_statements

```sql
-- PostgreSQL 17+: 新增标准差统计

-- 创建扩展（如果尚未安装）
CREATE EXTENSION IF NOT EXISTS pg_stat_statements;

-- 查询性能统计（含标准差）
SELECT
    query,
    calls,
    mean_exec_time,
    stddev_exec_time,  -- ⭐ PostgreSQL 17新增
    min_exec_time,
    max_exec_time,
    rows,
    shared_blks_hit,
    shared_blks_read,
    -- 计算稳定性指标
    CASE
        WHEN mean_exec_time > 0
        THEN round((stddev_exec_time / mean_exec_time * 100)::numeric, 2)
        ELSE 0
    END AS cv_percent  -- 变异系数，衡量查询稳定性
FROM pg_stat_statements
WHERE calls > 10
ORDER BY mean_exec_time DESC
LIMIT 20;

-- 识别不稳定的查询（高变异系数）
SELECT
    left(query, 60) AS query_preview,
    calls,
    round(mean_exec_time::numeric, 2) AS mean_ms,
    round(stddev_exec_time::numeric, 2) AS stddev_ms,
    round((stddev_exec_time / mean_exec_time * 100)::numeric, 2) AS cv_percent
FROM pg_stat_statements
WHERE calls > 100
  AND mean_exec_time > 10
  AND stddev_exec_time / mean_exec_time > 0.5  -- 变异系数>50%
ORDER BY cv_percent DESC
LIMIT 10;
```

### 2.2 共享内存监控

```sql
-- PostgreSQL 17+: 监控动态共享内存使用

SELECT
    name,
    allocated_size,
    free_size,
    used_size,
    dynamic,
    pg_size_pretty(allocated_size) AS allocated,
    pg_size_pretty(free_size) AS free,
    pg_size_pretty(used_size) AS used,
    round((used_size::float / allocated_size * 100)::numeric, 2) AS usage_percent
FROM pg_shmem_allocations
WHERE allocated_size > 0
ORDER BY allocated_size DESC
LIMIT 20;

-- 动态共享内存总览
SELECT
    dynamic,
    count(*) AS segment_count,
    pg_size_pretty(sum(allocated_size)) AS total_allocated,
    pg_size_pretty(sum(used_size)) AS total_used,
    round((sum(used_size)::float / sum(allocated_size) * 100)::numeric, 2) AS usage_percent
FROM pg_shmem_allocations
GROUP BY dynamic
ORDER BY dynamic;
```

### 2.3 改进的进度报告

```sql
-- PostgreSQL 17+: 增强的VACUUM进度监控

SELECT
    pid,
    datname,
    relid::regclass AS table_name,
    phase,
    heap_blks_total,
    heap_blks_scanned,
    heap_blks_vacuumed,
    index_vacuum_count,
    max_dead_tuples,
    num_dead_tuples,
    -- 计算进度百分比
    round((heap_blks_scanned::float / NULLIF(heap_blks_total, 0) * 100)::numeric, 2) AS scan_progress,
    round((heap_blks_vacuumed::float / NULLIF(heap_blks_total, 0) * 100)::numeric, 2) AS vacuum_progress
FROM pg_stat_progress_vacuum
ORDER BY scan_progress DESC;

-- ANALYZE进度监控
SELECT
    pid,
    datname,
    relid::regclass AS table_name,
    phase,
    sample_blks_total,
    sample_blks_scanned,
    round((sample_blks_scanned::float / NULLIF(sample_blks_total, 0) * 100)::numeric, 2) AS progress
FROM pg_stat_progress_analyze
ORDER BY progress DESC;
```

---

## 3. 常用视图与SQL

### 3.1 活跃会话监控

```sql
-- 活跃会话（PostgreSQL 17增强）
SELECT
    pid,
    usename,
    application_name,
    client_addr,
    backend_start,
    xact_start,
    query_start,
    state_change,
    wait_event_type,
    wait_event,
    state,
    backend_xid,
    backend_xmin,
    left(query, 100) AS query_preview
FROM pg_stat_activity
WHERE state <> 'idle'
ORDER BY
    CASE state
        WHEN 'active' THEN 1
        WHEN 'idle in transaction' THEN 2
        ELSE 3
    END,
    query_start;

-- 长时间运行的事务
SELECT
    pid,
    usename,
    application_name,
    state,
    now() - xact_start AS transaction_duration,
    now() - query_start AS query_duration,
    left(query, 80) AS query_preview
FROM pg_stat_activity
WHERE xact_start IS NOT NULL
  AND state NOT IN ('idle')
ORDER BY xact_start
LIMIT 20;
```

### 3.2 锁与等待

```sql
-- 锁与等待
SELECT
    locktype,
    relation::regclass,
    mode,
    granted,
    pid,
    page,
    tuple,
    virtualxid,
    transactionid,
    classid,
    objid
FROM pg_locks
WHERE NOT granted
ORDER BY relation, pid;

-- 锁等待详情（关联会话信息）
SELECT
    blocked_locks.pid AS blocked_pid,
    blocked_activity.usename AS blocked_user,
    blocking_locks.pid AS blocking_pid,
    blocking_activity.usename AS blocking_user,
    blocked_activity.query AS blocked_statement,
    blocking_activity.query AS blocking_statement
FROM pg_catalog.pg_locks blocked_locks
JOIN pg_catalog.pg_stat_activity blocked_activity ON blocked_activity.pid = blocked_locks.pid
JOIN pg_catalog.pg_locks blocking_locks
    ON blocking_locks.locktype = blocked_locks.locktype
    AND blocking_locks.database IS NOT DISTINCT FROM blocked_locks.database
    AND blocking_locks.relation IS NOT DISTINCT FROM blocked_locks.relation
    AND blocking_locks.page IS NOT DISTINCT FROM blocked_locks.page
    AND blocking_locks.tuple IS NOT DISTINCT FROM blocked_locks.tuple
    AND blocking_locks.virtualxid IS NOT DISTINCT FROM blocked_locks.virtualxid
    AND blocking_locks.transactionid IS NOT DISTINCT FROM blocked_locks.transactionid
    AND blocking_locks.classid IS NOT DISTINCT FROM blocked_locks.classid
    AND blocking_locks.objid IS NOT DISTINCT FROM blocked_locks.objid
    AND blocking_locks.objsubid IS NOT DISTINCT FROM blocked_locks.objsubid
    AND blocking_locks.pid != blocked_locks.pid
JOIN pg_catalog.pg_stat_activity blocking_activity ON blocking_activity.pid = blocking_locks.pid
WHERE NOT blocked_locks.granted;
```

### 3.3 表扫描/索引使用

```sql
-- 表扫描/索引使用
SELECT
    schemaname,
    relname,
    seq_scan,
    idx_scan,
    n_tup_ins,
    n_tup_upd,
    n_tup_del,
    n_tup_hot_upd,
    n_live_tup,
    n_dead_tup,
    round((n_dead_tup::float / NULLIF(n_live_tup, 0) * 100)::numeric, 2) AS dead_tuple_percent,
    last_vacuum,
    last_autovacuum,
    last_analyze,
    last_autoanalyze
FROM pg_stat_user_tables
ORDER BY (seq_scan + idx_scan) DESC
LIMIT 20;

-- 识别缺少索引的表（顺序扫描过多）
SELECT
    schemaname,
    relname,
    seq_scan,
    idx_scan,
    n_live_tup,
    round((seq_scan::float / NULLIF(seq_scan + idx_scan, 0) * 100)::numeric, 2) AS seq_scan_percent
FROM pg_stat_user_tables
WHERE seq_scan > 100
  AND n_live_tup > 1000
  AND seq_scan > idx_scan
ORDER BY seq_scan DESC
LIMIT 10;
```

### 3.4 I/O命中率

```sql
-- I/O 命中率
SELECT
    schemaname,
    relname,
    heap_blks_read,
    heap_blks_hit,
    idx_blks_read,
    idx_blks_hit,
    round(100.0 * heap_blks_hit / NULLIF(heap_blks_hit + heap_blks_read, 0), 2) AS heap_hit_ratio,
    round(100.0 * idx_blks_hit / NULLIF(idx_blks_hit + idx_blks_read, 0), 2) AS idx_hit_ratio
FROM pg_statio_user_tables
WHERE heap_blks_read + heap_blks_hit > 0
ORDER BY heap_hit_ratio ASC NULLS LAST
LIMIT 20;

-- 整体缓存命中率
SELECT
    sum(heap_blks_read) AS heap_read,
    sum(heap_blks_hit) AS heap_hit,
    round(100.0 * sum(heap_blks_hit) / NULLIF(sum(heap_blks_hit) + sum(heap_blks_read), 0), 2) AS cache_hit_ratio
FROM pg_statio_user_tables;
```

### 3.5 慢查询分析

```sql
-- 慢查询（需 pg_stat_statements）
SELECT
    queryid,
    left(query, 80) AS query_preview,
    calls,
    round(total_exec_time::numeric, 2) AS total_time_ms,
    round(mean_exec_time::numeric, 2) AS mean_time_ms,
    round(stddev_exec_time::numeric, 2) AS stddev_ms,  -- PG17+
    round(min_exec_time::numeric, 2) AS min_time_ms,
    round(max_exec_time::numeric, 2) AS max_time_ms,
    rows,
    round(100.0 * shared_blks_hit / NULLIF(shared_blks_hit + shared_blks_read, 0), 2) AS cache_hit_percent
FROM pg_stat_statements
WHERE calls > 10
ORDER BY mean_exec_time DESC
LIMIT 20;
```

## 3. 监控实现（Prometheus + Grafana）

- Exporter 部署：
  - `postgres_exporter` 运行在每台实例旁，使用最小权限监控用户：

    ```sql
    CREATE ROLE metrics WITH LOGIN PASSWORD '***';
    GRANT pg_monitor TO metrics;
    -- 如需 wal/replication 细粒度指标：GRANT pg_read_all_stats TO metrics;
    ```

  - 启动参数示例：

    ```bash
    DATA_SOURCE_NAME="postgresql://metrics:***@127.0.0.1:5432/postgres?sslmode=disable" ./postgres_exporter
    ```

- Prometheus 抓取配置：

  ```yaml
  scrape_configs:
    - job_name: pg
      scrape_interval: 15s
      static_configs:
        - targets: ["db1:9187", "db2:9187", "db3:9187"]
  ```

- Grafana 面板建议：
  - 概览：连接、TPS/QPS、缓冲命中、WAL速率、检查点、Autovacuum、锁等待。
  - 明细：Top 表与索引、Top 查询、复制延迟、磁盘 I/O、CPU 与内存。

## 3. 诊断流程（SOP）

- 性能劣化：
  1) 检查实例压力（连接/CPU/IO）→ 2) 慢查询TopN → 3) EXPLAIN ANALYZE 对比估算/实际基数 → 4) 索引/统计修复 → 5) 复测。
- 锁等待/死锁：
  1) `pg_locks` 与等待链 → 2) 找出持锁长事务 → 3) 评估中止与DDL/事务拆分 → 4) 防再发（索引/顺序/批量策略）。
- 膨胀/垃圾：
  1) 死元组与 `autovacuum` 频次 → 2) 提升 `autovacuum_*` 或离峰 `VACUUM (FULL)`/重建索引 → 3) 长事务排查。

## 4. 仪表盘建议（Prometheus+Grafana）

- 面板：连接/事务、命中率/WAL速率、检查点、Autovacuum、Top表与索引、Top查询、锁等待热力图。
- 告警：连接接近上限、命中率骤降、WAL暴涨、检查点频率异常、Autovacuum滞后、死锁事件。

## 5. 常见问题与对策

- 估算偏差大：提高统计目标、扩展统计、表达式列；
- 索引未命中：谓词不匹配、函数未可索引化、类型隐式转换；
- 写放大与膨胀：批写/合并、合理 `fillfactor`、冷热分层、周期重建。

## 6. 日志与可观测性增强

- 建议的 `postgresql.conf` 日志关键项：

  ```text
  log_line_prefix = '%m [%p] %u@%d %r %a '
  log_min_duration_statement = 500ms        # 生产按流量与存储调节
  log_checkpoints = on
  log_autovacuum_min_duration = 1s
  log_lock_waits = on
  track_io_timing = on
  shared_preload_libraries = 'pg_stat_statements,auto_explain'
  auto_explain.log_min_duration = '200ms'
  auto_explain.log_analyze = on
  auto_explain.log_buffers = on
  ```

- 慢日志采集：
  - Filebeat/Vector → Loki/Elastic，再在 Grafana 建立慢SQL面板与 TopN。
  - 生成 `fingerprint`（正则归一化）便于聚合统计。

## 6. 交叉引用

- `02-查询处理/02.04-执行计划与性能调优.md`
- `01-核心基础/01.06-存储管理与数据持久化.md`
- `1.1.49-选择率估计误差-敏感性与上界.md`
