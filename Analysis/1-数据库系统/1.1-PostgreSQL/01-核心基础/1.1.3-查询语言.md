# 1.1.3-查询语言

> PostgreSQL SQL 查询语言概要：SQL子语言、表达式与函数、连接与子查询、聚合与窗口、CTE与递归、查询重写与等价、示例与交叉引用。

## 1. SQL子语言分层

- DDL（数据定义）：`CREATE/ALTER/DROP` 对象（表、视图、物化视图、索引、类型、函数、触发器、模式等）。
- DML（数据操纵）：`INSERT/UPDATE/DELETE/MERGE`，以及 `COPY` 用于批量导入导出。
- DQL（数据查询）：`SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ... LIMIT/OFFSET`。
- DCL/TCL：`GRANT/REVOKE` 访问控制；`BEGIN/COMMIT/ROLLBACK/SAVEPOINT` 事务控制。

## 2. 表达式与函数

- 标量表达式：算术、比较、布尔、字符串、日期时间、正则、JSON路径等。
- 聚合函数：`count/sum/avg/min/max`、聚合过滤 `FILTER (WHERE ...)`、自定义聚合。
- 窗口函数：`OVER (PARTITION BY ... ORDER BY ... [frame])`，排名、移动平均、累积和等。
- JSON/数组/范围操作：`->`、`->>`、`@>`、`?`、`unnest()`、范围重叠 `&&` 等。

## 3. 连接、子查询与CTE

- 连接：`INNER/LEFT/RIGHT/FULL JOIN`、`CROSS JOIN`、`LATERAL`；外连接与NULL的三值逻辑语义见 `1.1.71-外连接与NULL-三值逻辑的形式语义.md`。
- 子查询：标量子查询、相关子查询、`EXISTS`/`IN`/`ANY`/`ALL`。
- CTE：`WITH` 提升可读性与可重用性；递归CTE定义图/层级遍历，见 `1.1.50-CTE与递归查询-关系代数不动点语义.md`。

## 4. 聚合、分组与窗口细节

- 分组语义：`GROUP BY` 与 `HAVING` 的约束与等价变换；函数依赖可用于分组列最小化（参见 `1.1.33`）。
- 窗口帧：`RANGE/ROWS/GROUPS` 窗口；边界 `UNBOUNDED PRECEDING`/`CURRENT ROW`/`FOLLOWING`；详见窗口稳定性 `1.1.52`。

## 5. 查询重写与等价律（概要）

- 代数等价：选择下推、投影下推、连接交换/结合、半连接重写。
- 谓词优化：反范式化条件合并、`OR` 到 `UNION` 的重写、`DISTINCT`/`GROUP BY` 去冗。
- 视图重写：物化视图匹配与替换（`1.1.60`）；部分索引与约束排除（`1.1.58`）。
- 正确性与完备性：参见 `1.1.26-查询语言的形式语义与等价律.md` 与 `1.1.80-查询重写等价性-基于同构的充分必要条件.md`。

## 6. 示例：典型查询片段

```sql
-- 6.1 聚合 + 过滤 + 窗口
SELECT c.id,
       c.name,
       sum(o.amount) FILTER (WHERE o.status = 'paid') AS paid_amount,
       avg(o.amount) OVER (PARTITION BY c.id ORDER BY o.created_at ROWS BETWEEN 3 PRECEDING AND CURRENT ROW) AS mov_avg
FROM customer c
LEFT JOIN orders o ON o.customer_id = c.id
GROUP BY c.id, c.name
HAVING sum(o.amount) > 0
ORDER BY paid_amount DESC
LIMIT 50;

-- 6.2 JSONB查询 + GIN
SELECT id, profile->>'tier' AS tier
FROM customer
WHERE profile @> '{"preferences": {"newsletter": true}}';

-- 6.3 递归CTE：层级遍历
WITH RECURSIVE org AS (
  SELECT id, parent_id, name, 1 AS depth FROM department WHERE parent_id IS NULL
  UNION ALL
  SELECT d.id, d.parent_id, d.name, org.depth + 1
  FROM department d
  JOIN org ON d.parent_id = org.id
)
SELECT * FROM org ORDER BY depth, id;

-- 6.4 LATERAL：依赖前一侧行
SELECT c.id, x.top_skus
FROM customer c
CROSS JOIN LATERAL (
  SELECT array_agg(oi.sku ORDER BY sum(oi.qty) DESC) AS top_skus
  FROM orders o JOIN order_items oi ON oi.order_id = o.id
  WHERE o.customer_id = c.id
  GROUP BY o.customer_id
  LIMIT 5
) AS x;
```

## 7. 计划器交互与提示

- 统计与选择率：正确的统计信息决定连接顺序与算子；参见 `02-查询处理/02.03-统计信息与代价模型.md`、`1.1.49-选择率估计误差-敏感性与上界.md`。
- 并行与算子选择：`enable_*` 开关仅用于诊断，生产中优先通过索引与统计修复。
- 锁与一致性：`SELECT ... FOR UPDATE/SKIP LOCKED` 与事务隔离交互（参见 `1.1.5-事务处理.md`、`01.05-并发控制与MVCC机制.md`）。
- 分区与裁剪：谓词可裁剪是关键；避免函数包裹分区键；过多分区会抬升计划时间。

## 8. 形式化接口（摘要）

- 语义域 \( D \)：关系代数表达式、Bag语义、三值逻辑（外连接/NULL）。
- 等价关系 \( \equiv \)：在给定依赖与约束集合下保持相同结果集与多重度。
- 不动点：递归CTE的最小不动点语义；参见 `1.1.50`、`1.1.42`。

## 10. 可执行脚本

- 参考 `sql/diagnostics.sql`、`sql/tuning_examples.sql`、`sql/graph_examples.sql`、`sql/vector_examples.sql`。

## 9. 延伸阅读

- `INDEX.md`、`README.md` 导航
- `02-查询处理/` 模块（优化器/执行计划）
- 相关证明：`1.1.26`、`1.1.50`、`1.1.52`、`1.1.80`、`1.1.63`
