# 1.5 æ•°æ®åº“ç³»ç»Ÿå®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [1.5 æ•°æ®åº“ç³»ç»Ÿå®è·µæ¡ˆä¾‹](#15-æ•°æ®åº“ç³»ç»Ÿå®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2. å…³ç³»å‹æ•°æ®åº“å®è·µæ¡ˆä¾‹](#2-å…³ç³»å‹æ•°æ®åº“å®è·µæ¡ˆä¾‹)
    - [2.1. ä¼ä¸šèµ„æºè§„åˆ’(ERP)ç³»ç»Ÿæ•°æ®åº“è®¾è®¡](#21-ä¼ä¸šèµ„æºè§„åˆ’erpç³»ç»Ÿæ•°æ®åº“è®¾è®¡)
    - [2.2. è´¢åŠ¡ç®¡ç†ç³»ç»Ÿæ•°æ®åº“è®¾è®¡](#22-è´¢åŠ¡ç®¡ç†ç³»ç»Ÿæ•°æ®åº“è®¾è®¡)
  - [3. NoSQLæ•°æ®åº“å®è·µæ¡ˆä¾‹](#3-nosqlæ•°æ®åº“å®è·µæ¡ˆä¾‹)
    - [3.1. MongoDBæ–‡æ¡£æ•°æ®åº“åº”ç”¨](#31-mongodbæ–‡æ¡£æ•°æ®åº“åº”ç”¨)
  - [4. æ€»ç»“](#4-æ€»ç»“)

---


## 1. æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›æ•°æ®åº“ç³»ç»Ÿåœ¨å®é™…é¡¹ç›®ä¸­çš„å…·ä½“åº”ç”¨æ¡ˆä¾‹ï¼Œæ¶µç›–å…³ç³»å‹æ•°æ®åº“ã€NoSQLæ•°æ®åº“ã€NewSQLæ•°æ®åº“ç­‰å„ä¸ªæ–¹é¢çš„å®é™…åº”ç”¨ã€‚

## 2. å…³ç³»å‹æ•°æ®åº“å®è·µæ¡ˆä¾‹

### 2.1. ä¼ä¸šèµ„æºè§„åˆ’(ERP)ç³»ç»Ÿæ•°æ®åº“è®¾è®¡

```sql
-- åˆ›å»ºERPæ•°æ®åº“
CREATE DATABASE erp_system;
USE erp_system;

-- å‘˜å·¥ç®¡ç†æ¨¡å—
CREATE TABLE employees (
    employee_id INT PRIMARY KEY AUTO_INCREMENT,
    employee_code VARCHAR(20) UNIQUE NOT NULL,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    phone VARCHAR(20),
    hire_date DATE NOT NULL,
    department_id INT,
    position_id INT,
    manager_id INT,
    salary DECIMAL(10,2),
    status ENUM('active', 'inactive', 'terminated') DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_department (department_id),
    INDEX idx_manager (manager_id),
    INDEX idx_status (status)
);

-- éƒ¨é—¨è¡¨
CREATE TABLE departments (
    department_id INT PRIMARY KEY AUTO_INCREMENT,
    department_name VARCHAR(100) NOT NULL,
    department_code VARCHAR(20) UNIQUE NOT NULL,
    parent_department_id INT,
    manager_id INT,
    budget DECIMAL(15,2),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (parent_department_id) REFERENCES departments(department_id),
    FOREIGN KEY (manager_id) REFERENCES employees(employee_id)
);

-- èŒä½è¡¨
CREATE TABLE positions (
    position_id INT PRIMARY KEY AUTO_INCREMENT,
    position_title VARCHAR(100) NOT NULL,
    position_level INT,
    base_salary DECIMAL(10,2),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- åº“å­˜ç®¡ç†æ¨¡å—
CREATE TABLE products (
    product_id INT PRIMARY KEY AUTO_INCREMENT,
    product_code VARCHAR(50) UNIQUE NOT NULL,
    product_name VARCHAR(200) NOT NULL,
    description TEXT,
    category_id INT,
    unit_price DECIMAL(10,2) NOT NULL,
    cost_price DECIMAL(10,2),
    supplier_id INT,
    min_stock_level INT DEFAULT 0,
    max_stock_level INT,
    current_stock INT DEFAULT 0,
    unit_of_measure VARCHAR(20),
    status ENUM('active', 'discontinued', 'out_of_stock') DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_category (category_id),
    INDEX idx_supplier (supplier_id),
    INDEX idx_status (status)
);

-- äº§å“åˆ†ç±»è¡¨
CREATE TABLE product_categories (
    category_id INT PRIMARY KEY AUTO_INCREMENT,
    category_name VARCHAR(100) NOT NULL,
    parent_category_id INT,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (parent_category_id) REFERENCES product_categories(category_id)
);

-- ä¾›åº”å•†è¡¨
CREATE TABLE suppliers (
    supplier_id INT PRIMARY KEY AUTO_INCREMENT,
    supplier_code VARCHAR(50) UNIQUE NOT NULL,
    supplier_name VARCHAR(200) NOT NULL,
    contact_person VARCHAR(100),
    email VARCHAR(100),
    phone VARCHAR(20),
    address TEXT,
    tax_id VARCHAR(50),
    payment_terms INT DEFAULT 30,
    status ENUM('active', 'inactive') DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- é‡‡è´­è®¢å•è¡¨
CREATE TABLE purchase_orders (
    po_id INT PRIMARY KEY AUTO_INCREMENT,
    po_number VARCHAR(50) UNIQUE NOT NULL,
    supplier_id INT NOT NULL,
    order_date DATE NOT NULL,
    expected_delivery_date DATE,
    total_amount DECIMAL(15,2) DEFAULT 0,
    status ENUM('draft', 'sent', 'confirmed', 'received', 'cancelled') DEFAULT 'draft',
    created_by INT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (supplier_id) REFERENCES suppliers(supplier_id),
    FOREIGN KEY (created_by) REFERENCES employees(employee_id),
    INDEX idx_supplier (supplier_id),
    INDEX idx_status (status),
    INDEX idx_order_date (order_date)
);

-- é‡‡è´­è®¢å•æ˜ç»†è¡¨
CREATE TABLE purchase_order_items (
    po_item_id INT PRIMARY KEY AUTO_INCREMENT,
    po_id INT NOT NULL,
    product_id INT NOT NULL,
    quantity INT NOT NULL,
    unit_price DECIMAL(10,2) NOT NULL,
    total_price DECIMAL(10,2) NOT NULL,
    received_quantity INT DEFAULT 0,
    FOREIGN KEY (po_id) REFERENCES purchase_orders(po_id),
    FOREIGN KEY (product_id) REFERENCES products(product_id),
    INDEX idx_po (po_id),
    INDEX idx_product (product_id)
);

-- é”€å”®è®¢å•è¡¨
CREATE TABLE sales_orders (
    so_id INT PRIMARY KEY AUTO_INCREMENT,
    so_number VARCHAR(50) UNIQUE NOT NULL,
    customer_id INT NOT NULL,
    order_date DATE NOT NULL,
    delivery_date DATE,
    total_amount DECIMAL(15,2) DEFAULT 0,
    discount_amount DECIMAL(10,2) DEFAULT 0,
    tax_amount DECIMAL(10,2) DEFAULT 0,
    grand_total DECIMAL(15,2) DEFAULT 0,
    status ENUM('draft', 'confirmed', 'shipped', 'delivered', 'cancelled') DEFAULT 'draft',
    created_by INT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id),
    FOREIGN KEY (created_by) REFERENCES employees(employee_id),
    INDEX idx_customer (customer_id),
    INDEX idx_status (status),
    INDEX idx_order_date (order_date)
);

-- å®¢æˆ·è¡¨
CREATE TABLE customers (
    customer_id INT PRIMARY KEY AUTO_INCREMENT,
    customer_code VARCHAR(50) UNIQUE NOT NULL,
    customer_name VARCHAR(200) NOT NULL,
    contact_person VARCHAR(100),
    email VARCHAR(100),
    phone VARCHAR(20),
    address TEXT,
    credit_limit DECIMAL(15,2) DEFAULT 0,
    payment_terms INT DEFAULT 30,
    status ENUM('active', 'inactive') DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- åº“å­˜äº‹åŠ¡è¡¨
CREATE TABLE inventory_transactions (
    transaction_id INT PRIMARY KEY AUTO_INCREMENT,
    product_id INT NOT NULL,
    transaction_type ENUM('purchase', 'sale', 'adjustment', 'transfer') NOT NULL,
    quantity INT NOT NULL,
    unit_cost DECIMAL(10,2),
    reference_type ENUM('po', 'so', 'adjustment', 'transfer') NOT NULL,
    reference_id INT NOT NULL,
    transaction_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by INT,
    notes TEXT,
    FOREIGN KEY (product_id) REFERENCES products(product_id),
    FOREIGN KEY (created_by) REFERENCES employees(employee_id),
    INDEX idx_product (product_id),
    INDEX idx_transaction_type (transaction_type),
    INDEX idx_transaction_date (transaction_date)
);

-- åˆ›å»ºè§¦å‘å™¨æ›´æ–°åº“å­˜
DELIMITER //
CREATE TRIGGER update_product_stock
AFTER INSERT ON inventory_transactions
FOR EACH ROW
BEGIN
    IF NEW.transaction_type = 'purchase' THEN
        UPDATE products
        SET current_stock = current_stock + NEW.quantity
        WHERE product_id = NEW.product_id;
    ELSEIF NEW.transaction_type = 'sale' THEN
        UPDATE products
        SET current_stock = current_stock - NEW.quantity
        WHERE product_id = NEW.product_id;
    END IF;
END//
DELIMITER ;

-- åˆ›å»ºè§†å›¾ï¼šåº“å­˜çŠ¶æ€
CREATE VIEW inventory_status AS
SELECT
    p.product_id,
    p.product_code,
    p.product_name,
    pc.category_name,
    p.current_stock,
    p.min_stock_level,
    p.max_stock_level,
    p.unit_price,
    p.cost_price,
    (p.current_stock * p.cost_price) as inventory_value,
    CASE
        WHEN p.current_stock = 0 THEN 'Out of Stock'
        WHEN p.current_stock <= p.min_stock_level THEN 'Low Stock'
        WHEN p.current_stock >= p.max_stock_level THEN 'Overstocked'
        ELSE 'Normal'
    END as stock_status
FROM products p
LEFT JOIN product_categories pc ON p.category_id = pc.category_id
WHERE p.status = 'active';

-- åˆ›å»ºå­˜å‚¨è¿‡ç¨‹ï¼šç”Ÿæˆé‡‡è´­å»ºè®®
DELIMITER //
CREATE PROCEDURE generate_purchase_suggestions()
BEGIN
    SELECT
        p.product_id,
        p.product_code,
        p.product_name,
        p.current_stock,
        p.min_stock_level,
        (p.min_stock_level - p.current_stock) as suggested_quantity,
        s.supplier_name,
        s.supplier_id
    FROM products p
    LEFT JOIN suppliers s ON p.supplier_id = s.supplier_id
    WHERE p.current_stock <= p.min_stock_level
    AND p.status = 'active'
    AND s.status = 'active';
END//
DELIMITER ;

-- åˆ›å»ºå­˜å‚¨è¿‡ç¨‹ï¼šè®¡ç®—åº“å­˜ä»·å€¼
DELIMITER //
CREATE PROCEDURE calculate_inventory_value()
BEGIN
    SELECT
        SUM(current_stock * cost_price) as total_inventory_value,
        COUNT(*) as total_products,
        COUNT(CASE WHEN current_stock = 0 THEN 1 END) as out_of_stock_products,
        COUNT(CASE WHEN current_stock <= min_stock_level THEN 1 END) as low_stock_products
    FROM products
    WHERE status = 'active';
END//
DELIMITER ;
```

### 2.2. è´¢åŠ¡ç®¡ç†ç³»ç»Ÿæ•°æ®åº“è®¾è®¡

```sql
-- åˆ›å»ºè´¢åŠ¡æ•°æ®åº“
CREATE DATABASE financial_management;
USE financial_management;

-- ä¼šè®¡ç§‘ç›®è¡¨
CREATE TABLE chart_of_accounts (
    account_id INT PRIMARY KEY AUTO_INCREMENT,
    account_code VARCHAR(20) UNIQUE NOT NULL,
    account_name VARCHAR(200) NOT NULL,
    account_type ENUM('asset', 'liability', 'equity', 'revenue', 'expense') NOT NULL,
    parent_account_id INT,
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (parent_account_id) REFERENCES chart_of_accounts(account_id),
    INDEX idx_account_type (account_type),
    INDEX idx_parent (parent_account_id)
);

-- ä¼šè®¡æœŸé—´è¡¨
CREATE TABLE accounting_periods (
    period_id INT PRIMARY KEY AUTO_INCREMENT,
    period_name VARCHAR(20) NOT NULL,
    start_date DATE NOT NULL,
    end_date DATE NOT NULL,
    is_closed BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE KEY unique_period (start_date, end_date)
);

-- æ€»è´¦è¡¨
CREATE TABLE general_ledger (
    entry_id INT PRIMARY KEY AUTO_INCREMENT,
    period_id INT NOT NULL,
    account_id INT NOT NULL,
    transaction_date DATE NOT NULL,
    reference_type VARCHAR(50),
    reference_id INT,
    description TEXT,
    debit_amount DECIMAL(15,2) DEFAULT 0,
    credit_amount DECIMAL(15,2) DEFAULT 0,
    balance DECIMAL(15,2),
    created_by INT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (period_id) REFERENCES accounting_periods(period_id),
    FOREIGN KEY (account_id) REFERENCES chart_of_accounts(account_id),
    INDEX idx_period_account (period_id, account_id),
    INDEX idx_transaction_date (transaction_date),
    INDEX idx_reference (reference_type, reference_id)
);

-- åº”æ”¶è´¦æ¬¾è¡¨
CREATE TABLE accounts_receivable (
    ar_id INT PRIMARY KEY AUTO_INCREMENT,
    customer_id INT NOT NULL,
    invoice_number VARCHAR(50) UNIQUE NOT NULL,
    invoice_date DATE NOT NULL,
    due_date DATE NOT NULL,
    amount DECIMAL(15,2) NOT NULL,
    paid_amount DECIMAL(15,2) DEFAULT 0,
    remaining_amount DECIMAL(15,2) NOT NULL,
    status ENUM('open', 'partial', 'paid', 'overdue', 'bad_debt') DEFAULT 'open',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_customer (customer_id),
    INDEX idx_status (status),
    INDEX idx_due_date (due_date)
);

-- åº”ä»˜è´¦æ¬¾è¡¨
CREATE TABLE accounts_payable (
    ap_id INT PRIMARY KEY AUTO_INCREMENT,
    supplier_id INT NOT NULL,
    invoice_number VARCHAR(50) NOT NULL,
    invoice_date DATE NOT NULL,
    due_date DATE NOT NULL,
    amount DECIMAL(15,2) NOT NULL,
    paid_amount DECIMAL(15,2) DEFAULT 0,
    remaining_amount DECIMAL(15,2) NOT NULL,
    status ENUM('open', 'partial', 'paid', 'overdue') DEFAULT 'open',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_supplier (supplier_id),
    INDEX idx_status (status),
    INDEX idx_due_date (due_date)
);

-- é“¶è¡Œè´¦æˆ·è¡¨
CREATE TABLE bank_accounts (
    bank_account_id INT PRIMARY KEY AUTO_INCREMENT,
    account_name VARCHAR(100) NOT NULL,
    account_number VARCHAR(50) NOT NULL,
    bank_name VARCHAR(100) NOT NULL,
    account_type ENUM('checking', 'savings', 'credit') NOT NULL,
    opening_balance DECIMAL(15,2) DEFAULT 0,
    current_balance DECIMAL(15,2) DEFAULT 0,
    currency VARCHAR(3) DEFAULT 'USD',
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE KEY unique_account (bank_name, account_number)
);

-- é“¶è¡Œäº¤æ˜“è¡¨
CREATE TABLE bank_transactions (
    transaction_id INT PRIMARY KEY AUTO_INCREMENT,
    bank_account_id INT NOT NULL,
    transaction_date DATE NOT NULL,
    description TEXT,
    reference_number VARCHAR(50),
    debit_amount DECIMAL(15,2) DEFAULT 0,
    credit_amount DECIMAL(15,2) DEFAULT 0,
    balance DECIMAL(15,2),
    transaction_type ENUM('deposit', 'withdrawal', 'transfer', 'fee', 'interest') NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (bank_account_id) REFERENCES bank_accounts(bank_account_id),
    INDEX idx_bank_account (bank_account_id),
    INDEX idx_transaction_date (transaction_date),
    INDEX idx_transaction_type (transaction_type)
);

-- åˆ›å»ºè§¦å‘å™¨ï¼šæ›´æ–°é“¶è¡Œè´¦æˆ·ä½™é¢
DELIMITER //
CREATE TRIGGER update_bank_balance
AFTER INSERT ON bank_transactions
FOR EACH ROW
BEGIN
    UPDATE bank_accounts
    SET current_balance = current_balance + NEW.credit_amount - NEW.debit_amount
    WHERE bank_account_id = NEW.bank_account_id;
END//
DELIMITER ;

-- åˆ›å»ºè§†å›¾ï¼šåº”æ”¶è´¦æ¬¾æ±‡æ€»
CREATE VIEW ar_summary AS
SELECT
    customer_id,
    COUNT(*) as total_invoices,
    SUM(amount) as total_amount,
    SUM(paid_amount) as total_paid,
    SUM(remaining_amount) as total_outstanding,
    MAX(due_date) as latest_due_date,
    COUNT(CASE WHEN status = 'overdue' THEN 1 END) as overdue_invoices
FROM accounts_receivable
GROUP BY customer_id;

-- åˆ›å»ºè§†å›¾ï¼šåº”ä»˜è´¦æ¬¾æ±‡æ€»
CREATE VIEW ap_summary AS
SELECT
    supplier_id,
    COUNT(*) as total_invoices,
    SUM(amount) as total_amount,
    SUM(paid_amount) as total_paid,
    SUM(remaining_amount) as total_outstanding,
    MAX(due_date) as latest_due_date,
    COUNT(CASE WHEN status = 'overdue' THEN 1 END) as overdue_invoices
FROM accounts_payable
GROUP BY supplier_id;

-- åˆ›å»ºå­˜å‚¨è¿‡ç¨‹ï¼šç”Ÿæˆè¯•ç®—å¹³è¡¡è¡¨
DELIMITER //
CREATE PROCEDURE generate_trial_balance(IN period_id_param INT)
BEGIN
    SELECT
        coa.account_code,
        coa.account_name,
        coa.account_type,
        SUM(gl.debit_amount) as total_debits,
        SUM(gl.credit_amount) as total_credits,
        (SUM(gl.debit_amount) - SUM(gl.credit_amount)) as balance
    FROM chart_of_accounts coa
    LEFT JOIN general_ledger gl ON coa.account_id = gl.account_id
        AND gl.period_id = period_id_param
    WHERE coa.is_active = TRUE
    GROUP BY coa.account_id, coa.account_code, coa.account_name, coa.account_type
    ORDER BY coa.account_code;
END//
DELIMITER ;

-- åˆ›å»ºå­˜å‚¨è¿‡ç¨‹ï¼šç”ŸæˆæŸç›Šè¡¨
DELIMITER //
CREATE PROCEDURE generate_income_statement(IN period_id_param INT)
BEGIN
    SELECT
        coa.account_code,
        coa.account_name,
        SUM(gl.credit_amount - gl.debit_amount) as amount
    FROM chart_of_accounts coa
    LEFT JOIN general_ledger gl ON coa.account_id = gl.account_id
        AND gl.period_id = period_id_param
    WHERE coa.account_type IN ('revenue', 'expense')
    AND coa.is_active = TRUE
    GROUP BY coa.account_id, coa.account_code, coa.account_name
    ORDER BY coa.account_type, coa.account_code;
END//
DELIMITER ;
```

## 3. NoSQLæ•°æ®åº“å®è·µæ¡ˆä¾‹

### 3.1. MongoDBæ–‡æ¡£æ•°æ®åº“åº”ç”¨

```javascript
// MongoDBè¿æ¥é…ç½®
const { MongoClient } = require('mongodb');

const uri = "mongodb://localhost:27017";
const client = new MongoClient(uri);

// ç”µå•†ç³»ç»Ÿæ•°æ®æ¨¡å‹
class EcommerceSystem {
    constructor() {
        this.db = null;
        this.collections = {};
    }

    async connect() {
        try {
            await client.connect();
            this.db = client.db("ecommerce");
            this.collections = {
                users: this.db.collection("users"),
                products: this.db.collection("products"),
                orders: this.db.collection("orders"),
                categories: this.db.collection("categories")
            };
            console.log("Connected to MongoDB");
        } catch (error) {
            console.error("Connection error:", error);
        }
    }

    // ç”¨æˆ·ç®¡ç†
    async createUser(userData) {
        const user = {
            _id: new ObjectId(),
            username: userData.username,
            email: userData.email,
            password_hash: userData.password_hash,
            profile: {
                first_name: userData.first_name,
                last_name: userData.last_name,
                phone: userData.phone,
                address: userData.address
            },
            preferences: {
                language: "zh-CN",
                currency: "CNY",
                notifications: {
                    email: true,
                    sms: false,
                    push: true
                }
            },
            created_at: new Date(),
            updated_at: new Date(),
            status: "active"
        };

        const result = await this.collections.users.insertOne(user);
        return result.insertedId;
    }

    async getUserById(userId) {
        return await this.collections.users.findOne({ _id: new ObjectId(userId) });
    }

    async updateUserProfile(userId, profileData) {
        const updateData = {
            $set: {
                "profile": { ...profileData },
                updated_at: new Date()
            }
        };
        return await this.collections.users.updateOne(
            { _id: new ObjectId(userId) },
            updateData
        );
    }

    // äº§å“ç®¡ç†
    async createProduct(productData) {
        const product = {
            _id: new ObjectId(),
            name: productData.name,
            description: productData.description,
            price: {
                amount: productData.price,
                currency: "CNY",
                original_price: productData.original_price || productData.price,
                discount_percentage: productData.discount_percentage || 0
            },
            category: {
                id: new ObjectId(productData.category_id),
                name: productData.category_name
            },
            attributes: productData.attributes || {},
            inventory: {
                stock_quantity: productData.stock_quantity,
                reserved_quantity: 0,
                min_stock_level: productData.min_stock_level || 10
            },
            images: productData.images || [],
            tags: productData.tags || [],
            ratings: {
                average: 0,
                count: 0,
                reviews: []
            },
            created_at: new Date(),
            updated_at: new Date(),
            status: "active"
        };

        const result = await this.collections.products.insertOne(product);
        return result.insertedId;
    }

    async searchProducts(searchCriteria) {
        const filter = {};

        if (searchCriteria.keyword) {
            filter.$text = { $search: searchCriteria.keyword };
        }

        if (searchCriteria.category_id) {
            filter["category.id"] = new ObjectId(searchCriteria.category_id);
        }

        if (searchCriteria.min_price || searchCriteria.max_price) {
            filter["price.amount"] = {};
            if (searchCriteria.min_price) {
                filter["price.amount"].$gte = searchCriteria.min_price;
            }
            if (searchCriteria.max_price) {
                filter["price.amount"].$lte = searchCriteria.max_price;
            }
        }

        const options = {
            sort: { [searchCriteria.sort_by || "created_at"]: searchCriteria.sort_order || -1 },
            limit: searchCriteria.limit || 20,
            skip: searchCriteria.skip || 0
        };

        return await this.collections.products.find(filter, options).toArray();
    }

    // è®¢å•ç®¡ç†
    async createOrder(orderData) {
        const order = {
            _id: new ObjectId(),
            order_number: this.generateOrderNumber(),
            user_id: new ObjectId(orderData.user_id),
            items: orderData.items.map(item => ({
                product_id: new ObjectId(item.product_id),
                name: item.name,
                price: item.price,
                quantity: item.quantity,
                total: item.price * item.quantity
            })),
            totals: {
                subtotal: orderData.subtotal,
                tax: orderData.tax,
                shipping: orderData.shipping,
                discount: orderData.discount,
                grand_total: orderData.grand_total
            },
            shipping: {
                address: orderData.shipping_address,
                method: orderData.shipping_method,
                tracking_number: null
            },
            payment: {
                method: orderData.payment_method,
                status: "pending",
                transaction_id: null
            },
            status: "pending",
            created_at: new Date(),
            updated_at: new Date()
        };

        const result = await this.collections.orders.insertOne(order);

        // æ›´æ–°åº“å­˜
        await this.updateInventory(order.items);

        return result.insertedId;
    }

    async updateOrderStatus(orderId, status, additionalData = {}) {
        const updateData = {
            $set: {
                status: status,
                updated_at: new Date(),
                ...additionalData
            }
        };

        if (status === "shipped" && additionalData.tracking_number) {
            updateData.$set["shipping.tracking_number"] = additionalData.tracking_number;
        }

        if (status === "paid" && additionalData.transaction_id) {
            updateData.$set["payment.transaction_id"] = additionalData.transaction_id;
            updateData.$set["payment.status"] = "completed";
        }

        return await this.collections.orders.updateOne(
            { _id: new ObjectId(orderId) },
            updateData
        );
    }

    async getUserOrders(userId, options = {}) {
        const filter = { user_id: new ObjectId(userId) };

        if (options.status) {
            filter.status = options.status;
        }

        const sortOptions = { created_at: -1 };
        if (options.sort_by) {
            sortOptions[options.sort_by] = options.sort_order || -1;
        }

        return await this.collections.orders
            .find(filter)
            .sort(sortOptions)
            .limit(options.limit || 10)
            .skip(options.skip || 0)
            .toArray();
    }

    // åº“å­˜ç®¡ç†
    async updateInventory(items) {
        for (const item of items) {
            await this.collections.products.updateOne(
                { _id: new ObjectId(item.product_id) },
                {
                    $inc: {
                        "inventory.stock_quantity": -item.quantity,
                        "inventory.reserved_quantity": item.quantity
                    }
                }
            );
        }
    }

    async releaseReservedInventory(items) {
        for (const item of items) {
            await this.collections.products.updateOne(
                { _id: new ObjectId(item.product_id) },
                {
                    $inc: {
                        "inventory.reserved_quantity": -item.quantity
                    }
                }
            );
        }
    }

    // åˆ†ææŸ¥è¯¢
    async getSalesAnalytics(startDate, endDate) {
        const pipeline = [
            {
                $match: {
                    created_at: {
                        $gte: new Date(startDate),
                        $lte: new Date(endDate)
                    },
                    status: { $in: ["completed", "shipped"] }
                }
            },
            {
                $group: {
                    _id: {
                        year: { $year: "$created_at" },
                        month: { $month: "$created_at" },
                        day: { $dayOfMonth: "$created_at" }
                    },
                    total_sales: { $sum: "$totals.grand_total" },
                    order_count: { $sum: 1 },
                    average_order_value: { $avg: "$totals.grand_total" }
                }
            },
            {
                $sort: { "_id.year": 1, "_id.month": 1, "_id.day": 1 }
            }
        ];

        return await this.collections.orders.aggregate(pipeline).toArray();
    }

    async getTopProducts(limit = 10) {
        const pipeline = [
            {
                $unwind: "$items"
            },
            {
                $group: {
                    _id: "$items.product_id",
                    total_quantity: { $sum: "$items.quantity" },
                    total_revenue: { $sum: "$items.total" },
                    order_count: { $sum: 1 }
                }
            },
            {
                $lookup: {
                    from: "products",
                    localField: "_id",
                    foreignField: "_id",
                    as: "product"
                }
            },
            {
                $unwind: "$product"
            },
            {
                $project: {
                    product_name: "$product.name",
                    total_quantity: 1,
                    total_revenue: 1,
                    order_count: 1
                }
            },
            {
                $sort: { total_revenue: -1 }
            },
            {
                $limit: limit
            }
        ];

        return await this.collections.orders.aggregate(pipeline).toArray();
    }

    // å·¥å…·æ–¹æ³•
    generateOrderNumber() {
        const timestamp = Date.now().toString();
        const random = Math.floor(Math.random() * 1000).toString().padStart(3, '0');
        return `ORD${timestamp}${random}`;
    }

    async close() {
        await client.close();
    }
}

// ä½¿ç”¨ç¤ºä¾‹
async function ecommerceExample() {
    const ecommerce = new EcommerceSystem();
    await ecommerce.connect();

    try {
        // åˆ›å»ºç”¨æˆ·
        const userId = await ecommerce.createUser({
            username: "john_doe",
            email: "john@example.com",
            password_hash: "hashed_password",
            first_name: "John",
            last_name: "Doe",
            phone: "+1234567890",
            address: "123 Main St, City, Country"
        });

        // åˆ›å»ºäº§å“
        const productId = await ecommerce.createProduct({
            name: "iPhone 15 Pro",
            description: "Latest iPhone model with advanced features",
            price: 999.99,
            category_id: "507f1f77bcf86cd799439011",
            category_name: "Electronics",
            stock_quantity: 50,
            attributes: {
                color: "Space Black",
                storage: "256GB",
                brand: "Apple"
            },
            images: ["iphone15_1.jpg", "iphone15_2.jpg"],
            tags: ["smartphone", "apple", "5g"]
        });

        // åˆ›å»ºè®¢å•
        const orderId = await ecommerce.createOrder({
            user_id: userId.toString(),
            items: [{
                product_id: productId.toString(),
                name: "iPhone 15 Pro",
                price: 999.99,
                quantity: 1
            }],
            subtotal: 999.99,
            tax: 89.99,
            shipping: 0,
            discount: 0,
            grand_total: 1089.98,
            shipping_address: "123 Main St, City, Country",
            shipping_method: "standard",
            payment_method: "credit_card"
        });

        // è·å–é”€å”®åˆ†æ
        const analytics = await ecommerce.getSalesAnalytics(
            new Date('2024-01-01'),
            new Date('2024-12-31')
        );

        console.log("Sales Analytics:", analytics);

        // è·å–çƒ­é—¨äº§å“
        const topProducts = await ecommerce.getTopProducts(5);
        console.log("Top Products:", topProducts);

    } catch (error) {
        console.error("Error:", error);
    } finally {
        await ecommerce.close();
    }
}

module.exports = { EcommerceSystem };
```

## 4. æ€»ç»“

æœ¬æ–‡æ¡£æä¾›äº†æ•°æ®åº“ç³»ç»Ÿåœ¨å®é™…é¡¹ç›®ä¸­çš„å…·ä½“åº”ç”¨æ¡ˆä¾‹ï¼ŒåŒ…æ‹¬ï¼š

1. **å…³ç³»å‹æ•°æ®åº“å®è·µ**ï¼šä¼ä¸šèµ„æºè§„åˆ’(ERP)ç³»ç»Ÿå’Œè´¢åŠ¡ç®¡ç†ç³»ç»Ÿ
2. **NoSQLæ•°æ®åº“å®è·µ**ï¼šMongoDBæ–‡æ¡£æ•°æ®åº“åº”ç”¨

è¿™äº›æ¡ˆä¾‹å±•ç¤ºäº†æ•°æ®åº“ç³»ç»Ÿåœ¨å„ä¸ªé¢†åŸŸçš„å®é™…åº”ç”¨ï¼Œä¸ºæ•°æ®åº“é¡¹ç›®æä¾›äº†å®ç”¨çš„å‚è€ƒå’ŒæŒ‡å¯¼ã€‚
