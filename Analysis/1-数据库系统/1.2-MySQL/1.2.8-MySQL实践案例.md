# 1.2.8 MySQL实践案例

## 概述

本文档提供MySQL数据库系统的实际应用案例，涵盖数据库设计、查询优化、性能调优、高可用配置等核心主题。每个案例都包含完整的代码示例和最佳实践。

## 目录

- [1.2.8 MySQL实践案例](#128-mysql实践案例)
  - [概述](#概述)
  - [目录](#目录)
  - [1. 数据库设计实践案例](#1-数据库设计实践案例)
    - [1.1 电商系统数据库设计](#11-电商系统数据库设计)
    - [1.2 数据库设计最佳实践](#12-数据库设计最佳实践)
  - [2. 查询优化实践案例](#2-查询优化实践案例)
    - [2.1 复杂查询优化](#21-复杂查询优化)
    - [2.2 子查询优化](#22-子查询优化)
  - [3. 性能调优实践案例](#3-性能调优实践案例)
    - [3.1 索引优化](#31-索引优化)
    - [3.2 配置优化](#32-配置优化)
  - [4. 高可用配置实践案例](#4-高可用配置实践案例)
    - [4.1 主从复制配置](#41-主从复制配置)
    - [4.2 读写分离配置](#42-读写分离配置)
  - [5. 安全配置实践案例](#5-安全配置实践案例)
    - [5.1 用户权限管理](#51-用户权限管理)
    - [5.2 数据加密](#52-数据加密)
  - [总结](#总结)

## 1. 数据库设计实践案例

### 1.1 电商系统数据库设计

```sql
-- 创建电商系统数据库
CREATE DATABASE ecommerce_system CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
USE ecommerce_system;

-- 用户表
CREATE TABLE users (
    user_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    phone VARCHAR(20),
    status ENUM('active', 'inactive', 'suspended') DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_email (email),
    INDEX idx_username (username),
    INDEX idx_status (status)
) ENGINE=InnoDB;

-- 商品表
CREATE TABLE products (
    product_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    description TEXT,
    price DECIMAL(10,2) NOT NULL,
    stock_quantity INT UNSIGNED NOT NULL DEFAULT 0,
    category_id BIGINT UNSIGNED,
    status ENUM('active', 'inactive', 'out_of_stock') DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_category (category_id),
    INDEX idx_status (status),
    INDEX idx_price (price),
    FULLTEXT idx_search (name, description)
) ENGINE=InnoDB;

-- 订单表
CREATE TABLE orders (
    order_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    user_id BIGINT UNSIGNED NOT NULL,
    order_number VARCHAR(50) UNIQUE NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    status ENUM('pending', 'paid', 'shipped', 'delivered', 'cancelled') DEFAULT 'pending',
    payment_method ENUM('credit_card', 'paypal', 'alipay') NOT NULL,
    shipping_address TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_user (user_id),
    INDEX idx_status (status),
    INDEX idx_created_at (created_at),
    FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE
) ENGINE=InnoDB;

-- 订单详情表
CREATE TABLE order_items (
    item_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    order_id BIGINT UNSIGNED NOT NULL,
    product_id BIGINT UNSIGNED NOT NULL,
    quantity INT UNSIGNED NOT NULL,
    unit_price DECIMAL(10,2) NOT NULL,
    total_price DECIMAL(10,2) NOT NULL,
    INDEX idx_order (order_id),
    INDEX idx_product (product_id),
    FOREIGN KEY (order_id) REFERENCES orders(order_id) ON DELETE CASCADE,
    FOREIGN KEY (product_id) REFERENCES products(product_id) ON DELETE CASCADE
) ENGINE=InnoDB;
```

### 1.2 数据库设计最佳实践

```sql
-- 1. 使用适当的数据类型
CREATE TABLE optimized_table (
    id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,  -- 使用UNSIGNED节省空间
    status TINYINT UNSIGNED DEFAULT 1,          -- 使用TINYINT而不是VARCHAR
    created_date DATE NOT NULL,                 -- 使用DATE而不是DATETIME
    amount DECIMAL(10,2) NOT NULL,              -- 使用DECIMAL而不是FLOAT
    description VARCHAR(255)                    -- 限制VARCHAR长度
);

-- 2. 创建复合索引
CREATE INDEX idx_user_status_date ON orders(user_id, status, created_at);

-- 3. 使用覆盖索引
CREATE INDEX idx_product_cover ON products(product_id, name, price, status);

-- 4. 分区表设计
CREATE TABLE orders_partitioned (
    order_id BIGINT UNSIGNED AUTO_INCREMENT,
    user_id BIGINT UNSIGNED NOT NULL,
    order_date DATE NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    PRIMARY KEY (order_id, order_date)
) PARTITION BY RANGE (YEAR(order_date)) (
    PARTITION p2022 VALUES LESS THAN (2023),
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

## 2. 查询优化实践案例

### 2.1 复杂查询优化

```sql
-- 原始查询（性能较差）
SELECT 
    u.username,
    COUNT(o.order_id) as order_count,
    SUM(o.total_amount) as total_spent
FROM users u
LEFT JOIN orders o ON u.user_id = o.user_id
WHERE u.status = 'active'
GROUP BY u.user_id, u.username
HAVING total_spent > 1000
ORDER BY total_spent DESC;

-- 优化后的查询
SELECT 
    u.username,
    COALESCE(order_stats.order_count, 0) as order_count,
    COALESCE(order_stats.total_spent, 0) as total_spent
FROM users u
LEFT JOIN (
    SELECT 
        user_id,
        COUNT(*) as order_count,
        SUM(total_amount) as total_spent
    FROM orders 
    WHERE status IN ('paid', 'shipped', 'delivered')
    GROUP BY user_id
    HAVING SUM(total_amount) > 1000
) order_stats ON u.user_id = order_stats.user_id
WHERE u.status = 'active'
ORDER BY order_stats.total_spent DESC;

-- 使用EXPLAIN分析查询计划
EXPLAIN FORMAT=JSON
SELECT 
    p.name,
    p.price,
    COUNT(oi.item_id) as sales_count
FROM products p
JOIN order_items oi ON p.product_id = oi.product_id
JOIN orders o ON oi.order_id = o.order_id
WHERE o.status = 'delivered'
    AND o.created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)
GROUP BY p.product_id
ORDER BY sales_count DESC
LIMIT 10;
```

### 2.2 子查询优化

```sql
-- 使用EXISTS替代IN
-- 原始查询
SELECT * FROM products 
WHERE category_id IN (
    SELECT category_id FROM categories 
    WHERE parent_id = 1
);

-- 优化后的查询
SELECT p.* FROM products p
WHERE EXISTS (
    SELECT 1 FROM categories c 
    WHERE c.category_id = p.category_id 
    AND c.parent_id = 1
);

-- 使用JOIN替代子查询
SELECT DISTINCT p.* 
FROM products p
JOIN categories c ON p.category_id = c.category_id
WHERE c.parent_id = 1;
```

## 3. 性能调优实践案例

### 3.1 索引优化

```sql
-- 分析慢查询
SHOW VARIABLES LIKE 'slow_query_log%';
SHOW VARIABLES LIKE 'long_query_time';

-- 查看当前索引使用情况
SELECT 
    table_name,
    index_name,
    cardinality,
    sub_part,
    packed,
    nullable,
    index_type
FROM information_schema.statistics 
WHERE table_schema = 'ecommerce_system'
ORDER BY table_name, index_name;

-- 创建复合索引优化多列查询
CREATE INDEX idx_orders_user_status_date ON orders(user_id, status, created_at);

-- 创建部分索引
CREATE INDEX idx_products_active ON products(product_id, name, price) 
WHERE status = 'active';

-- 使用覆盖索引
CREATE INDEX idx_orders_cover ON orders(order_id, user_id, status, total_amount, created_at);
```

### 3.2 配置优化

```sql
-- 查看当前配置
SHOW VARIABLES LIKE 'innodb_buffer_pool_size';
SHOW VARIABLES LIKE 'innodb_log_file_size';
SHOW VARIABLES LIKE 'max_connections';

-- 优化配置示例（my.cnf）
[mysqld]
# 缓冲池大小（建议为内存的70-80%）
innodb_buffer_pool_size = 4G

# 日志文件大小
innodb_log_file_size = 256M
innodb_log_files_in_group = 2

# 连接数
max_connections = 1000

# 查询缓存
query_cache_type = 1
query_cache_size = 128M

# 临时表大小
tmp_table_size = 64M
max_heap_table_size = 64M

# 排序缓冲区
sort_buffer_size = 2M
read_buffer_size = 1M
read_rnd_buffer_size = 2M
```

## 4. 高可用配置实践案例

### 4.1 主从复制配置

```sql
-- 主库配置（my.cnf）
[mysqld]
server-id = 1
log-bin = mysql-bin
binlog_format = ROW
sync_binlog = 1
innodb_flush_log_at_trx_commit = 1

-- 从库配置（my.cnf）
[mysqld]
server-id = 2
relay-log = mysql-relay-bin
read_only = 1
log_slave_updates = 1

-- 在主库创建复制用户
CREATE USER 'repl'@'%' IDENTIFIED BY 'password';
GRANT REPLICATION SLAVE ON *.* TO 'repl'@'%';

-- 在从库配置复制
CHANGE MASTER TO
    MASTER_HOST = 'master_host',
    MASTER_USER = 'repl',
    MASTER_PASSWORD = 'password',
    MASTER_LOG_FILE = 'mysql-bin.000001',
    MASTER_LOG_POS = 154;

START SLAVE;
SHOW SLAVE STATUS\G
```

### 4.2 读写分离配置

```sql
-- 使用ProxySQL配置读写分离
-- 配置服务器组
INSERT INTO mysql_servers(hostgroup_id, hostname, port) VALUES
(10, 'master_host', 3306),    -- 写组
(20, 'slave1_host', 3306),    -- 读组
(20, 'slave2_host', 3306);    -- 读组

-- 配置用户
INSERT INTO mysql_users(username, password, default_hostgroup) VALUES
('app_user', 'password', 10);

-- 配置查询规则
INSERT INTO mysql_query_rules(rule_id, active, match_pattern, destination_hostgroup) VALUES
(1, 1, '^SELECT.*FOR UPDATE', 10),  -- SELECT FOR UPDATE路由到主库
(2, 1, '^SELECT', 20),              -- 其他SELECT路由到从库
(3, 1, '^INSERT|^UPDATE|^DELETE', 10); -- 写操作路由到主库
```

## 5. 安全配置实践案例

### 5.1 用户权限管理

```sql
-- 创建应用用户
CREATE USER 'app_user'@'%' IDENTIFIED BY 'strong_password';

-- 授予最小权限
GRANT SELECT, INSERT, UPDATE, DELETE ON ecommerce_system.* TO 'app_user'@'%';
GRANT SELECT ON ecommerce_system.products TO 'app_user'@'%';

-- 创建只读用户
CREATE USER 'readonly_user'@'%' IDENTIFIED BY 'readonly_password';
GRANT SELECT ON ecommerce_system.* TO 'readonly_user'@'%';

-- 创建管理员用户
CREATE USER 'admin_user'@'localhost' IDENTIFIED BY 'admin_password';
GRANT ALL PRIVILEGES ON *.* TO 'admin_user'@'localhost' WITH GRANT OPTION;

-- 查看用户权限
SHOW GRANTS FOR 'app_user'@'%';
```

### 5.2 数据加密

```sql
-- 启用SSL连接
-- 在my.cnf中配置
[mysqld]
ssl-ca = /path/to/ca.pem
ssl-cert = /path/to/server-cert.pem
ssl-key = /path/to/server-key.pem

-- 要求SSL连接
ALTER USER 'app_user'@'%' REQUIRE SSL;

-- 列级加密
CREATE TABLE sensitive_data (
    id INT PRIMARY KEY,
    encrypted_ssn VARBINARY(255),
    encrypted_credit_card VARBINARY(255)
);

-- 使用AES加密
INSERT INTO sensitive_data (id, encrypted_ssn, encrypted_credit_card) VALUES
(1, 
 AES_ENCRYPT('123-45-6789', 'encryption_key'),
 AES_ENCRYPT('4111111111111111', 'encryption_key')
);

-- 解密数据
SELECT 
    id,
    AES_DECRYPT(encrypted_ssn, 'encryption_key') as ssn,
    AES_DECRYPT(encrypted_credit_card, 'encryption_key') as credit_card
FROM sensitive_data;
```

## 总结

这些实践案例展示了MySQL数据库系统的核心应用场景，包括：

1. **数据库设计**：合理的表结构设计和索引策略
2. **查询优化**：通过索引优化和查询重写提升性能
3. **性能调优**：系统配置和参数优化
4. **高可用配置**：主从复制和读写分离
5. **安全配置**：用户权限管理和数据加密

每个案例都提供了完整的代码示例和最佳实践，可以直接应用于实际项目中。

**相关链接：**

- [1.2.1-形式模型](1.2.1-形式模型.md)
- [1.2.2-系统架构](1.2.2-系统架构.md)
- [1.2.3-数据模型](1.2.3-数据模型.md)
- [1.2.4-查询优化](1.2.4-查询优化.md)
- [1.2.5-分布式与高可用](1.2.5-分布式与高可用.md)
- [1.2.6-性能调优与监控](1.2.6-性能调优与监控.md)
- [1.2.7-安全与合规](1.2.7-安全与合规.md)
