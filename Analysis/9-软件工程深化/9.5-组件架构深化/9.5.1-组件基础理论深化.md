# 9.5.1 ç»„ä»¶åŸºç¡€ç†è®ºæ·±åŒ–

## ğŸ“‘ ç›®å½•

- [9.5.1 ç»„ä»¶åŸºç¡€ç†è®ºæ·±åŒ–](#951-ç»„ä»¶åŸºç¡€ç†è®ºæ·±åŒ–)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. ç†è®ºåŸºç¡€](#1-ç†è®ºåŸºç¡€)
    - [1.1. ç»„ä»¶æ¦‚è¿°](#11-ç»„ä»¶æ¦‚è¿°)
    - [1.2. æ ¸å¿ƒç‰¹å¾](#12-æ ¸å¿ƒç‰¹å¾)
  - [2. æ¥å£è®¾è®¡](#2-æ¥å£è®¾è®¡)
    - [2.1. æ¥å£å®šä¹‰](#21-æ¥å£å®šä¹‰)
  - [3. æ¥å£å®ç°](#3-æ¥å£å®ç°)
  - [4. ä¾èµ–æ³¨å…¥](#4-ä¾èµ–æ³¨å…¥)
    - [4.1. ä¾èµ–æ³¨å…¥å®¹å™¨](#41-ä¾èµ–æ³¨å…¥å®¹å™¨)
  - [5. ç”Ÿå‘½å‘¨æœŸç®¡ç†](#5-ç”Ÿå‘½å‘¨æœŸç®¡ç†)
  - [6. æ’ä»¶æœºåˆ¶](#6-æ’ä»¶æœºåˆ¶)
    - [6.1. æ’ä»¶ç³»ç»Ÿ](#61-æ’ä»¶ç³»ç»Ÿ)
  - [7. ç»„ä»¶é€šä¿¡](#7-ç»„ä»¶é€šä¿¡)
    - [7.1. äº‹ä»¶æ€»çº¿](#71-äº‹ä»¶æ€»çº¿)
  - [8. æœ€ä½³å®è·µ](#8-æœ€ä½³å®è·µ)
    - [8.1. ç»„ä»¶è®¾è®¡åŸåˆ™](#81-ç»„ä»¶è®¾è®¡åŸåˆ™)
    - [8.2. æ€§èƒ½ä¼˜åŒ–](#82-æ€§èƒ½ä¼˜åŒ–)
    - [8.3. é”™è¯¯å¤„ç†](#83-é”™è¯¯å¤„ç†)
    - [8.4. å®‰å…¨è€ƒè™‘](#84-å®‰å…¨è€ƒè™‘)
  - [9. æ€»ç»“](#9-æ€»ç»“)

---


## 1. ç†è®ºåŸºç¡€

### 1.1. ç»„ä»¶æ¦‚è¿°

ç»„ä»¶(Component)æ˜¯è½¯ä»¶ç³»ç»Ÿä¸­å¯é‡ç”¨ã€å¯æ›¿æ¢çš„åŠŸèƒ½å•å…ƒï¼š

- **å°è£…æ€§**ï¼šç»„ä»¶å†…éƒ¨å®ç°å¯¹å¤–éƒ¨éšè—
- **æ¥å£åŒ–**ï¼šé€šè¿‡æ ‡å‡†æ¥å£ä¸å¤–éƒ¨äº¤äº’
- **å¯é‡ç”¨æ€§**ï¼šå¯åœ¨ä¸åŒåœºæ™¯ä¸­é‡å¤ä½¿ç”¨
- **å¯æ›¿æ¢æ€§**ï¼šæ”¯æŒåŠ¨æ€æ›¿æ¢å®ç°

### 1.2. æ ¸å¿ƒç‰¹å¾

- **é«˜å†…èš**ï¼šç»„ä»¶å†…éƒ¨åŠŸèƒ½ç´§å¯†ç›¸å…³
- **ä½è€¦åˆ**ï¼šç»„ä»¶é—´ä¾èµ–å…³ç³»æœ€å°åŒ–
- **æ ‡å‡†åŒ–**ï¼šéµå¾ªç»Ÿä¸€çš„æ¥å£è§„èŒƒ
- **å¯é…ç½®**ï¼šæ”¯æŒè¿è¡Œæ—¶é…ç½®è°ƒæ•´

## 2. æ¥å£è®¾è®¡

### 2.1. æ¥å£å®šä¹‰

```python
# ç»„ä»¶æ¥å£è®¾è®¡
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional
import asyncio

class ComponentInterface(ABC):
    """ç»„ä»¶åŸºç¡€æ¥å£"""

    @abstractmethod
    async def initialize(self, config: Dict[str, Any]) -> bool:
        """åˆå§‹åŒ–ç»„ä»¶"""
        pass

    @abstractmethod
    async def start(self) -> bool:
        """å¯åŠ¨ç»„ä»¶"""
        pass

    @abstractmethod
    async def stop(self) -> bool:
        """åœæ­¢ç»„ä»¶"""
        pass

    @abstractmethod
    async def get_status(self) -> Dict[str, Any]:
        """è·å–ç»„ä»¶çŠ¶æ€"""
        pass

class DataProcessorInterface(ComponentInterface):
    """æ•°æ®å¤„ç†ç»„ä»¶æ¥å£"""

    @abstractmethod
    async def process_data(self, data: Any) -> Any:
        """å¤„ç†æ•°æ®"""
        pass

    @abstractmethod
    async def get_processing_stats(self) -> Dict[str, Any]:
        """è·å–å¤„ç†ç»Ÿè®¡ä¿¡æ¯"""
        pass

class StorageInterface(ComponentInterface):
    """å­˜å‚¨ç»„ä»¶æ¥å£"""

    @abstractmethod
    async def store(self, key: str, value: Any) -> bool:
        """å­˜å‚¨æ•°æ®"""
        pass

    @abstractmethod
    async def retrieve(self, key: str) -> Optional[Any]:
        """æ£€ç´¢æ•°æ®"""
        pass

    @abstractmethod
    async def delete(self, key: str) -> bool:
        """åˆ é™¤æ•°æ®"""
        pass
```

## 3. æ¥å£å®ç°

```python
# å…·ä½“ç»„ä»¶å®ç°
import json
import time
from typing import Dict, Any, Optional

class DatabaseStorage(StorageInterface):
    """æ•°æ®åº“å­˜å‚¨ç»„ä»¶"""

    def __init__(self):
        self.connection = None
        self.is_initialized = False
        self.is_running = False

    async def initialize(self, config: Dict[str, Any]) -> bool:
        """åˆå§‹åŒ–æ•°æ®åº“è¿æ¥"""
        try:
# æ¨¡æ‹Ÿæ•°æ®åº“è¿æ¥
            self.connection = {
                'host': config.get('host', 'localhost'),
                'port': config.get('port', 5432),
                'database': config.get('database', 'default')
            }
            self.is_initialized = True
            print(f"Database storage initialized: {self.connection}")
            return True
        except Exception as e:
            print(f"Failed to initialize database storage: {e}")
            return False

    async def start(self) -> bool:
        """å¯åŠ¨å­˜å‚¨ç»„ä»¶"""
        if not self.is_initialized:
            print("Database storage not initialized")
            return False

        self.is_running = True
        print("Database storage started")
        return True

    async def stop(self) -> bool:
        """åœæ­¢å­˜å‚¨ç»„ä»¶"""
        self.is_running = False
        print("Database storage stopped")
        return True

    async def get_status(self) -> Dict[str, Any]:
        """è·å–ç»„ä»¶çŠ¶æ€"""
        return {
            'initialized': self.is_initialized,
            'running': self.is_running,
            'connection': self.connection
        }

    async def store(self, key: str, value: Any) -> bool:
        """å­˜å‚¨æ•°æ®"""
        if not self.is_running:
            return False

        try:
# æ¨¡æ‹Ÿæ•°æ®å­˜å‚¨
            print(f"Storing data: {key} = {value}")
            return True
        except Exception as e:
            print(f"Failed to store data: {e}")
            return False

    async def retrieve(self, key: str) -> Optional[Any]:
        """æ£€ç´¢æ•°æ®"""
        if not self.is_running:
            return None

        try:
# æ¨¡æ‹Ÿæ•°æ®æ£€ç´¢
            print(f"Retrieving data: {key}")
            return f"data_for_{key}"
        except Exception as e:
            print(f"Failed to retrieve data: {e}")
            return None

    async def delete(self, key: str) -> bool:
        """åˆ é™¤æ•°æ®"""
        if not self.is_running:
            return False

        try:
# æ¨¡æ‹Ÿæ•°æ®åˆ é™¤
            print(f"Deleting data: {key}")
            return True
        except Exception as e:
            print(f"Failed to delete data: {e}")
            return False

class FileStorage(StorageInterface):
    """æ–‡ä»¶å­˜å‚¨ç»„ä»¶"""

    def __init__(self):
        self.file_path = None
        self.is_initialized = False
        self.is_running = False

    async def initialize(self, config: Dict[str, Any]) -> bool:
        """åˆå§‹åŒ–æ–‡ä»¶å­˜å‚¨"""
        try:
            self.file_path = config.get('file_path', 'data.json')
            self.is_initialized = True
            print(f"File storage initialized: {self.file_path}")
            return True
        except Exception as e:
            print(f"Failed to initialize file storage: {e}")
            return False

    async def start(self) -> bool:
        """å¯åŠ¨æ–‡ä»¶å­˜å‚¨"""
        if not self.is_initialized:
            return False

        self.is_running = True
        print("File storage started")
        return True

    async def stop(self) -> bool:
        """åœæ­¢æ–‡ä»¶å­˜å‚¨"""
        self.is_running = False
        print("File storage stopped")
        return True

    async def get_status(self) -> Dict[str, Any]:
        """è·å–ç»„ä»¶çŠ¶æ€"""
        return {
            'initialized': self.is_initialized,
            'running': self.is_running,
            'file_path': self.file_path
        }

    async def store(self, key: str, value: Any) -> bool:
        """å­˜å‚¨æ•°æ®åˆ°æ–‡ä»¶"""
        if not self.is_running:
            return False

        try:
# æ¨¡æ‹Ÿæ–‡ä»¶å†™å…¥
            data = {key: value}
            print(f"Writing to file: {data}")
            return True
        except Exception as e:
            print(f"Failed to write to file: {e}")
            return False

    async def retrieve(self, key: str) -> Optional[Any]:
        """ä»æ–‡ä»¶æ£€ç´¢æ•°æ®"""
        if not self.is_running:
            return None

        try:
# æ¨¡æ‹Ÿæ–‡ä»¶è¯»å–
            print(f"Reading from file: {key}")
            return f"file_data_for_{key}"
        except Exception as e:
            print(f"Failed to read from file: {e}")
            return None

    async def delete(self, key: str) -> bool:
        """ä»æ–‡ä»¶åˆ é™¤æ•°æ®"""
        if not self.is_running:
            return False

        try:
# æ¨¡æ‹Ÿæ–‡ä»¶åˆ é™¤
            print(f"Deleting from file: {key}")
            return True
        except Exception as e:
            print(f"Failed to delete from file: {e}")
            return False
```

## 4. ä¾èµ–æ³¨å…¥

### 4.1. ä¾èµ–æ³¨å…¥å®¹å™¨

```python
# ä¾èµ–æ³¨å…¥å®¹å™¨
from typing import Dict, Type, Any, Optional
import inspect

class DependencyContainer:
    """ä¾èµ–æ³¨å…¥å®¹å™¨"""

    def __init__(self):
        self.registrations: Dict[str, Any] = {}
        self.singletons: Dict[str, Any] = {}

    def register(self, interface: Type, implementation: Type,
                singleton: bool = False, name: str = None):
        """æ³¨å†Œä¾èµ–"""
        key = name or interface.__name__
        self.registrations[key] = {
            'implementation': implementation,
            'singleton': singleton
        }

    def register_instance(self, interface: Type, instance: Any, name: str = None):
        """æ³¨å†Œå®ä¾‹"""
        key = name or interface.__name__
        self.singletons[key] = instance

    def resolve(self, interface: Type, name: str = None) -> Any:
        """è§£æä¾èµ–"""
        key = name or interface.__name__

# æ£€æŸ¥æ˜¯å¦æœ‰å·²æ³¨å†Œçš„å®ä¾‹
        if key in self.singletons:
            return self.singletons[key]

# æ£€æŸ¥æ˜¯å¦æœ‰æ³¨å†Œçš„å®ç°
        if key not in self.registrations:
            raise ValueError(f"No registration found for {key}")

        registration = self.registrations[key]
        implementation = registration['implementation']

# åˆ›å»ºå®ä¾‹
        instance = self.create_instance(implementation)

# å¦‚æœæ˜¯å•ä¾‹ï¼Œç¼“å­˜å®ä¾‹
        if registration['singleton']:
            self.singletons[key] = instance

        return instance

    def create_instance(self, implementation: Type) -> Any:
        """åˆ›å»ºå®ä¾‹"""
# è·å–æ„é€ å‡½æ•°çš„å‚æ•°
        sig = inspect.signature(implementation.__init__)
        params = {}

        for param_name, param in sig.parameters.items():
            if param_name == 'self':
                continue

# å°è¯•è§£æå‚æ•°ç±»å‹
            if param.annotation != inspect.Parameter.empty:
                try:
                    params[param_name] = self.resolve(param.annotation)
                except ValueError:
# å¦‚æœæ— æ³•è§£æï¼Œä½¿ç”¨é»˜è®¤å€¼
                    if param.default != inspect.Parameter.empty:
                        params[param_name] = param.default
                    else:
                        raise ValueError(f"Cannot resolve parameter {param_name}")

        return implementation(**params)

# ä½¿ç”¨ç¤ºä¾‹
class DataService:
    """æ•°æ®æœåŠ¡ï¼Œä¾èµ–å­˜å‚¨ç»„ä»¶"""

    def __init__(self, storage: StorageInterface):
        self.storage = storage

    async def save_data(self, key: str, value: Any) -> bool:
        """ä¿å­˜æ•°æ®"""
        return await self.storage.store(key, value)

    async def load_data(self, key: str) -> Optional[Any]:
        """åŠ è½½æ•°æ®"""
        return await self.storage.retrieve(key)

# é…ç½®ä¾èµ–æ³¨å…¥å®¹å™¨
container = DependencyContainer()

# æ³¨å†Œå­˜å‚¨ç»„ä»¶
container.register(StorageInterface, DatabaseStorage, singleton=True)

# æ³¨å†Œæ•°æ®æœåŠ¡
container.register(DataService, DataService)

# è§£æä¾èµ–
data_service = container.resolve(DataService)
print("Data service created with dependency injection")
```

## 5. ç”Ÿå‘½å‘¨æœŸç®¡ç†

```python
# ç»„ä»¶ç”Ÿå‘½å‘¨æœŸç®¡ç†
from typing import Dict, List, Any
import asyncio

class ComponentLifecycleManager:
    """ç»„ä»¶ç”Ÿå‘½å‘¨æœŸç®¡ç†å™¨"""

    def __init__(self):
        self.components: Dict[str, ComponentInterface] = {}
        self.dependencies: Dict[str, List[str]] = {}
        self.startup_order: List[str] = []
        self.shutdown_order: List[str] = []

    def register_component(self, name: str, component: ComponentInterface,
                          dependencies: List[str] = None):
        """æ³¨å†Œç»„ä»¶"""
        self.components[name] = component
        self.dependencies[name] = dependencies or []

    def calculate_startup_order(self) -> List[str]:
        """è®¡ç®—å¯åŠ¨é¡ºåº"""
# ä½¿ç”¨æ‹“æ‰‘æ’åºè®¡ç®—å¯åŠ¨é¡ºåº
        visited = set()
        temp_visited = set()
        order = []

        def visit(component_name):
            if component_name in temp_visited:
                raise ValueError(f"Circular dependency detected: {component_name}")
            if component_name in visited:
                return

            temp_visited.add(component_name)

            for dep in self.dependencies[component_name]:
                visit(dep)

            temp_visited.remove(component_name)
            visited.add(component_name)
            order.append(component_name)

        for component_name in self.components:
            if component_name not in visited:
                visit(component_name)

        self.startup_order = order
        self.shutdown_order = list(reversed(order))
        return order

    async def initialize_all(self, configs: Dict[str, Dict[str, Any]]) -> bool:
        """åˆå§‹åŒ–æ‰€æœ‰ç»„ä»¶"""
        try:
            for component_name in self.startup_order:
                component = self.components[component_name]
                config = configs.get(component_name, {})

                print(f"Initializing component: {component_name}")
                success = await component.initialize(config)

                if not success:
                    print(f"Failed to initialize component: {component_name}")
                    return False

            return True
        except Exception as e:
            print(f"Error during initialization: {e}")
            return False

    async def start_all(self) -> bool:
        """å¯åŠ¨æ‰€æœ‰ç»„ä»¶"""
        try:
            for component_name in self.startup_order:
                component = self.components[component_name]

                print(f"Starting component: {component_name}")
                success = await component.start()

                if not success:
                    print(f"Failed to start component: {component_name}")
                    return False

            return True
        except Exception as e:
            print(f"Error during startup: {e}")
            return False

    async def stop_all(self) -> bool:
        """åœæ­¢æ‰€æœ‰ç»„ä»¶"""
        try:
            for component_name in self.shutdown_order:
                component = self.components[component_name]

                print(f"Stopping component: {component_name}")
                success = await component.stop()

                if not success:
                    print(f"Failed to stop component: {component_name}")

            return True
        except Exception as e:
            print(f"Error during shutdown: {e}")
            return False

    async def get_all_status(self) -> Dict[str, Dict[str, Any]]:
        """è·å–æ‰€æœ‰ç»„ä»¶çŠ¶æ€"""
        status = {}
        for name, component in self.components.items():
            status[name] = await component.get_status()
        return status

# ä½¿ç”¨ç¤ºä¾‹
async def test_lifecycle_manager():
    manager = ComponentLifecycleManager()

# åˆ›å»ºç»„ä»¶
    db_storage = DatabaseStorage()
    file_storage = FileStorage()

# æ³¨å†Œç»„ä»¶
    manager.register_component("database", db_storage)
    manager.register_component("file_storage", file_storage, dependencies=["database"])

# è®¡ç®—å¯åŠ¨é¡ºåº
    startup_order = manager.calculate_startup_order()
    print(f"Startup order: {startup_order}")

# é…ç½®
    configs = {
        "database": {"host": "localhost", "port": 5432, "database": "test"},
        "file_storage": {"file_path": "data.json"}
    }

# åˆå§‹åŒ–
    success = await manager.initialize_all(configs)
    if not success:
        print("Initialization failed")
        return

# å¯åŠ¨
    success = await manager.start_all()
    if not success:
        print("Startup failed")
        return

# è·å–çŠ¶æ€
    status = await manager.get_all_status()
    print("Component status:", status)

# åœæ­¢
    await manager.stop_all()

# è¿è¡Œæµ‹è¯•
asyncio.run(test_lifecycle_manager())
```

## 6. æ’ä»¶æœºåˆ¶

### 6.1. æ’ä»¶ç³»ç»Ÿ

```python
# æ’ä»¶ç³»ç»Ÿå®ç°
import os
import importlib
import inspect
from typing import Dict, List, Type, Any
from abc import ABC, abstractmethod

class PluginInterface(ABC):
    """æ’ä»¶æ¥å£"""

    @abstractmethod
    def get_name(self) -> str:
        """è·å–æ’ä»¶åç§°"""
        pass

    @abstractmethod
    def get_version(self) -> str:
        """è·å–æ’ä»¶ç‰ˆæœ¬"""
        pass

    @abstractmethod
    async def initialize(self, context: Dict[str, Any]) -> bool:
        """åˆå§‹åŒ–æ’ä»¶"""
        pass

    @abstractmethod
    async def execute(self, data: Any) -> Any:
        """æ‰§è¡Œæ’ä»¶åŠŸèƒ½"""
        pass

class PluginManager:
    """æ’ä»¶ç®¡ç†å™¨"""

    def __init__(self):
        self.plugins: Dict[str, PluginInterface] = {}
        self.plugin_configs: Dict[str, Dict[str, Any]] = {}

    def load_plugins_from_directory(self, directory: str):
        """ä»ç›®å½•åŠ è½½æ’ä»¶"""
        if not os.path.exists(directory):
            print(f"Plugin directory does not exist: {directory}")
            return

        for filename in os.listdir(directory):
            if filename.endswith('.py') and not filename.startswith('__'):
                plugin_name = filename[:-3]
                plugin_path = os.path.join(directory, filename)

                try:
# åŠ¨æ€åŠ è½½æ¨¡å—
                    spec = importlib.util.spec_from_file_location(plugin_name, plugin_path)
                    module = importlib.util.module_from_spec(spec)
                    spec.loader.exec_module(module)

# æŸ¥æ‰¾æ’ä»¶ç±»
                    for name, obj in inspect.getmembers(module):
                        if (inspect.isclass(obj) and
                            issubclass(obj, PluginInterface) and
                            obj != PluginInterface):
                            plugin_instance = obj()
                            self.plugins[plugin_instance.get_name()] = plugin_instance
                            print(f"Loaded plugin: {plugin_instance.get_name()}")

                except Exception as e:
                    print(f"Failed to load plugin {filename}: {e}")

    def register_plugin(self, plugin: PluginInterface):
        """æ³¨å†Œæ’ä»¶"""
        self.plugins[plugin.get_name()] = plugin

    async def initialize_plugins(self, context: Dict[str, Any]):
        """åˆå§‹åŒ–æ‰€æœ‰æ’ä»¶"""
        for name, plugin in self.plugins.items():
            try:
                success = await plugin.initialize(context)
                if success:
                    print(f"Plugin {name} initialized successfully")
                else:
                    print(f"Plugin {name} initialization failed")
            except Exception as e:
                print(f"Error initializing plugin {name}: {e}")

    async def execute_plugin(self, plugin_name: str, data: Any) -> Any:
        """æ‰§è¡ŒæŒ‡å®šæ’ä»¶"""
        if plugin_name not in self.plugins:
            raise ValueError(f"Plugin {plugin_name} not found")

        plugin = self.plugins[plugin_name]
        return await plugin.execute(data)

    def get_plugin_info(self) -> Dict[str, Dict[str, str]]:
        """è·å–æ’ä»¶ä¿¡æ¯"""
        info = {}
        for name, plugin in self.plugins.items():
            info[name] = {
                'name': plugin.get_name(),
                'version': plugin.get_version()
            }
        return info

# ç¤ºä¾‹æ’ä»¶
class DataFilterPlugin(PluginInterface):
    """æ•°æ®è¿‡æ»¤æ’ä»¶"""

    def get_name(self) -> str:
        return "data_filter"

    def get_version(self) -> str:
        return "1.0.0"

    async def initialize(self, context: Dict[str, Any]) -> bool:
        self.filter_config = context.get('filter_config', {})
        return True

    async def execute(self, data: Any) -> Any:
# ç®€å•çš„æ•°æ®è¿‡æ»¤é€»è¾‘
        if isinstance(data, list):
            return [item for item in data if item is not None]
        return data

class DataTransformPlugin(PluginInterface):
    """æ•°æ®è½¬æ¢æ’ä»¶"""

    def get_name(self) -> str:
        return "data_transform"

    def get_version(self) -> str:
        return "1.0.0"

    async def initialize(self, context: Dict[str, Any]) -> bool:
        self.transform_config = context.get('transform_config', {})
        return True

    async def execute(self, data: Any) -> Any:
# ç®€å•çš„æ•°æ®è½¬æ¢é€»è¾‘
        if isinstance(data, dict):
            return {k.upper(): v for k, v in data.items()}
        return data

# ä½¿ç”¨ç¤ºä¾‹
async def test_plugin_system():
    manager = PluginManager()

# æ³¨å†Œæ’ä»¶
    manager.register_plugin(DataFilterPlugin())
    manager.register_plugin(DataTransformPlugin())

# åˆå§‹åŒ–æ’ä»¶
    context = {
        'filter_config': {'remove_nulls': True},
        'transform_config': {'uppercase_keys': True}
    }
    await manager.initialize_plugins(context)

# è·å–æ’ä»¶ä¿¡æ¯
    plugin_info = manager.get_plugin_info()
    print("Plugin info:", plugin_info)

# æ‰§è¡Œæ’ä»¶
    test_data = [1, None, 3, None, 5]
    filtered_data = await manager.execute_plugin("data_filter", test_data)
    print("Filtered data:", filtered_data)

    test_dict = {"name": "test", "value": 123}
    transformed_data = await manager.execute_plugin("data_transform", test_dict)
    print("Transformed data:", transformed_data)

# è¿è¡Œæµ‹è¯•
asyncio.run(test_plugin_system())
```

## 7. ç»„ä»¶é€šä¿¡

### 7.1. äº‹ä»¶æ€»çº¿

```python
# äº‹ä»¶æ€»çº¿å®ç°
from typing import Dict, List, Callable, Any
import asyncio

class Event:
    """äº‹ä»¶ç±»"""

    def __init__(self, event_type: str, data: Any = None, source: str = None):
        self.event_type = event_type
        self.data = data
        self.source = source
        self.timestamp = time.time()

class EventBus:
    """äº‹ä»¶æ€»çº¿"""

    def __init__(self):
        self.subscribers: Dict[str, List[Callable]] = {}
        self.event_history: List[Event] = []

    def subscribe(self, event_type: str, handler: Callable):
        """è®¢é˜…äº‹ä»¶"""
        if event_type not in self.subscribers:
            self.subscribers[event_type] = []
        self.subscribers[event_type].append(handler)

    def unsubscribe(self, event_type: str, handler: Callable):
        """å–æ¶ˆè®¢é˜…"""
        if event_type in self.subscribers:
            self.subscribers[event_type].remove(handler)

    async def publish(self, event: Event):
        """å‘å¸ƒäº‹ä»¶"""
        self.event_history.append(event)

        if event.event_type in self.subscribers:
            handlers = self.subscribers[event.event_type]
# å¼‚æ­¥æ‰§è¡Œæ‰€æœ‰å¤„ç†å™¨
            await asyncio.gather(*[handler(event) for handler in handlers])

    def get_event_history(self, event_type: str = None) -> List[Event]:
        """è·å–äº‹ä»¶å†å²"""
        if event_type:
            return [event for event in self.event_history if event.event_type == event_type]
        return self.event_history

# ä½¿ç”¨ç¤ºä¾‹
async def data_processed_handler(event: Event):
    print(f"Data processed event: {event.data}")

async def error_handler(event: Event):
    print(f"Error event: {event.data}")

async def test_event_bus():
    event_bus = EventBus()

# è®¢é˜…äº‹ä»¶
    event_bus.subscribe("data_processed", data_processed_handler)
    event_bus.subscribe("error", error_handler)

# å‘å¸ƒäº‹ä»¶
    await event_bus.publish(Event("data_processed", {"result": "success"}))
    await event_bus.publish(Event("error", {"message": "Something went wrong"}))

# è·å–äº‹ä»¶å†å²
    history = event_bus.get_event_history()
    print(f"Event history: {len(history)} events")

# è¿è¡Œæµ‹è¯•
asyncio.run(test_event_bus())
```

## 8. æœ€ä½³å®è·µ

### 8.1. ç»„ä»¶è®¾è®¡åŸåˆ™

1. **å•ä¸€èŒè´£**ï¼šæ¯ä¸ªç»„ä»¶åªè´Ÿè´£ä¸€ä¸ªåŠŸèƒ½é¢†åŸŸ
2. **æ¥å£éš”ç¦»**ï¼šæä¾›æœ€å°åŒ–çš„æ¥å£
3. **ä¾èµ–å€’ç½®**ï¼šä¾èµ–æŠ½è±¡è€Œéå…·ä½“å®ç°
4. **å¼€é—­åŸåˆ™**ï¼šå¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å…³é—­

### 8.2. æ€§èƒ½ä¼˜åŒ–

1. **æ‡’åŠ è½½**ï¼šæŒ‰éœ€åˆå§‹åŒ–ç»„ä»¶
2. **ç¼“å­˜æœºåˆ¶**ï¼šç¼“å­˜ç»„ä»¶å®ä¾‹
3. **å¼‚æ­¥å¤„ç†**ï¼šä½¿ç”¨å¼‚æ­¥æ“ä½œæé«˜æ€§èƒ½
4. **èµ„æºç®¡ç†**ï¼šåˆç†ç®¡ç†ç»„ä»¶èµ„æº

### 8.3. é”™è¯¯å¤„ç†

1. **å¼‚å¸¸éš”ç¦»**ï¼šé˜²æ­¢ç»„ä»¶é”™è¯¯å½±å“æ•´ä½“
2. **é‡è¯•æœºåˆ¶**ï¼šå¯¹ä¸´æ—¶é”™è¯¯è¿›è¡Œé‡è¯•
3. **é™çº§ç­–ç•¥**ï¼šæä¾›å¤‡ç”¨æ–¹æ¡ˆ
4. **ç›‘æ§å‘Šè­¦**ï¼šå®æ—¶ç›‘æ§ç»„ä»¶çŠ¶æ€

### 8.4. å®‰å…¨è€ƒè™‘

1. **æƒé™æ§åˆ¶**ï¼šé™åˆ¶ç»„ä»¶è®¿é—®æƒé™
2. **è¾“å…¥éªŒè¯**ï¼šéªŒè¯ç»„ä»¶è¾“å…¥æ•°æ®
3. **å®¡è®¡æ—¥å¿—**ï¼šè®°å½•ç»„ä»¶æ“ä½œæ—¥å¿—
4. **å®‰å…¨æ›´æ–°**ï¼šå®šæœŸæ›´æ–°ç»„ä»¶å®‰å…¨è¡¥ä¸

## 9. æ€»ç»“

ç»„ä»¶åŸºç¡€ç†è®ºä¸ºæ„å»ºæ¨¡å—åŒ–ã€å¯ç»´æŠ¤çš„è½¯ä»¶ç³»ç»Ÿæä¾›äº†é‡è¦æŒ‡å¯¼ã€‚é€šè¿‡åˆç†çš„æ¥å£è®¾è®¡ã€ä¾èµ–æ³¨å…¥ã€ç”Ÿå‘½å‘¨æœŸç®¡ç†å’Œæ’ä»¶æœºåˆ¶ï¼Œå¯ä»¥æ„å»ºå‡ºé«˜è´¨é‡ã€å¯æ‰©å±•çš„ç»„ä»¶åŒ–ç³»ç»Ÿã€‚
