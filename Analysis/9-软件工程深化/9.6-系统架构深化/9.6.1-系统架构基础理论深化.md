# 9.6.1 ç³»ç»Ÿæ¶æ„åŸºç¡€ç†è®ºæ·±åŒ–

## ğŸ“‘ ç›®å½•

- [9.6.1 ç³»ç»Ÿæ¶æ„åŸºç¡€ç†è®ºæ·±åŒ–](#961-ç³»ç»Ÿæ¶æ„åŸºç¡€ç†è®ºæ·±åŒ–)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. ç†è®ºåŸºç¡€](#1-ç†è®ºåŸºç¡€)
    - [1.1. ç³»ç»Ÿæ¶æ„æ¦‚è¿°](#11-ç³»ç»Ÿæ¶æ„æ¦‚è¿°)
    - [1.2. æ ¸å¿ƒåŸåˆ™](#12-æ ¸å¿ƒåŸåˆ™)
  - [2. æ¶æ„æ¨¡å¼](#2-æ¶æ„æ¨¡å¼)
    - [2.1. åˆ†å±‚æ¶æ„](#21-åˆ†å±‚æ¶æ„)
  - [3. å¾®æœåŠ¡æ¶æ„](#3-å¾®æœåŠ¡æ¶æ„)
  - [4. äº‹ä»¶é©±åŠ¨æ¶æ„](#4-äº‹ä»¶é©±åŠ¨æ¶æ„)
  - [5. æ¨¡å—åŒ–è®¾è®¡](#5-æ¨¡å—åŒ–è®¾è®¡)
    - [5.1. æ¨¡å—æ¥å£è®¾è®¡](#51-æ¨¡å—æ¥å£è®¾è®¡)
  - [6. å¯æ‰©å±•æ€§è®¾è®¡](#6-å¯æ‰©å±•æ€§è®¾è®¡)
    - [6.1. æ’ä»¶ç³»ç»Ÿ](#61-æ’ä»¶ç³»ç»Ÿ)
  - [7. å¯ç»´æŠ¤æ€§è®¾è®¡](#7-å¯ç»´æŠ¤æ€§è®¾è®¡)
    - [7.1. é…ç½®ç®¡ç†](#71-é…ç½®ç®¡ç†)
  - [8. æ—¥å¿—ç®¡ç†](#8-æ—¥å¿—ç®¡ç†)
  - [9. æœ€ä½³å®è·µ](#9-æœ€ä½³å®è·µ)
    - [9.1. æ¶æ„è®¾è®¡åŸåˆ™](#91-æ¶æ„è®¾è®¡åŸåˆ™)
    - [9.2. æ€§èƒ½ä¼˜åŒ–](#92-æ€§èƒ½ä¼˜åŒ–)
    - [9.3. å®‰å…¨è€ƒè™‘](#93-å®‰å…¨è€ƒè™‘)
    - [9.4. ç›‘æ§å‘Šè­¦](#94-ç›‘æ§å‘Šè­¦)
  - [10. æ€»ç»“](#10-æ€»ç»“)

---


## 1. ç†è®ºåŸºç¡€

### 1.1. ç³»ç»Ÿæ¶æ„æ¦‚è¿°

ç³»ç»Ÿæ¶æ„æ˜¯è½¯ä»¶ç³»ç»Ÿçš„æ•´ä½“ç»“æ„å’Œç»„ç»‡æ–¹å¼ï¼Œå®šä¹‰äº†ç³»ç»Ÿçš„å„ä¸ªç»„æˆéƒ¨åˆ†åŠå…¶ç›¸äº’å…³ç³»ï¼š

- **ç»“æ„è®¾è®¡**ï¼šå®šä¹‰ç³»ç»Ÿçš„ç»„ç»‡ç»“æ„å’Œç»„ä»¶å…³ç³»
- **è¡Œä¸ºè§„èŒƒ**ï¼šè§„å®šç³»ç»Ÿçš„è¿è¡Œè¡Œä¸ºå’Œäº¤äº’æ–¹å¼
- **è´¨é‡å±æ€§**ï¼šç¡®ä¿ç³»ç»Ÿæ»¡è¶³æ€§èƒ½ã€å¯é æ€§ç­‰è¦æ±‚
- **æŠ€æœ¯é€‰å‹**ï¼šé€‰æ‹©åˆé€‚çš„æŠ€æœ¯æ ˆå’Œå®ç°æ–¹æ¡ˆ

### 1.2. æ ¸å¿ƒåŸåˆ™

- **å…³æ³¨ç‚¹åˆ†ç¦»**ï¼šå°†ä¸åŒåŠŸèƒ½åˆ†ç¦»åˆ°ä¸åŒæ¨¡å—
- **é«˜å†…èšä½è€¦åˆ**ï¼šæ¨¡å—å†…éƒ¨ç´§å¯†ç›¸å…³ï¼Œæ¨¡å—é—´æ¾æ•£ä¾èµ–
- **å¯æ‰©å±•æ€§**ï¼šæ”¯æŒç³»ç»ŸåŠŸèƒ½çš„æ‰©å±•å’Œå‡çº§
- **å¯ç»´æŠ¤æ€§**ï¼šä¾¿äºç³»ç»Ÿçš„ç»´æŠ¤å’Œä¿®æ”¹

## 2. æ¶æ„æ¨¡å¼

### 2.1. åˆ†å±‚æ¶æ„

```python
# åˆ†å±‚æ¶æ„ç¤ºä¾‹
from abc import ABC, abstractmethod
from typing import Dict, Any, List

class PresentationLayer(ABC):
    """è¡¨ç¤ºå±‚"""

    @abstractmethod
    def display_data(self, data: Any):
        """æ˜¾ç¤ºæ•°æ®"""
        pass

    @abstractmethod
    def get_user_input(self) -> Dict[str, Any]:
        """è·å–ç”¨æˆ·è¾“å…¥"""
        pass

class BusinessLogicLayer(ABC):
    """ä¸šåŠ¡é€»è¾‘å±‚"""

    @abstractmethod
    def process_business_logic(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """å¤„ç†ä¸šåŠ¡é€»è¾‘"""
        pass

    @abstractmethod
    def validate_data(self, data: Dict[str, Any]) -> bool:
        """éªŒè¯æ•°æ®"""
        pass

class DataAccessLayer(ABC):
    """æ•°æ®è®¿é—®å±‚"""

    @abstractmethod
    async def save_data(self, data: Dict[str, Any]) -> bool:
        """ä¿å­˜æ•°æ®"""
        pass

    @abstractmethod
    async def load_data(self, criteria: Dict[str, Any]) -> List[Dict[str, Any]]:
        """åŠ è½½æ•°æ®"""
        pass

class LayeredArchitecture:
    """åˆ†å±‚æ¶æ„å®ç°"""

    def __init__(self, presentation: PresentationLayer,
                 business_logic: BusinessLogicLayer,
                 data_access: DataAccessLayer):
        self.presentation = presentation
        self.business_logic = business_logic
        self.data_access = data_access

    async def handle_user_request(self):
        """å¤„ç†ç”¨æˆ·è¯·æ±‚"""
# 1. è¡¨ç¤ºå±‚ï¼šè·å–ç”¨æˆ·è¾“å…¥
        user_input = self.presentation.get_user_input()

# 2. ä¸šåŠ¡é€»è¾‘å±‚ï¼šéªŒè¯å’Œå¤„ç†æ•°æ®
        if not self.business_logic.validate_data(user_input):
            self.presentation.display_data({"error": "Invalid data"})
            return

        processed_data = self.business_logic.process_business_logic(user_input)

# 3. æ•°æ®è®¿é—®å±‚ï¼šä¿å­˜æ•°æ®
        success = await self.data_access.save_data(processed_data)

# 4. è¡¨ç¤ºå±‚ï¼šæ˜¾ç¤ºç»“æœ
        if success:
            self.presentation.display_data({"message": "Data saved successfully"})
        else:
            self.presentation.display_data({"error": "Failed to save data"})

# å…·ä½“å®ç°
class WebPresentationLayer(PresentationLayer):
    """Webè¡¨ç¤ºå±‚"""

    def display_data(self, data: Any):
        print(f"Web UI: {data}")

    def get_user_input(self) -> Dict[str, Any]:
# æ¨¡æ‹Ÿä»Webè¡¨å•è·å–æ•°æ®
        return {"name": "John", "email": "john@example.com"}

class UserBusinessLogic(BusinessLogicLayer):
    """ç”¨æˆ·ä¸šåŠ¡é€»è¾‘"""

    def process_business_logic(self, data: Dict[str, Any]) -> Dict[str, Any]:
# å¤„ç†ç”¨æˆ·æ•°æ®
        processed_data = {
            "user_id": f"user_{hash(data['email'])}",
            "name": data['name'],
            "email": data['email'],
            "created_at": time.time()
        }
        return processed_data

    def validate_data(self, data: Dict[str, Any]) -> bool:
# éªŒè¯ç”¨æˆ·æ•°æ®
        return ('name' in data and 'email' in data and
                '@' in data['email'])

class DatabaseDataAccess(DataAccessLayer):
    """æ•°æ®åº“æ•°æ®è®¿é—®"""

    def __init__(self):
        self.data_store = {}  # æ¨¡æ‹Ÿæ•°æ®åº“

    async def save_data(self, data: Dict[str, Any]) -> bool:
        try:
            self.data_store[data['user_id']] = data
            return True
        except Exception as e:
            print(f"Database error: {e}")
            return False

    async def load_data(self, criteria: Dict[str, Any]) -> List[Dict[str, Any]]:
# æ¨¡æ‹Ÿæ•°æ®åº“æŸ¥è¯¢
        results = []
        for user_id, user_data in self.data_store.items():
            if all(user_data.get(k) == v for k, v in criteria.items()):
                results.append(user_data)
        return results
```

## 3. å¾®æœåŠ¡æ¶æ„

```python
# å¾®æœåŠ¡æ¶æ„ç¤ºä¾‹
import asyncio
from typing import Dict, Any, List
import json

class Microservice:
    """å¾®æœåŠ¡åŸºç±»"""

    def __init__(self, service_name: str):
        self.service_name = service_name
        self.dependencies: List[str] = []
        self.api_endpoints: Dict[str, callable] = {}

    async def initialize(self):
        """åˆå§‹åŒ–æœåŠ¡"""
        print(f"Initializing {self.service_name}")

    async def start(self):
        """å¯åŠ¨æœåŠ¡"""
        print(f"Starting {self.service_name}")

    async def stop(self):
        """åœæ­¢æœåŠ¡"""
        print(f"Stopping {self.service_name}")

    def register_endpoint(self, path: str, handler: callable):
        """æ³¨å†ŒAPIç«¯ç‚¹"""
        self.api_endpoints[path] = handler

    async def handle_request(self, path: str, data: Dict[str, Any]) -> Dict[str, Any]:
        """å¤„ç†è¯·æ±‚"""
        if path in self.api_endpoints:
            return await self.api_endpoints[path](data)
        else:
            return {"error": "Endpoint not found"}

class UserService(Microservice):
    """ç”¨æˆ·æœåŠ¡"""

    def __init__(self):
        super().__init__("user-service")
        self.users = {}
        self.setup_endpoints()

    def setup_endpoints(self):
        """è®¾ç½®APIç«¯ç‚¹"""
        self.register_endpoint("/users/create", self.create_user)
        self.register_endpoint("/users/get", self.get_user)
        self.register_endpoint("/users/update", self.update_user)

    async def create_user(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """åˆ›å»ºç”¨æˆ·"""
        user_id = f"user_{len(self.users) + 1}"
        user_data = {
            "id": user_id,
            "name": data.get("name"),
            "email": data.get("email"),
            "created_at": time.time()
        }
        self.users[user_id] = user_data
        return {"success": True, "user_id": user_id}

    async def get_user(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """è·å–ç”¨æˆ·"""
        user_id = data.get("user_id")
        if user_id in self.users:
            return {"success": True, "user": self.users[user_id]}
        else:
            return {"success": False, "error": "User not found"}

    async def update_user(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """æ›´æ–°ç”¨æˆ·"""
        user_id = data.get("user_id")
        if user_id in self.users:
            self.users[user_id].update(data.get("updates", {}))
            return {"success": True}
        else:
            return {"success": False, "error": "User not found"}

class OrderService(Microservice):
    """è®¢å•æœåŠ¡"""

    def __init__(self):
        super().__init__("order-service")
        self.orders = {}
        self.setup_endpoints()

    def setup_endpoints(self):
        """è®¾ç½®APIç«¯ç‚¹"""
        self.register_endpoint("/orders/create", self.create_order)
        self.register_endpoint("/orders/get", self.get_order)

    async def create_order(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """åˆ›å»ºè®¢å•"""
        order_id = f"order_{len(self.orders) + 1}"
        order_data = {
            "id": order_id,
            "user_id": data.get("user_id"),
            "items": data.get("items", []),
            "total": data.get("total", 0),
            "created_at": time.time()
        }
        self.orders[order_id] = order_data
        return {"success": True, "order_id": order_id}

    async def get_order(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """è·å–è®¢å•"""
        order_id = data.get("order_id")
        if order_id in self.orders:
            return {"success": True, "order": self.orders[order_id]}
        else:
            return {"success": False, "error": "Order not found"}

class ServiceMesh:
    """æœåŠ¡ç½‘æ ¼"""

    def __init__(self):
        self.services: Dict[str, Microservice] = {}
        self.service_discovery = {}

    def register_service(self, service: Microservice):
        """æ³¨å†ŒæœåŠ¡"""
        self.services[service.service_name] = service
        self.service_discovery[service.service_name] = {
            "host": "localhost",
            "port": 8000 + len(self.services)
        }

    async def call_service(self, service_name: str, endpoint: str,
                          data: Dict[str, Any]) -> Dict[str, Any]:
        """è°ƒç”¨æœåŠ¡"""
        if service_name not in self.services:
            return {"error": "Service not found"}

        service = self.services[service_name]
        return await service.handle_request(endpoint, data)

    async def start_all_services(self):
        """å¯åŠ¨æ‰€æœ‰æœåŠ¡"""
        for service in self.services.values():
            await service.initialize()
            await service.start()

    async def stop_all_services(self):
        """åœæ­¢æ‰€æœ‰æœåŠ¡"""
        for service in self.services.values():
            await service.stop()

# ä½¿ç”¨ç¤ºä¾‹
async def test_microservices():
# åˆ›å»ºæœåŠ¡ç½‘æ ¼
    mesh = ServiceMesh()

# æ³¨å†ŒæœåŠ¡
    user_service = UserService()
    order_service = OrderService()

    mesh.register_service(user_service)
    mesh.register_service(order_service)

# å¯åŠ¨æœåŠ¡
    await mesh.start_all_services()

# æµ‹è¯•æœåŠ¡è°ƒç”¨
# åˆ›å»ºç”¨æˆ·
    user_result = await mesh.call_service("user-service", "/users/create", {
        "name": "John Doe",
        "email": "john@example.com"
    })
    print("Create user result:", user_result)

# åˆ›å»ºè®¢å•
    order_result = await mesh.call_service("order-service", "/orders/create", {
        "user_id": user_result["user_id"],
        "items": ["item1", "item2"],
        "total": 100.0
    })
    print("Create order result:", order_result)

# åœæ­¢æœåŠ¡
    await mesh.stop_all_services()

# è¿è¡Œæµ‹è¯•
asyncio.run(test_microservices())
```

## 4. äº‹ä»¶é©±åŠ¨æ¶æ„

```python
# äº‹ä»¶é©±åŠ¨æ¶æ„ç¤ºä¾‹
from typing import Dict, List, Callable, Any
import asyncio

class Event:
    """äº‹ä»¶ç±»"""

    def __init__(self, event_type: str, data: Any = None, source: str = None):
        self.event_type = event_type
        self.data = data
        self.source = source
        self.timestamp = time.time()

class EventBus:
    """äº‹ä»¶æ€»çº¿"""

    def __init__(self):
        self.subscribers: Dict[str, List[Callable]] = {}
        self.event_history: List[Event] = []

    def subscribe(self, event_type: str, handler: Callable):
        """è®¢é˜…äº‹ä»¶"""
        if event_type not in self.subscribers:
            self.subscribers[event_type] = []
        self.subscribers[event_type].append(handler)

    async def publish(self, event: Event):
        """å‘å¸ƒäº‹ä»¶"""
        self.event_history.append(event)

        if event.event_type in self.subscribers:
            handlers = self.subscribers[event.event_type]
            await asyncio.gather(*[handler(event) for handler in handlers])

class EventDrivenComponent:
    """äº‹ä»¶é©±åŠ¨ç»„ä»¶"""

    def __init__(self, name: str, event_bus: EventBus):
        self.name = name
        self.event_bus = event_bus
        self.setup_event_handlers()

    def setup_event_handlers(self):
        """è®¾ç½®äº‹ä»¶å¤„ç†å™¨"""
        pass

    async def publish_event(self, event_type: str, data: Any = None):
        """å‘å¸ƒäº‹ä»¶"""
        event = Event(event_type, data, self.name)
        await self.event_bus.publish(event)

class OrderProcessor(EventDrivenComponent):
    """è®¢å•å¤„ç†å™¨"""

    def setup_event_handlers(self):
        """è®¾ç½®äº‹ä»¶å¤„ç†å™¨"""
        self.event_bus.subscribe("order_created", self.handle_order_created)
        self.event_bus.subscribe("payment_processed", self.handle_payment_processed)

    async def handle_order_created(self, event: Event):
        """å¤„ç†è®¢å•åˆ›å»ºäº‹ä»¶"""
        print(f"{self.name}: Processing order {event.data['order_id']}")

# å¤„ç†è®¢å•é€»è¾‘
        processed_order = {
            "order_id": event.data["order_id"],
            "status": "processing",
            "processed_at": time.time()
        }

# å‘å¸ƒè®¢å•å¤„ç†å®Œæˆäº‹ä»¶
        await self.publish_event("order_processed", processed_order)

    async def handle_payment_processed(self, event: Event):
        """å¤„ç†æ”¯ä»˜å®Œæˆäº‹ä»¶"""
        print(f"{self.name}: Order {event.data['order_id']} payment completed")

# æ›´æ–°è®¢å•çŠ¶æ€
        completed_order = {
            "order_id": event.data["order_id"],
            "status": "completed",
            "completed_at": time.time()
        }

# å‘å¸ƒè®¢å•å®Œæˆäº‹ä»¶
        await self.publish_event("order_completed", completed_order)

class PaymentProcessor(EventDrivenComponent):
    """æ”¯ä»˜å¤„ç†å™¨"""

    def setup_event_handlers(self):
        """è®¾ç½®äº‹ä»¶å¤„ç†å™¨"""
        self.event_bus.subscribe("order_processed", self.handle_order_processed)

    async def handle_order_processed(self, event: Event):
        """å¤„ç†è®¢å•å¤„ç†å®Œæˆäº‹ä»¶"""
        print(f"{self.name}: Processing payment for order {event.data['order_id']}")

# æ¨¡æ‹Ÿæ”¯ä»˜å¤„ç†
        await asyncio.sleep(1)

        payment_result = {
            "order_id": event.data["order_id"],
            "payment_id": f"pay_{event.data['order_id']}",
            "status": "success",
            "processed_at": time.time()
        }

# å‘å¸ƒæ”¯ä»˜å®Œæˆäº‹ä»¶
        await self.publish_event("payment_processed", payment_result)

class NotificationService(EventDrivenComponent):
    """é€šçŸ¥æœåŠ¡"""

    def setup_event_handlers(self):
        """è®¾ç½®äº‹ä»¶å¤„ç†å™¨"""
        self.event_bus.subscribe("order_completed", self.handle_order_completed)

    async def handle_order_completed(self, event: Event):
        """å¤„ç†è®¢å•å®Œæˆäº‹ä»¶"""
        print(f"{self.name}: Sending notification for order {event.data['order_id']}")

# å‘é€é€šçŸ¥
        notification = {
            "order_id": event.data["order_id"],
            "message": "Your order has been completed successfully!",
            "sent_at": time.time()
        }

        print(f"Notification sent: {notification}")

# ä½¿ç”¨ç¤ºä¾‹
async def test_event_driven_architecture():
# åˆ›å»ºäº‹ä»¶æ€»çº¿
    event_bus = EventBus()

# åˆ›å»ºç»„ä»¶
    order_processor = OrderProcessor("order-processor", event_bus)
    payment_processor = PaymentProcessor("payment-processor", event_bus)
    notification_service = NotificationService("notification-service", event_bus)

# å‘å¸ƒåˆå§‹äº‹ä»¶
    await order_processor.publish_event("order_created", {
        "order_id": "order_123",
        "user_id": "user_456",
        "amount": 100.0
    })

# ç­‰å¾…äº‹ä»¶å¤„ç†å®Œæˆ
    await asyncio.sleep(3)

# è¿è¡Œæµ‹è¯•
asyncio.run(test_event_driven_architecture())
```

## 5. æ¨¡å—åŒ–è®¾è®¡

### 5.1. æ¨¡å—æ¥å£è®¾è®¡

```python
# æ¨¡å—æ¥å£è®¾è®¡
from abc import ABC, abstractmethod
from typing import Dict, Any, List, Optional

class ModuleInterface(ABC):
    """æ¨¡å—æ¥å£"""

    @abstractmethod
    async def initialize(self, config: Dict[str, Any]) -> bool:
        """åˆå§‹åŒ–æ¨¡å—"""
        pass

    @abstractmethod
    async def start(self) -> bool:
        """å¯åŠ¨æ¨¡å—"""
        pass

    @abstractmethod
    async def stop(self) -> bool:
        """åœæ­¢æ¨¡å—"""
        pass

    @abstractmethod
    async def get_status(self) -> Dict[str, Any]:
        """è·å–æ¨¡å—çŠ¶æ€"""
        pass

class ModuleRegistry:
    """æ¨¡å—æ³¨å†Œè¡¨"""

    def __init__(self):
        self.modules: Dict[str, ModuleInterface] = {}
        self.module_configs: Dict[str, Dict[str, Any]] = {}

    def register_module(self, name: str, module: ModuleInterface,
                       config: Dict[str, Any] = None):
        """æ³¨å†Œæ¨¡å—"""
        self.modules[name] = module
        self.module_configs[name] = config or {}

    async def initialize_all_modules(self) -> bool:
        """åˆå§‹åŒ–æ‰€æœ‰æ¨¡å—"""
        for name, module in self.modules.items():
            config = self.module_configs[name]
            success = await module.initialize(config)
            if not success:
                print(f"Failed to initialize module: {name}")
                return False
        return True

    async def start_all_modules(self) -> bool:
        """å¯åŠ¨æ‰€æœ‰æ¨¡å—"""
        for name, module in self.modules.items():
            success = await module.start()
            if not success:
                print(f"Failed to start module: {name}")
                return False
        return True

    async def stop_all_modules(self):
        """åœæ­¢æ‰€æœ‰æ¨¡å—"""
        for name, module in self.modules.items():
            await module.stop()

    def get_module(self, name: str) -> Optional[ModuleInterface]:
        """è·å–æ¨¡å—"""
        return self.modules.get(name)

    async def get_all_status(self) -> Dict[str, Dict[str, Any]]:
        """è·å–æ‰€æœ‰æ¨¡å—çŠ¶æ€"""
        status = {}
        for name, module in self.modules.items():
            status[name] = await module.get_status()
        return status

# å…·ä½“æ¨¡å—å®ç°
class DatabaseModule(ModuleInterface):
    """æ•°æ®åº“æ¨¡å—"""

    def __init__(self):
        self.connection = None
        self.is_initialized = False
        self.is_running = False

    async def initialize(self, config: Dict[str, Any]) -> bool:
        try:
            self.connection = {
                'host': config.get('host', 'localhost'),
                'port': config.get('port', 5432),
                'database': config.get('database', 'default')
            }
            self.is_initialized = True
            return True
        except Exception as e:
            print(f"Database initialization failed: {e}")
            return False

    async def start(self) -> bool:
        if not self.is_initialized:
            return False
        self.is_running = True
        return True

    async def stop(self) -> bool:
        self.is_running = False
        return True

    async def get_status(self) -> Dict[str, Any]:
        return {
            'initialized': self.is_initialized,
            'running': self.is_running,
            'connection': self.connection
        }

class CacheModule(ModuleInterface):
    """ç¼“å­˜æ¨¡å—"""

    def __init__(self):
        self.cache = {}
        self.is_initialized = False
        self.is_running = False

    async def initialize(self, config: Dict[str, Any]) -> bool:
        self.max_size = config.get('max_size', 1000)
        self.is_initialized = True
        return True

    async def start(self) -> bool:
        if not self.is_initialized:
            return False
        self.is_running = True
        return True

    async def stop(self) -> bool:
        self.is_running = False
        return True

    async def get_status(self) -> Dict[str, Any]:
        return {
            'initialized': self.is_initialized,
            'running': self.is_running,
            'cache_size': len(self.cache),
            'max_size': self.max_size
        }

    def set(self, key: str, value: Any):
        """è®¾ç½®ç¼“å­˜"""
        if self.is_running and len(self.cache) < self.max_size:
            self.cache[key] = value

    def get(self, key: str) -> Optional[Any]:
        """è·å–ç¼“å­˜"""
        return self.cache.get(key) if self.is_running else None

# ä½¿ç”¨ç¤ºä¾‹
async def test_modular_design():
    registry = ModuleRegistry()

# æ³¨å†Œæ¨¡å—
    db_module = DatabaseModule()
    cache_module = CacheModule()

    registry.register_module("database", db_module, {
        'host': 'localhost',
        'port': 5432,
        'database': 'test'
    })

    registry.register_module("cache", cache_module, {
        'max_size': 500
    })

# åˆå§‹åŒ–æ¨¡å—
    success = await registry.initialize_all_modules()
    if not success:
        print("Module initialization failed")
        return

# å¯åŠ¨æ¨¡å—
    success = await registry.start_all_modules()
    if not success:
        print("Module startup failed")
        return

# è·å–çŠ¶æ€
    status = await registry.get_all_status()
    print("Module status:", status)

# ä½¿ç”¨æ¨¡å—
    cache = registry.get_module("cache")
    if cache:
        cache.set("test_key", "test_value")
        value = cache.get("test_key")
        print(f"Cache test: {value}")

# åœæ­¢æ¨¡å—
    await registry.stop_all_modules()

# è¿è¡Œæµ‹è¯•
asyncio.run(test_modular_design())
```

## 6. å¯æ‰©å±•æ€§è®¾è®¡

### 6.1. æ’ä»¶ç³»ç»Ÿ

```python
# æ’ä»¶ç³»ç»Ÿè®¾è®¡
import os
import importlib
import inspect
from typing import Dict, List, Type, Any
from abc import ABC, abstractmethod

class PluginInterface(ABC):
    """æ’ä»¶æ¥å£"""

    @abstractmethod
    def get_name(self) -> str:
        """è·å–æ’ä»¶åç§°"""
        pass

    @abstractmethod
    def get_version(self) -> str:
        """è·å–æ’ä»¶ç‰ˆæœ¬"""
        pass

    @abstractmethod
    async def initialize(self, context: Dict[str, Any]) -> bool:
        """åˆå§‹åŒ–æ’ä»¶"""
        pass

    @abstractmethod
    async def execute(self, data: Any) -> Any:
        """æ‰§è¡Œæ’ä»¶åŠŸèƒ½"""
        pass

class PluginManager:
    """æ’ä»¶ç®¡ç†å™¨"""

    def __init__(self):
        self.plugins: Dict[str, PluginInterface] = {}
        self.plugin_configs: Dict[str, Dict[str, Any]] = {}

    def load_plugins_from_directory(self, directory: str):
        """ä»ç›®å½•åŠ è½½æ’ä»¶"""
        if not os.path.exists(directory):
            print(f"Plugin directory does not exist: {directory}")
            return

        for filename in os.listdir(directory):
            if filename.endswith('.py') and not filename.startswith('__'):
                plugin_name = filename[:-3]
                plugin_path = os.path.join(directory, filename)

                try:
# åŠ¨æ€åŠ è½½æ¨¡å—
                    spec = importlib.util.spec_from_file_location(plugin_name, plugin_path)
                    module = importlib.util.module_from_spec(spec)
                    spec.loader.exec_module(module)

# æŸ¥æ‰¾æ’ä»¶ç±»
                    for name, obj in inspect.getmembers(module):
                        if (inspect.isclass(obj) and
                            issubclass(obj, PluginInterface) and
                            obj != PluginInterface):
                            plugin_instance = obj()
                            self.plugins[plugin_instance.get_name()] = plugin_instance
                            print(f"Loaded plugin: {plugin_instance.get_name()}")

                except Exception as e:
                    print(f"Failed to load plugin {filename}: {e}")

    def register_plugin(self, plugin: PluginInterface):
        """æ³¨å†Œæ’ä»¶"""
        self.plugins[plugin.get_name()] = plugin

    async def initialize_plugins(self, context: Dict[str, Any]):
        """åˆå§‹åŒ–æ‰€æœ‰æ’ä»¶"""
        for name, plugin in self.plugins.items():
            try:
                success = await plugin.initialize(context)
                if success:
                    print(f"Plugin {name} initialized successfully")
                else:
                    print(f"Plugin {name} initialization failed")
            except Exception as e:
                print(f"Error initializing plugin {name}: {e}")

    async def execute_plugin(self, plugin_name: str, data: Any) -> Any:
        """æ‰§è¡ŒæŒ‡å®šæ’ä»¶"""
        if plugin_name not in self.plugins:
            raise ValueError(f"Plugin {plugin_name} not found")

        plugin = self.plugins[plugin_name]
        return await plugin.execute(data)

    def get_plugin_info(self) -> Dict[str, Dict[str, str]]:
        """è·å–æ’ä»¶ä¿¡æ¯"""
        info = {}
        for name, plugin in self.plugins.items():
            info[name] = {
                'name': plugin.get_name(),
                'version': plugin.get_version()
            }
        return info

# ç¤ºä¾‹æ’ä»¶
class DataFilterPlugin(PluginInterface):
    """æ•°æ®è¿‡æ»¤æ’ä»¶"""

    def get_name(self) -> str:
        return "data_filter"

    def get_version(self) -> str:
        return "1.0.0"

    async def initialize(self, context: Dict[str, Any]) -> bool:
        self.filter_config = context.get('filter_config', {})
        return True

    async def execute(self, data: Any) -> Any:
# ç®€å•çš„æ•°æ®è¿‡æ»¤é€»è¾‘
        if isinstance(data, list):
            return [item for item in data if item is not None]
        return data

class DataTransformPlugin(PluginInterface):
    """æ•°æ®è½¬æ¢æ’ä»¶"""

    def get_name(self) -> str:
        return "data_transform"

    def get_version(self) -> str:
        return "1.0.0"

    async def initialize(self, context: Dict[str, Any]) -> bool:
        self.transform_config = context.get('transform_config', {})
        return True

    async def execute(self, data: Any) -> Any:
# ç®€å•çš„æ•°æ®è½¬æ¢é€»è¾‘
        if isinstance(data, dict):
            return {k.upper(): v for k, v in data.items()}
        return data

# ä½¿ç”¨ç¤ºä¾‹
async def test_plugin_system():
    manager = PluginManager()

# æ³¨å†Œæ’ä»¶
    manager.register_plugin(DataFilterPlugin())
    manager.register_plugin(DataTransformPlugin())

# åˆå§‹åŒ–æ’ä»¶
    context = {
        'filter_config': {'remove_nulls': True},
        'transform_config': {'uppercase_keys': True}
    }
    await manager.initialize_plugins(context)

# è·å–æ’ä»¶ä¿¡æ¯
    plugin_info = manager.get_plugin_info()
    print("Plugin info:", plugin_info)

# æ‰§è¡Œæ’ä»¶
    test_data = [1, None, 3, None, 5]
    filtered_data = await manager.execute_plugin("data_filter", test_data)
    print("Filtered data:", filtered_data)

    test_dict = {"name": "test", "value": 123}
    transformed_data = await manager.execute_plugin("data_transform", test_dict)
    print("Transformed data:", transformed_data)

# è¿è¡Œæµ‹è¯•
asyncio.run(test_plugin_system())
```

## 7. å¯ç»´æŠ¤æ€§è®¾è®¡

### 7.1. é…ç½®ç®¡ç†

```python
# é…ç½®ç®¡ç†ç³»ç»Ÿ
import json
import os
from typing import Dict, Any, Optional

class ConfigurationManager:
    """é…ç½®ç®¡ç†å™¨"""

    def __init__(self):
        self.configs: Dict[str, Any] = {}
        self.config_sources: Dict[str, str] = {}

    def load_from_file(self, file_path: str, config_name: str = "default"):
        """ä»æ–‡ä»¶åŠ è½½é…ç½®"""
        try:
            with open(file_path, 'r') as f:
                config = json.load(f)
            self.configs[config_name] = config
            self.config_sources[config_name] = file_path
            print(f"Loaded config from {file_path}")
        except Exception as e:
            print(f"Failed to load config from {file_path}: {e}")

    def load_from_environment(self, config_name: str = "env"):
        """ä»ç¯å¢ƒå˜é‡åŠ è½½é…ç½®"""
        env_config = {}
        for key, value in os.environ.items():
            if key.startswith('APP_'):
                config_key = key[4:].lower()
                env_config[config_key] = value

        self.configs[config_name] = env_config
        self.config_sources[config_name] = "environment"
        print("Loaded config from environment")

    def get_config(self, config_name: str = "default") -> Dict[str, Any]:
        """è·å–é…ç½®"""
        return self.configs.get(config_name, {})

    def get_value(self, key: str, default: Any = None, config_name: str = "default") -> Any:
        """è·å–é…ç½®å€¼"""
        config = self.get_config(config_name)
        return config.get(key, default)

    def set_value(self, key: str, value: Any, config_name: str = "default"):
        """è®¾ç½®é…ç½®å€¼"""
        if config_name not in self.configs:
            self.configs[config_name] = {}
        self.configs[config_name][key] = value

    def save_to_file(self, file_path: str, config_name: str = "default"):
        """ä¿å­˜é…ç½®åˆ°æ–‡ä»¶"""
        try:
            config = self.get_config(config_name)
            with open(file_path, 'w') as f:
                json.dump(config, f, indent=2)
            print(f"Saved config to {file_path}")
        except Exception as e:
            print(f"Failed to save config to {file_path}: {e}")

# ä½¿ç”¨ç¤ºä¾‹
def test_configuration_manager():
    manager = ConfigurationManager()

# ä»æ–‡ä»¶åŠ è½½é…ç½®
    config_data = {
        "database": {
            "host": "localhost",
            "port": 5432,
            "database": "test"
        },
        "cache": {
            "max_size": 1000,
            "ttl": 3600
        },
        "logging": {
            "level": "INFO",
            "file": "app.log"
        }
    }

# ä¿å­˜ç¤ºä¾‹é…ç½®
    with open('config.json', 'w') as f:
        json.dump(config_data, f, indent=2)

# åŠ è½½é…ç½®
    manager.load_from_file('config.json')

# ä»ç¯å¢ƒå˜é‡åŠ è½½é…ç½®
    os.environ['APP_DATABASE_HOST'] = 'prod-db.example.com'
    os.environ['APP_DATABASE_PORT'] = '5432'
    manager.load_from_environment()

# è·å–é…ç½®
    db_config = manager.get_value('database')
    cache_max_size = manager.get_value('cache.max_size', 500)
    env_db_host = manager.get_value('database_host', config_name='env')

    print("Database config:", db_config)
    print("Cache max size:", cache_max_size)
    print("Environment DB host:", env_db_host)

# è®¾ç½®æ–°é…ç½®
    manager.set_value('new_feature', True)
    manager.set_value('api.timeout', 30)

# ä¿å­˜é…ç½®
    manager.save_to_file('updated_config.json')

# è¿è¡Œæµ‹è¯•
test_configuration_manager()
```

## 8. æ—¥å¿—ç®¡ç†

```python
# æ—¥å¿—ç®¡ç†ç³»ç»Ÿ
import logging
import json
from datetime import datetime
from typing import Dict, Any, Optional

class LogManager:
    """æ—¥å¿—ç®¡ç†å™¨"""

    def __init__(self):
        self.loggers: Dict[str, logging.Logger] = {}
        self.log_handlers: Dict[str, logging.Handler] = {}

    def create_logger(self, name: str, level: str = "INFO",
                     log_file: Optional[str] = None) -> logging.Logger:
        """åˆ›å»ºæ—¥å¿—å™¨"""
        if name in self.loggers:
            return self.loggers[name]

        logger = logging.getLogger(name)
        logger.setLevel(getattr(logging, level.upper()))

# åˆ›å»ºæ ¼å¼åŒ–å™¨
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )

# æ·»åŠ æ§åˆ¶å°å¤„ç†å™¨
        console_handler = logging.StreamHandler()
        console_handler.setFormatter(formatter)
        logger.addHandler(console_handler)

# æ·»åŠ æ–‡ä»¶å¤„ç†å™¨ï¼ˆå¦‚æœæŒ‡å®šï¼‰
        if log_file:
            file_handler = logging.FileHandler(log_file)
            file_handler.setFormatter(formatter)
            logger.addHandler(file_handler)
            self.log_handlers[name] = file_handler

        self.loggers[name] = logger
        return logger

    def get_logger(self, name: str) -> logging.Logger:
        """è·å–æ—¥å¿—å™¨"""
        return self.loggers.get(name)

    def log_structured_data(self, logger_name: str, level: str,
                          message: str, data: Dict[str, Any]):
        """è®°å½•ç»“æ„åŒ–æ•°æ®"""
        logger = self.get_logger(logger_name)
        if logger:
            log_data = {
                'message': message,
                'data': data,
                'timestamp': datetime.now().isoformat()
            }
            log_level = getattr(logging, level.upper())
            logger.log(log_level, json.dumps(log_data))

    def set_log_level(self, logger_name: str, level: str):
        """è®¾ç½®æ—¥å¿—çº§åˆ«"""
        logger = self.get_logger(logger_name)
        if logger:
            logger.setLevel(getattr(logging, level.upper()))

# ä½¿ç”¨ç¤ºä¾‹
def test_log_manager():
    log_manager = LogManager()

# åˆ›å»ºæ—¥å¿—å™¨
    app_logger = log_manager.create_logger("app", "INFO", "app.log")
    db_logger = log_manager.create_logger("database", "DEBUG", "db.log")

# è®°å½•æ—¥å¿—
    app_logger.info("Application started")
    app_logger.warning("High memory usage detected")

    db_logger.debug("Database connection established")
    db_logger.error("Database query failed")

# è®°å½•ç»“æ„åŒ–æ•°æ®
    log_manager.log_structured_data("app", "INFO", "User action", {
        "user_id": "user_123",
        "action": "login",
        "ip": "192.168.1.1"
    })

# è®¾ç½®æ—¥å¿—çº§åˆ«
    log_manager.set_log_level("database", "ERROR")

    print("Log files created: app.log, db.log")

# è¿è¡Œæµ‹è¯•
test_log_manager()
```

## 9. æœ€ä½³å®è·µ

### 9.1. æ¶æ„è®¾è®¡åŸåˆ™

1. **å•ä¸€èŒè´£**ï¼šæ¯ä¸ªç»„ä»¶åªè´Ÿè´£ä¸€ä¸ªåŠŸèƒ½
2. **å¼€é—­åŸåˆ™**ï¼šå¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å…³é—­
3. **ä¾èµ–å€’ç½®**ï¼šä¾èµ–æŠ½è±¡è€Œéå…·ä½“å®ç°
4. **æ¥å£éš”ç¦»**ï¼šæä¾›æœ€å°åŒ–çš„æ¥å£

### 9.2. æ€§èƒ½ä¼˜åŒ–

1. **å¼‚æ­¥å¤„ç†**ï¼šä½¿ç”¨å¼‚æ­¥æ“ä½œæé«˜æ€§èƒ½
2. **ç¼“å­˜ç­–ç•¥**ï¼šåˆç†ä½¿ç”¨ç¼“å­˜å‡å°‘è®¡ç®—
3. **è´Ÿè½½å‡è¡¡**ï¼šåˆ†æ•£ç³»ç»Ÿè´Ÿè½½
4. **èµ„æºç®¡ç†**ï¼šåˆç†åˆ†é…å’Œé‡Šæ”¾èµ„æº

### 9.3. å®‰å…¨è€ƒè™‘

1. **è¾“å…¥éªŒè¯**ï¼šéªŒè¯æ‰€æœ‰è¾“å…¥æ•°æ®
2. **æƒé™æ§åˆ¶**ï¼šé™åˆ¶ç»„ä»¶è®¿é—®æƒé™
3. **æ•°æ®åŠ å¯†**ï¼šä¿æŠ¤æ•æ„Ÿæ•°æ®
4. **å®¡è®¡æ—¥å¿—**ï¼šè®°å½•é‡è¦æ“ä½œ

### 9.4. ç›‘æ§å‘Šè­¦

1. **æ€§èƒ½ç›‘æ§**ï¼šç›‘æ§ç³»ç»Ÿæ€§èƒ½æŒ‡æ ‡
2. **é”™è¯¯ç›‘æ§**ï¼šç›‘æ§ç³»ç»Ÿé”™è¯¯å’Œå¼‚å¸¸
3. **èµ„æºç›‘æ§**ï¼šç›‘æ§ç³»ç»Ÿèµ„æºä½¿ç”¨
4. **ä¸šåŠ¡ç›‘æ§**ï¼šç›‘æ§ä¸šåŠ¡å…³é”®æŒ‡æ ‡

## 10. æ€»ç»“

ç³»ç»Ÿæ¶æ„åŸºç¡€ç†è®ºä¸ºæ„å»ºé«˜è´¨é‡ã€å¯ç»´æŠ¤çš„è½¯ä»¶ç³»ç»Ÿæä¾›äº†é‡è¦æŒ‡å¯¼ã€‚é€šè¿‡åˆç†çš„æ¶æ„æ¨¡å¼é€‰æ‹©ã€æ¨¡å—åŒ–è®¾è®¡ã€å¯æ‰©å±•æ€§è§„åˆ’å’Œå¯ç»´æŠ¤æ€§è€ƒè™‘ï¼Œå¯ä»¥æ„å»ºå‡ºæ»¡è¶³ä¸šåŠ¡éœ€æ±‚çš„ä¼˜ç§€ç³»ç»Ÿæ¶æ„ã€‚
