# 软件工程深化实践案例

## 1. 设计模式实践案例

### 1.1 创建型模式实践

```python
# 抽象工厂模式 - 跨平台UI组件
from abc import ABC, abstractmethod

class Button(ABC):
    @abstractmethod
    def render(self):
        pass

class TextBox(ABC):
    @abstractmethod
    def render(self):
        pass

class WindowsButton(Button):
    def render(self):
        return "Windows风格按钮"

class WindowsTextBox(TextBox):
    def render(self):
        return "Windows风格文本框"

class MacButton(Button):
    def render(self):
        return "Mac风格按钮"

class MacTextBox(TextBox):
    def render(self):
        return "Mac风格文本框"

class UIFactory(ABC):
    @abstractmethod
    def create_button(self) -> Button:
        pass
    
    @abstractmethod
    def create_textbox(self) -> TextBox:
        pass

class WindowsUIFactory(UIFactory):
    def create_button(self) -> Button:
        return WindowsButton()
    
    def create_textbox(self) -> TextBox:
        return WindowsTextBox()

class MacUIFactory(UIFactory):
    def create_button(self) -> Button:
        return MacButton()
    
    def create_textbox(self) -> TextBox:
        return MacTextBox()

# 使用示例
def create_ui(factory: UIFactory):
    button = factory.create_button()
    textbox = factory.create_textbox()
    print(f"按钮: {button.render()}")
    print(f"文本框: {textbox.render()}")

# 测试
print("Windows UI:")
create_ui(WindowsUIFactory())
print("\nMac UI:")
create_ui(MacUIFactory())
```

### 1.2 结构型模式实践

```python
# 装饰器模式 - 咖啡订单系统
class Coffee:
    def cost(self):
        return 10
    
    def description(self):
        return "简单咖啡"

class CoffeeDecorator(Coffee):
    def __init__(self, coffee):
        self._coffee = coffee
    
    def cost(self):
        return self._coffee.cost()
    
    def description(self):
        return self._coffee.description()

class Milk(CoffeeDecorator):
    def cost(self):
        return self._coffee.cost() + 2
    
    def description(self):
        return self._coffee.description() + ", 牛奶"

class Sugar(CoffeeDecorator):
    def cost(self):
        return self._coffee.cost() + 1
    
    def description(self):
        return self._coffee.description() + ", 糖"

class Whip(CoffeeDecorator):
    def cost(self):
        return self._coffee.cost() + 3
    
    def description(self):
        return self._coffee.description() + ", 奶油"

# 使用示例
coffee = Coffee()
print(f"基础咖啡: {coffee.description()}, 价格: ${coffee.cost()}")

coffee_with_milk = Milk(coffee)
print(f"加牛奶: {coffee_with_milk.description()}, 价格: ${coffee_with_milk.cost()}")

coffee_with_milk_sugar = Sugar(coffee_with_milk)
print(f"加牛奶和糖: {coffee_with_milk_sugar.description()}, 价格: ${coffee_with_milk_sugar.cost()}")

coffee_complete = Whip(coffee_with_milk_sugar)
print(f"完整咖啡: {coffee_complete.description()}, 价格: ${coffee_complete.cost()}")
```

### 1.3 行为型模式实践

```python
# 观察者模式 - 股票价格监控系统
from abc import ABC, abstractmethod
from typing import List

class Observer(ABC):
    @abstractmethod
    def update(self, price: float):
        pass

class Subject(ABC):
    @abstractmethod
    def attach(self, observer: Observer):
        pass
    
    @abstractmethod
    def detach(self, observer: Observer):
        pass
    
    @abstractmethod
    def notify(self):
        pass

class StockPrice(Subject):
    def __init__(self, symbol: str, price: float):
        self._symbol = symbol
        self._price = price
        self._observers: List[Observer] = []
    
    def attach(self, observer: Observer):
        self._observers.append(observer)
    
    def detach(self, observer: Observer):
        self._observers.remove(observer)
    
    def notify(self):
        for observer in self._observers:
            observer.update(self._price)
    
    def set_price(self, price: float):
        self._price = price
        self.notify()
    
    def get_price(self):
        return self._price

class PriceAlert(Observer):
    def __init__(self, name: str, threshold: float):
        self._name = name
        self._threshold = threshold
    
    def update(self, price: float):
        if price > self._threshold:
            print(f"{self._name}: 价格 ${price} 超过阈值 ${self._threshold}")

class PriceLogger(Observer):
    def update(self, price: float):
        print(f"价格更新: ${price}")

# 使用示例
stock = StockPrice("AAPL", 150.0)
alert1 = PriceAlert("高风险警报", 160.0)
alert2 = PriceAlert("低风险警报", 155.0)
logger = PriceLogger()

stock.attach(alert1)
stock.attach(alert2)
stock.attach(logger)

print("初始价格: $150")
stock.set_price(155.0)
stock.set_price(165.0)
```

## 2. 微服务架构实践案例

### 2.1 服务注册与发现

```python
# 服务注册中心
import json
import time
from typing import Dict, List

class ServiceRegistry:
    def __init__(self):
        self._services: Dict[str, List[dict]] = {}
    
    def register(self, service_name: str, host: str, port: int, health_check_url: str):
        service_info = {
            'host': host,
            'port': port,
            'health_check_url': health_check_url,
            'registered_at': time.time(),
            'last_heartbeat': time.time()
        }
        
        if service_name not in self._services:
            self._services[service_name] = []
        
        self._services[service_name].append(service_info)
        print(f"服务 {service_name} 注册成功: {host}:{port}")
    
    def deregister(self, service_name: str, host: str, port: int):
        if service_name in self._services:
            self._services[service_name] = [
                s for s in self._services[service_name]
                if not (s['host'] == host and s['port'] == port)
            ]
            print(f"服务 {service_name} 注销成功: {host}:{port}")
    
    def get_services(self, service_name: str) -> List[dict]:
        return self._services.get(service_name, [])
    
    def heartbeat(self, service_name: str, host: str, port: int):
        for service in self._services.get(service_name, []):
            if service['host'] == host and service['port'] == port:
                service['last_heartbeat'] = time.time()
                break

# 服务发现客户端
class ServiceDiscovery:
    def __init__(self, registry: ServiceRegistry):
        self._registry = registry
    
    def discover_service(self, service_name: str) -> dict:
        services = self._registry.get_services(service_name)
        if not services:
            raise Exception(f"服务 {service_name} 不可用")
        
        # 简单的负载均衡 - 轮询
        service = services[0]  # 简化版本
        return service
    
    def get_service_url(self, service_name: str) -> str:
        service = self.discover_service(service_name)
        return f"http://{service['host']}:{service['port']}"

# 使用示例
registry = ServiceRegistry()
discovery = ServiceDiscovery(registry)

# 注册服务
registry.register("user-service", "localhost", 8081, "/health")
registry.register("user-service", "localhost", 8082, "/health")
registry.register("order-service", "localhost", 8083, "/health")

# 服务发现
try:
    user_service_url = discovery.get_service_url("user-service")
    print(f"发现用户服务: {user_service_url}")
except Exception as e:
    print(f"服务发现失败: {e}")
```

### 2.2 熔断器模式

```python
# 熔断器实现
import time
from enum import Enum
from typing import Callable, Any

class CircuitState(Enum):
    CLOSED = "CLOSED"      # 正常状态
    OPEN = "OPEN"         # 熔断状态
    HALF_OPEN = "HALF_OPEN"  # 半开状态

class CircuitBreaker:
    def __init__(self, failure_threshold: int = 5, recovery_timeout: int = 60):
        self.failure_threshold = failure_threshold
        self.recovery_timeout = recovery_timeout
        self.failure_count = 0
        self.last_failure_time = 0
        self.state = CircuitState.CLOSED
    
    def call(self, func: Callable, *args, **kwargs) -> Any:
        if self.state == CircuitState.OPEN:
            if time.time() - self.last_failure_time > self.recovery_timeout:
                self.state = CircuitState.HALF_OPEN
                print("熔断器进入半开状态")
            else:
                raise Exception("熔断器开启，服务不可用")
        
        try:
            result = func(*args, **kwargs)
            self._on_success()
            return result
        except Exception as e:
            self._on_failure()
            raise e
    
    def _on_success(self):
        self.failure_count = 0
        self.state = CircuitState.CLOSED
        print("调用成功，熔断器关闭")
    
    def _on_failure(self):
        self.failure_count += 1
        self.last_failure_time = time.time()
        
        if self.failure_count >= self.failure_threshold:
            self.state = CircuitState.OPEN
            print(f"失败次数达到阈值 {self.failure_threshold}，熔断器开启")

# 模拟服务调用
def unreliable_service(success_rate: float = 0.3):
    import random
    if random.random() > success_rate:
        raise Exception("服务调用失败")
    return "服务调用成功"

# 使用示例
breaker = CircuitBreaker(failure_threshold=3, recovery_timeout=10)

for i in range(10):
    try:
        result = breaker.call(unreliable_service, 0.3)
        print(f"调用 {i+1}: {result}")
    except Exception as e:
        print(f"调用 {i+1}: {e}")
    time.sleep(1)
```

## 3. 组件架构实践案例

### 3.1 插件化架构

```python
# 插件管理器
from abc import ABC, abstractmethod
from typing import Dict, Type
import importlib

class Plugin(ABC):
    @abstractmethod
    def name(self) -> str:
        pass
    
    @abstractmethod
    def execute(self, data: str) -> str:
        pass

class PluginManager:
    def __init__(self):
        self._plugins: Dict[str, Plugin] = {}
    
    def register_plugin(self, plugin: Plugin):
        self._plugins[plugin.name()] = plugin
        print(f"插件 {plugin.name()} 注册成功")
    
    def get_plugin(self, name: str) -> Plugin:
        return self._plugins.get(name)
    
    def list_plugins(self) -> list:
        return list(self._plugins.keys())
    
    def execute_plugin(self, name: str, data: str) -> str:
        plugin = self.get_plugin(name)
        if plugin:
            return plugin.execute(data)
        else:
            raise Exception(f"插件 {name} 不存在")

# 具体插件实现
class TextUppercasePlugin(Plugin):
    def name(self) -> str:
        return "uppercase"
    
    def execute(self, data: str) -> str:
        return data.upper()

class TextLowercasePlugin(Plugin):
    def name(self) -> str:
        return "lowercase"
    
    def execute(self, data: str) -> str:
        return data.lower()

class TextReversePlugin(Plugin):
    def name(self) -> str:
        return "reverse"
    
    def execute(self, data: str) -> str:
        return data[::-1]

# 使用示例
manager = PluginManager()

# 注册插件
manager.register_plugin(TextUppercasePlugin())
manager.register_plugin(TextLowercasePlugin())
manager.register_plugin(TextReversePlugin())

# 列出所有插件
print(f"可用插件: {manager.list_plugins()}")

# 执行插件
text = "Hello World"
print(f"原始文本: {text}")

for plugin_name in manager.list_plugins():
    try:
        result = manager.execute_plugin(plugin_name, text)
        print(f"{plugin_name}: {result}")
    except Exception as e:
        print(f"插件 {plugin_name} 执行失败: {e}")
```

### 3.2 事件驱动架构

```python
# 事件总线
from typing import Dict, List, Callable
from dataclasses import dataclass
from datetime import datetime

@dataclass
class Event:
    type: str
    data: dict
    timestamp: datetime = None
    
    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = datetime.now()

class EventBus:
    def __init__(self):
        self._handlers: Dict[str, List[Callable]] = {}
    
    def subscribe(self, event_type: str, handler: Callable):
        if event_type not in self._handlers:
            self._handlers[event_type] = []
        self._handlers[event_type].append(handler)
        print(f"订阅事件 {event_type}")
    
    def unsubscribe(self, event_type: str, handler: Callable):
        if event_type in self._handlers:
            self._handlers[event_type].remove(handler)
            print(f"取消订阅事件 {event_type}")
    
    def publish(self, event: Event):
        if event.type in self._handlers:
            for handler in self._handlers[event.type]:
                try:
                    handler(event)
                except Exception as e:
                    print(f"事件处理器执行失败: {e}")
        print(f"发布事件 {event.type}: {event.data}")

# 事件处理器
class UserEventHandler:
    def on_user_registered(self, event: Event):
        print(f"用户注册事件: {event.data}")
    
    def on_user_login(self, event: Event):
        print(f"用户登录事件: {event.data}")

class OrderEventHandler:
    def on_order_created(self, event: Event):
        print(f"订单创建事件: {event.data}")
    
    def on_order_paid(self, event: Event):
        print(f"订单支付事件: {event.data}")

# 使用示例
event_bus = EventBus()
user_handler = UserEventHandler()
order_handler = OrderEventHandler()

# 订阅事件
event_bus.subscribe("user.registered", user_handler.on_user_registered)
event_bus.subscribe("user.login", user_handler.on_user_login)
event_bus.subscribe("order.created", order_handler.on_order_created)
event_bus.subscribe("order.paid", order_handler.on_order_paid)

# 发布事件
user_registered_event = Event("user.registered", {
    "user_id": "12345",
    "email": "user@example.com",
    "username": "john_doe"
})

order_created_event = Event("order.created", {
    "order_id": "67890",
    "user_id": "12345",
    "amount": 99.99
})

event_bus.publish(user_registered_event)
event_bus.publish(order_created_event)
```

## 4. 工作流引擎实践案例

### 4.1 简单工作流引擎

```python
# 工作流引擎
from abc import ABC, abstractmethod
from typing import Dict, List, Any
from enum import Enum

class TaskStatus(Enum):
    PENDING = "PENDING"
    RUNNING = "RUNNING"
    COMPLETED = "COMPLETED"
    FAILED = "FAILED"

class Task(ABC):
    def __init__(self, name: str):
        self.name = name
        self.status = TaskStatus.PENDING
        self.result = None
    
    @abstractmethod
    def execute(self, context: Dict[str, Any]) -> Any:
        pass

class Workflow:
    def __init__(self, name: str):
        self.name = name
        self.tasks: List[Task] = []
        self.context: Dict[str, Any] = {}
    
    def add_task(self, task: Task):
        self.tasks.append(task)
    
    def execute(self):
        print(f"开始执行工作流: {self.name}")
        
        for task in self.tasks:
            try:
                task.status = TaskStatus.RUNNING
                print(f"执行任务: {task.name}")
                
                task.result = task.execute(self.context)
                task.status = TaskStatus.COMPLETED
                
                print(f"任务完成: {task.name}, 结果: {task.result}")
                
            except Exception as e:
                task.status = TaskStatus.FAILED
                print(f"任务失败: {task.name}, 错误: {e}")
                break

# 具体任务实现
class DataValidationTask(Task):
    def execute(self, context: Dict[str, Any]) -> Any:
        data = context.get("input_data", [])
        if not data:
            raise Exception("输入数据为空")
        
        valid_data = [item for item in data if isinstance(item, (int, float))]
        context["validated_data"] = valid_data
        return f"验证通过，有效数据: {len(valid_data)} 条"

class DataProcessingTask(Task):
    def execute(self, context: Dict[str, Any]) -> Any:
        data = context.get("validated_data", [])
        if not data:
            raise Exception("没有验证过的数据")
        
        processed_data = [x * 2 for x in data]
        context["processed_data"] = processed_data
        return f"处理完成，结果: {processed_data}"

class DataExportTask(Task):
    def execute(self, context: Dict[str, Any]) -> Any:
        data = context.get("processed_data", [])
        if not data:
            raise Exception("没有处理过的数据")
        
        # 模拟导出
        export_result = f"导出 {len(data)} 条数据到文件"
        context["export_result"] = export_result
        return export_result

# 使用示例
workflow = Workflow("数据处理工作流")

# 添加任务
workflow.add_task(DataValidationTask("数据验证"))
workflow.add_task(DataProcessingTask("数据处理"))
workflow.add_task(DataExportTask("数据导出"))

# 设置输入数据
workflow.context["input_data"] = [1, 2, 3, "invalid", 4, 5.5]

# 执行工作流
workflow.execute()

# 查看最终结果
print(f"\n工作流执行完成，最终结果: {workflow.context.get('export_result')}")
```

这些实践案例展示了软件工程深化中的核心概念和实际应用，包括设计模式、微服务架构、组件架构和工作流引擎等。每个案例都提供了完整的代码实现和使用示例，帮助理解这些概念的实际应用。
