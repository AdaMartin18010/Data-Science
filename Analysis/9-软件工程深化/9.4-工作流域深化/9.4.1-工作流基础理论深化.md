# 9.4.1 å·¥ä½œæµåŸºç¡€ç†è®ºæ·±åŒ–

## ğŸ“‘ ç›®å½•

- [9.4.1 å·¥ä½œæµåŸºç¡€ç†è®ºæ·±åŒ–](#941-å·¥ä½œæµåŸºç¡€ç†è®ºæ·±åŒ–)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. ç†è®ºåŸºç¡€](#1-ç†è®ºåŸºç¡€)
    - [1.1. å·¥ä½œæµæ¦‚è¿°](#11-å·¥ä½œæµæ¦‚è¿°)
    - [1.2. æ ¸å¿ƒæ¦‚å¿µ](#12-æ ¸å¿ƒæ¦‚å¿µ)
  - [2. çŠ¶æ€æœºæ¨¡å‹](#2-çŠ¶æ€æœºæ¨¡å‹)
    - [2.1. æœ‰é™çŠ¶æ€æœº](#21-æœ‰é™çŠ¶æ€æœº)
  - [3. äº‹ä»¶é©±åŠ¨çŠ¶æ€æœº](#3-äº‹ä»¶é©±åŠ¨çŠ¶æ€æœº)
  - [4. ä»»åŠ¡ç¼–æ’](#4-ä»»åŠ¡ç¼–æ’)
    - [4.1. ä»»åŠ¡ä¾èµ–ç®¡ç†](#41-ä»»åŠ¡ä¾èµ–ç®¡ç†)
  - [5. å¹¶è¡Œä»»åŠ¡æ‰§è¡Œ](#5-å¹¶è¡Œä»»åŠ¡æ‰§è¡Œ)
  - [6. æµç¨‹å¼•æ“](#6-æµç¨‹å¼•æ“)
    - [6.1. è§„åˆ™å¼•æ“](#61-è§„åˆ™å¼•æ“)
  - [7. å†³ç­–è¡¨](#7-å†³ç­–è¡¨)
  - [8. å¼‚å¸¸å¤„ç†](#8-å¼‚å¸¸å¤„ç†)
    - [8.1. é‡è¯•æœºåˆ¶](#81-é‡è¯•æœºåˆ¶)
  - [9. è¡¥å¿æœºåˆ¶](#9-è¡¥å¿æœºåˆ¶)
  - [10. æœ€ä½³å®è·µ](#10-æœ€ä½³å®è·µ)
    - [10.1. å·¥ä½œæµè®¾è®¡åŸåˆ™](#101-å·¥ä½œæµè®¾è®¡åŸåˆ™)
    - [10.2. æ€§èƒ½ä¼˜åŒ–](#102-æ€§èƒ½ä¼˜åŒ–)
    - [10.3. é”™è¯¯å¤„ç†](#103-é”™è¯¯å¤„ç†)
    - [10.4. å®‰å…¨è€ƒè™‘](#104-å®‰å…¨è€ƒè™‘)
  - [11. æ€»ç»“](#11-æ€»ç»“)

---


## 1. ç†è®ºåŸºç¡€

### 1.1. å·¥ä½œæµæ¦‚è¿°

å·¥ä½œæµ(Workflow)æ˜¯ä¸€ç³»åˆ—ç›¸äº’å…³è”çš„ä»»åŠ¡å’Œå†³ç­–ç‚¹çš„é›†åˆï¼Œç”¨äºè‡ªåŠ¨åŒ–ä¸šåŠ¡æµç¨‹ï¼š

- **ä»»åŠ¡ç¼–æ’**ï¼šå®šä¹‰ä»»åŠ¡çš„æ‰§è¡Œé¡ºåºå’Œä¾èµ–å…³ç³»
- **çŠ¶æ€ç®¡ç†**ï¼šè·Ÿè¸ªå·¥ä½œæµçš„æ‰§è¡ŒçŠ¶æ€
- **å†³ç­–é€»è¾‘**ï¼šæ ¹æ®æ¡ä»¶è‡ªåŠ¨é€‰æ‹©æ‰§è¡Œè·¯å¾„
- **å¼‚å¸¸å¤„ç†**ï¼šå¤„ç†æ‰§è¡Œè¿‡ç¨‹ä¸­çš„å¼‚å¸¸æƒ…å†µ

### 1.2. æ ¸å¿ƒæ¦‚å¿µ

- **æµç¨‹å®šä¹‰**ï¼šæè¿°å·¥ä½œæµçš„ç»“æ„å’Œè§„åˆ™
- **æµç¨‹å®ä¾‹**ï¼šå·¥ä½œæµçš„å…·ä½“æ‰§è¡Œå®ä¾‹
- **ä»»åŠ¡èŠ‚ç‚¹**ï¼šå·¥ä½œæµä¸­çš„å…·ä½“æ‰§è¡Œå•å…ƒ
- **ç½‘å…³èŠ‚ç‚¹**ï¼šæ§åˆ¶æµç¨‹åˆ†æ”¯å’Œåˆå¹¶çš„å†³ç­–ç‚¹

## 2. çŠ¶æ€æœºæ¨¡å‹

### 2.1. æœ‰é™çŠ¶æ€æœº

```python
# æœ‰é™çŠ¶æ€æœºå®ç°
from enum import Enum
from typing import Dict, Callable, Any

class WorkflowState(Enum):
    INITIAL = "initial"
    PROCESSING = "processing"
    APPROVED = "approved"
    REJECTED = "rejected"
    COMPLETED = "completed"

class WorkflowTransition:
    def __init__(self, from_state: WorkflowState, to_state: WorkflowState,
                 condition: Callable[[Any], bool] = None):
        self.from_state = from_state
        self.to_state = to_state
        self.condition = condition or (lambda x: True)

class WorkflowStateMachine:
    def __init__(self):
        self.current_state = WorkflowState.INITIAL
        self.transitions: Dict[WorkflowState, list] = {}
        self.data = {}

    def add_transition(self, transition: WorkflowTransition):
        if transition.from_state not in self.transitions:
            self.transitions[transition.from_state] = []
        self.transitions[transition.from_state].append(transition)

    def can_transition(self, to_state: WorkflowState) -> bool:
        if self.current_state not in self.transitions:
            return False

        for transition in self.transitions[self.current_state]:
            if (transition.to_state == to_state and
                transition.condition(self.data)):
                return True
        return False

    def transition_to(self, to_state: WorkflowState) -> bool:
        if self.can_transition(to_state):
            self.current_state = to_state
            return True
        return False

    def get_available_transitions(self) -> list:
        if self.current_state not in self.transitions:
            return []

        available = []
        for transition in self.transitions[self.current_state]:
            if transition.condition(self.data):
                available.append(transition.to_state)
        return available

# ä½¿ç”¨ç¤ºä¾‹
def create_approval_workflow():
    workflow = WorkflowStateMachine()

# å®šä¹‰è½¬æ¢
    transitions = [
        WorkflowTransition(WorkflowState.INITIAL, WorkflowState.PROCESSING),
        WorkflowTransition(WorkflowState.PROCESSING, WorkflowState.APPROVED,
                         lambda data: data.get('approved', False)),
        WorkflowTransition(WorkflowState.PROCESSING, WorkflowState.REJECTED,
                         lambda data: not data.get('approved', True)),
        WorkflowTransition(WorkflowState.APPROVED, WorkflowState.COMPLETED),
        WorkflowTransition(WorkflowState.REJECTED, WorkflowState.COMPLETED)
    ]

    for transition in transitions:
        workflow.add_transition(transition)

    return workflow

# æµ‹è¯•å·¥ä½œæµ
workflow = create_approval_workflow()
print(f"Initial state: {workflow.current_state}")

# è½¬æ¢åˆ°å¤„ç†çŠ¶æ€
workflow.transition_to(WorkflowState.PROCESSING)
print(f"Current state: {workflow.current_state}")

# è®¾ç½®å®¡æ‰¹ç»“æœ
workflow.data['approved'] = True
print(f"Available transitions: {workflow.get_available_transitions()}")

# è½¬æ¢åˆ°å®¡æ‰¹é€šè¿‡çŠ¶æ€
workflow.transition_to(WorkflowState.APPROVED)
print(f"Current state: {workflow.current_state}")
```

## 3. äº‹ä»¶é©±åŠ¨çŠ¶æ€æœº

```python
# äº‹ä»¶é©±åŠ¨çŠ¶æ€æœº
from typing import Dict, List, Callable
import asyncio

class WorkflowEvent:
    def __init__(self, event_type: str, data: dict = None):
        self.event_type = event_type
        self.data = data or {}
        self.timestamp = time.time()

class EventDrivenWorkflow:
    def __init__(self):
        self.current_state = WorkflowState.INITIAL
        self.event_handlers: Dict[str, List[Callable]] = {}
        self.state_handlers: Dict[WorkflowState, Callable] = {}
        self.data = {}

    def register_event_handler(self, event_type: str, handler: Callable):
        if event_type not in self.event_handlers:
            self.event_handlers[event_type] = []
        self.event_handlers[event_type].append(handler)

    def register_state_handler(self, state: WorkflowState, handler: Callable):
        self.state_handlers[state] = handler

    async def handle_event(self, event: WorkflowEvent):
# å¤„ç†äº‹ä»¶
        if event.event_type in self.event_handlers:
            for handler in self.event_handlers[event.event_type]:
                await handler(event, self)

# çŠ¶æ€è½¬æ¢é€»è¾‘
        await self.process_state_transition(event)

    async def process_state_transition(self, event: WorkflowEvent):
# æ ¹æ®äº‹ä»¶ç±»å‹å’Œå½“å‰çŠ¶æ€å†³å®šä¸‹ä¸€ä¸ªçŠ¶æ€
        if self.current_state == WorkflowState.INITIAL:
            if event.event_type == "start_processing":
                self.current_state = WorkflowState.PROCESSING
        elif self.current_state == WorkflowState.PROCESSING:
            if event.event_type == "approve":
                self.current_state = WorkflowState.APPROVED
            elif event.event_type == "reject":
                self.current_state = WorkflowState.REJECTED
        elif self.current_state in [WorkflowState.APPROVED, WorkflowState.REJECTED]:
            if event.event_type == "complete":
                self.current_state = WorkflowState.COMPLETED

# æ‰§è¡ŒçŠ¶æ€å¤„ç†å™¨
        if self.current_state in self.state_handlers:
            await self.state_handlers[self.current_state](self)

# äº‹ä»¶å¤„ç†å™¨ç¤ºä¾‹
async def handle_approval_request(event: WorkflowEvent, workflow: EventDrivenWorkflow):
    print(f"Handling approval request: {event.data}")
    workflow.data.update(event.data)

async def handle_approval_decision(event: WorkflowEvent, workflow: EventDrivenWorkflow):
    print(f"Handling approval decision: {event.data}")
    workflow.data['approved'] = event.data.get('approved', False)

async def processing_state_handler(workflow: EventDrivenWorkflow):
    print(f"Entering processing state with data: {workflow.data}")

async def approved_state_handler(workflow: EventDrivenWorkflow):
    print("Workflow approved, sending notification")

async def rejected_state_handler(workflow: EventDrivenWorkflow):
    print("Workflow rejected, sending notification")

# ä½¿ç”¨ç¤ºä¾‹
async def test_event_driven_workflow():
    workflow = EventDrivenWorkflow()

# æ³¨å†Œäº‹ä»¶å¤„ç†å™¨
    workflow.register_event_handler("approval_request", handle_approval_request)
    workflow.register_event_handler("approval_decision", handle_approval_decision)

# æ³¨å†ŒçŠ¶æ€å¤„ç†å™¨
    workflow.register_state_handler(WorkflowState.PROCESSING, processing_state_handler)
    workflow.register_state_handler(WorkflowState.APPROVED, approved_state_handler)
    workflow.register_state_handler(WorkflowState.REJECTED, rejected_state_handler)

# å¤„ç†äº‹ä»¶åºåˆ—
    events = [
        WorkflowEvent("start_processing", {"request_id": "123"}),
        WorkflowEvent("approval_request", {"amount": 1000}),
        WorkflowEvent("approval_decision", {"approved": True}),
        WorkflowEvent("complete")
    ]

    for event in events:
        await workflow.handle_event(event)
        print(f"Current state: {workflow.current_state}")

# è¿è¡Œæµ‹è¯•
asyncio.run(test_event_driven_workflow())
```

## 4. ä»»åŠ¡ç¼–æ’

### 4.1. ä»»åŠ¡ä¾èµ–ç®¡ç†

```python
# ä»»åŠ¡ä¾èµ–ç®¡ç†
from typing import Dict, List, Set, Callable
import networkx as nx

class Task:
    def __init__(self, task_id: str, name: str, handler: Callable = None):
        self.task_id = task_id
        self.name = name
        self.handler = handler
        self.dependencies: Set[str] = set()
        self.status = "pending"
        self.result = None
        self.error = None

    def add_dependency(self, task_id: str):
        self.dependencies.add(task_id)

    def is_ready(self, completed_tasks: Set[str]) -> bool:
        return self.dependencies.issubset(completed_tasks)

    async def execute(self, context: dict):
        if self.handler:
            try:
                self.result = await self.handler(context)
                self.status = "completed"
            except Exception as e:
                self.error = str(e)
                self.status = "failed"
        else:
            self.status = "completed"

class WorkflowOrchestrator:
    def __init__(self):
        self.tasks: Dict[str, Task] = {}
        self.execution_graph = nx.DiGraph()

    def add_task(self, task: Task):
        self.tasks[task.task_id] = task
        self.execution_graph.add_node(task.task_id)

    def add_dependency(self, task_id: str, dependency_id: str):
        if task_id in self.tasks and dependency_id in self.tasks:
            self.tasks[task_id].add_dependency(dependency_id)
            self.execution_graph.add_edge(dependency_id, task_id)

    def validate_workflow(self) -> bool:
        """éªŒè¯å·¥ä½œæµæ˜¯å¦æœ‰å¾ªç¯ä¾èµ–"""
        try:
            nx.topological_sort(self.execution_graph)
            return True
        except nx.NetworkXError:
            return False

    def get_execution_order(self) -> List[List[str]]:
        """è·å–ä»»åŠ¡æ‰§è¡Œé¡ºåº"""
        if not self.validate_workflow():
            raise ValueError("Workflow has circular dependencies")

# ä½¿ç”¨æ‹“æ‰‘æ’åºè·å–æ‰§è¡Œé¡ºåº
        sorted_tasks = list(nx.topological_sort(self.execution_graph))

# æŒ‰å±‚çº§åˆ†ç»„
        levels = []
        current_level = []
        completed = set()

        for task_id in sorted_tasks:
            task = self.tasks[task_id]
            if task.is_ready(completed):
                current_level.append(task_id)
            else:
                if current_level:
                    levels.append(current_level)
                    completed.update(current_level)
                    current_level = [task_id]

        if current_level:
            levels.append(current_level)

        return levels

    async def execute_workflow(self, context: dict = None):
        """æ‰§è¡Œå·¥ä½œæµ"""
        if not self.validate_workflow():
            raise ValueError("Workflow has circular dependencies")

        context = context or {}
        completed_tasks = set()
        failed_tasks = set()

        execution_order = self.get_execution_order()

        for level in execution_order:
# å¹¶è¡Œæ‰§è¡ŒåŒä¸€å±‚çº§çš„ä»»åŠ¡
            tasks_to_execute = [
                self.tasks[task_id] for task_id in level
                if task_id not in completed_tasks and task_id not in failed_tasks
            ]

            if tasks_to_execute:
# å¹¶è¡Œæ‰§è¡Œä»»åŠ¡
                import asyncio
                execution_tasks = [
                    task.execute(context) for task in tasks_to_execute
                ]
                await asyncio.gather(*execution_tasks)

# æ›´æ–°å®ŒæˆçŠ¶æ€
                for task in tasks_to_execute:
                    if task.status == "completed":
                        completed_tasks.add(task.task_id)
                    elif task.status == "failed":
                        failed_tasks.add(task.task_id)

        return {
            'completed': completed_tasks,
            'failed': failed_tasks,
            'results': {task_id: self.tasks[task_id].result
                       for task_id in completed_tasks}
        }

# ä»»åŠ¡å¤„ç†å™¨ç¤ºä¾‹
async def validate_request(context: dict):
    print("Validating request...")
    await asyncio.sleep(1)
    return {"valid": True, "request_id": context.get("request_id")}

async def process_payment(context: dict):
    print("Processing payment...")
    await asyncio.sleep(2)
    return {"payment_id": "pay_123", "status": "success"}

async def send_notification(context: dict):
    print("Sending notification...")
    await asyncio.sleep(1)
    return {"notification_sent": True}

# ä½¿ç”¨ç¤ºä¾‹
async def test_workflow_orchestrator():
    orchestrator = WorkflowOrchestrator()

# åˆ›å»ºä»»åŠ¡
    tasks = [
        Task("validate", "Validate Request", validate_request),
        Task("payment", "Process Payment", process_payment),
        Task("notify", "Send Notification", send_notification)
    ]

    for task in tasks:
        orchestrator.add_task(task)

# æ·»åŠ ä¾èµ–å…³ç³»
    orchestrator.add_dependency("payment", "validate")
    orchestrator.add_dependency("notify", "payment")

# æ‰§è¡Œå·¥ä½œæµ
    context = {"request_id": "req_123", "amount": 100}
    result = await orchestrator.execute_workflow(context)

    print("Workflow execution result:", result)

# è¿è¡Œæµ‹è¯•
asyncio.run(test_workflow_orchestrator())
```

## 5. å¹¶è¡Œä»»åŠ¡æ‰§è¡Œ

```python
# å¹¶è¡Œä»»åŠ¡æ‰§è¡Œ
import asyncio
from concurrent.futures import ThreadPoolExecutor
from typing import List, Dict, Any

class ParallelTaskExecutor:
    def __init__(self, max_workers: int = 4):
        self.max_workers = max_workers
        self.executor = ThreadPoolExecutor(max_workers=max_workers)

    async def execute_parallel_tasks(self, tasks: List[Callable],
                                   context: Dict[str, Any] = None) -> List[Any]:
        """å¹¶è¡Œæ‰§è¡Œä»»åŠ¡"""
        context = context or {}

# åˆ›å»ºå¼‚æ­¥ä»»åŠ¡
        async def execute_task(task):
            if asyncio.iscoroutinefunction(task):
                return await task(context)
            else:
# å¯¹äºåŒæ­¥å‡½æ•°ï¼Œåœ¨çº¿ç¨‹æ± ä¸­æ‰§è¡Œ
                loop = asyncio.get_event_loop()
                return await loop.run_in_executor(self.executor, task, context)

# å¹¶è¡Œæ‰§è¡Œæ‰€æœ‰ä»»åŠ¡
        results = await asyncio.gather(*[execute_task(task) for task in tasks])
        return results

    async def execute_with_dependencies(self, task_graph: Dict[str, List[str]],
                                      task_handlers: Dict[str, Callable],
                                      context: Dict[str, Any] = None) -> Dict[str, Any]:
        """æ‰§è¡Œæœ‰ä¾èµ–å…³ç³»çš„ä»»åŠ¡"""
        context = context or {}
        results = {}
        completed = set()

        while len(completed) < len(task_graph):
# æ‰¾åˆ°å¯ä»¥æ‰§è¡Œçš„ä»»åŠ¡
            ready_tasks = []
            for task_id, dependencies in task_graph.items():
                if (task_id not in completed and
                    all(dep in completed for dep in dependencies)):
                    ready_tasks.append(task_id)

            if not ready_tasks:
                raise ValueError("Circular dependency detected")

# å¹¶è¡Œæ‰§è¡Œå°±ç»ªçš„ä»»åŠ¡
            task_functions = [task_handlers[task_id] for task_id in ready_tasks]
            task_results = await self.execute_parallel_tasks(task_functions, context)

# æ›´æ–°ç»“æœå’Œå®ŒæˆçŠ¶æ€
            for task_id, result in zip(ready_tasks, task_results):
                results[task_id] = result
                completed.add(task_id)

        return results

# ä»»åŠ¡ç¤ºä¾‹
async def task_a(context):
    print("Executing task A")
    await asyncio.sleep(1)
    return {"result": "A", "data": context.get("input", 0) * 2}

async def task_b(context):
    print("Executing task B")
    await asyncio.sleep(1)
    return {"result": "B", "data": context.get("input", 0) + 10}

async def task_c(context):
    print("Executing task C")
    await asyncio.sleep(1)
    return {"result": "C", "data": context.get("input", 0) - 5}

def task_d(context):
    print("Executing task D (synchronous)")
    import time
    time.sleep(1)
    return {"result": "D", "data": context.get("input", 0) * 3}

# ä½¿ç”¨ç¤ºä¾‹
async def test_parallel_execution():
    executor = ParallelTaskExecutor(max_workers=4)

# å¹¶è¡Œæ‰§è¡Œç‹¬ç«‹ä»»åŠ¡
    tasks = [task_a, task_b, task_c, task_d]
    context = {"input": 5}

    results = await executor.execute_parallel_tasks(tasks, context)
    print("Parallel execution results:", results)

# æ‰§è¡Œæœ‰ä¾èµ–å…³ç³»çš„ä»»åŠ¡
    task_graph = {
        "task_a": [],
        "task_b": ["task_a"],
        "task_c": ["task_a"],
        "task_d": ["task_b", "task_c"]
    }

    task_handlers = {
        "task_a": task_a,
        "task_b": task_b,
        "task_c": task_c,
        "task_d": task_d
    }

    dependency_results = await executor.execute_with_dependencies(
        task_graph, task_handlers, context
    )
    print("Dependency execution results:", dependency_results)

# è¿è¡Œæµ‹è¯•
asyncio.run(test_parallel_execution())
```

## 6. æµç¨‹å¼•æ“

### 6.1. è§„åˆ™å¼•æ“

```python
# è§„åˆ™å¼•æ“å®ç°
from typing import Dict, List, Any, Callable
import re

class Rule:
    def __init__(self, name: str, condition: Callable, action: Callable, priority: int = 0):
        self.name = name
        self.condition = condition
        self.action = action
        self.priority = priority

    def evaluate(self, context: Dict[str, Any]) -> bool:
        """è¯„ä¼°è§„åˆ™æ¡ä»¶"""
        try:
            return self.condition(context)
        except Exception as e:
            print(f"Error evaluating rule {self.name}: {e}")
            return False

    async def execute(self, context: Dict[str, Any]):
        """æ‰§è¡Œè§„åˆ™åŠ¨ä½œ"""
        try:
            if asyncio.iscoroutinefunction(self.action):
                await self.action(context)
            else:
                self.action(context)
        except Exception as e:
            print(f"Error executing rule {self.name}: {e}")

class RuleEngine:
    def __init__(self):
        self.rules: List[Rule] = []

    def add_rule(self, rule: Rule):
        self.rules.append(rule)
# æŒ‰ä¼˜å…ˆçº§æ’åº
        self.rules.sort(key=lambda r: r.priority, reverse=True)

    async def execute_rules(self, context: Dict[str, Any]) -> List[str]:
        """æ‰§è¡ŒåŒ¹é…çš„è§„åˆ™"""
        executed_rules = []

        for rule in self.rules:
            if rule.evaluate(context):
                await rule.execute(context)
                executed_rules.append(rule.name)

        return executed_rules

    def add_condition_rule(self, name: str, condition_expr: str, action: Callable, priority: int = 0):
        """æ·»åŠ åŸºäºè¡¨è¾¾å¼çš„è§„åˆ™"""
        def condition(context):
# ç®€å•çš„è¡¨è¾¾å¼æ±‚å€¼
            expr = condition_expr
            for key, value in context.items():
                expr = expr.replace(f"${key}", str(value))

# å®‰å…¨åœ°æ±‚å€¼è¡¨è¾¾å¼
            try:
                return eval(expr)
            except:
                return False

        rule = Rule(name, condition, action, priority)
        self.add_rule(rule)

# è§„åˆ™ç¤ºä¾‹
async def approve_action(context):
    print(f"Approving request {context.get('request_id')}")
    context['status'] = 'approved'

async def reject_action(context):
    print(f"Rejecting request {context.get('request_id')}")
    context['status'] = 'rejected'

async def escalate_action(context):
    print(f"Escalating request {context.get('request_id')}")
    context['status'] = 'escalated'

# ä½¿ç”¨ç¤ºä¾‹
async def test_rule_engine():
    engine = RuleEngine()

# æ·»åŠ è§„åˆ™
    engine.add_condition_rule(
        "auto_approve_small_amounts",
        "${amount} <= 1000",
        approve_action,
        priority=1
    )

    engine.add_condition_rule(
        "reject_large_amounts",
        "${amount} > 10000",
        reject_action,
        priority=2
    )

    engine.add_condition_rule(
        "escalate_medium_amounts",
        "${amount} > 1000 and ${amount} <= 10000",
        escalate_action,
        priority=0
    )

# æµ‹è¯•ä¸åŒåœºæ™¯
    test_cases = [
        {"request_id": "req1", "amount": 500},
        {"request_id": "req2", "amount": 5000},
        {"request_id": "req3", "amount": 15000}
    ]

    for case in test_cases:
        print(f"\nTesting case: {case}")
        executed = await engine.execute_rules(case)
        print(f"Executed rules: {executed}")
        print(f"Final status: {case.get('status')}")

# è¿è¡Œæµ‹è¯•
asyncio.run(test_rule_engine())
```

## 7. å†³ç­–è¡¨

```python
# å†³ç­–è¡¨å®ç°
from typing import Dict, List, Any, Callable
import pandas as pd

class DecisionTable:
    def __init__(self):
        self.conditions = []
        self.actions = []
        self.rules = []

    def add_condition(self, name: str, getter: Callable):
        """æ·»åŠ æ¡ä»¶åˆ—"""
        self.conditions.append((name, getter))

    def add_action(self, name: str, action: Callable):
        """æ·»åŠ åŠ¨ä½œåˆ—"""
        self.actions.append((name, action))

    def add_rule(self, condition_values: List[Any], action_values: List[bool]):
        """æ·»åŠ è§„åˆ™è¡Œ"""
        if len(condition_values) != len(self.conditions):
            raise ValueError("Condition values count doesn't match conditions")
        if len(action_values) != len(self.actions):
            raise ValueError("Action values count doesn't match actions")

        self.rules.append((condition_values, action_values))

    async def evaluate(self, context: Dict[str, Any]) -> List[str]:
        """è¯„ä¼°å†³ç­–è¡¨"""
        executed_actions = []

        for rule_conditions, rule_actions in self.rules:
# æ£€æŸ¥æ¡ä»¶æ˜¯å¦åŒ¹é…
            conditions_match = True
            for i, (condition_name, condition_getter) in enumerate(self.conditions):
                expected_value = rule_conditions[i]
                actual_value = condition_getter(context)

                if actual_value != expected_value:
                    conditions_match = False
                    break

            if conditions_match:
# æ‰§è¡ŒåŒ¹é…è§„åˆ™çš„åŠ¨ä½œ
                for i, should_execute in enumerate(rule_actions):
                    if should_execute:
                        action_name, action_func = self.actions[i]
                        if asyncio.iscoroutinefunction(action_func):
                            await action_func(context)
                        else:
                            action_func(context)
                        executed_actions.append(action_name)
                break

        return executed_actions

    def to_dataframe(self) -> pd.DataFrame:
        """è½¬æ¢ä¸ºDataFrameä¾¿äºæŸ¥çœ‹"""
        columns = [name for name, _ in self.conditions] + [name for name, _ in self.actions]
        data = []

        for rule_conditions, rule_actions in self.rules:
            row = list(rule_conditions) + rule_actions
            data.append(row)

        return pd.DataFrame(data, columns=columns)

# ä½¿ç”¨ç¤ºä¾‹
async def test_decision_table():
    table = DecisionTable()

# æ·»åŠ æ¡ä»¶
    table.add_condition("amount", lambda ctx: ctx.get("amount", 0))
    table.add_condition("customer_type", lambda ctx: ctx.get("customer_type", "regular"))

# æ·»åŠ åŠ¨ä½œ
    async def auto_approve(ctx):
        ctx['status'] = 'approved'
        print(f"Auto approving request {ctx.get('request_id')}")

    async def manual_review(ctx):
        ctx['status'] = 'manual_review'
        print(f"Manual review required for request {ctx.get('request_id')}")

    async def reject(ctx):
        ctx['status'] = 'rejected'
        print(f"Rejecting request {ctx.get('request_id')}")

    table.add_action("auto_approve", auto_approve)
    table.add_action("manual_review", manual_review)
    table.add_action("reject", reject)

# æ·»åŠ è§„åˆ™
# æ¡ä»¶: amount, customer_type | åŠ¨ä½œ: auto_approve, manual_review, reject
    table.add_rule([1000, "premium"], [True, False, False])   # å°é¢+é«˜çº§å®¢æˆ·ï¼šè‡ªåŠ¨æ‰¹å‡†
    table.add_rule([1000, "regular"], [False, True, False])   # å°é¢+æ™®é€šå®¢æˆ·ï¼šäººå·¥å®¡æ ¸
    table.add_rule([5000, "premium"], [False, True, False])   # ä¸­é¢+é«˜çº§å®¢æˆ·ï¼šäººå·¥å®¡æ ¸
    table.add_rule([5000, "regular"], [False, True, False])   # ä¸­é¢+æ™®é€šå®¢æˆ·ï¼šäººå·¥å®¡æ ¸
    table.add_rule([15000, "premium"], [False, True, False])  # å¤§é¢+é«˜çº§å®¢æˆ·ï¼šäººå·¥å®¡æ ¸
    table.add_rule([15000, "regular"], [False, False, True])  # å¤§é¢+æ™®é€šå®¢æˆ·ï¼šæ‹’ç»

# æ˜¾ç¤ºå†³ç­–è¡¨
    print("Decision Table:")
    print(table.to_dataframe())

# æµ‹è¯•ä¸åŒåœºæ™¯
    test_cases = [
        {"request_id": "req1", "amount": 800, "customer_type": "premium"},
        {"request_id": "req2", "amount": 800, "customer_type": "regular"},
        {"request_id": "req3", "amount": 6000, "customer_type": "premium"},
        {"request_id": "req4", "amount": 20000, "customer_type": "regular"}
    ]

    for case in test_cases:
        print(f"\nTesting case: {case}")
        executed = await table.evaluate(case)
        print(f"Executed actions: {executed}")
        print(f"Final status: {case.get('status')}")

# è¿è¡Œæµ‹è¯•
asyncio.run(test_decision_table())
```

## 8. å¼‚å¸¸å¤„ç†

### 8.1. é‡è¯•æœºåˆ¶

```python
# é‡è¯•æœºåˆ¶å®ç°
import asyncio
from typing import Callable, Any, Optional
import time

class RetryConfig:
    def __init__(self, max_attempts: int = 3, delay: float = 1.0,
                 backoff_factor: float = 2.0, max_delay: float = 60.0):
        self.max_attempts = max_attempts
        self.delay = delay
        self.backoff_factor = backoff_factor
        self.max_delay = max_delay

class RetryHandler:
    def __init__(self, config: RetryConfig):
        self.config = config

    async def execute_with_retry(self, func: Callable, *args, **kwargs) -> Any:
        """å¸¦é‡è¯•çš„æ‰§è¡Œ"""
        last_exception = None

        for attempt in range(self.config.max_attempts):
            try:
                if asyncio.iscoroutinefunction(func):
                    return await func(*args, **kwargs)
                else:
                    return func(*args, **kwargs)
            except Exception as e:
                last_exception = e
                print(f"Attempt {attempt + 1} failed: {e}")

                if attempt < self.config.max_attempts - 1:
                    delay = min(
                        self.config.delay * (self.config.backoff_factor ** attempt),
                        self.config.max_delay
                    )
                    print(f"Retrying in {delay} seconds...")
                    await asyncio.sleep(delay)

        raise last_exception

# ä½¿ç”¨ç¤ºä¾‹
async def unreliable_function():
    """æ¨¡æ‹Ÿä¸å¯é çš„å‡½æ•°"""
    import random
    if random.random() < 0.7:  # 70%æ¦‚ç‡å¤±è´¥
        raise Exception("Random failure")
    return "Success"

async def test_retry_mechanism():
    config = RetryConfig(max_attempts=5, delay=0.5, backoff_factor=1.5)
    handler = RetryHandler(config)

    try:
        result = await handler.execute_with_retry(unreliable_function)
        print(f"Final result: {result}")
    except Exception as e:
        print(f"All attempts failed: {e}")

# è¿è¡Œæµ‹è¯•
asyncio.run(test_retry_mechanism())
```

## 9. è¡¥å¿æœºåˆ¶

```python
# è¡¥å¿æœºåˆ¶å®ç°
from typing import Dict, List, Callable, Any
import asyncio

class CompensationAction:
    def __init__(self, name: str, action: Callable, compensation: Callable):
        self.name = name
        self.action = action
        self.compensation = compensation
        self.executed = False
        self.result = None

    async def execute(self, context: Dict[str, Any]):
        """æ‰§è¡ŒåŠ¨ä½œ"""
        try:
            if asyncio.iscoroutinefunction(self.action):
                self.result = await self.action(context)
            else:
                self.result = self.action(context)
            self.executed = True
            return self.result
        except Exception as e:
            print(f"Action {self.name} failed: {e}")
            raise

    async def compensate(self, context: Dict[str, Any]):
        """æ‰§è¡Œè¡¥å¿"""
        if self.executed:
            try:
                if asyncio.iscoroutinefunction(self.compensation):
                    await self.compensation(context, self.result)
                else:
                    self.compensation(context, self.result)
                print(f"Compensation for {self.name} executed")
            except Exception as e:
                print(f"Compensation for {self.name} failed: {e}")

class SagaWorkflow:
    def __init__(self):
        self.actions: List[CompensationAction] = []

    def add_action(self, name: str, action: Callable, compensation: Callable):
        """æ·»åŠ åŠ¨ä½œå’Œè¡¥å¿"""
        comp_action = CompensationAction(name, action, compensation)
        self.actions.append(comp_action)

    async def execute(self, context: Dict[str, Any]):
        """æ‰§è¡ŒSagaå·¥ä½œæµ"""
        executed_actions = []

        try:
            for action in self.actions:
                await action.execute(context)
                executed_actions.append(action)
                print(f"Action {action.name} executed successfully")

        except Exception as e:
            print(f"Workflow failed, starting compensation: {e}")
# æ‰§è¡Œè¡¥å¿
            for action in reversed(executed_actions):
                await action.compensate(context)

        return context

# ä½¿ç”¨ç¤ºä¾‹
async def reserve_inventory(context):
    print(f"Reserving inventory for order {context.get('order_id')}")
    context['inventory_reserved'] = True
    return "inventory_reserved"

async def compensate_inventory(context, result):
    print(f"Releasing inventory for order {context.get('order_id')}")
    context['inventory_reserved'] = False

async def process_payment(context):
    print(f"Processing payment for order {context.get('order_id')}")
    context['payment_processed'] = True
    return "payment_processed"

async def compensate_payment(context, result):
    print(f"Refunding payment for order {context.get('order_id')}")
    context['payment_processed'] = False

async def send_notification(context):
    print(f"Sending notification for order {context.get('order_id')}")
    context['notification_sent'] = True
    return "notification_sent"

async def compensate_notification(context, result):
    print(f"Cancelling notification for order {context.get('order_id')}")
    context['notification_sent'] = False

async def test_saga_workflow():
    saga = SagaWorkflow()

# æ·»åŠ åŠ¨ä½œå’Œè¡¥å¿
    saga.add_action("reserve_inventory", reserve_inventory, compensate_inventory)
    saga.add_action("process_payment", process_payment, compensate_payment)
    saga.add_action("send_notification", send_notification, compensate_notification)

# æ‰§è¡Œå·¥ä½œæµ
    context = {"order_id": "order_123", "amount": 100}

    try:
        result = await saga.execute(context)
        print("Workflow completed successfully")
        print(f"Final context: {result}")
    except Exception as e:
        print(f"Workflow failed: {e}")

# è¿è¡Œæµ‹è¯•
asyncio.run(test_saga_workflow())
```

## 10. æœ€ä½³å®è·µ

### 10.1. å·¥ä½œæµè®¾è®¡åŸåˆ™

1. **å•ä¸€èŒè´£**ï¼šæ¯ä¸ªä»»åŠ¡ä¸“æ³¨äºç‰¹å®šåŠŸèƒ½
2. **æ¾è€¦åˆ**ï¼šä»»åŠ¡é—´å°½é‡å‡å°‘ä¾èµ–
3. **å¯æ‰©å±•æ€§**ï¼šæ”¯æŒåŠ¨æ€æ·»åŠ æ–°ä»»åŠ¡
4. **å¯è§‚æµ‹æ€§**ï¼šæä¾›è¯¦ç»†çš„æ‰§è¡ŒçŠ¶æ€

### 10.2. æ€§èƒ½ä¼˜åŒ–

1. **å¹¶è¡Œæ‰§è¡Œ**ï¼šåˆç†åˆ©ç”¨å¹¶è¡Œå¤„ç†èƒ½åŠ›
2. **ç¼“å­˜æœºåˆ¶**ï¼šç¼“å­˜é‡å¤è®¡ç®—ç»“æœ
3. **èµ„æºç®¡ç†**ï¼šåˆç†åˆ†é…å’Œé‡Šæ”¾èµ„æº
4. **ç›‘æ§å‘Šè­¦**ï¼šå®æ—¶ç›‘æ§å·¥ä½œæµçŠ¶æ€

### 10.3. é”™è¯¯å¤„ç†

1. **é‡è¯•æœºåˆ¶**ï¼šå¯¹ä¸´æ—¶é”™è¯¯è¿›è¡Œé‡è¯•
2. **è¡¥å¿æœºåˆ¶**ï¼šæä¾›å›æ»šèƒ½åŠ›
3. **è¶…æ—¶æ§åˆ¶**ï¼šè®¾ç½®åˆç†çš„è¶…æ—¶æ—¶é—´
4. **å¼‚å¸¸éš”ç¦»**ï¼šé˜²æ­¢å•ä¸ªé”™è¯¯å½±å“æ•´ä½“

### 10.4. å®‰å…¨è€ƒè™‘

1. **æƒé™æ§åˆ¶**ï¼šé™åˆ¶ä»»åŠ¡æ‰§è¡Œæƒé™
2. **æ•°æ®éªŒè¯**ï¼šéªŒè¯è¾“å…¥æ•°æ®æœ‰æ•ˆæ€§
3. **å®¡è®¡æ—¥å¿—**ï¼šè®°å½•æ‰€æœ‰æ“ä½œæ—¥å¿—
4. **æ•æ„Ÿä¿¡æ¯ä¿æŠ¤**ï¼šä¿æŠ¤æ•æ„Ÿæ•°æ®

## 11. æ€»ç»“

å·¥ä½œæµåŸºç¡€ç†è®ºä¸ºæ„å»ºå¤æ‚ä¸šåŠ¡æµç¨‹æä¾›äº†é‡è¦çš„ç†è®ºåŸºç¡€ã€‚é€šè¿‡çŠ¶æ€æœºã€ä»»åŠ¡ç¼–æ’ã€æµç¨‹å¼•æ“å’Œå¼‚å¸¸å¤„ç†ç­‰æœºåˆ¶ï¼Œå¯ä»¥æ„å»ºå‡ºå¯é ã€é«˜æ•ˆã€å¯ç»´æŠ¤çš„å·¥ä½œæµç³»ç»Ÿã€‚
