# çŸ¥è¯†å›¾è°±è‡ªåŠ¨åŒ–æµ‹è¯•

## ğŸ“‘ ç›®å½•

- [çŸ¥è¯†å›¾è°±è‡ªåŠ¨åŒ–æµ‹è¯•](#çŸ¥è¯†å›¾è°±è‡ªåŠ¨åŒ–æµ‹è¯•)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
- [1. æµ‹è¯•æ¡†æ¶æ¶æ„](#1-æµ‹è¯•æ¡†æ¶æ¶æ„)
  - [1.1. æ ¸å¿ƒæµ‹è¯•æ¡†æ¶](#11-æ ¸å¿ƒæµ‹è¯•æ¡†æ¶)
  - [1.2. æ•°æ®å®Œæ•´æ€§æµ‹è¯•](#12-æ•°æ®å®Œæ•´æ€§æµ‹è¯•)
- [2. æ€§èƒ½æµ‹è¯•](#2-æ€§èƒ½æµ‹è¯•)
- [3. APIæµ‹è¯•](#3-apiæµ‹è¯•)
- [4. æµ‹è¯•è¿è¡Œå™¨å’ŒæŠ¥å‘Š](#4-æµ‹è¯•è¿è¡Œå™¨å’ŒæŠ¥å‘Š)
- [5. æŒç»­é›†æˆæµ‹è¯•](#5-æŒç»­é›†æˆæµ‹è¯•)
  - [5.1. CI/CDé›†æˆé…ç½®](#51-cicdé›†æˆé…ç½®)
---


## 1. æµ‹è¯•æ¡†æ¶æ¶æ„

### 1.1. æ ¸å¿ƒæµ‹è¯•æ¡†æ¶

```python
import pytest
import unittest
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from abc import ABC, abstractmethod
import asyncio
import time
import logging
from pathlib import Path

@dataclass
class TestResult:
    """æµ‹è¯•ç»“æœæ•°æ®ç»“æ„"""
    test_name: str
    status: str  # PASS, FAIL, SKIP, ERROR
    duration: float
    message: Optional[str] = None
    error_type: Optional[str] = None
    traceback: Optional[str] = None

class BaseKGTest(ABC):
    """çŸ¥è¯†å›¾è°±æµ‹è¯•åŸºç±»"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.logger = logging.getLogger(self.__class__.__name__)
        
    @abstractmethod
    async def setup(self):
        """æµ‹è¯•å‰ç½®è®¾ç½®"""
        pass
    
    @abstractmethod
    async def teardown(self):
        """æµ‹è¯•åç½®æ¸…ç†"""
        pass
    
    @abstractmethod
    async def run_test(self) -> TestResult:
        """æ‰§è¡Œæµ‹è¯•"""
        pass

class KGTestSuite:
    """çŸ¥è¯†å›¾è°±æµ‹è¯•å¥—ä»¶"""
    
    def __init__(self, config_path: str):
        self.config = self._load_config(config_path)
        self.tests: List[BaseKGTest] = []
        self.results: List[TestResult] = []
        
    def add_test(self, test: BaseKGTest):
        """æ·»åŠ æµ‹è¯•"""
        self.tests.append(test)
        
    async def run_all(self) -> List[TestResult]:
        """è¿è¡Œæ‰€æœ‰æµ‹è¯•"""
        self.results = []
        
        for test in self.tests:
            try:
                await test.setup()
                result = await test.run_test()
                self.results.append(result)
            except Exception as e:
                self.results.append(TestResult(
                    test_name=test.__class__.__name__,
                    status="ERROR",
                    duration=0.0,
                    error_type=type(e).__name__,
                    message=str(e)
                ))
            finally:
                await test.teardown()
                
        return self.results
    
    def _load_config(self, config_path: str) -> Dict[str, Any]:
        """åŠ è½½æµ‹è¯•é…ç½®"""
        import json
        with open(config_path, 'r', encoding='utf-8') as f:
            return json.load(f)
```

### 1.2. æ•°æ®å®Œæ•´æ€§æµ‹è¯•

```python
class DataIntegrityTest(BaseKGTest):
    """æ•°æ®å®Œæ•´æ€§æµ‹è¯•"""
    
    def __init__(self, config: Dict[str, Any], kg_client):
        super().__init__(config)
        self.kg_client = kg_client
        
    async def setup(self):
        """è®¾ç½®æµ‹è¯•ç¯å¢ƒ"""
# åˆ›å»ºæµ‹è¯•æ•°æ®
        await self._create_test_data()
        
    async def teardown(self):
        """æ¸…ç†æµ‹è¯•æ•°æ®"""
        await self._cleanup_test_data()
        
    async def run_test(self) -> TestResult:
        """æ‰§è¡Œæ•°æ®å®Œæ•´æ€§æµ‹è¯•"""
        start_time = time.time()
        
        try:
# æµ‹è¯•èŠ‚ç‚¹å®Œæ•´æ€§
            await self._test_node_integrity()
            
# æµ‹è¯•å…³ç³»å®Œæ•´æ€§
            await self._test_relationship_integrity()
            
# æµ‹è¯•çº¦æŸæ£€æŸ¥
            await self._test_constraints()
            
# æµ‹è¯•æ•°æ®ç±»å‹
            await self._test_data_types()
            
            duration = time.time() - start_time
            return TestResult("DataIntegrityTest", "PASS", duration)
            
        except AssertionError as e:
            duration = time.time() - start_time
            return TestResult("DataIntegrityTest", "FAIL", duration, str(e))
            
    async def _test_node_integrity(self):
        """æµ‹è¯•èŠ‚ç‚¹å®Œæ•´æ€§"""
# æ£€æŸ¥å­¤ç«‹èŠ‚ç‚¹
        orphan_nodes = await self.kg_client.query("""
            MATCH (n)
            WHERE NOT (n)-[]-()
            RETURN count(n) as orphan_count
        """)
        
        assert orphan_nodes[0]['orphan_count'] == 0, "å‘ç°å­¤ç«‹èŠ‚ç‚¹"
        
# æ£€æŸ¥å¿…éœ€å±æ€§
        nodes_without_required = await self.kg_client.query("""
            MATCH (n)
            WHERE n.id IS NULL OR n.name IS NULL
            RETURN count(n) as invalid_count
        """)
        
        assert nodes_without_required[0]['invalid_count'] == 0, "å‘ç°ç¼ºå°‘å¿…éœ€å±æ€§çš„èŠ‚ç‚¹"
        
    async def _test_relationship_integrity(self):
        """æµ‹è¯•å…³ç³»å®Œæ•´æ€§"""
# æ£€æŸ¥å…³ç³»å®Œæ•´æ€§
        invalid_relationships = await self.kg_client.query("""
            MATCH (a)-[r]->(b)
            WHERE a.id IS NULL OR b.id IS NULL
            RETURN count(r) as invalid_count
        """)
        
        assert invalid_relationships[0]['invalid_count'] == 0, "å‘ç°æ— æ•ˆå…³ç³»"
        
    async def _test_constraints(self):
        """æµ‹è¯•çº¦æŸ"""
# æ£€æŸ¥å”¯ä¸€æ€§çº¦æŸ
        duplicate_ids = await self.kg_client.query("""
            MATCH (n)
            WITH n.id as id, count(n) as node_count
            WHERE node_count > 1
            RETURN count(id) as duplicate_count
        """)
        
        assert duplicate_ids[0]['duplicate_count'] == 0, "å‘ç°é‡å¤ID"
        
    async def _test_data_types(self):
        """æµ‹è¯•æ•°æ®ç±»å‹"""
# æ£€æŸ¥æ•°æ®ç±»å‹ä¸€è‡´æ€§
        invalid_types = await self.kg_client.query("""
            MATCH (n)
            WHERE n.created_at IS NOT NULL 
            AND toString(n.created_at) !~ '^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.*'
            RETURN count(n) as invalid_count
        """)
        
        assert invalid_types[0]['invalid_count'] == 0, "å‘ç°æ— æ•ˆçš„æ—¶é—´æ ¼å¼"
```

## 2. æ€§èƒ½æµ‹è¯•

```python
class PerformanceTest(BaseKGTest):
    """æ€§èƒ½æµ‹è¯•"""
    
    def __init__(self, config: Dict[str, Any], kg_client):
        super().__init__(config)
        self.kg_client = kg_client
        self.performance_thresholds = config.get('performance_thresholds', {})
        
    async def setup(self):
        """è®¾ç½®æ€§èƒ½æµ‹è¯•ç¯å¢ƒ"""
        await self._create_performance_test_data()
        
    async def teardown(self):
        """æ¸…ç†æ€§èƒ½æµ‹è¯•æ•°æ®"""
        await self._cleanup_performance_test_data()
        
    async def run_test(self) -> TestResult:
        """æ‰§è¡Œæ€§èƒ½æµ‹è¯•"""
        start_time = time.time()
        
        try:
# æŸ¥è¯¢æ€§èƒ½æµ‹è¯•
            await self._test_query_performance()
            
# å†™å…¥æ€§èƒ½æµ‹è¯•
            await self._test_write_performance()
            
# å¹¶å‘æ€§èƒ½æµ‹è¯•
            await self._test_concurrent_performance()
            
# å†…å­˜ä½¿ç”¨æµ‹è¯•
            await self._test_memory_usage()
            
            duration = time.time() - start_time
            return TestResult("PerformanceTest", "PASS", duration)
            
        except AssertionError as e:
            duration = time.time() - start_time
            return TestResult("PerformanceTest", "FAIL", duration, str(e))
            
    async def _test_query_performance(self):
        """æµ‹è¯•æŸ¥è¯¢æ€§èƒ½"""
        queries = [
            ("ç®€å•æŸ¥è¯¢", "MATCH (n:Person) RETURN count(n)"),
            ("å¤æ‚è¿æ¥", "MATCH (p:Person)-[:KNOWS*2..3]-(f:Person) RETURN count(f)"),
            ("èšåˆæŸ¥è¯¢", "MATCH (p:Person)-[:WORKS_FOR]->(c:Company) WITH c, count(p) as emp_count RETURN c.name, emp_count ORDER BY emp_count DESC LIMIT 10")
        ]
        
        for query_name, query in queries:
            start = time.time()
            result = await self.kg_client.query(query)
            duration = time.time() - start
            
            threshold = self.performance_thresholds.get(query_name, 1.0)
            assert duration < threshold, f"{query_name}æŸ¥è¯¢è¶…æ—¶: {duration}s > {threshold}s"
            
    async def _test_write_performance(self):
        """æµ‹è¯•å†™å…¥æ€§èƒ½"""
# æ‰¹é‡åˆ›å»ºèŠ‚ç‚¹
        start = time.time()
        nodes_data = [{"id": f"perf_test_{i}", "name": f"Test Node {i}"} for i in range(1000)]
        
        for node_data in nodes_data:
            await self.kg_client.create_node("TestNode", node_data)
            
        duration = time.time() - start
        threshold = self.performance_thresholds.get('batch_write', 5.0)
        assert duration < threshold, f"æ‰¹é‡å†™å…¥è¶…æ—¶: {duration}s > {threshold}s"
        
    async def _test_concurrent_performance(self):
        """æµ‹è¯•å¹¶å‘æ€§èƒ½"""
        async def concurrent_query():
            return await self.kg_client.query("MATCH (n:Person) RETURN count(n)")
            
        start = time.time()
        tasks = [concurrent_query() for _ in range(10)]
        results = await asyncio.gather(*tasks)
        duration = time.time() - start
        
        threshold = self.performance_thresholds.get('concurrent_queries', 2.0)
        assert duration < threshold, f"å¹¶å‘æŸ¥è¯¢è¶…æ—¶: {duration}s > {threshold}s"
        
    async def _test_memory_usage(self):
        """æµ‹è¯•å†…å­˜ä½¿ç”¨"""
        import psutil
        import os
        
        process = psutil.Process(os.getpid())
        
# æ‰§è¡Œå¤§æŸ¥è¯¢å‰çš„å†…å­˜
        memory_before = process.memory_info().rss / 1024 / 1024  # MB
        
# æ‰§è¡Œå¤§æŸ¥è¯¢
        await self.kg_client.query("""
            MATCH (n)-[r*1..3]-(m)
            RETURN n, r, m
            LIMIT 10000
        """)
        
# æ‰§è¡Œå¤§æŸ¥è¯¢åçš„å†…å­˜
        memory_after = process.memory_info().rss / 1024 / 1024  # MB
        memory_increase = memory_after - memory_before
        
        threshold = self.performance_thresholds.get('memory_increase', 100)  # MB
        assert memory_increase < threshold, f"å†…å­˜å¢é•¿è¿‡å¤§: {memory_increase}MB > {threshold}MB"
```

## 3. APIæµ‹è¯•

```python
class APITest(BaseKGTest):
    """APIæ¥å£æµ‹è¯•"""
    
    def __init__(self, config: Dict[str, Any]):
        super().__init__(config)
        self.api_base_url = config.get('api_base_url', 'http://localhost:8000')
        
    async def setup(self):
        """è®¾ç½®APIæµ‹è¯•ç¯å¢ƒ"""
        import aiohttp
        self.session = aiohttp.ClientSession()
        
    async def teardown(self):
        """æ¸…ç†APIæµ‹è¯•ç¯å¢ƒ"""
        await self.session.close()
        
    async def run_test(self) -> TestResult:
        """æ‰§è¡ŒAPIæµ‹è¯•"""
        start_time = time.time()
        
        try:
# æµ‹è¯•åŸºæœ¬API
            await self._test_basic_api()
            
# æµ‹è¯•è®¤è¯
            await self._test_authentication()
            
# æµ‹è¯•CRUDæ“ä½œ
            await self._test_crud_operations()
            
# æµ‹è¯•é”™è¯¯å¤„ç†
            await self._test_error_handling()
            
# æµ‹è¯•GraphQL API
            await self._test_graphql_api()
            
            duration = time.time() - start_time
            return TestResult("APITest", "PASS", duration)
            
        except AssertionError as e:
            duration = time.time() - start_time
            return TestResult("APITest", "FAIL", duration, str(e))
            
    async def _test_basic_api(self):
        """æµ‹è¯•åŸºæœ¬API"""
# å¥åº·æ£€æŸ¥
        async with self.session.get(f"{self.api_base_url}/health") as response:
            assert response.status == 200, "å¥åº·æ£€æŸ¥å¤±è´¥"
            data = await response.json()
            assert data['status'] == 'healthy', "æœåŠ¡çŠ¶æ€å¼‚å¸¸"
            
# ç‰ˆæœ¬ä¿¡æ¯
        async with self.session.get(f"{self.api_base_url}/version") as response:
            assert response.status == 200, "ç‰ˆæœ¬ä¿¡æ¯è·å–å¤±è´¥"
            
    async def _test_authentication(self):
        """æµ‹è¯•è®¤è¯"""
# ç™»å½•
        login_data = {
            "username": "test_user",
            "password": "test_password"
        }
        
        async with self.session.post(f"{self.api_base_url}/auth/login", json=login_data) as response:
            assert response.status == 200, "ç™»å½•å¤±è´¥"
            data = await response.json()
            assert 'access_token' in data, "æœªè¿”å›è®¿é—®ä»¤ç‰Œ"
            
            self.access_token = data['access_token']
            
# éªŒè¯ä»¤ç‰Œ
        headers = {"Authorization": f"Bearer {self.access_token}"}
        async with self.session.get(f"{self.api_base_url}/auth/verify", headers=headers) as response:
            assert response.status == 200, "ä»¤ç‰ŒéªŒè¯å¤±è´¥"
            
    async def _test_crud_operations(self):
        """æµ‹è¯•CRUDæ“ä½œ"""
        headers = {"Authorization": f"Bearer {self.access_token}"}
        
# åˆ›å»ºèŠ‚ç‚¹
        node_data = {
            "label": "TestPerson",
            "properties": {
                "name": "API Test User",
                "email": "api.test@example.com"
            }
        }
        
        async with self.session.post(f"{self.api_base_url}/nodes", json=node_data, headers=headers) as response:
            assert response.status == 201, "èŠ‚ç‚¹åˆ›å»ºå¤±è´¥"
            data = await response.json()
            node_id = data['id']
            
# è¯»å–èŠ‚ç‚¹
        async with self.session.get(f"{self.api_base_url}/nodes/{node_id}", headers=headers) as response:
            assert response.status == 200, "èŠ‚ç‚¹è¯»å–å¤±è´¥"
            data = await response.json()
            assert data['properties']['name'] == "API Test User", "èŠ‚ç‚¹æ•°æ®ä¸ä¸€è‡´"
            
# æ›´æ–°èŠ‚ç‚¹
        update_data = {
            "properties": {
                "name": "Updated API Test User"
            }
        }
        
        async with self.session.put(f"{self.api_base_url}/nodes/{node_id}", json=update_data, headers=headers) as response:
            assert response.status == 200, "èŠ‚ç‚¹æ›´æ–°å¤±è´¥"
            
# åˆ é™¤èŠ‚ç‚¹
        async with self.session.delete(f"{self.api_base_url}/nodes/{node_id}", headers=headers) as response:
            assert response.status == 204, "èŠ‚ç‚¹åˆ é™¤å¤±è´¥"
            
    async def _test_error_handling(self):
        """æµ‹è¯•é”™è¯¯å¤„ç†"""
        headers = {"Authorization": f"Bearer {self.access_token}"}
        
# è®¿é—®ä¸å­˜åœ¨çš„èŠ‚ç‚¹
        async with self.session.get(f"{self.api_base_url}/nodes/nonexistent", headers=headers) as response:
            assert response.status == 404, "åº”è¯¥è¿”å›404é”™è¯¯"
            
# æ— æ•ˆçš„è¯·æ±‚æ•°æ®
        invalid_data = {"invalid": "data"}
        async with self.session.post(f"{self.api_base_url}/nodes", json=invalid_data, headers=headers) as response:
            assert response.status == 400, "åº”è¯¥è¿”å›400é”™è¯¯"
            
    async def _test_graphql_api(self):
        """æµ‹è¯•GraphQL API"""
        headers = {"Authorization": f"Bearer {self.access_token}"}
        
        query = """
        query {
            nodes(first: 10) {
                edges {
                    node {
                        id
                        label
                        properties
                    }
                }
            }
        }
        """
        
        async with self.session.post(f"{self.api_base_url}/graphql", json={"query": query}, headers=headers) as response:
            assert response.status == 200, "GraphQLæŸ¥è¯¢å¤±è´¥"
            data = await response.json()
            assert 'data' in data, "GraphQLå“åº”æ ¼å¼é”™è¯¯"
```

## 4. æµ‹è¯•è¿è¡Œå™¨å’ŒæŠ¥å‘Š

```python
class TestRunner:
    """æµ‹è¯•è¿è¡Œå™¨"""
    
    def __init__(self, config_path: str):
        self.config_path = config_path
        self.test_suite = KGTestSuite(config_path)
        self.logger = logging.getLogger(__name__)
        
    async def run_tests(self) -> Dict[str, Any]:
        """è¿è¡Œæ‰€æœ‰æµ‹è¯•"""
        self.logger.info("å¼€å§‹è¿è¡ŒçŸ¥è¯†å›¾è°±æµ‹è¯•å¥—ä»¶")
        
        start_time = time.time()
        results = await self.test_suite.run_all()
        total_duration = time.time() - start_time
        
# ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š
        report = self._generate_report(results, total_duration)
        
# ä¿å­˜æŠ¥å‘Š
        await self._save_report(report)
        
        self.logger.info(f"æµ‹è¯•å®Œæˆï¼Œæ€»è€—æ—¶: {total_duration:.2f}ç§’")
        return report
        
    def _generate_report(self, results: List[TestResult], total_duration: float) -> Dict[str, Any]:
        """ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š"""
        total_tests = len(results)
        passed_tests = len([r for r in results if r.status == "PASS"])
        failed_tests = len([r for r in results if r.status == "FAIL"])
        error_tests = len([r for r in results if r.status == "ERROR"])
        skipped_tests = len([r for r in results if r.status == "SKIP"])
        
        return {
            "summary": {
                "total_tests": total_tests,
                "passed": passed_tests,
                "failed": failed_tests,
                "errors": error_tests,
                "skipped": skipped_tests,
                "success_rate": (passed_tests / total_tests * 100) if total_tests > 0 else 0,
                "total_duration": total_duration
            },
            "results": [
                {
                    "test_name": r.test_name,
                    "status": r.status,
                    "duration": r.duration,
                    "message": r.message,
                    "error_type": r.error_type
                }
                for r in results
            ],
            "timestamp": time.strftime("%Y-%m-%d %H:%M:%S")
        }
        
    async def _save_report(self, report: Dict[str, Any]):
        """ä¿å­˜æµ‹è¯•æŠ¥å‘Š"""
        import json
        from datetime import datetime
        
# JSONæŠ¥å‘Š
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        json_file = f"test_report_{timestamp}.json"
        
        with open(json_file, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
            
# HTMLæŠ¥å‘Š
        html_content = self._generate_html_report(report)
        html_file = f"test_report_{timestamp}.html"
        
        with open(html_file, 'w', encoding='utf-8') as f:
            f.write(html_content)
            
        self.logger.info(f"æµ‹è¯•æŠ¥å‘Šå·²ä¿å­˜: {json_file}, {html_file}")
        
    def _generate_html_report(self, report: Dict[str, Any]) -> str:
        """ç”ŸæˆHTMLæµ‹è¯•æŠ¥å‘Š"""
        summary = report['summary']
        results = report['results']
        
        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>çŸ¥è¯†å›¾è°±æµ‹è¯•æŠ¥å‘Š</title>
            <meta charset="utf-8">
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                .header {{ background-color: #f8f9fa; padding: 20px; border-radius: 5px; }}
                .summary {{ display: flex; gap: 20px; margin: 20px 0; }}
                .metric {{ background-color: #e9ecef; padding: 15px; border-radius: 5px; text-align: center; }}
                .metric h3 {{ margin: 0; color: #495057; }}
                .metric .value {{ font-size: 24px; font-weight: bold; margin: 5px 0; }}
                .passed {{ color: #28a745; }}
                .failed {{ color: #dc3545; }}
                .error {{ color: #fd7e14; }}
                .skipped {{ color: #6c757d; }}
                table {{ width: 100%; border-collapse: collapse; margin: 20px 0; }}
                th, td {{ padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }}
                th {{ background-color: #f8f9fa; }}
                .status-pass {{ color: #28a745; font-weight: bold; }}
                .status-fail {{ color: #dc3545; font-weight: bold; }}
                .status-error {{ color: #fd7e14; font-weight: bold; }}
                .status-skip {{ color: #6c757d; font-weight: bold; }}
            </style>
        </head>
        <body>
            <div class="header">
                <h1>çŸ¥è¯†å›¾è°±æµ‹è¯•æŠ¥å‘Š</h1>
                <p>ç”Ÿæˆæ—¶é—´: {report['timestamp']}</p>
            </div>
            
            <div class="summary">
                <div class="metric">
                    <h3>æ€»æµ‹è¯•æ•°</h3>
                    <div class="value">{summary['total_tests']}</div>
                </div>
                <div class="metric">
                    <h3>é€šè¿‡</h3>
                    <div class="value passed">{summary['passed']}</div>
                </div>
                <div class="metric">
                    <h3>å¤±è´¥</h3>
                    <div class="value failed">{summary['failed']}</div>
                </div>
                <div class="metric">
                    <h3>é”™è¯¯</h3>
                    <div class="value error">{summary['errors']}</div>
                </div>
                <div class="metric">
                    <h3>è·³è¿‡</h3>
                    <div class="value skipped">{summary['skipped']}</div>
                </div>
                <div class="metric">
                    <h3>æˆåŠŸç‡</h3>
                    <div class="value">{summary['success_rate']:.1f}%</div>
                </div>
                <div class="metric">
                    <h3>æ€»è€—æ—¶</h3>
                    <div class="value">{summary['total_duration']:.2f}s</div>
                </div>
            </div>
            
            <h2>è¯¦ç»†ç»“æœ</h2>
            <table>
                <thead>
                    <tr>
                        <th>æµ‹è¯•åç§°</th>
                        <th>çŠ¶æ€</th>
                        <th>è€—æ—¶</th>
                        <th>æ¶ˆæ¯</th>
                    </tr>
                </thead>
                <tbody>
        """
        
        for result in results:
            status_class = f"status-{result['status'].lower()}"
            message = result['message'] or ''
            html += f"""
                    <tr>
                        <td>{result['test_name']}</td>
                        <td class="{status_class}">{result['status']}</td>
                        <td>{result['duration']:.3f}s</td>
                        <td>{message}</td>
                    </tr>
            """
            
        html += """
                </tbody>
            </table>
        </body>
        </html>
        """
        
        return html

# æµ‹è¯•é…ç½®ç¤ºä¾‹
TEST_CONFIG = {
    "neo4j": {
        "uri": "bolt://localhost:7687",
        "username": "neo4j",
        "password": "password"
    },
    "api_base_url": "http://localhost:8000",
    "performance_thresholds": {
        "ç®€å•æŸ¥è¯¢": 0.5,
        "å¤æ‚è¿æ¥": 2.0,
        "èšåˆæŸ¥è¯¢": 1.0,
        "batch_write": 5.0,
        "concurrent_queries": 2.0,
        "memory_increase": 100
    },
    "test_data": {
        "node_count": 1000,
        "relationship_count": 5000
    }
}

# ä¸»æ‰§è¡Œå…¥å£
async def main():
    """ä¸»æ‰§è¡Œå…¥å£"""
# é…ç½®æ—¥å¿—
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
# è¿è¡Œæµ‹è¯•
    runner = TestRunner("test_config.json")
    
# æ·»åŠ æµ‹è¯•
    from neo4j import AsyncGraphDatabase
    
    driver = AsyncGraphDatabase.driver("bolt://localhost:7687", auth=("neo4j", "password"))
    kg_client = KnowledgeGraphClient(driver)
    
    runner.test_suite.add_test(DataIntegrityTest(TEST_CONFIG, kg_client))
    runner.test_suite.add_test(PerformanceTest(TEST_CONFIG, kg_client))
    runner.test_suite.add_test(APITest(TEST_CONFIG))
    
# è¿è¡Œæµ‹è¯•å¹¶ç”ŸæˆæŠ¥å‘Š
    report = await runner.run_tests()
    
    print(f"æµ‹è¯•å®Œæˆï¼æˆåŠŸç‡: {report['summary']['success_rate']:.1f}%")
    
    await driver.close()

if __name__ == "__main__":
    asyncio.run(main())
```

## 5. æŒç»­é›†æˆæµ‹è¯•

### 5.1. CI/CDé›†æˆé…ç½®

```yaml
# .github/workflows/kg-tests.yml
name: Knowledge Graph Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      neo4j:
        image: neo4j:5.0
        env:
          NEO4J_AUTH: neo4j/test_password
          NEO4J_dbms_security_procedures_unrestricted: gds.*
        ports:
          - 7687:7687
          - 7474:7474
      
      redis:
        image: redis:7
        ports:
          - 6379:6379
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
    
    - name: Install dependencies
      run: |
        pip install -r requirements.txt
        pip install pytest pytest-asyncio pytest-cov
    
    - name: Wait for Neo4j
      run: |
        timeout 60 bash -c 'until nc -z localhost 7687; do sleep 1; done'
    
    - name: Run tests
      run: |
        pytest tests/ -v --cov=kg_system --cov-report=xml
    
    - name: Upload coverage
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml
        fail_ci_if_error: true
```

è¿™ä¸ªè‡ªåŠ¨åŒ–æµ‹è¯•ç³»ç»Ÿæä¾›äº†ï¼š

1. **å®Œæ•´çš„æµ‹è¯•æ¡†æ¶** - æ”¯æŒå¼‚æ­¥æµ‹è¯•å’Œæ¨¡å—åŒ–è®¾è®¡
2. **æ•°æ®å®Œæ•´æ€§æµ‹è¯•** - éªŒè¯æ•°æ®è´¨é‡å’Œçº¦æŸ
3. **æ€§èƒ½æµ‹è¯•** - ç›‘æ§æŸ¥è¯¢å’Œå†™å…¥æ€§èƒ½
4. **APIæµ‹è¯•** - å®Œæ•´çš„æ¥å£åŠŸèƒ½éªŒè¯
5. **è¯¦ç»†çš„æµ‹è¯•æŠ¥å‘Š** - JSONå’ŒHTMLæ ¼å¼çš„æµ‹è¯•ç»“æœ
6. **CI/CDé›†æˆ** - è‡ªåŠ¨åŒ–æµ‹è¯•æµç¨‹

ç³»ç»Ÿç¡®ä¿äº†çŸ¥è¯†å›¾è°±çš„è´¨é‡ã€æ€§èƒ½å’Œå¯é æ€§ã€‚
