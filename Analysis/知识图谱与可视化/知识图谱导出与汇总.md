# çŸ¥è¯†å›¾è°±å¯¼å‡ºä¸æ±‡æ€»

## ğŸ“‘ ç›®å½•

- [çŸ¥è¯†å›¾è°±å¯¼å‡ºä¸æ±‡æ€»](#çŸ¥è¯†å›¾è°±å¯¼å‡ºä¸æ±‡æ€»)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
- [1. çŸ¥è¯†å›¾è°±æ„å»ºæ¡†æ¶](#1-çŸ¥è¯†å›¾è°±æ„å»ºæ¡†æ¶)
  - [1.1. çŸ¥è¯†å›¾è°±æ•°æ®ç»“æ„](#11-çŸ¥è¯†å›¾è°±æ•°æ®ç»“æ„)
- [2. çŸ¥è¯†å›¾è°±æ„å»ºå™¨](#2-çŸ¥è¯†å›¾è°±æ„å»ºå™¨)
- [3. çŸ¥è¯†å›¾è°±å¯¼å‡ºå·¥å…·](#3-çŸ¥è¯†å›¾è°±å¯¼å‡ºå·¥å…·)
  - [3.1. å¤šæ ¼å¼å¯¼å‡ºå™¨](#31-å¤šæ ¼å¼å¯¼å‡ºå™¨)
- [4. æ‰¹é‡å¯¼å‡ºå·¥å…·](#4-æ‰¹é‡å¯¼å‡ºå·¥å…·)
- [5. çŸ¥è¯†å›¾è°±å¯è§†åŒ–](#5-çŸ¥è¯†å›¾è°±å¯è§†åŒ–)
  - [5.1. äº¤äº’å¼å¯è§†åŒ–](#51-äº¤äº’å¼å¯è§†åŒ–)
- [6. Då¯è§†åŒ–](#6-då¯è§†åŒ–)
- [7. çŸ¥è¯†å›¾è°±æ±‡æ€»åˆ†æ](#7-çŸ¥è¯†å›¾è°±æ±‡æ€»åˆ†æ)
  - [7.1. ç»Ÿè®¡åˆ†æå·¥å…·](#71-ç»Ÿè®¡åˆ†æå·¥å…·)
- [8. æ±‡æ€»æŠ¥å‘Šç”Ÿæˆå™¨](#8-æ±‡æ€»æŠ¥å‘Šç”Ÿæˆå™¨)
- [9. å·¥å…·ä¸å¹³å°](#9-å·¥å…·ä¸å¹³å°)
  - [9.1. çŸ¥è¯†å›¾è°±å·¥å…·](#91-çŸ¥è¯†å›¾è°±å·¥å…·)
  - [9.2. å¯è§†åŒ–å·¥å…·](#92-å¯è§†åŒ–å·¥å…·)
  - [9.3. å¯¼å‡ºå·¥å…·](#93-å¯¼å‡ºå·¥å…·)
- [10. æœ€ä½³å®è·µ](#10-æœ€ä½³å®è·µ)
  - [10.1. çŸ¥è¯†å›¾è°±æ„å»º](#101-çŸ¥è¯†å›¾è°±æ„å»º)
  - [10.2. å¯è§†åŒ–è®¾è®¡](#102-å¯è§†åŒ–è®¾è®¡)
  - [10.3. å¯¼å‡ºå’Œæ±‡æ€»](#103-å¯¼å‡ºå’Œæ±‡æ€»)
---


## 1. çŸ¥è¯†å›¾è°±æ„å»ºæ¡†æ¶

### 1.1. çŸ¥è¯†å›¾è°±æ•°æ®ç»“æ„

```python
# çŸ¥è¯†å›¾è°±æ ¸å¿ƒæ•°æ®ç»“æ„
import networkx as nx
import pandas as pd
import json
from typing import Dict, List, Set, Tuple, Optional
from dataclasses import dataclass
import matplotlib.pyplot as plt
import seaborn as sns

@dataclass
class KnowledgeGraph:
    """çŸ¥è¯†å›¾è°±æ ¸å¿ƒç±»"""
    nodes: Dict[str, Dict]  # èŠ‚ç‚¹ID -> èŠ‚ç‚¹å±æ€§
    edges: List[Tuple[str, str, str]]  # (æºèŠ‚ç‚¹, å…³ç³», ç›®æ ‡èŠ‚ç‚¹)
    node_types: Set[str]  # èŠ‚ç‚¹ç±»å‹é›†åˆ
    edge_types: Set[str]  # å…³ç³»ç±»å‹é›†åˆ

    def __init__(self):
        self.nodes = {}
        self.edges = []
        self.node_types = set()
        self.edge_types = set()

    def add_node(self, node_id: str, node_type: str, properties: Dict = None):
        """æ·»åŠ èŠ‚ç‚¹"""
        if properties is None:
            properties = {}

        self.nodes[node_id] = {
            'type': node_type,
            'properties': properties
        }
        self.node_types.add(node_type)

    def add_edge(self, source: str, relation: str, target: str, properties: Dict = None):
        """æ·»åŠ è¾¹"""
        if properties is None:
            properties = {}

        self.edges.append((source, relation, target, properties))
        self.edge_types.add(relation)

    def get_neighbors(self, node_id: str) -> List[Tuple[str, str]]:
        """è·å–é‚»å±…èŠ‚ç‚¹"""
        neighbors = []
        for source, relation, target, _ in self.edges:
            if source == node_id:
                neighbors.append((target, relation))
            elif target == node_id:
                neighbors.append((source, relation))
        return neighbors

    def get_nodes_by_type(self, node_type: str) -> List[str]:
        """æ ¹æ®ç±»å‹è·å–èŠ‚ç‚¹"""
        return [node_id for node_id, node_data in self.nodes.items()
                if node_data['type'] == node_type]

    def get_edges_by_relation(self, relation: str) -> List[Tuple[str, str]]:
        """æ ¹æ®å…³ç³»ç±»å‹è·å–è¾¹"""
        return [(source, target) for source, rel, target, _ in self.edges
                if rel == relation]

    def to_networkx(self) -> nx.DiGraph:
        """è½¬æ¢ä¸ºNetworkXå›¾"""
        G = nx.DiGraph()

# æ·»åŠ èŠ‚ç‚¹
        for node_id, node_data in self.nodes.items():
            G.add_node(node_id, **node_data)

# æ·»åŠ è¾¹
        for source, relation, target, properties in self.edges:
            G.add_edge(source, target, relation=relation, **properties)

        return G

    def to_dataframe(self) -> Tuple[pd.DataFrame, pd.DataFrame]:
        """è½¬æ¢ä¸ºDataFrameæ ¼å¼"""
# èŠ‚ç‚¹DataFrame
        nodes_data = []
        for node_id, node_data in self.nodes.items():
            row = {'node_id': node_id, 'type': node_data['type']}
            row.update(node_data['properties'])
            nodes_data.append(row)

        nodes_df = pd.DataFrame(nodes_data)

# è¾¹DataFrame
        edges_data = []
        for source, relation, target, properties in self.edges:
            row = {'source': source, 'relation': relation, 'target': target}
            row.update(properties)
            edges_data.append(row)

        edges_df = pd.DataFrame(edges_data)

        return nodes_df, edges_df

    def export_to_json(self, filepath: str):
        """å¯¼å‡ºä¸ºJSONæ ¼å¼"""
        data = {
            'nodes': self.nodes,
            'edges': self.edges,
            'node_types': list(self.node_types),
            'edge_types': list(self.edge_types)
        }

        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)

    def import_from_json(self, filepath: str):
        """ä»JSONå¯¼å…¥"""
        with open(filepath, 'r', encoding='utf-8') as f:
            data = json.load(f)

        self.nodes = data['nodes']
        self.edges = data['edges']
        self.node_types = set(data['node_types'])
        self.edge_types = set(data['edge_types'])
```

## 2. çŸ¥è¯†å›¾è°±æ„å»ºå™¨

```python
# çŸ¥è¯†å›¾è°±æ„å»ºå™¨
class KnowledgeGraphBuilder:
    """çŸ¥è¯†å›¾è°±æ„å»ºå™¨"""

    def __init__(self):
        self.graph = KnowledgeGraph()

    def build_from_text(self, text: str, entity_extractor, relation_extractor):
        """ä»æ–‡æœ¬æ„å»ºçŸ¥è¯†å›¾è°±"""
# å®ä½“è¯†åˆ«
        entities = entity_extractor.extract(text)

# æ·»åŠ å®ä½“èŠ‚ç‚¹
        for entity in entities:
            self.graph.add_node(
                entity['id'],
                entity['type'],
                entity['properties']
            )

# å…³ç³»æŠ½å–
        relations = relation_extractor.extract(text, entities)

# æ·»åŠ å…³ç³»è¾¹
        for relation in relations:
            self.graph.add_edge(
                relation['source'],
                relation['relation'],
                relation['target'],
                relation['properties']
            )

    def build_from_dataframe(self, nodes_df: pd.DataFrame, edges_df: pd.DataFrame):
        """ä»DataFrameæ„å»ºçŸ¥è¯†å›¾è°±"""
# æ·»åŠ èŠ‚ç‚¹
        for _, row in nodes_df.iterrows():
            properties = row.to_dict()
            node_id = properties.pop('node_id')
            node_type = properties.pop('type')
            self.graph.add_node(node_id, node_type, properties)

# æ·»åŠ è¾¹
        for _, row in edges_df.iterrows():
            properties = row.to_dict()
            source = properties.pop('source')
            relation = properties.pop('relation')
            target = properties.pop('target')
            self.graph.add_edge(source, relation, target, properties)

    def merge_graphs(self, other_graph: KnowledgeGraph):
        """åˆå¹¶çŸ¥è¯†å›¾è°±"""
# åˆå¹¶èŠ‚ç‚¹
        for node_id, node_data in other_graph.nodes.items():
            if node_id not in self.graph.nodes:
                self.graph.add_node(node_id, node_data['type'], node_data['properties'])

# åˆå¹¶è¾¹
        for edge in other_graph.edges:
            source, relation, target, properties = edge
            self.graph.add_edge(source, relation, target, properties)

    def filter_by_type(self, node_types: Set[str] = None, edge_types: Set[str] = None) -> KnowledgeGraph:
        """æ ¹æ®ç±»å‹è¿‡æ»¤çŸ¥è¯†å›¾è°±"""
        filtered_graph = KnowledgeGraph()

# è¿‡æ»¤èŠ‚ç‚¹
        for node_id, node_data in self.graph.nodes.items():
            if node_types is None or node_data['type'] in node_types:
                filtered_graph.add_node(node_id, node_data['type'], node_data['properties'])

# è¿‡æ»¤è¾¹
        for source, relation, target, properties in self.graph.edges:
            if (edge_types is None or relation in edge_types) and \
               source in filtered_graph.nodes and target in filtered_graph.nodes:
                filtered_graph.add_edge(source, relation, target, properties)

        return filtered_graph
```

## 3. çŸ¥è¯†å›¾è°±å¯¼å‡ºå·¥å…·

### 3.1. å¤šæ ¼å¼å¯¼å‡ºå™¨

```python
# çŸ¥è¯†å›¾è°±å¯¼å‡ºå™¨
class KnowledgeGraphExporter:
    """çŸ¥è¯†å›¾è°±å¯¼å‡ºå™¨"""

    def __init__(self, graph: KnowledgeGraph):
        self.graph = graph

    def export_to_cypher(self, filepath: str):
        """å¯¼å‡ºä¸ºCypheræŸ¥è¯¢è¯­è¨€"""
        with open(filepath, 'w', encoding='utf-8') as f:
# åˆ›å»ºèŠ‚ç‚¹
            for node_id, node_data in self.graph.nodes.items():
                properties_str = ', '.join([f'{k}: "{v}"' for k, v in node_data['properties'].items()])
                f.write(f'CREATE ({node_id}:{node_data["type"]} {{{properties_str}}})\n')

# åˆ›å»ºå…³ç³»
            for source, relation, target, properties in self.graph.edges:
                properties_str = ', '.join([f'{k}: "{v}"' for k, v in properties.items()])
                if properties_str:
                    f.write(f'CREATE ({source})-[:{relation} {{{properties_str}}}]->({target})\n')
                else:
                    f.write(f'CREATE ({source})-[:{relation}]->({target})\n')

    def export_to_gml(self, filepath: str):
        """å¯¼å‡ºä¸ºGMLæ ¼å¼"""
        G = self.graph.to_networkx()
        nx.write_gml(G, filepath)

    def export_to_graphml(self, filepath: str):
        """å¯¼å‡ºä¸ºGraphMLæ ¼å¼"""
        G = self.graph.to_networkx()
        nx.write_graphml(G, filepath)

    def export_to_csv(self, nodes_filepath: str, edges_filepath: str):
        """å¯¼å‡ºä¸ºCSVæ ¼å¼"""
        nodes_df, edges_df = self.graph.to_dataframe()
        nodes_df.to_csv(nodes_filepath, index=False, encoding='utf-8')
        edges_df.to_csv(edges_filepath, index=False, encoding='utf-8')

    def export_to_rdf(self, filepath: str):
        """å¯¼å‡ºä¸ºRDFæ ¼å¼"""
        from rdflib import Graph, Namespace, Literal, URIRef

        g = Graph()
        ns = Namespace("http://example.org/")

# æ·»åŠ èŠ‚ç‚¹
        for node_id, node_data in self.graph.nodes.items():
            node_uri = URIRef(ns[node_id])
            g.add((node_uri, ns.type, Literal(node_data['type'])))

            for prop, value in node_data['properties'].items():
                g.add((node_uri, ns[prop], Literal(value)))

# æ·»åŠ å…³ç³»
        for source, relation, target, properties in self.graph.edges:
            source_uri = URIRef(ns[source])
            target_uri = URIRef(ns[target])
            relation_uri = URIRef(ns[relation])

            g.add((source_uri, relation_uri, target_uri))

            for prop, value in properties.items():
                g.add((source_uri, ns[prop], Literal(value)))

        g.serialize(filepath, format='xml')

    def export_to_neo4j(self, uri: str, username: str, password: str):
        """å¯¼å‡ºåˆ°Neo4jæ•°æ®åº“"""
        from neo4j import GraphDatabase

        driver = GraphDatabase.driver(uri, auth=(username, password))

        with driver.session() as session:
# åˆ›å»ºèŠ‚ç‚¹
            for node_id, node_data in self.graph.nodes.items():
                properties_str = ', '.join([f'{k}: "{v}"' for k, v in node_data['properties'].items()])
                query = f'CREATE ({node_id}:{node_data["type"]} {{{properties_str}}})'
                session.run(query)

# åˆ›å»ºå…³ç³»
            for source, relation, target, properties in self.graph.edges:
                properties_str = ', '.join([f'{k}: "{v}"' for k, v in properties.items()])
                if properties_str:
                    query = f'CREATE ({source})-[:{relation} {{{properties_str}}}]->({target})'
                else:
                    query = f'CREATE ({source})-[:{relation}]->({target})'
                session.run(query)

        driver.close()
```

## 4. æ‰¹é‡å¯¼å‡ºå·¥å…·

```python
# æ‰¹é‡å¯¼å‡ºå·¥å…·
class BatchExporter:
    """æ‰¹é‡å¯¼å‡ºå·¥å…·"""

    def __init__(self, graph: KnowledgeGraph):
        self.graph = graph
        self.exporter = KnowledgeGraphExporter(graph)

    def export_all_formats(self, output_dir: str):
        """å¯¼å‡ºæ‰€æœ‰æ ¼å¼"""
        import os

        os.makedirs(output_dir, exist_ok=True)

# JSONæ ¼å¼
        self.graph.export_to_json(os.path.join(output_dir, 'knowledge_graph.json'))

# CSVæ ¼å¼
        self.exporter.export_to_csv(
            os.path.join(output_dir, 'nodes.csv'),
            os.path.join(output_dir, 'edges.csv')
        )

# GMLæ ¼å¼
        self.exporter.export_to_gml(os.path.join(output_dir, 'knowledge_graph.gml'))

# GraphMLæ ¼å¼
        self.exporter.export_to_graphml(os.path.join(output_dir, 'knowledge_graph.graphml'))

# Cypheræ ¼å¼
        self.exporter.export_to_cypher(os.path.join(output_dir, 'knowledge_graph.cypher'))

# RDFæ ¼å¼
        self.exporter.export_to_rdf(os.path.join(output_dir, 'knowledge_graph.rdf'))

        print(f"æ‰€æœ‰æ ¼å¼å·²å¯¼å‡ºåˆ°: {output_dir}")

    def export_by_type(self, output_dir: str):
        """æŒ‰ç±»å‹åˆ†åˆ«å¯¼å‡º"""
        import os

        os.makedirs(output_dir, exist_ok=True)

# æŒ‰èŠ‚ç‚¹ç±»å‹å¯¼å‡º
        for node_type in self.graph.node_types:
            filtered_graph = self.graph.filter_by_type(node_types={node_type})
            filtered_exporter = KnowledgeGraphExporter(filtered_graph)

            type_dir = os.path.join(output_dir, f'type_{node_type}')
            os.makedirs(type_dir, exist_ok=True)

            filtered_graph.export_to_json(os.path.join(type_dir, f'{node_type}.json'))
            filtered_exporter.export_to_csv(
                os.path.join(type_dir, f'{node_type}_nodes.csv'),
                os.path.join(type_dir, f'{node_type}_edges.csv')
            )

# æŒ‰å…³ç³»ç±»å‹å¯¼å‡º
        for edge_type in self.graph.edge_types:
            filtered_graph = self.graph.filter_by_type(edge_types={edge_type})
            filtered_exporter = KnowledgeGraphExporter(filtered_graph)

            type_dir = os.path.join(output_dir, f'relation_{edge_type}')
            os.makedirs(type_dir, exist_ok=True)

            filtered_graph.export_to_json(os.path.join(type_dir, f'{edge_type}.json'))
            filtered_exporter.export_to_csv(
                os.path.join(type_dir, f'{edge_type}_nodes.csv'),
                os.path.join(type_dir, f'{edge_type}_edges.csv')
            )
```

## 5. çŸ¥è¯†å›¾è°±å¯è§†åŒ–

### 5.1. äº¤äº’å¼å¯è§†åŒ–

```python
# çŸ¥è¯†å›¾è°±å¯è§†åŒ–å·¥å…·
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots
import networkx as nx

class KnowledgeGraphVisualizer:
    """çŸ¥è¯†å›¾è°±å¯è§†åŒ–å™¨"""

    def __init__(self, graph: KnowledgeGraph):
        self.graph = graph
        self.nx_graph = graph.to_networkx()

    def create_network_visualization(self, layout='spring', height=800):
        """åˆ›å»ºç½‘ç»œå¯è§†åŒ–"""
# è®¡ç®—å¸ƒå±€
        if layout == 'spring':
            pos = nx.spring_layout(self.nx_graph)
        elif layout == 'circular':
            pos = nx.circular_layout(self.nx_graph)
        elif layout == 'kamada_kawai':
            pos = nx.kamada_kawai_layout(self.nx_graph)
        else:
            pos = nx.spring_layout(self.nx_graph)

# å‡†å¤‡è¾¹æ•°æ®
        edge_x = []
        edge_y = []
        edge_trace = go.Scatter(
            x=[], y=[],
            line=dict(width=0.5, color='#888'),
            hoverinfo='none',
            mode='lines')

        for edge in self.nx_graph.edges():
            x0, y0 = pos[edge[0]]
            x1, y1 = pos[edge[1]]
            edge_x.extend([x0, x1, None])
            edge_y.extend([y0, y1, None])

        edge_trace.x = edge_x
        edge_trace.y = edge_y

# å‡†å¤‡èŠ‚ç‚¹æ•°æ®
        node_x = []
        node_y = []
        node_text = []
        node_color = []

        for node in self.nx_graph.nodes():
            x, y = pos[node]
            node_x.append(x)
            node_y.append(y)
            node_text.append(f'Node: {node}<br>Type: {self.graph.nodes[node]["type"]}')
            node_color.append(len(list(self.nx_graph.neighbors(node))))

        node_trace = go.Scatter(
            x=node_x, y=node_y,
            mode='markers+text',
            hoverinfo='text',
            text=[node for node in self.nx_graph.nodes()],
            textposition="top center",
            marker=dict(
                showscale=True,
                colorscale='YlGnBu',
                size=10,
                colorbar=dict(
                    thickness=15,
                    title='Node Connections',
                    xanchor="left",
                    titleside="right"
                ),
                color=node_color
            ))

# åˆ›å»ºå›¾å½¢
        fig = go.Figure(data=[edge_trace, node_trace],
                       layout=go.Layout(
                           title='Knowledge Graph Visualization',
                           showlegend=False,
                           hovermode='closest',
                           margin=dict(b=20,l=5,r=5,t=40),
                           xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
                           yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
                           height=height
                       ))

        return fig

    def create_subgraph_visualization(self, node_ids: List[str], height=600):
        """åˆ›å»ºå­å›¾å¯è§†åŒ–"""
        subgraph = self.nx_graph.subgraph(node_ids)

        pos = nx.spring_layout(subgraph)

# å‡†å¤‡è¾¹æ•°æ®
        edge_x = []
        edge_y = []

        for edge in subgraph.edges():
            x0, y0 = pos[edge[0]]
            x1, y1 = pos[edge[1]]
            edge_x.extend([x0, x1, None])
            edge_y.extend([y0, y1, None])

        edge_trace = go.Scatter(
            x=edge_x, y=edge_y,
            line=dict(width=1, color='#888'),
            hoverinfo='none',
            mode='lines')

# å‡†å¤‡èŠ‚ç‚¹æ•°æ®
        node_x = []
        node_y = []
        node_text = []

        for node in subgraph.nodes():
            x, y = pos[node]
            node_x.append(x)
            node_y.append(y)
            node_text.append(f'Node: {node}<br>Type: {self.graph.nodes[node]["type"]}')

        node_trace = go.Scatter(
            x=node_x, y=node_y,
            mode='markers+text',
            hoverinfo='text',
            text=[node for node in subgraph.nodes()],
            textposition="top center",
            marker=dict(size=15, color='lightblue'))

        fig = go.Figure(data=[edge_trace, node_trace],
                       layout=go.Layout(
                           title='Subgraph Visualization',
                           showlegend=False,
                           hovermode='closest',
                           margin=dict(b=20,l=5,r=5,t=40),
                           xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
                           yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
                           height=height
                       ))

        return fig

    def create_statistics_dashboard(self):
        """åˆ›å»ºç»Ÿè®¡ä»ªè¡¨æ¿"""
# èŠ‚ç‚¹ç±»å‹ç»Ÿè®¡
        node_type_counts = {}
        for node_data in self.graph.nodes.values():
            node_type = node_data['type']
            node_type_counts[node_type] = node_type_counts.get(node_type, 0) + 1

# å…³ç³»ç±»å‹ç»Ÿè®¡
        relation_counts = {}
        for _, relation, _, _ in self.graph.edges:
            relation_counts[relation] = relation_counts.get(relation, 0) + 1

# åˆ›å»ºå­å›¾
        fig = make_subplots(
            rows=2, cols=2,
            subplot_titles=('Node Types', 'Relation Types', 'Graph Metrics', 'Degree Distribution'),
            specs=[[{"type": "bar"}, {"type": "bar"}],
                   [{"type": "indicator"}, {"type": "histogram"}]]
        )

# èŠ‚ç‚¹ç±»å‹æŸ±çŠ¶å›¾
        fig.add_trace(
            go.Bar(x=list(node_type_counts.keys()), y=list(node_type_counts.values()),
                   name='Node Types'),
            row=1, col=1
        )

# å…³ç³»ç±»å‹æŸ±çŠ¶å›¾
        fig.add_trace(
            go.Bar(x=list(relation_counts.keys()), y=list(relation_counts.values()),
                   name='Relation Types'),
            row=1, col=2
        )

# å›¾æŒ‡æ ‡
        fig.add_trace(
            go.Indicator(
                mode="number+delta",
                value=len(self.graph.nodes),
                title={"text": "Total Nodes"},
                delta={'reference': len(self.graph.nodes) - 10}
            ),
            row=2, col=1
        )

# åº¦åˆ†å¸ƒç›´æ–¹å›¾
        degrees = [len(list(self.nx_graph.neighbors(node))) for node in self.nx_graph.nodes()]
        fig.add_trace(
            go.Histogram(x=degrees, name='Degree Distribution'),
            row=2, col=2
        )

        fig.update_layout(height=800, title_text="Knowledge Graph Statistics Dashboard")

        return fig
```

## 6. Då¯è§†åŒ–

```python
# 3DçŸ¥è¯†å›¾è°±å¯è§†åŒ–
class KnowledgeGraph3DVisualizer:
    """3DçŸ¥è¯†å›¾è°±å¯è§†åŒ–å™¨"""

    def __init__(self, graph: KnowledgeGraph):
        self.graph = graph
        self.nx_graph = graph.to_networkx()

    def create_3d_network_visualization(self, layout='spring'):
        """åˆ›å»º3Dç½‘ç»œå¯è§†åŒ–"""
# è®¡ç®—3Då¸ƒå±€
        if layout == 'spring':
            pos = nx.spring_layout(self.nx_graph, dim=3)
        else:
            pos = nx.spring_layout(self.nx_graph, dim=3)

# å‡†å¤‡è¾¹æ•°æ®
        edge_x = []
        edge_y = []
        edge_z = []

        for edge in self.nx_graph.edges():
            x0, y0, z0 = pos[edge[0]]
            x1, y1, z1 = pos[edge[1]]
            edge_x.extend([x0, x1, None])
            edge_y.extend([y0, y1, None])
            edge_z.extend([z0, z1, None])

        edge_trace = go.Scatter3d(
            x=edge_x, y=edge_y, z=edge_z,
            mode='lines',
            line=dict(color='#888', width=2),
            hoverinfo='none'
        )

# å‡†å¤‡èŠ‚ç‚¹æ•°æ®
        node_x = []
        node_y = []
        node_z = []
        node_text = []
        node_color = []

        for node in self.nx_graph.nodes():
            x, y, z = pos[node]
            node_x.append(x)
            node_y.append(y)
            node_z.append(z)
            node_text.append(f'Node: {node}<br>Type: {self.graph.nodes[node]["type"]}')
            node_color.append(len(list(self.nx_graph.neighbors(node))))

        node_trace = go.Scatter3d(
            x=node_x, y=node_y, z=node_z,
            mode='markers',
            marker=dict(
                size=8,
                color=node_color,
                colorscale='Viridis',
                opacity=0.8
            ),
            text=node_text,
            hoverinfo='text'
        )

        fig = go.Figure(data=[edge_trace, node_trace])
        fig.update_layout(
            title='3D Knowledge Graph Visualization',
            scene=dict(
                xaxis_title='X',
                yaxis_title='Y',
                zaxis_title='Z'
            ),
            width=800,
            height=800
        )

        return fig
```

## 7. çŸ¥è¯†å›¾è°±æ±‡æ€»åˆ†æ

### 7.1. ç»Ÿè®¡åˆ†æå·¥å…·

```python
# çŸ¥è¯†å›¾è°±ç»Ÿè®¡åˆ†æ
class KnowledgeGraphAnalyzer:
    """çŸ¥è¯†å›¾è°±åˆ†æå™¨"""

    def __init__(self, graph: KnowledgeGraph):
        self.graph = graph
        self.nx_graph = graph.to_networkx()

    def get_basic_statistics(self) -> Dict:
        """è·å–åŸºæœ¬ç»Ÿè®¡ä¿¡æ¯"""
        return {
            'total_nodes': len(self.graph.nodes),
            'total_edges': len(self.graph.edges),
            'node_types': len(self.graph.node_types),
            'edge_types': len(self.graph.edge_types),
            'density': nx.density(self.nx_graph),
            'average_clustering': nx.average_clustering(self.nx_graph),
            'average_shortest_path': nx.average_shortest_path_length(self.nx_graph) if nx.is_connected(self.nx_graph) else None
        }

    def get_node_type_statistics(self) -> Dict[str, int]:
        """è·å–èŠ‚ç‚¹ç±»å‹ç»Ÿè®¡"""
        type_counts = {}
        for node_data in self.graph.nodes.values():
            node_type = node_data['type']
            type_counts[node_type] = type_counts.get(node_type, 0) + 1
        return type_counts

    def get_edge_type_statistics(self) -> Dict[str, int]:
        """è·å–è¾¹ç±»å‹ç»Ÿè®¡"""
        type_counts = {}
        for _, relation, _, _ in self.graph.edges:
            type_counts[relation] = type_counts.get(relation, 0) + 1
        return type_counts

    def get_centrality_measures(self) -> Dict[str, Dict[str, float]]:
        """è·å–ä¸­å¿ƒæ€§åº¦é‡"""
        return {
            'degree_centrality': nx.degree_centrality(self.nx_graph),
            'betweenness_centrality': nx.betweenness_centrality(self.nx_graph),
            'closeness_centrality': nx.closeness_centrality(self.nx_graph),
            'eigenvector_centrality': nx.eigenvector_centrality(self.nx_graph, max_iter=1000)
        }

    def get_community_structure(self) -> List[Set[str]]:
        """è·å–ç¤¾åŒºç»“æ„"""
        communities = nx.community.greedy_modularity_communities(self.nx_graph.to_undirected())
        return [set(community) for community in communities]

    def get_connected_components(self) -> List[Set[str]]:
        """è·å–è¿é€šåˆ†é‡"""
        components = nx.connected_components(self.nx_graph.to_undirected())
        return [set(component) for component in components]

    def get_path_analysis(self, source: str, target: str) -> Dict:
        """è·å–è·¯å¾„åˆ†æ"""
        try:
            shortest_path = nx.shortest_path(self.nx_graph, source, target)
            shortest_path_length = nx.shortest_path_length(self.nx_graph, source, target)

# æ‰€æœ‰ç®€å•è·¯å¾„
            all_paths = list(nx.all_simple_paths(self.nx_graph, source, target))

            return {
                'shortest_path': shortest_path,
                'shortest_path_length': shortest_path_length,
                'all_paths_count': len(all_paths),
                'all_paths': all_paths[:10]  # åªè¿”å›å‰10æ¡è·¯å¾„
            }
        except nx.NetworkXNoPath:
            return {'error': 'No path found between nodes'}

    def get_subgraph_analysis(self, node_ids: List[str]) -> Dict:
        """è·å–å­å›¾åˆ†æ"""
        subgraph = self.nx_graph.subgraph(node_ids)

        return {
            'subgraph_nodes': len(subgraph.nodes),
            'subgraph_edges': len(subgraph.edges),
            'subgraph_density': nx.density(subgraph),
            'subgraph_clustering': nx.average_clustering(subgraph),
            'is_connected': nx.is_connected(subgraph.to_undirected()),
            'connected_components': len(list(nx.connected_components(subgraph.to_undirected())))
        }
```

## 8. æ±‡æ€»æŠ¥å‘Šç”Ÿæˆå™¨

```python
# æ±‡æ€»æŠ¥å‘Šç”Ÿæˆå™¨
class KnowledgeGraphReportGenerator:
    """çŸ¥è¯†å›¾è°±æŠ¥å‘Šç”Ÿæˆå™¨"""

    def __init__(self, graph: KnowledgeGraph):
        self.graph = graph
        self.analyzer = KnowledgeGraphAnalyzer(graph)

    def generate_comprehensive_report(self) -> Dict:
        """ç”Ÿæˆç»¼åˆæŠ¥å‘Š"""
        report = {
            'basic_statistics': self.analyzer.get_basic_statistics(),
            'node_type_statistics': self.analyzer.get_node_type_statistics(),
            'edge_type_statistics': self.analyzer.get_edge_type_statistics(),
            'centrality_measures': self.analyzer.get_centrality_measures(),
            'community_structure': {
                'communities': self.analyzer.get_community_structure(),
                'community_count': len(self.analyzer.get_community_structure())
            },
            'connected_components': {
                'components': self.analyzer.get_connected_components(),
                'component_count': len(self.analyzer.get_connected_components())
            }
        }

        return report

    def export_report_to_html(self, report: Dict, filepath: str):
        """å¯¼å‡ºæŠ¥å‘Šä¸ºHTML"""
        html_content = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Knowledge Graph Analysis Report</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                .section {{ margin: 20px 0; padding: 10px; border: 1px solid #ddd; }}
                .metric {{ margin: 10px 0; }}
                table {{ border-collapse: collapse; width: 100%; }}
                th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
                th {{ background-color: #f2f2f2; }}
            </style>
        </head>
        <body>
            <h1>Knowledge Graph Analysis Report</h1>

            <div class="section">
                <h2>Basic Statistics</h2>
                <table>
                    <tr><th>Metric</th><th>Value</th></tr>
                    <tr><td>Total Nodes</td><td>{report['basic_statistics']['total_nodes']}</td></tr>
                    <tr><td>Total Edges</td><td>{report['basic_statistics']['total_edges']}</td></tr>
                    <tr><td>Node Types</td><td>{report['basic_statistics']['node_types']}</td></tr>
                    <tr><td>Edge Types</td><td>{report['basic_statistics']['edge_types']}</td></tr>
                    <tr><td>Density</td><td>{report['basic_statistics']['density']:.4f}</td></tr>
                    <tr><td>Average Clustering</td><td>{report['basic_statistics']['average_clustering']:.4f}</td></tr>
                </table>
            </div>

            <div class="section">
                <h2>Node Type Distribution</h2>
                <table>
                    <tr><th>Node Type</th><th>Count</th></tr>
                    {''.join([f'<tr><td>{node_type}</td><td>{count}</td></tr>' for node_type, count in report['node_type_statistics'].items()])}
                </table>
            </div>

            <div class="section">
                <h2>Edge Type Distribution</h2>
                <table>
                    <tr><th>Edge Type</th><th>Count</th></tr>
                    {''.join([f'<tr><td>{edge_type}</td><td>{count}</td></tr>' for edge_type, count in report['edge_type_statistics'].items()])}
                </table>
            </div>

            <div class="section">
                <h2>Community Structure</h2>
                <p>Number of Communities: {report['community_structure']['community_count']}</p>
                <p>Community Sizes: {[len(community) for community in report['community_structure']['communities']]}</p>
            </div>

            <div class="section">
                <h2>Connected Components</h2>
                <p>Number of Components: {report['connected_components']['component_count']}</p>
                <p>Component Sizes: {[len(component) for component in report['connected_components']['components']]}</p>
            </div>
        </body>
        </html>
        """

        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(html_content)

    def export_report_to_json(self, report: Dict, filepath: str):
        """å¯¼å‡ºæŠ¥å‘Šä¸ºJSON"""
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(report, f, ensure_ascii=False, indent=2, default=str)

    def export_report_to_csv(self, report: Dict, output_dir: str):
        """å¯¼å‡ºæŠ¥å‘Šä¸ºCSV"""
        import os

        os.makedirs(output_dir, exist_ok=True)

# åŸºæœ¬ç»Ÿè®¡
        basic_stats_df = pd.DataFrame([report['basic_statistics']])
        basic_stats_df.to_csv(os.path.join(output_dir, 'basic_statistics.csv'), index=False)

# èŠ‚ç‚¹ç±»å‹ç»Ÿè®¡
        node_type_df = pd.DataFrame(list(report['node_type_statistics'].items()),
                                  columns=['node_type', 'count'])
        node_type_df.to_csv(os.path.join(output_dir, 'node_type_statistics.csv'), index=False)

# è¾¹ç±»å‹ç»Ÿè®¡
        edge_type_df = pd.DataFrame(list(report['edge_type_statistics'].items()),
                                  columns=['edge_type', 'count'])
        edge_type_df.to_csv(os.path.join(output_dir, 'edge_type_statistics.csv'), index=False)

# ä¸­å¿ƒæ€§åº¦é‡
        centrality_df = pd.DataFrame(report['centrality_measures']['degree_centrality'].items(),
                                   columns=['node', 'degree_centrality'])
        centrality_df.to_csv(os.path.join(output_dir, 'centrality_measures.csv'), index=False)
```

## 9. å·¥å…·ä¸å¹³å°

### 9.1. çŸ¥è¯†å›¾è°±å·¥å…·

1. **Neo4j**ï¼šå›¾æ•°æ®åº“å’Œå¯è§†åŒ–å¹³å°
2. **Gephi**ï¼šç½‘ç»œåˆ†æå’Œå¯è§†åŒ–è½¯ä»¶
3. **Cytoscape**ï¼šç”Ÿç‰©ç½‘ç»œåˆ†æå’Œå¯è§†åŒ–
4. **NetworkX**ï¼šPythonç½‘ç»œåˆ†æåº“

### 9.2. å¯è§†åŒ–å·¥å…·

1. **Plotly**ï¼šäº¤äº’å¼å¯è§†åŒ–åº“
2. **D3.js**ï¼šæ•°æ®é©±åŠ¨æ–‡æ¡£åº“
3. **Vis.js**ï¼šåŠ¨æ€å¯è§†åŒ–åº“
4. **Three.js**ï¼š3Då¯è§†åŒ–åº“

### 9.3. å¯¼å‡ºå·¥å…·

1. **GraphML**ï¼šå›¾æ ‡è®°è¯­è¨€
2. **GML**ï¼šå›¾å»ºæ¨¡è¯­è¨€
3. **Cypher**ï¼šNeo4jæŸ¥è¯¢è¯­è¨€
4. **RDF**ï¼šèµ„æºæè¿°æ¡†æ¶

## 10. æœ€ä½³å®è·µ

### 10.1. çŸ¥è¯†å›¾è°±æ„å»º

1. **æ•°æ®è´¨é‡**ï¼šç¡®ä¿æ•°æ®çš„å‡†ç¡®æ€§å’Œå®Œæ•´æ€§
2. **æ ‡å‡†åŒ–**ï¼šä½¿ç”¨æ ‡å‡†åŒ–çš„å®ä½“å’Œå…³ç³»ç±»å‹
3. **å¯æ‰©å±•æ€§**ï¼šè®¾è®¡å¯æ‰©å±•çš„å›¾è°±ç»“æ„
4. **æ€§èƒ½ä¼˜åŒ–**ï¼šä¼˜åŒ–æŸ¥è¯¢å’Œå­˜å‚¨æ€§èƒ½
5. **ç‰ˆæœ¬æ§åˆ¶**ï¼šç®¡ç†å›¾è°±çš„ç‰ˆæœ¬å’Œå˜æ›´

### 10.2. å¯è§†åŒ–è®¾è®¡

1. **äº¤äº’æ€§**ï¼šæä¾›ä¸°å¯Œçš„äº¤äº’åŠŸèƒ½
2. **å¯è¯»æ€§**ï¼šç¡®ä¿å¯è§†åŒ–çš„æ¸…æ™°æ˜“è¯»
3. **æ€§èƒ½**ï¼šä¼˜åŒ–å¤§è§„æ¨¡å›¾è°±çš„æ¸²æŸ“æ€§èƒ½
4. **å®šåˆ¶åŒ–**ï¼šæ”¯æŒç”¨æˆ·è‡ªå®šä¹‰è§†å›¾
5. **å¤šç»´åº¦**ï¼šæ”¯æŒ2Då’Œ3Då¯è§†åŒ–

### 10.3. å¯¼å‡ºå’Œæ±‡æ€»

1. **å¤šæ ¼å¼æ”¯æŒ**ï¼šæ”¯æŒå¤šç§å¯¼å‡ºæ ¼å¼
2. **æ‰¹é‡å¤„ç†**ï¼šæ”¯æŒæ‰¹é‡å¯¼å‡ºæ“ä½œ
3. **ç»Ÿè®¡åˆ†æ**ï¼šæä¾›å…¨é¢çš„ç»Ÿè®¡åˆ†æ
4. **æŠ¥å‘Šç”Ÿæˆ**ï¼šè‡ªåŠ¨ç”Ÿæˆåˆ†ææŠ¥å‘Š
5. **æ•°æ®éªŒè¯**ï¼šç¡®ä¿å¯¼å‡ºæ•°æ®çš„æ­£ç¡®æ€§
