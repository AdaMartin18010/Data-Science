# çŸ¥è¯†å›¾è°±å®‰å…¨é˜²æŠ¤

## ğŸ“‘ ç›®å½•

- [çŸ¥è¯†å›¾è°±å®‰å…¨é˜²æŠ¤](#çŸ¥è¯†å›¾è°±å®‰å…¨é˜²æŠ¤)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
- [1. èº«ä»½è®¤è¯ä¸æˆæƒ](#1-èº«ä»½è®¤è¯ä¸æˆæƒ)
  - [1.1. JWTè®¤è¯ç³»ç»Ÿ](#11-jwtè®¤è¯ç³»ç»Ÿ)
- [2. RBACè®¿é—®æ§åˆ¶](#2-rbacè®¿é—®æ§åˆ¶)
- [3. æ•°æ®åŠ å¯†](#3-æ•°æ®åŠ å¯†)
  - [3.1. æ•°æ®åŠ å¯†ç®¡ç†å™¨](#31-æ•°æ®åŠ å¯†ç®¡ç†å™¨)
- [4. ä¼ è¾“åŠ å¯†](#4-ä¼ è¾“åŠ å¯†)
- [5. å®‰å…¨å®¡è®¡](#5-å®‰å…¨å®¡è®¡)
  - [5.1. å®¡è®¡æ—¥å¿—ç³»ç»Ÿ](#51-å®¡è®¡æ—¥å¿—ç³»ç»Ÿ)
- [6. å®‰å…¨ç›‘æ§](#6-å®‰å…¨ç›‘æ§)
  - [6.1. å®‰å…¨ç›‘æ§ç³»ç»Ÿ](#61-å®‰å…¨ç›‘æ§ç³»ç»Ÿ)
- [7. å·¥å…·ä¸å¹³å°](#7-å·¥å…·ä¸å¹³å°)
  - [7.1. å®‰å…¨å·¥å…·](#71-å®‰å…¨å·¥å…·)
  - [7.2. ç›‘æ§å·¥å…·](#72-ç›‘æ§å·¥å…·)
  - [7.3. äº‘å®‰å…¨æœåŠ¡](#73-äº‘å®‰å…¨æœåŠ¡)
- [8. æœ€ä½³å®è·µ](#8-æœ€ä½³å®è·µ)
  - [8.1. èº«ä»½è®¤è¯](#81-èº«ä»½è®¤è¯)
  - [8.2. è®¿é—®æ§åˆ¶](#82-è®¿é—®æ§åˆ¶)
  - [8.3. æ•°æ®ä¿æŠ¤](#83-æ•°æ®ä¿æŠ¤)
  - [8.4. å®‰å…¨ç›‘æ§](#84-å®‰å…¨ç›‘æ§)
---


## 1. èº«ä»½è®¤è¯ä¸æˆæƒ

### 1.1. JWTè®¤è¯ç³»ç»Ÿ

```python
# JWTè®¤è¯ç®¡ç†å™¨
import jwt
import datetime
from typing import Dict, Optional, Any, List
from fastapi import HTTPException, Depends
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
import hashlib
import secrets

class JWTAuthManager:
    """JWTè®¤è¯ç®¡ç†å™¨"""

    def __init__(self, secret_key: str, algorithm: str = "HS256"):
        self.secret_key = secret_key
        self.algorithm = algorithm
        self.security = HTTPBearer()
        self.token_blacklist = set()  # ä»¤ç‰Œé»‘åå•

    def create_token(self, user_id: str, username: str, roles: List[str],
                    expires_delta: datetime.timedelta = None) -> str:
        """åˆ›å»ºJWTä»¤ç‰Œ"""
        if expires_delta is None:
            expires_delta = datetime.timedelta(hours=24)

        expire = datetime.datetime.utcnow() + expires_delta

        to_encode = {
            "sub": user_id,
            "username": username,
            "roles": roles,
            "exp": expire,
            "iat": datetime.datetime.utcnow(),
            "jti": secrets.token_hex(16)  # JWT ID
        }

        encoded_jwt = jwt.encode(to_encode, self.secret_key, algorithm=self.algorithm)
        return encoded_jwt

    def verify_token(self, token: str) -> Dict[str, Any]:
        """éªŒè¯JWTä»¤ç‰Œ"""
        try:
# æ£€æŸ¥é»‘åå•
            if token in self.token_blacklist:
                raise HTTPException(status_code=401, detail="ä»¤ç‰Œå·²è¢«æ’¤é”€")

            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])

# æ£€æŸ¥è¿‡æœŸæ—¶é—´
            if datetime.datetime.utcnow() > datetime.datetime.fromtimestamp(payload["exp"]):
                raise HTTPException(status_code=401, detail="ä»¤ç‰Œå·²è¿‡æœŸ")

            return payload

        except jwt.ExpiredSignatureError:
            raise HTTPException(status_code=401, detail="ä»¤ç‰Œå·²è¿‡æœŸ")
        except jwt.JWTError:
            raise HTTPException(status_code=401, detail="æ— æ•ˆä»¤ç‰Œ")

    def revoke_token(self, token: str):
        """æ’¤é”€ä»¤ç‰Œ"""
        self.token_blacklist.add(token)

    def get_current_user(self, credentials: HTTPAuthorizationCredentials = Depends(HTTPBearer())) -> Dict[str, Any]:
        """è·å–å½“å‰ç”¨æˆ·"""
        token = credentials.credentials
        return self.verify_token(token)

    def require_role(self, required_role: str):
        """è§’è‰²è¦æ±‚è£…é¥°å™¨"""
        def role_checker(current_user: Dict[str, Any] = Depends(self.get_current_user)):
            if required_role not in current_user.get("roles", []):
                raise HTTPException(
                    status_code=403,
                    detail=f"éœ€è¦è§’è‰²: {required_role}"
                )
            return current_user
        return role_checker

# ä½¿ç”¨ç¤ºä¾‹
auth_manager = JWTAuthManager(secret_key="your-secret-key")

# åˆ›å»ºä»¤ç‰Œ
token = auth_manager.create_token(
    user_id="user123",
    username="john_doe",
    roles=["user", "admin"]
)

# éªŒè¯ä»¤ç‰Œ
user_info = auth_manager.verify_token(token)
```

## 2. RBACè®¿é—®æ§åˆ¶

```python
# RBACè®¿é—®æ§åˆ¶ç³»ç»Ÿ
from enum import Enum
from typing import Set, Dict, List, Any
import json

class Permission(Enum):
    """æƒé™æšä¸¾"""
    READ = "read"
    WRITE = "write"
    DELETE = "delete"
    ADMIN = "admin"

class Resource(Enum):
    """èµ„æºæšä¸¾"""
    NODES = "nodes"
    RELATIONSHIPS = "relationships"
    QUERIES = "queries"
    ANALYTICS = "analytics"
    USERS = "users"

class RBACManager:
    """RBACè®¿é—®æ§åˆ¶ç®¡ç†å™¨"""

    def __init__(self):
        self.roles = {
            "admin": {
                "permissions": {resource: {perm.value for perm in Permission} for resource in Resource},
                "description": "ç³»ç»Ÿç®¡ç†å‘˜"
            },
            "analyst": {
                "permissions": {
                    Resource.NODES: {Permission.READ.value},
                    Resource.RELATIONSHIPS: {Permission.READ.value},
                    Resource.QUERIES: {Permission.READ.value, Permission.WRITE.value},
                    Resource.ANALYTICS: {Permission.READ.value, Permission.WRITE.value}
                },
                "description": "æ•°æ®åˆ†æå¸ˆ"
            },
            "viewer": {
                "permissions": {
                    Resource.NODES: {Permission.READ.value},
                    Resource.RELATIONSHIPS: {Permission.READ.value},
                    Resource.QUERIES: {Permission.READ.value}
                },
                "description": "åªè¯»ç”¨æˆ·"
            }
        }

        self.user_roles = {}  # ç”¨æˆ·è§’è‰²æ˜ å°„
        self.resource_policies = {}  # èµ„æºç­–ç•¥

    def assign_role(self, user_id: str, role: str):
        """åˆ†é…è§’è‰²"""
        if role not in self.roles:
            raise ValueError(f"æ— æ•ˆè§’è‰²: {role}")

        self.user_roles[user_id] = role

    def check_permission(self, user_id: str, resource: Resource, permission: Permission) -> bool:
        """æ£€æŸ¥æƒé™"""
        if user_id not in self.user_roles:
            return False

        role = self.user_roles[user_id]
        role_permissions = self.roles[role]["permissions"]

        return (resource in role_permissions and
                permission.value in role_permissions[resource])

    def get_user_permissions(self, user_id: str) -> Dict[Resource, Set[str]]:
        """è·å–ç”¨æˆ·æƒé™"""
        if user_id not in self.user_roles:
            return {}

        role = self.user_roles[user_id]
        return self.roles[role]["permissions"]

    def add_resource_policy(self, resource: Resource, policy: Dict[str, Any]):
        """æ·»åŠ èµ„æºç­–ç•¥"""
        self.resource_policies[resource] = policy

    def check_resource_access(self, user_id: str, resource: Resource, action: str) -> bool:
        """æ£€æŸ¥èµ„æºè®¿é—®æƒé™"""
# æ£€æŸ¥åŸºæœ¬æƒé™
        if action == "read" and not self.check_permission(user_id, resource, Permission.READ):
            return False
        elif action == "write" and not self.check_permission(user_id, resource, Permission.WRITE):
            return False
        elif action == "delete" and not self.check_permission(user_id, resource, Permission.DELETE):
            return False

# æ£€æŸ¥èµ„æºç­–ç•¥
        if resource in self.resource_policies:
            policy = self.resource_policies[resource]
            return self._evaluate_policy(user_id, policy, action)

        return True

    def _evaluate_policy(self, user_id: str, policy: Dict[str, Any], action: str) -> bool:
        """è¯„ä¼°ç­–ç•¥"""
# å®ç°ç­–ç•¥è¯„ä¼°é€»è¾‘
        return True

# ä½¿ç”¨ç¤ºä¾‹
rbac_manager = RBACManager()

# åˆ†é…è§’è‰²
rbac_manager.assign_role("user123", "analyst")

# æ£€æŸ¥æƒé™
can_read = rbac_manager.check_permission("user123", Resource.NODES, Permission.READ)
can_write = rbac_manager.check_permission("user123", Resource.NODES, Permission.WRITE)

print(f"ç”¨æˆ·å¯è¯»: {can_read}, ç”¨æˆ·å¯å†™: {can_write}")
```

## 3. æ•°æ®åŠ å¯†

### 3.1. æ•°æ®åŠ å¯†ç®¡ç†å™¨

```python
# æ•°æ®åŠ å¯†ç®¡ç†å™¨
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import base64
import os
from typing import Dict, Any, Optional, List

class DataEncryptionManager:
    """æ•°æ®åŠ å¯†ç®¡ç†å™¨"""

    def __init__(self, master_key: str = None):
        if master_key is None:
            master_key = Fernet.generate_key()

        self.master_key = master_key
        self.fernet = Fernet(master_key)
        self.encryption_keys = {}  # ä¸åŒæ•°æ®ç±»å‹çš„åŠ å¯†å¯†é’¥

    def generate_key(self, salt: bytes = None) -> bytes:
        """ç”ŸæˆåŠ å¯†å¯†é’¥"""
        if salt is None:
            salt = os.urandom(16)

        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
        )

        key = base64.urlsafe_b64encode(kdf.derive(self.master_key))
        return key

    def encrypt_data(self, data: str, key: bytes = None) -> Dict[str, bytes]:
        """åŠ å¯†æ•°æ®"""
        if key is None:
            key = self.fernet.key

        fernet = Fernet(key)
        encrypted_data = fernet.encrypt(data.encode())

        return {
            "encrypted_data": encrypted_data,
            "key": key
        }

    def decrypt_data(self, encrypted_data: bytes, key: bytes) -> str:
        """è§£å¯†æ•°æ®"""
        fernet = Fernet(key)
        decrypted_data = fernet.decrypt(encrypted_data)
        return decrypted_data.decode()

    def encrypt_sensitive_fields(self, data: Dict[str, Any],
                               sensitive_fields: List[str]) -> Dict[str, Any]:
        """åŠ å¯†æ•æ„Ÿå­—æ®µ"""
        encrypted_data = data.copy()

        for field in sensitive_fields:
            if field in encrypted_data and encrypted_data[field]:
                encrypted_result = self.encrypt_data(str(encrypted_data[field]))
                encrypted_data[f"{field}_encrypted"] = base64.b64encode(
                    encrypted_result["encrypted_data"]
                ).decode()
                encrypted_data[f"{field}_key"] = base64.b64encode(
                    encrypted_result["key"]
                ).decode()
                del encrypted_data[field]  # åˆ é™¤åŸå§‹æ•°æ®

        return encrypted_data

    def decrypt_sensitive_fields(self, data: Dict[str, Any],
                               sensitive_fields: List[str]) -> Dict[str, Any]:
        """è§£å¯†æ•æ„Ÿå­—æ®µ"""
        decrypted_data = data.copy()

        for field in sensitive_fields:
            encrypted_field = f"{field}_encrypted"
            key_field = f"{field}_key"

            if encrypted_field in decrypted_data and key_field in decrypted_data:
                encrypted_data = base64.b64decode(decrypted_data[encrypted_field])
                key = base64.b64decode(decrypted_data[key_field])

                decrypted_data[field] = self.decrypt_data(encrypted_data, key)

# åˆ é™¤åŠ å¯†å­—æ®µ
                del decrypted_data[encrypted_field]
                del decrypted_data[key_field]

        return decrypted_data

# ä½¿ç”¨ç¤ºä¾‹
encryption_manager = DataEncryptionManager()

# åŠ å¯†æ•æ„Ÿæ•°æ®
sensitive_data = {
    "name": "John Doe",
    "email": "john.doe@example.com",
    "password": "secret123",
    "phone": "123-456-7890"
}

encrypted_data = encryption_manager.encrypt_sensitive_fields(
    sensitive_data,
    ["password", "phone"]
)

# è§£å¯†æ•°æ®
decrypted_data = encryption_manager.decrypt_sensitive_fields(
    encrypted_data,
    ["password", "phone"]
)
```

## 4. ä¼ è¾“åŠ å¯†

```python
# ä¼ è¾“åŠ å¯†ç®¡ç†å™¨
import ssl
import socket
from cryptography import x509
from cryptography.x509.oid import NameOID
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import rsa
import datetime
import logging

logger = logging.getLogger(__name__)

class TransportEncryptionManager:
    """ä¼ è¾“åŠ å¯†ç®¡ç†å™¨"""

    def __init__(self):
        self.ssl_context = ssl.create_default_context()

    def generate_self_signed_certificate(self, common_name: str = "localhost") -> tuple:
        """ç”Ÿæˆè‡ªç­¾åè¯ä¹¦"""
# ç”Ÿæˆç§é’¥
        private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=2048,
        )

# åˆ›å»ºè¯ä¹¦
        subject = issuer = x509.Name([
            x509.NameAttribute(NameOID.COMMON_NAME, common_name),
        ])

        cert = x509.CertificateBuilder().subject_name(
            subject
        ).issuer_name(
            issuer
        ).public_key(
            private_key.public_key()
        ).serial_number(
            x509.random_serial_number()
        ).not_valid_before(
            datetime.datetime.utcnow()
        ).not_valid_after(
            datetime.datetime.utcnow() + datetime.timedelta(days=365)
        ).add_extension(
            x509.SubjectAlternativeName([
                x509.DNSName(common_name),
                x509.IPAddress(socket.gethostbyname(common_name))
            ]),
            critical=False,
        ).sign(private_key, hashes.SHA256())

        return cert, private_key

    def save_certificate(self, cert: x509.Certificate, private_key: rsa.RSAPrivateKey,
                        cert_file: str, key_file: str):
        """ä¿å­˜è¯ä¹¦"""
# ä¿å­˜è¯ä¹¦
        with open(cert_file, "wb") as f:
            f.write(cert.public_bytes(serialization.Encoding.PEM))

# ä¿å­˜ç§é’¥
        with open(key_file, "wb") as f:
            f.write(private_key.private_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PrivateFormat.PKCS8,
                encryption_algorithm=serialization.NoEncryption()
            ))

    def create_ssl_context(self, cert_file: str, key_file: str) -> ssl.SSLContext:
        """åˆ›å»ºSSLä¸Šä¸‹æ–‡"""
        context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
        context.load_cert_chain(cert_file, key_file)
        context.check_hostname = False
        context.verify_mode = ssl.CERT_NONE
        return context

    def verify_certificate(self, cert_file: str) -> bool:
        """éªŒè¯è¯ä¹¦"""
        try:
            with open(cert_file, "rb") as f:
                cert_data = f.read()

            cert = x509.load_pem_x509_certificate(cert_data)

# æ£€æŸ¥è¯ä¹¦æ˜¯å¦è¿‡æœŸ
            now = datetime.datetime.utcnow()
            if now < cert.not_valid_before or now > cert.not_valid_after:
                return False

            return True

        except Exception as e:
            logger.error(f"è¯ä¹¦éªŒè¯å¤±è´¥: {e}")
            return False

# ä½¿ç”¨ç¤ºä¾‹
transport_manager = TransportEncryptionManager()

# ç”Ÿæˆè¯ä¹¦
cert, private_key = transport_manager.generate_self_signed_certificate("knowledge-graph.example.com")

# ä¿å­˜è¯ä¹¦
transport_manager.save_certificate(cert, private_key, "cert.pem", "key.pem")

# åˆ›å»ºSSLä¸Šä¸‹æ–‡
ssl_context = transport_manager.create_ssl_context("cert.pem", "key.pem")

# éªŒè¯è¯ä¹¦
is_valid = transport_manager.verify_certificate("cert.pem")
```

## 5. å®‰å…¨å®¡è®¡

### 5.1. å®¡è®¡æ—¥å¿—ç³»ç»Ÿ

```python
# å®¡è®¡æ—¥å¿—ç³»ç»Ÿ
import logging
import json
import datetime
from typing import Dict, Any, Optional, List
from dataclasses import dataclass, asdict
import hashlib

@dataclass
class AuditEvent:
    """å®¡è®¡äº‹ä»¶"""
    timestamp: datetime.datetime
    user_id: str
    action: str
    resource: str
    details: Dict[str, Any]
    ip_address: str
    user_agent: str
    session_id: str
    event_id: str = None

    def __post_init__(self):
        if self.event_id is None:
            self.event_id = self._generate_event_id()

    def _generate_event_id(self) -> str:
        """ç”Ÿæˆäº‹ä»¶ID"""
        event_data = f"{self.timestamp}{self.user_id}{self.action}{self.resource}"
        return hashlib.sha256(event_data.encode()).hexdigest()

class AuditLogger:
    """å®¡è®¡æ—¥å¿—è®°å½•å™¨"""

    def __init__(self, log_file: str = "audit.log"):
        self.log_file = log_file
        self.logger = logging.getLogger("audit")
        self.logger.setLevel(logging.INFO)

# æ–‡ä»¶å¤„ç†å™¨
        file_handler = logging.FileHandler(log_file)
        file_handler.setLevel(logging.INFO)

# æ ¼å¼åŒ–å™¨
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        file_handler.setFormatter(formatter)

        self.logger.addHandler(file_handler)

    def log_event(self, event: AuditEvent):
        """è®°å½•å®¡è®¡äº‹ä»¶"""
        event_dict = asdict(event)
        event_dict["timestamp"] = event.timestamp.isoformat()

        self.logger.info(json.dumps(event_dict))

    def log_user_action(self, user_id: str, action: str, resource: str,
                       details: Dict[str, Any], request_info: Dict[str, str]):
        """è®°å½•ç”¨æˆ·æ“ä½œ"""
        event = AuditEvent(
            timestamp=datetime.datetime.utcnow(),
            user_id=user_id,
            action=action,
            resource=resource,
            details=details,
            ip_address=request_info.get("ip_address", ""),
            user_agent=request_info.get("user_agent", ""),
            session_id=request_info.get("session_id", "")
        )

        self.log_event(event)

    def search_audit_logs(self, filters: Dict[str, Any]) -> List[AuditEvent]:
        """æœç´¢å®¡è®¡æ—¥å¿—"""
        events = []

        with open(self.log_file, 'r') as f:
            for line in f:
                try:
                    event_data = json.loads(line.split(' - ')[-1])

# åº”ç”¨è¿‡æ»¤å™¨
                    if self._matches_filters(event_data, filters):
                        event = AuditEvent(
                            timestamp=datetime.datetime.fromisoformat(event_data["timestamp"]),
                            user_id=event_data["user_id"],
                            action=event_data["action"],
                            resource=event_data["resource"],
                            details=event_data["details"],
                            ip_address=event_data["ip_address"],
                            user_agent=event_data["user_agent"],
                            session_id=event_data["session_id"],
                            event_id=event_data["event_id"]
                        )
                        events.append(event)

                except Exception as e:
                    logger.error(f"è§£æå®¡è®¡æ—¥å¿—å¤±è´¥: {e}")

        return events

    def _matches_filters(self, event_data: Dict[str, Any], filters: Dict[str, Any]) -> bool:
        """æ£€æŸ¥äº‹ä»¶æ˜¯å¦åŒ¹é…è¿‡æ»¤å™¨"""
        for key, value in filters.items():
            if key in event_data:
                if isinstance(value, list):
                    if event_data[key] not in value:
                        return False
                else:
                    if event_data[key] != value:
                        return False
            else:
                return False
        return True

    def generate_audit_report(self, start_date: datetime.datetime,
                            end_date: datetime.datetime) -> Dict[str, Any]:
        """ç”Ÿæˆå®¡è®¡æŠ¥å‘Š"""
        events = self.search_audit_logs({
            "timestamp": {
                "start": start_date.isoformat(),
                "end": end_date.isoformat()
            }
        })

# ç»Ÿè®¡ä¿¡æ¯
        action_counts = {}
        user_counts = {}
        resource_counts = {}

        for event in events:
            action_counts[event.action] = action_counts.get(event.action, 0) + 1
            user_counts[event.user_id] = user_counts.get(event.user_id, 0) + 1
            resource_counts[event.resource] = resource_counts.get(event.resource, 0) + 1

        return {
            "period": {
                "start": start_date.isoformat(),
                "end": end_date.isoformat()
            },
            "total_events": len(events),
            "action_counts": action_counts,
            "user_counts": user_counts,
            "resource_counts": resource_counts,
            "events": [asdict(event) for event in events]
        }

# ä½¿ç”¨ç¤ºä¾‹
audit_logger = AuditLogger()

# è®°å½•ç”¨æˆ·æ“ä½œ
request_info = {
    "ip_address": "192.168.1.100",
    "user_agent": "Mozilla/5.0...",
    "session_id": "session123"
}

audit_logger.log_user_action(
    user_id="user123",
    action="READ",
    resource="/api/nodes",
    details={"node_id": "node456"},
    request_info=request_info
)

# æœç´¢å®¡è®¡æ—¥å¿—
filters = {"user_id": "user123", "action": "READ"}
events = audit_logger.search_audit_logs(filters)

# ç”Ÿæˆå®¡è®¡æŠ¥å‘Š
start_date = datetime.datetime.utcnow() - datetime.timedelta(days=7)
end_date = datetime.datetime.utcnow()
report = audit_logger.generate_audit_report(start_date, end_date)
```

## 6. å®‰å…¨ç›‘æ§

### 6.1. å®‰å…¨ç›‘æ§ç³»ç»Ÿ

```python
# å®‰å…¨ç›‘æ§ç³»ç»Ÿ
import threading
import time
from collections import defaultdict, deque
from typing import Dict, List, Any, Callable
import json

class SecurityMonitor:
    """å®‰å…¨ç›‘æ§ç³»ç»Ÿ"""

    def __init__(self):
        self.event_queue = deque(maxlen=10000)
        self.alert_handlers = []
        self.thresholds = {
            "failed_login_attempts": 5,
            "api_rate_limit": 100,
            "suspicious_ip_attempts": 10
        }

        self.counters = defaultdict(int)
        self.ip_blacklist = set()
        self.user_suspicious_activity = defaultdict(list)

# å¯åŠ¨ç›‘æ§çº¿ç¨‹
        self.monitoring_thread = threading.Thread(target=self._monitor_events, daemon=True)
        self.monitoring_thread.start()

    def add_event(self, event_type: str, event_data: Dict[str, Any]):
        """æ·»åŠ å®‰å…¨äº‹ä»¶"""
        event = {
            "timestamp": time.time(),
            "type": event_type,
            "data": event_data
        }

        self.event_queue.append(event)
        self._analyze_event(event)

    def _analyze_event(self, event: Dict[str, Any]):
        """åˆ†æå®‰å…¨äº‹ä»¶"""
        event_type = event["type"]
        event_data = event["data"]

        if event_type == "failed_login":
            self._handle_failed_login(event_data)
        elif event_type == "api_request":
            self._handle_api_request(event_data)
        elif event_type == "suspicious_activity":
            self._handle_suspicious_activity(event_data)

    def _handle_failed_login(self, event_data: Dict[str, Any]):
        """å¤„ç†ç™»å½•å¤±è´¥äº‹ä»¶"""
        user_id = event_data.get("user_id", "unknown")
        ip_address = event_data.get("ip_address", "unknown")

        key = f"failed_login_{user_id}_{ip_address}"
        self.counters[key] += 1

        if self.counters[key] >= self.thresholds["failed_login_attempts"]:
            self._trigger_alert("multiple_failed_logins", {
                "user_id": user_id,
                "ip_address": ip_address,
                "attempts": self.counters[key]
            })

    def _handle_api_request(self, event_data: Dict[str, Any]):
        """å¤„ç†APIè¯·æ±‚äº‹ä»¶"""
        user_id = event_data.get("user_id", "anonymous")
        ip_address = event_data.get("ip_address", "unknown")
        endpoint = event_data.get("endpoint", "")

# æ£€æŸ¥IPé»‘åå•
        if ip_address in self.ip_blacklist:
            self._trigger_alert("blacklisted_ip_access", {
                "ip_address": ip_address,
                "user_id": user_id,
                "endpoint": endpoint
            })
            return

# é€Ÿç‡é™åˆ¶æ£€æŸ¥
        key = f"api_rate_{user_id}_{ip_address}"
        self.counters[key] += 1

        if self.counters[key] > self.thresholds["api_rate_limit"]:
            self._trigger_alert("rate_limit_exceeded", {
                "user_id": user_id,
                "ip_address": ip_address,
                "requests": self.counters[key]
            })

    def _handle_suspicious_activity(self, event_data: Dict[str, Any]):
        """å¤„ç†å¯ç–‘æ´»åŠ¨äº‹ä»¶"""
        user_id = event_data.get("user_id", "unknown")
        activity_type = event_data.get("activity_type", "")

        self.user_suspicious_activity[user_id].append({
            "timestamp": time.time(),
            "activity_type": activity_type,
            "details": event_data
        })

# æ£€æŸ¥å¯ç–‘æ´»åŠ¨æ¨¡å¼
        recent_activities = [
            activity for activity in self.user_suspicious_activity[user_id]
            if time.time() - activity["timestamp"] < 3600  # 1å°æ—¶å†…
        ]

        if len(recent_activities) >= self.thresholds["suspicious_ip_attempts"]:
            self._trigger_alert("suspicious_user_activity", {
                "user_id": user_id,
                "activities": recent_activities
            })

    def _trigger_alert(self, alert_type: str, alert_data: Dict[str, Any]):
        """è§¦å‘å®‰å…¨å‘Šè­¦"""
        alert = {
            "timestamp": time.time(),
            "type": alert_type,
            "data": alert_data,
            "severity": self._get_alert_severity(alert_type)
        }

# é€šçŸ¥æ‰€æœ‰å‘Šè­¦å¤„ç†å™¨
        for handler in self.alert_handlers:
            try:
                handler(alert)
            except Exception as e:
                logger.error(f"å‘Šè­¦å¤„ç†å™¨å¤±è´¥: {e}")

    def _get_alert_severity(self, alert_type: str) -> str:
        """è·å–å‘Šè­¦ä¸¥é‡ç¨‹åº¦"""
        high_severity = ["multiple_failed_logins", "blacklisted_ip_access"]
        medium_severity = ["rate_limit_exceeded", "suspicious_user_activity"]

        if alert_type in high_severity:
            return "HIGH"
        elif alert_type in medium_severity:
            return "MEDIUM"
        else:
            return "LOW"

    def add_alert_handler(self, handler: Callable[[Dict[str, Any]], None]):
        """æ·»åŠ å‘Šè­¦å¤„ç†å™¨"""
        self.alert_handlers.append(handler)

    def blacklist_ip(self, ip_address: str, reason: str = ""):
        """å°†IPåŠ å…¥é»‘åå•"""
        self.ip_blacklist.add(ip_address)
        logger.warning(f"IP {ip_address} å·²åŠ å…¥é»‘åå•: {reason}")

    def whitelist_ip(self, ip_address: str):
        """å°†IPä»é»‘åå•ç§»é™¤"""
        self.ip_blacklist.discard(ip_address)
        logger.info(f"IP {ip_address} å·²ä»é»‘åå•ç§»é™¤")

    def _monitor_events(self):
        """ç›‘æ§äº‹ä»¶çº¿ç¨‹"""
        while True:
            try:
# æ¸…ç†è¿‡æœŸè®¡æ•°å™¨
                current_time = time.time()
                expired_keys = []

                for key, count in self.counters.items():
# ç®€å•çš„è¿‡æœŸç­–ç•¥ï¼šæ¯å°æ—¶é‡ç½®è®¡æ•°å™¨
                    if "rate" in key and current_time % 3600 < 60:
                        expired_keys.append(key)

                for key in expired_keys:
                    del self.counters[key]

                time.sleep(60)  # æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡

            except Exception as e:
                logger.error(f"ç›‘æ§çº¿ç¨‹é”™è¯¯: {e}")
                time.sleep(60)

# å‘Šè­¦å¤„ç†å™¨ç¤ºä¾‹
def email_alert_handler(alert: Dict[str, Any]):
    """é‚®ä»¶å‘Šè­¦å¤„ç†å™¨"""
    print(f"å®‰å…¨å‘Šè­¦: {alert['type']} - {alert['data']}")

def log_alert_handler(alert: Dict[str, Any]):
    """æ—¥å¿—å‘Šè­¦å¤„ç†å™¨"""
    logger.warning(f"å®‰å…¨å‘Šè­¦ [{alert['severity']}]: {alert['type']} - {alert['data']}")

# ä½¿ç”¨ç¤ºä¾‹
security_monitor = SecurityMonitor()

# æ·»åŠ å‘Šè­¦å¤„ç†å™¨
security_monitor.add_alert_handler(email_alert_handler)
security_monitor.add_alert_handler(log_alert_handler)

# æ¨¡æ‹Ÿå®‰å…¨äº‹ä»¶
security_monitor.add_event("failed_login", {
    "user_id": "user123",
    "ip_address": "192.168.1.100",
    "reason": "invalid_password"
})

security_monitor.add_event("api_request", {
    "user_id": "user123",
    "ip_address": "192.168.1.100",
    "endpoint": "/api/nodes",
    "method": "GET"
})
```

## 7. å·¥å…·ä¸å¹³å°

### 7.1. å®‰å…¨å·¥å…·

1. **OWASP ZAP**ï¼šWebåº”ç”¨å®‰å…¨æµ‹è¯•
2. **Nmap**ï¼šç½‘ç»œæ‰«æå·¥å…·
3. **Wireshark**ï¼šç½‘ç»œåè®®åˆ†æ
4. **Metasploit**ï¼šæ¸—é€æµ‹è¯•æ¡†æ¶

### 7.2. ç›‘æ§å·¥å…·

1. **ELK Stack**ï¼šæ—¥å¿—åˆ†æå¹³å°
2. **Splunk**ï¼šå®‰å…¨ä¿¡æ¯å’Œäº‹ä»¶ç®¡ç†
3. **Wazuh**ï¼šå¼€æºå®‰å…¨å¹³å°
4. **OSSEC**ï¼šå…¥ä¾µæ£€æµ‹ç³»ç»Ÿ

### 7.3. äº‘å®‰å…¨æœåŠ¡

1. **AWS Security Hub**ï¼šå®‰å…¨ä¸­å¿ƒ
2. **Azure Security Center**ï¼šå®‰å…¨ä¸­å¿ƒ
3. **Google Cloud Security Command Center**ï¼šå®‰å…¨æŒ‡æŒ¥ä¸­å¿ƒ
4. **é˜¿é‡Œäº‘å®‰å…¨ä¸­å¿ƒ**ï¼šå®‰å…¨ä¸­å¿ƒ

## 8. æœ€ä½³å®è·µ

### 8.1. èº«ä»½è®¤è¯

1. **å¤šå› ç´ è®¤è¯**ï¼šä½¿ç”¨MFAå¢å¼ºå®‰å…¨æ€§
2. **å¯†ç ç­–ç•¥**ï¼šå¼ºå¯†ç è¦æ±‚å’Œå®šæœŸæ›´æ¢
3. **ä¼šè¯ç®¡ç†**ï¼šå®‰å…¨çš„ä¼šè¯è¶…æ—¶å’Œä»¤ç‰Œç®¡ç†
4. **å•ç‚¹ç™»å½•**ï¼šSSOé›†æˆ

### 8.2. è®¿é—®æ§åˆ¶

1. **æœ€å°æƒé™åŸåˆ™**ï¼šåªæˆäºˆå¿…è¦æƒé™
2. **è§’è‰²åˆ†ç¦»**ï¼šèŒè´£åˆ†ç¦»å’Œæƒé™éš”ç¦»
3. **åŠ¨æ€æˆæƒ**ï¼šåŸºäºä¸Šä¸‹æ–‡çš„è®¿é—®æ§åˆ¶
4. **æƒé™å®¡è®¡**ï¼šå®šæœŸå®¡æŸ¥æƒé™åˆ†é…

### 8.3. æ•°æ®ä¿æŠ¤

1. **æ•°æ®åˆ†ç±»**ï¼šæ•æ„Ÿæ•°æ®è¯†åˆ«å’Œåˆ†ç±»
2. **åŠ å¯†å­˜å‚¨**ï¼šé™æ€æ•°æ®åŠ å¯†
3. **ä¼ è¾“åŠ å¯†**ï¼šTLS/SSLåŠ å¯†ä¼ è¾“
4. **æ•°æ®è„±æ•**ï¼šæ•æ„Ÿæ•°æ®è„±æ•å¤„ç†

### 8.4. å®‰å…¨ç›‘æ§

1. **å®æ—¶ç›‘æ§**ï¼š24/7å®‰å…¨ç›‘æ§
2. **å¼‚å¸¸æ£€æµ‹**ï¼šæœºå™¨å­¦ä¹ å¼‚å¸¸æ£€æµ‹
3. **å¨èƒæƒ…æŠ¥**ï¼šå¨èƒæƒ…æŠ¥é›†æˆ
4. **äº‹ä»¶å“åº”**ï¼šå¿«é€Ÿå®‰å…¨äº‹ä»¶å“åº”
