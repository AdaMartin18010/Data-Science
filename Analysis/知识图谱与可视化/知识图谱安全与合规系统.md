# 知识图谱安全与合规系统

## 安全架构设计

### 1. 多层安全防护体系

```python
import asyncio
import logging
import hashlib
import hmac
import jwt
import bcrypt
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass
from datetime import datetime, timedelta
from enum import Enum
import json
import ssl
import cryptography
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC

class SecurityLevel(Enum):
    """安全级别"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

class ComplianceType(Enum):
    """合规类型"""
    GDPR = "gdpr"
    CCPA = "ccpa"
    HIPAA = "hipaa"
    SOX = "sox"
    ISO27001 = "iso27001"

@dataclass
class SecurityPolicy:
    """安全策略"""
    id: str
    name: str
    description: str
    security_level: SecurityLevel
    compliance_types: List[ComplianceType]
    rules: List[Dict[str, Any]]
    enabled: bool = True

@dataclass
class ComplianceRule:
    """合规规则"""
    id: str
    name: str
    description: str
    compliance_type: ComplianceType
    requirements: List[str]
    validation_logic: str
    severity: SecurityLevel

class MultiLayerSecuritySystem:
    """多层安全防护系统"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.logger = logging.getLogger(__name__)
        self.security_policies: Dict[str, SecurityPolicy] = {}
        self.compliance_rules: Dict[str, ComplianceRule] = {}
        self.encryption_manager = EncryptionManager()
        self.access_control = AccessControlManager()
        self.audit_logger = AuditLogger()
        self.threat_detector = ThreatDetector()
        
    async def initialize(self):
        """初始化安全系统"""
        await self._load_security_policies()
        await self._load_compliance_rules()
        await self.encryption_manager.initialize()
        await self.access_control.initialize()
        await self.audit_logger.initialize()
        await self.threat_detector.initialize()
        
    async def _load_security_policies(self):
        """加载安全策略"""
        default_policies = [
            SecurityPolicy(
                id="data_encryption",
                name="数据加密策略",
                description="确保所有敏感数据在传输和存储时加密",
                security_level=SecurityLevel.HIGH,
                compliance_types=[ComplianceType.GDPR, ComplianceType.HIPAA],
                rules=[
                    {"type": "encryption", "algorithm": "AES-256", "required": True},
                    {"type": "key_rotation", "interval": "90d", "required": True}
                ]
            ),
            
            SecurityPolicy(
                id="access_control",
                name="访问控制策略",
                description="基于角色的细粒度访问控制",
                security_level=SecurityLevel.HIGH,
                compliance_types=[ComplianceType.GDPR, ComplianceType.SOX],
                rules=[
                    {"type": "rbac", "enabled": True},
                    {"type": "mfa", "required": True},
                    {"type": "session_timeout", "duration": "8h"}
                ]
            ),
            
            SecurityPolicy(
                id="audit_logging",
                name="审计日志策略",
                description="记录所有安全相关事件和操作",
                security_level=SecurityLevel.MEDIUM,
                compliance_types=[ComplianceType.SOX, ComplianceType.ISO27001],
                rules=[
                    {"type": "event_logging", "enabled": True},
                    {"type": "log_retention", "duration": "7y"},
                    {"type": "log_integrity", "enabled": True}
                ]
            ),
            
            SecurityPolicy(
                id="data_classification",
                name="数据分类策略",
                description="对数据进行分类和标记",
                security_level=SecurityLevel.MEDIUM,
                compliance_types=[ComplianceType.GDPR, ComplianceType.CCPA],
                rules=[
                    {"type": "classification", "levels": ["public", "internal", "confidential", "restricted"]},
                    {"type": "labeling", "required": True}
                ]
            ),
            
            SecurityPolicy(
                id="threat_detection",
                name="威胁检测策略",
                description="实时检测和响应安全威胁",
                security_level=SecurityLevel.CRITICAL,
                compliance_types=[ComplianceType.ISO27001],
                rules=[
                    {"type": "anomaly_detection", "enabled": True},
                    {"type": "intrusion_detection", "enabled": True},
                    {"type": "response_time", "max_duration": "5m"}
                ]
            )
        ]
        
        for policy in default_policies:
            self.security_policies[policy.id] = policy
            
    async def _load_compliance_rules(self):
        """加载合规规则"""
        default_rules = [
            ComplianceRule(
                id="gdpr_data_minimization",
                name="GDPR数据最小化",
                description="只收集和处理必要的数据",
                compliance_type=ComplianceType.GDPR,
                requirements=[
                    "数据收集必须明确目的",
                    "数据使用必须与收集目的一致",
                    "定期审查数据必要性"
                ],
                validation_logic="check_data_purpose_alignment",
                severity=SecurityLevel.HIGH
            ),
            
            ComplianceRule(
                id="gdpr_consent_management",
                name="GDPR同意管理",
                description="确保获得有效的用户同意",
                compliance_type=ComplianceType.GDPR,
                requirements=[
                    "明确、具体的同意请求",
                    "可撤销的同意机制",
                    "同意记录保存"
                ],
                validation_logic="validate_consent_records",
                severity=SecurityLevel.HIGH
            ),
            
            ComplianceRule(
                id="hipaa_data_protection",
                name="HIPAA数据保护",
                description="保护医疗健康信息的隐私和安全",
                compliance_type=ComplianceType.HIPAA,
                requirements=[
                    "PHI数据加密存储",
                    "访问控制机制",
                    "审计日志记录"
                ],
                validation_logic="check_phi_protection",
                severity=SecurityLevel.CRITICAL
            ),
            
            ComplianceRule(
                id="sox_financial_controls",
                name="SOX财务控制",
                description="确保财务数据的准确性和完整性",
                compliance_type=ComplianceType.SOX,
                requirements=[
                    "财务数据访问控制",
                    "数据完整性验证",
                    "变更审计跟踪"
                ],
                validation_logic="validate_financial_controls",
                severity=SecurityLevel.HIGH
            )
        ]
        
        for rule in default_rules:
            self.compliance_rules[rule.id] = rule
```

### 2. 加密管理系统

```python
class EncryptionManager:
    """加密管理器"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.master_key = None
        self.fernet = None
        self.key_rotation_schedule = {}
        
    async def initialize(self):
        """初始化加密管理器"""
        # 生成或加载主密钥
        self.master_key = await self._generate_or_load_master_key()
        self.fernet = Fernet(self.master_key)
        
        # 设置密钥轮换计划
        await self._setup_key_rotation()
        
    async def _generate_or_load_master_key(self) -> bytes:
        """生成或加载主密钥"""
        key_file = "master_key.key"
        
        try:
            with open(key_file, "rb") as f:
                return f.read()
        except FileNotFoundError:
            # 生成新密钥
            key = Fernet.generate_key()
            with open(key_file, "wb") as f:
                f.write(key)
            return key
            
    async def _setup_key_rotation(self):
        """设置密钥轮换"""
        # 每90天轮换一次密钥
        self.key_rotation_schedule = {
            "interval": 90,
            "last_rotation": datetime.now(),
            "next_rotation": datetime.now() + timedelta(days=90)
        }
        
    async def encrypt_data(self, data: str, context: str = "default") -> Dict[str, Any]:
        """加密数据"""
        try:
            # 添加上下文信息
            data_with_context = {
                "data": data,
                "context": context,
                "timestamp": datetime.now().isoformat()
            }
            
            # 序列化并加密
            json_data = json.dumps(data_with_context)
            encrypted_data = self.fernet.encrypt(json_data.encode())
            
            # 生成数据完整性校验
            integrity_hash = hashlib.sha256(encrypted_data).hexdigest()
            
            return {
                "encrypted_data": encrypted_data.hex(),
                "integrity_hash": integrity_hash,
                "encryption_algorithm": "AES-256",
                "timestamp": datetime.now().isoformat()
            }
            
        except Exception as e:
            self.logger.error(f"数据加密失败: {e}")
            raise
            
    async def decrypt_data(self, encrypted_info: Dict[str, Any]) -> str:
        """解密数据"""
        try:
            # 验证数据完整性
            encrypted_data = bytes.fromhex(encrypted_info["encrypted_data"])
            expected_hash = encrypted_info["integrity_hash"]
            actual_hash = hashlib.sha256(encrypted_data).hexdigest()
            
            if expected_hash != actual_hash:
                raise ValueError("数据完整性验证失败")
                
            # 解密数据
            decrypted_data = self.fernet.decrypt(encrypted_data)
            data_with_context = json.loads(decrypted_data.decode())
            
            return data_with_context["data"]
            
        except Exception as e:
            self.logger.error(f"数据解密失败: {e}")
            raise
            
    async def rotate_keys(self):
        """轮换密钥"""
        try:
            # 生成新密钥
            new_key = Fernet.generate_key()
            new_fernet = Fernet(new_key)
            
            # 重新加密所有数据（这里需要实现数据迁移逻辑）
            await self._migrate_encrypted_data(new_fernet)
            
            # 更新主密钥
            self.master_key = new_key
            self.fernet = new_fernet
            
            # 更新轮换计划
            self.key_rotation_schedule["last_rotation"] = datetime.now()
            self.key_rotation_schedule["next_rotation"] = datetime.now() + timedelta(days=90)
            
            self.logger.info("密钥轮换完成")
            
        except Exception as e:
            self.logger.error(f"密钥轮换失败: {e}")
            raise
            
    async def _migrate_encrypted_data(self, new_fernet: Fernet):
        """迁移加密数据"""
        # 实现数据迁移逻辑
        # 这里需要根据具体的数据存储方式来实现
        pass
```

### 3. 访问控制管理器

```python
class AccessControlManager:
    """访问控制管理器"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.roles: Dict[str, Dict[str, Any]] = {}
        self.permissions: Dict[str, List[str]] = {}
        self.sessions: Dict[str, Dict[str, Any]] = {}
        
    async def initialize(self):
        """初始化访问控制"""
        await self._load_default_roles()
        await self._load_default_permissions()
        
    async def _load_default_roles(self):
        """加载默认角色"""
        self.roles = {
            "admin": {
                "name": "管理员",
                "description": "系统管理员，拥有所有权限",
                "permissions": ["*"],
                "security_level": SecurityLevel.CRITICAL
            },
            "data_scientist": {
                "name": "数据科学家",
                "description": "数据分析和模型开发",
                "permissions": [
                    "read:knowledge_graph",
                    "write:analysis_results",
                    "execute:queries",
                    "read:public_data"
                ],
                "security_level": SecurityLevel.HIGH
            },
            "analyst": {
                "name": "分析师",
                "description": "业务数据分析",
                "permissions": [
                    "read:knowledge_graph",
                    "execute:queries",
                    "read:public_data"
                ],
                "security_level": SecurityLevel.MEDIUM
            },
            "viewer": {
                "name": "查看者",
                "description": "只读访问权限",
                "permissions": [
                    "read:public_data"
                ],
                "security_level": SecurityLevel.LOW
            }
        }
        
    async def _load_default_permissions(self):
        """加载默认权限"""
        self.permissions = {
            "read:knowledge_graph": "读取知识图谱数据",
            "write:knowledge_graph": "写入知识图谱数据",
            "delete:knowledge_graph": "删除知识图谱数据",
            "execute:queries": "执行查询操作",
            "read:analysis_results": "读取分析结果",
            "write:analysis_results": "写入分析结果",
            "read:public_data": "读取公开数据",
            "admin:users": "用户管理",
            "admin:security": "安全管理"
        }
        
    async def authenticate_user(self, username: str, password: str, mfa_code: Optional[str] = None) -> Dict[str, Any]:
        """用户认证"""
        try:
            # 验证用户名和密码
            user_info = await self._verify_credentials(username, password)
            
            if not user_info:
                return {"success": False, "error": "用户名或密码错误"}
                
            # 验证MFA（如果启用）
            if user_info.get("mfa_enabled") and mfa_code:
                if not await self._verify_mfa(username, mfa_code):
                    return {"success": False, "error": "MFA验证失败"}
                    
            # 生成会话令牌
            session_token = await self._generate_session_token(user_info)
            
            # 记录会话
            self.sessions[session_token] = {
                "user_id": user_info["id"],
                "username": username,
                "roles": user_info["roles"],
                "created_at": datetime.now(),
                "expires_at": datetime.now() + timedelta(hours=8)
            }
            
            return {
                "success": True,
                "session_token": session_token,
                "user_info": {
                    "id": user_info["id"],
                    "username": username,
                    "roles": user_info["roles"]
                }
            }
            
        except Exception as e:
            self.logger.error(f"用户认证失败: {e}")
            return {"success": False, "error": "认证过程出错"}
            
    async def _verify_credentials(self, username: str, password: str) -> Optional[Dict[str, Any]]:
        """验证用户凭据"""
        # 这里应该连接到用户数据库进行验证
        # 简化实现
        if username == "admin" and password == "admin123":
            return {
                "id": "1",
                "username": username,
                "roles": ["admin"],
                "mfa_enabled": True
            }
        return None
        
    async def _verify_mfa(self, username: str, mfa_code: str) -> bool:
        """验证MFA代码"""
        # 简化实现
        return mfa_code == "123456"
        
    async def _generate_session_token(self, user_info: Dict[str, Any]) -> str:
        """生成会话令牌"""
        payload = {
            "user_id": user_info["id"],
            "username": user_info["username"],
            "roles": user_info["roles"],
            "exp": datetime.now() + timedelta(hours=8)
        }
        
        # 使用JWT生成令牌
        token = jwt.encode(payload, "secret_key", algorithm="HS256")
        return token
        
    async def verify_permission(self, session_token: str, permission: str) -> bool:
        """验证权限"""
        try:
            # 验证会话令牌
            session = self.sessions.get(session_token)
            if not session:
                return False
                
            # 检查会话是否过期
            if datetime.now() > session["expires_at"]:
                del self.sessions[session_token]
                return False
                
            # 检查用户角色权限
            user_roles = session["roles"]
            
            for role in user_roles:
                role_permissions = self.roles[role]["permissions"]
                
                # 检查通配符权限
                if "*" in role_permissions:
                    return True
                    
                # 检查具体权限
                if permission in role_permissions:
                    return True
                    
            return False
            
        except Exception as e:
            self.logger.error(f"权限验证失败: {e}")
            return False
            
    async def revoke_session(self, session_token: str):
        """撤销会话"""
        if session_token in self.sessions:
            del self.sessions[session_token]
            
    async def get_user_permissions(self, session_token: str) -> List[str]:
        """获取用户权限列表"""
        session = self.sessions.get(session_token)
        if not session:
            return []
            
        permissions = []
        for role in session["roles"]:
            role_permissions = self.roles[role]["permissions"]
            if "*" in role_permissions:
                return list(self.permissions.keys())
            permissions.extend(role_permissions)
            
        return list(set(permissions))
```

### 4. 审计日志系统

```python
class AuditLogger:
    """审计日志系统"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.audit_events: List[Dict[str, Any]] = []
        
    async def initialize(self):
        """初始化审计日志"""
        # 设置日志文件
        logging.basicConfig(
            filename="audit.log",
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s'
        )
        
    async def log_event(self, event_type: str, user_id: str, action: str, 
                       resource: str, details: Dict[str, Any] = None):
        """记录审计事件"""
        event = {
            "timestamp": datetime.now().isoformat(),
            "event_type": event_type,
            "user_id": user_id,
            "action": action,
            "resource": resource,
            "details": details or {},
            "session_id": details.get("session_id") if details else None,
            "ip_address": details.get("ip_address") if details else None
        }
        
        # 添加到内存列表
        self.audit_events.append(event)
        
        # 写入日志文件
        log_message = f"EVENT: {event_type} | USER: {user_id} | ACTION: {action} | RESOURCE: {resource}"
        self.logger.info(log_message)
        
        # 如果事件数量超过限制，清理旧事件
        if len(self.audit_events) > 10000:
            self.audit_events = self.audit_events[-5000:]
            
    async def search_events(self, filters: Dict[str, Any]) -> List[Dict[str, Any]]:
        """搜索审计事件"""
        filtered_events = []
        
        for event in self.audit_events:
            match = True
            
            # 应用过滤器
            for key, value in filters.items():
                if key in event and event[key] != value:
                    match = False
                    break
                    
            if match:
                filtered_events.append(event)
                
        return filtered_events
        
    async def generate_audit_report(self, start_date: datetime, end_date: datetime) -> Dict[str, Any]:
        """生成审计报告"""
        events_in_range = [
            event for event in self.audit_events
            if start_date <= datetime.fromisoformat(event["timestamp"]) <= end_date
        ]
        
        # 统计事件类型
        event_type_counts = {}
        user_activity_counts = {}
        action_counts = {}
        
        for event in events_in_range:
            # 事件类型统计
            event_type = event["event_type"]
            event_type_counts[event_type] = event_type_counts.get(event_type, 0) + 1
            
            # 用户活动统计
            user_id = event["user_id"]
            user_activity_counts[user_id] = user_activity_counts.get(user_id, 0) + 1
            
            # 操作类型统计
            action = event["action"]
            action_counts[action] = action_counts.get(action, 0) + 1
            
        return {
            "period": {
                "start_date": start_date.isoformat(),
                "end_date": end_date.isoformat()
            },
            "total_events": len(events_in_range),
            "event_type_distribution": event_type_counts,
            "user_activity": user_activity_counts,
            "action_distribution": action_counts,
            "events": events_in_range
        }
```

### 5. 威胁检测系统

```python
class ThreatDetector:
    """威胁检测系统"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.threat_patterns: List[Dict[str, Any]] = []
        self.anomaly_detectors: Dict[str, Any] = {}
        
    async def initialize(self):
        """初始化威胁检测"""
        await self._load_threat_patterns()
        await self._setup_anomaly_detectors()
        
    async def _load_threat_patterns(self):
        """加载威胁模式"""
        self.threat_patterns = [
            {
                "id": "brute_force_attack",
                "name": "暴力破解攻击",
                "description": "检测多次失败的登录尝试",
                "pattern": {
                    "event_type": "authentication_failure",
                    "threshold": 5,
                    "time_window": 300,  # 5分钟
                    "severity": SecurityLevel.HIGH
                }
            },
            {
                "id": "data_exfiltration",
                "name": "数据泄露",
                "description": "检测异常的数据访问模式",
                "pattern": {
                    "event_type": "data_access",
                    "threshold": 1000,
                    "time_window": 3600,  # 1小时
                    "severity": SecurityLevel.CRITICAL
                }
            },
            {
                "id": "privilege_escalation",
                "name": "权限提升",
                "description": "检测异常的权限使用",
                "pattern": {
                    "event_type": "permission_use",
                    "threshold": 10,
                    "time_window": 1800,  # 30分钟
                    "severity": SecurityLevel.HIGH
                }
            },
            {
                "id": "session_hijacking",
                "name": "会话劫持",
                "description": "检测异常的会话活动",
                "pattern": {
                    "event_type": "session_activity",
                    "threshold": 3,
                    "time_window": 600,  # 10分钟
                    "severity": SecurityLevel.CRITICAL
                }
            }
        ]
        
    async def _setup_anomaly_detectors(self):
        """设置异常检测器"""
        self.anomaly_detectors = {
            "user_behavior": UserBehaviorAnomalyDetector(),
            "network_traffic": NetworkTrafficAnomalyDetector(),
            "data_access": DataAccessAnomalyDetector()
        }
        
    async def detect_threats(self, events: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """检测威胁"""
        detected_threats = []
        
        # 基于模式的威胁检测
        for pattern in self.threat_patterns:
            threats = await self._check_pattern_threats(events, pattern)
            detected_threats.extend(threats)
            
        # 基于异常的威胁检测
        for detector_name, detector in self.anomaly_detectors.items():
            anomalies = await detector.detect_anomalies(events)
            for anomaly in anomalies:
                detected_threats.append({
                    "type": "anomaly",
                    "detector": detector_name,
                    "anomaly": anomaly,
                    "severity": SecurityLevel.MEDIUM,
                    "timestamp": datetime.now().isoformat()
                })
                
        return detected_threats
        
    async def _check_pattern_threats(self, events: List[Dict[str, Any]], pattern: Dict[str, Any]) -> List[Dict[str, Any]]:
        """检查基于模式的威胁"""
        threats = []
        pattern_config = pattern["pattern"]
        
        # 过滤相关事件
        relevant_events = [
            event for event in events
            if event.get("event_type") == pattern_config["event_type"]
        ]
        
        # 按时间窗口分组
        time_window = pattern_config["time_window"]
        current_time = datetime.now()
        
        for event in relevant_events:
            event_time = datetime.fromisoformat(event["timestamp"])
            if (current_time - event_time).total_seconds() <= time_window:
                # 检查是否超过阈值
                similar_events = [
                    e for e in relevant_events
                    if (current_time - datetime.fromisoformat(e["timestamp"])).total_seconds() <= time_window
                ]
                
                if len(similar_events) >= pattern_config["threshold"]:
                    threats.append({
                        "type": "pattern",
                        "pattern_id": pattern["id"],
                        "pattern_name": pattern["name"],
                        "events": similar_events,
                        "severity": pattern_config["severity"],
                        "timestamp": datetime.now().isoformat()
                    })
                    
        return threats

class UserBehaviorAnomalyDetector:
    """用户行为异常检测器"""
    
    def __init__(self):
        self.user_profiles = {}
        
    async def detect_anomalies(self, events: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """检测用户行为异常"""
        anomalies = []
        
        # 按用户分组事件
        user_events = {}
        for event in events:
            user_id = event.get("user_id")
            if user_id:
                if user_id not in user_events:
                    user_events[user_id] = []
                user_events[user_id].append(event)
                
        # 分析每个用户的行为
        for user_id, user_event_list in user_events.items():
            user_anomalies = await self._analyze_user_behavior(user_id, user_event_list)
            anomalies.extend(user_anomalies)
            
        return anomalies
        
    async def _analyze_user_behavior(self, user_id: str, events: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """分析用户行为"""
        anomalies = []
        
        # 分析登录时间模式
        login_events = [e for e in events if e.get("action") == "login"]
        if len(login_events) > 0:
            login_times = [datetime.fromisoformat(e["timestamp"]) for e in login_events]
            if await self._is_unusual_login_time(login_times):
                anomalies.append({
                    "type": "unusual_login_time",
                    "user_id": user_id,
                    "details": {"login_times": [t.isoformat() for t in login_times]}
                })
                
        # 分析访问模式
        access_events = [e for e in events if e.get("action") == "access"]
        if len(access_events) > 10:
            if await self._is_unusual_access_pattern(access_events):
                anomalies.append({
                    "type": "unusual_access_pattern",
                    "user_id": user_id,
                    "details": {"access_count": len(access_events)}
                })
                
        return anomalies
        
    async def _is_unusual_login_time(self, login_times: List[datetime]) -> bool:
        """检查是否为异常登录时间"""
        # 简化实现：检查是否在非工作时间登录
        for login_time in login_times:
            hour = login_time.hour
            if hour < 6 or hour > 22:  # 非工作时间
                return True
        return False
        
    async def _is_unusual_access_pattern(self, access_events: List[Dict[str, Any]]) -> bool:
        """检查是否为异常访问模式"""
        # 简化实现：检查访问频率
        if len(access_events) > 50:  # 短时间内大量访问
            return True
        return False

class NetworkTrafficAnomalyDetector:
    """网络流量异常检测器"""
    
    def __init__(self):
        self.traffic_baseline = {}
        
    async def detect_anomalies(self, events: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """检测网络流量异常"""
        # 简化实现
        return []

class DataAccessAnomalyDetector:
    """数据访问异常检测器"""
    
    def __init__(self):
        self.access_patterns = {}
        
    async def detect_anomalies(self, events: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """检测数据访问异常"""
        anomalies = []
        
        # 分析数据访问事件
        data_access_events = [e for e in events if e.get("action") == "data_access"]
        
        for event in data_access_events:
            # 检查是否访问了敏感数据
            if await self._is_sensitive_data_access(event):
                anomalies.append({
                    "type": "sensitive_data_access",
                    "user_id": event.get("user_id"),
                    "resource": event.get("resource"),
                    "details": {"sensitivity_level": "high"}
                })
                
        return anomalies
        
    async def _is_sensitive_data_access(self, event: Dict[str, Any]) -> bool:
        """检查是否为敏感数据访问"""
        resource = event.get("resource", "")
        sensitive_keywords = ["password", "credit_card", "ssn", "medical", "confidential"]
        
        return any(keyword in resource.lower() for keyword in sensitive_keywords)
```

### 6. 合规监控系统

```python
class ComplianceMonitor:
    """合规监控系统"""
    
    def __init__(self, security_system: MultiLayerSecuritySystem):
        self.security_system = security_system
        self.logger = logging.getLogger(__name__)
        self.compliance_status: Dict[str, Dict[str, Any]] = {}
        
    async def check_compliance(self, compliance_type: ComplianceType) -> Dict[str, Any]:
        """检查合规状态"""
        compliance_rules = [
            rule for rule in self.security_system.compliance_rules.values()
            if rule.compliance_type == compliance_type
        ]
        
        compliance_results = []
        overall_status = "compliant"
        
        for rule in compliance_rules:
            result = await self._validate_compliance_rule(rule)
            compliance_results.append(result)
            
            if result["status"] == "non_compliant":
                overall_status = "non_compliant"
            elif result["status"] == "warning" and overall_status == "compliant":
                overall_status = "warning"
                
        return {
            "compliance_type": compliance_type.value,
            "overall_status": overall_status,
            "rules": compliance_results,
            "checked_at": datetime.now().isoformat()
        }
        
    async def _validate_compliance_rule(self, rule: ComplianceRule) -> Dict[str, Any]:
        """验证合规规则"""
        try:
            # 根据规则类型执行验证
            if rule.validation_logic == "check_data_purpose_alignment":
                result = await self._check_data_purpose_alignment()
            elif rule.validation_logic == "validate_consent_records":
                result = await self._validate_consent_records()
            elif rule.validation_logic == "check_phi_protection":
                result = await self._check_phi_protection()
            elif rule.validation_logic == "validate_financial_controls":
                result = await self._validate_financial_controls()
            else:
                result = {"status": "unknown", "details": "未知验证逻辑"}
                
            return {
                "rule_id": rule.id,
                "rule_name": rule.name,
                "status": result["status"],
                "details": result["details"],
                "severity": rule.severity.value
            }
            
        except Exception as e:
            self.logger.error(f"合规规则验证失败: {rule.id} - {e}")
            return {
                "rule_id": rule.id,
                "rule_name": rule.name,
                "status": "error",
                "details": str(e),
                "severity": rule.severity.value
            }
            
    async def _check_data_purpose_alignment(self) -> Dict[str, Any]:
        """检查数据目的对齐"""
        # 简化实现
        return {
            "status": "compliant",
            "details": "数据收集和使用目的对齐"
        }
        
    async def _validate_consent_records(self) -> Dict[str, Any]:
        """验证同意记录"""
        # 简化实现
        return {
            "status": "compliant",
            "details": "同意记录完整有效"
        }
        
    async def _check_phi_protection(self) -> Dict[str, Any]:
        """检查PHI保护"""
        # 简化实现
        return {
            "status": "compliant",
            "details": "PHI数据得到适当保护"
        }
        
    async def _validate_financial_controls(self) -> Dict[str, Any]:
        """验证财务控制"""
        # 简化实现
        return {
            "status": "compliant",
            "details": "财务控制措施有效"
        }
        
    async def generate_compliance_report(self) -> Dict[str, Any]:
        """生成合规报告"""
        compliance_types = [ComplianceType.GDPR, ComplianceType.HIPAA, ComplianceType.SOX, ComplianceType.CCPA]
        
        report = {
            "generated_at": datetime.now().isoformat(),
            "compliance_status": {}
        }
        
        for compliance_type in compliance_types:
            status = await self.check_compliance(compliance_type)
            report["compliance_status"][compliance_type.value] = status
            
        return report
```

### 7. 安全仪表板

```python
class SecurityDashboard:
    """安全仪表板"""
    
    def __init__(self, security_system: MultiLayerSecuritySystem):
        self.security_system = security_system
        self.compliance_monitor = ComplianceMonitor(security_system)
        self.logger = logging.getLogger(__name__)
        
    async def generate_security_report(self) -> Dict[str, Any]:
        """生成安全报告"""
        # 检查安全策略状态
        policy_status = await self._check_policy_status()
        
        # 检查合规状态
        compliance_report = await self.compliance_monitor.generate_compliance_report()
        
        # 检查威胁状态
        threat_status = await self._check_threat_status()
        
        # 检查访问控制状态
        access_control_status = await self._check_access_control_status()
        
        return {
            "policy_status": policy_status,
            "compliance_status": compliance_report,
            "threat_status": threat_status,
            "access_control_status": access_control_status,
            "overall_security_score": await self._calculate_security_score(),
            "generated_at": datetime.now().isoformat()
        }
        
    async def _check_policy_status(self) -> Dict[str, Any]:
        """检查安全策略状态"""
        policy_status = {
            "total_policies": len(self.security_system.security_policies),
            "enabled_policies": 0,
            "critical_policies": 0,
            "policy_details": []
        }
        
        for policy in self.security_system.security_policies.values():
            if policy.enabled:
                policy_status["enabled_policies"] += 1
                
            if policy.security_level == SecurityLevel.CRITICAL:
                policy_status["critical_policies"] += 1
                
            policy_status["policy_details"].append({
                "id": policy.id,
                "name": policy.name,
                "enabled": policy.enabled,
                "security_level": policy.security_level.value
            })
            
        return policy_status
        
    async def _check_threat_status(self) -> Dict[str, Any]:
        """检查威胁状态"""
        return {
            "active_threats": 0,
            "threat_level": "low",
            "recent_detections": [],
            "threat_patterns": len(self.security_system.threat_detector.threat_patterns)
        }
        
    async def _check_access_control_status(self) -> Dict[str, Any]:
        """检查访问控制状态"""
        return {
            "active_sessions": len(self.security_system.access_control.sessions),
            "total_roles": len(self.security_system.access_control.roles),
            "total_permissions": len(self.security_system.access_control.permissions)
        }
        
    async def _calculate_security_score(self) -> float:
        """计算安全评分"""
        # 简化实现
        return 85.5
        
    async def create_security_dashboard(self) -> str:
        """创建安全仪表板"""
        report = await self.generate_security_report()
        
        html_content = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>安全与合规仪表板</title>
            <meta charset="utf-8">
            <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                .dashboard-header {{ background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%); 
                                   color: white; padding: 20px; border-radius: 10px; margin-bottom: 20px; }}
                .security-score {{ font-size: 3em; font-weight: bold; text-align: center; 
                                  margin: 20px 0; }}
                .score-excellent {{ color: #27ae60; }}
                .score-good {{ color: #f39c12; }}
                .score-poor {{ color: #e74c3c; }}
                .metrics-grid {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); 
                                gap: 20px; margin-bottom: 30px; }}
                .metric-card {{ background: white; border: 1px solid #e0e0e0; border-radius: 8px; 
                              padding: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }}
                .chart-container {{ background: white; padding: 20px; border-radius: 8px; 
                                   box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin: 20px 0; }}
            </style>
        </head>
        <body>
            <div class="dashboard-header">
                <h1>安全与合规仪表板</h1>
                <p>最后更新: {report['generated_at']}</p>
            </div>
            
            <div class="security-score score-good">{report['overall_security_score']}</div>
            <div style="text-align: center; margin-bottom: 30px;">
                <h3>整体安全评分</h3>
            </div>
            
            <div class="metrics-grid">
                <div class="metric-card">
                    <h3>安全策略</h3>
                    <p>总策略数: {report['policy_status']['total_policies']}</p>
                    <p>启用策略: {report['policy_status']['enabled_policies']}</p>
                    <p>关键策略: {report['policy_status']['critical_policies']}</p>
                </div>
                
                <div class="metric-card">
                    <h3>访问控制</h3>
                    <p>活跃会话: {report['access_control_status']['active_sessions']}</p>
                    <p>角色数量: {report['access_control_status']['total_roles']}</p>
                    <p>权限数量: {report['access_control_status']['total_permissions']}</p>
                </div>
                
                <div class="metric-card">
                    <h3>威胁检测</h3>
                    <p>活跃威胁: {report['threat_status']['active_threats']}</p>
                    <p>威胁等级: {report['threat_status']['threat_level']}</p>
                    <p>威胁模式: {report['threat_status']['threat_patterns']}</p>
                </div>
            </div>
            
            <div class="chart-container">
                <h3>合规状态</h3>
                <ul>
        """
        
        for compliance_type, status in report['compliance_status'].items():
            status_class = f"status-{status['overall_status']}"
            html_content += f"""
                    <li><span class="{status_class}">{compliance_type.upper()}: {status['overall_status']}</span></li>
            """
            
        html_content += """
                </ul>
            </div>
        </body>
        </html>
        """
        
        # 保存仪表板
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        dashboard_file = f"security_dashboard_{timestamp}.html"
        
        with open(dashboard_file, 'w', encoding='utf-8') as f:
            f.write(html_content)
            
        self.logger.info(f"安全仪表板已生成: {dashboard_file}")
        return dashboard_file

# 主安全协调器
class SecurityComplianceOrchestrator:
    """安全合规协调器"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.logger = logging.getLogger(__name__)
        
    async def initialize_security_system(self):
        """初始化安全系统"""
        # 创建多层安全系统
        self.security_system = MultiLayerSecuritySystem(self.config)
        self.dashboard = SecurityDashboard(self.security_system)
        
        # 初始化组件
        await self.security_system.initialize()
        
        self.logger.info("安全与合规系统初始化完成")
        
    async def run_security_checks(self):
        """运行安全检查"""
        # 执行威胁检测
        events = []  # 从审计日志获取事件
        threats = await self.security_system.threat_detector.detect_threats(events)
        
        # 检查合规状态
        compliance_monitor = ComplianceMonitor(self.security_system)
        compliance_report = await compliance_monitor.generate_compliance_report()
        
        # 生成安全报告
        await self.dashboard.generate_security_report()
        
    async def create_security_dashboard(self) -> str:
        """创建安全仪表板"""
        return await self.dashboard.create_security_dashboard()

# 配置示例
SECURITY_CONFIG = {
    "encryption": {
        "algorithm": "AES-256",
        "key_rotation_interval": 90
    },
    "access_control": {
        "session_timeout": 8,
        "mfa_required": True,
        "max_login_attempts": 5
    },
    "audit": {
        "log_retention": 7,
        "log_integrity": True
    },
    "compliance": {
        "gdpr_enabled": True,
        "hipaa_enabled": True,
        "sox_enabled": True
    }
}

# 主函数
async def main():
    """主函数"""
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    # 创建安全协调器
    orchestrator = SecurityComplianceOrchestrator(SECURITY_CONFIG)
    await orchestrator.initialize_security_system()
    
    # 运行安全检查
    await orchestrator.run_security_checks()
    
    # 生成仪表板
    dashboard_file = await orchestrator.create_security_dashboard()
    print(f"安全仪表板已创建: {dashboard_file}")

if __name__ == "__main__":
    asyncio.run(main())
```

这个安全与合规系统提供了：

1. **多层安全防护** - 数据加密、访问控制、审计日志、威胁检测
2. **加密管理** - AES-256加密、密钥轮换、数据完整性验证
3. **访问控制** - 基于角色的权限管理、MFA、会话管理
4. **审计日志** - 完整的事件记录和报告生成
5. **威胁检测** - 模式识别和异常检测
6. **合规监控** - GDPR、HIPAA、SOX等合规检查
7. **安全仪表板** - 可视化的安全状态展示

系统确保了知识图谱的数据安全、访问控制和合规性。
