# çŸ¥è¯†å›¾è°±æ•°æ®è´¨é‡ç®¡ç†

## ğŸ“‘ ç›®å½•

- [çŸ¥è¯†å›¾è°±æ•°æ®è´¨é‡ç®¡ç†](#çŸ¥è¯†å›¾è°±æ•°æ®è´¨é‡ç®¡ç†)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ•°æ®è´¨é‡æ¡†æ¶](#1-æ•°æ®è´¨é‡æ¡†æ¶)
    - [1.1. è´¨é‡è¯„ä¼°ä½“ç³»](#11-è´¨é‡è¯„ä¼°ä½“ç³»)
  - [2. æ•°æ®æ¸…æ´—å’Œä¿®å¤](#2-æ•°æ®æ¸…æ´—å’Œä¿®å¤)
  - [3. æ•°æ®ç›‘æ§å’Œé¢„è­¦](#3-æ•°æ®ç›‘æ§å’Œé¢„è­¦)
  - [4. è´¨é‡æŠ¥å‘Šç”Ÿæˆ](#4-è´¨é‡æŠ¥å‘Šç”Ÿæˆ)

---


## 1. æ•°æ®è´¨é‡æ¡†æ¶

### 1.1. è´¨é‡è¯„ä¼°ä½“ç³»

```python
from typing import Dict, List, Any, Optional, Set, Tuple
from dataclasses import dataclass
from enum import Enum
import asyncio
import statistics
import re
from datetime import datetime, timedelta
import logging

class QualityDimension(Enum):
    """æ•°æ®è´¨é‡ç»´åº¦"""
    COMPLETENESS = "completeness"      # å®Œæ•´æ€§
    ACCURACY = "accuracy"              # å‡†ç¡®æ€§
    CONSISTENCY = "consistency"        # ä¸€è‡´æ€§
    VALIDITY = "validity"              # æœ‰æ•ˆæ€§
    UNIQUENESS = "uniqueness"          # å”¯ä¸€æ€§
    TIMELINESS = "timeliness"          # æ—¶æ•ˆæ€§
    RELEVANCE = "relevance"            # ç›¸å…³æ€§

@dataclass
class QualityMetric:
    """è´¨é‡æŒ‡æ ‡"""
    dimension: QualityDimension
    name: str
    value: float
    threshold: float
    status: str  # PASS, FAIL, WARNING
    details: Dict[str, Any]
    timestamp: datetime

@dataclass
class QualityRule:
    """è´¨é‡è§„åˆ™"""
    id: str
    name: str
    dimension: QualityDimension
    description: str
    query: str
    threshold: float
    severity: str  # HIGH, MEDIUM, LOW
    enabled: bool = True

class DataQualityManager:
    """æ•°æ®è´¨é‡ç®¡ç†å™¨"""

    def __init__(self, kg_client, config: Dict[str, Any]):
        self.kg_client = kg_client
        self.config = config
        self.logger = logging.getLogger(__name__)
        self.quality_rules: List[QualityRule] = []
        self.quality_history: List[QualityMetric] = []

    async def initialize(self):
        """åˆå§‹åŒ–è´¨é‡ç®¡ç†å™¨"""
        await self._load_default_rules()
        await self._load_custom_rules()

    async def _load_default_rules(self):
        """åŠ è½½é»˜è®¤è´¨é‡è§„åˆ™"""
        default_rules = [
# å®Œæ•´æ€§è§„åˆ™
            QualityRule(
                id="completeness_required_props",
                name="å¿…éœ€å±æ€§å®Œæ•´æ€§",
                dimension=QualityDimension.COMPLETENESS,
                description="æ£€æŸ¥èŠ‚ç‚¹æ˜¯å¦å…·æœ‰å¿…éœ€çš„å±æ€§",
                query="""
                MATCH (n)
                WHERE n.id IS NULL OR n.name IS NULL OR n.created_at IS NULL
                RETURN count(n) as incomplete_count
                """,
                threshold=0.0,
                severity="HIGH"
            ),

# å‡†ç¡®æ€§è§„åˆ™
            QualityRule(
                id="accuracy_email_format",
                name="é‚®ç®±æ ¼å¼å‡†ç¡®æ€§",
                dimension=QualityDimension.ACCURACY,
                description="æ£€æŸ¥é‚®ç®±åœ°å€æ ¼å¼æ˜¯å¦æ­£ç¡®",
                query="""
                MATCH (n)
                WHERE n.email IS NOT NULL
                AND NOT n.email =~ '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'
                RETURN count(n) as invalid_email_count
                """,
                threshold=0.0,
                severity="MEDIUM"
            ),

# ä¸€è‡´æ€§è§„åˆ™
            QualityRule(
                id="consistency_name_case",
                name="åç§°å¤§å°å†™ä¸€è‡´æ€§",
                dimension=QualityDimension.CONSISTENCY,
                description="æ£€æŸ¥ç›¸åŒå®ä½“çš„åç§°å¤§å°å†™æ˜¯å¦ä¸€è‡´",
                query="""
                MATCH (n)
                WITH toLower(n.name) as lower_name, collect(n.name) as names
                WHERE size(names) > 1 AND size([name IN names WHERE name <> names[0]]) > 0
                RETURN count(lower_name) as inconsistent_names
                """,
                threshold=0.0,
                severity="LOW"
            ),

# å”¯ä¸€æ€§è§„åˆ™
            QualityRule(
                id="uniqueness_duplicate_ids",
                name="IDå”¯ä¸€æ€§",
                dimension=QualityDimension.UNIQUENESS,
                description="æ£€æŸ¥æ˜¯å¦å­˜åœ¨é‡å¤çš„ID",
                query="""
                MATCH (n)
                WITH n.id as id, count(n) as node_count
                WHERE node_count > 1
                RETURN count(id) as duplicate_ids
                """,
                threshold=0.0,
                severity="HIGH"
            ),

# æœ‰æ•ˆæ€§è§„åˆ™
            QualityRule(
                id="validity_date_format",
                name="æ—¥æœŸæ ¼å¼æœ‰æ•ˆæ€§",
                dimension=QualityDimension.VALIDITY,
                description="æ£€æŸ¥æ—¥æœŸå­—æ®µæ ¼å¼æ˜¯å¦æœ‰æ•ˆ",
                query="""
                MATCH (n)
                WHERE n.created_at IS NOT NULL
                AND NOT n.created_at =~ '^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.*'
                RETURN count(n) as invalid_dates
                """,
                threshold=0.0,
                severity="MEDIUM"
            )
        ]

        self.quality_rules.extend(default_rules)

    async def _load_custom_rules(self):
        """åŠ è½½è‡ªå®šä¹‰è´¨é‡è§„åˆ™"""
        custom_rules_config = self.config.get('custom_quality_rules', [])

        for rule_config in custom_rules_config:
            rule = QualityRule(
                id=rule_config['id'],
                name=rule_config['name'],
                dimension=QualityDimension(rule_config['dimension']),
                description=rule_config['description'],
                query=rule_config['query'],
                threshold=rule_config['threshold'],
                severity=rule_config['severity'],
                enabled=rule_config.get('enabled', True)
            )
            self.quality_rules.append(rule)

    async def run_quality_assessment(self) -> Dict[str, Any]:
        """è¿è¡Œå®Œæ•´çš„è´¨é‡è¯„ä¼°"""
        self.logger.info("å¼€å§‹æ•°æ®è´¨é‡è¯„ä¼°")

        assessment_start = datetime.now()
        metrics = []

# å¹¶è¡Œæ‰§è¡Œæ‰€æœ‰å¯ç”¨çš„è´¨é‡è§„åˆ™
        enabled_rules = [rule for rule in self.quality_rules if rule.enabled]

        tasks = [self._evaluate_rule(rule) for rule in enabled_rules]
        rule_results = await asyncio.gather(*tasks, return_exceptions=True)

# å¤„ç†ç»“æœ
        for rule, result in zip(enabled_rules, rule_results):
            if isinstance(result, Exception):
                self.logger.error(f"è§„åˆ™ {rule.id} æ‰§è¡Œå¤±è´¥: {result}")
                continue

            metric = QualityMetric(
                dimension=rule.dimension,
                name=rule.name,
                value=result['value'],
                threshold=rule.threshold,
                status=result['status'],
                details=result['details'],
                timestamp=datetime.now()
            )

            metrics.append(metric)
            self.quality_history.append(metric)

# ç”Ÿæˆæ€»ä½“è´¨é‡æŠ¥å‘Š
        report = self._generate_quality_report(metrics)
        report['assessment_duration'] = (datetime.now() - assessment_start).total_seconds()

        self.logger.info(f"æ•°æ®è´¨é‡è¯„ä¼°å®Œæˆï¼Œæ€»ä½“å¾—åˆ†: {report['overall_score']:.2f}")

        return report

    async def _evaluate_rule(self, rule: QualityRule) -> Dict[str, Any]:
        """è¯„ä¼°å•ä¸ªè´¨é‡è§„åˆ™"""
        try:
            result = await self.kg_client.query(rule.query)

            if not result:
                raise ValueError(f"è§„åˆ™ {rule.id} è¿”å›ç©ºç»“æœ")

# æå–æŒ‡æ ‡å€¼
            metric_value = self._extract_metric_value(result, rule)

# åˆ¤æ–­çŠ¶æ€
            if metric_value <= rule.threshold:
                status = "PASS"
            elif metric_value <= rule.threshold * 1.1:  # 10%å®¹é”™
                status = "WARNING"
            else:
                status = "FAIL"

            return {
                'value': metric_value,
                'status': status,
                'details': {
                    'raw_result': result[0] if result else {},
                    'rule_id': rule.id,
                    'severity': rule.severity
                }
            }

        except Exception as e:
            self.logger.error(f"è§„åˆ™ {rule.id} æ‰§è¡Œå¤±è´¥: {e}")
            raise

    def _extract_metric_value(self, result: List[Dict], rule: QualityRule) -> float:
        """ä»æŸ¥è¯¢ç»“æœä¸­æå–æŒ‡æ ‡å€¼"""
        if not result:
            return 0.0

        first_result = result[0]

# å°è¯•ä»ç»“æœä¸­æ‰¾åˆ°æ•°å€¼å­—æ®µ
        for key, value in first_result.items():
            if isinstance(value, (int, float)):
                return float(value)

        return 0.0

    def _generate_quality_report(self, metrics: List[QualityMetric]) -> Dict[str, Any]:
        """ç”Ÿæˆè´¨é‡æŠ¥å‘Š"""
        if not metrics:
            return {
                'overall_score': 0.0,
                'dimension_scores': {},
                'metrics': [],
                'issues': [],
                'recommendations': []
            }

# æŒ‰ç»´åº¦åˆ†ç»„æŒ‡æ ‡
        dimension_metrics = {}
        for metric in metrics:
            if metric.dimension not in dimension_metrics:
                dimension_metrics[metric.dimension] = []
            dimension_metrics[metric.dimension].append(metric)

# è®¡ç®—å„ç»´åº¦å¾—åˆ†
        dimension_scores = {}
        for dimension, dim_metrics in dimension_metrics.items():
            passed_metrics = [m for m in dim_metrics if m.status == "PASS"]
            score = len(passed_metrics) / len(dim_metrics) * 100 if dim_metrics else 0
            dimension_scores[dimension.value] = score

# è®¡ç®—æ€»ä½“å¾—åˆ†
        overall_score = statistics.mean(dimension_scores.values()) if dimension_scores else 0

# è¯†åˆ«é—®é¢˜
        issues = [
            {
                'metric': metric.name,
                'dimension': metric.dimension.value,
                'status': metric.status,
                'value': metric.value,
                'threshold': metric.threshold,
                'severity': metric.details.get('severity', 'UNKNOWN')
            }
            for metric in metrics if metric.status in ['FAIL', 'WARNING']
        ]

# ç”Ÿæˆå»ºè®®
        recommendations = self._generate_recommendations(issues)

        return {
            'overall_score': overall_score,
            'dimension_scores': dimension_scores,
            'metrics': [
                {
                    'name': m.name,
                    'dimension': m.dimension.value,
                    'value': m.value,
                    'threshold': m.threshold,
                    'status': m.status,
                    'timestamp': m.timestamp.isoformat()
                }
                for m in metrics
            ],
            'issues': issues,
            'recommendations': recommendations
        }

    def _generate_recommendations(self, issues: List[Dict[str, Any]]) -> List[str]:
        """ç”Ÿæˆæ”¹è¿›å»ºè®®"""
        recommendations = []

# æŒ‰ä¸¥é‡ç¨‹åº¦å’Œç»´åº¦åˆ†ç»„é—®é¢˜
        high_severity_issues = [i for i in issues if i['severity'] == 'HIGH']
        completeness_issues = [i for i in issues if i['dimension'] == 'completeness']
        accuracy_issues = [i for i in issues if i['dimension'] == 'accuracy']

        if high_severity_issues:
            recommendations.append("ç«‹å³å¤„ç†é«˜ä¸¥é‡æ€§é—®é¢˜ï¼Œè¿™äº›é—®é¢˜å¯èƒ½å½±å“ç³»ç»Ÿçš„åŸºæœ¬åŠŸèƒ½")

        if completeness_issues:
            recommendations.append("å®Œå–„æ•°æ®å½•å…¥æµç¨‹ï¼Œç¡®ä¿å¿…éœ€å­—æ®µçš„å®Œæ•´æ€§")

        if accuracy_issues:
            recommendations.append("åŠ å¼ºæ•°æ®éªŒè¯æœºåˆ¶ï¼Œåœ¨æ•°æ®å½•å…¥æ—¶è¿›è¡Œæ ¼å¼æ£€æŸ¥")

        if len(issues) > 10:
            recommendations.append("è€ƒè™‘å®æ–½è‡ªåŠ¨åŒ–æ•°æ®æ¸…æ´—æµç¨‹æ¥æ‰¹é‡å¤„ç†è´¨é‡é—®é¢˜")

        return recommendations
```

## 2. æ•°æ®æ¸…æ´—å’Œä¿®å¤

```python
class DataCleaningEngine:
    """æ•°æ®æ¸…æ´—å¼•æ“"""

    def __init__(self, kg_client, quality_manager: DataQualityManager):
        self.kg_client = kg_client
        self.quality_manager = quality_manager
        self.logger = logging.getLogger(__name__)
        self.cleaning_rules: List[Dict[str, Any]] = []

    async def initialize(self):
        """åˆå§‹åŒ–æ¸…æ´—å¼•æ“"""
        await self._load_cleaning_rules()

    async def _load_cleaning_rules(self):
        """åŠ è½½æ¸…æ´—è§„åˆ™"""
        self.cleaning_rules = [
            {
                'id': 'normalize_email',
                'name': 'é‚®ç®±æ ¼å¼è§„èŒƒåŒ–',
                'description': 'å°†é‚®ç®±åœ°å€è½¬æ¢ä¸ºå°å†™',
                'condition': 'n.email IS NOT NULL',
                'action': 'SET n.email = toLower(n.email)',
                'auto_apply': True
            },
            {
                'id': 'trim_whitespace',
                'name': 'å»é™¤ç©ºç™½å­—ç¬¦',
                'description': 'å»é™¤å­—ç¬¦ä¸²å­—æ®µçš„é¦–å°¾ç©ºç™½',
                'condition': 'n.name IS NOT NULL',
                'action': 'SET n.name = trim(n.name)',
                'auto_apply': True
            },
            {
                'id': 'standardize_phone',
                'name': 'ç”µè¯å·ç æ ‡å‡†åŒ–',
                'description': 'æ ‡å‡†åŒ–ç”µè¯å·ç æ ¼å¼',
                'condition': 'n.phone IS NOT NULL',
                'action': 'SET n.phone = apoc.text.regexReplace(n.phone, "[^0-9+]", "")',
                'auto_apply': False
            },
            {
                'id': 'fix_date_format',
                'name': 'æ—¥æœŸæ ¼å¼ä¿®å¤',
                'description': 'ä¿®å¤ä¸æ ‡å‡†çš„æ—¥æœŸæ ¼å¼',
                'condition': '''n.created_at IS NOT NULL
                               AND NOT n.created_at =~ '^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.*' ''',
                'action': 'SET n.created_at = datetime(n.created_at).toString()',
                'auto_apply': False
            }
        ]

    async def run_automatic_cleaning(self) -> Dict[str, Any]:
        """è¿è¡Œè‡ªåŠ¨æ¸…æ´—"""
        self.logger.info("å¼€å§‹è‡ªåŠ¨æ•°æ®æ¸…æ´—")

        cleaning_results = []

        for rule in self.cleaning_rules:
            if not rule.get('auto_apply', False):
                continue

            try:
                result = await self._apply_cleaning_rule(rule)
                cleaning_results.append(result)

            except Exception as e:
                self.logger.error(f"æ¸…æ´—è§„åˆ™ {rule['id']} æ‰§è¡Œå¤±è´¥: {e}")
                cleaning_results.append({
                    'rule_id': rule['id'],
                    'status': 'ERROR',
                    'error': str(e),
                    'affected_count': 0
                })

        total_cleaned = sum(r['affected_count'] for r in cleaning_results)

        self.logger.info(f"è‡ªåŠ¨æ¸…æ´—å®Œæˆï¼Œå¤„ç†äº† {total_cleaned} ä¸ªèŠ‚ç‚¹")

        return {
            'total_cleaned': total_cleaned,
            'rules_applied': len([r for r in cleaning_results if r['status'] == 'SUCCESS']),
            'details': cleaning_results
        }

    async def _apply_cleaning_rule(self, rule: Dict[str, Any]) -> Dict[str, Any]:
        """åº”ç”¨æ¸…æ´—è§„åˆ™"""
# é¦–å…ˆæŸ¥è¯¢åŒ¹é…çš„èŠ‚ç‚¹æ•°é‡
        count_query = f"""
        MATCH (n)
        WHERE {rule['condition']}
        RETURN count(n) as affected_count
        """

        count_result = await self.kg_client.query(count_query)
        affected_count = count_result[0]['affected_count'] if count_result else 0

        if affected_count == 0:
            return {
                'rule_id': rule['id'],
                'status': 'NO_MATCH',
                'affected_count': 0
            }

# åº”ç”¨æ¸…æ´—æ“ä½œ
        cleaning_query = f"""
        MATCH (n)
        WHERE {rule['condition']}
        {rule['action']}
        RETURN count(n) as cleaned_count
        """

        result = await self.kg_client.query(cleaning_query)
        cleaned_count = result[0]['cleaned_count'] if result else 0

        return {
            'rule_id': rule['id'],
            'status': 'SUCCESS',
            'affected_count': cleaned_count,
            'rule_name': rule['name']
        }

    async def suggest_cleaning_actions(self, quality_report: Dict[str, Any]) -> List[Dict[str, Any]]:
        """åŸºäºè´¨é‡æŠ¥å‘Šå»ºè®®æ¸…æ´—æ“ä½œ"""
        suggestions = []

        issues = quality_report.get('issues', [])

        for issue in issues:
            if issue['dimension'] == 'accuracy' and 'email' in issue['metric'].lower():
                suggestions.append({
                    'action': 'normalize_email',
                    'description': 'è§„èŒƒåŒ–é‚®ç®±åœ°å€æ ¼å¼',
                    'priority': 'HIGH' if issue['severity'] == 'HIGH' else 'MEDIUM',
                    'estimated_impact': 'æé«˜é‚®ç®±åœ°å€å‡†ç¡®æ€§'
                })

            elif issue['dimension'] == 'consistency' and 'name' in issue['metric'].lower():
                suggestions.append({
                    'action': 'trim_whitespace',
                    'description': 'å»é™¤åç§°å­—æ®µçš„ç©ºç™½å­—ç¬¦',
                    'priority': 'MEDIUM',
                    'estimated_impact': 'æé«˜åç§°ä¸€è‡´æ€§'
                })

            elif issue['dimension'] == 'validity' and 'date' in issue['metric'].lower():
                suggestions.append({
                    'action': 'fix_date_format',
                    'description': 'ä¿®å¤æ—¥æœŸæ ¼å¼é—®é¢˜',
                    'priority': 'HIGH',
                    'estimated_impact': 'ç¡®ä¿æ—¥æœŸå­—æ®µæœ‰æ•ˆæ€§'
                })

        return suggestions
```

## 3. æ•°æ®ç›‘æ§å’Œé¢„è­¦

```python
class DataQualityMonitor:
    """æ•°æ®è´¨é‡ç›‘æ§å™¨"""

    def __init__(self, quality_manager: DataQualityManager, config: Dict[str, Any]):
        self.quality_manager = quality_manager
        self.config = config
        self.logger = logging.getLogger(__name__)
        self.alert_thresholds = config.get('alert_thresholds', {})
        self.monitoring_active = False

    async def start_monitoring(self):
        """å¯åŠ¨ç›‘æ§"""
        self.monitoring_active = True
        self.logger.info("å¯åŠ¨æ•°æ®è´¨é‡ç›‘æ§")

# åˆ›å»ºç›‘æ§ä»»åŠ¡
        asyncio.create_task(self._monitoring_loop())
        asyncio.create_task(self._trend_analysis_loop())

    async def stop_monitoring(self):
        """åœæ­¢ç›‘æ§"""
        self.monitoring_active = False
        self.logger.info("åœæ­¢æ•°æ®è´¨é‡ç›‘æ§")

    async def _monitoring_loop(self):
        """ç›‘æ§å¾ªç¯"""
        monitor_interval = self.config.get('monitor_interval', 300)  # 5åˆ†é’Ÿ

        while self.monitoring_active:
            try:
# è¿è¡Œè´¨é‡è¯„ä¼°
                quality_report = await self.quality_manager.run_quality_assessment()

# æ£€æŸ¥é¢„è­¦æ¡ä»¶
                alerts = await self._check_alerts(quality_report)

# å‘é€é¢„è­¦
                for alert in alerts:
                    await self._send_alert(alert)

# è®°å½•ç›‘æ§æ—¥å¿—
                self.logger.info(f"è´¨é‡ç›‘æ§æ£€æŸ¥å®Œæˆï¼Œæ€»ä½“å¾—åˆ†: {quality_report['overall_score']:.2f}")

            except Exception as e:
                self.logger.error(f"ç›‘æ§å¾ªç¯é”™è¯¯: {e}")

# ç­‰å¾…ä¸‹ä¸€æ¬¡æ£€æŸ¥
            await asyncio.sleep(monitor_interval)

    async def _trend_analysis_loop(self):
        """è¶‹åŠ¿åˆ†æå¾ªç¯"""
        analysis_interval = self.config.get('trend_analysis_interval', 3600)  # 1å°æ—¶

        while self.monitoring_active:
            try:
# åˆ†æè´¨é‡è¶‹åŠ¿
                trends = await self._analyze_quality_trends()

# æ£€æŸ¥å¼‚å¸¸è¶‹åŠ¿
                anomalies = await self._detect_trend_anomalies(trends)

# å‘é€è¶‹åŠ¿æŠ¥å‘Š
                if anomalies:
                    await self._send_trend_alert(anomalies)

            except Exception as e:
                self.logger.error(f"è¶‹åŠ¿åˆ†æé”™è¯¯: {e}")

            await asyncio.sleep(analysis_interval)

    async def _check_alerts(self, quality_report: Dict[str, Any]) -> List[Dict[str, Any]]:
        """æ£€æŸ¥é¢„è­¦æ¡ä»¶"""
        alerts = []

# æ£€æŸ¥æ€»ä½“å¾—åˆ†é¢„è­¦
        overall_score = quality_report['overall_score']
        if overall_score < self.alert_thresholds.get('overall_score', 70):
            alerts.append({
                'type': 'overall_quality_low',
                'severity': 'HIGH',
                'message': f'æ€»ä½“è´¨é‡å¾—åˆ†è¿‡ä½: {overall_score:.2f}',
                'value': overall_score,
                'threshold': self.alert_thresholds.get('overall_score', 70)
            })

# æ£€æŸ¥å„ç»´åº¦å¾—åˆ†é¢„è­¦
        dimension_scores = quality_report['dimension_scores']
        for dimension, score in dimension_scores.items():
            threshold = self.alert_thresholds.get(f'{dimension}_score', 80)
            if score < threshold:
                alerts.append({
                    'type': 'dimension_quality_low',
                    'severity': 'MEDIUM',
                    'message': f'{dimension}ç»´åº¦è´¨é‡å¾—åˆ†è¿‡ä½: {score:.2f}',
                    'dimension': dimension,
                    'value': score,
                    'threshold': threshold
                })

# æ£€æŸ¥é«˜ä¸¥é‡æ€§é—®é¢˜
        high_severity_issues = [
            issue for issue in quality_report['issues']
            if issue['severity'] == 'HIGH' and issue['status'] == 'FAIL'
        ]

        if len(high_severity_issues) > 0:
            alerts.append({
                'type': 'high_severity_issues',
                'severity': 'HIGH',
                'message': f'å‘ç° {len(high_severity_issues)} ä¸ªé«˜ä¸¥é‡æ€§è´¨é‡é—®é¢˜',
                'issues': high_severity_issues
            })

        return alerts

    async def _analyze_quality_trends(self) -> Dict[str, Any]:
        """åˆ†æè´¨é‡è¶‹åŠ¿"""
# è·å–æœ€è¿‘çš„è´¨é‡å†å²æ•°æ®
        recent_history = [
            metric for metric in self.quality_manager.quality_history
            if metric.timestamp > datetime.now() - timedelta(days=7)
        ]

        if len(recent_history) < 2:
            return {}

# æŒ‰ç»´åº¦åˆ†ç»„åˆ†æè¶‹åŠ¿
        trends = {}

        for dimension in QualityDimension:
            dimension_metrics = [
                m for m in recent_history
                if m.dimension == dimension and m.status in ['PASS', 'FAIL']
            ]

            if len(dimension_metrics) >= 2:
# è®¡ç®—é€šè¿‡ç‡è¶‹åŠ¿
                pass_rates = []
                time_points = []

# æŒ‰å°æ—¶åˆ†ç»„è®¡ç®—é€šè¿‡ç‡
                hourly_groups = {}
                for metric in dimension_metrics:
                    hour_key = metric.timestamp.replace(minute=0, second=0, microsecond=0)
                    if hour_key not in hourly_groups:
                        hourly_groups[hour_key] = []
                    hourly_groups[hour_key].append(metric)

                for hour, metrics in sorted(hourly_groups.items()):
                    passed = len([m for m in metrics if m.status == 'PASS'])
                    total = len(metrics)
                    pass_rate = passed / total * 100 if total > 0 else 0

                    pass_rates.append(pass_rate)
                    time_points.append(hour)

                if len(pass_rates) >= 2:
# è®¡ç®—è¶‹åŠ¿æ–œç‡
                    x_values = list(range(len(pass_rates)))
                    slope = self._calculate_trend_slope(x_values, pass_rates)

                    trends[dimension.value] = {
                        'slope': slope,
                        'current_rate': pass_rates[-1],
                        'previous_rate': pass_rates[-2] if len(pass_rates) > 1 else pass_rates[-1],
                        'data_points': len(pass_rates)
                    }

        return trends

    def _calculate_trend_slope(self, x_values: List[int], y_values: List[float]) -> float:
        """è®¡ç®—è¶‹åŠ¿æ–œç‡"""
        if len(x_values) != len(y_values) or len(x_values) < 2:
            return 0.0

        n = len(x_values)
        sum_x = sum(x_values)
        sum_y = sum(y_values)
        sum_xy = sum(x * y for x, y in zip(x_values, y_values))
        sum_x2 = sum(x * x for x in x_values)

        denominator = n * sum_x2 - sum_x * sum_x
        if denominator == 0:
            return 0.0

        slope = (n * sum_xy - sum_x * sum_y) / denominator
        return slope

    async def _detect_trend_anomalies(self, trends: Dict[str, Any]) -> List[Dict[str, Any]]:
        """æ£€æµ‹è¶‹åŠ¿å¼‚å¸¸"""
        anomalies = []

        for dimension, trend_data in trends.items():
            slope = trend_data['slope']
            current_rate = trend_data['current_rate']

# æ£€æµ‹æ€¥å‰§ä¸‹é™è¶‹åŠ¿
            if slope < -5:  # æ¯å°æ—¶ä¸‹é™è¶…è¿‡5%
                anomalies.append({
                    'type': 'declining_trend',
                    'dimension': dimension,
                    'slope': slope,
                    'current_rate': current_rate,
                    'severity': 'HIGH' if slope < -10 else 'MEDIUM'
                })

# æ£€æµ‹è´¨é‡ç‡è¿‡ä½
            if current_rate < 50:
                anomalies.append({
                    'type': 'low_quality_rate',
                    'dimension': dimension,
                    'current_rate': current_rate,
                    'severity': 'HIGH'
                })

        return anomalies

    async def _send_alert(self, alert: Dict[str, Any]):
        """å‘é€é¢„è­¦"""
# å®ç°é¢„è­¦å‘é€é€»è¾‘ï¼ˆé‚®ä»¶ã€Slackã€çŸ­ä¿¡ç­‰ï¼‰
        self.logger.warning(f"è´¨é‡é¢„è­¦: {alert['message']}")

# è¿™é‡Œå¯ä»¥é›†æˆå„ç§é€šçŸ¥æ¸ é“
# await self._send_email_alert(alert)
# await self._send_slack_alert(alert)

    async def _send_trend_alert(self, anomalies: List[Dict[str, Any]]):
        """å‘é€è¶‹åŠ¿é¢„è­¦"""
        message = f"æ£€æµ‹åˆ° {len(anomalies)} ä¸ªè´¨é‡è¶‹åŠ¿å¼‚å¸¸"
        self.logger.warning(message)

        for anomaly in anomalies:
            self.logger.warning(f"è¶‹åŠ¿å¼‚å¸¸: {anomaly}")
```

## 4. è´¨é‡æŠ¥å‘Šç”Ÿæˆ

```python
class QualityReportGenerator:
    """è´¨é‡æŠ¥å‘Šç”Ÿæˆå™¨"""

    def __init__(self, quality_manager: DataQualityManager):
        self.quality_manager = quality_manager
        self.logger = logging.getLogger(__name__)

    async def generate_comprehensive_report(self) -> str:
        """ç”Ÿæˆç»¼åˆè´¨é‡æŠ¥å‘Š"""
# è¿è¡Œå®Œæ•´è´¨é‡è¯„ä¼°
        quality_report = await self.quality_manager.run_quality_assessment()

# ç”ŸæˆHTMLæŠ¥å‘Š
        html_report = self._generate_html_report(quality_report)

# ä¿å­˜æŠ¥å‘Š
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        report_file = f"quality_report_{timestamp}.html"

        with open(report_file, 'w', encoding='utf-8') as f:
            f.write(html_report)

        self.logger.info(f"è´¨é‡æŠ¥å‘Šå·²ç”Ÿæˆ: {report_file}")
        return report_file

    def _generate_html_report(self, quality_report: Dict[str, Any]) -> str:
        """ç”ŸæˆHTMLè´¨é‡æŠ¥å‘Š"""
        overall_score = quality_report['overall_score']
        dimension_scores = quality_report['dimension_scores']
        issues = quality_report['issues']
        recommendations = quality_report['recommendations']

# ç”Ÿæˆç»´åº¦å¾—åˆ†å›¾è¡¨æ•°æ®
        chart_data = {
            'labels': list(dimension_scores.keys()),
            'scores': list(dimension_scores.values())
        }

        html_content = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>æ•°æ®è´¨é‡æŠ¥å‘Š</title>
            <meta charset="utf-8">
            <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                .header {{ background-color: #f8f9fa; padding: 20px; border-radius: 5px; }}
                .score {{ font-size: 36px; font-weight: bold; text-align: center; margin: 20px 0; }}
                .score.excellent {{ color: #28a745; }}
                .score.good {{ color: #ffc107; }}
                .score.poor {{ color: #dc3545; }}
                .section {{ margin: 30px 0; }}
                .chart-container {{ width: 400px; height: 400px; margin: 0 auto; }}
                .issues-table {{ width: 100%; border-collapse: collapse; }}
                .issues-table th, .issues-table td {{ padding: 10px; text-align: left; border-bottom: 1px solid #ddd; }}
                .issues-table th {{ background-color: #f8f9fa; }}
                .severity-high {{ color: #dc3545; font-weight: bold; }}
                .severity-medium {{ color: #ffc107; font-weight: bold; }}
                .severity-low {{ color: #6c757d; }}
                .recommendations {{ background-color: #e9ecef; padding: 15px; border-radius: 5px; }}
                .recommendations ul {{ margin: 10px 0; }}
            </style>
        </head>
        <body>
            <div class="header">
                <h1>æ•°æ®è´¨é‡æŠ¥å‘Š</h1>
                <p>ç”Ÿæˆæ—¶é—´: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
            </div>

            <div class="section">
                <h2>æ€»ä½“è´¨é‡å¾—åˆ†</h2>
                <div class="score {self._get_score_class(overall_score)}">
                    {overall_score:.1f}/100
                </div>
            </div>

            <div class="section">
                <h2>å„ç»´åº¦å¾—åˆ†</h2>
                <div class="chart-container">
                    <canvas id="dimensionChart"></canvas>
                </div>
            </div>

            <div class="section">
                <h2>è´¨é‡é—®é¢˜ ({len(issues)}ä¸ª)</h2>
                <table class="issues-table">
                    <thead>
                        <tr>
                            <th>æŒ‡æ ‡</th>
                            <th>ç»´åº¦</th>
                            <th>çŠ¶æ€</th>
                            <th>å½“å‰å€¼</th>
                            <th>é˜ˆå€¼</th>
                            <th>ä¸¥é‡æ€§</th>
                        </tr>
                    </thead>
                    <tbody>
        """

        for issue in issues:
            severity_class = f"severity-{issue['severity'].lower()}"
            html_content += f"""
                        <tr>
                            <td>{issue['metric']}</td>
                            <td>{issue['dimension']}</td>
                            <td>{issue['status']}</td>
                            <td>{issue['value']}</td>
                            <td>{issue['threshold']}</td>
                            <td class="{severity_class}">{issue['severity']}</td>
                        </tr>
            """

        html_content += """
                    </tbody>
                </table>
            </div>

            <div class="section">
                <h2>æ”¹è¿›å»ºè®®</h2>
                <div class="recommendations">
                    <ul>
        """

        for recommendation in recommendations:
            html_content += f"<li>{recommendation}</li>"

        html_content += f"""
                    </ul>
                </div>
            </div>

            <script>
                // åˆ›å»ºç»´åº¦å¾—åˆ†å›¾è¡¨
                const ctx = document.getElementById('dimensionChart').getContext('2d');
                const chart = new Chart(ctx, {{
                    type: 'radar',
                    data: {{
                        labels: {chart_data['labels']},
                        datasets: [{{
                            label: 'è´¨é‡å¾—åˆ†',
                            data: {chart_data['scores']},
                            backgroundColor: 'rgba(54, 162, 235, 0.2)',
                            borderColor: 'rgba(54, 162, 235, 1)',
                            borderWidth: 2
                        }}]
                    }},
                    options: {{
                        scales: {{
                            r: {{
                                beginAtZero: true,
                                max: 100
                            }}
                        }}
                    }}
                }});
            </script>
        </body>
        </html>
        """

        return html_content

    def _get_score_class(self, score: float) -> str:
        """è·å–å¾—åˆ†å¯¹åº”çš„CSSç±»"""
        if score >= 80:
            return "excellent"
        elif score >= 60:
            return "good"
        else:
            return "poor"
```

è¿™ä¸ªæ•°æ®è´¨é‡ç®¡ç†ç³»ç»Ÿæä¾›äº†ï¼š

1. **å…¨é¢çš„è´¨é‡è¯„ä¼°** - æ¶µç›–å®Œæ•´æ€§ã€å‡†ç¡®æ€§ã€ä¸€è‡´æ€§ç­‰å¤šä¸ªç»´åº¦
2. **è‡ªåŠ¨åŒ–æ•°æ®æ¸…æ´—** - åŸºäºè§„åˆ™çš„è‡ªåŠ¨æ•°æ®ä¿®å¤
3. **å®æ—¶ç›‘æ§é¢„è­¦** - æŒç»­ç›‘æ§è´¨é‡çŠ¶æ€å¹¶åŠæ—¶é¢„è­¦
4. **è¶‹åŠ¿åˆ†æ** - åˆ†æè´¨é‡å˜åŒ–è¶‹åŠ¿å’Œå¼‚å¸¸
5. **è¯¦ç»†çš„è´¨é‡æŠ¥å‘Š** - ç”Ÿæˆå¯è§†åŒ–çš„è´¨é‡åˆ†ææŠ¥å‘Š
6. **æ™ºèƒ½å»ºè®®** - åŸºäºè´¨é‡é—®é¢˜æä¾›æ”¹è¿›å»ºè®®

ç³»ç»Ÿç¡®ä¿äº†çŸ¥è¯†å›¾è°±æ•°æ®çš„é«˜è´¨é‡å’Œå¯é æ€§ã€‚
