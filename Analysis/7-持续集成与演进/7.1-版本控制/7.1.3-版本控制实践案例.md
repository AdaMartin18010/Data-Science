# 版本控制实践案例

## 概述

本文档提供版本控制系统的实践应用案例，涵盖Git基础操作、分支管理、协作工作流等实际场景。

## 1. Git基础操作实践

### 1.1 仓库初始化与基本操作

```python
import subprocess
import os
from datetime import datetime
from typing import List, Dict, Optional

class GitRepository:
    def __init__(self, repo_path: str):
        self.repo_path = repo_path
        self.git_dir = os.path.join(repo_path, '.git')
    
    def init_repository(self) -> bool:
        """初始化Git仓库"""
        try:
            result = subprocess.run(['git', 'init'], 
                                  cwd=self.repo_path, 
                                  capture_output=True, 
                                  text=True)
            return result.returncode == 0
        except Exception as e:
            print(f"初始化仓库失败: {e}")
            return False
    
    def add_file(self, file_path: str) -> bool:
        """添加文件到暂存区"""
        try:
            result = subprocess.run(['git', 'add', file_path], 
                                  cwd=self.repo_path, 
                                  capture_output=True, 
                                  text=True)
            return result.returncode == 0
        except Exception as e:
            print(f"添加文件失败: {e}")
            return False
    
    def commit_changes(self, message: str) -> bool:
        """提交更改"""
        try:
            result = subprocess.run(['git', 'commit', '-m', message], 
                                  cwd=self.repo_path, 
                                  capture_output=True, 
                                  text=True)
            return result.returncode == 0
        except Exception as e:
            print(f"提交失败: {e}")
            return False
    
    def get_status(self) -> Dict[str, List[str]]:
        """获取仓库状态"""
        try:
            result = subprocess.run(['git', 'status', '--porcelain'], 
                                  cwd=self.repo_path, 
                                  capture_output=True, 
                                  text=True)
            
            status = {
                'modified': [],
                'added': [],
                'deleted': [],
                'untracked': []
            }
            
            for line in result.stdout.strip().split('\n'):
                if line:
                    status_code = line[:2]
                    file_path = line[3:]
                    
                    if status_code == 'M ':
                        status['modified'].append(file_path)
                    elif status_code == 'A ':
                        status['added'].append(file_path)
                    elif status_code == 'D ':
                        status['deleted'].append(file_path)
                    elif status_code == '??':
                        status['untracked'].append(file_path)
            
            return status
        except Exception as e:
            print(f"获取状态失败: {e}")
            return {}
    
    def get_commit_history(self, max_count: int = 10) -> List[Dict]:
        """获取提交历史"""
        try:
            result = subprocess.run([
                'git', 'log', 
                f'--max-count={max_count}',
                '--pretty=format:%H|%an|%ad|%s',
                '--date=short'
            ], cwd=self.repo_path, capture_output=True, text=True)
            
            commits = []
            for line in result.stdout.strip().split('\n'):
                if line:
                    parts = line.split('|')
                    if len(parts) == 4:
                        commits.append({
                            'hash': parts[0],
                            'author': parts[1],
                            'date': parts[2],
                            'message': parts[3]
                        })
            
            return commits
        except Exception as e:
            print(f"获取提交历史失败: {e}")
            return []

# 使用示例
def create_sample_repository():
    """创建示例仓库"""
    repo_path = "sample_project"
    
    # 创建目录
    os.makedirs(repo_path, exist_ok=True)
    
    # 初始化仓库
    repo = GitRepository(repo_path)
    if repo.init_repository():
        print("仓库初始化成功")
    
    # 创建示例文件
    with open(os.path.join(repo_path, "README.md"), "w") as f:
        f.write("# 示例项目\n\n这是一个示例项目。")
    
    with open(os.path.join(repo_path, "main.py"), "w") as f:
        f.write("print('Hello, World!')\n")
    
    # 添加文件
    repo.add_file("README.md")
    repo.add_file("main.py")
    
    # 提交更改
    if repo.commit_changes("初始提交：添加README和main.py"):
        print("初始提交成功")
    
    # 查看状态
    status = repo.get_status()
    print("仓库状态:", status)
    
    # 查看提交历史
    history = repo.get_commit_history()
    print("提交历史:", history)

# 运行示例
create_sample_repository()
```

### 1.2 分支管理实践

```python
class GitBranchManager:
    def __init__(self, repo_path: str):
        self.repo_path = repo_path
    
    def create_branch(self, branch_name: str) -> bool:
        """创建新分支"""
        try:
            result = subprocess.run(['git', 'checkout', '-b', branch_name], 
                                  cwd=self.repo_path, 
                                  capture_output=True, 
                                  text=True)
            return result.returncode == 0
        except Exception as e:
            print(f"创建分支失败: {e}")
            return False
    
    def switch_branch(self, branch_name: str) -> bool:
        """切换分支"""
        try:
            result = subprocess.run(['git', 'checkout', branch_name], 
                                  cwd=self.repo_path, 
                                  capture_output=True, 
                                  text=True)
            return result.returncode == 0
        except Exception as e:
            print(f"切换分支失败: {e}")
            return False
    
    def list_branches(self) -> List[str]:
        """列出所有分支"""
        try:
            result = subprocess.run(['git', 'branch'], 
                                  cwd=self.repo_path, 
                                  capture_output=True, 
                                  text=True)
            
            branches = []
            for line in result.stdout.strip().split('\n'):
                if line.strip():
                    # 移除当前分支的*标记
                    branch_name = line.strip().lstrip('* ').strip()
                    branches.append(branch_name)
            
            return branches
        except Exception as e:
            print(f"列出分支失败: {e}")
            return []
    
    def get_current_branch(self) -> str:
        """获取当前分支名"""
        try:
            result = subprocess.run(['git', 'branch', '--show-current'], 
                                  cwd=self.repo_path, 
                                  capture_output=True, 
                                  text=True)
            return result.stdout.strip()
        except Exception as e:
            print(f"获取当前分支失败: {e}")
            return ""
    
    def merge_branch(self, source_branch: str) -> bool:
        """合并分支"""
        try:
            result = subprocess.run(['git', 'merge', source_branch], 
                                  cwd=self.repo_path, 
                                  capture_output=True, 
                                  text=True)
            return result.returncode == 0
        except Exception as e:
            print(f"合并分支失败: {e}")
            return False
    
    def delete_branch(self, branch_name: str, force: bool = False) -> bool:
        """删除分支"""
        try:
            cmd = ['git', 'branch', '-D' if force else '-d', branch_name]
            result = subprocess.run(cmd, 
                                  cwd=self.repo_path, 
                                  capture_output=True, 
                                  text=True)
            return result.returncode == 0
        except Exception as e:
            print(f"删除分支失败: {e}")
            return False

# 使用示例
def demonstrate_branch_workflow():
    """演示分支工作流"""
    repo_path = "branch_demo"
    os.makedirs(repo_path, exist_ok=True)
    
    # 初始化仓库
    repo = GitRepository(repo_path)
    repo.init_repository()
    
    # 创建初始文件
    with open(os.path.join(repo_path, "app.py"), "w") as f:
        f.write("def main():\n    print('Hello, World!')\n\nif __name__ == '__main__':\n    main()\n")
    
    repo.add_file("app.py")
    repo.commit_changes("初始提交：添加主程序")
    
    # 分支管理
    branch_manager = GitBranchManager(repo_path)
    
    # 创建功能分支
    branch_manager.create_branch("feature/user-authentication")
    print(f"当前分支: {branch_manager.get_current_branch()}")
    
    # 在功能分支上工作
    with open(os.path.join(repo_path, "auth.py"), "w") as f:
        f.write("def login(username, password):\n    return True\n\ndef logout():\n    pass\n")
    
    repo.add_file("auth.py")
    repo.commit_changes("添加用户认证功能")
    
    # 切换回主分支
    branch_manager.switch_branch("main")
    print(f"当前分支: {branch_manager.get_current_branch()}")
    
    # 列出所有分支
    branches = branch_manager.list_branches()
    print("所有分支:", branches)
    
    # 合并功能分支
    branch_manager.merge_branch("feature/user-authentication")
    
    # 删除功能分支
    branch_manager.delete_branch("feature/user-authentication")

# 运行示例
demonstrate_branch_workflow()
```

## 2. 协作工作流实践

### 2.1 远程仓库管理

```python
class GitRemoteManager:
    def __init__(self, repo_path: str):
        self.repo_path = repo_path
    
    def add_remote(self, name: str, url: str) -> bool:
        """添加远程仓库"""
        try:
            result = subprocess.run(['git', 'remote', 'add', name, url], 
                                  cwd=self.repo_path, 
                                  capture_output=True, 
                                  text=True)
            return result.returncode == 0
        except Exception as e:
            print(f"添加远程仓库失败: {e}")
            return False
    
    def list_remotes(self) -> Dict[str, str]:
        """列出远程仓库"""
        try:
            result = subprocess.run(['git', 'remote', '-v'], 
                                  cwd=self.repo_path, 
                                  capture_output=True, 
                                  text=True)
            
            remotes = {}
            for line in result.stdout.strip().split('\n'):
                if line:
                    parts = line.split()
                    if len(parts) >= 2:
                        name = parts[0]
                        url = parts[1]
                        remotes[name] = url
            
            return remotes
        except Exception as e:
            print(f"列出远程仓库失败: {e}")
            return {}
    
    def push_to_remote(self, remote: str, branch: str) -> bool:
        """推送到远程仓库"""
        try:
            result = subprocess.run(['git', 'push', remote, branch], 
                                  cwd=self.repo_path, 
                                  capture_output=True, 
                                  text=True)
            return result.returncode == 0
        except Exception as e:
            print(f"推送失败: {e}")
            return False
    
    def pull_from_remote(self, remote: str, branch: str) -> bool:
        """从远程仓库拉取"""
        try:
            result = subprocess.run(['git', 'pull', remote, branch], 
                                  cwd=self.repo_path, 
                                  capture_output=True, 
                                  text=True)
            return result.returncode == 0
        except Exception as e:
            print(f"拉取失败: {e}")
            return False
    
    def fetch_from_remote(self, remote: str) -> bool:
        """从远程仓库获取更新"""
        try:
            result = subprocess.run(['git', 'fetch', remote], 
                                  cwd=self.repo_path, 
                                  capture_output=True, 
                                  text=True)
            return result.returncode == 0
        except Exception as e:
            print(f"获取更新失败: {e}")
            return False

# 使用示例
def demonstrate_remote_workflow():
    """演示远程仓库工作流"""
    repo_path = "remote_demo"
    os.makedirs(repo_path, exist_ok=True)
    
    # 初始化仓库
    repo = GitRepository(repo_path)
    repo.init_repository()
    
    # 创建初始文件
    with open(os.path.join(repo_path, "config.py"), "w") as f:
        f.write("DEBUG = True\nDATABASE_URL = 'sqlite:///app.db'\n")
    
    repo.add_file("config.py")
    repo.commit_changes("添加配置文件")
    
    # 远程仓库管理
    remote_manager = GitRemoteManager(repo_path)
    
    # 添加远程仓库（示例URL）
    # remote_manager.add_remote("origin", "https://github.com/user/repo.git")
    
    # 列出远程仓库
    remotes = remote_manager.list_remotes()
    print("远程仓库:", remotes)
    
    # 推送更改（需要实际的远程仓库）
    # remote_manager.push_to_remote("origin", "main")
```

### 2.2 冲突解决实践

```python
class GitConflictResolver:
    def __init__(self, repo_path: str):
        self.repo_path = repo_path
    
    def create_conflict_scenario(self):
        """创建冲突场景"""
        # 创建主分支文件
        with open(os.path.join(self.repo_path, "data.py"), "w") as f:
            f.write("users = [\n    {'name': 'Alice', 'age': 25},\n    {'name': 'Bob', 'age': 30}\n]\n")
        
        repo = GitRepository(self.repo_path)
        repo.add_file("data.py")
        repo.commit_changes("添加用户数据")
        
        # 创建功能分支
        branch_manager = GitBranchManager(self.repo_path)
        branch_manager.create_branch("feature/add-users")
        
        # 在功能分支上修改
        with open(os.path.join(self.repo_path, "data.py"), "w") as f:
            f.write("users = [\n    {'name': 'Alice', 'age': 25},\n    {'name': 'Bob', 'age': 30},\n    {'name': 'Charlie', 'age': 35}\n]\n")
        
        repo.add_file("data.py")
        repo.commit_changes("添加新用户Charlie")
        
        # 切换回主分支并修改同一文件
        branch_manager.switch_branch("main")
        with open(os.path.join(self.repo_path, "data.py"), "w") as f:
            f.write("users = [\n    {'name': 'Alice', 'age': 25},\n    {'name': 'Bob', 'age': 30},\n    {'name': 'David', 'age': 28}\n]\n")
        
        repo.add_file("data.py")
        repo.commit_changes("添加新用户David")
        
        # 尝试合并（会产生冲突）
        try:
            branch_manager.merge_branch("feature/add-users")
            print("合并成功（无冲突）")
        except:
            print("检测到合并冲突")
    
    def resolve_conflict_automatically(self, file_path: str, strategy: str = "ours"):
        """自动解决冲突"""
        try:
            if strategy == "ours":
                result = subprocess.run(['git', 'checkout', '--ours', file_path], 
                                      cwd=self.repo_path, 
                                      capture_output=True, 
                                      text=True)
            elif strategy == "theirs":
                result = subprocess.run(['git', 'checkout', '--theirs', file_path], 
                                      cwd=self.repo_path, 
                                      capture_output=True, 
                                      text=True)
            
            if result.returncode == 0:
                # 标记冲突已解决
                repo = GitRepository(self.repo_path)
                repo.add_file(file_path)
                repo.commit_changes(f"解决冲突：{file_path}")
                return True
            return False
        except Exception as e:
            print(f"自动解决冲突失败: {e}")
            return False
    
    def get_conflict_files(self) -> List[str]:
        """获取冲突文件列表"""
        try:
            result = subprocess.run(['git', 'diff', '--name-only', '--diff-filter=U'], 
                                  cwd=self.repo_path, 
                                  capture_output=True, 
                                  text=True)
            
            conflict_files = []
            for line in result.stdout.strip().split('\n'):
                if line.strip():
                    conflict_files.append(line.strip())
            
            return conflict_files
        except Exception as e:
            print(f"获取冲突文件失败: {e}")
            return []

# 使用示例
def demonstrate_conflict_resolution():
    """演示冲突解决"""
    repo_path = "conflict_demo"
    os.makedirs(repo_path, exist_ok=True)
    
    # 初始化仓库
    repo = GitRepository(repo_path)
    repo.init_repository()
    
    # 创建冲突场景
    conflict_resolver = GitConflictResolver(repo_path)
    conflict_resolver.create_conflict_scenario()
    
    # 获取冲突文件
    conflict_files = conflict_resolver.get_conflict_files()
    print("冲突文件:", conflict_files)
    
    # 自动解决冲突
    for file_path in conflict_files:
        conflict_resolver.resolve_conflict_automatically(file_path, "ours")

# 运行示例
demonstrate_conflict_resolution()
```

## 3. 高级Git操作实践

### 3.1 版本回退与重置

```python
class GitVersionManager:
    def __init__(self, repo_path: str):
        self.repo_path = repo_path
    
    def reset_to_commit(self, commit_hash: str, mode: str = "soft") -> bool:
        """重置到指定提交"""
        try:
            result = subprocess.run(['git', 'reset', f'--{mode}', commit_hash], 
                                  cwd=self.repo_path, 
                                  capture_output=True, 
                                  text=True)
            return result.returncode == 0
        except Exception as e:
            print(f"重置失败: {e}")
            return False
    
    def revert_commit(self, commit_hash: str) -> bool:
        """撤销指定提交"""
        try:
            result = subprocess.run(['git', 'revert', commit_hash], 
                                  cwd=self.repo_path, 
                                  capture_output=True, 
                                  text=True)
            return result.returncode == 0
        except Exception as e:
            print(f"撤销提交失败: {e}")
            return False
    
    def stash_changes(self, message: str = "") -> bool:
        """暂存更改"""
        try:
            cmd = ['git', 'stash', 'push', '-m', message] if message else ['git', 'stash']
            result = subprocess.run(cmd, 
                                  cwd=self.repo_path, 
                                  capture_output=True, 
                                  text=True)
            return result.returncode == 0
        except Exception as e:
            print(f"暂存失败: {e}")
            return False
    
    def pop_stash(self, stash_index: int = 0) -> bool:
        """应用暂存的更改"""
        try:
            result = subprocess.run(['git', 'stash', 'pop', f'stash@{{{stash_index}}}'], 
                                  cwd=self.repo_path, 
                                  capture_output=True, 
                                  text=True)
            return result.returncode == 0
        except Exception as e:
            print(f"应用暂存失败: {e}")
            return False
    
    def list_stashes(self) -> List[Dict]:
        """列出暂存列表"""
        try:
            result = subprocess.run(['git', 'stash', 'list'], 
                                  cwd=self.repo_path, 
                                  capture_output=True, 
                                  text=True)
            
            stashes = []
            for line in result.stdout.strip().split('\n'):
                if line:
                    # 解析暂存信息
                    parts = line.split(':')
                    if len(parts) >= 2:
                        stash_ref = parts[0].strip()
                        message = parts[1].strip()
                        stashes.append({
                            'ref': stash_ref,
                            'message': message
                        })
            
            return stashes
        except Exception as e:
            print(f"列出暂存失败: {e}")
            return []

# 使用示例
def demonstrate_version_management():
    """演示版本管理"""
    repo_path = "version_demo"
    os.makedirs(repo_path, exist_ok=True)
    
    # 初始化仓库
    repo = GitRepository(repo_path)
    repo.init_repository()
    
    # 创建多个提交
    for i in range(3):
        with open(os.path.join(repo_path, f"file_{i}.txt"), "w") as f:
            f.write(f"这是文件 {i} 的内容\n")
        
        repo.add_file(f"file_{i}.txt")
        repo.commit_changes(f"添加文件 {i}")
    
    # 获取提交历史
    history = repo.get_commit_history()
    print("提交历史:", history)
    
    # 版本管理
    version_manager = GitVersionManager(repo_path)
    
    # 暂存当前更改
    version_manager.stash_changes("临时保存更改")
    
    # 列出暂存
    stashes = version_manager.list_stashes()
    print("暂存列表:", stashes)
    
    # 应用暂存
    if stashes:
        version_manager.pop_stash(0)
```

### 3.2 Git标签管理

```python
class GitTagManager:
    def __init__(self, repo_path: str):
        self.repo_path = repo_path
    
    def create_tag(self, tag_name: str, message: str = "", commit_hash: str = None) -> bool:
        """创建标签"""
        try:
            if message:
                cmd = ['git', 'tag', '-a', tag_name, '-m', message]
            else:
                cmd = ['git', 'tag', tag_name]
            
            if commit_hash:
                cmd.append(commit_hash)
            
            result = subprocess.run(cmd, 
                                  cwd=self.repo_path, 
                                  capture_output=True, 
                                  text=True)
            return result.returncode == 0
        except Exception as e:
            print(f"创建标签失败: {e}")
            return False
    
    def list_tags(self) -> List[str]:
        """列出所有标签"""
        try:
            result = subprocess.run(['git', 'tag'], 
                                  cwd=self.repo_path, 
                                  capture_output=True, 
                                  text=True)
            
            tags = []
            for line in result.stdout.strip().split('\n'):
                if line.strip():
                    tags.append(line.strip())
            
            return tags
        except Exception as e:
            print(f"列出标签失败: {e}")
            return []
    
    def delete_tag(self, tag_name: str) -> bool:
        """删除标签"""
        try:
            result = subprocess.run(['git', 'tag', '-d', tag_name], 
                                  cwd=self.repo_path, 
                                  capture_output=True, 
                                  text=True)
            return result.returncode == 0
        except Exception as e:
            print(f"删除标签失败: {e}")
            return False
    
    def checkout_tag(self, tag_name: str) -> bool:
        """检出标签"""
        try:
            result = subprocess.run(['git', 'checkout', tag_name], 
                                  cwd=self.repo_path, 
                                  capture_output=True, 
                                  text=True)
            return result.returncode == 0
        except Exception as e:
            print(f"检出标签失败: {e}")
            return False

# 使用示例
def demonstrate_tag_management():
    """演示标签管理"""
    repo_path = "tag_demo"
    os.makedirs(repo_path, exist_ok=True)
    
    # 初始化仓库
    repo = GitRepository(repo_path)
    repo.init_repository()
    
    # 创建版本文件
    with open(os.path.join(repo_path, "version.py"), "w") as f:
        f.write("VERSION = '1.0.0'\n")
    
    repo.add_file("version.py")
    repo.commit_changes("初始版本 1.0.0")
    
    # 标签管理
    tag_manager = GitTagManager(repo_path)
    
    # 创建版本标签
    tag_manager.create_tag("v1.0.0", "第一个正式版本")
    
    # 添加新功能
    with open(os.path.join(repo_path, "feature.py"), "w") as f:
        f.write("def new_feature():\n    pass\n")
    
    repo.add_file("feature.py")
    repo.commit_changes("添加新功能")
    
    # 创建新版本标签
    tag_manager.create_tag("v1.1.0", "添加新功能")
    
    # 列出所有标签
    tags = tag_manager.list_tags()
    print("所有标签:", tags)
    
    # 检出特定版本
    tag_manager.checkout_tag("v1.0.0")

# 运行示例
demonstrate_tag_management()
```

## 4. 总结

本文档提供了版本控制系统的实践案例，涵盖：

1. **Git基础操作**：仓库初始化、文件管理、提交历史
2. **分支管理**：分支创建、切换、合并、删除
3. **协作工作流**：远程仓库、冲突解决
4. **高级操作**：版本回退、暂存管理、标签管理

每个案例都包含：

- 实际操作步骤
- 错误处理机制
- 最佳实践建议
- 实际应用场景

这些实践案例展示了Git版本控制系统的核心功能，为团队协作和代码管理提供了完整的解决方案。
