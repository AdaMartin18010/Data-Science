# æµ‹è¯•ç­–ç•¥ä¸æ¡†æ¶æ·±åŒ–

## ğŸ“‘ ç›®å½•

- [æµ‹è¯•ç­–ç•¥ä¸æ¡†æ¶æ·±åŒ–](#æµ‹è¯•ç­–ç•¥ä¸æ¡†æ¶æ·±åŒ–)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æµ‹è¯•é‡‘å­—å¡”ç­–ç•¥](#1-æµ‹è¯•é‡‘å­—å¡”ç­–ç•¥)
    - [1.1. æµ‹è¯•å±‚æ¬¡ç»“æ„](#11-æµ‹è¯•å±‚æ¬¡ç»“æ„)
  - [2. æµ‹è¯•è¦†ç›–ç‡åˆ†æ](#2-æµ‹è¯•è¦†ç›–ç‡åˆ†æ)
  - [3. æµ‹è¯•ç±»å‹æ·±åŒ–](#3-æµ‹è¯•ç±»å‹æ·±åŒ–)
    - [3.1. å•å…ƒæµ‹è¯•æ¡†æ¶](#31-å•å…ƒæµ‹è¯•æ¡†æ¶)
  - [4. é›†æˆæµ‹è¯•æ¡†æ¶](#4-é›†æˆæµ‹è¯•æ¡†æ¶)
  - [5. ç«¯åˆ°ç«¯æµ‹è¯•æ¡†æ¶](#5-ç«¯åˆ°ç«¯æµ‹è¯•æ¡†æ¶)
  - [6. æµ‹è¯•æ•°æ®ç®¡ç†](#6-æµ‹è¯•æ•°æ®ç®¡ç†)
    - [6.1. æµ‹è¯•æ•°æ®ç”Ÿæˆå™¨](#61-æµ‹è¯•æ•°æ®ç”Ÿæˆå™¨)
  - [7. æµ‹è¯•æ•°æ®æ¸…ç†](#7-æµ‹è¯•æ•°æ®æ¸…ç†)
  - [8. æ€§èƒ½æµ‹è¯•æ¡†æ¶](#8-æ€§èƒ½æµ‹è¯•æ¡†æ¶)
    - [8.1. è´Ÿè½½æµ‹è¯•](#81-è´Ÿè½½æµ‹è¯•)
  - [9. å‹åŠ›æµ‹è¯•](#9-å‹åŠ›æµ‹è¯•)
  - [10. å®‰å…¨æµ‹è¯•æ¡†æ¶](#10-å®‰å…¨æµ‹è¯•æ¡†æ¶)
    - [10.1. å®‰å…¨æ¼æ´æ‰«æ](#101-å®‰å…¨æ¼æ´æ‰«æ)
  - [11. æµ‹è¯•è‡ªåŠ¨åŒ–ä¸CI/CDé›†æˆ](#11-æµ‹è¯•è‡ªåŠ¨åŒ–ä¸cicdé›†æˆ)
    - [11.1. è‡ªåŠ¨åŒ–æµ‹è¯•æµæ°´çº¿](#111-è‡ªåŠ¨åŒ–æµ‹è¯•æµæ°´çº¿)
  - [12. æµ‹è¯•æŠ¥å‘Šä¸ç›‘æ§](#12-æµ‹è¯•æŠ¥å‘Šä¸ç›‘æ§)
    - [12.1. æµ‹è¯•æŠ¥å‘Šç”Ÿæˆå™¨](#121-æµ‹è¯•æŠ¥å‘Šç”Ÿæˆå™¨)
  - [13. å·¥å…·ä¸å¹³å°](#13-å·¥å…·ä¸å¹³å°)
    - [13.1. æµ‹è¯•æ¡†æ¶](#131-æµ‹è¯•æ¡†æ¶)
    - [13.2. æµ‹è¯•å·¥å…·](#132-æµ‹è¯•å·¥å…·)
    - [13.3. æµ‹è¯•å¹³å°](#133-æµ‹è¯•å¹³å°)
  - [14. æœ€ä½³å®è·µ](#14-æœ€ä½³å®è·µ)
    - [14.1. æµ‹è¯•ç­–ç•¥](#141-æµ‹è¯•ç­–ç•¥)
    - [14.2. æµ‹è¯•è´¨é‡](#142-æµ‹è¯•è´¨é‡)

---


## 1. æµ‹è¯•é‡‘å­—å¡”ç­–ç•¥

### 1.1. æµ‹è¯•å±‚æ¬¡ç»“æ„

```python
# æµ‹è¯•é‡‘å­—å¡”å®ç°
class TestPyramid:
    def __init__(self):
        self.unit_tests = []
        self.integration_tests = []
        self.e2e_tests = []

    def add_unit_test(self, test_case):
        """æ·»åŠ å•å…ƒæµ‹è¯•"""
        self.unit_tests.append(test_case)

    def add_integration_test(self, test_case):
        """æ·»åŠ é›†æˆæµ‹è¯•"""
        self.integration_tests.append(test_case)

    def add_e2e_test(self, test_case):
        """æ·»åŠ ç«¯åˆ°ç«¯æµ‹è¯•"""
        self.e2e_tests.append(test_case)

    def get_test_distribution(self):
        """è·å–æµ‹è¯•åˆ†å¸ƒ"""
        total_tests = len(self.unit_tests) + len(self.integration_tests) + len(self.e2e_tests)

        return {
            'unit_tests': {
                'count': len(self.unit_tests),
                'percentage': len(self.unit_tests) / total_tests * 100
            },
            'integration_tests': {
                'count': len(self.integration_tests),
                'percentage': len(self.integration_tests) / total_tests * 100
            },
            'e2e_tests': {
                'count': len(self.e2e_tests),
                'percentage': len(self.e2e_tests) / total_tests * 100
            }
        }

    def run_test_suite(self):
        """è¿è¡Œæµ‹è¯•å¥—ä»¶"""
        results = {
            'unit_tests': self.run_unit_tests(),
            'integration_tests': self.run_integration_tests(),
            'e2e_tests': self.run_e2e_tests()
        }

        return self.analyze_results(results)

    def run_unit_tests(self):
        """è¿è¡Œå•å…ƒæµ‹è¯•"""
        results = []
        for test in self.unit_tests:
            try:
                result = test.run()
                results.append({
                    'test': test.name,
                    'status': 'passed' if result else 'failed',
                    'duration': test.duration
                })
            except Exception as e:
                results.append({
                    'test': test.name,
                    'status': 'error',
                    'error': str(e)
                })

        return results

    def run_integration_tests(self):
        """è¿è¡Œé›†æˆæµ‹è¯•"""
        results = []
        for test in self.integration_tests:
            try:
                result = test.run()
                results.append({
                    'test': test.name,
                    'status': 'passed' if result else 'failed',
                    'duration': test.duration
                })
            except Exception as e:
                results.append({
                    'test': test.name,
                    'status': 'error',
                    'error': str(e)
                })

        return results

    def run_e2e_tests(self):
        """è¿è¡Œç«¯åˆ°ç«¯æµ‹è¯•"""
        results = []
        for test in self.e2e_tests:
            try:
                result = test.run()
                results.append({
                    'test': test.name,
                    'status': 'passed' if result else 'failed',
                    'duration': test.duration
                })
            except Exception as e:
                results.append({
                    'test': test.name,
                    'status': 'error',
                    'error': str(e)
                })

        return results

    def analyze_results(self, results):
        """åˆ†ææµ‹è¯•ç»“æœ"""
        total_tests = 0
        passed_tests = 0
        failed_tests = 0
        error_tests = 0

        for test_type, test_results in results.items():
            for result in test_results:
                total_tests += 1
                if result['status'] == 'passed':
                    passed_tests += 1
                elif result['status'] == 'failed':
                    failed_tests += 1
                else:
                    error_tests += 1

        return {
            'total_tests': total_tests,
            'passed_tests': passed_tests,
            'failed_tests': failed_tests,
            'error_tests': error_tests,
            'success_rate': passed_tests / total_tests * 100 if total_tests > 0 else 0,
            'detailed_results': results
        }
```

## 2. æµ‹è¯•è¦†ç›–ç‡åˆ†æ

```python
# æµ‹è¯•è¦†ç›–ç‡åˆ†æ
import coverage
import os

class CoverageAnalyzer:
    def __init__(self):
        self.cov = coverage.Coverage()
        self.coverage_data = {}

    def start_coverage(self):
        """å¼€å§‹è¦†ç›–ç‡æ”¶é›†"""
        self.cov.start()

    def stop_coverage(self):
        """åœæ­¢è¦†ç›–ç‡æ”¶é›†"""
        self.cov.stop()
        self.cov.save()

    def analyze_coverage(self, source_dir):
        """åˆ†æä»£ç è¦†ç›–ç‡"""
        self.cov.load()

# è·å–è¦†ç›–ç‡æ•°æ®
        coverage_data = self.cov.get_data()

# åˆ†ææ¯ä¸ªæ–‡ä»¶çš„è¦†ç›–ç‡
        for filename in coverage_data.measured_files():
            if filename.startswith(source_dir):
                relative_path = os.path.relpath(filename, source_dir)

# è·å–è¡Œè¦†ç›–ç‡
                lines = coverage_data.get_file_coverage(filename)
                total_lines = len(lines)
                covered_lines = sum(1 for line in lines if line > 0)

                self.coverage_data[relative_path] = {
                    'total_lines': total_lines,
                    'covered_lines': covered_lines,
                    'coverage_percentage': (covered_lines / total_lines * 100) if total_lines > 0 else 0
                }

        return self.coverage_data

    def generate_coverage_report(self):
        """ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š"""
        total_files = len(self.coverage_data)
        total_lines = sum(data['total_lines'] for data in self.coverage_data.values())
        total_covered = sum(data['covered_lines'] for data in self.coverage_data.values())

        overall_coverage = (total_covered / total_lines * 100) if total_lines > 0 else 0

        report = {
            'overall_coverage': overall_coverage,
            'total_files': total_files,
            'total_lines': total_lines,
            'total_covered': total_covered,
            'file_coverage': self.coverage_data
        }

        return report

    def find_low_coverage_files(self, threshold=80):
        """æŸ¥æ‰¾ä½è¦†ç›–ç‡æ–‡ä»¶"""
        low_coverage_files = []

        for file_path, data in self.coverage_data.items():
            if data['coverage_percentage'] < threshold:
                low_coverage_files.append({
                    'file': file_path,
                    'coverage': data['coverage_percentage'],
                    'covered_lines': data['covered_lines'],
                    'total_lines': data['total_lines']
                })

        return sorted(low_coverage_files, key=lambda x: x['coverage'])
```

## 3. æµ‹è¯•ç±»å‹æ·±åŒ–

### 3.1. å•å…ƒæµ‹è¯•æ¡†æ¶

```python
# å•å…ƒæµ‹è¯•æ¡†æ¶
import unittest
from unittest.mock import Mock, patch, MagicMock

class UnitTestFramework:
    def __init__(self):
        self.test_cases = []
        self.mocks = {}

    def create_test_case(self, test_name, test_function):
        """åˆ›å»ºæµ‹è¯•ç”¨ä¾‹"""
        test_case = {
            'name': test_name,
            'function': test_function,
            'mocks': [],
            'assertions': []
        }

        self.test_cases.append(test_case)
        return test_case

    def add_mock(self, test_case, target, mock_object):
        """æ·»åŠ æ¨¡æ‹Ÿå¯¹è±¡"""
        test_case['mocks'].append({
            'target': target,
            'mock': mock_object
        })

    def add_assertion(self, test_case, assertion_function):
        """æ·»åŠ æ–­è¨€"""
        test_case['assertions'].append(assertion_function)

    def run_test_case(self, test_case):
        """è¿è¡Œæµ‹è¯•ç”¨ä¾‹"""
        try:
# è®¾ç½®æ¨¡æ‹Ÿå¯¹è±¡
            with patch.multiple(*[mock['target'] for mock in test_case['mocks']]):
# è¿è¡Œæµ‹è¯•å‡½æ•°
                result = test_case['function']()

# æ‰§è¡Œæ–­è¨€
                for assertion in test_case['assertions']:
                    assertion(result)

                return {
                    'status': 'passed',
                    'test_name': test_case['name'],
                    'result': result
                }

        except Exception as e:
            return {
                'status': 'failed',
                'test_name': test_case['name'],
                'error': str(e)
            }

    def run_all_tests(self):
        """è¿è¡Œæ‰€æœ‰æµ‹è¯•"""
        results = []

        for test_case in self.test_cases:
            result = self.run_test_case(test_case)
            results.append(result)

        return results

# ä½¿ç”¨ç¤ºä¾‹
def test_user_authentication():
    """ç”¨æˆ·è®¤è¯æµ‹è¯•"""
    framework = UnitTestFramework()

# åˆ›å»ºæµ‹è¯•ç”¨ä¾‹
    test_case = framework.create_test_case(
        'test_user_login_success',
        lambda: authenticate_user('user@example.com', 'password123')
    )

# æ·»åŠ æ¨¡æ‹Ÿ
    mock_user_service = Mock()
    mock_user_service.authenticate.return_value = {'user_id': 1, 'status': 'success'}

    framework.add_mock(test_case, 'user_service', mock_user_service)

# æ·»åŠ æ–­è¨€
    framework.add_assertion(test_case, lambda result: result['status'] == 'success')
    framework.add_assertion(test_case, lambda result: 'user_id' in result)

    return framework.run_test_case(test_case)
```

## 4. é›†æˆæµ‹è¯•æ¡†æ¶

```python
# é›†æˆæµ‹è¯•æ¡†æ¶
import requests
import json
from datetime import datetime

class IntegrationTestFramework:
    def __init__(self, base_url):
        self.base_url = base_url
        self.test_data = {}
        self.test_results = []

    def setup_test_data(self, test_name, data):
        """è®¾ç½®æµ‹è¯•æ•°æ®"""
        self.test_data[test_name] = data

    def create_api_test(self, test_name, method, endpoint, data=None, headers=None):
        """åˆ›å»ºAPIæµ‹è¯•"""
        test = {
            'name': test_name,
            'method': method,
            'endpoint': endpoint,
            'data': data,
            'headers': headers or {},
            'expected_status': 200,
            'expected_response': None,
            'validation_rules': []
        }

        return test

    def add_validation_rule(self, test, rule_function):
        """æ·»åŠ éªŒè¯è§„åˆ™"""
        test['validation_rules'].append(rule_function)

    def run_api_test(self, test):
        """è¿è¡ŒAPIæµ‹è¯•"""
        url = f"{self.base_url}{test['endpoint']}"

        try:
            if test['method'].upper() == 'GET':
                response = requests.get(url, headers=test['headers'])
            elif test['method'].upper() == 'POST':
                response = requests.post(url, json=test['data'], headers=test['headers'])
            elif test['method'].upper() == 'PUT':
                response = requests.put(url, json=test['data'], headers=test['headers'])
            elif test['method'].upper() == 'DELETE':
                response = requests.delete(url, headers=test['headers'])

# éªŒè¯çŠ¶æ€ç 
            if response.status_code != test['expected_status']:
                return {
                    'status': 'failed',
                    'test_name': test['name'],
                    'error': f"Expected status {test['expected_status']}, got {response.status_code}"
                }

# éªŒè¯å“åº”
            response_data = response.json() if response.headers.get('content-type', '').startswith('application/json') else response.text

# æ‰§è¡ŒéªŒè¯è§„åˆ™
            for rule in test['validation_rules']:
                if not rule(response_data):
                    return {
                        'status': 'failed',
                        'test_name': test['name'],
                        'error': f"Validation rule failed for {test['name']}"
                    }

            return {
                'status': 'passed',
                'test_name': test['name'],
                'response': response_data,
                'duration': response.elapsed.total_seconds()
            }

        except Exception as e:
            return {
                'status': 'error',
                'test_name': test['name'],
                'error': str(e)
            }

    def run_integration_suite(self, tests):
        """è¿è¡Œé›†æˆæµ‹è¯•å¥—ä»¶"""
        results = []

        for test in tests:
            result = self.run_api_test(test)
            results.append(result)

# è®°å½•ç»“æœ
            self.test_results.append({
                'timestamp': datetime.now(),
                'result': result
            })

        return results

# ä½¿ç”¨ç¤ºä¾‹
def test_user_api_integration():
    """ç”¨æˆ·APIé›†æˆæµ‹è¯•"""
    framework = IntegrationTestFramework('http://localhost:3000/api')

# åˆ›å»ºç”¨æˆ·æµ‹è¯•
    create_user_test = framework.create_api_test(
        'test_create_user',
        'POST',
        '/users',
        data={'name': 'John Doe', 'email': 'john@example.com'}
    )

# æ·»åŠ éªŒè¯è§„åˆ™
    framework.add_validation_rule(create_user_test, lambda response: 'id' in response)
    framework.add_validation_rule(create_user_test, lambda response: response['name'] == 'John Doe')

# è·å–ç”¨æˆ·æµ‹è¯•
    get_user_test = framework.create_api_test(
        'test_get_user',
        'GET',
        '/users/1'
    )

    framework.add_validation_rule(get_user_test, lambda response: 'id' in response)

# è¿è¡Œæµ‹è¯•
    tests = [create_user_test, get_user_test]
    return framework.run_integration_suite(tests)
```

## 5. ç«¯åˆ°ç«¯æµ‹è¯•æ¡†æ¶

```python
# ç«¯åˆ°ç«¯æµ‹è¯•æ¡†æ¶
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import time

class E2ETestFramework:
    def __init__(self, browser_type='chrome'):
        self.browser_type = browser_type
        self.driver = None
        self.test_results = []

    def setup_driver(self):
        """è®¾ç½®æµè§ˆå™¨é©±åŠ¨"""
        if self.browser_type == 'chrome':
            self.driver = webdriver.Chrome()
        elif self.browser_type == 'firefox':
            self.driver = webdriver.Firefox()
        elif self.browser_type == 'safari':
            self.driver = webdriver.Safari()

        self.driver.implicitly_wait(10)
        self.driver.maximize_window()

    def teardown_driver(self):
        """æ¸…ç†æµè§ˆå™¨é©±åŠ¨"""
        if self.driver:
            self.driver.quit()

    def create_e2e_test(self, test_name, steps):
        """åˆ›å»ºç«¯åˆ°ç«¯æµ‹è¯•"""
        test = {
            'name': test_name,
            'steps': steps,
            'screenshots': [],
            'logs': []
        }

        return test

    def add_step(self, test, action, selector, value=None, wait_time=5):
        """æ·»åŠ æµ‹è¯•æ­¥éª¤"""
        step = {
            'action': action,
            'selector': selector,
            'value': value,
            'wait_time': wait_time
        }

        test['steps'].append(step)

    def execute_step(self, step):
        """æ‰§è¡Œæµ‹è¯•æ­¥éª¤"""
        try:
            element = WebDriverWait(self.driver, step['wait_time']).until(
                EC.presence_of_element_located((By.CSS_SELECTOR, step['selector']))
            )

            if step['action'] == 'click':
                element.click()
            elif step['action'] == 'type':
                element.clear()
                element.send_keys(step['value'])
            elif step['action'] == 'select':
                from selenium.webdriver.support.ui import Select
                select = Select(element)
                select.select_by_visible_text(step['value'])
            elif step['action'] == 'verify':
                assert step['value'] in element.text
            elif step['action'] == 'wait':
                time.sleep(step['value'])

            return True

        except Exception as e:
            return False

    def run_e2e_test(self, test):
        """è¿è¡Œç«¯åˆ°ç«¯æµ‹è¯•"""
        try:
            self.setup_driver()

            for i, step in enumerate(test['steps']):
# æ‰§è¡Œæ­¥éª¤
                success = self.execute_step(step)

                if not success:
# æˆªå›¾
                    screenshot_path = f"screenshots/{test['name']}_step_{i}.png"
                    self.driver.save_screenshot(screenshot_path)
                    test['screenshots'].append(screenshot_path)

                    return {
                        'status': 'failed',
                        'test_name': test['name'],
                        'failed_step': i,
                        'step': step,
                        'screenshots': test['screenshots']
                    }

# è®°å½•æ—¥å¿—
                test['logs'].append({
                    'step': i,
                    'action': step['action'],
                    'timestamp': time.time()
                })

            return {
                'status': 'passed',
                'test_name': test['name'],
                'logs': test['logs']
            }

        except Exception as e:
            return {
                'status': 'error',
                'test_name': test['name'],
                'error': str(e)
            }

        finally:
            self.teardown_driver()

    def run_e2e_suite(self, tests):
        """è¿è¡Œç«¯åˆ°ç«¯æµ‹è¯•å¥—ä»¶"""
        results = []

        for test in tests:
            result = self.run_e2e_test(test)
            results.append(result)

            self.test_results.append({
                'timestamp': time.time(),
                'result': result
            })

        return results

# ä½¿ç”¨ç¤ºä¾‹
def test_user_registration_e2e():
    """ç”¨æˆ·æ³¨å†Œç«¯åˆ°ç«¯æµ‹è¯•"""
    framework = E2ETestFramework('chrome')

# åˆ›å»ºæµ‹è¯•
    test = framework.create_e2e_test('test_user_registration', [])

# æ·»åŠ æ­¥éª¤
    framework.add_step(test, 'type', '#name', 'John Doe')
    framework.add_step(test, 'type', '#email', 'john@example.com')
    framework.add_step(test, 'type', '#password', 'password123')
    framework.add_step(test, 'click', '#register-btn')
    framework.add_step(test, 'wait', '', 3)
    framework.add_step(test, 'verify', '.success-message', 'Registration successful')

# è¿è¡Œæµ‹è¯•
    return framework.run_e2e_test(test)
```

## 6. æµ‹è¯•æ•°æ®ç®¡ç†

### 6.1. æµ‹è¯•æ•°æ®ç”Ÿæˆå™¨

```python
# æµ‹è¯•æ•°æ®ç”Ÿæˆå™¨
import random
import string
from faker import Faker
import json

class TestDataGenerator:
    def __init__(self):
        self.fake = Faker()
        self.generated_data = {}

    def generate_user_data(self, count=1):
        """ç”Ÿæˆç”¨æˆ·æµ‹è¯•æ•°æ®"""
        users = []

        for i in range(count):
            user = {
                'id': i + 1,
                'name': self.fake.name(),
                'email': self.fake.email(),
                'phone': self.fake.phone_number(),
                'address': self.fake.address(),
                'created_at': self.fake.date_time_this_year().isoformat()
            }
            users.append(user)

        return users

    def generate_product_data(self, count=1):
        """ç”Ÿæˆäº§å“æµ‹è¯•æ•°æ®"""
        products = []

        for i in range(count):
            product = {
                'id': i + 1,
                'name': self.fake.product_name(),
                'description': self.fake.text(),
                'price': round(random.uniform(10, 1000), 2),
                'category': random.choice(['Electronics', 'Clothing', 'Books', 'Home']),
                'stock': random.randint(0, 100)
            }
            products.append(product)

        return products

    def generate_order_data(self, count=1):
        """ç”Ÿæˆè®¢å•æµ‹è¯•æ•°æ®"""
        orders = []

        for i in range(count):
            order = {
                'id': i + 1,
                'user_id': random.randint(1, 10),
                'total_amount': round(random.uniform(50, 500), 2),
                'status': random.choice(['pending', 'confirmed', 'shipped', 'delivered']),
                'created_at': self.fake.date_time_this_year().isoformat()
            }
            orders.append(order)

        return orders

    def save_test_data(self, data, filename):
        """ä¿å­˜æµ‹è¯•æ•°æ®åˆ°æ–‡ä»¶"""
        with open(filename, 'w') as f:
            json.dump(data, f, indent=2)

    def load_test_data(self, filename):
        """ä»æ–‡ä»¶åŠ è½½æµ‹è¯•æ•°æ®"""
        with open(filename, 'r') as f:
            return json.load(f)

    def create_test_database(self):
        """åˆ›å»ºæµ‹è¯•æ•°æ®åº“"""
        test_db = {
            'users': self.generate_user_data(10),
            'products': self.generate_product_data(20),
            'orders': self.generate_order_data(15)
        }

        return test_db

# ä½¿ç”¨ç¤ºä¾‹
def setup_test_environment():
    """è®¾ç½®æµ‹è¯•ç¯å¢ƒ"""
    generator = TestDataGenerator()

# ç”Ÿæˆæµ‹è¯•æ•°æ®
    test_data = generator.create_test_database()

# ä¿å­˜åˆ°æ–‡ä»¶
    generator.save_test_data(test_data, 'test_data.json')

    return test_data
```

## 7. æµ‹è¯•æ•°æ®æ¸…ç†

```python
# æµ‹è¯•æ•°æ®æ¸…ç†å™¨
class TestDataCleaner:
    def __init__(self, database_connection):
        self.db = database_connection
        self.cleanup_queries = []

    def add_cleanup_query(self, table_name, condition=None):
        """æ·»åŠ æ¸…ç†æŸ¥è¯¢"""
        if condition:
            query = f"DELETE FROM {table_name} WHERE {condition}"
        else:
            query = f"DELETE FROM {table_name}"

        self.cleanup_queries.append(query)

    def cleanup_test_data(self):
        """æ¸…ç†æµ‹è¯•æ•°æ®"""
        for query in self.cleanup_queries:
            try:
                self.db.execute(query)
                self.db.commit()
            except Exception as e:
                print(f"Cleanup failed for query: {query}, Error: {e}")

    def reset_auto_increment(self, table_name):
        """é‡ç½®è‡ªå¢ID"""
        query = f"ALTER TABLE {table_name} AUTO_INCREMENT = 1"
        try:
            self.db.execute(query)
            self.db.commit()
        except Exception as e:
            print(f"Reset auto increment failed: {e}")

    def backup_test_data(self, table_name):
        """å¤‡ä»½æµ‹è¯•æ•°æ®"""
        backup_query = f"CREATE TABLE {table_name}_backup AS SELECT * FROM {table_name}"
        try:
            self.db.execute(backup_query)
            self.db.commit()
        except Exception as e:
            print(f"Backup failed: {e}")

    def restore_test_data(self, table_name):
        """æ¢å¤æµ‹è¯•æ•°æ®"""
        restore_query = f"INSERT INTO {table_name} SELECT * FROM {table_name}_backup"
        try:
            self.db.execute(restore_query)
            self.db.commit()
        except Exception as e:
            print(f"Restore failed: {e}")
```

## 8. æ€§èƒ½æµ‹è¯•æ¡†æ¶

### 8.1. è´Ÿè½½æµ‹è¯•

```python
# è´Ÿè½½æµ‹è¯•æ¡†æ¶
import threading
import time
import requests
from concurrent.futures import ThreadPoolExecutor
import statistics

class LoadTestFramework:
    def __init__(self, target_url):
        self.target_url = target_url
        self.results = []
        self.start_time = None
        self.end_time = None

    def create_load_test(self, concurrent_users, duration, requests_per_user):
        """åˆ›å»ºè´Ÿè½½æµ‹è¯•"""
        test_config = {
            'concurrent_users': concurrent_users,
            'duration': duration,
            'requests_per_user': requests_per_user,
            'target_url': self.target_url
        }

        return test_config

    def simulate_user(self, user_id, requests_count, endpoint):
        """æ¨¡æ‹Ÿå•ä¸ªç”¨æˆ·"""
        user_results = []

        for i in range(requests_count):
            start_time = time.time()

            try:
                response = requests.get(f"{self.target_url}{endpoint}")
                end_time = time.time()

                result = {
                    'user_id': user_id,
                    'request_id': i,
                    'status_code': response.status_code,
                    'response_time': end_time - start_time,
                    'success': response.status_code == 200
                }

                user_results.append(result)

            except Exception as e:
                end_time = time.time()
                result = {
                    'user_id': user_id,
                    'request_id': i,
                    'status_code': None,
                    'response_time': end_time - start_time,
                    'success': False,
                    'error': str(e)
                }

                user_results.append(result)

        return user_results

    def run_load_test(self, test_config):
        """è¿è¡Œè´Ÿè½½æµ‹è¯•"""
        self.start_time = time.time()
        self.results = []

        with ThreadPoolExecutor(max_workers=test_config['concurrent_users']) as executor:
            futures = []

            for user_id in range(test_config['concurrent_users']):
                future = executor.submit(
                    self.simulate_user,
                    user_id,
                    test_config['requests_per_user'],
                    '/api/test'
                )
                futures.append(future)

# æ”¶é›†ç»“æœ
            for future in futures:
                user_results = future.result()
                self.results.extend(user_results)

        self.end_time = time.time()

        return self.analyze_results()

    def analyze_results(self):
        """åˆ†ææµ‹è¯•ç»“æœ"""
        if not self.results:
            return {}

        total_requests = len(self.results)
        successful_requests = sum(1 for r in self.results if r['success'])
        failed_requests = total_requests - successful_requests

        response_times = [r['response_time'] for r in self.results]

        analysis = {
            'total_requests': total_requests,
            'successful_requests': successful_requests,
            'failed_requests': failed_requests,
            'success_rate': (successful_requests / total_requests) * 100,
            'total_duration': self.end_time - self.start_time,
            'requests_per_second': total_requests / (self.end_time - self.start_time),
            'response_time_stats': {
                'min': min(response_times),
                'max': max(response_times),
                'mean': statistics.mean(response_times),
                'median': statistics.median(response_times),
                'p95': sorted(response_times)[int(len(response_times) * 0.95)],
                'p99': sorted(response_times)[int(len(response_times) * 0.99)]
            }
        }

        return analysis

# ä½¿ç”¨ç¤ºä¾‹
def run_performance_test():
    """è¿è¡Œæ€§èƒ½æµ‹è¯•"""
    framework = LoadTestFramework('http://localhost:3000')

# åˆ›å»ºè´Ÿè½½æµ‹è¯•
    test_config = framework.create_load_test(
        concurrent_users=10,
        duration=60,
        requests_per_user=100
    )

# è¿è¡Œæµ‹è¯•
    results = framework.run_load_test(test_config)

    return results
```

## 9. å‹åŠ›æµ‹è¯•

```python
# å‹åŠ›æµ‹è¯•æ¡†æ¶
class StressTestFramework:
    def __init__(self, target_url):
        self.target_url = target_url
        self.results = []

    def run_stress_test(self, max_users, step_size, step_duration):
        """è¿è¡Œå‹åŠ›æµ‹è¯•"""
        current_users = step_size
        stress_results = []

        while current_users <= max_users:
            print(f"Testing with {current_users} concurrent users...")

# è¿è¡Œè´Ÿè½½æµ‹è¯•
            load_test = LoadTestFramework(self.target_url)
            test_config = load_test.create_load_test(
                concurrent_users=current_users,
                duration=step_duration,
                requests_per_user=50
            )

            result = load_test.run_load_test(test_config)
            result['concurrent_users'] = current_users
            stress_results.append(result)

# æ£€æŸ¥ç³»ç»Ÿæ˜¯å¦è¿˜èƒ½æ‰¿å—
            if result['success_rate'] < 95:
                print(f"System started failing at {current_users} users")
                break

            current_users += step_size

        return stress_results

    def find_breaking_point(self, max_users, step_size, step_duration):
        """æ‰¾åˆ°ç³»ç»Ÿå´©æºƒç‚¹"""
        stress_results = self.run_stress_test(max_users, step_size, step_duration)

        breaking_point = None
        for result in stress_results:
            if result['success_rate'] < 95:
                breaking_point = result['concurrent_users']
                break

        return {
            'breaking_point': breaking_point,
            'stress_results': stress_results
        }
```

## 10. å®‰å…¨æµ‹è¯•æ¡†æ¶

### 10.1. å®‰å…¨æ¼æ´æ‰«æ

```python
# å®‰å…¨æµ‹è¯•æ¡†æ¶
import requests
import re
from urllib.parse import urljoin, urlparse

class SecurityTestFramework:
    def __init__(self, target_url):
        self.target_url = target_url
        self.vulnerabilities = []

    def test_sql_injection(self, endpoints):
        """æµ‹è¯•SQLæ³¨å…¥æ¼æ´"""
        sql_payloads = [
            "' OR '1'='1",
            "'; DROP TABLE users; --",
            "' UNION SELECT * FROM users --",
            "admin'--",
            "1' OR '1'='1'--"
        ]

        for endpoint in endpoints:
            for payload in sql_payloads:
                try:
                    response = requests.post(
                        urljoin(self.target_url, endpoint),
                        data={'username': payload, 'password': 'test'}
                    )

# æ£€æŸ¥SQLé”™è¯¯ä¿¡æ¯
                    if any(error in response.text.lower() for error in [
                        'sql', 'mysql', 'oracle', 'postgresql', 'syntax error'
                    ]):
                        self.vulnerabilities.append({
                            'type': 'SQL Injection',
                            'endpoint': endpoint,
                            'payload': payload,
                            'severity': 'High'
                        })

                except Exception as e:
                    print(f"Error testing SQL injection: {e}")

    def test_xss(self, endpoints):
        """æµ‹è¯•XSSæ¼æ´"""
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "javascript:alert('XSS')",
            "<svg onload=alert('XSS')>",
            "'><script>alert('XSS')</script>"
        ]

        for endpoint in endpoints:
            for payload in xss_payloads:
                try:
                    response = requests.post(
                        urljoin(self.target_url, endpoint),
                        data={'input': payload}
                    )

# æ£€æŸ¥å“åº”ä¸­æ˜¯å¦åŒ…å«payload
                    if payload in response.text:
                        self.vulnerabilities.append({
                            'type': 'XSS',
                            'endpoint': endpoint,
                            'payload': payload,
                            'severity': 'Medium'
                        })

                except Exception as e:
                    print(f"Error testing XSS: {e}")

    def test_csrf(self, endpoints):
        """æµ‹è¯•CSRFæ¼æ´"""
        for endpoint in endpoints:
            try:
# æ£€æŸ¥æ˜¯å¦æœ‰CSRF token
                response = requests.get(urljoin(self.target_url, endpoint))

                if 'csrf' not in response.text.lower() and 'token' not in response.text.lower():
                    self.vulnerabilities.append({
                        'type': 'CSRF',
                        'endpoint': endpoint,
                        'description': 'No CSRF protection found',
                        'severity': 'Medium'
                    })

            except Exception as e:
                print(f"Error testing CSRF: {e}")

    def test_authentication_bypass(self, protected_endpoints):
        """æµ‹è¯•è®¤è¯ç»•è¿‡"""
        for endpoint in protected_endpoints:
            try:
# å°è¯•è®¿é—®å—ä¿æŠ¤çš„ç«¯ç‚¹è€Œä¸æä¾›è®¤è¯
                response = requests.get(urljoin(self.target_url, endpoint))

                if response.status_code == 200:
                    self.vulnerabilities.append({
                        'type': 'Authentication Bypass',
                        'endpoint': endpoint,
                        'description': 'Protected endpoint accessible without authentication',
                        'severity': 'High'
                    })

            except Exception as e:
                print(f"Error testing authentication bypass: {e}")

    def generate_security_report(self):
        """ç”Ÿæˆå®‰å…¨æŠ¥å‘Š"""
        report = {
            'target_url': self.target_url,
            'scan_date': time.time(),
            'total_vulnerabilities': len(self.vulnerabilities),
            'vulnerabilities_by_severity': {},
            'vulnerabilities_by_type': {},
            'detailed_vulnerabilities': self.vulnerabilities
        }

# æŒ‰ä¸¥é‡ç¨‹åº¦åˆ†ç»„
        for vuln in self.vulnerabilities:
            severity = vuln['severity']
            if severity not in report['vulnerabilities_by_severity']:
                report['vulnerabilities_by_severity'][severity] = 0
            report['vulnerabilities_by_severity'][severity] += 1

# æŒ‰ç±»å‹åˆ†ç»„
        for vuln in self.vulnerabilities:
            vuln_type = vuln['type']
            if vuln_type not in report['vulnerabilities_by_type']:
                report['vulnerabilities_by_type'][vuln_type] = 0
            report['vulnerabilities_by_type'][vuln_type] += 1

        return report

# ä½¿ç”¨ç¤ºä¾‹
def run_security_test():
    """è¿è¡Œå®‰å…¨æµ‹è¯•"""
    framework = SecurityTestFramework('http://localhost:3000')

# æµ‹è¯•SQLæ³¨å…¥
    framework.test_sql_injection(['/login', '/search', '/api/users'])

# æµ‹è¯•XSS
    framework.test_xss(['/comment', '/profile', '/api/feedback'])

# æµ‹è¯•CSRF
    framework.test_csrf(['/api/users', '/api/orders'])

# æµ‹è¯•è®¤è¯ç»•è¿‡
    framework.test_authentication_bypass(['/admin', '/api/admin/users'])

# ç”ŸæˆæŠ¥å‘Š
    return framework.generate_security_report()
```

## 11. æµ‹è¯•è‡ªåŠ¨åŒ–ä¸CI/CDé›†æˆ

### 11.1. è‡ªåŠ¨åŒ–æµ‹è¯•æµæ°´çº¿

```yaml
# .github/workflows/test-automation.yml
name: Automated Testing Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Setup Python
      uses: actions/setup-python@v3
      with:
        python-version: '3.9'
    - name: Install dependencies
      run: |
        pip install -r requirements.txt
        pip install pytest pytest-cov
    - name: Run unit tests
      run: |
        pytest tests/unit/ --cov=src --cov-report=xml
    - name: Upload coverage
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml

  integration-tests:
    runs-on: ubuntu-latest
    needs: unit-tests
    steps:
    - uses: actions/checkout@v3
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
    - name: Install dependencies
      run: npm ci
    - name: Start test database
      run: |
        docker-compose up -d test-db
    - name: Run integration tests
      run: npm run test:integration
    - name: Stop test database
      run: docker-compose down

  e2e-tests:
    runs-on: ubuntu-latest
    needs: integration-tests
    steps:
    - uses: actions/checkout@v3
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
    - name: Install dependencies
      run: npm ci
    - name: Start application
      run: npm run start:test
    - name: Run E2E tests
      run: npm run test:e2e
    - name: Upload screenshots
      uses: actions/upload-artifact@v3
      with:
        name: e2e-screenshots
        path: screenshots/

  performance-tests:
    runs-on: ubuntu-latest
    needs: e2e-tests
    steps:
    - uses: actions/checkout@v3
    - name: Setup Python
      uses: actions/setup-python@v3
      with:
        python-version: '3.9'
    - name: Install dependencies
      run: pip install -r requirements.txt
    - name: Run performance tests
      run: python tests/performance/load_test.py
    - name: Upload performance report
      uses: actions/upload-artifact@v3
      with:
        name: performance-report
        path: reports/performance/

  security-tests:
    runs-on: ubuntu-latest
    needs: performance-tests
    steps:
    - uses: actions/checkout@v3
    - name: Setup Python
      uses: actions/setup-python@v3
      with:
        python-version: '3.9'
    - name: Install dependencies
      run: pip install -r requirements.txt
    - name: Run security tests
      run: python tests/security/security_scan.py
    - name: Upload security report
      uses: actions/upload-artifact@v3
      with:
        name: security-report
        path: reports/security/
```

## 12. æµ‹è¯•æŠ¥å‘Šä¸ç›‘æ§

### 12.1. æµ‹è¯•æŠ¥å‘Šç”Ÿæˆå™¨

```python
# æµ‹è¯•æŠ¥å‘Šç”Ÿæˆå™¨
import json
import datetime
from jinja2 import Template

class TestReportGenerator:
    def __init__(self):
        self.test_results = []
        self.report_data = {}

    def add_test_result(self, test_type, result):
        """æ·»åŠ æµ‹è¯•ç»“æœ"""
        self.test_results.append({
            'type': test_type,
            'result': result,
            'timestamp': datetime.datetime.now()
        })

    def generate_html_report(self, template_path):
        """ç”ŸæˆHTMLæŠ¥å‘Š"""
        with open(template_path, 'r') as f:
            template = Template(f.read())

        report_html = template.render(
            test_results=self.test_results,
            summary=self.generate_summary(),
            charts=self.generate_charts()
        )

        return report_html

    def generate_summary(self):
        """ç”Ÿæˆæµ‹è¯•æ‘˜è¦"""
        total_tests = len(self.test_results)
        passed_tests = sum(1 for r in self.test_results if r['result']['status'] == 'passed')
        failed_tests = sum(1 for r in self.test_results if r['result']['status'] == 'failed')

        return {
            'total_tests': total_tests,
            'passed_tests': passed_tests,
            'failed_tests': failed_tests,
            'success_rate': (passed_tests / total_tests * 100) if total_tests > 0 else 0
        }

    def generate_charts(self):
        """ç”Ÿæˆå›¾è¡¨æ•°æ®"""
# æŒ‰æµ‹è¯•ç±»å‹åˆ†ç»„
        test_types = {}
        for result in self.test_results:
            test_type = result['type']
            if test_type not in test_types:
                test_types[test_type] = {'passed': 0, 'failed': 0}

            if result['result']['status'] == 'passed':
                test_types[test_type]['passed'] += 1
            else:
                test_types[test_type]['failed'] += 1

        return test_types

    def save_report(self, filename, report_content):
        """ä¿å­˜æŠ¥å‘Š"""
        with open(filename, 'w') as f:
            f.write(report_content)
```

## 13. å·¥å…·ä¸å¹³å°

### 13.1. æµ‹è¯•æ¡†æ¶

1. **Jest**ï¼šJavaScriptæµ‹è¯•æ¡†æ¶
2. **PyTest**ï¼šPythonæµ‹è¯•æ¡†æ¶
3. **JUnit**ï¼šJavaæµ‹è¯•æ¡†æ¶
4. **NUnit**ï¼š.NETæµ‹è¯•æ¡†æ¶

### 13.2. æµ‹è¯•å·¥å…·

1. **Selenium**ï¼šWebè‡ªåŠ¨åŒ–æµ‹è¯•
2. **Cypress**ï¼šç°ä»£Webæµ‹è¯•å·¥å…·
3. **Postman**ï¼šAPIæµ‹è¯•å·¥å…·
4. **JMeter**ï¼šæ€§èƒ½æµ‹è¯•å·¥å…·

### 13.3. æµ‹è¯•å¹³å°

1. **TestRail**ï¼šæµ‹è¯•ç”¨ä¾‹ç®¡ç†
2. **Zephyr**ï¼šJiraæµ‹è¯•ç®¡ç†
3. **Katalon Studio**ï¼šè‡ªåŠ¨åŒ–æµ‹è¯•å¹³å°
4. **Ranorex**ï¼šGUIæµ‹è¯•å·¥å…·

## 14. æœ€ä½³å®è·µ

### 14.1. æµ‹è¯•ç­–ç•¥

1. **æµ‹è¯•é©±åŠ¨å¼€å‘**ï¼šå…ˆå†™æµ‹è¯•ï¼Œå†å†™ä»£ç 
2. **æŒç»­æµ‹è¯•**ï¼šé›†æˆåˆ°CI/CDæµæ°´çº¿
3. **æµ‹è¯•æ•°æ®ç®¡ç†**ï¼šä½¿ç”¨æµ‹è¯•æ•°æ®å·¥å‚
4. **æµ‹è¯•ç¯å¢ƒéš”ç¦»**ï¼šç‹¬ç«‹çš„æµ‹è¯•ç¯å¢ƒ
5. **æµ‹è¯•ç›‘æ§**ï¼šå®æ—¶ç›‘æ§æµ‹è¯•ç»“æœ

### 14.2. æµ‹è¯•è´¨é‡

1. **æµ‹è¯•è¦†ç›–ç‡**ï¼šä¿æŒé«˜è¦†ç›–ç‡
2. **æµ‹è¯•å¯ç»´æŠ¤æ€§**ï¼šç¼–å†™å¯ç»´æŠ¤çš„æµ‹è¯•
3. **æµ‹è¯•æ€§èƒ½**ï¼šä¼˜åŒ–æµ‹è¯•æ‰§è¡Œæ—¶é—´
4. **æµ‹è¯•å¯é æ€§**ï¼šå‡å°‘æµ‹è¯•ä¸ç¨³å®š
5. **æµ‹è¯•æ–‡æ¡£**ï¼šå®Œå–„æµ‹è¯•æ–‡æ¡£
