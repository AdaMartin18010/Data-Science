# 部署流程实践案例

## 概述

本文档提供部署流程的实践应用案例，涵盖容器化部署、自动化部署、蓝绿部署、滚动更新等实际场景。

## 1. 容器化部署实践

### 1.1 Docker容器化部署

```python
import docker
import yaml
import os
from typing import Dict, List, Optional
import subprocess

class DockerDeploymentManager:
    def __init__(self):
        self.client = docker.from_env()
        self.containers = {}
        self.networks = {}
    
    def build_image(self, dockerfile_path: str, image_name: str, tag: str = "latest") -> bool:
        """构建Docker镜像"""
        try:
            image, logs = self.client.images.build(
                path=dockerfile_path,
                tag=f"{image_name}:{tag}",
                rm=True
            )
            print(f"镜像构建成功: {image_name}:{tag}")
            return True
        except Exception as e:
            print(f"镜像构建失败: {e}")
            return False
    
    def create_network(self, network_name: str, driver: str = "bridge") -> bool:
        """创建Docker网络"""
        try:
            network = self.client.networks.create(
                name=network_name,
                driver=driver
            )
            self.networks[network_name] = network
            print(f"网络创建成功: {network_name}")
            return True
        except Exception as e:
            print(f"网络创建失败: {e}")
            return False
    
    def deploy_container(self, image_name: str, container_name: str, 
                        ports: Dict[str, str] = None, 
                        environment: Dict[str, str] = None,
                        volumes: Dict[str, str] = None,
                        network: str = None) -> bool:
        """部署容器"""
        try:
            container = self.client.containers.run(
                image=image_name,
                name=container_name,
                ports=ports or {},
                environment=environment or {},
                volumes=volumes or {},
                network=network,
                detach=True,
                restart_policy={"Name": "unless-stopped"}
            )
            self.containers[container_name] = container
            print(f"容器部署成功: {container_name}")
            return True
        except Exception as e:
            print(f"容器部署失败: {e}")
            return False
    
    def stop_container(self, container_name: str) -> bool:
        """停止容器"""
        try:
            if container_name in self.containers:
                container = self.containers[container_name]
                container.stop()
                container.remove()
                del self.containers[container_name]
                print(f"容器停止成功: {container_name}")
                return True
            return False
        except Exception as e:
            print(f"容器停止失败: {e}")
            return False
    
    def get_container_status(self, container_name: str) -> Dict:
        """获取容器状态"""
        try:
            if container_name in self.containers:
                container = self.containers[container_name]
                container.reload()
                return {
                    'name': container_name,
                    'status': container.status,
                    'ports': container.ports,
                    'ip': container.attrs['NetworkSettings']['IPAddress']
                }
            return {}
        except Exception as e:
            print(f"获取容器状态失败: {e}")
            return {}
    
    def scale_service(self, service_name: str, replicas: int) -> bool:
        """扩展服务"""
        try:
            # 这里可以实现服务扩展逻辑
            print(f"服务 {service_name} 扩展到 {replicas} 个实例")
            return True
        except Exception as e:
            print(f"服务扩展失败: {e}")
            return False

# 使用示例
def demonstrate_docker_deployment():
    """演示Docker部署"""
    deployment_manager = DockerDeploymentManager()
    
    # 创建网络
    deployment_manager.create_network("app-network")
    
    # 构建镜像（需要实际的Dockerfile）
    # deployment_manager.build_image("./app", "myapp", "v1.0")
    
    # 部署应用容器
    deployment_manager.deploy_container(
        image_name="nginx:latest",
        container_name="web-server",
        ports={"80/tcp": "8080"},
        network="app-network"
    )
    
    # 部署数据库容器
    deployment_manager.deploy_container(
        image_name="postgres:13",
        container_name="database",
        environment={
            "POSTGRES_DB": "myapp",
            "POSTGRES_USER": "user",
            "POSTGRES_PASSWORD": "password"
        },
        volumes={"/var/lib/postgresql/data": {"bind": "/var/lib/postgresql/data", "mode": "rw"}},
        network="app-network"
    )
    
    # 检查容器状态
    web_status = deployment_manager.get_container_status("web-server")
    db_status = deployment_manager.get_container_status("database")
    print("Web服务器状态:", web_status)
    print("数据库状态:", db_status)

# 运行示例
demonstrate_docker_deployment()
```

### 1.2 Kubernetes部署实践

```python
import yaml
import subprocess
from typing import Dict, List, Optional

class KubernetesDeploymentManager:
    def __init__(self, namespace: str = "default"):
        self.namespace = namespace
        self.deployments = {}
    
    def create_namespace(self, namespace: str) -> bool:
        """创建命名空间"""
        try:
            cmd = f"kubectl create namespace {namespace}"
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            return result.returncode == 0
        except Exception as e:
            print(f"创建命名空间失败: {e}")
            return False
    
    def deploy_application(self, app_name: str, image: str, 
                          replicas: int = 1, 
                          ports: List[int] = None) -> bool:
        """部署应用"""
        try:
            deployment_yaml = {
                "apiVersion": "apps/v1",
                "kind": "Deployment",
                "metadata": {
                    "name": app_name,
                    "namespace": self.namespace
                },
                "spec": {
                    "replicas": replicas,
                    "selector": {
                        "matchLabels": {
                            "app": app_name
                        }
                    },
                    "template": {
                        "metadata": {
                            "labels": {
                                "app": app_name
                            }
                        },
                        "spec": {
                            "containers": [{
                                "name": app_name,
                                "image": image,
                                "ports": [{"containerPort": port} for port in (ports or [80])]
                            }]
                        }
                    }
                }
            }
            
            # 保存YAML文件
            yaml_file = f"{app_name}-deployment.yaml"
            with open(yaml_file, 'w') as f:
                yaml.dump(deployment_yaml, f)
            
            # 应用部署
            cmd = f"kubectl apply -f {yaml_file}"
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            
            if result.returncode == 0:
                self.deployments[app_name] = deployment_yaml
                print(f"应用部署成功: {app_name}")
                return True
            else:
                print(f"应用部署失败: {result.stderr}")
                return False
                
        except Exception as e:
            print(f"应用部署失败: {e}")
            return False
    
    def create_service(self, app_name: str, service_type: str = "ClusterIP", 
                      ports: List[Dict] = None) -> bool:
        """创建服务"""
        try:
            service_yaml = {
                "apiVersion": "v1",
                "kind": "Service",
                "metadata": {
                    "name": f"{app_name}-service",
                    "namespace": self.namespace
                },
                "spec": {
                    "type": service_type,
                    "selector": {
                        "app": app_name
                    },
                    "ports": ports or [{"port": 80, "targetPort": 80}]
                }
            }
            
            # 保存YAML文件
            yaml_file = f"{app_name}-service.yaml"
            with open(yaml_file, 'w') as f:
                yaml.dump(service_yaml, f)
            
            # 应用服务
            cmd = f"kubectl apply -f {yaml_file}"
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            
            return result.returncode == 0
            
        except Exception as e:
            print(f"服务创建失败: {e}")
            return False
    
    def scale_deployment(self, app_name: str, replicas: int) -> bool:
        """扩展部署"""
        try:
            cmd = f"kubectl scale deployment {app_name} --replicas={replicas} -n {self.namespace}"
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            return result.returncode == 0
        except Exception as e:
            print(f"扩展部署失败: {e}")
            return False
    
    def get_deployment_status(self, app_name: str) -> Dict:
        """获取部署状态"""
        try:
            cmd = f"kubectl get deployment {app_name} -n {self.namespace} -o yaml"
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            
            if result.returncode == 0:
                deployment_data = yaml.safe_load(result.stdout)
                return {
                    'name': app_name,
                    'replicas': deployment_data['spec']['replicas'],
                    'available': deployment_data['status']['availableReplicas'],
                    'ready': deployment_data['status']['readyReplicas']
                }
            return {}
        except Exception as e:
            print(f"获取部署状态失败: {e}")
            return {}

# 使用示例
def demonstrate_kubernetes_deployment():
    """演示Kubernetes部署"""
    k8s_manager = KubernetesDeploymentManager("myapp")
    
    # 创建命名空间
    k8s_manager.create_namespace("myapp")
    
    # 部署Web应用
    k8s_manager.deploy_application(
        app_name="web-app",
        image="nginx:latest",
        replicas=3,
        ports=[80]
    )
    
    # 创建服务
    k8s_manager.create_service(
        app_name="web-app",
        service_type="LoadBalancer",
        ports=[{"port": 80, "targetPort": 80}]
    )
    
    # 扩展部署
    k8s_manager.scale_deployment("web-app", 5)
    
    # 检查状态
    status = k8s_manager.get_deployment_status("web-app")
    print("部署状态:", status)

# 运行示例
demonstrate_kubernetes_deployment()
```

## 2. 自动化部署实践

### 2.1 CI/CD流水线部署

```python
import json
import requests
from typing import Dict, List, Optional
import time

class CICDPipelineManager:
    def __init__(self, jenkins_url: str, username: str, token: str):
        self.jenkins_url = jenkins_url
        self.username = username
        self.token = token
        self.session = requests.Session()
        self.session.auth = (username, token)
    
    def trigger_build(self, job_name: str, parameters: Dict = None) -> bool:
        """触发构建"""
        try:
            url = f"{self.jenkins_url}/job/{job_name}/build"
            
            if parameters:
                url += "/buildWithParameters"
                response = self.session.post(url, params=parameters)
            else:
                response = self.session.post(url)
            
            return response.status_code == 201
        except Exception as e:
            print(f"触发构建失败: {e}")
            return False
    
    def get_build_status(self, job_name: str, build_number: int) -> Dict:
        """获取构建状态"""
        try:
            url = f"{self.jenkins_url}/job/{job_name}/{build_number}/api/json"
            response = self.session.get(url)
            
            if response.status_code == 200:
                build_info = response.json()
                return {
                    'number': build_info['number'],
                    'result': build_info.get('result'),
                    'building': build_info['building'],
                    'duration': build_info.get('duration'),
                    'timestamp': build_info.get('timestamp')
                }
            return {}
        except Exception as e:
            print(f"获取构建状态失败: {e}")
            return {}
    
    def wait_for_build_completion(self, job_name: str, build_number: int, 
                                 timeout: int = 300) -> bool:
        """等待构建完成"""
        start_time = time.time()
        
        while time.time() - start_time < timeout:
            status = self.get_build_status(job_name, build_number)
            
            if not status.get('building', False):
                return status.get('result') == 'SUCCESS'
            
            time.sleep(10)
        
        return False
    
    def deploy_to_staging(self, app_name: str, version: str) -> bool:
        """部署到测试环境"""
        try:
            parameters = {
                'APP_NAME': app_name,
                'VERSION': version,
                'ENVIRONMENT': 'staging'
            }
            
            success = self.trigger_build('deploy-staging', parameters)
            if success:
                print(f"部署到测试环境成功: {app_name} v{version}")
                return True
            return False
        except Exception as e:
            print(f"部署到测试环境失败: {e}")
            return False
    
    def deploy_to_production(self, app_name: str, version: str) -> bool:
        """部署到生产环境"""
        try:
            parameters = {
                'APP_NAME': app_name,
                'VERSION': version,
                'ENVIRONMENT': 'production'
            }
            
            success = self.trigger_build('deploy-production', parameters)
            if success:
                print(f"部署到生产环境成功: {app_name} v{version}")
                return True
            return False
        except Exception as e:
            print(f"部署到生产环境失败: {e}")
            return False

# 使用示例
def demonstrate_cicd_deployment():
    """演示CI/CD部署"""
    # 初始化CI/CD管理器（需要实际的Jenkins配置）
    # cicd_manager = CICDPipelineManager(
    #     jenkins_url="http://jenkins.example.com",
    #     username="admin",
    #     token="your-token"
    # )
    
    # 部署到测试环境
    # success = cicd_manager.deploy_to_staging("myapp", "v1.0.0")
    
    # 如果测试通过，部署到生产环境
    # if success:
    #     cicd_manager.deploy_to_production("myapp", "v1.0.0")
```

### 2.2 蓝绿部署实践

```python
class BlueGreenDeploymentManager:
    def __init__(self, k8s_manager):
        self.k8s_manager = k8s_manager
        self.current_environment = "blue"  # 当前活跃环境
        self.environments = {
            "blue": {"active": True, "version": "v1.0.0"},
            "green": {"active": False, "version": "v1.0.0"}
        }
    
    def deploy_new_version(self, app_name: str, new_version: str) -> bool:
        """部署新版本到非活跃环境"""
        try:
            # 确定目标环境
            target_env = "green" if self.current_environment == "blue" else "blue"
            
            # 部署新版本到目标环境
            deployment_name = f"{app_name}-{target_env}"
            success = self.k8s_manager.deploy_application(
                app_name=deployment_name,
                image=f"{app_name}:{new_version}",
                replicas=3
            )
            
            if success:
                self.environments[target_env]["version"] = new_version
                print(f"新版本部署成功到 {target_env} 环境")
                return True
            return False
        except Exception as e:
            print(f"新版本部署失败: {e}")
            return False
    
    def switch_traffic(self, app_name: str) -> bool:
        """切换流量到新环境"""
        try:
            # 更新服务选择器指向新环境
            new_env = "green" if self.current_environment == "blue" else "blue"
            
            # 更新服务配置
            service_yaml = {
                "apiVersion": "v1",
                "kind": "Service",
                "metadata": {
                    "name": f"{app_name}-service",
                    "namespace": self.k8s_manager.namespace
                },
                "spec": {
                    "type": "LoadBalancer",
                    "selector": {
                        "app": f"{app_name}-{new_env}"
                    },
                    "ports": [{"port": 80, "targetPort": 80}]
                }
            }
            
            # 应用服务更新
            yaml_file = f"{app_name}-service-update.yaml"
            with open(yaml_file, 'w') as f:
                yaml.dump(service_yaml, f)
            
            cmd = f"kubectl apply -f {yaml_file}"
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            
            if result.returncode == 0:
                # 更新环境状态
                self.environments[self.current_environment]["active"] = False
                self.environments[new_env]["active"] = True
                self.current_environment = new_env
                
                print(f"流量切换成功到 {new_env} 环境")
                return True
            return False
        except Exception as e:
            print(f"流量切换失败: {e}")
            return False
    
    def rollback(self, app_name: str) -> bool:
        """回滚到上一个版本"""
        try:
            # 切换回上一个环境
            previous_env = "blue" if self.current_environment == "green" else "green"
            
            # 切换流量
            service_yaml = {
                "apiVersion": "v1",
                "kind": "Service",
                "metadata": {
                    "name": f"{app_name}-service",
                    "namespace": self.k8s_manager.namespace
                },
                "spec": {
                    "type": "LoadBalancer",
                    "selector": {
                        "app": f"{app_name}-{previous_env}"
                    },
                    "ports": [{"port": 80, "targetPort": 80}]
                }
            }
            
            yaml_file = f"{app_name}-service-rollback.yaml"
            with open(yaml_file, 'w') as f:
                yaml.dump(service_yaml, f)
            
            cmd = f"kubectl apply -f {yaml_file}"
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            
            if result.returncode == 0:
                self.environments[self.current_environment]["active"] = False
                self.environments[previous_env]["active"] = True
                self.current_environment = previous_env
                
                print(f"回滚成功到 {previous_env} 环境")
                return True
            return False
        except Exception as e:
            print(f"回滚失败: {e}")
            return False
    
    def get_deployment_status(self) -> Dict:
        """获取部署状态"""
        return {
            'current_environment': self.current_environment,
            'environments': self.environments
        }

# 使用示例
def demonstrate_blue_green_deployment():
    """演示蓝绿部署"""
    k8s_manager = KubernetesDeploymentManager("myapp")
    bg_manager = BlueGreenDeploymentManager(k8s_manager)
    
    # 部署新版本
    success = bg_manager.deploy_new_version("web-app", "v1.1.0")
    
    if success:
        # 等待新版本就绪
        time.sleep(30)
        
        # 切换流量
        bg_manager.switch_traffic("web-app")
        
        # 检查状态
        status = bg_manager.get_deployment_status()
        print("部署状态:", status)
```

## 3. 监控与健康检查

### 3.1 应用健康检查

```python
import requests
import time
from typing import Dict, List

class HealthCheckManager:
    def __init__(self):
        self.health_endpoints = {}
        self.check_results = {}
    
    def add_health_endpoint(self, service_name: str, endpoint: str, 
                           expected_status: int = 200) -> None:
        """添加健康检查端点"""
        self.health_endpoints[service_name] = {
            'endpoint': endpoint,
            'expected_status': expected_status
        }
    
    def check_service_health(self, service_name: str) -> Dict:
        """检查服务健康状态"""
        try:
            if service_name not in self.health_endpoints:
                return {'status': 'unknown', 'error': 'Service not found'}
            
            endpoint_info = self.health_endpoints[service_name]
            response = requests.get(endpoint_info['endpoint'], timeout=10)
            
            is_healthy = response.status_code == endpoint_info['expected_status']
            
            result = {
                'service': service_name,
                'status': 'healthy' if is_healthy else 'unhealthy',
                'status_code': response.status_code,
                'response_time': response.elapsed.total_seconds(),
                'timestamp': time.time()
            }
            
            self.check_results[service_name] = result
            return result
        except Exception as e:
            result = {
                'service': service_name,
                'status': 'error',
                'error': str(e),
                'timestamp': time.time()
            }
            self.check_results[service_name] = result
            return result
    
    def check_all_services(self) -> List[Dict]:
        """检查所有服务健康状态"""
        results = []
        for service_name in self.health_endpoints:
            result = self.check_service_health(service_name)
            results.append(result)
        return results
    
    def get_service_status_summary(self) -> Dict:
        """获取服务状态摘要"""
        healthy_count = 0
        unhealthy_count = 0
        error_count = 0
        
        for result in self.check_results.values():
            if result['status'] == 'healthy':
                healthy_count += 1
            elif result['status'] == 'unhealthy':
                unhealthy_count += 1
            else:
                error_count += 1
        
        return {
            'total_services': len(self.check_results),
            'healthy': healthy_count,
            'unhealthy': unhealthy_count,
            'errors': error_count,
            'health_percentage': (healthy_count / len(self.check_results) * 100) if self.check_results else 0
        }

# 使用示例
def demonstrate_health_check():
    """演示健康检查"""
    health_manager = HealthCheckManager()
    
    # 添加健康检查端点
    health_manager.add_health_endpoint("web-app", "http://localhost:8080/health")
    health_manager.add_health_endpoint("api-service", "http://localhost:8081/health")
    health_manager.add_health_endpoint("database", "http://localhost:5432/health")
    
    # 检查所有服务
    results = health_manager.check_all_services()
    print("健康检查结果:", results)
    
    # 获取状态摘要
    summary = health_manager.get_service_status_summary()
    print("服务状态摘要:", summary)
```

## 4. 总结

本文档提供了部署流程的实践案例，涵盖：

1. **容器化部署**：Docker容器化、Kubernetes部署
2. **自动化部署**：CI/CD流水线、蓝绿部署
3. **监控与健康检查**：应用健康检查、状态监控

每个案例都包含：

- 部署流程设计
- 自动化脚本实现
- 错误处理机制
- 实际应用场景

这些实践案例展示了现代部署流程的核心技术，为构建可靠、高效的部署系统提供了参考。
